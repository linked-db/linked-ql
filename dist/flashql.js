(()=>{var si=Object.defineProperty;var Ie=(c,e)=>{for(var t in e)si(c,t,{get:e[t],enumerable:!0})};function ne(c){return!Array.isArray(c)&&typeof c=="object"&&c}function pt(c){return typeof c}function be(c){return Array.isArray(c)}function mt(c){return typeof c=="function"}function ia(c){return c===null||c===""}function rt(c){return arguments.length&&(c===void 0||typeof c>"u")}function _e(c){return Array.isArray(c)||typeof c=="object"&&c||mt(c)}function oa(c){return ia(c)||rt(c)||c===!1||c===0||_e(c)&&!Object.keys(c).length}function je(c){return mt(c)||c&&{}.toString.call(c)==="[object function]"}function Xt(c){return c instanceof String||typeof c=="string"&&c!==null}function la(c){return!Xt(c)&&!rt(c.length)}function er(c,...e){if(!c||!["object","function"].includes(typeof c))throw new Error("Argument #1 must be of type object");let t=c[Symbol.for("wq")];if(t||(t=new Zt,Object.defineProperty(c,Symbol.for("wq"),{value:t,enumerable:!1,configurable:!1,writable:!1})),!e.length)return t;let s,r;for(;s=e.shift();)(r=t)&&!(t=t.get(s))&&(t=new Zt,r.set(s,t));return t}var Zt=class extends Map{};function z(c,e,t=!1,s=null){if(Array.isArray(c)&&Array.isArray(e))return c.length===e.length&&(e=e.slice(0).sort())&&c.slice(0).sort().every((r,n)=>z(r,e[n],t,s));if(typeof c?.jsonfy=="function"&&(c=c.jsonfy()),typeof e?.jsonfy=="function"&&(e=e.jsonfy()),ne(c)&&ne(e)){let r={indexs_a:Object.keys(c),indexs_b:Object.keys(e)};if(s?.length){let n=[].concat(s);r.indexs_a=r.indexs_a.filter(a=>!n.includes(a)),r.indexs_b=r.indexs_b.filter(a=>!n.includes(a))}return r.indexs_a.length===r.indexs_b.length&&r.indexs_a.reduce((n,a)=>n&&z(c[a],e[a],t,s),!0)}return typeof c=="string"&&typeof e=="string"&&t===!1?c.toLowerCase()===e.toLowerCase():c===e}function Fa(c){let e=c.replace(/([a-z0-9])([A-Z])/g,"$1_$2");return e=e.replace(/([A-Z])([A-Z][a-z])/g,"$1_$2"),e.toUpperCase()}var ca={};Ie(ca,{TOK_TYPES:()=>Pt,aggrFunctionNames:()=>mi,dataTypes:()=>yi,functionNames:()=>pi,keywords:()=>fi,operators:()=>tr,statements:()=>ci});var Pt={data_type:{type:"data_type",value:void 0,resolve(){return this}},identifier:{type:"identifier",value:void 0,delim:[void 0],resolve({dialect:c,mysqlAnsiQuotes:e}={}){return{...this,delim:this.delim.concat(c==="mysql"?e?['"',"`"]:["`"]:['"'])}}},keyword:{type:"keyword",value:void 0,resolve(){return this}},operator:{type:"operator",value:void 0,prec:void 0,assoc:void 0,resultType:void 0,resolve(){return this}},punctuation:{type:"punctuation",value:void 0,resolve(){return this}},string_literal:{type:"string_literal",value:void 0,delim:["'"],modifier:[void 0],resolve({dialect:c,mysqlAnsiQuotes:e}={}){return{...this,delim:this.delim.concat(c==="mysql"?e?[]:['"']:[/^(\$\$|\$[a-zA-Z_][a-zA-Z0-9_]*\$)$/]),modifier:this.modifier.concat(c==="mysql"?["N"]:["E"])}}},number_literal:{type:"number_literal",value:void 0,match({value:c}){return!!/^[+-]?(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?$/.test(c)}},null_literal:{type:"null_literal",value:void 0,resolve(){return this}},unknown_literal:{type:"unknown_literal",value:void 0,resolve(){return this}},bool_literal:{type:"bool_literal",value:void 0,resolve(){return this}},hex_literal:{type:"hex_literal",value:void 0,resolve(){return this}},bit_literal:{type:"bit_literal",value:void 0,resolve(){return this}},bind_var:{type:"bind_var",value:void 0,delim:[],resolve({dialect:c}={}){return{...this,delim:this.delim.concat(c==="mysql"?["?"]:["$"])}}},version_spec:{type:"version_spec",value:void 0,delim:[void 0,"'"],resolve(){return this}},user_var:{type:"user_var",value:void 0,delim:[void 0],resolve({dialect:c}={}){return{...this,delim:this.delim.concat(c==="mysql"?["'"]:[])}}},system_var:{type:"system_var",value:void 0,resolve(){return this}},brace_block:{type:"brace_block",value:void 0,resolve(){return this}},bracket_block:{type:"bracket_block",value:void 0,resolve(){return this}},parent_block:{type:"paren_block",value:void 0,resolve(){return this}},block_comment:{type:"block_comment",value:void 0,resolve(){return this}},line_comment:{type:"line_comment",value:void 0,delim:["--"],resolve({dialect:c}={}){return{...this,delim:this.delim.concat(c==="mysql"?["#"]:[])}}}},ci={common:["ALTER","CREATE","DROP","SELECT","INSERT","UPSERT","UPDATE","MERGE","DELETE","BEGIN","COMMIT","ROLLBACK","RELEASE","DESCRIBE","EXPLAIN","USE"],postgres:["ANALYZE","CLUSTER","COMMENT ON","REFRESH","REINDEX","VACUUM"],mysql:["ANALYZE","FLUSH","LOCK","OPTIMIZE","RENAME","REPAIR","RESET","SET","SHOW","TRUNCATE","UNLOCK"]},fi={common:["ALL","ON","NO","KEY","ANY","AS","BY","ASC","CASE","CAST","DEFAULT","DESC","DO","DISTINCT","ELSE","END","ESCAPE","EXISTS","FIRST","LAST","FOLLOWING","FOR","HAVING","FILTER","SHARE","UNIQUE","JOIN","SEPARATOR","SKIP","LOCKED","NOWAIT","OF","RECURSIVE","LIMIT","LOAD","NEXT","NOTHING","NULLS","OFFSET","ONLY","TIES","OVER","PARTITION","PRECEDING","RANGE","RETURNING","ROW","ROWS","INCLUDE","EXCLUDE","SET","SOME","THEN","USING","MATERIALIZED","MODE","TEMPORARY","MATCH","PARTIAL","SIMPLE","WITHIN","BOTH","CHECK","PRIMARY","FOREIGN","CONSTRAINT","REFERENCES","INHERITS","DATABASE","TABLE","COLUMN","INDEX","SEQUENCE","TRIGGER","VIEW","SAVEPOINT","VALUES","WHEN","WHERE","WINDOW","WITH","WITHOUT","TO","TABLESPACE","INTO","FROM","GROUP","ORDER","PARTITION","BREADTH","DEPTH","GENERATED","ALWAYS","INNER","LEFT","RIGHT","OUTER","FULL","CROSS","NATURAL","NO OTHERS","NO INHERIT","ROLLUP","UNBOUNDED","CURRENT ROW","GROUPS","IGNORE","RESPECT","CHARACTER SET","NO ACTION","SET NULL","SET DEFAULT","RESTRICT","CASCADE","STORED","GIST","SCHEMA"],postgres:["ARRAY","GROUPING SETS","CUBE","TABLESAMPLE","REPEATABLE","SEARCH","LATERAL","ORDINALITY","OVERLAPS","SIMILAR","BERNOULLI","SYSTEM","UNLOGGED","PERFORM","CURRENT OF","TYPE","EXTENSION","IMMUTABLE","STABLE","VOLATILE","CYCLE","CONFLICT","TEMP","TIME ZONE","FETCH","LOCAL","IDENTITY","DEFERRABLE","INITIALLY","DEFERRED","IMMEDIATE","AUTHORIZATION","CURRENT_ROLE","CURRENT_USER","SESSION_USER"],mysql:["LOCK","RENAME","REPLACE","SHOW","UNLOCK","VIRTUAL","VISIBLE","INVISIBLE","HIGH_PRIORITY","CACHE","SQL_CACHE","SQL_NO_CACHE","STRAIGHT_JOIN","COMMENT","DATABASES","TABLES","COLUMNS","PROCEDURE","FUNCTION","AUTO_INCREMENT","CHARACTER SET","ENGINE","VALUE","DUPLICATE"]},pi={common:["NOW","CURRENT_DATE","CURRENT_TIME","CURRENT_TIMESTAMP","IF","NULLIF","IFNULL","COALESCE","GREATEST","LEAST","CONCAT","GROUPING","CONCAT_WS","FORMAT","UNNEST","MD5","SHA1","ST_ASTEXT","ST_ASGEOJSON","ST_GEOMFROMTEXT","ST_WITHIN","ST_CONTAINS","ST_INTERSECTS","ST_DISTANCE","ST_BUFFER"],postgres:["MAKE_DATE","MAKE_TIME","MAKE_TIMESTAMP","TO_JSON","TO_JSONB","JSON_TYPEOF","JSONB_TYPEOF","JSON_BUILD_ARRAY","JSONB_BUILD_ARRAY","JSON_BUILD_OBJECT","JSONB_BUILD_OBJECT","JSON_POPULATE_RECORD","JSONB_POPULATE_RECORD","JSON_PATH_QUERY","JSON_PATH_EXISTS"],mysql:["CURDATE","CURTIME","SYSDATE","STR_TO_DATE","MAKEDATE","MAKETIME","JSON_ARRAY","JSON_OBJECT","JSON_EXTRACT","JSON_UNQUOTE","JSON_SET","JSON_INSERT","JSON_REPLACE","JSON_REMOVE","JSON_SEARCH","JSON_CONTAINS","JSON_CONTAINS_PATH","JSON_KEYS","JSON_ARRAY_APPEND","JSON_ARRAY_INSERT","JSON_DEPTH","JSON_LENGTH","JSON_MERGE_PRESERVE","JSON_MERGE_PATCH","JSON_PRETTY","JSON_STORAGE_FREE"]},mi={common:["COUNT","SUM","AVG","MIN","MAX","COVAR_POP","COVAR_SAMP","CORR","ROW_NUMBER","BIT_AND","BIT_OR","STDDEV_POP","STDDEV_SAMP","VAR_POP","VAR_SAMP","VARIANCE","STD","LEAD","LAG","NTILE","FIRST_VALUE","LAST_VALUE"],postgres:["ARRAY_AGG","STRING_AGG","REGR_SLOPE","PERCENTILE_CONT","PERCENTILE_DISC","MODE","RANK","DENSE_RANK","EVERY","BOOL_AND","BOOL_OR","JSON_AGG","JSON_OBJECT_AGG","JSONB_OBJECT_AGG","XMLAGG"],mysql:["GROUP_CONCAT","BIT_XOR","JSON_ARRAYAGG","JSON_OBJECTAGG"]},yi={common:["SMALLINT","INTEGER","INT","BIGINT","DECIMAL","DEC","NUMERIC","REAL","FLOAT","DATE","TIME","TIMESTAMP","INTERVAL","CHAR","CHARACTER","VARCHAR","TEXT","BINARY","VARBINARY","BOOLEAN","JSON","GEOMETRY","POINT","LINESTRING","POLYGON","DOUBLE PRECISION","CHARACTER VARYING","BYTEA","ENUM"],postgres:["SERIAL","BIGSERIAL","MONEY","BIT","CIDR","INET","MACADDR","MACADDR8","TIMESTAMPTZ","TIMETZ","TSVECTOR","TSQUERY","UUID","XML","INT4RANGE","INT8RANGE","NUMRANGE","TSRANGE","TSTZRANGE","DATERANGE","BOX","PATH","CIRCLE","LINE","LSEG","POLYGON","OID","BIT VARYING","JSONB","REGCLASS"],mysql:["TINYINT","MEDIUMINT","BIT","YEAR","DATETIME","TINYTEXT","QUERY","MEDIUMTEXT","LONGTEXT","TINYBLOB","BLOB","MEDIUMBLOB","LONGBLOB","GEOMETRYCOLLECTION","MULTIPOINT","MULTILINESTRING","MULTIPOLYGON","BOOL"]},tr={common:[["<~",{prec:100,assoc:"left",resultType:":right"}],["~>",{prec:100,assoc:"right",resultType:":right"}],["BETWEEN",{prec:85,assoc:"left",resultType:"boolean"}],["NOT",{prec:80,assoc:"right",resultType:"boolean"}],["*",{prec:70,assoc:"left",resultType:"number"}],["/",{prec:70,assoc:"left",resultType:"number"}],["%",{prec:70,assoc:"left",resultType:"number"}],["+",{prec:60,assoc:"left",resultType:"number"}],["-",{prec:60,assoc:"left",resultType:"number"}],["&",{prec:60,assoc:"left",resultType:"number"}],["|",{prec:60,assoc:"left",resultType:"number"}],["<<",{prec:60,assoc:"left",resultType:"number"}],[">>",{prec:60,assoc:"left",resultType:"number"}],["=",{prec:50,assoc:"left",resultType:"boolean"}],["!=",{prec:50,assoc:"left",resultType:"boolean"}],["<>",{prec:50,assoc:"left",resultType:"boolean"}],["<",{prec:50,assoc:"left",resultType:"boolean"}],["<=",{prec:50,assoc:"left",resultType:"boolean"}],[">",{prec:50,assoc:"left",resultType:"boolean"}],[">=",{prec:50,assoc:"left",resultType:"boolean"}],["IS",{prec:50,assoc:"left",resultType:"boolean"}],["IS NOT",{prec:50,assoc:"left",resultType:"boolean"}],["DISTINCT FROM",{prec:50,assoc:"left",resultType:"boolean"}],["IN",{prec:50,assoc:"left",resultType:"boolean"}],["LIKE",{prec:50,assoc:"left",resultType:"boolean"}],["AND",{prec:40,assoc:"left",resultType:"boolean"}],["OR",{prec:30,assoc:"left",resultType:"boolean"}],["INTERSECT",{prec:20,assoc:"left",resultType:"set",isSetOp:!0}],["UNION",{prec:10,assoc:"left",resultType:"set",isSetOp:!0}],["EXCEPT",{prec:10,assoc:"left",resultType:"set",isSetOp:!0}]],postgres:[["COLLATE",{prec:83,assoc:"left",resultType:"string"}],["||",{prec:60,assoc:"left",resultType:"string"}],["::",{prec:97,assoc:"left",resultType:"casted"}],["AT",{prec:95,assoc:"left",resultType:"timestamptz"}],["^",{prec:90,assoc:"left",resultType:"number"}],["#",{prec:60,assoc:"left",resultType:"number"}],["->",{prec:80,assoc:"left",resultType:"json"}],["->>",{prec:80,assoc:"left",resultType:"text"}],["#>",{prec:80,assoc:"left",resultType:"json"}],["#>>",{prec:80,assoc:"left",resultType:"text"}],["@>",{prec:80,assoc:"left",resultType:"boolean"}],["<@",{prec:80,assoc:"left",resultType:"boolean"}],["?",{prec:80,assoc:"left",resultType:"boolean"}],["?|",{prec:80,assoc:"left",resultType:"boolean"}],["?&",{prec:80,assoc:"left",resultType:"boolean"}],["-@",{prec:80,assoc:"left",resultType:"boolean"}],["#-",{prec:80,assoc:"left",resultType:"json"}],["@?",{prec:80,assoc:"left",resultType:"boolean"}],["@@",{prec:80,assoc:"left",resultType:"boolean"}],["ILIKE",{prec:50,assoc:"left",resultType:"boolean"}],["~",{prec:50,assoc:"left",resultType:"boolean"}],["!~",{prec:50,assoc:"left",resultType:"boolean"}],["~*",{prec:50,assoc:"left",resultType:"boolean"}],["!~*",{prec:50,assoc:"left",resultType:"boolean"}],["SIMILAR TO",{prec:50,assoc:"left",resultType:"boolean"}],["&&",{prec:60,assoc:"left",resultType:"boolean"}],["<->",{prec:60,assoc:"left",resultType:"number"}],["@",{prec:60,assoc:"left",resultType:"geometry"}],["&<",{prec:60,assoc:"left",resultType:"boolean"}],["&>",{prec:60,assoc:"left",resultType:"boolean"}],["|-",{prec:60,assoc:"left",resultType:"boolean"}],["-|",{prec:60,assoc:"left",resultType:"boolean"}],["<<",{prec:60,assoc:"left",resultType:"boolean"}],[">>",{prec:60,assoc:"left",resultType:"boolean"}],["<<|",{prec:60,assoc:"left",resultType:"boolean"}],["|>>",{prec:60,assoc:"left",resultType:"boolean"}],["&<|",{prec:60,assoc:"left",resultType:"boolean"}],["|&>",{prec:60,assoc:"left",resultType:"boolean"}],["~=",{prec:50,assoc:"left",resultType:"boolean"}],["?#",{prec:60,assoc:"left",resultType:"boolean"}],["?-",{prec:60,assoc:"left",resultType:"boolean"}],["?-|",{prec:60,assoc:"left",resultType:"boolean"}],["?|",{prec:60,assoc:"left",resultType:"boolean"}],["?||",{prec:60,assoc:"left",resultType:"boolean"}],["#",{prec:60,assoc:"left",resultType:"number"}],["##",{prec:60,assoc:"left",resultType:"geometry"}],["@-@",{prec:60,assoc:"left",resultType:"number"}]],mysql:[["DIV",{prec:70,assoc:"left",resultType:"number"}],["MOD",{prec:70,assoc:"left",resultType:"number"}],["BINARY",{prec:90,assoc:"right",resultType:"binary"}],["^",{prec:80,assoc:"left",resultType:"number"}],["~",{prec:85,assoc:"right",resultType:"number"}],["<=>",{prec:50,assoc:"left",resultType:"boolean"}],["REGEXP",{prec:50,assoc:"left",resultType:"boolean"}],["RLIKE",{prec:50,assoc:"left",resultType:"boolean"}],["!",{prec:80,assoc:"right",resultType:"boolean"}],["XOR",{prec:40,assoc:"left",resultType:"boolean"}],["&&",{prec:40,assoc:"left",resultType:"boolean"}],["||",{prec:30,assoc:"left",resultType:"boolean"}],[":=",{prec:10,assoc:"right",resultType:":right"}],["SOUNDS LIKE",{prec:50,assoc:"left",resultType:"boolean"}]]};var jt=class{buffer="";cursor=0;line=1;column=1;mysqlBindingIndex=0;nestingContext=[];nextTokenEscape=0;next(e=1,t=!1){t&&(this.line++,this.column=0),this.column+=e,this.cursor+=e,this.nextTokenEscape===1?this.nextTokenEscape=2:this.nextTokenEscape===2&&(this.nextTokenEscape=0)}},Ut=class{#e;#t;#r=!1;#n=!1;#i=!1;#a=null;#s=[];#u;#l=[];constructor(e,{state:t,...s}={}){this.#e=e,this.#t=s}[Symbol.asyncIterator](){return this}get options(){return this.#t}get locked(){return this.#r}get started(){return this.#n}get done(){return this.#i&&!this.#l.length}previous(){return this.#s[this.#s.length-1]}current(){return this.#u}async next(){this.#y("next()"),this.#n=!0;let e,t=!1;return this.#l.length?(this.#o(this.#u),this.#u=this.#c(),e=this.#u):({value:e,done:t}=await this.#e.next(),this.#o(this.#u),this.#u=e,this.#i=t),this.#a!==null&&e?.type.endsWith("_block")&&e.value.savepoint(),{value:e,done:t}}async match(e,t=void 0){let[s,r,n]=typeof arguments[0]=="number"?arguments:[0,e,t],a=o=>o&&(Array.isArray(r)?r.includes(o.type):r===o.type)&&(n===void 0||(Array.isArray(n)?n.includes(o.value)||n.includes(void 0):n===o.value))&&o||void 0;if(s===1/0){let o=0,u;for(;u=await this.peek(o++);)if(a(u))return u;return}return a(s?await this.peek(s):this.current())}async peek(e=1){if(e===0)return this.#u;let t=e-this.#l.length;for(;t;){let r=await this.#e.next();if(r.done)break;this.#h(r.value),t--}return this.#l[e-1]}async eat(e=void 0,t=void 0){let s=e?await this.match(e,t):this.current();return s&&(await this.next())?.value,s}async expect(e,t=void 0){let s=await this.eat(e,t);if(!s)throw new Error(`Expected token: ${e}${t?` (${t})`:""}`);return s}#o(e){e?.type.endsWith("_block"),this.#a!==null?this.#s.push(e):this.#s=[e]}#c(){let e=this.#l.shift();return e?.type.endsWith("_block")&&(e.value.#r=!1),e}#d(){let e=this.#s.pop();return e?.type.endsWith("_block")&&e.value.restore(e.value.#a),e}#m(e){e?.type.endsWith("_block")&&(e.value.restore(e.value.#a),e.value.#r=!0),this.#l.unshift(e)}#h(e){e?.type.endsWith("_block")&&(e.value.#r=!0),this.#l.push(e)}#y(e){if(this.#r)throw new Error(`Can't execute ${e}; TokenStream is locked`)}savepoint(){this.#y("savepoint()");let e=this.#s.length;return this.#a===null&&(this.#a=e),e}savepointStatus(){return this.#a!==null?this.#s.length:null}restore(e){if(this.#y("restore()"),this.#a===null||typeof e!="number"||e>this.#s.length)throw new Error(`Invalid restore point ${e}${this.#a===null?". Not in savepoint mode":""}`);for(;e<this.#s.length;)this.#u&&this.#m(this.#u),this.#u=this.#d()}commit(e){if(this.#y("commit()"),e!==this.#a)return;let t;for(;e<this.#s.length&&(t=this.#d());)t.type.endsWith("_block")&&t.value.commit(t.value.#a);this.#a=null}static async create(e,{dialect:t="postgres",state:s=new jt,...r}={}){return Array.isArray(e)&&e.every(n=>typeof n=="object"&&n?.type)&&(e=e.slice())?new this(e[Symbol.iterator](),{dialect:t,...r}):(r.normalized||(r=qa({dialect:t,...r,normalized:!0})),new this(await this.createIterator(e,{dialect:t,state:s,...r,extendedAPI:!0}),{dialect:t,...r}))}static toIterator(e){return typeof e[Symbol.asyncIterator]=="function"?typeof e.next=="function"?e:e[Symbol.asyncIterator]():typeof e[Symbol.iterator]=="function"&&typeof e!="string"&&!(e instanceof String)?typeof e.next=="function"?e:e[Symbol.iterator]():function*(){yield e+""}()}static async*createIterator(e,{dialect:t="postgres",state:s=new jt,...r}={}){let n=this.toIterator(e);if(!["postgres","mysql"].includes(t))throw new Error(`Unknown dialect: ${t}`);if(!(s instanceof jt))throw new Error("options.state must be an instance of TokenStreamState");r.normalized?r={dialect:t,...r}:r=qa({dialect:t,...r,normalized:!0});let a={token:null,prevEmittedToken:null,nextTokenSpaceBefore:"",multiwordBuffer:[]},o=(l,m=!1)=>l?Wa(l,{options:r,state:s,localState:a},m):[],u={value:""};do{s.buffer+=u.value||"";let l;for(;l=s.buffer[s.cursor];){let m=s.buffer[s.cursor+1]===void 0&&!u.done,f=Ga.has(l),p=()=>{throw new SyntaxError(`Unexpected token: ${l} at line ${s.line}, column ${s.column}`)};if(a.token?.type==="hex_literal"||a.token?.type==="bit_literal"){(a.token.delim?l===a.token.delim:f)?(yield*o(a.token),a.token=null,f&&r.spaces&&(a.nextTokenSpaceBefore+=l)):(a.token?.type==="hex_literal"?/[0-9A-Fa-f]/.test(l)||p():/[01]/.test(l)||p(),a.token.value+=l),s.next();continue}if(a.token?.type==="version_spec"){let g=a.token.delim&&l===a.token.delim,E=g||f||l==="."||l===","||l===";"||l===")";if(E?(yield*o(a.token),a.token=null):(a.token.value&&(l==="="?["<",">"].includes(a.token.value)||p():l==="_"?/\d$/.test(a.token.value)||p():/\d/.test(l)||p()),a.token.value+=l),!E||g){s.next();continue}}if(f){let g=a.token?.type==="string_literal",E=a.token?.type==="identifier"&&a.token.delim,N=a.token?.type==="block_comment",x=a.token?.type==="line_comment";if(g||E||N||x&&!(l==="\r"||l===`
`))a.token.value+=l;else{let S=s.buffer[s.cursor-1];!Ga.has(S)&&a.token&&(yield*o(a.token),a.token=null),r.spaces&&(a.nextTokenSpaceBefore+=l)}l===`
`||l==="\r"?s.next(1,!0):s.next();continue}if(l==="\\"){if(m)break;let g=s.buffer[s.cursor+1],E=a.token?.type==="string_literal"&&(r.dialect==="mysql"?!r.mysqlNoBackslashEscapes:a.token.modifier==="E"),N=g===a.token?.delim||g==="\\"||g==="0"||g==="b"||g==="f"||g==="n"||g==="r"||g==="t"||g==="v"||g==="Z";if(E&&N){g={"\\":"\\",0:"\0",b:"\b",f:"\f",n:`
`,r:"\r",t:"	",v:"\v",Z:""}[g]||g,a.token.value+=g,s.next(2);continue}s.nextTokenEscape=1,s.next();continue}if(a.token?.type==="block_comment"||a.token?.type==="line_comment"||a.token?.type==="string_literal"||a.token?.type==="identifier"&&a.token.delim||a.token?.type==="user_var"&&a.token.delim){let g;if(a.token.type==="block_comment"){if(l==="*"){if(m)break;g=s.buffer[s.cursor+1]==="/"?2:0}}else if(l===a.token.delim){if(a.token.type==="identifier"||a.token.type==="string_literal"&&(r.dialect==="mysql"?r.mysqlNoBackslashEscapes:a.token.modifier!=="E")){if(m)break;if(s.buffer[s.cursor+1]===l){a.token.value+=l,s.next(2);continue}}g=1}else if(a.token.type==="string_literal"&&a.token.delim.startsWith("$")&&l==="$"){let E=s.cursor+1;s.buffer.slice(E-a.token.delim.length,E)===a.token.delim&&(a.token.value=a.token.value.slice(0,-a.token.delim.length+1),g=1)}if(g){yield*o(a.token),a.token=null,s.next(g);continue}a.token.value+=l,s.next();continue}if(s.nestingContext.length&&l==={"{":"}","[":"]","(":")"}[s.nestingContext[0]]){if(yield*o(a.token,!0),s.nestingContext.shift(),r.structured){s.next(),a.nestingEndTagSeen=!0;return}a.token=null}let d,h=0,_=0;if(r.dialect==="postgres"){if(a.token?.type==="pg_possible_dollar_delim"||l==="$"){if(a.token?.type==="pg_possible_dollar_delim"){if(l==="$"){let{type:E,value:N,delim:x,...S}=a.token;a.token={type:"string_literal",value:"",delim:`$${N}$`,...S}}else a.token.value+=l;s.next();continue}if(m)break;let g=s.buffer[s.cursor+1];/[0-9]/.test(g)?d={type:"bind_var"}:d={type:"pg_possible_dollar_delim",delim:l}}}else r.dialect==="mysql"&&(l==="?"&&(d={type:"bind_var"}),l==="#"&&(d={type:"line_comment",delim:l}),l==="`"&&(d={type:"identifier",delim:l}));if(l==="'"){let g=new RegExp(`(@)$|^\\W?(${r.dialect==="postgres"?"E|X|B":"N|X"})$`,"i"),E=s.buffer.slice(Math.max(s.cursor-2,0),s.cursor).match(g),N=E?.[1]||E?.[2];if(N==="@"&&a.prevEmittedToken?.type==="identifier"){if(m)break;let x=s.buffer[s.cursor+1];/[\^~=\d<>!]/.test(x)&&(d={type:"version_spec",delim:l},h=1)}if(!d)if(N&&(N!=="@"||r.dialect==="mysql")){let x=/^(E|N)/i.test(N)?"string_literal":N==="@"?"user_var":(N==="X"?"hex_":"bit_")+"literal";d={type:x,...x==="string_literal"?{modifier:N.toUpperCase()}:{},delim:l},h=N==="@"?1:N.length}else d={type:"string_literal",delim:l}}else l==='"'&&(d={type:r.dialect!=="mysql"||r.mysqlAnsiQuotes?"identifier":"string_literal",delim:l});if(l==="@"){if(m)break;let g=s.buffer[s.cursor+1];(a.token||a.prevEmittedToken)?.type==="identifier"&&/[\^~=\d<>!]/.test(g)?d={type:"version_spec"}:r.dialect==="mysql"&&(g==="@"?(d={type:"system_var"},_=1):/[a-zA-Z_$]/.test(g)&&(d={type:"user_var"}))}if(l==="/"||l==="-"){if(m)break;let g=s.buffer[s.cursor+1];l==="/"&&g==="*"?(d={type:"block_comment"},_=1):l==="-"&&g==="-"&&(d={type:"line_comment",delim:l+g},_=1)}if(d){a.token&&!h&&(yield*o(a.token)),a.token={type:d.type,value:"",...d,line:s.line,column:h?s.column-h:s.column},s.next(1+_);continue}if((l==="{"||l==="["||l==="(")&&(yield*o(a.token),a.token=null,s.nestingContext.unshift(l),r.structured)){s.next();let g={type:{"{":"brace_block","[":"bracket_block","(":"paren_block"}[l],value:await this[r.extendedAPI?"create":"createIterator"](n,{state:s,...r}),line:s.line,column:s.column};if(yield*o(g),r.extendedAPI)await g.value.peek(1/0);else for(;!(await g.value.next()).done;);continue}if(/[0-9]/.test(l)){if(a.token?.type!=="identifier"&&a.token?.type!=="bind_var"&&a.token?.type!=="version_spec"&&!a.token?.type.endsWith("_literal")&&!a.token?.type.endsWith("_var")){if(yield*o(a.token),l==="0"){if(m)break;let g=s.buffer[s.cursor+1]?.toUpperCase();if((g==="X"||g==="B")&&r.dialect==="mysql"){a.token={type:(g==="X"?"hex_":"bit_")+"literal",value:"",line:s.line,column:s.column},s.next(2);continue}}a.token={type:"number_literal",value:l,line:s.line,column:s.column},s.next();continue}}else if(/[a-zA-Z_]/.test(l)){if(a.token?.type!=="identifier"&&!a.token?.type.endsWith("_var")&&!(a.token?.type==="number_literal"&&/\d$/.test(a.token.value)&&/E/i.test(l))){a.token?.type==="number_literal"&&p(),yield*o(a.token),a.token={type:"identifier",value:l,line:s.line,column:s.column},s.next();continue}}else{let g="operator";if(l===";"||l===","||l===":"||l==="{"||l==="}"||l==="["||l==="]"||l==="("||l===")"){if(l===":"&&(s.nestingContext[0]!=="{"||s.nextTokenEscape)?g="operator":g="punctuation",r.dialect==="postgres"&&l===":"&&g==="operator"&&a.token?.type!=="operator"){let E=s.buffer[s.cursor-1];if(m)break;let N=s.buffer[s.cursor+1];E!==":"&&/[a-zA-Z_]/.test(N)&&r.PL_SQL!==!1&&(g="user_var",l="")}}else if(l===".")if(a.token?.type==="number_literal")a.token.value.includes(".")&&p(),g="number_literal";else{if(m)break;let E=s.buffer[s.cursor+1];/\d/.test(E)?g="number_literal":(g="punctuation",a.token?.type==="system_var"&&(g="system_var"))}else(l==="+"||l==="-")&&a.token?.type==="number_literal"&&/E$/i.test(a.token.value)&&(/\+|\-/.test(a.token.value)&&p(),g="number_literal");if(a.token?.type!==g||g==="punctuation"||g==="operator"&&!r.operators.classic.has(`${a.token.value}${l}`)){yield*o(a.token),a.token={type:g,value:l,line:s.line,column:s.column},s.next();continue}}a.token.value+=l,s.next()}if(u.done)break;s.buffer=s.buffer.slice(s.cursor),s.cursor=0}while(u=await n.next());if(a.token){if(a.token.type==="operator"&&a.token.value!=="*"||a.token.type==="number_literal"&&/E$/i.test(a.token.value)||a.token.type==="block_comment"||a.token.type==="pg_possible_dollar_delim"||["string_literal","hex_literal","bit_literal","identifier","version_spec","user_var"].includes(a.token.type)&&a.token.delim)throw new SyntaxError(`Unterminated ${a.token.type} at line ${s.line}, column ${s.column}`);yield*o(a.token,!0)}if(s.nestingContext.length&&!a.nestingEndTagSeen)throw new SyntaxError(`Unterminated nesting "${s.nestingContext[0]}" at line ${s.line}, column ${s.column}`)}},Ga=new Set([" ","\f",`
`,"\r","	","\v"]);function qa(c){let e=(t,s,r,n)=>{r.split(" ").reduce((a,o)=>(a=a?`${a} ${o}`:o,t.set(a,n),a),s)};for(let t of["statements","functionNames","aggrFunctionNames","keywords","operators","dataTypes"]){let s=["statements","functionNames","aggrFunctionNames"].includes(t)?"keywords":t,r=c[s]||{classic:new Map,compound:new Map};for(let n of["common",c.dialect==="mysql"?"mysql":"postgres"]){let a=ca[t][n];for(let o of a){let[u,l]=Array.isArray(o)?[o[0],{...o[1],value:o[0]}]:[o,{value:o}];u.includes(" ")?e(r.compound,"",u,l):r.classic.set(u,l)}}c={...c,[s]:r}}return c}function Wa(c,{options:e,state:t,localState:s},r=!1){if(s.nextTokenSpaceBefore){let{type:o,...u}=c;c={type:o,spaceBefore:s.nextTokenSpaceBefore,...u},s.nextTokenSpaceBefore=""}if(c.type==="block_comment"||c.type==="line_comment")return di(c,{options:e});let n,a=!1;if(e.dialect==="mysql"&&c.type==="bind_var")n=[{...c,value:`${++t.mysqlBindingIndex}`}];else if(c.type==="operator"){let{line:o,column:u,...l}=c;n=[{...l,...e.operators.classic.get(c.value)||{},line:o,column:u}]}else c.type==="identifier"&&!c.delim&&(n=hi(c,{options:e,state:t,localState:s},r),a=!0);return n||(n=[c]),n?.length?s.prevEmittedToken=n[0]:s.prevEmittedToken=c,!a&&n.length&&s.multiwordBuffer.length?s.multiwordBuffer.splice(0).concat(n):n}function di(c,{options:e}){return e.comments?(c.type==="block_comment"?c={...c,value:c.value.split(`
`).map(t=>t.replace(/^[ ]+\*[ ]+?/,"").trim()).join(`
`)}:c={...c,value:c.value.trim()},[c]):[]}function hi(c,{options:e,state:t,localState:s},r=!1){let n,a=s.multiwordBuffer.length,o=(a?s.multiwordBuffer.map(_=>_.value).concat(c.value).join(" "):c.value).toUpperCase(),u=_=>{for(let g of["keywords","operators","dataTypes"]){let E=e[g][_].get(o);if(E)return[g,E]}return[]},l=_=>{let{type:g,spaceBefore:E,line:N,column:x,...S}=c;return a&&(E=s.multiwordBuffer[0].spaceBefore,N=s.multiwordBuffer[0].line,x=s.multiwordBuffer[0].column),{type:d==="dataTypes"?"data_type":d.replace(/s$/,""),...E?{spaceBefore:E}:{},...S,..._,value:o,line:N,column:x}},m=_=>{let g=l(_);a?(n=[g],s.multiwordBuffer.splice(0),a=0):n=[g]},f=_=>{let g=l(_);s.multiwordBuffer.push(g),n=[]},p=!1,[d,h]=u("compound");if(h?.value===o)m(h),p=!0;else if(h){let[_,g]=u("classic");g&&_!==d&&([d,h]=[_,g]),r?m(h):f(h),p=!0}else[d,h]=u("classic"),h&&(m(h),p=!0);if(!p&&a){let _=s.multiwordBuffer.splice(0),g=Wa(c,{options:e,state:t,localState:s});return[..._,...g]}if(!n&&/^(TRUE|FALSE|NULL|UNKNOWN)$/i.test(c.value)){let{type:_,...g}=c;n=[{type:/UNKNOWN/.test(c.value)?"unknown_literal":/NULL/i.test(c.value)?"null_literal":"bool_literal",...g,value:c.value.toUpperCase()}]}return n}var y=Object.create(null);var w=class c{static get NODE_NAME(){return Fa(this.name)}get NODE_NAME(){return this.constructor.NODE_NAME}#e;get _ast(){return this.#e}#t;get options(){return this.#t||this.#r?.options||{dialect:"postgres"}}#r;get parentNode(){return this.#r}get statementNode(){return this.#r?.statementNode}get rootNode(){return this.#r?.rootNode||this}constructor(e={},t={}){this.#e=e,this.#t=t;for(let s of Object.values(this.#e))this._adoptNodes(...[].concat(s))}_keys(){return Object.keys(this.#e).filter(e=>this.#e[e]!==void 0)}_has(e,t=void 0,s=void 0){return e in this.#e?typeof t=="number"?typeof this.#e[e][t]<"u":t?this.#e[e].some(r=>r.identifiesAs?.(t,s)):!0:!1}_get(e,t=void 0,s=void 0){if(!(e in this.#e))return;if(typeof t<"u"&&!Array.isArray(this.#e[e]))throw new Error(`Can't use index in field "${e}"; not an array.`);let r=this.#e[e];return typeof t=="number"?r=r[t]:t&&(r=r.find(n=>n.identifiesAs?.(t,s))),r}_set(e,t,s=void 0,r=void 0){let n=arguments.length>2?t:void 0,a=arguments.length>2?s:t,o=typeof n<"u"?this._get(e,n,r):void 0;return o&&this._unadoptNodes(...[].concat(o)),typeof n<"u"?this.#e[e]=o?this.#e[e].reduce((u,l)=>l===o?u.concat(a):u.concat(l),[]):this.#e[e].concat(a):this.#e[e]=a,this._adoptNodes(...[].concat(a)),!0}_delete(e,t=void 0,s=void 0){if(!(e in this.#e))return!1;if(typeof t<"u"&&!Array.isArray(this.#e[e]))throw new Error(`Can't use index in field "${e}"; not an array.`);return typeof t<"u"?this.#e[e]=this.#e[e].reduce((r,n,a)=>(typeof t=="number"?a===t:n.identifiesAs?.(t,s))?(this._unadoptNodes(n),r):r.concat(n),[]):(this._unadoptNodes(...[].concat(this.#e[e])),this.#e[e]=Array.isArray(this.#e[e])?[]:void 0),!0}_add(e,...t){if(!Array.isArray(this.#e[e]))throw new Error(`Can't add on field "${e}"; not an array.`);return this._adoptNodes(...t),this.#e[e]=this.#e[e].concat(t),!0}_adoptNodes(...e){for(let t of e)if(t instanceof c){if(t.#r&&t.#r!==this){let s=`${this.NODE_NAME}`;throw new Error(`[${s}] Illegal node operation`)}t.#r=this}}_unadoptNodes(...e){for(let t of e)if(t instanceof c){if(t.#r!==this){let s=`${this.NODE_NAME}`;throw new Error(`[${s}] Illegal node operation`)}t.#r=null}}climbTree(e){if(this.#r)return e(this.#r,()=>this.#r.climbTree(e))}walkTree(e,t=!1,s=null){let r=(n,a,o)=>{if(!(n instanceof c)&&!Array.isArray(n))return;let u=new Map(o||[]);e(n,a,u)===n&&(Array.isArray(n)?n.map((m,f)=>r(m,f,u)):(t||n.statementNode!==n)&&n.walkTree(e,t,u))};for(let[n,a]of Object.entries(this.#e))r(a,n,s)}containsNode(e){return e?this===e.parentNode||this.containsNode(e.parentNode):!1}identifiesAs(e,t=!1){if(typeof e>"u")return!1;if(typeof e?.jsonfy=="function")return z(this.jsonfy({nodeNames:!1}),e.jsonfy({nodeNames:!1}),t)}static morphsTo(){return this}clone(e={},t=null,s=null){let r=this.jsonfy(e,t,s);return[this.constructor].concat(this.constructor.morphsTo()).reduce((o,u)=>o||u.fromJSON(r,{dialect:e.toDialect||this.options.dialect}),void 0)}deSugar(e,t={},s=null,r=null){return t={...t,deSugar:e},this.clone(t,s,r)}toDialect(e,t={},s=null,r=null){return t={...t,toDialect:e},this.clone(t,s,r)}static get syntaxRules(){return[]}static compileASTSchemaFromSyntaxRules({dialect:e="postgres"}={}){this._astSchemaCompileCache||(this._astSchemaCompileCache=new Map);let t=`${this.NODE_NAME}:${e}`;if(!this._astSchemaCompileCache.has(t)){let s,r=this.syntaxRules,n=[].concat(r);n.length===1&&Array.isArray(n[0].type)&&!n[0].as?s=n[0]:s=this._compileASTSchemaFromSyntaxRules(r,e,{trail:[this.NODE_NAME]}),this._astSchemaCompileCache.set(t,s)}return this._astSchemaCompileCache.get(t)}static _compileASTSchemaFromSyntaxRules(e,t="postgres",{trail:s=[],schemaSet:r=new Set([new Map]),assertionTrail:n={dependencies:new Set,optional:!1,assert:!1}}={}){let a=Array.isArray(e)?e:[e],o=new Set(n.dependencies),u=m=>new Set([...m].map(f=>new Map(f)));for(let[m,f]of a.entries()){if(f.dialect&&f.dialect!==t)continue;let{type:p,as:d,if:h=n.inference,value:_,arity:g,singletons:E,modifier:N,booleanfy:x,optional:S=n.optional,assert:A=n.assert,syntax:v,syntaxes:b,...O}=f,T=s.concat(`${Array.isArray(e)?m:""}${d?`<${d}>`:""}`||[]),R=T.join("."),k=Ha(O);if(k.length)throw new SyntaxError(`[${R}] Unsupported attributes in rule: "${k.join('", "')}".`);let J=typeof p=="string"&&p[0]===p[0].toLowerCase();if(d){if(!p)throw new SyntaxError(`[${R}] Field rules must have a "type" attribute of type string.`);if(v||b)throw new SyntaxError(`[${R}] Field rules ("${d}") can not have a "syntax" or "syntaxes" attribute.`);if(d==="."){if(!J)throw new SyntaxError(`[${R}] Terminal Node rules must be token-typed rules.`);if(S)throw new SyntaxError(`[${R}] Terminal Node rules can not be optional.`)}else if(N)throw new SyntaxError(`[${R}] Only Terminal Node rules can have a "modifier" attribute.`);if(J){if(![void 0,null].includes(g))throw new SyntaxError(`[${R}] Token rules can not be item-based.`);if(!Pt[p])throw new SyntaxError(`[${R}] Unknown token type "${p}".`)}else{if(_)throw new SyntaxError(`[${R}] Only token rules can have a "value" attribute.`);for(let P of[].concat(p))if(!y[P])throw new SyntaxError(`[${R}] Unknown node type "${P}".`);if(![void 0,null].includes(g)){if(ne(g)){let P=Object.keys(g);if(P.some(q=>!["min","max","eager"].includes(q)||typeof g[q]!=(q==="eager"?"boolean":"number")))throw new SyntaxError(`Invalid arity object "{ ${P.join(", ")} }" for field "${d}". Only "min: <number>", "max: <number>" and "eager: <bool>" expected.`)}else if([].concat(g).some(P=>typeof P!="number"))throw new SyntaxError(`[${R}] Invalid arity value "${[].concat(g).join(", ")}" for field "${d}". Number(s) expected.`)}}let U={rulePath:R,type:p};_&&(U.value=_),N&&(U.modifier=N),x&&(U.booleanfy=x),[void 0,null].includes(g)||(U.arity=g),E&&(U.singletons=E),S&&(U.optional=!0),A&&(U.assert=A),h&&(U.if=h),S&&n.dependencies.size&&(U.dependencies=Array.from(n.dependencies));for(let P of r)P.set(d,U);d!=="."&&S&&!f.optional&&o.add(d)}if(v||b){let U={dependencies:o,optional:S,assert:A,inference:h};if(v){r=this._compileASTSchemaFromSyntaxRules(v,t,{trail:T.concat("syntax"),schemaSet:r,assertionTrail:U});continue}let P=new Set;for(let[q,I]of b.entries()){let j=u(r),K=this._compileASTSchemaFromSyntaxRules(I,t,{trail:T.concat("syntaxes",q),schemaSet:j,assertionTrail:U});for(let F of K)P.add(F)}r=P}}let l=Array.from(r);for(let m=0;m<l.length;m++){let f=l[m],p=Object.fromEntries(f);if(!f.size){r.delete(f);continue}for(let d=m+1;d<l.length;d++){let h=l[d],_=Object.fromEntries(h);z(p,_,"cs","rulePath")&&r.delete(h)}}return r}static fromJSON(e,t={},s=null){let r=this.compileASTSchemaFromSyntaxRules(t);if(Array.isArray(r.type)){for(let f of r.type){let d=y[f].fromJSON(e,t,s);if(d)return d}return}if(e instanceof c){if(e instanceof this)return e;e=e.jsonfy()}if(!ne(e))return;let n=null;if("nodeName"in e){if(e.nodeName&&e.nodeName!==this.NODE_NAME)return;({nodeName:n,...e}=e)}let a,o=(f,p=null,d=!1)=>{if(!(!n&&t.assert!==!0&&!(t.assert instanceof RegExp&&t.assert.test(activeTrailStr)))){if(p&&(f=`[${p}] ${f}`),d){a=f;return}throw new Error(f)}},u=(f,p)=>{if(f.value!==void 0){let d=f.booleanfy?[!0,!1]:f.value;return[].concat(d).includes(p.value)}return Pt[f.type].match?.(p,t)!==!1},l=(f,p)=>{for(let d of[].concat(f.type))if(typeof d=="string"&&d[0]===d[0].toLowerCase()){if(u(f,{value:p})===!0)return p}else{let _=y[d].fromJSON(p,{...t,assert:!1});if(_)return _}},m=(f,p,d,h=!1)=>{if(d.dependencies?.length){for(let g of d.dependencies)if(!(g in f))return o(`Missing dependency field "${g}" required by "${p}"`,d.rulePath,h),!1}if(d.if&&!fa(d.if,f,d.rulePath))return!0;if(![void 0,null].includes(d.arity)){if(e[p]===void 0)return d.optional?(f[p]=void 0,!0):(o(`Missing required field "${p}"`,d.rulePath,h),!1);if(!Array.isArray(e[p]))return o(`Field "${p}" must be an array`,d.rulePath,h),!1;if(d.arity!==1/0){let N=e[p].length;if(ne(d.arity)){if("min"in d.arity&&N<d.arity.min)return o(`A minimum of ${d.arity.min} argument(s) expected but got ${N}`,d.rulePath,h),!1;if("max"in d.arity&&N>d.arity.max)return o(`A maximum of ${d.arity.max} argument(s) expected but got ${N}`,d.rulePath,h),!1}else if(![].concat(d.arity).includes(N))return o(`Exactly ${[].concat(d.arity).join(" or ")} argument(s) expected but got ${N}`,d.rulePath,h),!1}let g=e[p].map(N=>l(d,N)).filter(N=>N!==void 0),E=g.length;if(e[p].length>E)return E?(o(`Failed to resolve some arguments for "${p}"`,d.rulePath,h),!1):(o(`Failed to resolve any argument for "${p}"`,d.rulePath,h),!1);if(d.singletons){let N=g.find((x,S)=>g.slice(S+1).some(A=>d.singletons==="BY_KEY"?A.identifiesAs?.(x):A instanceof x.constructor));if(N)return o(`Duplicate entry of type "${N.constructor.name}"`,d.rulePath,h),!1}return f[p]=g,!0}if(e[p]===void 0)return d.optional?(f[p]=d.booleanfy?!1:void 0,!0):(o(`Missing required field "${p}"`,d.rulePath,h),!1);let _=l(d,e[p]);return _===void 0?(o(`Failed to resolve field "${p}"`,d.rulePath,h),!1):(f[p]=_,!0)};e:for(let f of r instanceof Map?[r]:r){let p=Object.create(null),d=new Map(f),h=e;if(d.has(".")){let _=d.get("."),g=Pt[_.type];if([void 0,null].includes(h.value))continue e;({value:p.value,...h}=h);for(let E of Object.keys(g))typeof g[E]!="function"&&E in h&&({[E]:p[E],...h}=h);if(u(_,p)===!1)continue e;d.delete(".")}for(let _ of new Set(Object.keys(h).concat(...d.keys()))){if(!d.has(_)){if(e[_]===void 0)continue;continue e}let g=d.get(_);if(m(p,_,g,!0)===!1)continue e}return typeof s=="function"?s(p,t):new this(p,t)}o(`Failed to match any schema${a?`. ${a}`:""}`,this.NODE_NAME)}toJSON(){return this.jsonfy()}jsonfy(e={},t=null,s=null){let r=(n,a,o)=>{let u=(m=e,f=o)=>Array.isArray(a)?a.reduce((p,d,h)=>{let _=r(h,d,f);return _===void 0?p:p.concat(_)},[]):a instanceof c?a.jsonfy(m,f,s):a;if(a===void 0)return;let l=o?o.transform(a,u,n,e):u();if(l instanceof c)throw new Error('"jsonfy" transforms must return plain JSON objects.');return l};return{...e.nodeNames!==!1?{nodeName:this.NODE_NAME}:{},...Object.fromEntries(Object.entries(this.#e).reduce((n,[a,o])=>{let u=r(a,o,t);return u===void 0?n:[...n,[a,u]]},[]))}}static async toStream(e,t={}){let s=e instanceof Ut?e:await Ut.create(e,{structured:!0,spaces:!0,...t});return!s.current()&&!s.done&&await s.next(),s}static async parse(e,{left:t=void 0,minPrecedence:s=0,trail:r=[],...n}={}){let a=await this.toStream(e,n),o=a.savepoint(),u=this.syntaxRules,l,m;if((m=[].concat(u)).length===1&&Array.isArray(m[0].type)&&!m[0].as)m[0].expression?l=await this._parseAsExpression(a,m[0].type,{exprClass:m[0].expression,left:t,minPrecedence:s,trail:r.concat(this.NODE_NAME),...n}):l=await this._parseFromTypes(a,m[0].type,{left:t,minPrecedence:s,trail:r.concat(this.NODE_NAME),...n});else{let f=await this._parseFromRules(a,u,{left:t,minPrecedence:s,trail:r.concat(this.NODE_NAME),...n});f&&(l=new this(f,{...n,dialect:a.options.dialect}))}return l||a.restore(o),l}static async _parseAsExpression(e,t,{exprClass:s=1,left:r=void 0,minPrecedence:n,trail:a,...o}){if(r)throw new Error("TODO");for(r=await this._parseFromTypes(e,t,{minPrecedence:n,trail:a,...o});r;){let u=await e.match("operator");if(!u||u.prec<n||u.isSetOp&&s!==2)break;let l=await this._parseFromTypes(e,t,{left:r,minPrecedence:n,trail:a,...o});if(!l)return r;r=l}return r}static async _parseFromRules(e,t,{left:s,minPrecedence:r,trail:n,...a},o={}){let u=Array.isArray(t)?t:[t],l=0,m=r;for(let[f,p]of u.entries()){if(p.dialect&&p.dialect!==e.options.dialect){l++;continue}let{requiredSpacing:d,peek:h,type:_,value:g,syntax:E,syntaxes:N,as:x,if:S,arity:A,optionalParens:v,singletons:b,itemSeparator:O,optional:T=!1,assert:R=!1,booleanfy:k,...J}=p,U=n.concat(`${Array.isArray(t)?f:""}${x?`<${x}>`:""}`||[]),P=U.join("."),q=Ha(J);if(q.length)throw new SyntaxError(`[${P}] Unsupported attributes in rule: "${q.join('", "')}".`);let I=typeof _=="string"&&_[0]===_[0].toLowerCase(),j=x&&!I&&u[f+1]?.type==="operator"||u[f+1]?.type==="punctuation"&&u[f+1]?.value===".",K=async()=>{if(!(Array.isArray(h)&&!await Y(-1))){for(let M of[].concat(_))if(s instanceof y[M])return o[x]=s,!0;return!1}},F=()=>{let M=e.current();return d===!1&&!M?.spaceBefore||d===!0&&M?.spaceBefore||d===`
`&&/\n/.test(M?.spaceBefore)},Y=async(M=0)=>M?await e.match(h[0]+M,...h.slice(1)):await e.match(...h),D=async()=>{let M;if((M=await e.match("operator"))&&M.prec<r)return;let B=await e.eat(_,_.endsWith("_block")?void 0:g);return B?.type==="operator"&&(m=B.prec+(B.assoc==="right"?0:1)),B},$=async(M,B)=>{if(Array.isArray(_))return await this._parseFromTypes(M,_,{minPrecedence:B,trail:U,...a});let me=y[_];if(!me)throw new SyntaxError(`[${P}] Unknown node type <${_}>.`);return await me.parse(M,{minPrecedence:B,trail:U,...a})},H=(M,B,me=!1,ie=!1)=>{if(!(!R&&!ie&&a.assert!==!0&&!(a.assert instanceof RegExp&&a.assert.test(P)))){if(me){let fe=M.current()||M.previous(),xe=M.current()?me===1?":":" near":" by";B+=fe?`${xe}${typeof fe.value=="string"?` "${fe.value}"`:""} (${fe.type}) at <line ${fe.line}, column ${fe.column}>`:`${xe} end of stream`}throw new SyntaxError(`[${P}] ${B}.`)}};if(_){if(s){if(!j||!await K())return;s=null;continue}else if(s===!1&&j){if(T){s=null;continue}return}}if(S&&!fa(S,o,P))continue;if(d!==void 0&&!F()){H(e,"Required spacing mismatch",!0);return}if(Array.isArray(h)&&!await Y()){H(e,"Peek failure",!0);return}if(x==="."){if(!_||!I)throw new SyntaxError(`[${P}] Terminal node rules must be token-typed rules.`);let M=await D();if(!M){H(e,`Token of type "${_}"${g?` and value "${g}"`:""} expected but got "${e.current()?.type}"`,!0);return}let B,me,ie,fe,xe,sa,Ce,Pe;({type:B,line:me,column:ie,spaceBefore:fe,prec:xe,assoc:sa,resultType:Ce,...Pe}=M),Object.assign(o,Pe);continue}let C=e;if(typeof _=="string"&&_.endsWith("_block")){if(!(C=(await D())?.value)){if(T)continue;H(e,`Token of type "${_}" expected but got "${e.current()?.type}"`,!0);return}m=0,!C.current()&&!C.done&&await C.next()}if(![void 0,null].includes(A)){if(!x)throw new SyntaxError(`[${P}] Multi-argument field rules must have a "as" attribute.`);if(!_)throw new SyntaxError(`[${P}] Multi-argument field rules must have a "type" attribute.`);if(I)throw new SyntaxError(`[${P}] Multi-argument field rules must be node-typed rules.`);let M,B=[],me=m;if(O?.type==="operator"){let ie=O.value&&(C.options.operators?.classic.get(O.value)||C.options.operators?.compound.get(O.value));ie?.prec&&(me=ie?.prec+1)}for(;M=await $(C,me);){if(b&&(b==="BY_KEY"?B.some(fe=>fe.identifiesAs?.(M)):B.some(fe=>fe instanceof M.constructor))){H(C,`Duplicate entry of type "${M.constructor.name}"`,!0,!0);return}if(B.push(M),ne(A)&&A.eager===!1&&B.length===A.max||O&&!await C.eat(O.type,O.value))break}if(A!==1/0){let ie=B.length;if(!ie&&T)continue;let fe=C.current(),xe=fe?`. Unexpected ${fe.type}${typeof fe.value=="string"?` "${fe.value}"`:""}`:"";if(ne(A)){if("min"in A&&ie<A.min){H(C,`A minimum of ${A.min} argument(s) expected but got ${ie}${xe}`,!0);return}if("max"in A&&ie>A.max){H(C,`A maximum of ${A.max} argument(s) expected but got ${ie}${xe}`,!0);return}}else if(![].concat(A).includes(ie)){H(C,`Exactly ${[].concat(A).join(" or ")} argument(s) expected but got ${ie}${xe}`,!0);return}}o[x]=B;continue}let W;if(E){let M=C.savepoint();W=await this._parseFromRules(C,E,{left:s,minPrecedence:m,trail:U.concat("syntax"),...a}),W===void 0?C.restore(M):s&&(s=null)}else if(N){for(let[M,B]of N.entries()){let me=C.savepoint();if(W=await this._parseFromRules(C,B,{left:s,minPrecedence:m,trail:U.concat("syntaxes",M),...a}),W===void 0)C.restore(me);else break}W!==void 0&&s&&(s=null)}else if(!(typeof _=="string"&&_.endsWith("_block")))W=I?(await D())?.value:await $(C,m);else if(!_)throw new SyntaxError(`[${P}] Rules must have a "type", "syntax" or "syntaxes" attribute.`);if(W===void 0&&!T){H(C,_?"Unexpected token":null,1);return}if(typeof _=="string"&&_.endsWith("_block")&&!C.done&&C.current())return;x?(k&&(W=W!==void 0),o[x]=W):(E||N)&&Object.assign(o,W)}if(l!==u.length)return o}static async _parseFromTypes(e,t,{left:s,minPrecedence:r,trail:n,...a}){for(let o of t)if(typeof o=="string"&&o[0]===o[0].toLowerCase()){if(await e.match(o))return await e.eat()}else{let l=y[o];if(!l)throw new SyntaxError(`[${this.NODE_NAME}] Unknown node type "${o}".`);let m=await l.parse(e,{left:s,minPrecedence:r,trail:n,...a});if(m!==void 0)return m}}toString(){return this.stringify()}stringify(e={}){return this._stringifyFromRules(this.constructor.syntaxRules,{trail:[this.NODE_NAME],...e})}_stringifyFromRules(e,{trail:t=[],startingIndentLevel:s=0,autoLineBreakThreshold:r=60,...n},a=null){let o=()=>" ",u=p=>`
${(n.tabSpaces===4?"	":" ".repeat(n.tabSpaces||2)).repeat(p)}`,l=[],m=[].concat(e),f=0;for(let[p,d]of m.entries()){if(d.dialect&&d.dialect!==this.options.dialect)continue;let{requiredSpacing:h,type:_,value:g,booleanfy:E,syntax:N,syntaxes:x,as:S,if:A,arity:v,itemSeparator:b,optional:O=!1,autoSpacing:T=h,optionalParens:R,autoIndent:k=!1,autoIndentAdjust:J=0}=d,U=t.concat(`${Array.isArray(e)?p:""}${S?`<${S}>`:""}`||[]),P=U.join("."),q=k;if(A&&!fa(A,this.#e,this.NODE_NAME))continue;let I={startingIndentLevel:s+(k?1:0)+J,autoLineBreakThreshold:r,...n},j;if([void 0,null].includes(v))if(N)j=this._stringifyFromRules(N,{trail:U.concat("syntax"),...I},a);else if(x){let D=-1;for(let[$,H]of x.entries()){let C={score:0},W=this._stringifyFromRules(H,{trail:U.concat("syntaxes",$),...I},C);typeof W=="string"&&C.score>D&&(j=W,D=C.score)}a&&(a.score+=D)}else if(S){let D=this._get(S==="."?"value":S),$=g!=null;if($&&E&&D===!0&&(D=g),$&&([].concat(g).includes(D)?a&&a.score++:D=void 0),D!==void 0){D instanceof c&&(D=D.stringify(I));let H=S==="."?{...d,...this.#e}:{...d,value:D};j=this._stringifyTerminal(H,I)}}else j=this._stringifyTerminal(d,I);else{let D=!1,$=this._get(S),H=$?.length||0;if(typeof k=="number"&&H<k&&(I.startingIndentLevel-=1),$&&((D=v===1/0)||(ne(v)?D=(!("min"in v)||H>=v.min)&&(!("max"in v)||H<=v.max):D=[].concat(v).includes(H))),D){let C=$.map(me=>me.stringify(I));q=k===!0||typeof k=="number"&&$.length>=k||T===`
`;let W=C.join(" "),M=I.prettyPrint&&q&&(W.length>r||W.includes(`
`))?u(I.startingIndentLevel):o(),B=b?this._stringifyTerminal(b,I):"";/^\w+$/.test(B)?B=`${M}${B}${M}`:B===";"&&I.prettyPrint?B=`${B}
${M}`:B=`${B}${M}`,j=C.join(B)}}if(_==="paren_block"&&R&&!j?.trim()){if(R===!0||n.pruneOptionalParens){a&&a.score++,f++;continue}j=""}if(j===void 0){if(O){f++;continue}return}S&&a&&a.score++;let K=!1,F=j.length>r||j.includes(`
`);if(typeof _=="string"&&_.endsWith("_block")){let D=I.prettyPrint&&k&&F,$={brace_block:"{}",bracket_block:"[]",paren_block:"()"}[_];j=[$[0],D&&!/^\s/.test(j)?u(s+1):$[0]==="{"?o():"",j,D||/^\s/.test(j)?u(s):$[1]==="}"?o():"",$[1]].join("")}else I.prettyPrint&&q&&(l.length||F)&&j!==""&&(j=[u(s+(T===`
`?0:1)),j].join(""),K=!0);let Y=l[l.length-1];j!==""&&!K&&l.length&&!/\s$/.test(Y)&&(Array.isArray(T)?T.includes(Y):T!==!1)&&(T===`
`&&I.prettyPrint?l.push(u(s)):l.push(o())),l.push(j)}if(l.length||f===m.length)return l.join("")}_stringifyTerminal(e,t={}){switch(e.type){case"data_type":return this._stringifyDataType(e,t);case"identifier":return this._stringifyIdentifier(e,t);case"keyword":return this._stringifyKeyword(e,t);case"operator":return this._stringifyOperator(e,t);case"punctuation":return this._stringifyPunctuation(e,t);case"bind_var":return this._stringifyBindVar(e,t);case"version_spec":return`@${e.value}`}if(!Array.isArray(e.type)){if(e.type.endsWith("_literal"))return this._stringifyLiteral(e,t);if(e.type.endsWith("_var"))return this._stringifyVariable(e,t);if(e.type.endsWith("_comment"))return this._stringifyComment(e,t)}return String(e.value)}_stringifyIdentifier(e){let{value:t}=e,s=['"'];this.options.dialect==="mysql"&&(this.options.mysqlAnsiQuotes?s.push("`"):s.fill("`"));let r=s.includes(e.delim)?e.delim:s[0];return e.delim||/^\d/.test(t)||!/^(\*|[\w]+)$/.test(t)?`${r}${String(t||"").replace(new RegExp(r,"g"),r.repeat(2))}${r}`:t}_stringifyKeyword(e){return String(e.value)}_stringifyOperator(e){return e.value===":"&&this.#r?.isProperty?"\\:":String(e.value)}_stringifyPunctuation(e){return String(e.value)}_stringifyDataType(e){return String(e.value)}_stringifyLiteral(e,t){let{value:s}=e;switch(e.type){case"bit_literal":return this._stringifyBitLiteral(e,t);case"hex_literal":return this._stringifyHexLiteral(e,t);case"number_literal":return this._stringifyNumberLiteral(e,t);case"string_literal":return this._stringifyStringLiteral(e,t);case"bool_literal":return/^true$/i.test(s+"")?"TRUE":"FALSE";case"null_literal":return"NULL"}return String(s)}_stringifyBindVar(e){let{value:t}=e;return this.options.dialect==="mysql"?"?":`$${t}`}_stringifyBitLiteral(e){let{value:t}=e;return this.options.dialect==="mysql"?`0b${t}`:`B'${t}'`}_stringifyHexLiteral(e){let{value:t}=e;return this.options.dialect==="mysql"?`0x${t}`:`X'${t}'`}_stringifyNumberLiteral(e){let{value:t}=e;return String(t)}_stringifyStringLiteral(e){let{value:t}=e,s=["'"],r=null;this.options.dialect==="postgres"&&e.delim?.startsWith("$")?s.fill(e.delim):this.options.dialect==="mysql"&&!this.options.mysqlAnsiQuotes&&s.push('"');let n=s.includes(e.delim)?e.delim:s[0];if((this.options.dialect==="mysql"&&!this.options.mysqlNoBackslashEscapes||this.options.dialect==="postgres"&&e.modifier==="E")&&(r="\\"),n.length>1)return`${n}${t}${n}`;if(!r)r=n;else if(r==="\\"){let a={"\\":"\\\\","\0":"\\0","\b":"\\b","\f":"\\f","\n":"\\n","\r":"\\r","	":"\\t","\v":"\\v","":"\\Z"};t=t.replace(/[\\\0\b\r\n\t\x1A]/g,o=>a[o])}return t=`${n}${(t||"").replace(new RegExp(n,"g"),`${r}${n}`)}${n}`,e.modifier?`${e.modifier}${t}`:t}_stringifyVariable(e){let{type:t,value:s}=e;return this.options.dialect==="mysql"?`${t==="system_var"?"@@":"@"}${s}`:`${this.#r?.isProperty?"\\:":":"}${s}`}_stringifyComment(e,t={}){let{value:s}=e;if(e.type==="block_comment"){let a="  ".repeat(t.startingIndentLevel||0),o=s.trim().split(`
`).map(l=>l.trim());return[`${a}/**`,...o.map(l=>`${a} * ${l}`),`${a} */`].join(`
`)}let r=["--"];return this.options.dialect==="mysql"&&r.push("#"),`${r.includes(e.delim)?e.delim:r[0]} ${s}`}},Ha=c=>Object.keys(c).filter(e=>!_i.has(e)),_i=new Set(["dialect","autoSpacing","optionalParens","autoIndent","autoIndentAdjust","type","value","delim","modifier","syntax","syntaxes","as","booleanfy","if","arity","itemSeparator","singletons","keyed","requiredSpacing","peek","optional","assert"]),fa=(c,e,t)=>[].concat(c).some(s=>{if(ne(s))return Object.entries(s).every(([n,a])=>{let o=!0;return n.startsWith("!")&&(n=n.slice(1),o=!1),(Array.isArray(a)?a.includes(e[n]):e[n]===a)===o});if(typeof s!="string")throw new SyntaxError(`[${t}] A specifier of type string or object expected in inferenceMatch but got ${s===null?"null":`type ${typeof s}`}`);let r=!0;return s.startsWith("!")&&(s=s.slice(1),r=!1),![void 0,null,!1].includes(e[s])===r});function st(c,e=!1){if(c==="*")c={"*":["*"]};else if(Array.isArray(c)&&c.length)c=c.reduce((t,s,r)=>{let n;if(!(typeof s=="object"&&s)||!(n=Object.keys(s)).length||n.filter(u=>u!=="namespace"&&u!=="tables"&&u!=="name").length)throw new SyntaxError(`Given selector ${JSON.stringify(c)} invalid at index ${r}`);let a=s.namespace||"*",o=s.tables||s.name||"*";return{...t,[a]:[...new Set((t[a]||[]).concat(o))]}},{});else if(typeof c=="object"&&c&&Object.keys(c).length)c=Object.fromEntries(Object.entries(c).map(([t,s])=>[t,[].concat(s)]));else throw new SyntaxError(`Given selector ${JSON.stringify(c)} invalid`);return e&&(c=new Set(Object.entries(c).reduce((t,[s,r])=>t.concat([].concat(r).map(n=>JSON.stringify([s,n]))),[]))),c}function gi(c){let[e,t,s,r]=c.reduce(([n,a,o,u],l)=>/^!%|^!.+%$/.test(l)?[n,a,o,u.concat(l.slice(1))]:/^%|%$/.test(l)?[n,a,o.concat(l),u]:/^!/.test(l)?[n,a.concat(l.slice(1)),o,u]:[n.concat(l),a,o,u],[[],[],[],[]]);return[e,t,s,r]}function Bt(c,e){let[t,s,r,n]=gi(e),a=t.length?t.includes(c)||t.length===1&&t[0]==="*":!1,o=s.length?!s.includes(c):!1,u=r.length?r.some(m=>new RegExp(m.replace("%",".+?")).test(c)):!1,l=n.length?!n.some(m=>new RegExp(m.replace("%",".+?")).test(c)):!1;return[a,o,u,l].some(m=>m)}function qe(...c){let e,t={};return typeof c[0]=="object"&&c[0]&&typeof c[0].query=="string"?{query:e,...t}=c[0]:typeof c[0]=="object"&&c[0]&&typeof c[0].text=="string"?{text:e,...t}=c[0]:typeof c[0]=="object"&&c[0]&&typeof c[0].url=="string"?{url:e,...t}=c[0]:(e=c.shift(),Array.isArray(c[0])&&(t.values=c.shift()),typeof c[0]=="function"&&(t.callback=c.shift()),typeof c[0]=="object"&&c[0]&&(t={...t,...c.shift()})),[e,t]}function pe(c,e,t=null){if(Array.isArray(c)&&Array.isArray(e)){if(c.length!==e.length)return!1;for(let[n,a]of c.entries())if(!pe(a,e[n]))return!1;return!0}if(!(c instanceof w)||!(e instanceof w))return z(c,e);if(!(c instanceof e.constructor)&&!(e instanceof c.constructor))return!1;if(c instanceof y.BinaryExpr){let n=o=>[c,e].every(u=>o.includes(u.operator())),a;if(n([a="AND"])||n([a="OR"])||t==="AND~"&&(c.operator()==="AND"||e.operator()==="AND")&&(a="AND")){let o=pa(c,a),u=pa(e,a);return Ei(o,u,t||a)}if(n(["=","=="])||n(["!=","<>"])||c.operator()===e.operator()&&["IS","IS NOT","DISTINCT FROM"].includes(c.operator()))return pe(c.left(),e.left())&&pe(c.right(),e.right())||pe(c.right(),e.left())&&pe(c.left(),e.right());if(c.operator()==="<"&&e.operator()===">"||c.operator()==="<="&&e.operator()===">="||c.operator()===">"&&e.operator()==="<"||c.operator()===">="&&e.operator()==="<=")return pe(c.right(),e.left())&&pe(c.left(),e.right())}let s=new Set(c._keys().filter(n=>c._get(n)!==void 0)),r=new Set(e._keys().filter(n=>e._get(n)!==void 0));if(s.size!==r.size)return!1;for(let n of new Set([...s,...r]))if(!s.has(n)||!r.has(n)||!pe(c._get(n),e._get(n)))return!1;return!0}function Ei(c,e,t="AND"){if(t==="OR"){for(let[r,n]of c.entries())if(!pe(n,e[r]))return!1;return!0}let s=new Set(e);e:for(let r of c){for(let n of s)if(pe(r,n)){s.delete(n);continue e}return!1}return t==="AND~"?s:s.size===0}function pa(c,e="AND"){return c instanceof y.BinaryExpr&&c.operator()===e?pa(c.left(),e).concat(c.right()):[c]}var ma={};Ie(ma,{CTE:()=>nr,CTEItem:()=>ar,CTEItemAlias:()=>ir,PGCycleClause:()=>rr,PGSearchClause:()=>sr});var rr=class extends w{static get syntaxRules(){return{dialect:"postgres",syntax:[{type:"keyword",value:"CYCLE"},{assert:!0,syntax:[{type:"ColumnRef1",as:"column_names",arity:{min:1},itemSeparator:{type:"punctuation",value:","},assert:!0,autoIndent:2},{type:"keyword",value:"SET"},{type:"ColumnRef1",as:"mark_col_name"},{optional:!0,syntax:[{type:"keyword",value:"TO"},{type:"Expr",as:"mark_value"},{type:"keyword",value:"DEFAULT"},{type:"Expr",as:"mark_default"}]},{type:"keyword",value:"USING"},{type:"ColumnRef1",as:"path_col_name"}]}]}}breadthOrDepthFirst(){return this._get("breadth_or_depth_first")}columnNames(){return this._get("column_names")}markColName(){return this._get("mark_col_name")}markValue(){return this._get("mark_value")}markDefault(){return this._get("mark_default")}pathColName(){return this._get("path_col_name")}};var sr=class extends w{static get syntaxRules(){return{dialect:"postgres",syntax:[{type:"keyword",value:"SEARCH"},{assert:!0,syntax:[{type:"keyword",as:"breadth_or_depth_first",value:["BREADTH","DEPTH"]},{type:"keyword",value:"FIRST"},{type:"keyword",value:"BY"},{type:"ColumnRef1",as:"column_names",arity:{min:1},itemSeparator:{type:"punctuation",value:","},assert:!0,autoIndent:2},{type:"keyword",value:"SET"},{type:"ColumnRef1",as:"seq_col_name"}]}]}}breadthOrDepthFirst(){return this._get("breadth_or_depth_first")}columnNames(){return this._get("column_names")}seqColName(){return this._get("seq_col_name")}};var X=c=>class extends c{#e;resultSchema(){return this.#e}static fromJSON(e,t={},s=null){if(!e||e instanceof w)return super.fromJSON(e,t,s);let{result_schema:r,...n}=e,a=super.fromJSON(n,t,s);if(a&&r){if(!(r instanceof w))throw new Error("Invalid Schema object passed at inputJson.result_schema");a.#e=r}return a}jsonfy(e={},t=null,s=null){let r=super.jsonfy(e,t,s);return this.#e&&e.resultSchemas!==!1&&(r={...r,result_schema:this.#e}),r}};var Ka=c=>class extends c{#e;originSchemas(){return this.#e}static fromJSON(e,t={},s=null){if(!e||e instanceof w)return super.fromJSON(e,t,s);let{origin_schemas:r,...n}=e,a=super.fromJSON(n,t,s);if(a&&r){if(!Array.isArray(r))throw new Error("Invalid list passed at inputJson.origin_schemas");a.#e=r}return a}jsonfy(e={},t=null,s=null){let r=super.jsonfy(e,t,s);return this.#e&&e.originSchemas!==!1&&(r={...r,origin_schemas:this.#e}),r}getOriginSchemas(e){let t=[],s=!1;for(let{resultSchema:r}of e.statementContext.artifacts.get("tableSchemas")){if(r instanceof y.JSONSchema){if(s)throw new Error("Multiple anonymous origin schemas detected");s=!0}t.push(r)}return t}};var We=class extends w{get statementNode(){return this}#e;get uuid(){return this.#e||(this.#e=`$query${(0|Math.random()*9e6).toString(36)}`),this.#e}static fromJSON(e,t={},s=null){if(e instanceof w)return super.fromJSON(e,t,s);let{uuid:r,...n}=e,a=super.fromJSON(n,t,s);return a&&(a.#e=r),a}jsonfy(e={},t=null,s=null){let r=super.jsonfy(e,t,s);return this.#e&&(r={uuid:this.#e,...r}),r}};var Se=class extends X(Ka(We)){renderBindings(e){if(!Array.isArray(e))throw new Error("Values must be an array");let t=[...this.queryBindings()];for(let s=0;s<e.length;s++){let r=t.filter(n=>n.offset()===s+1);if(!r.length)throw new Error(`No bindings exists at offset #${s}`);r.forEach(n=>n.value(e[s]))}}normalizeBindings(e=!1){let t=[...this.queryBindings()];if(!e)return t.forEach((n,a)=>n.offset(a+1)),t;let s=new Map,r=1;for(let n of t)if(n.offset()===0||!s.has(n.offset())){let a=r++;s.set(n.offset(),a),n.offset(a)}else n.offset(s.get(n.offset())).withDetail("redundant",!0);return t.filter(n=>!n.getDetail("redundant"))}};var te=class c{#e;get cb(){return this.#e}#t=new Map;#r=new Map;#n;get parentTransformer(){return this.#n}#i;get statementNode(){return this.#i}get statementContext(){return this.#a?this:this.#n.statementContext}get rootContext(){return this.#n?.rootContext||this}#a;get isStatementContext(){return this.#a}#s=new Map([["outputSchemas",new Set],["tableSchemas",new Set],["selectorDimensions",new Map],["payloadDimensions",new Set]]);get artifacts(){return this.#s}constructor(e,t=null,s=null){this.#e=e,this.#n=t,this.#i=s,this.#a=!t||s!==t.statementNode}rand(e,{asSalt:t=!1,rands:s=this.#t}={}){return s.set(e,s.has(e)?s.get(e)+1:0),`${t?"~":"$"}${e}~${s.get(e)}`}hash(e,t,{hashes:s=this.#r}={}){return s.has(e)||s.set(e,this.rand(t)),s.get(e)}transform(e,t,s,r,n=this){let a=(o=r,u=n)=>(typeof o=="function"&&(u=new c(o,u,this.#i),o=r),n.statementNode!==this.#i?t(o,u):this.#e(e,(l=o)=>(typeof l=="function"&&(u=new c(l,u,this.#i),l=o),t(l,u)),s,o));return this.#n?this.#n.transform(e,a,s,r,n):a()}};var nr=class extends Se{static get _bodyTypes(){return["SelectStmt","TableStmt","InsertStmt","UpsertStmt","UpdateStmt","DeleteStmt","ValuesConstructor"]}static get syntaxRules(){return[{type:"keyword",value:"WITH"},{type:"keyword",as:"recursive",value:"RECURSIVE",booleanfy:!0,optional:!0},{type:"CTEItem",as:"declarations",arity:{min:1},itemSeparator:{type:"punctuation",value:","},assert:!0,autoIndent:2},{type:this._bodyTypes,as:"body",assert:!0,autoSpacing:`
`}]}recursive(){return this._get("recursive")}declarations(){return this._get("declarations")}body(){return this._get("body")}jsonfy(e={},t=null,s=null){if(!e.deSugar)return super.jsonfy(e,t,s);let r;return t=new te((a,o,u)=>{if(u==="body"&&a.parentNode===this){let l=o();return r=l.result_schema,l}return o()},t,this),{...super.jsonfy(e,t,s),result_schema:r}}};var ar=class extends Se{static get syntaxRules(){return[{type:"CTEItemAlias",as:"alias",assert:!0},{type:"keyword",value:"AS"},{optional:!0,dialect:"postgres",syntaxes:[[{type:"operator",as:"not_materialized_kw",value:"NOT",booleanfy:!0},{type:"keyword",value:"MATERIALIZED",assert:!0}],{type:"keyword",as:"materialized",value:"MATERIALIZED",booleanfy:!0}]},{type:"paren_block",syntax:{type:["SelectStmt","InsertStmt","UpsertStmt","UpdateStmt","DeleteStmt","TableStmt","ValuesConstructor"],as:"expr",autoIndent:!0}},{type:"PGSearchClause",as:"search_clause",optional:!0},{type:"PGCycleClause",as:"cycle_clause",optional:!0}]}alias(){return this._get("alias")}notMaterializedKW(){return this._get("not_materialized_kw")}materialized(){return this._get("materialized")}expr(){return this._get("expr")}searchClause(){return this._get("search_clause")}cycleClause(){return this._get("cycle_clause")}jsonfy(e={},t=null,s=null){let r=super.jsonfy(e,t,s);if(e.deSugar){let n={nodeName:y.Identifier.NODE_NAME,value:r.alias.value,delim:r.alias.delim},a=r.expr.result_schema;if(a instanceof y.TableSchema?a=a.clone({renameTo:n}):a=y.TableSchema.fromJSON({name:n,entries:a?.entries().map(o=>o.jsonfy())||[]}),r.alias.columns?.length){if(r.alias.columns.length!==a.length)throw new SyntaxError(`[${this}] Number of column aliases must match number of result columns.`);a=a.clone({},new te((o,u,l)=>typeof l=="number"&&o.parentNode===a?o instanceof y.ColumnSchema?o.jsonfy({renameTo:r.alias.columns[l]}):{...o.jsonfy(),nodeName:y.ColumnSchema.NODE_NAME,name:r.alias.columns[l]}:u()))}t.statementContext.artifacts.get("tableSchemas").add({type:"CTEItem",resultSchema:a}),r={...r,result_schema:a}}return r}};var ue=class c extends w{static get syntaxRules(){return{type:"identifier",as:"."}}static get syntaxPriority(){return-1}value(){return this._get("value")}identifiesAs(e,t=void 0){return e instanceof c?z(this.value(),e.value(),t===void 0?this._has("delim")||e._has("delim"):t):typeof e=="string"?z(this._get("value"),e,t===void 0?this._has("delim"):t):super.identifiesAs(e,t)}};var ir=class extends ue{static get syntaxRules(){let e={type:"punctuation",value:","};return[{...[].concat(super.syntaxRules)[0]},{type:"paren_block",syntax:{type:"Identifier",as:"columns",arity:{min:1},itemSeparator:e,assert:!0},if:"value",optional:!0,optionalParens:!0}]}columns(){return this._get("columns")}};var ya={};Ie(ya,{CheckConstraint:()=>gr,ColumnDefaultConstraint:()=>Er,ColumnDiff:()=>or,ColumnExpressionConstraint:()=>Nr,ColumnFKConstraint:()=>xr,ColumnIdent:()=>Ss,ColumnIdentityConstraint:()=>dt,ColumnNullConstraint:()=>Sr,ColumnPKConstraint:()=>wr,ColumnSchema:()=>lr,ColumnUKConstraint:()=>Ar,ConstraintSchema:()=>Z,CreateSchemaStmt:()=>Cs,CreateTableStmt:()=>ks,DDLStmt:()=>Oe,DropSchemaStmt:()=>Is,DropTableStmt:()=>Ds,FKDeleteRule:()=>cr,FKMatchRule:()=>ur,FKUpdateRule:()=>fr,IndexDiff:()=>Os,IndexSchema:()=>vs,MYColumnAutoIncrementModifier:()=>yt,MYColumnCommentModifier:()=>Or,MYColumnOnUpdateModifier:()=>vr,MYColumnVisibilityModifier:()=>br,NamespaceIdent:()=>ws,NamespaceSchema:()=>wt,PGIndexParamInclude:()=>mr,PGIndexParamUsing:()=>yr,PGIndexParamWith:()=>dr,PGIndexParameters:()=>pr,PGTableEXConstraint:()=>Tr,PGTableEXConstraintItem:()=>hr,ReferentialAction:()=>_r,SchemaDiff:()=>bs,TableDiff:()=>Ts,TableFKConstraint:()=>Rr,TableIdent:()=>As,TablePKConstraint:()=>Cr,TableSchema:()=>Rs,TableUKConstraint:()=>Ir});var L=class extends w{static get syntaxRules(){return[]}get length(){return(this._get("entries")||[]).length}[Symbol.iterator](){return(this._get("entries")||[])[Symbol.iterator]()}entries(){return(this._get("entries")||[]).slice(0)}delete(e){return this._delete("entries",e)}get(e){return this._get("entries",e)}set(e,t){return this._set("entries",e,t)}has(e){return this._has("entries",e)}add(...e){return this._add("entries",...e)}};var ke=class extends L{};var or=class extends ke{};var we=class c extends L{name(){return this._get("name")}identifiesAs(e,...t){return this.name()?.identifiesAs(e instanceof c?e.name():e,...t)}static fromJSON(e,t={},s=null){if(e instanceof w)return super.fromJSON(e,t,s);let{ddl_name:r,...n}=e,a=super.fromJSON(n,t,s);if(r&&a){let o=[y.NamespaceIdent,y.TableIdent,y.ColumnIdent].reduce((u,l)=>u||l.fromJSON(r),null);a._set("ddl_name",o)}return a}jsonfy({renameTo:e,...t}={},s=null,r=null){let n=super.jsonfy(t,s,r);if(e){if(e instanceof w)throw new Error("options.renameTo must be a JSON value.");return n.name?.value&&!n.ddl_name&&(n={...n,ddl_name:n.name}),{...n,name:e}}return n}};var lr=class extends we{static get syntaxRules(){return[{type:["ColumnIdent","Identifier"],as:"name"},{type:"DataType",as:"data_type"},{type:["CheckConstraint","ColumnDefaultConstraint","ColumnExpressionConstraint","ColumnFKConstraint","ColumnIdentityConstraint","ColumnNullConstraint","ColumnPKConstraint","ColumnUKConstraint","MYColumnAutoIncrementModifier","MYColumnCommentModifier","MYColumnOnUpdateModifier","MYColumnVisibilityModifier"],as:"entries",arity:1/0,singletons:!0,optional:!0}]}dataType(){return this._get("data_type")}defaultConstraint(){for(let e of this)if(e instanceof y.ColumnDefaultConstraint)return e}expressionConstraint(){for(let e of this)if(e instanceof y.ColumnExpressionConstraint)return e}identityConstraint(){for(let e of this)if(e instanceof y.ColumnIdentityConstraint)return e}autoIncrementConstraint(){for(let e of this)if(e instanceof y.MYColumnAutoIncrementModifier)return e}nullConstraint(){for(let e of this)if(e instanceof y.ColumnNullConstraint)return e}pkConstraint(e=!1){for(let t of this)if(t instanceof y.ColumnPKConstraint)return t;if(e&&this.parentNode instanceof y.TableSchema){let t=this.parentNode.pkConstraint(!1),s=t?.columns()||[];if(s.length===1&&s[0].identifiesAs(this.name())){let{nodeName:r,columns:n,...a}=t.jsonfy(),o=y.ColumnPKConstraint.fromJSON(a);return this._adoptNodes(o),o}}}fkConstraint(e=!1){for(let t of this)if(t instanceof y.ColumnFKConstraint)return t;if(e&&this.parentNode instanceof y.TableSchema){let{nodeName:t,columns:s,...r}=this.parentNode.fkConstraints(!1).find(n=>{let a=n.columns();return a.length===1&&a[0].identifiesAs(this.name())})?.jsonfy()||{};if(t){let n=y.ColumnFKConstraint.fromJSON(r);return this._adoptNodes(n),n}}}ukConstraint(e=!1){for(let t of this)if(t instanceof y.ColumnUKConstraint)return t;if(e&&this.parentNode instanceof y.TableSchema){let{nodeName:t,columns:s,...r}=this.parentNode.ukConstraints(!1).find(n=>{let a=n.columns();return a.length===1&&a[0].identifiesAs(this.name())})?.jsonfy()||{};if(t){let n=y.ColumnUKConstraint.fromJSON(r);return this._adoptNodes(n),n}}}ckConstraint(e=!1){for(let t of this)if(t instanceof y.CheckConstraint)return t;if(e&&this.parentNode instanceof y.TableSchema){let t=this.parentNode.ckConstraints(!1).find(s=>{let r=s.columns();return r.length===1&&r[0].identifiesAs(this.name())});if(t=t?.clone())return this._adoptNodes(t),t}}jsonfy({normalized:e=!1,...t}={},s=null,r=null){let n=super.jsonfy(t,s,r);if(e){let a=[];for(let o of["pk","fk","uk","ck"]){let u=`${o}Constraint`;this[u]()||a.push(this[u](!0)?.jsonfy())}if((a=a.filter(o=>o)).length)return{...n,entries:n.entries.concat(a)}}return n}};var ur=class extends w{static get syntaxRules(){return[{type:"keyword",value:"MATCH"},{type:"keyword",as:"value",value:["FULL","PARTIAL","SIMPLE"],assert:!0}]}value(){return this._get("value")}};var cr=class extends w{static get syntaxRules(){return[{type:"keyword",value:"ON"},{type:"keyword",value:"DELETE"},{type:"ReferentialAction",as:"action",assert:!0}]}action(){return this._get("action")}};var fr=class extends w{static get syntaxRules(){return[{type:"keyword",value:"ON"},{type:"keyword",value:"UPDATE"},{type:"ReferentialAction",as:"action",assert:!0}]}action(){return this._get("action")}};var pr=class extends L{static get syntaxRules(){return[{type:["PGIndexParamInclude","PGIndexParamUsing","PGIndexParamWith"],as:"entries",arity:1/0,singletons:!0}]}};var mr=class extends L{static get syntaxRules(){return[{type:"keyword",value:"INCLUDE"},{type:"paren_block",syntax:{type:"ColumnRef2",as:"entries",arity:{min:1},itemSeparator:{type:"punctuation",value:","}}}]}};var yr=class extends w{static get syntaxRules(){return[{type:"keyword",value:"USING"},{type:"keyword",value:"INDEX"},{type:"keyword",value:"TABLESPACE"},{type:"identifier",as:"."}]}};var dr=class extends L{static get syntaxRules(){return[{type:"keyword",value:"WITH"},{type:"paren_block",syntax:{type:"ConfigAssignmentExprAlt2",as:"entries",arity:{min:1},itemSeparator:{type:"punctuation",value:","}}}]}};var Z=class extends we{static buildSyntaxRules(e){return[{optional:!0,syntax:[{type:"keyword",value:"CONSTRAINT"},{type:"Identifier",as:"name",assert:!0}]},...e,{optional:!0,dialect:"postgres",syntaxes:[[{type:"operator",as:"pg_deferrable",value:"NOT"},{type:"keyword",value:"DEFERRABLE"}],{type:"keyword",as:"pg_deferrable",value:"DEFERRABLE"}]},{optional:!0,dialect:"postgres",syntax:[{type:"keyword",value:"INITIALLY"},{type:"keyword",as:"pg_deferred",value:["DEFERRED","IMMEDIATE"]}]}]}static get syntaxRules(){return{type:["TableFKConstraint","TablePKConstraint","TableUKConstraint","CheckConstraint","ColumnDefaultConstraint","ColumnExpressionConstraint","ColumnFKConstraint","ColumnIdentityConstraint","ColumnNullConstraint","ColumnPKConstraint","ColumnUKConstraint"]}}get isColumnLevel(){return this.parentNode instanceof y.ColumnSchema}pgDeferrable(){return this._get("pg_deferrable")}pgDeferred(){return this._get("pg_deferred")}};var hr=class extends Z{static get syntaxRules(){return[{syntaxes:[{type:"ColumnRef2",as:"expr"},{type:"ParenExpr",as:"expr"}]},{optional:!0,syntax:[{type:"operator",value:"COLLATE"},{type:"string_literal",as:"collation",assert:!0}]},{optional:!0,syntax:[{type:"Identifier",as:"opclass"},{optional:!0,type:"paren_block",syntax:{type:"ConfigAssignmentExpr",as:"opclass_parameters",arity:{min:1},itemSeparator:{type:"punctuation",value:","},assert:!0}}]},{type:"keyword",value:["ASC","DESC"],as:"dir",optional:!0},{optional:!0,syntax:[{type:"keyword",value:"NULLS"},{type:"keyword",as:"nulls_spec",value:["FIRST","LAST"],assert:!0}]},{type:"keyword",value:"WITH"},{type:"operator",as:"operator"}]}expr(){return this._get("expr")}collation(){return this._get("collation")}opclass(){return this._get("opclass")}opclassParameters(){return this._get("opclass_parameters")}dir(){return this._get("dir")}nullsSpec(){return this._get("nulls_spec")}operator(){return this._get("operator")}};var _r=class extends w{static get syntaxRules(){return{syntaxes:[{type:"keyword",as:"value",value:["NO ACTION","RESTRICT","CASCADE"]},[{type:"keyword",as:"value",value:["SET NULL","SET DEFAULT"]},{optional:!0,dialect:"postgres",type:"paren_block",syntax:{type:"Identifier",as:"columns",arity:{min:1},itemSeparator:{type:"punctuation",value:","}}}]]}}value(){return this._get("value")}columns(){return this._get("columns")}};var gr=class extends Z{static get syntaxRules(){return this.buildSyntaxRules([{type:"keyword",value:"CHECK"},{type:"paren_block",syntax:{type:"Expr",as:"expr",assert:!0},assert:!0},{type:"keyword",as:"no_inherit_kw",value:"NO INHERIT",optional:!0}])}expr(){return this._get("expr")}noInheritKW(){return this._get("no_inherit_kw")}columns(){let e=[];return this.expr()?.walkTree(t=>{if(t instanceof y.ColumnRef1)e.push(y.ColumnRef2.fromJSON({value:t.value()}));else return t}),e}};var Er=class extends Z{static get syntaxRules(){return this.buildSyntaxRules([{type:"keyword",value:"DEFAULT"},{type:"Expr",as:"expr",assert:!0,dialect:"postgres"},{type:["NumberLiteral","StringLiteral","NullLiteral","BoolLiteral","CallExpr","RowConstructor"],as:"expr",assert:!0,dialect:"mysql"}])}expr(){return this._get("expr")}};var Nr=class extends Z{static get syntaxRules(){return this.buildSyntaxRules([{dialect:"postgres",syntax:[{type:"keyword",value:"GENERATED"},{type:"keyword",value:"ALWAYS"},{type:"keyword",value:"AS"},{type:"paren_block",syntax:{type:"Expr",as:"expr",assert:!0}},{type:"keyword",as:"stored",value:"STORED",assert:!0}]},{dialect:"mysql",syntax:[{optional:!0,syntax:[{type:"keyword",as:"my_generated_kw",value:"GENERATED",booleanfy:!0},{type:"keyword",value:"ALWAYS"}]},{type:"keyword",value:"AS"},{type:"paren_block",syntax:{type:"Expr",as:"expr",assert:!0}},{type:"keyword",as:"stored",value:["STORED","VIRTUAL"],optional:!0}]}])}myGeneratedKW(){return this._get("my_generated_kw")}expr(){return this._get("expr")}stored(){return this._get("stored")}};var{ColumnSchema:Ni,ColumnRef2:xi}=y,xr=class extends Z{static get syntaxRules(){let e={type:"punctuation",value:","};return this.buildSyntaxRules([{type:"keyword",value:"REFERENCES"},{type:"TableRef2",as:"target_table",assert:!0},{dialect:"postgres",optional:!0,type:"paren_block",syntax:{type:"Identifier",as:"target_columns",arity:1,itemSeparator:e,singletons:"BY_KEY",assert:!0}},{dialect:"mysql",type:"paren_block",syntax:{type:"Identifier",as:"target_columns",arity:1,itemSeparator:e,singletons:"BY_KEY",assert:!0}},{type:["FKMatchRule","FKDeleteRule","FKUpdateRule"],as:"referential_rules",arity:1/0,singletons:!0}])}targetTable(){return this._get("target_table")}targetColumns(){return this._get("target_columns")}referentialRules(){return this._get("referential_rules")}columns(){return this.parentNode instanceof Ni?[xi.fromJSON({value:this.parentNode.name().value()})]:[]}};var yt=class extends w{static get syntaxRules(){return{dialect:"mysql",syntax:{type:"keyword",as:".",value:"AUTO_INCREMENT"}}}jsonfy(e={},t=null,s=null){return(e.toDialect||this.options.dialect)==="postgres"?new dt().jsonfy(e,t,s):super.jsonfy(e,t,s)}};var dt=class extends Z{static get syntaxRules(){return this.buildSyntaxRules([{type:"keyword",value:"GENERATED"},{syntaxes:[{type:"keyword",as:"always_kw",value:"ALWAYS",booleanfy:!0},{syntax:[{type:"keyword",as:"by_default_kw",value:"BY",booleanfy:!0},{type:"keyword",value:"DEFAULT",assert:!0}]}]},{optional:!0,syntax:[{type:"keyword",as:"as_identity_kw",value:"AS",booleanfy:!0},{type:"keyword",value:"IDENTITY",assert:!0}]}])}alwaysKW(){return this._get("always_kw")}byDefaultKW(){return this._get("by_default_kw")}asIdentityKW(){return this._get("as_identity_kw")}jsonfy(e={},t=null,s=null){return(e.toDialect||this.options.dialect)==="mysql"?new yt().jsonfy(e,t,s):super.jsonfy(e,t,s)}};var Sr=class extends Z{static get syntaxRules(){return this.buildSyntaxRules([{syntaxes:[[{type:"operator",as:".",value:"NOT"},{type:"null_literal",value:"NULL"}],{type:"null_literal",as:".",value:"NULL"}]}])}value(){return this._get("value")}};var wr=class extends Z{static get syntaxRules(){return this.buildSyntaxRules([{type:"keyword",value:"PRIMARY"},{type:"keyword",as:".",value:"KEY",assert:!0},{type:"PGIndexParameters",as:"pg_index_parameters",optional:!0,dialect:"postgres"}])}primaryKW(){return this._get("primary_kw")}pgIndexParameters(){return this._get("pg_index_parameters")}columns(){return this.parentNode instanceof y.ColumnSchema?[y.ColumnRef2.fromJSON({value:this.parentNode.name().value()})]:[]}};var Ar=class extends Z{static get syntaxRules(){return this.buildSyntaxRules([{type:"keyword",value:"UNIQUE"},{type:"keyword",as:"my_key_kw",value:["KEY","INDEX"],optional:!0,dialect:"mysql"},{optional:!0,dialect:"postgres",syntaxes:[[{type:"keyword",value:"NULLS"},{type:"operator",as:"pg_nulls_distinct",value:"NOT"},{type:"keyword",value:"DISTINCT",assert:!0}],[{type:"keyword",value:"NULLS"},{type:"keyword",as:"pg_nulls_distinct",value:"DISTINCT",assert:!0}]]},{type:"PGIndexParameters",as:"pg_index_parameters",optional:!0,dialect:"postgres"}])}myKeyKW(){return this._get("my_key_kw")}pgNullsDistinct(){return this._get("pg_nulls_distinct")}pgIndexParameters(){return this._get("pg_index_parameters")}columns(){let{ColumnSchema:e,ColumnRef2:t}=y;return this.parentNode instanceof e?[t.fromJSON({value:this.parentNode.name().value()})]:[]}};var Or=class extends w{static get syntaxRules(){return{dialect:"mysql",syntax:[{type:"keyword",value:"COMMENT"},{type:"string_literal",as:"."}]}}};var vr=class extends w{static get syntaxRules(){return{dialect:"mysql",syntax:[{type:"keyword",value:"ON"},{type:"keyword",value:"UPDATE"},{type:"keyword",as:"."}]}}};var br=class extends w{static get syntaxRules(){return{dialect:"mysql",syntaxes:[{type:"keyword",as:".",value:"VISIBLE"},{type:"keyword",as:".",value:"INVISIBLE"}]}}};var Tr=class extends Z{static get syntaxRules(){let e={type:"punctuation",value:","};return{dialect:"postgres",syntax:this.buildSyntaxRules([{type:"keyword",value:"EXCLUDE"},{optional:!0,syntax:[{type:"keyword",value:"USING"},{type:"keyword",as:"index_method",assert:!0}]},{type:"paren_block",syntax:{type:"PGTableEXConstraintItem",as:"entries",arity:{min:1},itemSeparator:e,assert:!0},assert:!0},{type:"PGIndexParameters",as:"pg_index_parameters",optional:!0},{optional:!0,syntax:[{type:"keyword",value:"WHERE"},{type:"paren_block",syntax:{type:"Expr",as:"where_predicate",assert:!0},assert:!0}]}])}}indexMethod(){return this._get("index_method")}entries(){return this._get("entries")}pgIndexParameters(){return this._get("pg_index_parameters")}wherePredicate(){return this._get("where_predicate")}};var Rr=class extends Z{static get syntaxRules(){let e={type:"punctuation",value:","};return this.buildSyntaxRules([{type:"keyword",value:"FOREIGN"},{type:"keyword",value:"KEY",assert:!0},{type:"paren_block",syntax:{type:"ColumnRef2",as:"columns",arity:{min:1},itemSeparator:e,assert:!0,singletons:"BY_KEY"}},{type:"keyword",value:"REFERENCES"},{type:"TableRef2",as:"target_table",assert:!0},{dialect:"postgres",optional:!0,type:"paren_block",syntax:{type:"Identifier",as:"target_columns",arity:{min:1},itemSeparator:e,singletons:"BY_KEY",assert:!0}},{dialect:"mysql",type:"paren_block",syntax:{type:"Identifier",as:"target_columns",arity:{min:1},itemSeparator:e,singletons:"BY_KEY",assert:!0}},{type:["FKMatchRule","FKDeleteRule","FKUpdateRule"],as:"referential_rules",arity:1/0,assert:!0,singletons:!0}])}columns(){return this._get("columns")}targetTable(){return this._get("target_table")}targetColumns(){return this._get("target_columns")}referentialRules(){return this._get("referential_rules")}};var Cr=class extends Z{static get syntaxRules(){let e={type:"punctuation",value:","};return this.buildSyntaxRules([{type:"keyword",value:"PRIMARY"},{type:"keyword",as:".",value:"KEY",assert:!0},{type:"paren_block",syntax:{type:"ColumnRef2",as:"columns",arity:{min:1},itemSeparator:e,singletons:"BY_KEY",assert:!0},assert:!0},{type:"PGIndexParameters",as:"pg_index_parameters",optional:!0,dialect:"postgres"}])}columns(){return this._get("columns")}pgIndexParameters(){return this._get("pg_index_parameters")}};var Ir=class extends Z{static get syntaxRules(){let e={type:"punctuation",value:","};return this.buildSyntaxRules([{type:"keyword",value:"UNIQUE"},{type:"keyword",as:"my_key_kw",value:["KEY","INDEX"],optional:!0,dialect:"mysql"},{optional:!0,dialect:"postgres",syntaxes:[[{type:"keyword",value:"NULLS"},{type:"operator",as:"pg_nulls_distinct",value:"NOT"},{type:"keyword",value:"DISTINCT",assert:!0}],[{type:"keyword",value:"NULLS"},{type:"keyword",as:"pg_nulls_distinct",value:"DISTINCT",assert:!0}]]},{type:"paren_block",syntax:{type:"ColumnRef2",as:"columns",arity:{min:1},itemSeparator:e,singletons:"BY_KEY",assert:!0},assert:!0},{type:"PGIndexParameters",as:"pg_index_parameters",optional:!0,dialect:"postgres"}])}myKeyKW(){return this._get("my_key_kw")}pgNullsDistinct(){return this._get("pg_nulls_distinct")}columns(){return this._get("columns")}pgIndexParameters(){return this._get("pg_index_parameters")}};var He=c=>class extends c{static get _qualifierType(){return"Identifier"}static buildSyntaxRules(e=null){return[{optional:!0,syntax:[{type:this._qualifierType,as:"qualifier"},{type:"punctuation",value:".",autoSpacing:!1}]},e||{...[].concat(super.syntaxRules)[0],autoSpacing:!1}]}static get syntaxRules(){return this.buildSyntaxRules()}static get syntaxPriority(){return-1}qualifier(){return this._get("qualifier")}identifiesAs(e,t=void 0){let s=super.identifiesAs(e,t);return s&&this.qualifier()&&e.qualifier?.()?this.qualifier().identifiesAs(e.qualifier(),t):s}static async _parseFromRules(e,t,{left:s=void 0,minPrecedence:r=0,trail:n,...a},o={}){if(s)return super._parseFromRules(e,t,{left:s,minPrecedence:r,trail:n,...a},o);let u=[];for(;;){if(await e.match(1,"punctuation","."))u.push(await e.eat());else if(await e.match(1,"version_spec")&&await e.match(2,"punctuation","."))u.push(await e.eat()),u.push(await e.eat());else break;(await e.match(2,"punctuation",".")||await e.match(2,"version_spec")&&await e.match(3,"punctuation","."))&&u.push(await e.eat())}let l="qualifier";if(u.length){let m=[].concat(this._qualifierType),f=await this.toStream(u,a),p={minPrecedence:r,trail:n.concat(this.NODE_NAME,`<${l}>`),...a};s=await this._parseFromTypes(f,m,p)}else s=!1;return await super._parseFromRules(e,t,{left:s,minPrecedence:r,trail:n,...a},o)}};var Ae={};Ie(Ae,{AggrCallExpr:()=>Mr,AtTimeZoneExpr:()=>ns,BetweenExpr:()=>as,BinaryExpr:()=>re,BindVar:()=>Es,BitLiteral:()=>Jr,BoolLiteral:()=>Fr,CallExpr:()=>_t,CaseBranch:()=>Pr,CaseExpr:()=>Lr,CastExpr:()=>jr,ColumnRef0:()=>cs,ColumnRef1:()=>xt,ColumnRef2:()=>at,DefaultLiteral:()=>Gr,DistinctFromExpr:()=>is,Expr:()=>Gt,ExtractExpr:()=>Ur,HexLiteral:()=>qr,Identifier:()=>ue,InExpr:()=>os,LQArrayLiteral:()=>es,LQBackBackRef:()=>Ve,LQBackRef:()=>fs,LQBackRefAbstraction:()=>Ft,LQBackRefEndpoint:()=>ps,LQDeepDeepRef1:()=>Be,LQDeepDeepRef2:()=>ms,LQDeepRef1:()=>St,LQDeepRef2:()=>ys,LQObjectLiteral:()=>ts,LQObjectProperty:()=>rs,NamespaceRef:()=>ds,NullLiteral:()=>Wr,NumberLiteral:()=>Hr,PGCastExpr2:()=>ls,PGFilterClause:()=>kr,PGTypedArrayLiteral:()=>ss,PGWithinGroupClause:()=>Dr,ParenExpr:()=>Ke,PredicateExpr:()=>Br,QuantitativeExpr:()=>$r,RowConstructor:()=>nt,ScalarSubquery:()=>$t,StringLiteral:()=>Kr,SystemVar:()=>Ns,TableRef0:()=>hs,TableRef1:()=>Qe,TableRef2:()=>_s,TypedDateLiteral:()=>Yr,TypedIntervalLiteral:()=>zr,TypedLiteral:()=>Ee,TypedRowConstructor:()=>Jt,TypedTimeLiteral:()=>Vr,TypedTimeZoneLiteral:()=>Xr,TypedTimestampLiteral:()=>Qr,UnaryExpr:()=>us,UnknownLiteral:()=>Zr,UserVar:()=>xs,WindowRef:()=>gs});var De=c=>class extends c{dataType(){return y.DataType.fromJSON({value:"TEXT"})}};var ae=class extends De(w){};var Ke=class c extends ae{static get syntaxRules(){return{type:"paren_block",syntax:{type:"Expr",as:"expr"},autoIndent:!0}}static get syntaxPriority(){return-1}expr(){return this._get("expr")}exprUnwrapped(){let e=this._get("expr");return e instanceof c?e.exprUnwrapped():e}dataType(){return this.expr()?.dataType()}};var nt=class c extends X(De(L)){static get syntaxRules(){return{syntax:[{type:"paren_block",syntax:{type:["DerivedQuery","ValuesTableLiteral","Expr"],as:"entries",arity:1/0,itemSeparator:{type:"punctuation",value:","},autoIndent:10}}]}}static get syntaxPriority(){return 49}exprUnwrapped(){return this._get("entries")?.length===1&&this._get("entries")[0]instanceof c?this._get("entries")[0].exprUnwrapped():this}dataType(){return y.DataType.fromJSON({value:"SET"})}jsonfy(e={},t=null,s=null){let r=super.jsonfy(e,t,s);if(e.deSugar?.rowConstructorSchemas||e.forceDeSugar){let n=this.entries()||[],o=(r.entries||[]).map((u,l)=>{let m={nodeName:y.Identifier.NODE_NAME,value:l};return u.result_schema instanceof y.ColumnSchema?u.result_schema.clone({renameTo:m}):y.ColumnSchema.fromJSON({name:m,data_type:n[l].dataType().jsonfy()})});r={...r,result_schema:y.JSONSchema.fromJSON({entries:o},{assert:!0})}}return r}};var ht=class extends X(Ke){static get syntaxRules(){return{type:"paren_block",syntax:{type:["SelectStmt","TableStmt","CTE"],as:"expr",autoIndent:!0}}}static get syntaxPriority(){return-1}dataType(){return this.expr()?.dataType()}#e=!1;isCorrelated(){return this.#e}static fromJSON(e,t={},s=null){if(!e||e instanceof w)return super.fromJSON(e,t,s);let{is_correlated:r,...n}=e,a=super.fromJSON(n,t,s);if(a&&r){if(typeof r!="boolean")throw new Error("Invalid value passed at inputJson.is_correlated");a.#e=r}return a}jsonfy(e={},t=null,s=null){let r=t?.statementContext?.artifacts||new Map;r.set("derivedQueryCorrelationFlag",null);let n=super.jsonfy(e,t,s),a=r.get("derivedQueryCorrelationFlag");if(r.delete("derivedQueryCorrelationFlag"),e.deSugar){let o=n.expr?.result_schema;n={...n,is_correlated:!!a,result_schema:o}}else n={...n,is_correlated:this.#e};return n}};var $t=class extends ht{static get syntaxRules(){return{type:"paren_block",syntax:{type:["SelectStmt","CTE"],as:"expr"},autoIndent:!0}}static get syntaxPriority(){return 48}dataType(){return this.resultSchema()?this.resultSchema().dataType():y.DataType.fromJSON({value:"TEXT"})}jsonfy(e={},t=null,s=null){let r=super.jsonfy(e,t,s);if(e.deSugar){let n=r.expr?.result_schema;if(n?.length!==1)throw new Error("Scalar subqueries must return a scalar value.");n=n.entries()[0],r={...r,result_schema:n}}return r}};var Jt=class extends nt{static get syntaxRules(){return[{type:"keyword",value:"ROW"},...[].concat(super.syntaxRules)]}static get syntaxPriority(){return 52}};var kr=class extends w{static get syntaxRules(){return{dialect:"postgres",syntax:[{type:"keyword",value:"FILTER"},{type:"paren_block",syntax:{type:"WhereClause",as:"where_clause"},assert:!0,autoIndent:!0}]}}static get syntaxPriority(){return-1}whereClause(){return this._get("where_clause")}};var Dr=class extends w{static get syntaxRules(){return{dialect:"postgres",syntax:[{type:"keyword",value:"WITHIN"},{type:"keyword",value:"GROUP"},{type:"paren_block",syntax:{type:"OrderByClause",as:"order_by_clause"},assert:!0,autoIndent:!0}]}}static get syntaxPriority(){return-1}orderByClause(){return this._get("order_by_clause")}};var _t=class extends X(ae){static get syntaxRules(){let e={type:"punctuation",value:","};return{syntaxes:[{peek:[0,"keyword",["NOW","CURRENT_DATE","CURRENT_TIME","CURRENT_TIMESTAMP","IF","NULLIF","IFNULL","COALESCE","GREATEST","LEAST","CONCAT","CONCAT_WS","FORMAT","MD5","SHA1","TO_JSON","TO_JSONB","JSON_TYPEOF","JSONB_TYPEOF","JSON_BUILD_ARRAY","JSONB_BUILD_ARRAY","JSON_BUILD_OBJECT","JSONB_BUILD_OBJECT","JSON_POPULATE_RECORD","JSONB_POPULATE_RECORD","JSON_PATH_QUERY","JSON_PATH_EXISTS","JSON_ARRAY","JSON_OBJECT","JSON_EXTRACT","JSON_UNQUOTE","JSON_SET","JSON_INSERT","JSON_REPLACE","JSON_REMOVE","JSON_SEARCH","JSON_CONTAINS","JSON_CONTAINS_PATH","JSON_KEYS","JSON_ARRAY_APPEND","JSON_ARRAY_INSERT","JSON_DEPTH","JSON_LENGTH","JSON_MERGE_PRESERVE","JSON_MERGE_PATCH","JSON_PRETTY","JSON_STORAGE_FREE","ST_ASTEXT","ST_ASGEOJSON","ST_GEOMFROMTEXT","ST_WITHIN","ST_CONTAINS","ST_INTERSECTS","ST_DISTANCE","ST_BUFFER","MAKE_DATE","MAKE_TIME","MAKE_TIMESTAMP","ARRAY","CURDATE","CURTIME","SYSDATE","STR_TO_DATE","MAKEDATE","MAKETIME"]],syntaxes:[[{type:"keyword",as:"name",value:["CURRENT_DATE","CURRENT_TIME","CURRENT_TIMESTAMP"]},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:0,itemSeparator:e,assert:!0},optional:!0,optionalParens:!0,autoSpacing:!1}],[{type:"keyword",as:"name",value:["NOW"]},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:0,itemSeparator:e,assert:!0},optional:!0,autoSpacing:!1}],[{type:"keyword",as:"name",value:["IF","NULLIF","IFNULL"]},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:{min:2,max:3},itemSeparator:e,assert:!0},autoSpacing:!1}],[{type:"keyword",as:"name",value:["COALESCE","GREATEST","LEAST","CONCAT"]},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:{min:1},itemSeparator:e,assert:!0},autoSpacing:!1}],[{type:"keyword",as:"name",value:["CONCAT_WS","FORMAT"]},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:{min:2},itemSeparator:e,assert:!0},autoSpacing:!1}],[{type:"keyword",as:"name",value:["MD5","SHA1"]},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:1,itemSeparator:e,assert:!0},autoSpacing:!1}],[{type:"keyword",as:"name",value:["ST_ASTEXT","ST_ASGEOJSON","ST_GEOMFROMTEXT"]},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:1,itemSeparator:e,assert:!0},autoSpacing:!1}],[{type:"keyword",as:"name",value:["ST_WITHIN","ST_CONTAINS","ST_INTERSECTS","ST_DISTANCE","ST_BUFFER"]},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:2,itemSeparator:e,assert:!0},autoSpacing:!1}],{dialect:"postgres",syntax:[{type:"keyword",as:"name",value:["TO_JSON","TO_JSONB","JSON_TYPEOF","JSONB_TYPEOF"]},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:1,itemSeparator:e,assert:!0},autoSpacing:!1}]},{dialect:"postgres",syntax:[{type:"keyword",as:"name",value:["JSON_BUILD_ARRAY","JSONB_BUILD_ARRAY","JSON_BUILD_OBJECT","JSONB_BUILD_OBJECT"]},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:{min:0},itemSeparator:e,assert:!0},autoSpacing:!1}]},{dialect:"postgres",syntax:[{type:"keyword",as:"name",value:["JSON_POPULATE_RECORD","JSONB_POPULATE_RECORD","JSON_PATH_QUERY","JSON_PATH_EXISTS"]},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:2,itemSeparator:e,assert:!0},autoSpacing:!1}]},{dialect:"postgres",syntax:[{type:"keyword",as:"name",value:["ARRAY"]},{type:"paren_block",syntax:{type:"SelectStmt",as:"arguments",arity:1,itemSeparator:e,assert:!0},autoIndent:!0,autoSpacing:!0}]},{dialect:"postgres",syntax:[{type:"keyword",as:"name",value:["MAKE_DATE","MAKE_TIME","MAKE_TIMESTAMP"]},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:1/0,itemSeparator:e,assert:!0},autoSpacing:!1}]},{dialect:"mysql",syntax:[{type:"keyword",as:"name",value:["JSON_ARRAY","JSON_OBJECT","JSON_EXTRACT","JSON_UNQUOTE","JSON_SET","JSON_INSERT","JSON_REPLACE","JSON_REMOVE","JSON_SEARCH","JSON_CONTAINS","JSON_CONTAINS_PATH","JSON_KEYS","JSON_ARRAY_APPEND","JSON_ARRAY_INSERT","JSON_DEPTH","JSON_LENGTH","JSON_MERGE_PRESERVE","JSON_MERGE_PATCH","JSON_PRETTY","JSON_STORAGE_FREE"]},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:{min:1},itemSeparator:e,assert:!0},autoSpacing:!1}]},{dialect:"mysql",syntax:[{type:"keyword",as:"name",value:["CURDATE","CURTIME","SYSDATE"]},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:0,itemSeparator:e,optional:!0,assert:!0},autoSpacing:!1}]},{dialect:"mysql",syntax:[{type:"keyword",as:"name",value:"STR_TO_DATE"},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:2,itemSeparator:e,assert:!0},autoSpacing:!1}]},{dialect:"mysql",syntax:[{type:"keyword",as:"name",value:["MAKEDATE","MAKETIME"]},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:2,itemSeparator:e,assert:!0},autoSpacing:!1}]}]},[{type:"keyword",as:"name"},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:1/0,itemSeparator:e},autoSpacing:!1}],[{type:"identifier",as:"name"},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:1/0,itemSeparator:e},autoSpacing:!1}]]}}static get syntaxPriority(){return 51}name(){return this._get("name")}arguments(){return this._get("arguments")}};var Mr=class extends _t{static get syntaxRules(){let e={type:"punctuation",value:","},t={type:"keyword",as:"distinct",value:"DISTINCT",booleanfy:!0,optional:!0},s={optional:!0,syntax:[{type:"keyword",value:"SEPARATOR"},{type:"Expr",as:"separator",assert:!0}]},r={type:"OrderByClause",as:"order_by_clause",optional:!0},n={type:"PGFilterClause",as:"pg_filter_clause",optional:!0,dialect:"postgres"},a={type:"PGWithinGroupClause",as:"pg_within_group_clause",optional:!0,dialect:"postgres"},o={optional:!0,syntax:[{type:"keyword",as:"null_handling",value:["IGNORE","RESPECT"]},{type:"keyword",value:"NULLS",assert:!0}]},u={optional:!0,syntax:[{type:"keyword",value:"OVER"},{type:["WindowRef","WindowSpec"],as:"over_clause",assert:!0}]};return{peek:[0,"keyword",["COUNT","SUM","AVG","MIN","MAX","ARRAY_AGG","STRING_AGG","GROUP_CONCAT","REGR_SLOPE","COVAR_POP","COVAR_SAMP","CORR","PERCENTILE_CONT","PERCENTILE_DISC","MODE","RANK","DENSE_RANK","ROW_NUMBER","EVERY","BOOL_AND","BOOL_OR","BIT_AND","BIT_OR","BIT_XOR","JSON_AGG","JSON_ARRAYAGG","JSON_OBJECT_AGG","JSONB_OBJECT_AGG","JSON_OBJECTAGG","STDDEV_POP","STDDEV_SAMP","VAR_POP","VAR_SAMP","VARIANCE","STD","XMLAGG","LEAD","LAG","NTILE","FIRST_VALUE","LAST_VALUE"]],syntaxes:[[{type:"keyword",as:"name",value:"COUNT"},{type:"paren_block",syntax:[{dialect:"postgres",type:"ColumnRef0",as:"arguments",arity:1,assert:!1,itemSeparator:e},{dialect:"mysql",type:"ColumnRef0",as:"arguments",arity:1/0,assert:!1,itemSeparator:e,optional:!0}],autoSpacing:!1},{...n},{...u}],[{type:"keyword",as:"name",value:["COUNT","SUM","AVG","MIN","MAX"]},{type:"paren_block",syntax:[{...t},{type:"Expr",as:"arguments",arity:1,itemSeparator:e,assert:!0}],autoSpacing:!1},{...n},{...u}],{dialect:"postgres",syntax:[{type:"keyword",as:"name",value:"ARRAY_AGG"},{type:"paren_block",syntax:[{...t},{type:"Expr",as:"arguments",arity:{min:1},itemSeparator:e,assert:!0},{...r}],autoSpacing:!1},{...n},{...u}]},{dialect:"postgres",syntax:[{type:"keyword",as:"name",value:"STRING_AGG"},{type:"paren_block",syntax:[{...t},{type:"Expr",as:"arguments",arity:2,itemSeparator:e,assert:!0},{...r},{...s}],autoSpacing:!1},{...n},{...u}]},{dialect:"mysql",syntax:[{type:"keyword",as:"name",value:"GROUP_CONCAT"},{type:"paren_block",syntax:[{...t},{type:"Expr",as:"arguments",arity:{min:1},itemSeparator:e,assert:!0},{...r},{...s}],autoSpacing:!1},{...u}]},{dialect:"postgres",syntax:[{type:"keyword",as:"name",value:"REGR_SLOPE"},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:2,itemSeparator:e,assert:!0},autoSpacing:!1},{...n},{...u}]},[{type:"keyword",as:"name",value:["COVAR_POP","COVAR_SAMP","CORR"]},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:2,itemSeparator:e,assert:!0},autoSpacing:!1},{...n},{...u}],{dialect:"postgres",syntax:[{type:"keyword",as:"name",value:["PERCENTILE_CONT","PERCENTILE_DISC"]},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:1,itemSeparator:e,assert:!0},autoSpacing:!1},{...n},{...a,optional:!1}]},{dialect:"postgres",syntax:[{type:"keyword",as:"name",value:"MODE"},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:0,itemSeparator:e,assert:!0},autoSpacing:!1},{...n},{...a,optional:!1}]},{dialect:"postgres",syntax:[{type:"keyword",as:"name",value:["RANK","DENSE_RANK"]},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:0,itemSeparator:e,assert:!0},autoSpacing:!1},{...n},{...u,optional:!1}]},[{type:"keyword",as:"name",value:"ROW_NUMBER"},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:0,itemSeparator:e,assert:!0},autoSpacing:!1},{...u,optional:!1}],{dialect:"postgres",syntax:[{type:"keyword",as:"name",value:["EVERY","BOOL_AND","BOOL_OR"]},{type:"paren_block",syntax:[{...t},{type:"Expr",as:"arguments",arity:1,itemSeparator:e,assert:!0}],autoSpacing:!1},{...n},{...u}]},{dialect:"postgres",syntax:[{type:"keyword",as:"name",value:"JSON_AGG"},{type:"paren_block",syntax:[{...t},{type:"Expr",as:"arguments",arity:{min:1},itemSeparator:e,assert:!0}],autoSpacing:!1},{...n},{...u}]},{dialect:"mysql",syntax:[{type:"keyword",as:"name",value:"JSON_ARRAYAGG"},{type:"paren_block",syntax:[{...t},{type:"Expr",as:"arguments",arity:{min:1},itemSeparator:e,assert:!0}],autoSpacing:!1},{...u}]},{dialect:"mysql",syntax:[{type:"keyword",as:"name",value:"BIT_XOR"},{type:"paren_block",syntax:[{...t},{type:"Expr",as:"arguments",arity:1,itemSeparator:e,assert:!0}],autoSpacing:!1},{...u}]},[{type:"keyword",as:"name",value:["BIT_AND","BIT_OR"]},{type:"paren_block",syntax:[{...t},{type:"Expr",as:"arguments",arity:1,itemSeparator:e,assert:!0}],autoSpacing:!1},{...n},{...u}],{dialect:"postgres",syntax:[{type:"keyword",as:"name",value:["JSON_OBJECT_AGG","JSONB_OBJECT_AGG"]},{type:"paren_block",syntax:[{...t},{type:"Expr",as:"arguments",arity:2,itemSeparator:e,assert:!0}],autoSpacing:!1},{...n},{...u}]},{dialect:"mysql",syntax:[{type:"keyword",as:"name",value:"JSON_OBJECTAGG"},{type:"paren_block",syntax:[{...t},{type:"Expr",as:"arguments",arity:2,itemSeparator:e,assert:!0}],autoSpacing:!1},{...u}]},[{type:"keyword",as:"name",value:["STDDEV_POP","STDDEV_SAMP","VAR_POP","VAR_SAMP","VARIANCE","STD"]},{type:"paren_block",syntax:[{...t},{type:"Expr",as:"arguments",arity:1,itemSeparator:e,assert:!0}],autoSpacing:!1},{...n},{...u}],{dialect:"postgres",syntax:[{type:"keyword",as:"name",value:"XMLAGG"},{type:"paren_block",syntax:[{type:"Expr",as:"arguments",arity:1,itemSeparator:e,assert:!0},{...r}],autoSpacing:!1},{...n},{...u}]},[{type:"keyword",as:"name",value:["LEAD","LAG"]},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:{max:3},itemSeparator:e,optional:!0,assert:!0},autoSpacing:!1},{...o},{...u}],[{type:"keyword",as:"name",value:["NTILE","FIRST_VALUE","LAST_VALUE"]},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:1,itemSeparator:e,assert:!0},autoSpacing:!1},{...u,optional:!1}]]}}distinct(){return this._get("distinct")}orderByClause(){return this._get("order_by_clause")}separator(){return this._get("separator")}overClause(){return this._get("over_clause")}pgFilterClause(){return this._get("pg_filter_clause")}pgWithinGroupClause(){return this._get("pg_within_group_clause")}};var Lr=class extends De(L){static get syntaxRules(){return[{type:"keyword",value:"CASE"},{type:"Expr",as:"subject",optional:!0},{type:"CaseBranch",as:"entries",arity:{min:1},assert:!0,autoIndent:2},{optional:!0,syntax:[{type:"keyword",value:"ELSE"},{type:"Expr",as:"alternate",autoIndent:!0}],autoSpacing:`
`},{type:"keyword",value:"END",autoSpacing:`
`}]}subject(){return this._get("subject")}branches(){return this.entries()}alternate(){return this._get("alternate")}};var Pr=class extends w{static get syntaxRules(){return[{type:"keyword",value:"WHEN"},{type:"Expr",as:"condition"},{type:"keyword",value:"THEN"},{type:"Expr",as:"consequent"}]}static get syntaxPriority(){return-1}condition(){return this._get("condition")}consequent(){return this._get("consequent")}};var jr=class extends ae{static get syntaxRules(){return[{type:"keyword",value:"CAST"},{type:"paren_block",syntax:[{type:"Expr",as:"expr"},{type:"keyword",value:"AS"},{type:"DataType",as:"data_type",assert:!0}],assert:!0,autoSpacing:!1}]}expr(){return this._get("expr")}dataType(){return this._get("data_type")}};var re=class extends ae{static get syntaxRules(){return[{type:"Expr",as:"left",peek:[1,"operator",["NOT",void 0]]},{type:"operator",as:"negation",value:"NOT",booleanfy:!0,optional:!0},{type:"operator",as:"operator"},{type:"Expr",as:"right"}]}static get syntaxPriority(){return 0}left(){return this._get("left")}negation(){return this._get("negation")}operator(){return this._get("operator")}right(){return this._get("right")}dataType(){let e=this.operator();if(!e)return this.left()?.dataType();let t=this.options.dialect,r=new Map(tr.common.concat(tr[t])).get(e)?.resultType;if(r)return r===":right"?this.right()?.dataType():r===":left"?this.left()?.dataType():y.DataType.fromJSON({value:r.toUpperCase()})}};var Ur=class extends re{static get syntaxRules(){return[{type:"keyword",value:"EXTRACT"},{type:"paren_block",syntax:[{type:"Expr",as:"left"},{type:"keyword",value:"FROM"},{type:"Expr",as:"right",assert:!0}],autoSpacing:!1}]}left(){return this._get("left")}right(){return this._get("right")}};var Br=class extends ae{static get syntaxRules(){return[{type:"keyword",as:"predicate",value:["EXISTS"]},{type:"ScalarSubquery",as:"expr"}]}predicate(){return this._get("predicate")}expr(){return this._get("expr")}dataType(){return y.DataType.fromJSON({value:"BOOLEAN"})}};var $r=class extends w{static get syntaxRules(){return[{type:"keyword",as:"quantifier",value:["ALL","ANY","SOME"]},{syntaxes:[{type:"DerivedQuery",as:"expr"},{type:"paren_block",syntax:{type:"Expr",as:"expr"}}]}]}quantifier(){return this._get("quantifier")}expr(){return this._get("expr")}};var de=class extends ae{static get syntaxPriority(){return 49}value(){return this._get("value")}};var Jr=class extends de{static get syntaxRules(){return{type:"bit_literal",as:"."}}dataType(){return y.DataType.fromJSON({value:"BINARY"})}};var Fr=class extends de{static get syntaxRules(){return{type:"bool_literal",as:"."}}dataType(){return y.DataType.fromJSON({value:"BOOLEAN"})}};var Gr=class extends de{static get syntaxRules(){return{type:"keyword",as:".",value:"DEFAULT"}}};var qr=class extends de{static get syntaxRules(){return{type:"hex_literal",as:"."}}dataType(){return y.DataType.fromJSON({value:"BINARY"})}};var Wr=class extends de{static get syntaxRules(){return{type:"null_literal",as:"."}}};var Hr=class extends de{static get syntaxRules(){return{type:"number_literal",as:"."}}dataType(){return y.DataType.fromJSON({value:"INT"})}};var Kr=class extends de{static get syntaxRules(){return{type:"string_literal",as:"."}}qualifier(){return this._get("qualifier")}dataType(){return y.DataType.fromJSON({value:"TEXT"})}};var Ee=class extends ae{static get syntaxRules(){return[{type:"data_type",as:"data_type"},{type:"string_literal",as:"value"}]}static get syntaxPriority(){return 50}dataType(){return y.DataType.fromJSON({value:this._get("data_type")})}value(){return this._get("value")}};var Yr=class extends Ee{static get syntaxRules(){return[{type:"data_type",as:"data_type",value:"DATE"},{type:"string_literal",as:"value"}]}};var zr=class extends Ee{static get syntaxRules(){return[{type:"data_type",as:"data_type",value:"INTERVAL"},{syntaxes:[{type:"string_literal",as:"value"},{type:"number_literal",as:"value",dialect:"mysql"}]},{optional:!0,syntax:[{type:"keyword",as:"unit",value:["YEAR","MONTH","DAY","HOUR","MINUTE","SECOND"]},{optional:!0,syntax:[{type:"keyword",value:"TO"},{type:"keyword",as:"to_unit",value:["YEAR","MONTH","DAY","HOUR","MINUTE","SECOND"],assert:!0}]}]}]}unit(){return this._get("unit")}toUnit(){return this._get("to_unit")}parseInterval(){let e=this._get("value");if(!e)return{};let t="";if(e.type==="string_literal")t=e.value.toString().trim();else if(e.type==="number_literal"){let u=e.value,l=(this.unit()||"").toUpperCase();return this.#e(u,l)}let s=t.startsWith("-")?-1:1;s===-1&&(t=t.slice(1).trim());let r={years:0,months:0,days:0,hours:0,minutes:0,seconds:0},n=this.unit()?this.unit().toUpperCase():null,a=this.toUnit()?this.toUnit().toUpperCase():null;if(n&&a)switch(`${n} TO ${a}`){case"YEAR TO MONTH":{let[l,m]=t.split("-").map(Number);return r.years=l,r.months=m,this.#t(r,s)}case"DAY TO HOUR":{let[l,m]=t.split(/\s+/);return r.days=Number(l),r.hours=Number(m),this.#t(r,s)}case"DAY TO MINUTE":{let[l,m]=t.split(/\s+/);r.days=Number(l);let[f,p]=m.split(":").map(Number);return r.hours=f,r.minutes=p,this.#t(r,s)}case"DAY TO SECOND":{let[l,m]=t.split(/\s+/);r.days=Number(l);let[f,p,d]=m.split(":").map(Number);return r.hours=f,r.minutes=p,r.seconds=d,this.#t(r,s)}case"HOUR TO MINUTE":{let[l,m]=t.split(":").map(Number);return r.hours=l,r.minutes=m,this.#t(r,s)}case"HOUR TO SECOND":{let[l,m,f]=t.split(":").map(Number);return r.hours=l,r.minutes=m,r.seconds=f,this.#t(r,s)}case"MINUTE TO SECOND":{let[l,m]=t.split(":").map(Number);return r.minutes=l,r.seconds=m,this.#t(r,s)}}let o=t.split(/\s+/);for(let u=0;u<o.length;u++){let l=o[u];if(/^\d{1,2}:\d{1,2}(:\d{1,2}(\.\d+)?)?$/.test(l)){let[f,p,d]=l.split(":").map(Number);isNaN(f)||(r.hours+=f),isNaN(p)||(r.minutes+=p),isNaN(d)||(r.seconds+=d);continue}let m=parseFloat(l);if(!isNaN(m)){let f=(o[u+1]||"").toUpperCase();if(f){let p=this.#e(m,f);for(let[d,h]of Object.entries(p))r[d]+=h;u++}}}return this.#t(r,s)}#e(e,t){let s={};switch(t){case"YEAR":s.years=e;break;case"MONTH":s.months=e;break;case"DAY":s.days=e;break;case"HOUR":s.hours=e;break;case"MINUTE":s.minutes=e;break;case"SECOND":s.seconds=e;break;default:break}return s}#t(e,t){for(let s of Object.keys(e))e[s]*=t;return e}applyToDate(e,t="FOLLOWING"){let s=this.parseInterval(),r=new Date(e),n=t==="FOLLOWING"?1:-1;return s.years&&r.setFullYear(r.getFullYear()+n*s.years),s.months&&r.setMonth(r.getMonth()+n*s.months),s.days&&r.setDate(r.getDate()+n*s.days),s.hours&&r.setHours(r.getHours()+n*s.hours),s.minutes&&r.setMinutes(r.getMinutes()+n*s.minutes),s.seconds&&r.setSeconds(r.getSeconds()+n*s.seconds),r.getTime()}};var Vr=class extends Ee{static get syntaxRules(){return[{type:"data_type",as:"data_type",value:"TIME"},{type:"string_literal",as:"value"},{optional:!0,dialect:"postgres",syntax:[{type:"keyword",as:"pg_with_tz",value:["WITH","WITHOUT"]},{type:"keyword",value:"TIME ZONE",assert:!0}]}]}pgWithTZ(){return this._get("pg_with_tz")}};var Qr=class extends Ee{static get syntaxRules(){return[{type:"data_type",as:"data_type",value:"TIMESTAMP",dialect:"postgres"},{type:"data_type",as:"data_type",value:["TIMESTAMP","DATETIME"],dialect:"mysql"},{type:"string_literal",as:"value"},{optional:!0,dialect:"postgres",syntax:[{type:"keyword",as:"pg_with_tz",value:["WITH","WITHOUT"]},{type:"keyword",value:"TIME ZONE",assert:!0}]}]}pgWithTZ(){return this._get("pg_with_tz")}};var Xr=class extends Ee{static get syntaxRules(){return[{type:"keyword",value:"TIME ZONE"},{type:"Expr",as:"value"}]}};var Zr=class extends de{static get syntaxRules(){return{type:"unknown_literal",as:"."}}};var gt=c=>class extends c{get isSugar(){return!0}};var Et=class extends gt(De(L)){dataType(){return y.DataType.fromJSON({value:"JSON"})}};var es=class extends Et{static get syntaxRules(){return{syntax:[{type:"bracket_block",syntax:{type:"Expr",as:"entries",arity:1/0,itemSeparator:{type:"punctuation",value:","},autoIndent:2}}]}}static morphsTo(){return y.CallExpr}jsonfy(e={},t=null,s=null){let r=super.jsonfy(e,t,s);if(e.deSugar){let n=[];r={nodeName:y.CallExpr.NODE_NAME,name:(e.toDialect||this.options.dialect)==="mysql"?"JSON_ARRAY":"JSON_BUILD_ARRAY",arguments:r.entries.map((a,o)=>{let u=a.result_schema,l={value:o,nodeName:y.Identifier.NODE_NAME};return u instanceof y.ColumnSchema?u=u.clone({renameTo:l}):u=y.ColumnSchema.fromJSON({name:l,data_type:this.entries()[o].dataType().jsonfy()}),n.push(u),a}),result_schema:y.JSONSchema.fromJSON({entries:n},{assert:!0})}}return r}};var ts=class extends Et{static get syntaxRules(){return{syntax:[{type:"brace_block",syntax:{type:"LQObjectProperty",as:"entries",arity:1/0,itemSeparator:{type:"punctuation",value:","},autoIndent:3}}]}}static morphsTo(){return y.CallExpr}jsonfy(e={},t=null,s=null){let r=super.jsonfy(e,t,s);if(e.deSugar){let n=r.entries.reduce((o,u)=>{if(u.star_ref){for(let l of u.star_ref.result_schema){let m={key:{value:l.value(),delim:l._get("delim")},value:l.jsonfy()};o=o.reduce((f,p)=>z(m.key.value,p.key.value,m.key.delim||p.key.delim)?f:f.concat(p),[]),o=o.concat(m)}return o}return o.concat(u)},[]),a=[];r={nodeName:y.CallExpr.NODE_NAME,name:(e.toDialect||this.options.dialect)==="mysql"?"JSON_OBJECT":"JSON_BUILD_OBJECT",arguments:n.reduce((o,u,l)=>{let m=u.value.result_schema,f={...u.key,nodeName:y.Identifier.NODE_NAME};return m instanceof y.ColumnSchema?m=m.clone({renameTo:f}):m=y.ColumnSchema.fromJSON({name:f,data_type:this.entries()[l].value()?.dataType().jsonfy()||{nodeName:y.DataType.NODE_NAME,value:"TEXT"}}),a.push(m),o.concat({...u.key,nodeName:y.StringLiteral.NODE_NAME},{...u.value})},[]),result_schema:y.JSONSchema.fromJSON({entries:a},{assert:!0})}}return r}};var rs=class c extends w{static get syntaxRules(){return{syntaxes:[{type:"ColumnRef0",as:"star_ref"},[{type:"SelectItemAlias",as:"key"},{optional:!0,syntax:[{type:"punctuation",value:":"},{type:"Expr",as:"value",assert:!0}],autoSpacing:!1}]]}}static get syntaxPriority(){return-1}get isProperty(){return!0}starRef(){return this._get("star_ref")}key(){return this._get("key")}value(){return this._get("value")}jsonfy(e={},t=null,s=null){if(e.deSugar&&!this.starRef()){let r=this.key(),n,a=t?t.transform(r,(m=e)=>r.jsonfy(m),"key",e):r.jsonfy(e);a.is_aggr&&({is_aggr:n,...a}=a);let o=this.value();o||(o=y.ColumnRef1.fromJSON({...a,nodeName:void 0}),this._adoptNodes(o));let u;n&&!(o instanceof y.LQDeepRef1)?u=(m=e,f=t)=>({nodeName:y.AggrCallExpr.NODE_NAME,name:(e.toDialect||this.options.dialect)==="mysql"?"JSON_ARRAYAGG":"JSON_AGG",arguments:[o.jsonfy(m,f,s)]}):u=(m=e,f=t)=>o.jsonfy(m,f,s);let l=t?t.transform(o,u,"value",{...e,asAggr:n}):u();return{nodeName:c.NODE_NAME,key:a,value:l}}return super.jsonfy(e,t,s)}};var ss=class extends L{static get syntaxRules(){return{dialect:"postgres",syntax:[{type:"keyword",value:"ARRAY"},{type:"bracket_block",syntax:{type:"Expr",as:"entries",arity:1/0,itemSeparator:{type:"punctuation",value:","},autoIndent:2},autoSpacing:!1}]}}static morphsTo(){return y.CallExpr}dataType(){return y.DataType.fromJSON({value:"JSON"})}jsonfy(e={},t=null,s=null){let r=super.jsonfy(e,t,s);return(e.toDialect||this.options.dialect)==="mysql"&&(r={nodeName:y.CallExpr.NODE_NAME,name:"JSON_ARRAY",arguments:r.entries}),r}};var ns=class extends re{static get syntaxRules(){return[{type:"Expr",as:"left",peek:[1,"operator","AT"]},{type:"operator",as:"operator",value:"AT"},{syntaxes:[{type:"TypedTimeZoneLiteral",as:"right"},{type:"keyword",as:"right",value:"LOCAL"}]}]}static get syntaxPriority(){return 0}left(){return this._get("left")}right(){return this._get("right")}dataType(){return y.DataType.fromJSON({value:"TIME ZONE"})}};var as=class extends re{static get syntaxRules(){return[{type:"Expr",as:"left",peek:[1,"operator",["NOT","BETWEEN"]]},{type:"operator",as:"negation",value:"NOT",booleanfy:!0,optional:!0},{type:"operator",as:"operator",value:"BETWEEN"},{type:"Expr",as:"right",arity:{min:2,max:2,eager:!1},itemSeparator:{type:"operator",value:"AND"},assert:!0}]}};var is=class extends re{static get syntaxRules(){return[{type:"Expr",as:"left",peek:[1,"operator",["IS","IS NOT"]]},{type:"operator",as:"logic",value:["IS","IS NOT"]},{type:"operator",as:"operator",value:"DISTINCT FROM"},{type:"Expr",as:"right",assert:!0}]}logic(){return this._get("logic")}};var os=class extends re{static get syntaxRules(){return[{type:"Expr",as:"left",peek:[1,"operator",["NOT","IN"]]},{type:"operator",as:"negation",value:"NOT",booleanfy:!0,optional:!0},{type:"operator",as:"operator",value:"IN"},{type:["DerivedQuery","RowConstructor","TypedRowConstructor"],as:"right",assert:!0}]}};var ls=class extends re{static get syntaxRules(){return{dialect:"postgres",syntax:[{type:"Expr",as:"left",peek:[1,"operator","::"]},{type:"operator",as:"operator",value:"::",autoSpacing:!1},{type:"DataType",as:"right",assert:!0,autoSpacing:!1}]}}expr(){return this.left()}dataType(){return this.right()}};var us=class extends ae{static get syntaxRules(){return[{type:"operator",as:"operator",value:["-","+","NOT"]},{type:"Expr",as:"operand",autoSpacing:["NOT"]}]}static get syntaxPriority(){return 1}operator(){return this._get("operator")}operand(){return this._get("operand")}dataType(){let e=this.operator();return e?y.DataType.fromJSON({value:e==="NOT"?"BOOLEAN":"NUMBER"}):super.dataType()}};var Ue=class extends Error{};var Nt=class extends Error{};var Me=class extends X(De(ue)){#e;resolution(){return this.#e}lookup(e,t){return[]}resolve(e,t){let s=this.lookup(null,e,t)||[],r=this.constructor.name.match(/namespace/i)?"Namespace":this.constructor.name.match(/table/i)?"Table":"Column";if(s.length>1)throw new Nt(`[${this.parentNode?.parentNode||this.parentNode||this}] ${r} ${this} is ambiguous. (Is it ${s.join(" or ")}?)`);if(!s.length)throw new Ue(`[${this.parentNode?.parentNode||this.parentNode||this}] ${r} ${this} does not exist.`);return s[0]}static fromJSON(e,t={},s=null){if(!e||e instanceof w)return super.fromJSON(e,t,s);let{resolution:r,...n}=e,a=super.fromJSON(n,t,s);if(a&&r){if(typeof r!="string")throw new Error('Invalid "resolution" hint passed at inputJson.resolution');a.#e=r}return a}jsonfy(e={},t=null,s=null){let r=super.jsonfy(e,t,s);return this.#e&&(r={...r,resolution:this.#e}),r}};var xt=class c extends He(Me){static get _qualifierType(){return["TableRef1","LQBackRefAbstraction"]}static get syntaxRules(){return this.buildSyntaxRules({type:"identifier",as:".",autoSpacing:!1})}static get syntaxPriority(){return 51}static morphsTo(){return y.ColumnRef2}dataType(){return this.resultSchema()?.dataType()||super.dataType()}canReferenceOutputColumns(){return this.climbTree((e,t)=>e instanceof y.SelectStmt?!1:e instanceof y.GroupByClause||e instanceof y.HavingClause||e instanceof y.OrderByClause?e:t())}lookup(e=null,t=null,s=null){if(!t&&!s)return[];let r=this._get("value"),n=(!r||r==="*")&&!e,a=[],o=(l,m=void 0,f="default")=>{if(!(l instanceof y.ColumnSchema)||r&&r!=="*"&&!l.identifiesAs(this))return!1;let p;if(e&&!(p=e(l,m,f)))return!1;if(p instanceof w||Array.isArray(p))return p;let d=l.clone({normalized:!0});l.parentNode?._adoptNodes(d);let h=c.fromJSON({...l.name().jsonfy({nodeNames:!1}),resolution:f,qualifier:m,result_schema:d});return this.parentNode._adoptNodes(h),h};if(((this.options.dialect||"postgres")==="postgres"?["CTID","OID","XMIN","XMAX","TABLEOID"]:[]).includes(r?.toUpperCase())){let l=y.ColumnSchema.fromJSON({name:{nodeName:y.Identifier.NODE_NAME,value:r},data_type:{nodeName:y.DataType.NODE_NAME,value:"INT"}},{assert:!0});return[].concat(o(l,void 0,"system")||[])}if(this.canReferenceOutputColumns()&&t){let l=t.statementContext;for(let m of l.artifacts.get("outputSchemas"))if(a=a.concat(o(m,void 0,"scope")||[]),!n&&a.length)break}if(n||!a.length){let l=new y.TableRef1(this.qualifier()?.jsonfy()||{});this._adoptNodes(l),a=a.concat(l.lookup((m,f=void 0,p=void 0)=>m._get("entries").reduce((d,h)=>{if(m instanceof y.JSONSchema)return d.concat(o(h)||[]);let _={...m.name().jsonfy({nodeNames:!1}),resolution:p,qualifier:f,result_schema:m};return d.concat(o(h,_)||[])},[]),t,s))}if(r==="*"){let l=y.ColumnRef0.fromJSON({value:this.value(),result_schema:y.JSONSchema.fromJSON({entries:a.map(m=>m.clone())},{assert:!0})});this.parentNode._adoptNodes(l),a=[l]}return a}jsonfy({toKind:e=1,...t}={},s=null,r=null){let n;if(t.deSugar&&((t.deSugar===!0||t.deSugar.columnQualifiers)&&!this.qualifier()||!this.resultSchema())&&(s||r)){let a=this.resolve(s,r);if(a.value?.()!==this.value())return a.jsonfy();n=a.jsonfy(),(t.deSugar===!0||t.deSugar.normalizeCasing)&&!n.delim&&(n={...n,value:n.resolution==="system"?n.value.toUpperCase():n.value.toLowerCase()}),!(t.deSugar===!0||t.deSugar.columnQualifiers)&&!this.qualifier()&&(n={...n,qualifier:void 0})}else n=super.jsonfy(t,s,r),e===2&&(n={...n,nodeName:y.ColumnRef2.NODE_NAME},delete n.qualifier);return n}};var cs=class extends xt{static get _qualifierType(){return["TableRef1"]}static get syntaxRules(){return this.buildSyntaxRules({type:"operator",as:".",value:"*",autoSpacing:!1})}static get syntaxPriority(){return-1}dataType(){return y.DataType.fromJSON({value:"SET"})}};var Ye=class extends Error{constructor(e){super(e),this.name="ErrorFKInvalid"}};var ze=class extends gt(re){rhsTable(e,t){let r=(this.operand()?.resolve(e,t)).resultSchema()?.fkConstraint(!0);if(!r)throw new Ye(`[${this.parentNode||this}] Column ${this.operand()} is not a foreign key.`);return r.targetTable()?.resolve(null,t)}rhsSchema(e,t){return this.rhsTable(e,t)?.resultSchema()}};var at=class c extends Me{static get syntaxPriority(){return-1}static morphsTo(){return y.ColumnRef1}dataType(){return this.resultSchema()?.dataType()||super.dataType()}lookup(e,t=null,s=null){if(!t&&!s)return[];let r=this._get("value"),n=!r&&!e,a=[],o=l=>{if(!(l instanceof y.ColumnSchema)||r&&!l.identifiesAs(this))return!1;let m;if(e&&!(m=e(l)))return!1;if(m instanceof w||Array.isArray(m))return m;let f=l.clone({normalized:!0});l.parentNode._adoptNodes(f);let p=c.fromJSON({...l.name().jsonfy({nodeNames:!1}),result_schema:f});return this.parentNode._adoptNodes(p),p},u;this.parentNode instanceof ze?this===this.parentNode.operand()?u=[this.parentNode.parentNode.rhsSchema(t,s)]:u=[this.parentNode.rhsSchema(t,s)]:u=this.climbTree((l,m)=>{if(l instanceof y.InsertStmt||l instanceof y.UpdateStmt){let f=[...t.statementContext.artifacts.get("tableSchemas")].map(p=>p.resultSchema);return this.options.dialect!=="mysql"&&(f=f.slice(0,1)),f}return l instanceof y.TableSchema?[l]:m()});e:for(let l of u||[])for(let m of l)if(a=a.concat(o(m)||[]),!n&&a.length)break e;return a}jsonfy({toKind:e=2,...t}={},s=null,r=null){if(t.deSugar&&!this.resultSchema()&&(s||r))return this.resolve(s,r).jsonfy();let n=super.jsonfy(t,s,r);return e===1&&(n={...n,nodeName:y.ColumnRef1.NODE_NAME},delete n.qualifier),n}};var Ve=class c extends ze{static get _leftType(){return["LQBackRefEndpoint","LQBackBackRef"]}static get syntaxRules(){return[{type:this._leftType,as:"left",peek:[1,"operator","<~"]},{type:"operator",value:"<~"},{type:"ColumnRef2",as:"right",peek:[1,"operator","<~"]}]}static get syntaxPriority(){return 1}static morphsTo(){return[y.LQDeepRef1,y.LQDeepRef2,y.LQDeepDeepRef1,y.LQDeepDeepRef2]}operand(){return this.right()}endpoint(){return this.left()instanceof c?this.left().endpoint():this.left()}jsonfy({reverseRef:e=!1,toKind:t=1,...s}={},r=null,n=null){return e?{nodeName:t===2?e===1/0?y.LQDeepDeepRef2.NODE_NAME:y.LQDeepRef2.NODE_NAME:e===1/0?y.LQDeepDeepRef1.NODE_NAME:y.LQDeepRef1.NODE_NAME,left:this.right().jsonfy({toKind:e!==1/0?1:2,...s}),right:this.left()instanceof y.LQBackRefEndpoint?{nodeName:y.ColumnRef2.NODE_NAME,value:this.left().value(),delim:this.left()._get("delim")}:this.left().jsonfy({reverseRef:1/0,toKind:t,...s})}:super.jsonfy(s,r,n)}};var fs=class extends Ve{static get syntaxRules(){return[{type:this._leftType,as:"left",peek:[1,"operator","<~"]},{type:"operator",value:"<~"},{type:"TableRef2",as:"right"}]}static get syntaxPriority(){return 0}rhsTable(e,t){if(!t)return;let s=this.right()?.lookup(null,null,t)||[];if(!s.length)throw new Ue(`[${this.parentNode||this}] Implied RHS table ${this.right()} does not exist.`);return s[0]}resolve(e,t,s=1){if(!e||!t)return;let r=this.left(),n=r instanceof Ve?r.endpoint():r,a=n.qualifier(),o=y.ColumnRef2.fromJSON({...n.jsonfy({nodeNames:!1}),qualifier:void 0}),l=n.resolve(e,t).resultSchema().fkConstraint(!0);if(!l)throw new Ye(`[${this.parentNode||this}] Endpoint column ${o} is not a foreign key.`);let m=l.targetTable(),f,p=(g,E)=>{let N=E.pkConstraint(!0)?.columns()[0]?.resolve(e,t);if(!N)throw new Ye(`[${this.parentNode||this}] The referenced LHS table ${g} does not have a primary key.`);let x=y.ColumnRef1.fromJSON({qualifier:{...E.name().jsonfy({nodeNames:!1}),result_schema:E},value:N.value(),delim:N._get("delim"),result_schema:N.resultSchema()});if(f)throw new Nt(`[${this.parentNode||this}]: The referenced endpoint for foreign key ${o} is ambiguous. (Is it ${f} or ${x}?)`);f=x},d=e.statementContext;e:do for(let{type:g,resultSchema:E}of d.artifacts.get("tableSchemas")){if(g==="CTEItem")continue;let N=E._get("ddl_name")||E.name();if(a){if(!E.identifiesAs(a))continue;if(!m.identifiesAs(N))throw new Ye(`[${this.parentNode||this}] The endpoint table implied by ${a} (${N}) is not the actual target (${m}) of the foreign key column ${o}.`);p(N,E);break e}else m.identifiesAs(N)&&p(N,E)}while(!f&&(d=d.parentTransformer?.statementContext));if(!f)throw new Ue(`[${this.parentNode||this}] Ref does not correlate with current query.`);let h=this.rhsTable(e,t),_=r instanceof Ve?r.clone({reverseRef:!0,toKind:s}):o.constructor.fromJSON({...o.jsonfy(),result_schema:h.resultSchema()._get("entries",o)});return{lhsOperand:f,rhsOperand:_.clone({toKind:s}),rhsTable:h}}};var Ft=class extends Ke{static get syntaxRules(){return{type:"paren_block",syntaxes:[{type:"Expr",as:"expr",peek:[1,"operator","<~"]},{type:"Expr",as:"expr",peek:[2,"operator","<~"]}]}}static get syntaxPriority(){return 51}expr(){return this._get("expr")}};var ps=class extends at{static get syntaxRules(){return[{optional:!0,type:"paren_block",syntax:{type:"Identifier",as:"qualifier"}},{...[].concat(super.syntaxRules)[0],peek:[1,"operator","<~"]}]}static get syntaxPriority(){return 52}static morphsTo(){return at}qualifier(){return this._get("qualifier")}};var Be=class c extends ze{static get _rightType(){return["LQDeepDeepRef1","LQObjectLiteral","LQArrayLiteral","RowConstructor","ColumnRef2"]}static get syntaxRules(){return[{type:["ColumnRef2","LQBackRefAbstraction"],as:"left",peek:[1,"operator","~>"]},{type:"operator",value:"~>"},{type:this._rightType,as:"right"}]}static get syntaxPriority(){return-1}static morphsTo(){return[y.LQDeepRef1,y.LQDeepRef2,y.LQDeepDeepRef1,y.LQDeepDeepRef2]}operand(){return this.left()}endpoint(){return this.right()instanceof c?this.right().endpoint():this.right()}jsonfy({toDeepRef:e=!1,toKind:t=1,...s}={},r=null,n=null){if(e||t===1||t===2){let a=[y.LQDeepRef1.NODE_NAME,y.LQDeepRef2.NODE_NAME,y.LQDeepDeepRef1.NODE_NAME,y.LQDeepDeepRef2.NODE_NAME],o=a.indexOf(this.NODE_NAME);return e&&o>1&&(o-=2),{nodeName:a[(o+1)%2===t%2?o:t%2?o-1:o+1],left:this.left().jsonfy({toKind:o>1?2:1}),right:this.right().jsonfy({toKind:this.right()instanceof c?t:void 0})}}return super.jsonfy(s,r,n)}};var ms=class extends Be{static get _rightType(){return["LQDeepDeepRef2","ColumnRef2","ColumnsConstructor"]}jsonfy({toDeepRef:e=!1,toKind:t=2,...s}={},r=null,n=null){return super.jsonfy({toDeepRef:e,toKind:t,...s},r=null,n)}};var St=class c extends Be{static get syntaxRules(){return[{syntaxes:[[{type:["ColumnRef1","LQBackRefAbstraction"],as:"left",peek:[1,"operator","~>"]},{type:"operator",value:"~>"}],[{type:"ColumnRef1",as:"left",peek:[3,"operator","~>"]},{type:"operator",value:"~>"}]]},{type:this._rightType,as:"right"}]}static get syntaxPriority(){return 1}rhsTable(e,t){return this.left()?.qualifier?.()instanceof y.LQBackRefAbstraction?this._normalize().rhsTable(e,t):this.left()instanceof y.LQBackRefAbstraction?this.left().expr().rhsTable(e,t):super.rhsTable(e,t)}_normalize(){let e=this.left(),t=this.right(),s=e.qualifier().jsonfy(),r={...e.jsonfy(),qualifier:void 0,nodeName:y.ColumnRef2.NODE_NAME},n=c.fromJSON({left:s,right:{nodeName:Be.NODE_NAME,left:r,right:t.jsonfy()}});return this._adoptNodes(n),n}resolve(e,t,s=1){if(!e||!t)return;if(this.left()?.qualifier?.()instanceof y.LQBackRefAbstraction)return this._normalize().resolve(e,t,s);let r;if(this.right()instanceof y.ColumnRef2?r=this.right().clone({toKind:s}):this.right()instanceof y.LQDeepDeepRef1?r=this.right().clone({toDeepRef:!0,toKind:s}):r=this.right(),this.left()instanceof y.LQBackRefAbstraction)return{...this.left().expr().resolve(e,t,s),detail:r};let n=this.left().resolve(e,t),a=this.rhsTable(e,t),o=a.resultSchema().pkConstraint(!0)?.columns()[0]?.resolve(e,t);if(!o)throw new Error(`[${this.parentNode||this}] The referenced RHS table ${a} does not have a primary key.`);return{lhsOperand:n,rhsOperand:o.clone({toKind:s}),rhsTable:a,detail:r}}};var ys=class extends St{static get _rightType(){return["LQDeepDeepRef2","ColumnRef2","ColumnsConstructor"]}static get syntaxPriority(){return-1}resolve(e,t,s=2){return super.resolve(e,t,s)}jsonfy({toDeepRef:e=!1,toKind:t=2,...s}={},r=null,n=null){return super.jsonfy({toDeepRef:e,toKind:t,...s},r,n)}};var ds=class extends Me{static get syntaxRules(){return[{type:"identifier",as:"."},{type:"LQVersionSpec",as:"version_spec",optional:!0,autoSpacing:!1}]}static get syntaxPriority(){return-1}versionSpec(){return this._get("version_spec")}lookup(e=null,t=null,s=null){if(!s)return[];let r=this._get("value"),n=!r&&!e,a=[],o=u=>{if(!(u instanceof y.NamespaceSchema)||r&&!u.identifiesAs(this))return!1;let l;if(e&&!(l=e(u)))return!1;if(l instanceof w||Array.isArray(l))return l;let m=ColumnRef2.fromJSON({...u.name().jsonfy({nodeNames:!1}),result_schema:u});return this.parentNode._adoptNodes(m),m};for(let u of s.catalog)if(a=a.concat(o(u)||[]),!n&&a.length)break;return a}jsonfy(e={},t=null,s=null){let r;return e.deSugar&&!this.resultSchema()&&s?r=this.resolve(t,s).jsonfy():r=super.jsonfy(e,t,s),(e.deSugar===!0||e.deSugar?.normalizeCasing)&&!r.delim&&(r={...r,value:r.value.toLowerCase()}),(e.deSugar===!0||e.deSugar?.dropVersionSpecs)&&r.version_spec&&(r={...r,version_spec:void 0}),r}};var Qe=class extends He(Me){static get _qualifierType(){return"NamespaceRef"}static get syntaxRules(){return this.buildSyntaxRules({syntax:[{type:"identifier",as:"."},{type:"LQVersionSpec",as:"version_spec",optional:!0,autoSpacing:!1}],autoSpacing:!1})}versionSpec(){return this._get("version_spec")}dataType(){return y.DataType.fromJSON({value:"SET"})}canReferenceInlineTables(){return!0}lookup(e=null,t=null,s=null){if(!t&&!s)return[];let r=this._get("value"),n=(!r||r==="*")&&(!e||this.parentNode?.value?.()==="*"),a=this.parentNode instanceof y.FromItem,o=this.statementNode?.parentNode instanceof y.DerivedQuery?this.statementNode?.parentNode:null,u=a||!o||!(o.parentNode instanceof y.FromItem)||!(o.parentNode.parentNode?.parentNode instanceof y.SelectStmt)||o.parentNode.lateralKW(),l=[],m=(p,d=void 0,h="default")=>{if(p instanceof y.JSONSchema&&(!r||r==="*")&&e)return e(p,d,h);if(!(p instanceof y.TableSchema)||r&&r!=="*"&&!p.identifiesAs(this))return!1;let _;if(e&&!(_=e(p,d,h)))return!1;if(_ instanceof w||Array.isArray(_))return _;let g=this.constructor.fromJSON({...p.name().jsonfy({nodeNames:!1}),resolution:h,qualifier:d,result_schema:p});return this.parentNode?._adoptNodes(g),g};if(((this.options.dialect||"postgres")==="postgres"?["EXCLUDED"]:[]).includes(r?.toUpperCase())&&t){let p=[...t.statementContext.artifacts.get("tableSchemas")][0].resultSchema.clone({renameTo:{nodeName:y.Identifier.NODE_NAME,value:r}});return[].concat(m(p,void 0,"system")||[])}if(this.canReferenceInlineTables()&&t){let p=t.statementContext,d,h,_=new Set;do{h=p!==t.statementContext,a||_.add(p);for(let{type:g,resultSchema:E}of p.artifacts.get("tableSchemas")){if(a){if(g!=="CTEItem")continue}else{if(g==="CTEItem"||d&&d!=="dml"&&g==="dml")continue;d||(d=g)}if(l=l.concat(m(E,void 0,g==="CTEItem"?"cte":h?"scope":"default")||[]),l.length&&!n){for(let N of _)N.artifacts.has("derivedQueryCorrelationFlag")&&N.artifacts.set("derivedQueryCorrelationFlag",!0);break}}}while(u&&(n||!l.length)&&(p=p.parentTransformer?.statementContext))}if(!e&&(n||!l.length)){let p=new y.NamespaceRef(this.qualifier()?.jsonfy()||{});this._adoptNodes(p),l=l.concat(p.lookup(d=>d._get("entries").reduce((h,_)=>{let g={...d.name().jsonfy({nodeNames:!1}),result_schema:d};return h.concat(m(_,g)||[])},[]),t,s))}if(r==="*"){let p=y.TableRef0.fromJSON({value:this.value(),result_schema:y.JSONSchema.fromJSON({entries:l.map(d=>d.clone())},{assert:!0})});this.parentNode._adoptNodes(p),l=[p]}return l}jsonfy(e={},t=null,s=null){let r;return e.deSugar&&((e.deSugar===!0||e.deSugar.tableQualifiers)&&!this.qualifier()||!this.resultSchema())&&(t||s)?(r=this.resolve(t,s).jsonfy(),(e.deSugar===!0||e.deSugar.normalizeCasing)&&!r.delim&&(r={...r,value:r.resolution==="system"?r.value.toUpperCase():r.value.toLowerCase()}),!(e.deSugar===!0||e.deSugar.tableQualifiers)&&!this.qualifier()&&(r={...r,qualifier:void 0})):r=super.jsonfy(e,t,s),(e.deSugar===!0||e.deSugar?.dropVersionSpecs)&&r.version_spec&&(r={...r,version_spec:void 0}),r}};var hs=class extends Qe{static get _qualifierType(){return["NamespaceRef"]}static get syntaxRules(){return this.buildSyntaxRules({type:"operator",as:".",value:"*",autoSpacing:!1})}static get syntaxPriority(){return-1}dataType(){return y.DataType.fromJSON({value:"SET"})}};var _s=class extends Qe{canReferenceInlineTables(){return!1}};var gs=class extends ue{static get syntaxPriority(){return-1}};var Es=class extends ae{static get syntaxRules(){return{type:"bind_var",as:"."}}value(){return this._get("value")}};var Ns=class extends ae{static get syntaxRules(){return{type:"system_var",as:"."}}value(){return this._get("value")}};var xs=class extends ae{static get syntaxRules(){return{type:"user_var",as:"."}}value(){return this._get("value")}};var Gt=class extends ae{static get syntaxRules(){return{type:wi,expression:1}}static[Symbol.hasInstance](e){return e instanceof ae||e.constructor.name in Ae}},Si=Object.keys(Ae),wi=Si.filter(c=>Ae[c]!==Gt&&Ae[c].syntaxPriority!==-1).sort((c,e)=>{let t=(Ae[e].syntaxPriority??100)-(Ae[c].syntaxPriority??100);return t===0?Ae[e].prototype.isPrototypeOf(Ae[c].prototype)?-1:1:t});var Ss=class extends He(ue){static get _qualifierType(){return"TableRef2"}};var ws=class extends ue{};var As=class extends He(ue){static get _qualifierType(){return"NamespaceRef"}};var Os=class extends ke{};var vs=class extends we{static get syntaxRules(){return[{type:"Identifier",as:"name",assert:!0}]}};var bs=class extends ke{};var wt=class extends we{static get syntaxRules(){return[{type:"NamespaceIdent",as:"name",assert:!0},{type:"paren_block",syntax:{type:"TableSchema",as:"entries",arity:1/0,itemSeparator:{type:"punctuation",value:","},singletons:"BY_KEY",autoIndent:!0}}]}tables(){let e=[];for(let t of this)t instanceof y.TableSchema&&e.push(t);return e}};var Ts=class extends ke{};var Rs=class extends we{static get syntaxRules(){let e={type:"punctuation",value:","},t=["TablePKConstraint","TableFKConstraint","TableUKConstraint","PGTableEXConstraint","CheckConstraint","ColumnSchema","IndexSchema"];return[{type:["TableIdent","Identifier"],as:"name"},{type:"paren_block",syntaxes:[{type:t,as:"entries",arity:1/0,itemSeparator:e,singletons:"BY_KEY",optional:!0,dialect:"postgres",autoIndent:!0},{type:t,as:"entries",arity:{min:1},itemSeparator:e,singletons:"BY_KEY",dialect:"mysql",autoIndent:!0}]}]}columns(){let e=[];for(let t of this)t instanceof y.ColumnSchema&&e.push(t);return e}pkConstraint(e=!1){for(let t of this){if(t instanceof y.TablePKConstraint)return t;let s;if(e&&t instanceof y.ColumnSchema&&(s=t.pkConstraint())){let r=y.TablePKConstraint.fromJSON({...s.jsonfy(),nodeName:void 0,columns:[y.ColumnRef2.fromJSON({value:t.name().value()})]});return this._adoptNodes(r),r}}}fkConstraints(e=!1){let t=[];for(let s of this){s instanceof y.TableFKConstraint&&t.push(s);let r;if(e&&s instanceof y.ColumnSchema&&(r=s.fkConstraint())){let n=y.TableFKConstraint.fromJSON({...r.jsonfy(),nodeName:void 0,columns:[y.ColumnRef2.fromJSON({value:s.name().value()})]});this._adoptNodes(n),t.push(n)}}return t}ukConstraints(e=!1){let t=[];for(let s of this){s instanceof y.TableUKConstraint&&t.push(s);let r;if(e&&s instanceof y.ColumnSchema&&(r=s.ukConstraint())){let n=y.TableUKConstraint.fromJSON({...r.jsonfy(),nodeName:void 0,columns:[y.ColumnRef2.fromJSON({value:s.name().value()})]});this._adoptNodes(n),t.push(n)}}return t}ckConstraints(e=!1){let t=[];for(let s of this){s instanceof y.CheckConstraint&&t.push(s);let r;e&&s instanceof y.ColumnSchema&&(r=s.ckConstraint()?.clone())&&(this._adoptNodes(r),t.push(r))}return t}jsonfy({normalized:e=!1,...t}={},s=null,r=null){let n=[],a={[y.ColumnPKConstraint.NODE_NAME]:y.TablePKConstraint.NODE_NAME,[y.ColumnFKConstraint.NODE_NAME]:y.TableFKConstraint.NODE_NAME,[y.ColumnUKConstraint.NODE_NAME]:y.TableUKConstraint.NODE_NAME,[y.CheckConstraint.NODE_NAME]:y.CheckConstraint.NODE_NAME};e&&(s=new te((u,l)=>{if(u?.NODE_NAME in a&&u.parentNode instanceof y.ColumnSchema){n.push({...u.jsonfy(),nodeName:a[u.NODE_NAME],...u instanceof y.CheckConstraint?{}:{columns:[y.ColumnRef2.fromJSON({value:u.parentNode.name().value()})]}});return}return l()},s));let o=super.jsonfy(t,s,r);return e&&(o={...o,entries:o.entries.concat(n)}),o}};var Oe=class extends We{static get syntaxRules(){return{type:["CreateSchemaStmt","DropSchemaStmt","CreateTableStmt","DropTableStmt"]}}};var Cs=class extends Oe{static get syntaxRules(){let e={type:["NamespaceIdent","Identifier"],as:"name"},t={syntax:[{type:"keyword",value:"AUTHORIZATION"},{syntaxes:[{type:"keyword",as:"pg_authorization",value:["CURRENT_ROLE","CURRENT_USER","SESSION_USER"]},{type:"Identifier",as:"pg_authorization"}]}]},s={type:["CreateTableStmt"],as:"pg_entries",arity:1/0,optional:!0,dialect:"postgres"};return[{type:"keyword",value:"CREATE"},{type:"keyword",value:"SCHEMA",dialect:"postgres"},{type:"keyword",value:["SCHEMA","DATABASE"],dialect:"mysql"},{dialect:"postgres",syntaxes:[[{type:"keyword",as:"if_not_exists",value:"IF",booleanfy:!0},{type:"operator",value:"NOT"},{type:"keyword",value:"EXISTS"},{syntaxes:[[{...e},{...t,optional:!0}],{...t}]}],[{...e},{...t,optional:!0},{...s}],[{...t},{...s}]]},{dialect:"mysql",syntax:[{optional:!0,syntax:[{type:"keyword",as:"if_not_exists",value:"IF",booleanfy:!0},{type:"operator",value:"NOT"},{type:"keyword",value:"EXISTS"}]},{...e}]}]}ifNotExists(){return this._get("if_not_exists")}name(){return this._get("name")}pgAuthorization(){return this._get("pg_authorization")}pgEntries(){return this._get("pg_entries")}};var Is=class extends Oe{static get syntaxRules(){return[{type:"keyword",value:"DROP"},{type:"keyword",value:"SCHEMA",dialect:"postgres"},{type:"keyword",value:["SCHEMA","DATABASE"],dialect:"mysql"},{optional:!0,syntax:[{type:"keyword",as:"if_exists",value:"IF",booleanfy:!0},{type:"keyword",value:"EXISTS"}]},{type:["NamespaceIdent","Identifier"],as:"pg_names",arity:{min:1},itemSeparator:{type:"punctuation",value:","},dialect:"postgres"},{type:["NamespaceIdent","Identifier"],as:"my_name",dialect:"mysql"},{type:"keyword",as:"pg_cascade_rule",value:["CASCADE","RESTRICT"],optional:!0,dialect:"postgres"}]}ifExists(){return this._get("if_exists")}pgNames(){return this._get("pg_names")}myName(){return this._get("my_name")}pgCascadeRule(){return this._get("pg_cascade_rule")}};var ks=class extends Oe{static get syntaxRules(){return[{type:"keyword",value:"CREATE"},{optional:!0,syntaxes:[{type:"keyword",as:"temporary_kw",value:"TEMPORARY",booleanfy:!0},{type:"keyword",as:"temporary_kw",value:"TEMP",booleanfy:!0,dialect:"postgres"}]},{type:"keyword",value:"TABLE"},{optional:!0,syntax:[{type:"keyword",as:"if_not_exists",value:"IF",booleanfy:!0},{type:"operator",value:"NOT"},{type:"keyword",value:"EXISTS"}]},{type:"TableSchema",as:"argument"},{type:["ConfigAssignmentExprAlt1","ConfigAssignmentExprAlt2"],as:"my_create_options",arity:1/0,dialect:"mysql"}]}temporaryKW(){return this._get("temporary_kw")}ifNotExists(){return this._get("if_not_exists")}argument(){return this._get("argument")}myCreateOptions(){return this._get("my_create_options")}};var Ds=class extends Oe{static get syntaxRules(){return[{type:"keyword",value:"DROP"},{type:"keyword",as:"my_temporary_kw",value:"TEMPORARY",booleanfy:!0,optional:!0,dialect:"mysql"},{type:"keyword",value:"TABLE"},{optional:!0,syntax:[{type:"keyword",as:"if_exists",value:"IF",booleanfy:!0},{type:"keyword",value:"EXISTS"}]},{type:["TableIdent","Identifier"],as:"names",arity:{min:1},itemSeparator:{type:"punctuation",value:","}},{type:"keyword",as:"cascade_rule",value:["CASCADE","RESTRICT"],optional:!0}]}myTemporaryKW(){return this._get("my_temporary_kw")}ifExists(){return this._get("if_exists")}names(){return this._get("names")}cascadeRule(){return this._get("cascade_rule")}};var da={};Ie(da,{AssignmentExpr:()=>Ws,ColumnsConstructor:()=>qs,ConfigAssignmentExpr:()=>Hs,ConfigAssignmentExprAlt1:()=>Ks,ConfigAssignmentExprAlt2:()=>Ys,DeleteStmt:()=>Xs,InsertStmt:()=>Ze,MYOnDuplicateKeyUpdateClause:()=>Ms,MYPartitionClause:()=>Ls,MYSetStmt:()=>en,MYVarAssignmentExpr:()=>zs,PGConflictTarget:()=>Ps,PGConflictTargetIndexSpec:()=>js,PGDefaultValuesClause:()=>Us,PGOnConflictClause:()=>Bs,PGWhereCurrentClause:()=>Js,ReturningClause:()=>$s,SetClause:()=>Fs,TableAbstraction1:()=>Qs,TableAbstraction2:()=>Vs,UpdateStmt:()=>tn,UpsertStmt:()=>rn,UsingFromClause:()=>Gs,ValuesConstructor:()=>Ot});var Ms=class extends L{static get syntaxRules(){return{dialect:"mysql",syntax:[{type:"keyword",value:"ON"},{type:"keyword",value:"DUPLICATE"},{type:"keyword",value:"KEY"},{type:"keyword",value:"UPDATE"},{type:"AssignmentExpr",as:"entries",arity:{min:1},itemSeparator:{type:"punctuation",value:","},assert:!0,autoIndent:!0}]}}};var Ls=class extends L{static get syntaxRules(){return{dialect:"mysql",syntax:[{type:"keyword",value:"PARTITION"},{type:"Identifier",as:"entries",arity:{min:1},itemSeparator:{type:"punctuation",value:","},assert:!0}]}}};var Ps=class extends w{static get syntaxRules(){return{syntaxes:[[{type:"keyword",value:"ON"},{type:"keyword",value:"CONSTRAINT"},{type:"Identifier",as:"constraint_name",assert:!0}],[{type:"paren_block",syntax:{type:"PGConflictTargetIndexSpec",as:"index_list",arity:{min:1},itemSeparator:{type:"punctuation",value:","},assert:!0},autoIndent:!0},{type:"WhereClause",as:"where_clause",optional:!0,autoIndent:!0}]]}}constraintName(){return this._get("constraint_name")}indexList(){return this._get("index_list")}whereClause(){return this._get("where_clause")}};var js=class extends w{static get syntaxRules(){return[{syntaxes:[{type:"ColumnRef2",as:"column_name"},{type:"paren_block",syntax:{type:"Expr",as:"expr",assert:!0},autoIndent:!0},{type:"CallExpr",as:"expr"}]},{optional:!0,syntax:[{type:"operator",value:"COLLATE"},{type:"string_literal",as:"collation",assert:!0}]},{type:"Identifier",as:"opclass",optional:!0}]}columnName(){return this._get("column_name")}expr(){return this._get("expr")}collation(){return this._get("collation")}opclass(){return this._get("opclass")}};var Us=class extends w{static get syntaxRules(){return{dialect:"postgres",syntax:[{type:"keyword",as:".",value:"DEFAULT"},{type:"keyword",value:"VALUES"}]}}};var Bs=class extends L{static get syntaxRules(){return{dialect:"postgres",syntax:[{type:"keyword",value:"ON"},{type:"keyword",value:"CONFLICT"},{syntaxes:[[{type:"PGConflictTarget",as:"conflict_target",optional:!0},{type:"keyword",as:"do_nothing_kw",value:"DO",booleanfy:!0},{type:"keyword",value:"NOTHING"}],[{type:"PGConflictTarget",as:"conflict_target"},{type:"keyword",value:"DO"},{type:"keyword",value:"UPDATE"},{type:"keyword",value:"SET"},{type:"AssignmentExpr",as:"entries",arity:{min:1},itemSeparator:{type:"punctuation",value:","},assert:!0,autoIndent:!0},{type:"WhereClause",as:"where_clause",optional:!0,autoIndent:!0}]]}]}}conflictTarget(){return this._get("conflict_target")}doNothingKW(){return this._get("do_nothing_kw")}whereClause(){return this._get("where_clause")}};var At=class extends X(L){static get syntaxRules(){return{type:"SelectItem",as:"entries",arity:{min:1},itemSeparator:{type:"punctuation",value:","},assert:!0,autoIndent:2}}jsonfy(e={},t=null,s=null){let r=super.jsonfy(e,t,s);if(!e.deSugar)return r;let n=[],a=e.deSugar===!0||e.deSugar?.flattenUnaliasedRootObjects,o=!1,u=l=>{o&&(n=n.reduce((m,f)=>l.alias&&f.alias&&z(l.alias.value,f.alias.value,l.alias.delim||f.alias.delim)?m:m.concat(f),[])),n=n.concat(l)};for(let[l,m]of r.entries.entries())if(m.expr.value==="*")for(let f of m.result_schema){let p=f.jsonfy(),d={nodeName:y.SelectItemAlias.NODE_NAME,as_kw:!0,value:p.value,delim:p.delim};u({nodeName:y.SelectItem.NODE_NAME,expr:p,alias:d,result_schema:p.result_schema.clone(),_originalStarJson:m})}else if(a&&this.entries()[l].expr()instanceof y.LQObjectLiteral&&!this.entries()[l].alias()){let[f]=m.expr.arguments.reduce(([d,h],_)=>h?[[...d,[h,_]]]:[d,_],[[]]),p=m.expr.result_schema.entries();for(let d=0;d<f.length;d++)u({nodeName:y.SelectItem.NODE_NAME,expr:f[d][1],alias:{...f[d][0],nodeName:y.SelectItemAlias.NODE_NAME,as_kw:!0},result_schema:p[d]})}else u(m);return{...r,entries:n}}finalizeJSON(e,t,s,r){let n=r.deSugar===!0||r.deSugar?.expandStarRefs,a,[o,u]=e.entries.reduce(([l,m],{_originalStarJson:f,...p})=>{if(f&&(a=!0),f&&!n)return f.result_schema||(f.result_schema=y.JSONSchema.fromJSON({entries:[]},{assert:!0})),f.result_schema._add("entries",p.result_schema),[l.concat(f),m.concat(p.result_schema.clone())];if(!p.result_schema){let d=y.SelectItem.fromJSON(p,this.options);this._adoptNodes(d),p=d.jsonfy(r,t,s)}return[l.concat(p),m.concat(p.result_schema.clone())]},[[],[]]);return e={...e,entries:a&&!n?[...new Set(o)]:o,result_schema:y.JSONSchema.fromJSON({entries:u},{assert:!0})},t.statementContext.artifacts.set("outputSchemas",new Set(u)),e}};var $s=class extends At{static get syntaxRules(){return[{type:"keyword",value:"RETURNING"},...[].concat(super.syntaxRules)]}};var Js=class extends w{static get syntaxRules(){return{dialect:"postgres",syntax:[{type:"keyword",value:"WHERE"},{type:"keyword",value:"CURRENT OF"},{type:"identifier",as:"cursor_name",assert:!0}]}}cursorName(){return this._get("cursor_name")}};var Fs=class extends L{static get syntaxRules(){return[{type:"keyword",value:"SET"},{type:"AssignmentExpr",as:"entries",arity:{min:1},itemSeparator:{type:"punctuation",value:","},assert:!0,autoIndent:2}]}};var Gs=class extends L{static get syntaxRules(){return[{type:"keyword",value:"USING"},{type:"FromItem",as:"entries",arity:{min:1},itemSeparator:{type:"punctuation",value:","},assert:!0}]}};var qs=class extends L{static get syntaxRules(){return{syntax:[{type:"paren_block",syntax:{type:["LQDeepRef2","ColumnRef2"],as:"entries",arity:1/0,itemSeparator:{type:"punctuation",value:","},autoIndent:10}}]}}static get syntaxPriority(){return-1}};var Ot=class extends X(L){static get syntaxRules(){let e={type:"punctuation",value:","};return{syntaxes:[[{type:"keyword",value:"VALUES"},{type:["TypedRowConstructor","RowConstructor"],as:"entries",arity:{min:1},itemSeparator:e,assert:!0,autoIndent:2}],{dialect:"mysql",syntax:[{type:"keyword",value:["VALUES","VALUE"]},{type:["TypedRowConstructor","RowConstructor"],as:"entries",arity:{min:1},itemSeparator:e,assert:!0,autoIndent:2}]}]}}static get syntaxPriority(){return-1}jsonfy(e={},t=null,s=null){let r=super.jsonfy({...e,forceDeSugar:e.deSugar},t,s);if(e.deSugar){let n=r.entries?.[0]?.result_schema;r={...r,result_schema:n?.clone()}}return r}};var Ws=class extends re{static get syntaxRules(){return[{type:["LQDeepRef2","ColumnsConstructor","ColumnRef2"],as:"left",dialect:"postgres"},{type:["LQDeepRef2","ColumnRef1"],as:"left",dialect:"mysql"},{type:"operator",as:"operator",value:"="},{type:["ValuesTableLiteral","DerivedQuery","Expr"],as:"right"}]}};var Hs=class extends re{static get syntaxRules(){return[{type:"keyword",as:"my_default_kw",value:"DEFAULT",booleanfy:!0,dialect:"mysql",optional:!0},{syntaxes:[{type:"keyword",as:"left"},{type:"identifier",as:"left"}]},{type:"operator",as:"operator",value:"="},{syntaxes:[{type:"Expr",as:"right"},{type:"keyword",as:"right"}]}]}myDefaultKW(){return this._get("my_default_kw")}};var Ks=class extends re{static get syntaxRules(){return[{type:"keyword",as:"my_default_kw",value:"DEFAULT",booleanfy:!0,dialect:"mysql",optional:!0},{syntaxes:[{type:"keyword",as:"left"},{type:"identifier",as:"left"}]},{type:"operator",as:"operator",value:"=",optional:!0},{syntaxes:[{type:"Expr",as:"right"},{type:"keyword",as:"right"}]}]}myDefaultKW(){return this._get("my_default_kw")}};var Ys=class extends re{static get syntaxRules(){return[{type:"keyword",as:"default_kw",value:"DEFAULT",booleanfy:!0,optional:!0},{syntaxes:[{type:"keyword",as:"left"},{type:"identifier",as:"left"}]},{optional:!0,syntax:[{type:"operator",as:"operator",value:"="},{syntaxes:[{type:"Expr",as:"right"},{type:"keyword",as:"right"}]}]}]}myDefaultKW(){return this._get("my_default_kw")}};var zs=class extends re{static get syntaxRules(){return{dialect:"mysql",syntax:[{type:["UserVar","SystemVar"],as:"left"},{type:"operator",as:"operator",value:["=",":="]},{type:"Expr",as:"right"}]}}};var Vs=class extends X(w){static get syntaxRules(){return[{type:"keyword",as:"pg_only_kw",value:"ONLY",optional:!0,dialect:"postgres"},{type:"TableRef1",as:"table_ref",assert:!0},{type:"operator",as:"pg_star_ref",value:"*",booleanfy:!0,optional:!0,dialect:"postgres"},{type:"SelectItemAlias",as:"alias",optional:!0}]}tableRef(){return this._get("table_ref")}alias(){return this._get("alias")}pgOnlyKW(){return this._get("pg_only_kw")}pgStarRef(){return this._get("pg_star_ref")}deriveAlias(){let e;return this.alias()?e=this.alias():e=y.SelectItemAlias.fromJSON({as_kw:!0,value:this.tableRef().value(),delim:this.tableRef()._get("delim")}),e}jsonfy(e={},t=null,s=null){let r=super.jsonfy(e,t,s);if(e.deSugar){let n=r.alias||this.deriveAlias().jsonfy(),a={nodeName:y.Identifier.NODE_NAME,value:n.value,delim:n.delim},o=r.table_ref.result_schema.clone({renameTo:a});r.alias&&(o=o.clone({renameTo:{nodeName:y.Identifier.NODE_NAME,value:r.alias.value,delim:r.alias.delim}})),t.statementContext.artifacts.get("tableSchemas").add({resultSchema:o});let u=(e.deSugar===!0||e.deSugar?.tableAliases)&&n||r.alias;r={...r,alias:u,result_schema:o}}return r}};var Qs=class extends X(w){static get syntaxRules(){return[{type:"TableRef1",as:"table_ref"},{optional:!0,dialect:"mysql",syntax:[{type:"punctuation",value:".",autoSpacing:!1},{type:"operator",as:"my_star_ref",value:"*",booleanfy:!0,autoSpacing:!1}]},{type:"SelectItemAlias",as:"alias",optional:!0}]}tableRef(){return this._get("table_ref")}myStarRef(){return this._get("my_star_ref")}alias(){return this._get("alias")}deriveAlias(){let e;return this.alias()?e=this.alias():e=y.SelectItemAlias.fromJSON({as_kw:!0,value:this.tableRef().value(),delim:this.tableRef()._get("delim")}),e}jsonfy(e={},t=null,s=null){let r=super.jsonfy(e,t,s);if(e.deSugar){let n=r.alias||this.deriveAlias().jsonfy(),a={nodeName:y.Identifier.NODE_NAME,value:n.value,delim:n.delim},o=r.table_ref.result_schema.clone({renameTo:a});r.alias&&(o=o.clone({renameTo:{nodeName:y.Identifier.NODE_NAME,value:r.alias.value,delim:r.alias.delim}})),t.statementContext.artifacts.get("tableSchemas").add({resultSchema:o});let u=(e.deSugar===!0||e.deSugar?.tableAliases)&&n||r.alias;r={...r,alias:u,result_schema:o}}return r}};var vt=c=>class extends c{get isSelectorStmt(){return!0}jsonfy(e={},t=null,s=null){if(!e.deSugar)return super.jsonfy(e,t,s);let{ColumnRef1:r,ColumnRef2:n,AggrCallExpr:a,LQBackRefAbstraction:o,LQDeepRef1:u,LQBackRef:l}=y;return t=new te((m,f,p,{deSugar:d,asAggr:h,..._})=>{let g=x=>x instanceof r&&x.qualifier()instanceof o,E=x=>{let S=x.qualifier().jsonfy(),A={...x.jsonfy(),qualifier:void 0,nodeName:n.NODE_NAME},v=u.fromJSON({left:S,right:A});return x.parentNode._adoptNodes(v),v},N=x=>({nodeName:a.NODE_NAME,name:(_.toDialect||this.options.dialect)==="mysql"?"JSON_ARRAYAGG":"JSON_AGG",arguments:[x]});if(g(m)&&(m=E(m)),m instanceof u){let{select:x,detail:S}=this.createSelectorDimension(m,t,s,{..._,asAggr:h}),A=h?N(S.jsonfy()):S.jsonfy();return x(A)}if(m instanceof l||m instanceof o){m instanceof o&&(m=m.expr());let{alias:x}=this.createSelectorDimension(m,t,s,_);return x()}return f()},t,this),super.jsonfy(e,t,s)}createSelectorDimension(e,t,s,{asAggr:r=!1,...n}={}){let{lhsOperand:a,rhsOperand:o,rhsTable:u,detail:l}=e.resolve(t,s),m=t.statementContext.artifacts.get("selectorDimensions"),{CompleteSelectStmt:f,DerivedQuery:p,FromClause:d,JoinClause:h,OnClause:_,GroupByClause:g,GroupingElement:E,FromItem:N,SelectList:x,SelectItem:S,FromItemAlias:A,SelectItemAlias:v,TableRef1:b,ColumnRef1:O,BinaryExpr:T}=y,R=`dimension${r?"/g":""}|${[a,o,u].join("|")}`,k=t.statementContext.hash(R,"join");if(m?.has(k))return{...m.get(k),detail:l};let J=new Map,U=t.rand("key",J),P=o.jsonfy(),q={nodeName:S.NODE_NAME,expr:P,alias:{nodeName:v.NODE_NAME,as_kw:!0,value:U}},I={nodeName:h.NODE_NAME,join_type:"LEFT",expr:{nodeName:p.NODE_NAME,expr:{nodeName:f.NODE_NAME,select_list:{nodeName:x.NODE_NAME,entries:[q]},from_clause:{nodeName:d.NODE_NAME,entries:[{nodeName:N.NODE_NAME,expr:u.jsonfy({...n,deSugar:null})}]},group_by_clause:r?{nodeName:g.NODE_NAME,entries:[{nodeName:E.NODE_NAME,expr:{nodeName:O.NODE_NAME,value:U}}]}:void 0}},alias:{nodeName:A.NODE_NAME,as_kw:!0,value:k},condition_clause:{nodeName:_.NODE_NAME,expr:{nodeName:T.NODE_NAME,operator:"=",left:a.jsonfy({...n,deSugar:null},t,s),right:{nodeName:O.NODE_NAME,qualifier:{nodeName:b.NODE_NAME,value:k},value:U}}}},F={id:k,type:"join",query:I,alias:()=>({nodeName:b.NODE_NAME,value:k}),select:Y=>{let D=t.rand("ref",J);return I.expr.expr.select_list.entries.push({nodeName:S.NODE_NAME,expr:Y,alias:{nodeName:v.NODE_NAME,as_kw:!0,value:D}}),{nodeName:O.NODE_NAME,qualifier:{nodeName:b.NODE_NAME,value:k},value:D}},detail:l};return m.set(k,F),F}finalizeSelectorJSON(e,t,s,r){let n;[e,n]=this.preprocessSelectorDimensions(e,t,s,r),e={...e,join_clauses:e.join_clauses?.slice(0)||[]};for(let a of n){let o=y.JoinClause.fromJSON(a,this.options);this._adoptNodes(o);let u=t.transform(o,(l=r,m=t)=>o.jsonfy(l,m,s),null,r);e.join_clauses.push(u)}return e}preprocessSelectorDimensions(e,t,s,r){let n=t.statementContext.artifacts.get("selectorDimensions");if(!n.size)return[e,[]];if(this.options.dialect==="postgres"&&(this instanceof y.DeleteStmt||this instanceof y.UpdateStmt)){if(e.where_clause?.cursor_name)throw new Error('Deep/Back Refs are currently not supported with a "WHERE CURRENT OF..." statement');let{DerivedQuery:a,CompleteSelectStmt:o,SelectList:u,SelectItem:l,FromItemAlias:m,FromClause:f,WhereClause:p,TableRef1:d,BinaryExpr:h,FromItem:_}=y,g=t.rand("join"),E=e.table_expr,N=E.alias.value,x=E.alias.delim,S=`${g}:${N}`,v=E.result_schema.pkConstraint(!0)?.columns()[0].jsonfy({toKind:1}),b,O,T=q=>({nodeName:h.NODE_NAME,left:{...q,qualifier:{nodeName:d.NODE_NAME,value:N,delim:x}},operator:"=",right:{...q,qualifier:{nodeName:d.NODE_NAME,value:S}}}),R,k=q=>{if(!z(q.qualifier.value,N,q.qualifier.delim||x))return q;if(!b){let I={nodeName:_.NODE_NAME,expr:{nodeName:a.NODE_NAME,expr:{nodeName:o.NODE_NAME,select_list:{nodeName:u.NODE_NAME,entries:[]},from_clause:{nodeName:f.NODE_NAME,entries:[{nodeName:_.NODE_NAME,expr:E.table_ref}]}}},alias:{nodeName:m.NODE_NAME,as_kw:!0,value:S}};R=I.expr.expr.select_list.entries,v&&(R.push({nodeName:l.NODE_NAME,expr:v}),O={nodeName:p.NODE_NAME,expr:T(v)}),b=I}if(R.find(I=>z(I.expr.value,q.value,I.expr.delim||q.delim))||R.push({nodeName:l.NODE_NAME,expr:q}),!v){let I=T(q);O&&(I={nodeName:h.NODE_NAME,left:O.expr,operator:"AND",right:I}),O={nodeName:p.NODE_NAME,expr:I}}return{...q,qualifier:{nodeName:d.NODE_NAME,value:S}}},J=[];for(let[,{query:q}]of n)J.push({...q,condition_clause:{...q.condition_clause,expr:{...q.condition_clause.expr,left:k(q.condition_clause.expr.left)}}});let[U,P]=this instanceof y.DeleteStmt?["pg_using_clause","UsingFromClause"]:["pg_from_clause","FromClause"];if(b){let q=_.fromJSON(b,this.options);this._adoptNodes(q),e={...e,[U]:{nodeName:y[P].NODE_NAME,entries:(e[U]?.entries||[]).concat(q.jsonfy(r,t,s))},where_clause:e.where_clause?{nodeName:p.NODE_NAME,expr:{nodeName:h.NODE_NAME,left:O.expr,operator:"AND",right:e.where_clause.expr}}:O}}return[e,J]}return[e,[...n].map(([,{query:a}])=>a)]}};var Xe=class extends Se{static get syntaxRules(){return{type:["InsertStmt","UpsertStmt","UpdateStmt","DeleteStmt"]}}finalizeOutputJSON(e,t,s,r){if(e.returning_clause){let n=this.returningClause().finalizeJSON(e.returning_clause,t,s,r);e={...e,returning_clause:n,result_schema:n.result_schema}}else e={...e,result_schema:y.JSONSchema.fromJSON({entries:[]},this.options)};return e}};var Xs=class extends vt(Xe){static get syntaxRules(){let e={type:"punctuation",value:","};return[{type:"keyword",value:"DELETE"},{assert:!0,syntaxes:[{dialect:"postgres",syntax:[{type:"keyword",value:"FROM"},{type:"TableAbstraction2",as:"table_expr"},{type:"UsingFromClause",as:"pg_using_clause",optional:!0,autoIndent:!0},{type:"JoinClause",as:"join_clauses",arity:1/0,optional:!0,autoIndent:!0},{type:["PGWhereCurrentClause","WhereClause"],as:"where_clause",optional:!0,autoIndent:!0},{type:"ReturningClause",as:"returning_clause",optional:!0,autoIndent:!0}]},{dialect:"mysql",syntax:[{type:"Identifier",as:"my_delete_list",arity:{min:1},itemSeparator:e},{type:"FromClause",as:"my_from_clause",autoIndent:!0},{type:"JoinClause",as:"join_clauses",arity:1/0,optional:!0,autoIndent:!0},{type:"WhereClause",as:"where_clause",optional:!0,autoIndent:!0}]},{dialect:"mysql",syntax:[{type:"keyword",value:"FROM"},{type:"Identifier",as:"my_delete_list",arity:{min:1},itemSeparator:e},{type:"UsingFromClause",as:"my_using_clause",autoIndent:!0},{type:"JoinClause",as:"join_clauses",arity:1/0,optional:!0,autoIndent:!0},{type:"WhereClause",as:"where_clause",optional:!0,autoIndent:!0}]},{dialect:"mysql",syntax:[{type:"keyword",value:"FROM"},{type:"TableAbstraction2",as:"table_expr"},{type:"MYPartitionClause",as:"my_partition_clause",optional:!0,autoIndent:!0},{type:"WhereClause",as:"where_clause",optional:!0,autoIndent:!0},{type:"OrderByClause",as:"my_order_by_clause",optional:!0,dialect:"mysql",autoIndent:!0},{type:"LimitClause",as:"my_limit_clause",optional:!0,dialect:"mysql",autoIndent:!0}]}]}]}tableExpr(){return this._get("table_expr")}joinClauses(){return this._get("join_clauses")}whereClause(){return this._get("where_clause")}returningClause(){return this._get("returning_clause")}pgUsingClause(){return this._get("pg_using_clause")}myUsingClause(){return this._get("my_using_clause")}myPartitionClause(){return this._get("my_partition_clause")}myDeleteList(){return this._get("my_delete_list")}myFromClause(){return this._get("my_from_clause")}myOrderByClause(){return this._get("my_order_by_clause")}myLimitClause(){return this._get("my_limit_clause")}jsonfy(e={},t=null,s=null){if(!e.deSugar)return super.jsonfy(e,t,s);t=new te((n,a)=>a(),t,this);let r=super.jsonfy(e,t,s);return(e.toDialect||this.options.dialect)==="mysql"?r={uuid:r.uuid,nodeName:r.nodeName,my_delete_list:r.my_delete_list,my_from_clause:r.my_from_clause,my_using_clause:r.my_using_clause,join_clauses:r.join_clauses,where_clause:r.where_clause,table_expr:r.table_expr,my_partition_clause:r.my_partition_clause,my_order_by_clause:r.my_order_by_clause,my_limit_clause:r.my_limit_clause,returning_clause:r.returning_clause,result_schema:r.result_schema}:r={uuid:r.uuid,nodeName:r.nodeName,table_expr:r.table_expr,pg_using_clause:r.pg_using_clause,join_clauses:r.join_clauses,where_clause:r.where_clause,returning_clause:r.returning_clause,result_schema:r.result_schema},r=this.finalizeOutputJSON(r,t,s,e),r=this.finalizeSelectorJSON(r,t,s,e),r={...r,origin_schemas:this.getOriginSchemas(t)},r}};var Zs=c=>class extends c{get isPayloadStmt(){return!0}static morphsTo(){return y.CTE}jsonfy(e={},t=null,s=null){if(!e.deSugar)return super.jsonfy(e,t,s);let{LQDeepRef2:r,AssignmentExpr:n,DerivedQuery:a,ColumnsConstructor:o,ValuesConstructor:u,TypedRowConstructor:l,RowConstructor:m}=y,f=["column_list","pg_default_values_clause","values_clause","select_clause"].map(x=>this._get(x)),[p,d,h,_]=f,g=p?.entries().some(x=>x instanceof r),E=g?new Set(f):new Set;t=new te((x,S,A,{deSugar:v,...b})=>{if(E.has(x))return;if(!(x instanceof n))return S();let O=!!this._get("conflict_handling_clause")?.containsNode(x);if(O&&this.options.dialect!=="postgres")return S();let T={...b,conflictHandlingClauseContext:O};if(x.left()instanceof r){let[[R],[[k]]]=this.deSugarPayload(o.fromJSON({entries:[x.left().jsonfy()]}),[[x.right()]],t,s,T);return R?{nodeName:n.NODE_NAME,operator:"=",left:R,right:k}:void 0}if(x.left()instanceof o&&x.left().entries().some(R=>R instanceof r)){let R=x.left(),k,J;return x.right()instanceof m?([k,[J]]=this.deSugarPayload(R,[x.right().entries()],t,s,T),J={nodeName:l.NODE_NAME,entries:J}):x.right()instanceof a?([k,J]=this.deSugarPayload(R,x.right().expr(),t,s,T),J={nodeName:a.NODE_NAME,expr:J}):[k,[J]]=this.deSugarPayload(R,[[x.right()]],t,s,T),k.length?{nodeName:n.NODE_NAME,operator:"=",left:{nodeName:o.NODE_NAME,entries:k},right:J}:void 0}return S()},t,this);let N=super.jsonfy(e,t,s);if(g){let[x,S]=this.deSugarPayload(p,d||h?.entries().map(A=>A.entries())||_,t,s,e);if(N={...N,column_list:{nodeName:o.NODE_NAME,entries:x}},d&&Array.isArray(S)||h){let A=S.map(v=>({nodeName:l.NODE_NAME,entries:v}));N={...N,values_clause:{nodeName:u.NODE_NAME,entries:A}}}else d?N={...N,pg_default_values_clause:S}:N={...N,select_clause:S}}return N}deSugarPayload(e,t,s,r,{conflictHandlingClauseContext:n=!1,deSugar:a,...o}={}){let u=s.statementContext.artifacts.get("payloadDimensions"),{LQDeepRef2:l,TableRef1:m,ColumnRef1:f,SelectItemAlias:p,ColumnRef2:d,ColumnsConstructor:h,TypedRowConstructor:_,RowConstructor:g,DefaultLiteral:E,SelectStmt:N,CompleteSelectStmt:x,PGDefaultValuesClause:S,SelectList:A,SelectItem:v,FromClause:b,FromItem:O}=y,T=(j,K=a)=>j.jsonfy({...o,deSugar:K},s,r),R=(j,K)=>j.entries().reduce((F,Y,D)=>{if(Y instanceof l){let $=this.createPayloadDimension(Y,s,r,{conflictHandlingClauseContext:n,...o});return K.set(D,$),$.refMode==="dependency"&&$.lhsOperandJson?F.concat({nodeName:d.NODE_NAME,value:$.lhsOperandJson.value,delim:$.lhsOperandJson.delim,result_schema:$.lhsOperandJson.result_schema}):F}return F.concat(T(Y))},[]),k=(j,K)=>{let F=e.entries().reduce((Y,D,$)=>{let H=K.has($)?K.get($).offload(j):{nodeName:E.NODE_NAME,value:"DEFAULT"};return H?Y.concat(H):Y},[]);return e.length-F.length===K.size?j.jsonfy():[F]},J=(j,K)=>j.map((F,Y)=>F.reduce((D,$,H)=>{let C;return e.get(H)instanceof l&&$ instanceof E?C=K.get(H).offload(S.fromJSON({value:"DEFAULT"},this.options),Y):K.has(H)?C=K.get(H).offload($,Y):C=T($),C?D.concat(C):D},[])),U=(j,K)=>{let F={...T(j,2),result_schema:void 0},Y=F.select_list.entries;if(Y.length!==e.length)throw new Error(`Select list (${Y.length}) does not match columns length (${e.length})`);let D;if(!n&&F.from_clause&&!/^[`"]\$memo~.+[`"]$/.test(j.fromClause().entries()[0].expr()+"")){let C=s.rootContext.rand("memo");D={...F,uuid:C,select_list:{nodeName:A.NODE_NAME,entries:[za("$row_number~a")]}},u.add({refMode:"memo",query:D});let W={nodeName:O.NODE_NAME,expr:{nodeName:m.NODE_NAME,value:C}};F={nodeName:x.NODE_NAME,select_list:{nodeName:A.NODE_NAME,entries:[]},from_clause:{nodeName:b.NODE_NAME,entries:[W]}}}let $=(C,W=!1)=>D?(C.alias&&W?C={...C,alias:{...C.alias,value:C.alias.value+s.rand("rand",{asSalt:!0})}}:C.alias||(C.alias={nodeName:p.NODE_NAME,as_kw:!0,value:s.rand("value")}),D.select_list.entries.push(C),{nodeName:v.NODE_NAME,expr:{nodeName:f.NODE_NAME,value:C.alias.value,delim:C.alias.delim}}):C,H=Y.reduce((C,W,M)=>{if(K.has(M)){let B;[_.NODE_NAME,g.NODE_NAME].includes(W.expr.nodeName)?(B=W.expr.entries.map(ie=>$({nodeName:v.NODE_NAME,expr:ie,alias:W.alias},!0)),e.get(M).right()instanceof h||(B=[{nodeName:v.NODE_NAME,expr:{nodeName:_.NODE_NAME,entries:B.map(ie=>ie.expr)}}])):B=[$(W)];let me=N.fromJSON({...F,select_list:{nodeName:A.NODE_NAME,entries:B}},this.options);if(W=K.get(M).offload(me),W){let ie=K.get(M).lhsOperandJson;return C.concat({nodeName:v.NODE_NAME,expr:W,alias:{nodeName:p.NODE_NAME,as_kw:!0,value:ie.value,delim:ie.delim}})}return C}if(!W.alias){let B=e.get(M);W={...W,alias:{nodeName:p.NODE_NAME,as_kw:!0,value:B.value(),delim:B._get("delim")}}}return C.concat($(W))},[]);return F={...F,select_list:{nodeName:A.NODE_NAME,entries:H}},F},P=new Map,q=R(e,P),I=t instanceof S?k(t,P):t instanceof N?U(t,P):J(t,P);return P.clear(),[q,I]}createPayloadDimension(e,t,s,{conflictHandlingClauseContext:r=!1,...n}={}){let{lhsOperand:a,rhsOperand:o,rhsTable:u,detail:l}=e.resolve(t,s,2),m=t.statementContext.artifacts.get("payloadDimensions"),{LQDeepRef2:f,LQBackRefAbstraction:p,ReturningClause:d,ColumnRef2:h,ColumnRef1:_,TableRef1:g,SelectList:E,SelectItem:N,SelectItemAlias:x,AssignmentExpr:S,ColumnsConstructor:A,TypedRowConstructor:v,RowConstructor:b,PGDefaultValuesClause:O,ValuesConstructor:T,ValuesTableLiteral:R,DefaultLiteral:k,SelectStmt:J,WhereClause:U,CompleteSelectStmt:P,ScalarSubquery:q,DerivedQuery:I,FromItem:j,FromClause:K,SetClause:F,BinaryExpr:Y,BoolLiteral:D,NumberLiteral:$,UpdateStmt:H,TableAbstraction2:C}=y,W=t.rootContext.hash(this,"main"),M=G=>G.jsonfy(n,t,s),B=M(a),me=M(o),ie=M(u),fe=a.jsonfy({toKind:1}),xe=o.jsonfy({toKind:1}),sa={...ie,nodeName:g.NODE_NAME},Ce=e.left()instanceof p?"dependent":"dependency",Pe=l instanceof f,Ge;if(l instanceof A)Ge=M(l);else if(l instanceof h||l instanceof f)Ge={nodeName:A.NODE_NAME,entries:[M(l)]};else throw new Error(`Invalid columns spec: ${e}`);let La=Ge.entries.length,ct=(G,Q=null)=>{if(Pe)return G;let oe=1;if(Q?oe=Q.length:G instanceof b||G instanceof J||G instanceof J?oe=G.length:G instanceof I&&(oe=G.expr().length),oe>La)throw new Error(`[${G}] Payload has more columns than target columns: ${l}.`);if(oe<La)throw new Error(`[${G}] Payload has fewer columns than target columns: ${l}.`);return G},Qt=(G,Q,oe=null,ye=null)=>{let V,ee;typeof oe=="number"?ee={nodeName:$.NODE_NAME,value:oe+1}:oe&&(ee=oe),ee?V={nodeName:Y.NODE_NAME,left:{nodeName:_.NODE_NAME,value:"$row_number~b"},operator:"=",right:ee}:ye&&(V={nodeName:Y.NODE_NAME,left:{nodeName:_.NODE_NAME,value:ye},operator:"IS",right:{nodeName:D.NODE_NAME,value:"TRUE"}});let se={nodeName:j.NODE_NAME,expr:{nodeName:g.NODE_NAME,value:ee?`${G}~indices`:G}},Lt={nodeName:P.NODE_NAME,select_list:{nodeName:E.NODE_NAME,entries:[{nodeName:N.NODE_NAME,expr:{...Q,qualifier:void 0}}]},from_clause:{nodeName:K.NODE_NAME,entries:[se]},where_clause:V&&{nodeName:U.NODE_NAME,expr:V}};return{nodeName:q.NODE_NAME,expr:Lt}};if(this instanceof H||r){let G=r?`${W}_conflict_based_update`:null,Q={nodeName:Y.NODE_NAME,left:xe,operator:"IN",right:Qt(W,B,null,G)},oe={uuid:t.rootContext.rand(Ce),nodeName:H.NODE_NAME,table_expr:{nodeName:C.NODE_NAME,table_ref:sa},set_clause:{nodeName:F.NODE_NAME,entries:[]},where_clause:{nodeName:U.NODE_NAME,expr:Q}},V={refMode:Ce,query:oe,offload:ee=>{if(ee instanceof R)throw new Error(`Single-row payload structure expected for column structure: ${l}. Recieved ${ee.NODE_NAME}.`);if(oe.set_clause.entries.length)throw new Error(`Unexpected multiple offload() call on ${e}`);let se=M(ee);if(Pe&&!(ee instanceof O)&&(ee=v.fromJSON({entries:[se]},this.options),se=M(ee)),ee instanceof J?(se={nodeName:I.NODE_NAME,expr:se,result_schema:se.result_schema},ct(ee,se.result_schema)):ee instanceof I?ct(ee,se.result_schema):ee instanceof b?ct(ee):ee instanceof O||(se={nodeName:v.NODE_NAME,entries:[se]}),oe.set_clause.entries.push({nodeName:S.NODE_NAME,left:Ge,operator:"=",right:se}),Ce==="dependency")return fe},lhsOperandJson:B,conflictHandlingClauseContext:r};return m.add(V),V}let ge=[],na=(G,Q,oe=null)=>{if(Q instanceof O)if(oe){let ye=G.column_list.entries.length-1;G.values_clause.entries.push({nodeName:v.NODE_NAME,entries:G.column_list.entries.map((V,ee)=>ee===ye?oe:{nodeName:k.NODE_NAME,value:"DEFAULT"})})}else delete G.values_clause,G.pg_default_values_clause=M(Q);else{ct(Q);let ye=M(Q);Q instanceof b||(ye={nodeName:v.NODE_NAME,entries:[ye]}),oe&&(ye={...ye,entries:ye.entries.concat(oe)}),G.values_clause.entries.push(ye)}};if(Ce==="dependent"){let G=()=>({uuid:t.rootContext.rand(Ce),nodeName:this.NODE_NAME,table_ref:ie,column_list:A.fromJSON({entries:Ge.entries.concat(me)}).jsonfy()}),Q=(V,ee)=>{let se={nodeName:N.NODE_NAME,expr:ee,alias:o instanceof h?{nodeName:x.NODE_NAME,as_kw:!0,value:o.value(),delim:o._get("delim")}:void 0};return{...V,select_list:{...V.select_list,entries:V.select_list.entries.concat(se)}}},ye={refMode:Ce,queries:ge,offload:(V,ee=null)=>{ge.length||ge.push(G());let se=ge[ge.length-1];V instanceof J&&(ee={nodeName:_.NODE_NAME,value:"$row_number~a"});let Lt=Qt(W,B,ee),Ua;if(V instanceof I&&(V=V.expr(),(se.select_clause||se.values_clause)&&(se=G(),ge.push(se)),Ua=!0),V instanceof J){let ft=M(V);!Ua&&!Pe&&(ft=Ya(ft,Ge)),ct(V,ft.result_schema),se.select_clause=Q(ft,Lt);return}if(se.select_clause&&(se=G(),ge.push(se)),se.values_clause||(se.values_clause={nodeName:T.NODE_NAME,entries:[]}),Pe&&!(V instanceof O)&&(V=v.fromJSON({entries:[M(V)]})),V instanceof R)for(let ft of V.entries())na(se,ft,Lt);else na(se,V,Lt)},lhsOperandJson:B};return m.add(ye),ye}let Pa={nodeName:_.NODE_NAME,value:o.value(),delim:o._get("delim")},aa=()=>({uuid:t.rootContext.rand(Ce),nodeName:this.NODE_NAME,table_ref:ie,column_list:Ge,returning_clause:{nodeName:d.NODE_NAME,entries:[{nodeName:N.NODE_NAME,expr:xe}]}}),ja={refMode:Ce,queries:ge,offload:G=>{if(G instanceof R)throw new Error(`Single-row payload structure expected for column structure: ${e.right()}. Recieved ${G.NODE_NAME}.`);ge.length||ge.push(aa());let Q=ge[ge.length-1],oe=!1;if(G instanceof I&&(G=G.expr(),(Q.select_clause||Q.values_clause)&&(Q=aa(),ge.push(Q)),oe=!0),G instanceof J){let V=M(G),ee;return oe||(Pe||(V=Ya(V,Ge)),ee={nodeName:_.NODE_NAME,value:"$row_number~a"}),ct(G,V.result_schema),Q.select_clause=V,Qt(Q.uuid,Pa,ee)}Q.select_clause&&(Q=aa(),ge.push(Q)),Q.values_clause||(Q.values_clause={nodeName:T.NODE_NAME,entries:[]}),Pe&&!(G instanceof O)&&(G=v.fromJSON({entries:[M(G)]})),na(Q,G);let ye;return Q.values_clause&&(ye=Q.values_clause.entries.length-1),Qt(Q.uuid,Pa,ye)},lhsOperandJson:B,rhsOperandJson:xe};return m.add(ja),ja}finalizePayloadJSON(e,t,s,r){let n=t.statementContext.artifacts.get("payloadDimensions");if(!n.size)return e;let{ColumnRef0:a,ColumnRef1:o,TableRef1:u,FromItem:l,FromClause:m,AggrCallExpr:f,ReturningClause:p,SelectList:d,SelectItem:h,SelectItemAlias:_,NumberLiteral:g,BinaryExpr:E,CTE:N,CTEItem:x,CTEItemAlias:S,CompleteSelectStmt:A,UpdateStmt:v}=y,b=t.rootContext.hash(this,"main"),O={nodeName:N.NODE_NAME,declarations:[],body:null},T=t,R=(I,j,K=[],F=T)=>{let Y=x.fromJSON({nodeName:x.NODE_NAME,alias:{nodeName:S.NODE_NAME,value:I},expr:j},this.options).jsonfy(r,F,s);if(Y.expr?.nodeName===N.NODE_NAME){if(O.declarations.push(...Y.expr.declarations),this instanceof v&&Y.expr.body.nodeName===A.NODE_NAME)return;Y={nodeName:x.NODE_NAME,alias:{nodeName:S.NODE_NAME,value:I},expr:Y.expr.body}}O.declarations.push(Y),K.length&&O.declarations.push(x.fromJSON({nodeName:x.NODE_NAME,alias:{nodeName:S.NODE_NAME,value:`${I}~indices`},expr:Ai(K,I)},this.options).jsonfy(r,F,s))},k=[],J=[],U=[],P=!1,q=e.returning_clause?.entries||[];for(let{refMode:I,query:j,queries:K,lhsOperandJson:F,rhsOperandJson:Y,conflictHandlingClauseContext:D}of n)for(let{uuid:$,...H}of j&&[j]||K)if(I==="dependent"||this instanceof v&&I==="dependency"||D){if(!U.find(C=>z(C.expr.value,F.value))){let C={nodeName:h.NODE_NAME,expr:F};q.find(W=>z((W.alias||W.expr).value,F.value))&&(C.alias={nodeName:_.NODE_NAME,as_kw:!0,value:t.rand("key")}),U.push(C)}D&&(P=!0),k.push({uuid:$,...H})}else if(I==="dependency"){let C=[{nodeName:h.NODE_NAME,expr:Y}];e.select_clause?J.push({uuid:$,wherePredicate:C,...H}):H.pg_default_values_clause||H.select_clause?R($,H):R($,H,C)}else R($,H);for(let{uuid:I,wherePredicate:j,...K}of J)R(I,K,j);if(k.length){let I=[],j=[];for(let D of q)D.alias||(D={...D,alias:{nodeName:_.NODE_NAME,as_kw:!0,value:t.rand("key")}}),I.push(D),j.push({...D,expr:{nodeName:o.NODE_NAME,value:D.alias.value,delim:D.alias.delim}});if(P){let D=`${b}_conflict_based_update`;I.push({nodeName:h.NODE_NAME,expr:{nodeName:E.NODE_NAME,left:{nodeName:o.NODE_NAME,value:"XMAX"},operator:"!=",right:{nodeName:g.NODE_NAME,value:"0"}},alias:{nodeName:_.NODE_NAME,as_kw:!0,value:D}})}let K={nodeName:p.NODE_NAME,entries:[...I,...U]};this instanceof v||P?R(b,{...e,returning_clause:K}):e.pg_default_values_clause?R(b,{...e,returning_clause:K}):R(b,{...e,returning_clause:K},U);for(let{uuid:D,...$}of k)R(D,$);let F=j;F.length||(F=[{nodeName:h.NODE_NAME,expr:{nodeName:f.NODE_NAME,name:"COUNT",arguments:[{nodeName:a.NODE_NAME,value:"*"}]},alias:{nodeName:_.NODE_NAME,as_kw:!0,value:"COUNT"}}]);let Y={nodeName:l.NODE_NAME,expr:{nodeName:u.NODE_NAME,value:b}};O.body=A.fromJSON({nodeName:A.NODE_NAME,select_list:{nodeName:d.NODE_NAME,entries:F},from_clause:{nodeName:m.NODE_NAME,entries:[Y]}},this.options).jsonfy(r,T,s)}else{let j=[this.constructor].concat(this.constructor.morphsTo()).reduce((K,F)=>K||F.fromJSON(e,this.options),void 0);O.body=j.jsonfy(r,T,s)}return{...O,origin_schemas:O.body.origin_schemas,result_schema:O.body.result_schema}}},Ya=(c,e)=>{let t=c.select_list.entries.reduce((s,r,n)=>{if(!r.alias){let a=e.entries[n];r={...r,alias:{nodeName:y.SelectItemAlias.NODE_NAME,as_kw:!0,value:a.value,delim:a.delim}}}return s.concat(r)},[]);return{...c,select_list:{...c.select_list,entries:t}}},Ai=(c,e)=>{let t=za("$row_number~b");c=c.map(r=>r.alias?{...r,expr:{...r.expr,value:r.alias.value,delim:r.alias.delim,qualifier:void 0},alias:{...r.alias,value:r.expr.value,delim:r.expr.delim}}:r.expr.nodeName===y.ColumnRef0.NODE_NAME?i:{...r,expr:{...r.expr,qualifier:void 0},alias:{nodeName:y.SelectItemAlias.NODE_NAME,as_kw:!0,value:r.expr.value,delim:r.expr.delim}}).concat(t);let s={nodeName:y.FromItem.NODE_NAME,expr:{nodeName:y.TableRef1.NODE_NAME,value:e}};return{nodeName:y.CompleteSelectStmt.NODE_NAME,select_list:{nodeName:y.SelectList.NODE_NAME,entries:c},from_clause:{nodeName:y.FromClause.NODE_NAME,entries:[s]}}},za=c=>({nodeName:y.SelectItem.NODE_NAME,expr:{nodeName:y.AggrCallExpr.NODE_NAME,name:"ROW_NUMBER",arguments:[],over_clause:{nodeName:y.WindowSpec.NODE_NAME}},alias:{nodeName:y.SelectItemAlias.NODE_NAME,as_kw:!0,value:c||3}});var Ze=class extends Zs(Xe){static get _clause(){return"INSERT"}static get syntaxRules(){let e={optional:!0,syntax:[{type:"keyword",value:"AS",booleanfy:!0},{type:"Identifier",as:"pg_table_alias",assert:!0}]},t={optional:!0,dialect:"mysql",if:["!select_clause","!my_table_clause"],syntax:[{type:"keyword",value:"AS"},{type:"FromItemAlias",as:"my_row_alias",assert:!0}]};return[{type:"keyword",value:this._clause},{type:"keyword",value:"INTO"},{assert:!0,syntax:[{dialect:"postgres",syntax:[{type:"TableRef2",as:"table_ref"},{...e},{type:"ColumnsConstructor",as:"column_list",optional:!0,autoIndent:!0},{syntaxes:[{type:"PGDefaultValuesClause",as:"pg_default_values_clause"},{type:"ValuesConstructor",as:"values_clause"},{type:"SelectStmt",as:"select_clause"}],autoSpacing:`
`},...this._clause==="INSERT"?[{type:"PGOnConflictClause",as:"conflict_handling_clause",optional:!0,autoSpacing:`
`}]:[],{type:"ReturningClause",as:"returning_clause",optional:!0,autoSpacing:`
`}]},{dialect:"mysql",syntax:[{type:"TableRef2",as:"table_ref"},{type:"MYPartitionClause",as:"my_partition_clause",optional:!0,autoIndent:!0},{syntaxes:[[{type:"ColumnsConstructor",as:"column_list",optional:!0,autoIndent:!0},{syntaxes:[{type:"ValuesConstructor",as:"values_clause"},{type:"SelectStmt",as:"select_clause"},{type:"TableStmt",as:"my_table_clause"}],autoSpacing:`
`}],{type:"SetClause",as:"my_set_clause",autoSpacing:`
`}]},{...t},...this._clause==="INSERT"?[{type:"MYOnDuplicateKeyUpdateClause",as:"conflict_handling_clause",optional:!0,autoSpacing:`
`}]:[],{type:"ReturningClause",as:"returning_clause",optional:!0,autoSpacing:`
`}]}]}]}tableRef(){return this._get("table_ref")}columnList(){return this._get("column_list")}valuesClause(){return this._get("values_clause")}selectClause(){return this._get("select_clause")}conflictHandlingClause(){return this._get("conflict_handling_clause")}returningClause(){return this._get("returning_clause")}pgTableAlias(){return this._get("pg_table_alias")}pgDefaultValuesClause(){return this._get("pg_default_values_clause")}myRowAlias(){return this._get("my_row_alias")}myPartitionClause(){return this._get("my_partition_clause")}mySetClause(){return this._get("my_set_clause")}myTableClause(){return this._get("my_table_clause")}jsonfy(e={},t=null,s=null){if(!e.deSugar)return super.jsonfy(e,t,s);t=new te((a,o)=>{if(a instanceof y.TableRef2){let u=o(),l=u.result_schema;return u.pg_table_alias&&(l=l.clone({renameTo:u.pg_table_alias})),t.statementContext.artifacts.get("tableSchemas").add({type:"dml",resultSchema:l}),u}return o()},t,this);let r=super.jsonfy(e,t,s),n=e.toDialect||this.options.dialect;if(n==="mysql"?r={uuid:r.uuid,nodeName:r.nodeName,table_ref:r.table_ref,my_partition_clause:r.my_partition_clause,column_list:r.column_list,values_clause:r.values_clause,select_clause:r.select_clause,my_table_clause:r.my_table_clause,my_set_clause:r.my_set_clause,my_row_alias:r.my_row_alias,conflict_handling_clause:r.conflict_handling_clause,returning_clause:r.returning_clause,result_schema:r.result_schema}:r={uuid:r.uuid,nodeName:r.nodeName,table_ref:r.table_ref,pg_table_alias:r.pg_table_alias,column_list:r.column_list,pg_default_values_clause:r.pg_default_values_clause,values_clause:r.values_clause,select_clause:r.select_clause,conflict_handling_clause:r.conflict_handling_clause,returning_clause:r.returning_clause,result_schema:r.result_schema},r.conflict_handling_clause?.entries&&!r.conflict_handling_clause.entries.length){let o=r.table_ref.result_schema.pkConstraint(!0).columns()[0];r={...r,conflict_handling_clause:{...r.conflict_handling_clause,entries:[{nodeName:y.AssignmentExpr.NODE_NAME,left:o.jsonfy(),operator:"=",right:o.jsonfy({toKind:1})}]}}}return n==="postgres"&&!r.pg_table_alias&&(e.deSugar===!0||Number(e.deSugar?.tableAliases)===1)&&(r={...r,pg_table_alias:{nodeName:y.Identifier.NODE_NAME,value:r.table_ref.value,delim:r.table_ref.delim}}),r=this.finalizeOutputJSON(r,t,s,e),r={...r,origin_schemas:this.getOriginSchemas(t)},r=this.finalizePayloadJSON(r,t,s,e),r}};var en=class extends L{static get syntaxRules(){return[{type:"keyword",value:"SET"},{type:"MYVarAssignmentExpr",as:"entries",arity:{min:1},itemSeparator:{type:"punctuation",value:","},assert:!0,autoIndent:2}]}};var tn=class extends Zs(vt(Xe)){static get syntaxRules(){return[{type:"keyword",value:"UPDATE"},{assert:!0,syntaxes:[{dialect:"postgres",syntax:[{type:"TableAbstraction2",as:"table_expr"},{type:"SetClause",as:"set_clause",autoSpacing:`
`},{type:"FromClause",as:"pg_from_clause",optional:!0,dialect:"postgres",autoSpacing:`
`},{type:"JoinClause",as:"join_clauses",arity:1/0,optional:!0,autoSpacing:`
`},{type:["PGWhereCurrentClause","WhereClause"],as:"where_clause",optional:!0,autoSpacing:`
`},{type:"ReturningClause",as:"returning_clause",optional:!0,autoSpacing:`
`}]},{dialect:"mysql",syntax:[{type:"TableAbstraction2",as:"table_expr"},{type:"SetClause",as:"set_clause",autoSpacing:`
`},{type:"WhereClause",as:"where_clause",optional:!0,autoSpacing:`
`},{type:"OrderByClause",as:"my_order_by_clause",optional:!0,autoSpacing:`
`},{type:"LimitClause",as:"my_limit_clause",optional:!0,autoSpacing:`
`},{type:"ReturningClause",as:"returning_clause",optional:!0,autoSpacing:`
`}]},{dialect:"mysql",syntax:[{type:"TableAbstraction1",as:"my_update_list",arity:{min:1},itemSeparator:{type:"punctuation",value:","}},{type:"JoinClause",as:"join_clauses",arity:1/0,optional:!0,autoSpacing:`
`},{type:"SetClause",as:"set_clause",autoSpacing:`
`},{type:"WhereClause",as:"where_clause",optional:!0,autoSpacing:`
`},{type:"ReturningClause",as:"returning_clause",optional:!0,autoSpacing:`
`}]}]}]}tableExpr(){return this._get("table_expr")}joinClauses(){return this._get("join_clauses")}setClause(){return this._get("set_clause")}whereClause(){return this._get("where_clause")}returningClause(){return this._get("returning_clause")}pgFromClause(){return this._get("pg_from_clause")}myUpdateList(){return this._get("my_update_list")}myOrderByClause(){return this._get("my_order_by_clause")}myLimitClause(){return this._get("my_limit_clause")}jsonfy(e={},t=null,s=null){if(!e.deSugar)return super.jsonfy(e,t,s);let r={set_clause:null};t=new te((a,o)=>{if(a instanceof y.SetClause){r.set_clause=o;return}return o()},t,this);let n=super.jsonfy(e,t,s);if(n={...n,set_clause:r.set_clause()},(e.toDialect||this.options.dialect)==="mysql"?n={uuid:n.uuid,nodeName:n.nodeName,table_expr:n.table_expr,my_update_list:n.my_update_list,join_clauses:n.join_clauses,set_clause:n.set_clause,where_clause:n.where_clause,my_order_by_clause:n.my_order_by_clause,my_limit_clause:n.my_limit_clause,returning_clause:n.returning_clause,result_schema:n.result_schema}:n={uuid:n.uuid,nodeName:n.nodeName,table_expr:n.table_expr,set_clause:n.set_clause,pg_from_clause:n.pg_from_clause,join_clauses:n.join_clauses,where_clause:n.where_clause,returning_clause:n.returning_clause,result_schema:n.result_schema},!n.set_clause?.entries.length){let o=n.table_expr.result_schema.pkConstraint(!0).columns()[0];n={...n,set_clause:{...n.set_clause,entries:[{nodeName:y.AssignmentExpr.NODE_NAME,left:o.jsonfy(),operator:"=",right:o.jsonfy({toKind:1})}]}}}return n=this.finalizeOutputJSON(n,t,s,e),n=this.finalizeSelectorJSON(n,t,s,e),n={...n,origin_schemas:this.getOriginSchemas(t)},n=this.finalizePayloadJSON(n,t,s,e),n}};var rn=class extends gt(Ze){static get _clause(){return"UPSERT"}static morphsTo(){return[Ze].concat(super.morphsTo())}finalizePayloadJSON(e,t,s,r){if(e.conflict_handling_clause)throw new Error("An explicit conflict handling clause is forbidden on the UPSERT statement.");let n=[...t.statementContext.artifacts.get("tableSchemas")].map(l=>l.resultSchema)[0],a=r.toDialect||this.options.dialect,o;e.my_set_clause?o=e.my_set_clause.entries.map(l=>({value:l.left.value,delim:l.left.delim})):e.column_list?o=e.column_list.entries.map(l=>({value:l.value,delim:l.delim})):o=n.columns().map(l=>l.name().jsonfy({nodeNames:!1}));let u={nodeName:a==="mysql"?y.MYOnDuplicateKeyUpdateClause.NODE_NAME:y.PGOnConflictClause.NODE_NAME,entries:o.map(l=>({nodeName:y.AssignmentExpr.NODE_NAME,left:{nodeName:a==="mysql"?y.ColumnRef1.NODE_NAME:y.ColumnRef2.NODE_NAME,...l},operator:"=",right:a==="mysql"?{nodeName:y.CallExpr.NODE_NAME,name:"VALUES",arguments:[{nodeName:y.ColumnRef1.NODE_NAME,...l}]}:{...l,nodeName:y.ColumnRef1.NODE_NAME,qualifier:{value:"EXCLUDED"}}}))};if(a==="postgres"){let l=[].concat(n.pkConstraint(!0)||[]).concat(n.ukConstraints(!0)).map(f=>f.columns().map(p=>p.jsonfy()));if(!l.length)throw new Error(`Table ${this.tableRef()} has no unique keys defined to process an UPSERT operation. You may want to perform a direct INSERT operation.`);let m=l.find(f=>f.find(p=>o.find(d=>z(p.value,d.value,p.delim||d.delim))))||l[0];u.conflict_target={nodeName:y.PGConflictTarget.NODE_NAME,index_list:m.map(f=>({nodeName:y.PGConflictTargetIndexSpec.NODE_NAME,column_name:f}))}}return super.finalizePayloadJSON({...e,nodeName:Ze.NODE_NAME,conflict_handling_clause:u},t,s,r)}};var ha={};Ie(ha,{BasicSelectStmt:()=>Tt,CompleteSelectStmt:()=>Pn,CompositeSelectStmt:()=>jn,DerivedQuery:()=>ht,DistinctClause:()=>sn,ForClause:()=>nn,FromClause:()=>an,FromItem:()=>bt,FromItemAlias:()=>vn,GroupByClause:()=>on,GroupingElement:()=>ln,HavingClause:()=>un,JoinClause:()=>cn,LimitClause:()=>fn,OffsetClause:()=>pn,OnClause:()=>mn,OrderByClause:()=>yn,OrderElement:()=>dn,PGFetchClause:()=>_n,PGOrderOperator:()=>gn,PartitionByClause:()=>hn,SRFExpr1:()=>Rn,SRFExpr2:()=>Cn,SRFExpr3:()=>In,SRFExpr4:()=>kn,SRFExprDDL1:()=>Dn,SRFExprDDL2:()=>Mn,SelectItem:()=>bn,SelectItemAlias:()=>Tn,SelectList:()=>At,SelectStmt:()=>et,TableStmt:()=>Un,UsingClause:()=>En,ValuesTableLiteral:()=>Ln,WhereClause:()=>Nn,WindowClause:()=>xn,WindowDeclaration:()=>Sn,WindowFrameBound:()=>An,WindowFrameSpec:()=>wn,WindowSpec:()=>On});var sn=class extends w{static get syntaxRules(){return{syntaxes:[{dialect:"postgres",syntax:[{type:"keyword",value:"DISTINCT"},{type:"keyword",value:"ON"},{type:"paren_block",syntax:{type:"Expr",as:"pg_distinct_on_list",arity:{min:1},itemSeparator:{type:"punctuation",value:","},assert:!0}}]},{type:"keyword",as:"all_or_distinct",value:["ALL","DISTINCT"]}]}}allOrDistinct(){return this._get("all_or_distinct")}pgDistinctOnList(){return this._get("pg_distinct_on_list")}};var nn=class extends w{static get syntaxRules(){return[{type:"keyword",value:"FOR"},{optional:!0,dialect:"postgres",syntaxes:[[{type:"keyword",as:"pg_no_key_kw",value:"NO",booleanfy:!0},{type:"keyword",value:"KEY",if:"pg_no_key_kw",assert:!0}],{type:"keyword",as:"pg_key_kw",value:"KEY",booleanfy:!0}]},{type:"keyword",as:"intent_kw",value:["UPDATE","SHARE"],assert:!0},{optional:!0,syntax:[{type:"keyword",value:"OF"},{type:"TableRef2",as:"table_names",arity:{min:1},itemSeparator:{type:"punctuation",value:","},assert:!0}]},{optional:!0,syntaxes:[[{type:"keyword",as:"skip_locked_kw",value:"SKIP",booleanfy:!0},{type:"keyword",value:"LOCKED",assert:!0}],{type:"keyword",as:"nowait_kw",value:"NOWAIT",booleanfy:!0},{dialect:"mysql",syntax:[{type:"keyword",as:"my_lock_in_share_mode",value:"LOCK",booleanfy:!0},{type:"operator",value:"IN",assert:!0},{type:"keyword",value:"SHARE",assert:!0},{type:"keyword",value:"MODE",assert:!0}]}]}]}intentKW(){return this._get("intent_kw")}tableNames(){return this._get("table_names")}skipLockedKW(){return this._get("skip_locked_kw")}nowaitKW(){return this._get("nowait_kw")}pgKeyKW(){return this._get("pg_key_kw")}pgNoKeyKW(){return this._get("pg_no_key_kw")}myLockInShareMode(){return this._get("my_lock_in_share_mode")}};var an=class extends L{static get syntaxRules(){return[{type:"keyword",value:"FROM"},{type:"FromItem",as:"entries",arity:{min:1},itemSeparator:{type:"punctuation",value:","},assert:!0}]}};var on=class extends L{static get syntaxRules(){return[{type:"keyword",value:"GROUP"},{type:"keyword",value:"BY",assert:!0},{type:"keyword",as:"all_or_distinct",value:["ALL","DISTINCT"],optional:!0},{type:"GroupingElement",as:"entries",arity:{min:1},itemSeparator:{type:"punctuation",value:","},assert:!0,autoIndent:2},{optional:!0,autoIndent:!0,syntax:[{type:"keyword",as:"with_rollup",value:"WITH",booleanfy:!0},{type:"keyword",value:"ROLLUP",assert:!0}]}]}allOrDistinct(){return this._get("all_or_distinct")}withRollup(){return this._get("with_rollup")}};var ln=class extends w{static get syntaxRules(){return{syntaxes:[[{type:"keyword",value:"GROUPING SETS"},{type:"paren_block",syntax:{type:"GroupingElement",as:"grouping_sets",arity:{min:1},itemSeparator:{type:"punctuation",value:","},assert:!0,autoIndent:2},autoIndent:!0}],[{type:"keyword",value:"ROLLUP"},{type:"RowConstructor",as:"rollup_set",assert:!0}],[{type:"keyword",value:"CUBE"},{type:"RowConstructor",as:"cube_set",assert:!0}],{type:"Expr",as:"expr"}]}}groupingSets(){return this._get("grouping_sets")}rollupSet(){return this._get("rollup_set")}cubeSet(){return this._get("cube_set")}expr(){return this._get("expr")}};var un=class extends w{static get syntaxRules(){return[{type:"keyword",value:"HAVING"},{type:"Expr",as:"expr",assert:!0}]}static get syntaxPriority(){return-1}expr(){return this._get("expr")}};var bt=class extends X(w){static get syntaxRules(){let e={type:"punctuation",value:","};return{syntaxes:[[{type:"keyword",as:"lateral_kw",value:"LATERAL",booleanfy:!0,optional:!0},{type:"SRFExpr1",as:"expr"}],[{type:"keyword",as:"lateral_kw",value:"LATERAL",booleanfy:!0,optional:!0},{type:["SRFExpr2","SRFExpr4"],as:"expr"},{type:"FromItemAlias",as:"alias",optional:!0}],[{type:"keyword",as:"lateral_kw",value:"LATERAL",booleanfy:!0,optional:!0},{type:["DerivedQuery","ValuesTableLiteral"],as:"expr",dialect:"postgres"},{type:"DerivedQuery",as:"expr",dialect:"mysql"},{type:"FromItemAlias",as:"alias",optional:!0}],[{type:"keyword",as:"pg_only_kw",value:"ONLY",optional:!0,dialect:"postgres"},{type:["TableRef1","TableRef2"],as:"expr"},{type:"operator",as:"pg_star_ref",value:"*",booleanfy:!0,optional:!0,dialect:"postgres"},{type:"FromItemAlias",as:"alias",optional:!0},{...{optional:!0,dialect:"postgres",syntax:[{type:"keyword",value:"TABLESAMPLE"},{syntaxes:[[{type:"keyword",as:"pg_sampling_method",value:["BERNOULLI","SYSTEM"]},{type:"paren_block",syntax:{type:"Expr",as:"pg_sampling_arguments",arity:1,itemSeparator:e,assert:!0}}],[{type:"identifier",as:"pg_sampling_method"},{type:"paren_block",syntax:{type:"Expr",as:"pg_sampling_arguments",arity:1/0,itemSeparator:e,assert:!0}}]],assert:!0},{optional:!0,syntax:[{type:"keyword",value:"REPEATABLE"},{type:"paren_block",syntax:{type:"Expr",as:"pg_repeatable_seed"},assert:!0}]}]}}]]}}lateralKW(){return this._get("lateral_kw")}expr(){return this._get("expr")}alias(){return this._get("alias")}pgOnlyKW(){return this._get("pg_only_kw")}pgStarRef(){return this._get("pg_star_ref")}pgSamplingMethod(){return this._get("pg_sampling_method")}pgSamplingArguments(){return this._get("pg_sampling_arguments")}pgRepeatableSeed(){return this._get("pg_repeatable_seed")}deriveAlias(){let e;if(this.alias()?.value()?e={as_kw:!0,value:this.alias().value(),delim:this.alias()._get("delim")}:this.expr()instanceof y.TableRef1||this.expr()instanceof y.TableRef2?e={as_kw:!0,value:this.expr().value(),delim:this.expr()._get("delim")}:this.expr()instanceof y.SRFExpr1&&this.expr().qualif()instanceof y.SRFExprDDL2&&(e={as_kw:!0,value:this.expr().qualif().alias().value(),delim:this.expr().qualif().alias()._get("delim")}),e)return y.FromItemAlias.fromJSON(e)}jsonfy(e={},t=null,s=null){let r=super.jsonfy(e,t,s);if(e.deSugar){let n=r.alias||this.deriveAlias()?.jsonfy(),a=n?.value&&{nodeName:y.Identifier.NODE_NAME,value:n.value,delim:n.delim},o=r.expr.result_schema;if(o instanceof y.TableSchema?o=o.clone({renameTo:a}):a&&(o=y.TableSchema.fromJSON({name:a,entries:o?.entries().map(l=>l.jsonfy())||[]},{assert:!0})),r.alias?.columns?.length){if(r.alias.columns.length!==o.length)throw new SyntaxError(`[${this}] Number of column aliases must match number of result columns.`);o=o.clone({},new te((l,m,f)=>typeof f=="number"&&l.parentNode===o?l instanceof y.ColumnSchema?l.jsonfy({renameTo:r.alias.columns[f]}):{...l.jsonfy(),nodeName:y.ColumnSchema.NODE_NAME,name:r.alias.columns[f]}:m()))}t.statementContext.artifacts.get("tableSchemas").add({type:this.joinType?.()||"dql",lateral:this.lateralKW(),resultSchema:o});let u=!(this.expr()instanceof y.SRFExpr1)&&(e.deSugar===!0||Number(e.deSugar?.tableAliases)===1||e.deSugar?.tableAliases===-1&&(this.parentNode?.length||0)>1)&&n||r.alias;r={...r,alias:u,result_schema:o}}return r}};var cn=class extends bt{static get syntaxRules(){return{syntaxes:[[{type:"keyword",as:"join_type",value:"CROSS"},{type:"keyword",value:"JOIN",assert:!0},...[].concat(super.syntaxRules)],[{type:"keyword",as:"natural_kw",value:"NATURAL",booleanfy:!0,optional:!0},{optional:!0,syntaxes:[{type:"keyword",as:"join_type",value:"INNER"},[{type:"keyword",as:"join_type",value:["LEFT","RIGHT","FULL"],dialect:"postgres"},{type:"keyword",as:"join_type",value:["LEFT","RIGHT"],dialect:"mysql"},{type:"keyword",as:"outer_kw",value:"OUTER",booleanfy:!0,optional:!0}]]},{type:"keyword",value:"JOIN"},...[].concat(super.syntaxRules),{type:["OnClause","UsingClause"],as:"condition_clause",if:"!natural_kw",assert:!0,autoIndent:!0}]]}}naturalKW(){return this._get("natural_kw")}joinType(){return this._get("join_type")}outerKW(){return this._get("outer_kw")}conditionClause(){return this._get("condition_clause")}jsonfy(e={},t=null,s=null){let r;e.deSugar&&(t=new te((a,o,u)=>{if(u==="condition_clause")r=o;else return o()},t,this.statementNode));let n=super.jsonfy(e,t,s);return r&&(n={...n,condition_clause:r()}),n}};var fn=class extends w{static get syntaxRules(){return[{type:"keyword",value:"LIMIT"},{dialect:"mysql",syntax:[{optional:!0,syntax:[{type:"Expr",as:"my_offset"},{type:"punctuation",value:",",autoSpacing:!1}]},{type:"Expr",as:"expr",assert:!0}]},{dialect:"postgres",syntaxes:[{type:"keyword",as:"pg_all_kw",value:"ALL"},{type:"Expr",as:"expr",assert:!0}]}]}expr(){return this._get("expr")}pgAllKW(){return this._get("pg_all_kw")}myOffset(){return this._get("my_offset")}};var pn=class extends w{static get syntaxRules(){return[{type:"keyword",value:"OFFSET"},{type:"Expr",as:"expr",assert:!0},{type:"keyword",as:"pg_row_kw",value:["ROW","ROWS"],optional:!0,dialect:"postgres"}]}expr(){return this._get("expr")}pgRowKW(){return this._get("pg_row_kw")}};var mn=class extends w{static get syntaxRules(){return[{type:"keyword",value:"ON"},{type:"Expr",as:"expr",assert:!0}]}expr(){return this._get("expr")}};var yn=class extends L{static get syntaxRules(){return[{type:"keyword",value:"ORDER"},{type:"keyword",value:"BY",assert:!0},{type:"OrderElement",as:"entries",arity:{min:1},itemSeparator:{type:"punctuation",value:","},assert:!0,autoIndent:2},{optional:!0,autoIndent:!0,syntax:[{type:"keyword",as:"with_rollup",value:"WITH",booleanfy:!0},{type:"keyword",value:"ROLLUP",assert:!0}]}]}withRollup(){return this._get("with_rollup")}};var dn=class extends w{static get syntaxRules(){return[{type:"Expr",as:"expr"},{optional:!0,syntaxes:[{type:"keyword",value:["ASC","DESC"],as:"dir"},{type:"PGOrderOperator",as:"dir"}]},{optional:!0,syntax:[{type:"keyword",value:"NULLS"},{type:"keyword",as:"nulls_spec",value:["FIRST","LAST"],assert:!0}]}]}expr(){return this._get("expr")}dir(){return this._get("dir")}nullsSpec(){return this._get("nulls_spec")}};var hn=class extends L{static get syntaxRules(){return[{type:"keyword",value:"PARTITION"},{type:"keyword",value:"BY",assert:!0},{type:"Expr",as:"entries",arity:{min:1},itemSeparator:{type:"punctuation",value:","},assert:!0,autoIndent:2}]}};var _n=class extends w{static get syntaxRules(){return{dialect:"postgres",syntax:[{type:"keyword",value:"FETCH"},{type:"keyword",as:"rel_kw",value:["FIRST","NEXT"]},{type:"Expr",as:"expr",optional:!0},{type:"keyword",as:"row_kw",value:["ROW","ROWS"],assert:!0},{syntaxes:[{type:"keyword",value:"ONLY"},[{type:"keyword",as:"with_ties",value:"WITH"},{type:"keyword",value:"TIES",assert:!0}]]}]}}relKW(){return this._get("rel_kw")}expr(){return this._get("expr")}rowKW(){return this._get("row_kw")}withTies(){return this._get("with_ties")}};var gn=class extends w{static get syntaxRules(){return{dialect:"postgres",syntax:[{type:"keyword",value:"USING"},{type:"operator",as:".",assert:!0}]}}value(){return this._get("value")}};var En=class extends w{static get syntaxRules(){return[{type:"keyword",value:"USING"},{syntaxes:[{type:"Identifier",as:"column"},{type:"paren_block",syntax:{type:"Identifier",as:"columns",arity:{min:1},itemSeparator:{type:"punctuation",value:","},assert:!0}}],assert:!0}]}column(){return this._get("column")}columns(){return this._get("columns")}};var Nn=class extends w{static get syntaxRules(){return[{type:"keyword",value:"WHERE"},{type:"Expr",as:"expr",assert:!0}]}expr(){return this._get("expr")}};var xn=class extends L{static get syntaxRules(){return[{type:"keyword",value:"WINDOW"},{type:"WindowDeclaration",as:"entries",arity:{min:1},itemSeparator:{type:"punctuation",value:","},assert:!0,autoIndent:2}]}};var Sn=class extends w{static get syntaxRules(){return[{type:"Identifier",as:"name"},{type:"keyword",value:"AS"},{type:"WindowSpec",as:"spec",assert:!0}]}name(){return this._get("name")}spec(){return this._get("spec")}};var wn=class extends w{static get syntaxRules(){let e={type:"operator",value:"AND"};return[{type:"keyword",as:"specifier",value:["ROWS","RANGE","GROUPS"]},{syntaxes:[[{type:"operator",as:"with_between_clause",value:"BETWEEN",booleanfy:!0},{type:"WindowFrameBound",as:"bounds",arity:2,itemSeparator:e,assert:!0}],{type:"WindowFrameBound",as:"bounds",arity:1,itemSeparator:e,assert:!0}]},{optional:!0,syntax:[{type:"keyword",value:"EXCLUDE"},{type:"keyword",as:"exclusion",value:["CURRENT ROW","GROUP","TIES","NO OTHERS"],assert:!0}]}]}specifier(){return this._get("specifier")}withBetweenClause(){return this._get("with_between_clause")}bounds(){return this._get("bounds")}exclusion(){return this._get("exclusion")}};var An=class extends w{static get syntaxRules(){return{syntaxes:[{type:"keyword",as:"specifier",value:"CURRENT ROW"},[{type:"keyword",as:"specifier",value:"UNBOUNDED"},{type:"keyword",as:"dir",value:["PRECEDING","FOLLOWING"]}],[{type:"number_literal",as:"specifier"},{type:"keyword",as:"dir",value:["PRECEDING","FOLLOWING"]}],[{type:"Expr",as:"specifier"},{type:"keyword",as:"dir",value:["PRECEDING","FOLLOWING"]}]]}}specifier(){return this._get("specifier")}dir(){return this._get("dir")}};var On=class extends w{static get syntaxRules(){return{type:"paren_block",syntax:[{type:"WindowRef",as:"super_window",optional:!0},{type:"PartitionByClause",as:"partition_by_clause",optional:!0,autoIndent:!0},{type:"OrderByClause",as:"order_by_clause",optional:!0,autoIndent:!0},{type:"WindowFrameSpec",as:"frame_spec",optional:!0,autoIndent:!0}],autoIndent:!0,autoIndentAdjust:-1}}superWindow(){return this._get("super_window")}partitionByClause(){return this._get("partition_by_clause")}orderByClause(){return this._get("order_by_clause")}frameSpec(){return this._get("frame_spec")}};var vn=class extends ue{static get syntaxRules(){let e={type:"punctuation",value:","};return[{syntaxes:[{...[].concat(super.syntaxRules)[0]},[{type:"keyword",as:"as_kw",value:"AS",booleanfy:!0},{...[].concat(super.syntaxRules)[0],assert:!0}]]},{type:"paren_block",syntax:{type:"Identifier",as:"columns",arity:{min:1},itemSeparator:e,assert:!0},if:"value",optional:!0,optionalParens:!0}]}asKW(){return this._get("as_kw")}columns(){return this._get("columns")}jsonfy(e={},t=null,s=null){let r=super.jsonfy(e,t,s);return(e.deSugar===!0||e.deSugar?.normalizeCasing)&&!r.delim&&(r={...r,value:r.value.toLowerCase()}),r}};var bn=class c extends X(w){static get syntaxRules(){return[{type:["Expr","ColumnRef0","MYVarAssignmentExpr"],as:"expr"},{type:"SelectItemAlias",as:"alias",optional:!0}]}expr(){return this._get("expr")}alias(){return this._get("alias")}deriveAlias(){let e=this.alias()?.jsonfy(),t=this.expr();if(!(t instanceof y.ColumnRef0)){if(t instanceof y.RowConstructor&&(t=t.exprUnwrapped()),(t instanceof y.CastExpr||t instanceof y.PGCastExpr2)&&(t=t.expr()),!e)if(t instanceof y.ColumnRef1)e={as_kw:!0,value:t.value(),delim:t._get("delim")};else if(t instanceof y.LQDeepRef1&&t.endpoint()instanceof y.ColumnRef2){let s=t.endpoint();e={as_kw:!0,value:s.value(),delim:s._get("delim")}}else{let s=this.options.dialect==="postgres";t instanceof y.CallExpr&&s&&(e={as_kw:!0,value:t.name().toLowerCase()})}return y.SelectItemAlias.fromJSON(e)}}jsonfy(e={},t=null,s=null){if(e.deSugar){let r=this.deriveAlias(),n,a=r&&(t?t.transform(r,(d=e)=>r.jsonfy(d),"alias",e):r.jsonfy(e));a?.is_aggr&&({is_aggr:n,...a}=a);let o=this.expr(),u;n&&!(o instanceof y.LQDeepRef1)?u=(d=e,h=t)=>({nodeName:y.AggrCallExpr.NODE_NAME,name:(e.toDialect||this.options.dialect)==="mysql"?"JSON_ARRAYAGG":"JSON_AGG",arguments:[o.jsonfy(d,h,s)]}):u=(d=e,h=t)=>o.jsonfy(d,h,s);let l=t?t.transform(o,u,"expr",{...e,asAggr:n}):u(),m=a&&{nodeName:y.Identifier.NODE_NAME,value:a.value,delim:a.delim}||{nodeName:y.Identifier.NODE_NAME,value:this.options.dialect==="postgres"?"?column?":o.stringify()},f=l.result_schema;if(f instanceof y.ColumnSchema){let d=f.parentNode;f=f.clone({renameTo:m}),d?._adoptNodes(f)}else!(o instanceof y.LQDeepRef1)&&!(o instanceof y.ColumnRef0)&&(f=y.ColumnSchema.fromJSON({name:m,data_type:this.expr().dataType().jsonfy()}),o._adoptNodes(f));let p=(n||e.deSugar===!0||Number(e.deSugar?.selectAliases)===1||e.deSugar?.selectAliases===-1&&(this.parentNode?.entries().length||0)>1)&&a||this.alias()?.jsonfy();return{nodeName:c.NODE_NAME,expr:l,alias:p,result_schema:f}}return super.jsonfy(e,t,s)}};var Tn=class extends ue{static get syntaxRules(){return[{syntaxes:[{...[].concat(super.syntaxRules)[0]},[{type:"keyword",as:"as_kw",value:"AS",booleanfy:!0},{...[].concat(super.syntaxRules)[0],assert:!0}]]},{type:"AggrNotation",as:"is_aggr",autoSpacing:!1,optional:!0}]}asKW(){return this._get("as_kw")}isAggr(){return this._get("is_aggr")}jsonfy(e={},t=null,s=null){let r=super.jsonfy(e,t,s);return(e.deSugar===!0||e.deSugar?.normalizeCasing)&&!r.delim&&(r={...r,value:r.value.toLowerCase()}),r}};var Rn=class extends X(w){static get syntaxRules(){return[{type:"CallExpr",as:"call_expr"},{type:["SRFExprDDL1","SRFExprDDL2"],as:"qualif"}]}callExpr(){return this._get("call_expr")}qualif(){return this._get("qualif")}jsonfy(e={},t=null,s=null){let r=super.jsonfy(e,t,s);if(e.deSugar){let n=r.qualif?.column_defs||[],a=r.qualif?.alias?y.TableSchema.fromJSON({name:r.qualif.alias,entries:n}):y.JSONSchema.fromJSON({entries:n});r={...r,result_schema:a}}return r}};var Cn=class extends X(w){static get syntaxRules(){return[{type:"CallExpr",as:"call_expr"},{optional:!0,syntax:[{type:"keyword",as:"with_ordinality",value:"WITH",booleanfy:!0},{type:"keyword",value:"ORDINALITY",assert:!0}]}]}callExpr(){return this._get("call_expr")}withOrdinality(){return this._get("with_ordinality")}jsonfy(e={},t=null,s=null){let r=super.jsonfy(e,t,s);if(e.deSugar){let n,a;r.with_ordinality&&(a=y.ColumnSchema.fromJSON({name:{nodeName:y.Identifier.NODE_NAME,value:"ordinality"},data_type:{nodeName:y.DataType.NODE_NAME,value:"INT"}}));let o={nodeName:y.Identifier.NODE_NAME,value:r.call_expr.name};if(r.call_expr?.result_schema)if(n=r.call_expr.result_schema,n instanceof y.TableSchema||n instanceof y.JSONSchema)if(a){let u=n.jsonfy();n=n.constructor.fromJSON({name:o,...u,entries:[...u.entries,a]})}else n=n.clone();else n=y.JSONSchema.fromJSON({entries:[n.jsonfy()].concat(a||[])});else n=y.JSONSchema.fromJSON({entries:[{nodeName:y.ColumnSchema.NODE_NAME,name:o,data_type:this.callExpr().dataType().jsonfy()}].concat(a||[])});r={...r,result_schema:n}}return r}};var In=class extends X(w){static get syntaxRules(){return[{type:"CallExpr",as:"call_expr"},{type:"SRFExprDDL1",as:"qualif",optional:!0}]}callExpr(){return this._get("call_expr")}qualif(){return this._get("qualif")}jsonfy(e={},t=null,s=null){let r=super.jsonfy(e,t,s);if(e.deSugar){let n;if(r.qualif?.column_defs.length)n=y.JSONSchema.fromJSON({entries:r.qualif.column_defs});else if(r.call_expr?.result_schema){let a=r.call_expr.result_schema;n=a instanceof y.TableSchema||a instanceof y.JSONSchema?a.clone():y.JSONSchema.fromJSON({entries:[a.jsonfy()]})}else{let a={nodeName:y.Identifier.NODE_NAME,value:r.call_expr.name};n=y.JSONSchema.fromJSON({entries:[{nodeName:y.ColumnSchema.NODE_NAME,name:a,data_type:this.callExpr().dataType().jsonfy()}]})}r={...r,result_schema:n}}return r}};var kn=class extends X(L){static get syntaxRules(){return[{type:"keyword",value:"ROWS"},{type:"keyword",value:"FROM"},{type:"paren_block",syntax:{type:"SRFExpr3",as:"entries",arity:{min:1},itemSeparator:{type:"punctuation",value:","},assert:!0,autoIndent:2},autoIndent:!0},{optional:!0,syntax:[{type:"keyword",as:"with_ordinality",value:"WITH",booleanfy:!0},{type:"keyword",value:"ORDINALITY",assert:!0}]}]}static get syntaxPriority(){return-1}withOrdinality(){return this._get("with_ordinality")}jsonfy(e={},t=null,s=null){let r=super.jsonfy(e,t,s);if(e.deSugar){let n=1,a=r.entries.reduce((u,l)=>{let m=l.result_schema.jsonfy().entries.map(f=>({...f,name:{...f.name,value:n++}}));return u.concat(m)},[]);r.with_ordinality&&a.push({name:{nodeName:y.Identifier.NODE_NAME,value:n},data_type:{nodeName:y.DataType.NODE_NAME,value:"INT"}});let o=y.JSONSchema.fromJSON({entries:a});r={...r,result_schema:o}}return r}};var Dn=class extends w{static get syntaxRules(){return[{type:"keyword",as:"as_kw",value:"AS"},{type:"paren_block",syntax:{type:"ColumnSchema",as:"column_defs",arity:{min:1},itemSeparator:{type:"punctuation",value:","}}}]}asKW(){return this._get("as_kw")}columnDefs(){return this._get("column_defs")}};var Mn=class extends w{static get syntaxRules(){return[{syntaxes:[{type:"Identifier",as:"alias",peek:[1,"paren_block"]},[{type:"keyword",as:"as_kw",value:"AS",peek:[2,"paren_block"]},{type:"Identifier",as:"alias",assert:!0}]]},{type:"paren_block",syntax:{type:"ColumnSchema",as:"column_defs",arity:{min:1},itemSeparator:{type:"punctuation",value:","}}}]}asKW(){return this._get("as_kw")}alias(){return this._get("alias")}columnDefs(){return this._get("column_defs")}};var Ln=class extends Ot{static get syntaxRules(){return{type:"paren_block",syntax:super.syntaxRules,autoIndent:!0}}};var et=class extends Se{static get syntaxRules(){return{type:["CompleteSelectStmt","CompositeSelectStmt"],expression:2}}static buildSyntaxRules(e=null){let t=(r=[])=>[{type:"keyword",value:"SELECT"},{type:"DistinctClause",as:"distinct_clause",optional:!0},{type:"SelectList",as:"select_list"},{optional:!0,syntax:[{type:"FromClause",as:"from_clause",autoSpacing:`
`},{type:"JoinClause",as:"join_clauses",arity:1/0,optional:!0,autoSpacing:`
`},{type:"MYPartitionClause",as:"my_partition_clause",optional:!0,autoSpacing:`
`},{type:"WhereClause",as:"where_clause",optional:!0,autoSpacing:`
`},{optional:!0,syntax:[{type:"GroupByClause",as:"group_by_clause",autoSpacing:`
`},{type:"HavingClause",as:"having_clause",optional:!0,autoSpacing:`
`}]},{type:"WindowClause",as:"window_clause",optional:!0,autoSpacing:`
`},...r],autoSpacing:`
`}],s=()=>[{type:"OrderByClause",as:"order_by_clause",optional:!0,autoSpacing:`
`},{type:"LimitClause",as:"limit_clause",optional:!0,autoSpacing:`
`},{type:"OffsetClause",as:"offset_clause",optional:!0,autoSpacing:`
`},{type:"PGFetchClause",as:"pg_fetch_clause",optional:!0,dialect:"postgres",autoSpacing:`
`},{type:"ForClause",as:"for_clause",optional:!0,autoSpacing:`
`}];return e===1?t():e===2?s():t(s())}dataType(){return y.DataType.fromJSON({value:"SET"})}};var Tt=class extends vt(et){static get syntaxRules(){return this.buildSyntaxRules(1)}static get syntaxPriority(){return-1}distinctClause(){return this._get("distinct_clause")}selectList(){return this._get("select_list")}fromClause(){return this._get("from_clause")}joinClauses(){return this._get("join_clauses")}whereClause(){return this._get("where_clause")}groupByClause(){return this._get("group_by_clause")}havingClause(){return this._get("having_clause")}windowClause(){return this._get("window_clause")}myPartitionClause(){return this._get("my_partition_clause")}get length(){return this.selectList()?.length??0}[Symbol.iterator](){return(this.selectList()||[])[Symbol.iterator]()}jsonfy(e={},t=null,s=null){if(!e.deSugar)return super.jsonfy(e,t,s);let r={select_list:null,group_by_clause:new Set,having_clause:new Set,order_by_clause:new Set};t=new te((l,m,f)=>{if(l instanceof y.SelectList){r.select_list=m;return}return l instanceof y.GroupByClause||l instanceof y.HavingClause||l instanceof y.OrderByClause&&l.parentNode===this?m((p,d,h)=>{if((typeof h=="number"||h==="expr")&&p.parentNode===l){try{r[f].add(d())}catch(_){if(_ instanceof Ue)r[f].add(d);else throw _}return}return d()}):m()},t,this);let n=super.jsonfy(e,t,s),a=r.select_list(),{select_list:o,...u}=this.finalizeSelectorJSON(n,t,s,e);a=this.selectList().finalizeJSON(a,t,s,e),n={select_list:a,...u,result_schema:a.result_schema,origin_schemas:this.getOriginSchemas(t)};for(let[l,m]of Object.entries(r)){if(l==="select_list"||!m.size)continue;let f=[];for(let p of m)typeof p=="function"&&(p=p()),f.push(p);l==="having_clause"?n={...n,[l]:{expr:f[0]}}:(l==="group_by_clause"||l==="order_by_clause")&&(n={...n,[l]:{entries:f}})}return n}};var Pn=class extends Tt{static get syntaxRules(){return this.buildSyntaxRules()}static get syntaxPriority(){return 99}orderByClause(){return this._get("order_by_clause")}offsetClause(){return this._get("offset_clause")}limitClause(){return this._get("limit_clause")}forClause(){return this._get("for_clause")}pgFetchClause(){return this._get("pg_fetch_clause")}};var jn=class extends et{static get syntaxRules(){let e=["DerivedQuery","ValuesTableLiteral","ValuesConstructor","TableStmt","BasicSelectStmt"];return[{type:[...e,"CompositeSelectStmt"],as:"left"},{type:"operator",as:"operator",value:["INTERSECT","UNION","EXCEPT"],autoSpacing:`
`},{type:"keyword",as:"all_or_distinct",value:["ALL","DISTINCT"],optional:!0},{type:e,as:"right",assert:!0,autoSpacing:`
`},...this.buildSyntaxRules(2)]}static get syntaxPriority(){return-1}left(){return this._get("left")}operator(){return this._get("operator")}allOrDistinct(){return this._get("all_or_distinct")}right(){return this._get("right")}orderByClause(){return this._get("order_by_clause")}offsetClause(){return this._get("offset_clause")}limitClause(){return this._get("limit_clause")}forClause(){return this._get("for_clause")}pgFetchClause(){return this._get("pg_fetch_clause")}get length(){return this.left()?.length??0}[Symbol.iterator](){return(this.left()||[])[Symbol.iterator]()}jsonfy(e={},t=null,s=null){if(!e.deSugar)return super.jsonfy(e,t,s);let r={order_by_clause:null};t=new te((u,l)=>{if(u instanceof y.OrderByClause){r.order_by_clause=l;return}return l()},t,this);let n=super.jsonfy(e,t,s),a=n.left.result_schema;t.statementContext.artifacts.set("outputSchemas",new Set(a?.entries()||[]));let o=r.order_by_clause?.();return n={...n,order_by_clause:o,result_schema:a},n}static async _parseFromRules(e,t,{left:s=void 0,minPrecedence:r=0,trail:n,...a},o={}){let u=n.slice(-3);if(!(u[0]===this.NODE_NAME&&u[2]===this.NODE_NAME)){if((await e.match("operator"))?.isSetOp&&s instanceof y.CompleteSelectStmt){if(s.orderByClause()||s.offsetClause()||s.limitClause()||s.forClause()){let l=e.current(),m=`[${this.NODE_NAME}] Unexpected ${l.type} token:${typeof l.value=="string"?` "${l.value}"`:""} at <line ${l.line}, column ${l.column}>`;throw new SyntaxError(m)}s=y.BasicSelectStmt.fromJSON({...s.jsonfy(),nodeName:void 0})}return await super._parseFromRules(e,t,{left:s,minPrecedence:r,trail:n,...a},o)}}};var Un=class extends Se{static get syntaxRules(){return[{type:"keyword",value:"TABLE"},{type:"keyword",as:"pg_only_kw",value:"ONLY",optional:!0,dialect:"postgres"},{type:"TableRef2",as:"table_ref",assert:!0},{type:"operator",as:"pg_star_ref",value:"*",booleanfy:!0,optional:!0,dialect:"postgres"}]}tableRef(){return this._get("table_ref")}pgOnlyKW(){return this._get("pg_only_kw")}pgStarRef(){return this._get("pg_star_ref")}jsonfy(e={},t=null,s=null){let r=super.jsonfy({...e,forceDeSugar:e.deSugar},t,s);if(e.deSugar){let n=r.table_ref.result_schema;r={...r,result_schema:y.JSONSchema.fromJSON({entries:n.jsonfy().entries}),origin_schemas:[n]}}return r}};var _a={};Ie(_a,{AggrNotation:()=>Bn,LQVersionSpec:()=>$n});var Bn=class extends w{static get syntaxRules(){return{type:"bracket_block",syntax:{type:"Expr",as:"_",arity:0,assert:!0}}}static get syntaxPriority(){return-1}};var $n=class extends w{static get syntaxRules(){return{type:"version_spec",as:"."}}static get syntaxPriority(){return-1}value(){return this._get("value")}};var ga={};Ie(ga,{DataType:()=>Jn});var Jn=class extends w{static get syntaxRules(){return[{syntaxes:[{type:"data_type",as:"."},{type:"keyword",as:".",value:["SET"]}]},{type:"paren_block",syntax:{type:"Expr",as:"specificity",arity:1/0,itemSeparator:{type:"punctuation",value:","},assert:!0},optional:!0,optionalParens:!0,autoSpacing:!1},{type:"AggrNotation",as:"pg_is_aggr",autoSpacing:!1,optional:!0,dialect:"postgres"}]}value(){return this._get("value")}specificity(){return this._get("specificity")}pgIsAggr(){return this._get("pg_is_aggr")}};var Fn=class extends L{static get syntaxRules(){return{type:["JSONSchema","TableSchema","ColumnSchema","ColumnRef1"],as:"entries",arity:1/0}}};var Gn=class extends L{static get _contentTypes(){return["SelectStmt","TableStmt","InsertStmt","UpsertStmt","UpdateStmt","DeleteStmt","MYSetStmt","CTE","CreateSchemaStmt","DropSchemaStmt","CreateTableStmt","DropTableStmt"]}static get syntaxRules(){let e={type:"punctuation",value:";"};return{type:this._contentTypes,as:"entries",arity:1/0,itemSeparator:e,autoSpacing:`
`}}static async parse(e,t={}){let s=await this.toStream(e,t),r=await super.parse(s,t);if(!s.done&&s.current()){let n=s.current(),a=`[${this.NODE_NAME}] Unexpected ${n.type} token:${typeof n.value=="string"?` "${n.value}"`:""} at <line ${n.line}, column ${n.column}>`;throw new SyntaxError(a)}return r}stringify(e={}){return`${super.stringify(e)};`}};Object.assign(y,{...ma,...ya,...da,...ha,...Ae,..._a,...ga,Script:Gn,JSONSchema:Fn});var Ne=class{#e=new Map;#t=new Set;on(e,t){return this.#e.has(e)||this.#e.set(e,new Set),this.#e.get(e).add(t),()=>{if(this.#e.get(e).delete(t),!this.#e.get(e).size&&(this.#e.delete(e),!this.#e.size)){for(let s of this.#t)s();this.#t.clear()}}}onClose(e){this.#t.add(e)}emit(e,t){let s=this.#e.get(e);if(s)for(let r of s){r(t);try{}catch(n){console.error("emitter handler error",n)}}}};var qn=class{#e=["public"];get searchPath(){return this.#e}#t;#r=new Map;#n;get catalog(){return this.#n}#i;get options(){return this.#i}constructor({driver:e,catalog:t=[]}={},s={}){this.#t=e,this.#n=new Set(t),this.#i=s}async provide(e){let t=[...this.#r.entries()],s={},r=!1,n=[],a=[],o=(h,_)=>_.includes(h)?!0:/^!|^%|%$|^\*$/.test(h)?!1:Bt(h,_),u=(h,_,g)=>_[0]===h?-1:g[0]===h||_[0]==="*"?1:g[0]==="*"?-1:0,l=(h,_)=>{s[h]=_;let g=[].concat(this.#r.get(h)?.tables||[]).concat(_),E={namespace:h,tables:g,fulfilment:null};this.#r.set(h,E),a.push(E)},m=(h,_)=>{if(!t.length)return l(h,_);let g=t.sort((E,N)=>u(h,E,N));for(let[E,N]of g)if(o(h,[E])){let x=_.filter(S=>!o(S,N.tables));x.length<_.length&&(r=!0,N.fulfilment&&n.push(N.fulfilment)),x.length&&l(h,x)}else l(h,_)};e=st(e);for(let[h,_]of Object.entries(e))m(h,_);let f,p=Promise.resolve(0);if(Object.keys(s).length){f=this.#t?.showCreate(s,!0),n.push(f);for(let h of a)h.fulfilment=f;f.finally(()=>{for(let h of a)h.fulfilment=null}),p=Promise.all(n).then(()=>r?2:1)}else n.length&&(p=Promise.all(n).then(()=>-1));let d=await f;if(d?.length)for(let h of d){let _=wt.fromJSON(h,{dialect:this.#t.dialect});for(let g of this.#n)if(g.name().identifiesAs(_.name())){for(let E of g.tables())_.has(E.name())||_.add(E.clone());this.#n.delete(g)}this.#n.add(_)}return await p}};var Rt=class extends Ne{#e=new Map;#t;#r;#n;get schemaInference(){return this.#t}constructor({capability:e={}}={}){super(),this.#r=e,this.#n=e,this.#t=new qn({driver:this})}async connect(){await this._connect()}async disconnect(){await this.setCapability({realtime:!1}),await this._disconnect()}async parse(e,{alias:t=null,dynamicWhereMode:s=!1,...r}={}){throw new Error("parse() is unimplemented")}async resolve(e,t={}){throw new Error("resolve() is unimplemented")}async query(...e){throw new Error("resolve() is unimplemented")}async cursor(...e){throw new Error("resolve() is unimplemented")}async showCreate(e,t=!1){throw new Error("resolve() is unimplemented")}async subscribe(e,t){await this.setCapability({realtime:!0}),typeof e=="function"&&(t=e,e="*");let s=st(e,!0);return this.#e.set(t,s),async()=>{this.#e.delete(t),this.#e.size||await this.setCapability({realtime:!1})}}async setCapability(e){let t=Object.fromEntries(Object.entries(e).filter(([s,r])=>!r||this.#r[s]!==!1));t.realtime===!1?await this._teardownRealtime():t.realtime&&await this._setupRealtime(),this.#n={...this.#n,...t}}_fanout(e){let t=[],s=new Set;for(let r of e){let n=[JSON.stringify([r.relation.namespace,r.relation.name]),JSON.stringify(["*",r.relation.name]),JSON.stringify([r.relation.namespace,"*"])];t.push({event:r,patterns:n}),s.add(n[0]),s.add(n[1]),s.add(n[2])}for(let[r,n]of this.#e.entries()){let a=[];for(let o of n)if(o==='["*","*"]'){a=[...e];break}else if(s.has(o)){for(let{event:u,patterns:l}of t)l.includes(o)&&a.push(u);break}a.length&&r(a)}}};var Da={};Ie(Da,{any:()=>Ui,apply:()=>ba,batch:()=>ka,construct:()=>va,defineProperties:()=>Fi,defineProperty:()=>Kt,deleteProperties:()=>Gi,deleteProperty:()=>Yt,get:()=>Fe,getOwnPropertyDescriptor:()=>Hn,getOwnPropertyDescriptors:()=>$i,getPrototypeOf:()=>wa,has:()=>Kn,intercept:()=>Bi,isExtensible:()=>Aa,map:()=>Ji,observe:()=>Ia,ownKeys:()=>Oa,path:()=>Pi,preventExtensions:()=>Ra,reduce:()=>Ca,set:()=>lt,setPrototypeOf:()=>Ta,subtree:()=>ji});function tt(c,e=!0){return be(c)?c:!e&&ne(c)?[c]:c!==!1&&c!==0&&oa(c)?[]:la(c)?Array.prototype.slice.call(c):ne(c)?Object.values(c):[c]}var le=(c,...e)=>er(c,"observerAPI",...e),Ct=(c,e)=>c instanceof Promise?c.then(e):e(c),Wn={};var it=class{constructor(e,t){this.registry=e,Object.assign(this,{...t,target:e.target}),this.params.signal&&this.params.signal.addEventListener("abort",()=>this.remove())}remove(){return this.removed=!0,this.registry.removeRegistration(this)}};var qt=class extends it{constructor(){super(...arguments),this.emit.currentRegistration=this,Object.defineProperty(this,"abortController",{value:new AbortController}),Object.defineProperty(this,"signal",{value:this.abortController.signal}),Wn.setMaxListeners?.(0,this.signal)}remove(){this.abortController.abort(),super.remove()}fire(e){if(this.emit.recursionTarget&&!["inject","force-async","force-sync"].includes(this.params.recursions))return;let t=e,s=this.filter;if(s!==1/0&&(s=tt(s,!1))&&(t=e.filter(n=>s.includes(n.key))),this.params.diff&&(t=t.filter(n=>n.type!=="set"||n.value!==n.oldValue)),!t.length)return;if(["inject","defer"].includes(this.params.recursions)){if(this.emit.recursionTarget){this.emit.recursionTarget.push(...t);return}this.emit.recursionTarget=this.params.recursions==="inject"?t:[]}let r=this.filter===1/0||Array.isArray(this.filter)?this.emit(t,this):this.emit(t[0],this);return Ct(r,n=>{let a=this.emit.recursionTarget;return delete this.emit.recursionTarget,this.params.recursions==="defer"&&a?.length?this.emit.currentRegistration.fire(a):n})}};var ot=class{constructor(e){this.target=e,this.entries=[]}addRegistration(e){return this.entries.push(e),e}removeRegistration(e){this.entries=this.entries.filter(t=>t!==e)}static _getInstance(e,t,s=!0,r=this.__namespace){if(!_e(t))throw new Error(`Subject must be of type object; "${pt(t)}" given!`);let n=this;return r&&le(globalThis,"observerAPI","namespaces").has(e+"-"+r)&&(n=le(globalThis,"observerAPI","namespaces").get(e+"-"+r),e+="-"+r),!le(t,"registry").has(e)&&s&&le(t,"registry").set(e,new n(t)),le(t,"registry").get(e)}static _namespace(e,t,s=null){if(e+="-"+t,arguments.length===2)return le(globalThis,"observerAPI","namespaces").get(e);if(!(s.prototype instanceof this))throw new Error(`The implementation of the namespace ${this.name}.${t} must be a subclass of ${this.name}.`);le(globalThis,"observerAPI","namespaces").set(e,s),s.__namespace=t}};var he=class{constructor(e,t){if(this.target=e,!t.operation)throw new Error("Descriptor operation must be given in definition!");Object.assign(this,t)}};var $e=class extends ot{static getInstance(e,t=!0,s=null){return super._getInstance("listeners",...arguments)}static namespace(e,t=null){return super._namespace("listeners",...arguments)}constructor(e){super(e),this.batches=[]}addRegistration(e,t,s){return super.addRegistration(new qt(this,{filter:e,emit:t,params:s}))}emit(e,{eventsArePropertyDescriptors:t=!1,eventIsArrayMethodDescriptor:s=!1}={}){if(this.batches.length){let r=this.batches[0].params.arrayMethodName;this.batches[0].snapshots.push({events:[...e],arrayMethodName:r,eventsArePropertyDescriptors:t,eventIsArrayMethodDescriptor:s});return}this.$emit(this.entries,[{events:e,eventsArePropertyDescriptors:t,eventIsArrayMethodDescriptor:s}])}$emit(e,t){let s=0,r=0,n=0;for(let m of e)s+=1,m.params.withPropertyDescriptors&&(r+=1),m.params.withArrayMethodDescriptors&&(n+=1);let a=[],o=[],u=[],l=[];for(let m of t){let f=m.arrayMethodName,p=m.eventsArePropertyDescriptors,d=m.eventIsArrayMethodDescriptor;for(let h of m.events)if(f&&(h.operation=f),r&&(n&&a.push(h),d||n!==s&&o.push(h)),r!==s){let _=h;if(p){let{target:g,type:E,...N}=h;_=new he(g,{type:"set",...N}),Object.defineProperty(_,"value","get"in N.value?{get:()=>N.value.get()}:{value:N.value.value}),N.oldValue&&Object.defineProperty(_,"oldValue","get"in N.oldValue?{get:()=>N.oldValue.get()}:{value:N.oldValue.value})}n&&u.push(_),d||n!==s&&l.push(_)}}for(let m of e)m.params.withPropertyDescriptors?m.params.withArrayMethodDescriptors?a.length&&m.fire(a):o.length&&m.fire(o):m.params.withArrayMethodDescriptors?u.length&&m.fire(u):l.length&&m.fire(l)}batch(e,t={}){this.batches.unshift({entries:[...this.entries],snapshots:[],params:t});let s=e();return Ct(s,r=>{let n=this.batches.shift();return n.snapshots.length&&this.$emit(n.entries,n.snapshots),r})}};var Wt=class extends it{exec(e,t,s){return this.running||!this.traps[e.operation]?t(...Array.prototype.slice.call(arguments,2)):(this.running=!0,this.traps[e.operation](e,s,(...r)=>(this.running=!1,t(...r))))}};var Je=class extends ot{static getInstance(e,t=!0,s=null){return super._getInstance("traps",...arguments)}static namespace(e,t=null){return super._namespace("traps",...arguments)}addRegistration(e){return super.addRegistration(new Wt(this,e))}emit(e,t=null){let s=this;return function r(n,...a){let o=s.entries[n];return o?o.exec(e,(...u)=>r(n+1,...u),...a):t?t(e,...a):a[0]}(0)}};var Sa={};Ie(Sa,{accessorize:()=>Mi,proxy:()=>Na,unaccessorize:()=>Li,unproxy:()=>Ht});var Xa=Symbol("wqOriginal");function Mi(c,e,t={}){c=xa(c);let s=le(c,"accessorizedProps");function r(u){let l,m=c;do l=Object.getOwnPropertyDescriptor(m,u);while(!l&&(m=Object.getPrototypeOf(m)));return l?{proto:m,descriptor:l}:{descriptor:{value:void 0,configurable:!0,enumerable:!0,writable:!0}}}function n(u){if(s.has(u+""))return!0;let l=r(u);l.getValue=function(p=!1){return p?this.descriptor:this.descriptor.get?this.descriptor.get():this.descriptor.value},l.setValue=function(p,d=!1){if(this.dirty=!0,d){this.descriptor=p;return}return this.descriptor.set?this.descriptor.set(p)!==!1:(this.descriptor.value=p,!0)},l.intact=function(){let p=Object.getOwnPropertyDescriptor(c,u);return p?.get===f.get&&p?.set===f.set&&s.get(u+"")===this},l.restore=function(){return this.intact()?(this.proto&&this.proto!==c||!this.proto&&!this.dirty?delete c[u]:Object.defineProperty(c,u,this.descriptor),s.delete(u+""),!0):!1},s.set(isNaN(u)?u:parseInt(u),l);let{enumerable:m=!0}=l.descriptor,f={enumerable:m,configurable:!0};("value"in l.descriptor||l.descriptor.set)&&(f.set=function(p){return lt(this,u,p,t)}),("value"in l.descriptor||l.descriptor.get)&&(f.get=function(){return Fe(this,u,t)});try{return Object.defineProperty(c,u,f),!0}catch{return s.delete(u+""),!1}}let o=(Array.isArray(e)?e:e===void 0?Object.keys(c):[e]).map(n);return e===void 0||Array.isArray(e)?o:o[0]}function Li(c,e,t={}){c=xa(c);let s=le(c,"accessorizedProps");function r(o){return s.has(o+"")?s.get(o+"").restore():!0}let a=(Array.isArray(e)?e:e===void 0?Object.keys(c):[e]).map(r);return e===void 0||Array.isArray(e)?a:a[0]}function Na(c,e={},t=void 0){let s=xa(c);if(typeof e.membrane=="boolean")throw new Error("The params.membrane parameter cannot be of type boolean.");if(e.membrane&&le(s,"membraneRef").has(e.membrane))return le(s,"membraneRef").get(e.membrane);let r={apply:(o,u,l)=>ba(o,u,l,void 0,e),construct:(o,u,l=null)=>va(o,u,l,e),defineProperty:(o,u,l)=>Kt(o,u,l,e),deleteProperty:(o,u)=>Yt(o,u,e),get:(o,u,l=null)=>{if(u===Xa)return s;let m={...e,receiver:l},f=Fe(o,u,m);return Array.isArray(o)&&typeof f=="function"&&!/^class\s?/.test(Function.prototype.toString.call(f))?Na(f,{...e,arrayMethodName:u,membrane:l},t):e.chainable&&_e(f)&&u!=="prototype"&&!(typeof f=="function"&&/^class\s?|\{\s\[native\scode\]\s\}$/.test(Function.prototype.toString.call(f)))?Na(f,e,t):f},getOwnPropertyDescriptor:(o,u)=>Hn(o,u,e),getPrototypeOf:o=>wa(o,e),has:(o,u)=>Kn(o,u,e),isExtensible:o=>Aa(o,e),ownKeys:o=>Oa(o,e),preventExtensions:o=>Ra(o,e),set:(o,u,l,m=null)=>lt(o,u,l,{...e,receiver:m}),setPrototypeOf:(o,u)=>Ta(o,u,e)},n=t?.(r)||r,a=new Proxy(s,n);return e.membrane&&le(s,"membraneRef").set(e.membrane,a),a}function Ht(c){return c&&c[Xa]||c}function xa(c){if(!c||!_e(c))throw new Error("Target must be of type object!");return Ht(c)}var zt=class extends Array{};function Pi(...c){return new zt(...c)}var ut=class extends Array{};function ji(){return new ut}function Ui(){return 1/0}function Ca(c,e,t,s=n=>n,r={}){let n=e instanceof ut;if(!(!n&&!e?.length))return function a(o,u,l,m){let f=m||u[l.level]instanceof ut,p=f?1/0:u[l.level],d=f?!1:l.level===u.length-1;return o instanceof he&&o.operation!=="get"?l={...l,probe:"always"}:l.probe!=="always"&&(l={...l,probe:!d}),t(o,p,(h,..._)=>{let g=x=>{x instanceof he&&(x.path="key"in x?[x.key]:[],o instanceof he&&(x.path="key"in x?o.path.concat(x.key):o.path.slice(0),Object.defineProperty(x,"context",{get:()=>o,configurable:!0})))},E=_[0]||{},N=x=>{if(x instanceof he&&"argumentsList"in x)return;let S=Le(x,!1);return Ct(S,A=>(x instanceof he?x.value=A:x=A,a(x,u,{...l,...E,keyInParent:x.key,level:l.level+1},f)))};if(Vt(p)&&Array.isArray(h)){if(h.forEach(g),d)return s(h,..._);f&&h[0]instanceof he&&(h[0].operation!=="get"||r.asGet)&&s(h,..._);for(let x of h)N(x);return}return g(h),d?s(h,..._):N(h)},l)}(c,e.slice(0),{...r,level:0},n)}function Ia(c,e,t,s={}){let r=Le(c,!s.level);if(je(arguments[1])&&([,t,s={}]=arguments,e=1/0),!je(t))throw new Error(`Handler must be a function; "${pt(t)}" given!`);if(e instanceof zt||e instanceof ut)return Ca(r,e,Ia,t,s);if(s={...s,descripted:!0},delete s.live,!_e(r))return s.probe&&Fe(r,e,t,s)||void 0;let n=Za(r,e,t,s);return s.probe?Fe(r,e,n,s):n()}function Bi(c,e,t={}){let s=Le(c);return ne(e)||([,,,t={}]=arguments,e={[arguments[1]]:arguments[2]}),Je.getInstance(s,!0,t.namespace).addRegistration({traps:e,params:t})}function Hn(c,e,t=r=>r,s={}){return Te(c,"getOwnPropertyDescriptor",{key:e},t,s)}function $i(c,e,t=r=>r,s={}){return Te(c,"getOwnPropertyDescriptors",{key:e},t,s)}function wa(c,e=s=>s,t={}){return Te(c,"getPrototypeOf",{},e,t)}function Aa(c,e=s=>s,t={}){return Te(c,"isExtensible",{},e,t)}function Oa(c,e=s=>s,t={}){return Te(c,"ownKeys",{},e,t)}function Kn(c,e,t=r=>r,s={}){return Te(c,"has",{key:e},t,s)}function Fe(c,e,t=r=>r,s={}){let r,n=Le(c,!s.level);return ne(t)?[s,t]=[t,a=>a]:s.live&&(r=!0),e instanceof zt||e instanceof ut?Ca(n,e,Fe,t,{...s,asGet:!0}):qi(n,e,a=>{let o=[...a];return function u(l,m,f){if(!m.length)return f(l);let p=m.shift();if(!["string","number","symbol"].includes(typeof p))throw new Error(`Property name/key ${p} invalid.`);function d(g,E=void 0){let N=A=>(g.value=A,u([...l,s.live||s.descripted?g:A],m,f));if(arguments.length>1)return N(E);if(!_e(n))return N(n?.[g.key]);let x=le(n,"accessorizedProps",!1),S=x&&x.get(g.key);if(S&&S.intact())return N(S.getValue(s.withPropertyDescriptors));if(s.withPropertyDescriptors){let A=Object.getOwnPropertyDescriptor(n,g.key);return N(A)}return N(Reflect.get(n,g.key))}let h=new he(n,{type:"get",key:p,value:void 0,operation:"get",related:o});if(!_e(n))return d(h);let _=Je.getInstance(n,!1,s.namespace);return _?_.emit(h,d):d(h)}([],a.slice(0),u=>{let l=Vt(e)?u:u[0];return r&&_e(n)?Za(n,e,t,s,c.key)(l):t(l)})},s)}function ka(c,e,t={}){let s=Le(c);return $e.getInstance(s,!0,t.namespace).batch(e,t)}function Ji(c,e,t={}){e=Le(e),c=Le(c);let s=(t.only||[]).slice(0),r=(t.except||[]).slice(0),n=Object.keys(t.spread?[...c]:c).map(l=>isNaN(l)?l:parseInt(l)),a=s.length?s.filter(l=>n.includes(l)):n.filter(l=>!r.includes(l)),o=l=>!Array.isArray(e)||isNaN(l)?l:l-r.filter(m=>m<l).length,u=l=>{let m=Hn(c,l,t);"value"in m&&m.writable&&m.enumerable&&m.configurable?lt(e,o(l),m.value,t):(m.enumerable||t.onlyEnumerable===!1)&&Kt(e,l,{...m,configurable:!0},t)};return ka(e,()=>{a.forEach(u)}),Ia(c,l=>{l.filter(m=>s.length?s.includes(m.key):!r.includes(m.key)).forEach(m=>{if(m.type==="delete")return Yt(e,o(m.key),t);if(m.type==="def"){(m.value.enumerable||t.onlyEnumerable===!1)&&Kt(e,o(m.key),{...m.value,configurable:!0},t);return}u(m.key)})},{...t,withPropertyDescriptors:!0})}function lt(c,e,t,s=a=>a,r={},n=!1){let a=Le(c),o=[[e,t]];ne(e)&&([,,s=l=>l,r={},n=!1]=arguments,o=Object.entries(e)),ne(s)&&([n,r,s]=[typeof r=="boolean"?r:n,s,l=>l]);let u=o.map(([l])=>l);return function l(m,f,p){if(!f.length)return p(m);let[d,h]=f.shift();function _(E,N=void 0){let x=v=>(E.status=v,l(m.concat(E),f,p));if(arguments.length>1)return x(E,N);let S=le(a,"accessorizedProps",!1),A=S&&S.get(E.key);return E.type==="def"?(A&&!A.restore()&&x(!1),Object.defineProperty(a,E.key,E.value),x(!0)):A&&A.intact()?x(A.setValue(E.value)):x(Reflect.set(a,E.key,E.value))}function g(E,N){if(r.diff&&h===N)return l(m,f,p);let x=new he(a,{type:n?"def":"set",key:d,value:h,isUpdate:E,oldValue:N,related:[...u],operation:n?"defineProperty":"set",detail:r.detail}),S=Je.getInstance(a,!1,r.namespace);return S?S.emit(x,_):_(x)}return Kn(a,d,E=>{if(!E)return g(E);if(d==="length"&&Array.isArray(a)&&le(a).has("$length"))return g(!0,le(a).get("$length"));let N={...r,withPropertyDescriptors:n};return Fe(a,d,x=>g(E,x),N)},r)}([],o.slice(0),l=>{let m=$e.getInstance(a,!1,r.namespace);return m&&m.emit(l,{eventsArePropertyDescriptors:!!n}),s(Vt(e)?l.map(f=>f.status):l[0]?.status)})}function Kt(c,e,t,s=n=>n,r={}){return lt(c,e,t,s,r,!0)}function Fi(c,e,t=r=>r,s={}){return lt(c,e,t,s,!0)}function Yt(c,e,t=r=>r,s={}){let r=Le(c);ne(t)&&([s,t]=[t,o=>o]);let n=tt(e,!1),a=[...n];return function o(u,l,m){if(!l.length)return m(u);let f=l.shift();function p(h,_=void 0){let g=x=>(h.status=x,o(u.concat(h),l,m));if(arguments.length>1)return g(h,_);let E=le(r,"accessorizedProps",!1),N=E&&E.get(h.key);return N&&!N.restore()&&g(!1),g(Reflect.deleteProperty(r,h.key))}function d(h){let _=new he(r,{type:"delete",key:f,oldValue:h,related:[...a],operation:"deleteProperty",detail:s.detail}),g=Je.getInstance(r,!1,s.namespace);return g?g.emit(_,p):p(_)}return Fe(r,f,d,s)}([],n.slice(0),o=>{let u=$e.getInstance(r,!1,s.namespace);return u&&u.emit(o),t(Vt(e)?o.map(l=>l.status):o[0].status)})}function Gi(c,e,t=r=>r,s={}){return Yt(...arguments)}function va(c,e,t=null,s=n=>n,r={}){return Te(c,"construct",arguments.length>2?{argumentsList:e,newTarget:t}:{argumentsList:e},s,r)}function ba(c,e,t,s=n=>n,r={}){let n=Ht(e),a;if(Array.isArray(e)){if(r.arrayMethodName){let o=new he(n,{operation:r.arrayMethodName,argumentsList:t});$e.getInstance(n,!1,r.namespace)?.emit([o],{eventIsArrayMethodDescriptor:!0})}le(n).set("$length",n.length),a=ka(n,()=>Te(c,"apply",{thisArgument:e,argumentsList:t},s,r),r),le(n).delete("$length")}else a=Te(c,"apply",{thisArgument:n,argumentsList:t},s,r);return a}function Ta(c,e,t=r=>r,s={}){return Te(c,"setPrototypeOf",{proto:e},t,s)}function Ra(c,e=s=>s,t={}){return Te(c,"preventExtensions",{},e,t)}function Za(c,e,t,s={}){let r=new AbortController;Wn.setMaxListeners?.(0,r.signal),s.signal&&s.signal.addEventListener("abort",()=>r.abort());let n={...s,signal:r.signal},a=$e.getInstance(c,!0,n.namespace),o=new Map;return function u(l=[],m=null){let f,p,d;if(Vt(e)){if(m){d=!0,p=m;for(let h of l)o.get(h.key)?.remove(),o.delete(h.key)}else p=a.addRegistration(e,u,n);f={signal:p.signal,childRegistrations:o}}else m?.remove(),p=a.addRegistration(e,u,n),f={signal:p.signal};if(n.childRegistrations&&n.keyInParent&&n.childRegistrations.set(n.keyInParent,p),arguments.length){let h=t(l,f);if(arguments.length>1)return h}return r}}function Te(c,e,t={},s=n=>n,r={}){c=Le(c),ne(s)&&([r,s]=[s,u=>u]);function n(u,l){return arguments.length>1?s(l):s((Reflect[e]||Object[e])(c,...Object.values(t)))}let a=new he(c,{operation:e,...t}),o=Je.getInstance(c,!1,r.namespace);return o?o.emit(a,n):n(a)}function Vt(c){return c===1/0||Array.isArray(c)}function Le(c,e=!0,t=!0){if((!c||!_e(c))&&e)throw new Error(`Object must be of type object or array! "${pt(c)}" given.`);return c instanceof he&&(c.type==="def"&&t?c=typeof c.value.get=="function"?c.value.get():c.value.value:c=c.value),c&&Ht(c)}function qi(c,e,t,s={}){return e===1/0?s.level&&!_e(c)?t([]):t(Object.entries(Object.getOwnPropertyDescriptors(c)).filter(([,r])=>r.writable!==!1&&!r.get&&!r.set).map(([r])=>r)):t(tt(e,!1))}var Wi={...Da,...Sa},It=Wi;var kt=class{#e;#t;get rows(){return this.#e}get rowCount(){return this.#t}get affectedRows(){return this.#t}constructor({rows:e=[],rowCount:t=0}={}){this.#e=e,this.#t=t}};var Yn=class extends kt{#e;#t;#r;get hashes(){return this.#t}constructor({rows:e=[],hashes:t=[]}={},s=()=>{},r=void 0){super({rows:e}),this.#e=It.proxy(e),this.#t=t,this.#r=s,r&&r.addEventListener("abort",()=>this.abort())}abort(){this.#r()}_apply(e,t){e==="diff"&&It.batch(this.#e,()=>{for(let s of t){if(s.type==="update"){let r=this.#t.indexOf(s.oldHash);r>-1?(It.set(this.#e[r],s.new,{diff:!0}),this.#t[r]=s.newHash):s={...s,type:"insert"}}if(s.type==="insert"&&(this.#e.push(s.new),this.#t.push(s.newHash)),s.type==="delete"){let r=this.#t.indexOf(s.oldHash);r>-1&&(this.#e.splice(r,1),this.#t.splice(r,1))}}}),e==="swap"&&It.batch(this.#e,()=>{let s=this.rows.slice(0),r=this.#t.slice(0);for(let[n,a]of t){let o=r.indexOf(n),u=r.indexOf(a);this.#e[u]=s[o],this.#t[u]=n}}),e==="result"&&(this.#t=t.hashes,It.batch(this.#e,()=>{let s=Math.max(this.#e.length,t.rows.length);for(let r=0;r<s;r++){if(!t.rows[r]){this.#e.splice(r);break}z(t.rows[r],this.#e[r])||(this.#e[r]=t.rows[r])}}))}};var Hi=Symbol.for("tbl_placeholder"),ei=Symbol.for("grouping_meta"),zn=Symbol.for("window_meta"),Dt=class{#e;#t;constructor(e=null,t={}){this.#e=e,this.#t=t}async evaluate(e,t,s={}){if(!e)throw new Error("ExprEngine: Cannot evaluate null/undefined node");if(["DERIVED_QUERY","SCALAR_SUBQUERY"].includes(e.NODE_NAME)){if(!this.#e)throw new Error(`ExprEngine: Node ${e.NODE_NAME} not supported in this context`);return await this.#e(e,t,s)}let r=this[e.NODE_NAME];if(!r)throw new Error(`ExprEngine: Unsupported AST node: ${e.NODE_NAME}`);return await r.call(this,e,t,s)}async evaluateToScalar(e,t,s){if(e instanceof y.DerivedQuery){let r=[];for await(let a of await this.evaluate(e,t,s))r.push(a);if(!r.length)return;if(r.length>1)throw new Error(`[${node}] Subquery returned more than one row`);let n=Object.values(r[0]);if(n.length>1)throw new Error(`[${node}] Subquery returned more than one column`);return n[0]??null}if(e instanceof y.RowConstructor){if(e.length!==1)throw new Error(`Expects a scalar expression but got ${e}`);return await this.evaluateToScalar(e.entries()[0],t,s)}return await this.evaluate(e,t,s)}async evaluateToList(e,t,s){if(e instanceof y.DerivedQuery){let n=[];for await(let a of await this.evaluate(e,t,s))n.push(a);if(!n.length)return[];if(Object.values(n[0]).length>1)throw new Error(`[${node}] Subquery returned more than one column`);return n.map(a=>Object.values(a)[0])}if(e instanceof y.RowConstructor){let n=await Promise.all(e.entries().map(a=>this.evaluateToScalar(a,t,s)));return n.some(a=>a instanceof w)?y.RowConstructor.fromJSON({nodeName:y.RowConstructor.NODE_NAME,entries:n.map(ce)},{assert:!0,dialect:s.options?.dialect}):n}let r=await this.evaluate(e,t,s);if(!Array.isArray(r)&&!(r instanceof w))throw new Error(`[${e}] Not a list`);return r}async SELECT_ITEM(e,t,s={}){let r=e.alias()?.value()||(this.#t.dialect==="mysql","?column?"),n=await this.evaluateToScalar(e.expr(),t,s);return{alias:r,value:n}}async ON_CLAUSE(e,t,s={}){return await this.evaluate(e.expr(),t,s)}async USING_CLAUSE(e,t){return(e.columns()||[e.column()]).every(r=>{let n=r.value(),a=Object.keys(t).filter(o=>o&&n in t[o]);if(a.length<2)throw new Error(`USING clause column ${n} not found in both tables`);return a.reduce((o,u)=>o&&z(t[u][n],t[a[0]][n]),!0)})}async ROW_CONSTRUCTOR(e,t,s={}){let r=await Promise.all(e.entries().map(n=>this.evaluateToScalar(n,t,s)));return r.length===1?r[0]:r.some(n=>n instanceof w)?y.RowConstructor.fromJSON({nodeName:y.RowConstructor.NODE_NAME,entries:r.map(ce)},{assert:!0,dialect:s.options?.dialect}):r}async TYPED_ROW_CONSTRUCTOR(e,t,s={}){return await this.ROW_CONSTRUCTOR(e,t,s)}async PG_TYPED_ARRAY_LITERAL(e,t,s={}){let r=await Promise.all(e.entries().map(n=>this.evaluate(n,t,s)));return r.some(n=>n instanceof w)?y.PGTypedArrayLiteral.fromJSON({nodeName:y.PGTypedArrayLiteral.NODE_NAME,entries:r.map(ce)},{assert:!0,dialect:s.options?.dialect}):r}async CASE_EXPR(e,t,s={}){let r=e.subject()?await this.evaluate(e.subject(),t,s):void 0,n=[];for(let o of e){let u=await this.evaluate(o.condition(),t,s);if(r instanceof w||u instanceof w){n.push({nodeName:y.CaseBranch.NODE_NAME,condition:ce(u),consequent:ce(await this.evaluate(o.consequent(),t,s))});continue}if(r===void 0?!!u:z(r,u)){let m=await this.evaluate(o.consequent(),t,s);if(!n.length)return m;n.push({nodeName:y.CaseBranch.NODE_NAME,condition:ce(u),consequent:ce(m)});continue}}let a;return e.alternate()&&(a=await this.evaluate(e.alternate(),t,s),!n.length)?a:n.length?y.CaseExpr.fromJSON({nodeName:y.CaseExpr.NODE_NAME,subject:ce(r),entries:n,alternate:ce(a)},{assert:!0,dialect:s.options?.dialect}):null}async CAST_EXPR(e,t,s={}){return await this._CAST_EXPR(e.expr(),e.dataType(),t,s)}async PG_CAST_EXPR2(e,t,s={}){return await this._CAST_EXPR(e.left(),e.right(),t,s)}async _CAST_EXPR(e,t,s,r={}){let n=await this.evaluateToScalar(e,s,r);if(n instanceof w)return y.CastExpr.fromJSON({nodeName:y.CastExpr.NODE_NAME,expr:ce(n),data_type:t.jsonfy()},{assert:!0,dialect:r.options?.dialect});switch(t.value()){case"INT":return parseInt(n);case"TEXT":return String(n);case"BOOLEAN":return!!n;default:return n}}async PREDICATE_EXPR(e,t,s={}){let r=e.predicate();switch(r){case"EXISTS":let n=await this.evaluate(e.expr(),t,s);return n instanceof w?y.PredicateExpr.fromJSON({nodeName:y.PredicateExpr.NODE_NAME,predicate:r,expr:n},{assert:!0,dialect:s.options?.dialect}):!!(await n.next()).value;default:throw new Error(`ExprEngine: Unimplemented predicate ${e.predicate()}`)}}async IN_EXPR(e,t,s={}){let r=await this.evaluateToScalar(e.left(),t,s),n=await this.evaluateToList(e.right(),t,s),a=e.negation();return r instanceof w||n instanceof w?y.InExpr.fromJSON({nodeName:y.InExpr.NODE_NAME,left:ce(r),negation:a,operator:"IN",right:ce(n)},{assert:!0,dialect:s.options?.dialect}):(u=>a?!u:u)(n.some(u=>z(r,u)))}async BETWEEN_EXPR(e,t,s={}){let r=await this.evaluateToScalar(e.left(),t,s),n=await Promise.all(e.right().map(u=>this.evaluateToScalar(u,t,s))),a=e.negation();return r instanceof w||n.some(u=>u instanceof w)?y.BetweenExpr.fromJSON({nodeName:y.BetweenExpr.NODE_NAME,left:ce(r),negation:a,operator:"BETWEEN",right:n.map(ce)},{assert:!0,dialect:s.options?.dialect}):(u=>a?!u:u)(r>=n[0]&&r<=n[1])}async DISTINCT_FROM_EXPR(e,t,s={}){let r=await this.evaluate(e.left(),t,s),n=await this.evaluate(e.right(),t,s),a=e.logic();if(r instanceof w||n instanceof w)return y.DistinctFromExpr.fromJSON({nodeName:y.DistinctFromExpr.NODE_NAME,left:ce(r),logic:a,operator:"DISTINCT FROM",right:ce(n)},{assert:!0,dialect:s.options?.dialect});let o=a==="IS NOT";return(l=>o?!l:l)(!z(r,n))}async BINARY_EXPR(e,t,s={}){let r=e.operator().toUpperCase(),n=e.negation(),a=(f,p)=>y.BinaryExpr.fromJSON({nodeName:y.BinaryExpr.NODE_NAME,operator:r,left:ce(f),right:ce(p)},{assert:!0,dialect:s.options?.dialect}),o=f=>n?!f:f,u=(f,p)=>{if((f===null||p===null)&&r!=="IS"&&r!=="IS NOT")return!1;switch(r){case"=":case"IS":return z(f,p);case"<>":case"!=":case"IS NOT":return!z(f,p);case"<":return f<p;case"<=":return f<=p;case">":return f>p;case">=":return f>=p;case"LIKE":return Ki(String(f),String(p));default:throw new Error(`ExprEngine: Unsupported comparison operator ${r}`)}};if(e.right()instanceof y.QuantitativeExpr){let f=e.right().quantifier(),p=await this.evaluateToScalar(e.left(),t,s),d=await this.evaluateToList(e.right().expr(),t,s);if(p instanceof w||d instanceof w)return a(p,y.QuantitativeExpr.fromJSON({nodeName:y.QuantitativeExpr.NODE_NAME,quantifier:f,expr:ce(d)},{assert:!0,dialect:s.options?.dialect}));switch(f){case"ALL":return o(d.every(h=>u(p,h)));case"ANY":case"SOME":return o(d.some(h=>u(p,h)))}}let l=await this.evaluateToScalar(e.left(),t,s),m=await this.evaluateToScalar(e.right(),t,s);if(r==="AND")return o(l&&m);if(r==="OR")return o(l||m);if(l instanceof w||m instanceof w)return a(l,m);switch(r){case"=":case"IS":case"<>":case"!=":case"IS NOT":case"<":case"<=":case">":case">=":case"LIKE":return o(u(l,m));case"+":return Number(l)+Number(m);case"-":return Number(l)-Number(m);case"/":return Number(l)/Number(m);case"*":return Number(l)*Number(m);case"%":return Number(l)%Number(m);case"||":return String(l??"")+String(m??"");case"->":case"->>":{if(l==null)return null;let f;return typeof m=="number"?f=Array.isArray(l)?l[m]:void 0:typeof m=="string"&&(typeof l=="object"&&!Array.isArray(l)?f=l[m]:Array.isArray(l)&&!isNaN(m)&&(f=l[Number(m)])),r==="->"?f:f==null?null:String(f)}case"#>":case"#>>":{if(l==null||!Array.isArray(m))return null;let f=l;for(let p of m){if(f==null)return null;if(Array.isArray(f)&&!isNaN(p))f=f[Number(p)];else if(typeof f=="object")f=f[p];else return null}return r==="#>"?f:f==null?null:String(f)}case"@>":{if(l==null||m==null||typeof l!="object"||typeof m!="object")return!1;let f=(p,d)=>typeof d!="object"||d==null?p===d:Array.isArray(d)?Array.isArray(p)?d.every((h,_)=>f(p[_],h)):!1:Object.keys(d).every(h=>f(p[h],d[h]));return f(l,m)}case"<@":{if(l==null||m==null||typeof l!="object"||typeof m!="object")return!1;let f=(p,d)=>typeof d!="object"||d==null?p===d:Array.isArray(d)?Array.isArray(p)?d.every((h,_)=>f(p[_],h)):!1:Object.keys(d).every(h=>f(p[h],d[h]));return f(m,l)}case"?":return l==null||typeof l!="object"?!1:Array.isArray(l)?l.includes(m):Object.prototype.hasOwnProperty.call(l,m);case"?|":return l==null||typeof l!="object"||!Array.isArray(m)?!1:Array.isArray(l)?m.some(f=>l.includes(f)):m.some(f=>Object.prototype.hasOwnProperty.call(l,f));case"?&":return l==null||typeof l!="object"||!Array.isArray(m)?!1:Array.isArray(l)?m.every(f=>l.includes(f)):m.every(f=>Object.prototype.hasOwnProperty.call(l,f));default:throw new Error(`ExprEngine: Unsupported binary operator ${r}`)}}async UNARY_EXPR(e,t,s={}){let r=e.operator().toUpperCase(),n=await this.evaluateToScalar(e.operand(),t,s);if(n instanceof w)return y.UnaryExpr.fromJSON({nodeName:y.UnaryExpr.NODE_NAME,operand:n},{assert:!0,dialect:s.options?.dialect});switch(r){case"NOT":return!n;case"-":return-n;default:throw new Error(`ExprEngine: Unsupported unary operator ${r}`)}}async CALL_EXPR(e,t,s={}){let r=e.name().toUpperCase();if(r==="UNNEST"||r==="GENERATE_SERIES"){let a=await Promise.all(e.arguments().map(o=>this.evaluate(o,t,s)));return function*(){if(r==="UNNEST")for(let o=0;o<a[0].length;o++)yield a.map(u=>u[o]??null);if(r==="GENERATE_SERIES")for(let o=a[0];o<=a[1];o+=a[2]??1)yield[o]}()}if(r==="GROUPING"||r==="GROUPING_ID"){let a=t[ei];if(!a)throw new Error(`${r}() called outside of grouping pipeline`);let o=e.arguments(),u=m=>{let f=a.exprIndex.get(m);if(f!==void 0)return a.groupingId>>f&1;if(!(m instanceof y.ColumnRef1))throw new Error(`${r}() argument must be a grouping column reference`);let p=m.qualifier()?.value()||"",d=m.value();return a.groupingColumnsMap.get(p)?.has(d)?0:1};if(r==="GROUPING_ID"&&o.length===a.exprIndex.size&&o.every((m,f)=>a.exprIndex.has(m)&&a.exprIndex.get(m)===f))return a.groupingId;let l=0;for(let m=0;m<o.length;m++){let f=u(o[m]);if(r==="GROUPING")return f;l=l<<1|f}return l}if(r==="VALUES"&&t.EXCLUDED&&typeof t.EXCLUDED=="object"){let o=e.arguments()[0].value();return t.EXCLUDED[o]}let n=await Promise.all(e.arguments().map(a=>this.evaluate(a,t,s)));if(n.some(a=>a instanceof w))return y.CallExpr.fromJSON({nodeName:y.CallExpr.NODE_NAME,name:r,arguments:n.map(ce)},{assert:!0,dialect:s.options?.dialect});switch(r){case"LOWER":return String(n[0]??"").toLowerCase();case"UPPER":return String(n[0]??"").toUpperCase();case"LENGTH":return n[0]==null?null:String(n[0]).length;case"ABS":return Math.abs(Number(n[0]));case"COALESCE":return n.reduce((a,o)=>a!==null?a:o,null);case"NULLIF":return z(n[0],n[1])?null:n[0];case"JSON_BUILD_ARRAY":case"JSON_ARRAY":return n;case"JSON_BUILD_OBJECT":case"JSON_OBJECT":{if(n.length%2!==0)throw new Error("JSON_BUILD_OBJECT requires an even number of arguments");let a=Object.create(null);for(let o=0;o<n.length;o+=2)a[n[o]]=n[o+1];return a}default:throw new Error(`ExprEngine: Unsupported function ${e.name()}`)}}async AGGR_CALL_EXPR(e,t,s={}){let r;if(e.overClause()){let p=t[zn];if(!p)throw new Error(`${e} called outside of window processing pipeline (1)`);if(!e.winHash)throw new Error(`${e} called outside of window processing pipeline (2)`);if(!p[e.winHash])throw new Error(`${e} called outside of window processing pipeline (3)`);r=p[e.winHash]}else{let p=t[ei];if(!p)throw new Error("GROUPING() called outside of grouping pipeline");r=p}let{window:n,frameStart:a,frameEnd:o,offset:u=0}=r,l=e.name().toUpperCase(),m=e.arguments(),f=m[0]||null;switch(l){case"COUNT":{if(!f||f instanceof y.ColumnRef0)return o-a+1;let p=0;for(let d=a;d<=o;d++){let h=n[d],_=await this.evaluate(f,h,s);_!=null&&p++}return p}case"SUM":case"AVG":{if(!f)return null;let p=0,d=0;for(let h=a;h<=o;h++){let _=n[h],g=await this.evaluate(f,_,s);g!==null&&!Number.isNaN(Number(g))&&(p+=Number(g),d++)}return l==="SUM"?d===0?null:p:d===0?null:p/d}case"MIN":case"MAX":{if(!f)return null;let p=null;for(let d=a;d<=o;d++){let h=n[d],_=await this.evaluate(f,h,s);_!=null&&(p==null?p=_:(l==="MIN"&&_<p&&(p=_),l==="MAX"&&_>p&&(p=_)))}return p}case"JSON_AGG":case"JSON_ARRAYAGG":{if(!f)return[];let p=[];for(let d=a;d<=o;d++){let h=n[d];p.push(await this.evaluate(f,h,s))}return p}case"JSON_OBJECT_AGG":case"JSON_OBJECTAGG":{let p=m[0],d=m[1];if(!p||!d)return{};let h=Object.create(null);for(let _=a;_<=o;_++){let g=n[_],E=await this.evaluate(p,g,s),N=await this.evaluate(d,g,s);h[E]=N}return h}case"STRING_AGG":{let p=m[0],d=m[1]?await this.evaluate(m[1],t,s):",",h=[];for(let _=a;_<=o;_++){let g=await this.evaluate(p,n[_],s);g!=null&&h.push(String(g))}return h.join(d)}case"ARRAY_AGG":{let p=m[0],d=[];for(let h=a;h<=o;h++)d.push(await this.evaluate(p,n[h],s));return d}case"BIT_AND":{let p=m[0],d=-1;for(let h=a;h<=o;h++){let _=await this.evaluate(p,n[h],s);_!=null&&(d&=Number(_))}return d}case"BIT_OR":{let p=m[0],d=0;for(let h=a;h<=o;h++){let _=await this.evaluate(p,n[h],s);_!=null&&(d|=Number(_))}return d}case"BOOL_AND":{let p=m[0];for(let d=a;d<=o;d++)if(!await this.evaluate(p,n[d],s))return!1;return!0}case"BOOL_OR":{let p=m[0];for(let d=a;d<=o;d++)if(await this.evaluate(p,n[d],s))return!0;return!1}case"ROW_NUMBER":return u+1;case"RANK":case"PERCENT_RANK":{let p=r.orderKeysHash,d;for(let _=0;_<=u;_++){let g=n[_][zn][e.winHash].orderKeysHash;if(p===g){d=_+1;break}}if(l==="RANK")return d;let h=n.length;return h===1?0:(d-1)/(h-1)}case"DENSE_RANK":{let p=new Set;for(let d=0;d<=u;d++){let h=n[d][zn][e.winHash].orderKeysHash;p.has(h)||p.add(h)}return p.size}case"NTILE":{let p=Number(await this.evaluateToScalar(m[0],t,s));if(!Number.isInteger(p)||p<=0)throw new Error(`[${e}] NTILE(n) requires a positive integer`);let d=n.length,h=Math.floor(d/p),_=d%p,g=0;for(let E=1;E<=p;E++){let N=h+(E<=_?1:0);if(u<g+N)return E;g+=N}}case"CUME_DIST":{let p=n.length,d=r.orderKeysHash,h=u;for(let _=u+1;_<p&&n[_][zn][e.winHash].orderKeysHash===d;_++)h=_;return(h+1)/p}case"LAG":{let p=m[0],d=Number(await this.evaluate(m[1]??{value:1},t,s)),h=m[2]?await this.evaluate(m[2],t,s):null,_=u-d;return _>=0?await this.evaluate(p,n[_],s):h}case"LEAD":{let p=m[0],d=Number(await this.evaluate(m[1]??{value:1},t,s)),h=m[2]?await this.evaluate(m[2],t,s):null,_=u+d;return _<n.length?await this.evaluate(p,n[_],s):h}case"FIRST_VALUE":{let p=m[0];return await this.evaluate(p,n[a],s)}case"LAST_VALUE":{let p=m[0];return await this.evaluate(p,n[o],s)}case"NTH_VALUE":{let p=m[0],d=Number(await this.evaluateToScalar(m[1],t,s));if(!Number.isInteger(d)||d<=0)throw new Error(`[${e}] NTH_VALUE(n) requires a positive integer`);let h=a+(d-1);return h>o?null:await this.evaluate(p,n[h],s)}default:throw new Error(`ExprEngine: Unsupported window function ${e.name()}`)}}async COLUMN_REF1(e,t){if(!e)return;let s=e.value(),r=e.qualifier()?.value()||"";if(r){let n=t[r];if(n===Hi)return e.clone();if(!n)throw new Error(`Table alias ${r} not found in the current context`);return n[s]}for(let n of Object.keys(t)){let a=t[n];if(s in a)return a[s]}throw new Error(`Column ${s} not found in the current context`)}async BIND_VAR(e,t,s={}){if(!Array.isArray(s.options.values))throw new Error(`there is no parameter ${e}`);let r=Number(e.value());if(s.options.values.length<r)throw new Error(`there is no parameter ${e}`);return s.options.values[r-1]}async DEFAULT_LITERAL(e){return null}async STRING_LITERAL(e){return e.value()}async NUMBER_LITERAL(e){return Number(e.value())}async BOOL_LITERAL(e){return e.value()==="TRUE"}async NULL_LITERAL(){return null}resolveScopedRefsInClause(e,t){return e.entries().map(s=>{let r;if(s.expr()instanceof y.NumberLiteral){if(!(r=t.entries()[parseInt(s.expr().value())-1]?.expr()))throw new Error(`[${e}] The reference by offset ${s.expr().value()} does not resolve to a select list entry`)}else s.expr()?.resolution?.()==="scope"&&(r=t.entries().find((n,a)=>n.alias()?.identifiesAs(s.expr()))?.expr());return r&&(s=s.constructor.fromJSON({...s.jsonfy(),expr:r.jsonfy()},{assert:!0}),e._adoptNodes(s)),s})}applySorting(e,t,s={}){e.sort((r,n)=>{for(let a=0;a<t.length;a++){let o=t[a].dir()==="DESC",u=o?-1:1,l=t[a].nullsSpec()||(s.options?.dialect==="mysql"?o?"LAST":"FIRST":o?"FIRST":"LAST"),m=r.keys[a],f=n.keys[a],p=m===null,d=f===null;if(!(p&&d)){if(p||d)if(l==="FIRST"){if(p)return-1;if(d)return 1}else{if(p)return 1;if(d)return-1}if(m<f)return-u;if(m>f)return u}}return 0})}};function ce(c){if(c===void 0||c instanceof w)return c;if(typeof c=="number")return y.NumberLiteral.fromJSON({value:c});if(typeof c=="string")return y.StringLiteral.fromJSON({value:c});if(typeof c=="boolean")return y.BoolLiteral.fromJSON({value:c});if(c===null)return y.NullLiteral.fromJSON({value:c});throw new Error(`Cannot convert value to AST node: ${c}`)}function Ki(c,e){let t=e.replace(/([.+^=!:${}()|\[\]\\/])/g,"\\$1").replace(/%/g,".*").replace(/_/g,".");try{return new RegExp(`^${t}$`,"i").test(c)}catch{return!1}}var Vn=class c extends Ne{static analyseQuery(e){let t={hasSubqueryExprsInSelect:0,hasSubqueryExprsInWhere:0,hasSubqueryExprsInOrderBy:0,hasSubqueryExprs:0,hasWindowFunctions:!1,hasAggrFunctions:!1,hasGroupByClause:!1,hasOrderByClause:!1,hasOffsetClause:!1,hasLimitClause:!1,fromItemsBySchema:{},fromItemsByAlias:{},isSingleTable:!1};e.walkTree(n=>{if(n instanceof y.AggrCallExpr)n.overClause()?t.hasWindowFunctions=!0:t.hasAggrFunctions=!0;else if(n instanceof y.DerivedQuery){let a=new Set;s(n.expr(),t.fromItemsBySchema,a);let o=a.size||!(n.expr()instanceof y.SelectStmt)?2:n.isCorrelated()?1:0;if(o===0)return;t.hasSubqueryExprs<o&&(t.hasSubqueryExprs=o),t.hasSubqueryExprsInSelect<o&&e.selectList().containsNode(n)?t.hasSubqueryExprsInSelect=o:t.hasSubqueryExprsInWhere<o&&e.whereClause()?.containsNode(n)?t.hasSubqueryExprsInWhere=o:t.hasSubqueryExprsInOrderBy<o&&e.orderByClause()?.containsNode(n)&&(t.hasSubqueryExprsInOrderBy=o)}else if(n instanceof y.FromItem){let a=n.alias()?.value()||"";if(n.expr()instanceof y.DerivedQuery){let o=new Set;s(n.expr().expr(),t.fromItemsBySchema,o),t.fromItemsByAlias[a]=o}else if(n.expr()instanceof y.TableRef1&&n.expr().resolution()==="default"){let o=new Set;r(n.expr(),t.fromItemsBySchema,o),t.fromItemsByAlias[a]=o}else t.fromItemsByAlias[a]=new Set}else return n});function s(n,a,o=null){n.walkTree(u=>{if(u instanceof y.FromItem&&u.expr()instanceof y.TableRef1&&u.expr().resolution()==="default")r(u.expr(),a,o);else return u},!0)}function r(n,a,o=null){let u=n.value(),l=n.qualifier().value();a[l]=[].concat(a[l]||[]).concat(u),o&&o.add(JSON.stringify([l,u]))}return e.groupByClause()&&(t.hasGroupByClause=!0),e.orderByClause()&&(t.hasOrderByClause=!0),e.offsetClause()&&(t.hasOffsetClause=!0),e.limitClause()&&(t.hasLimitClause=!0),t.isSingleTable=!e.joinClauses()?.length&&!(t.hasAggrFunctions||t.hasGroupByClause)&&!t.hasWindowFunctions&&t.hasSubqueryExprs!==2&&(n=>n.length===1&&!(n[0].expr()instanceof y.DerivedQuery))(e.fromClause().entries()),t}static intersectQueries(e,t,s){let r=["select_list","where_clause","order_by_clause","offset_clause","limit_clause"],n=new Set(e._keys().filter(N=>!r.includes(N))),a=new Set(t._keys().filter(N=>!r.includes(N)));if(n.size!==a.size)return!1;for(let N of new Set([...n,...a]))if(!n.has(N)||!a.has(N)||!pe(e._get(N),t._get(N)))return!1;let o=[];if(s.projection==="="){let N=e.selectList().entries(),x=t.selectList().entries();for(let S of x){let A=N.findIndex(v=>pe(v.expr(),S.expr()));if(A===-1)return!1;o.push(A)}}let u=[],l=e.whereClause()?.expr(),m=t.whereClause()?.expr();if(l||m){if(s.whereClause===">=")if(!l)u.push(m);else{let N=pe(l,m,"AND~");if(N===!1)return!1;u.push(...N)}else if(!pe(l,m))return!1}let f=e.orderByClause()?.entries()||[],p=t.orderByClause()?.entries()||[];if(s.ordinality==="="){if(f.length!==p.length||!f.every((N,x)=>pe(N.expr(),p[x].expr()))||s.orderDirections==="="&&!f.every((N,x)=>pe(N.dir(),p[x].dir())))return!1}else if(f.length&&!p.length)return!1;let d=0,h=e.offsetClause()?.expr(),_=t.offsetClause()?.expr();if(s.offsetClause==="="){if((h||_)&&!pe(h,_))return}else if((h||_)&&(!(_ instanceof y.NumberLiteral)||(d=_.value()-(h?.value()||0))<0))return!1;let g=e.limitClause()?.expr(),E=t.limitClause()?.expr();if(s.limitClause==="="){if((g||E)&&!pe(g,E))return}else if((g||E)&&(!(E instanceof y.NumberLiteral)||(g?.value()||1/0)-E.value()<0))return!1;return{selectMapping:o,filters:u,offset:d}}#e;#t;#r=0;#n;#i;#a;#s;#u;#l;#o={ssr:!1,requeryMode:"selective",requeryWrappedSelectivity:!1,diffing:"key"};#c={projection:"~",whereClause:">=",ordinality:"~",orderDirections:"~",offsetClause:">=",limitClause:"<="};#d;#m;#h=[];#y=new Map;#p;#E={selectMapping:[],filters:[],offset:0};#x=0;#f=new Map;#S=!1;#N=[];#_;get driver(){return this.#e}get analysis(){return this.#l}get strategy(){return this.#o}get subwindowingRules(){return this.#c}get status(){return this.#r}get parentWindow(){return this.#p}get inheritanceDepth(){return this.#x}constructor(e,t,s={}){if(super(),this.#e=e,!(t instanceof y.BasicSelectStmt))throw new Error("Only SELECT statements are supported in live mode");if(!t.fromClause())throw new Error("Query has no FROM clause");if(!Array.isArray(t.originSchemas()))throw new Error("Expected a pre-resolved query object with originSchemas() returning an array");this.#s=t,this.#u=this.#s.jsonfy({resultSchemas:!1,originSchemas:!1}),this.#t=s,this.#_={dialect:this.#e.dialect,assert:!0};let r=this;this.#i=new Dt(async function*(o,u,l){let m=o.expr();if(!(m instanceof y.SelectStmt))throw new Error(`Unexpected expression: ${m}`);let f=Object.create(null);for(let p of m.selectList()){let{alias:d,value:h}=await r.#i.evaluate(p,{},l);f[d]=h}yield f},this.#t),this.#s.orderByClause()&&(this.#N=this.#i.resolveScopedRefsInClause(this.#s.orderByClause(),this.#s.selectList()));let n=this.constructor.analyseQuery(t);this.#l=n;let a=this.#o;(n.hasAggrFunctions||n.hasGroupByClause)&&(a.ssr=!0,a.requeryMode="wholistic",this.#t.forceDiffing?a.diffing="deep":a.diffing=!1),n.hasWindowFunctions&&(a.ssr=!0,a.requeryMode==="selective"&&(a.requeryWrappedSelectivity=!0),a.diffing!==!1&&(a.diffing="deep")),(n.hasSubqueryExprsInSelect||n.hasSubqueryExprsInOrderBy)&&(a.ssr=!0,a.diffing!==!1&&n.hasSubqueryExprsInSelect&&(a.diffing="deep")),n.hasOffsetClause&&!this.#t.noOffsetRevalidate&&(a.requeryMode="wholistic"),(n.hasOffsetClause||n.hasLimitClause&&n.hasOrderByClause)&&a.requeryMode==="selective"&&(a.requeryWrappedSelectivity=!0),a.ssr?(this.#c.projection="=",this.#c.whereClause="=",this.#c.ordinality="="):n.hasSubqueryExprsInWhere&&(this.#c.whereClause="="),(n.hasOffsetClause||n.hasLimitClause&&n.hasOrderByClause)&&(this.#c.whereClause="=",this.#c.ordinality="=",this.#c.orderDirections="=")}async inherit(e){if(e===null){this.#E={selectMapping:[],filters:[],offset:0},this.#x=0,this.#p&&(this.#p=null,await this.stop());return}if(!(e instanceof c))throw new Error("Parent window must be instance of QueryWindow or null");if(!z(this.#c,e.#c))return!1;let t=this.constructor.intersectQueries(e.#s,this.#s,this.#c);return t===!1?!1:(this.#E=t,this.#x=e.inheritanceDepth+1,this.#p=e,await this.start(),!0)}async start(){await this.stop(),this.#p?await this.#b():await this.#v(),this.#r=1}async stop(){await this.#n?.(),this.#n=null,this.#r=0}async#v(){let e=this.#l,t=this.#o,s=u=>{let l=u.value(),m=u._get("delim");return{value:m?l:l.toLowerCase(),delim:m}};for(let[u,l]of Object.entries(e.fromItemsByAlias)){let m=this.#s.originSchemas().find(g=>g instanceof y.JSONSchema?u==="":g.identifiesAs(u)),f,p,d=!1;m instanceof y.JSONSchema?(f=m.entries().map(g=>s(g.name())),(l.size>1||!(p=m.entries().filter(g=>g.pkConstraint()).map(s)).length)&&(p=structuredClone(f),d=!0)):(f=m.columns().map(g=>s(g.name())),(l.size>1||!(p=m.pkConstraint(!0)?.columns().map(s)))&&(p=structuredClone(f),d=!0));let h=l.size===1?(([g,E])=>({namespace:g,name:E}))(JSON.parse([...l][0])):null;this.#y.set(u,{relation:h,relationHashes:l,columns:f.map(g=>g.value),keyColumns:p.map(g=>g.value),usingAllColumnsForKeyColumns:d,$columns:f,$keyColumns:p});let _=u!==u.toLowerCase()||/^\d/.test(u)||!/^(\*|[\w]+)$/.test(u);this.#h.push({value:u,delim:_&&'"'||""})}let r=this.#N.map(u=>u.jsonfy()),n=this.#h.reduce((u,l)=>{let m=this.#y.get(l.value),f=g=>{let E={nodeName:"STRING_LITERAL",...g},N={nodeName:"COLUMN_REF1",...g,qualifier:{nodeName:"TABLE_REF1",...l}};return e.hasAggrFunctions&&(N={nodeName:"CALL_EXPR",name:this.#e.dialect==="mysql"?"JSON_STRINGAGG":"JSON_AGG",arguments:[N]}),[E,N]},p=this.#e.dialect==="mysql"?"JSON_OBJECT":"JSON_BUILD_OBJECT",d=(t.ssr?m.$keyColumns:m.$columns).reduce((g,E)=>[...g,...f(E)],[]),h={nodeName:"CALL_EXPR",name:p,arguments:d};if(t.ssr){let g={nodeName:"STRING_LITERAL",...l};return u.concat(g,h)}let _={nodeName:"SELECT_ITEM_ALIAS",...l};return u.concat({nodeName:"SELECT_ITEM",alias:_,expr:h})},[]);if(t.ssr){let u=this.#e.dialect==="mysql"?"JSON_OBJECT":"JSON_BUILD_OBJECT",l=this.#u.select_list.entries.reduce((p,d)=>p.concat({nodeName:"STRING_LITERAL",value:d.alias.value},d.expr),[]),m={nodeName:"CALL_EXPR",name:u,arguments:l},f={nodeName:"CALL_EXPR",name:u,arguments:n};if(n=[{nodeName:"SELECT_ITEM",alias:{nodeName:"SELECT_ITEM_ALIAS",value:"ssr"},expr:m}],t.diffing&&(n.push({nodeName:"SELECT_ITEM",alias:{nodeName:"SELECT_ITEM_ALIAS",value:"key"},expr:f}),e.hasOrderByClause)){let d={nodeName:"CALL_EXPR",name:this.#e.dialect==="mysql"?"JSON_ARRAY":"JSON_BUILD_ARRAY",entries:r.map(h=>h.expr)};n.push({nodeName:"SELECT_ITEM",alias:{nodeName:"SELECT_ITEM_ALIAS",value:"ord"},expr:d})}}let a={entries:n},o=r.length?{entries:r}:void 0;this.#m={...this.#u,select_list:a,order_by_clause:o},this.#d=this.#s.constructor.fromJSON(this.#m,this.#_),this.#n=await this.#e.subscribe(e.fromItemsBySchema,async u=>{await this.#J(u)})}async#b(){let e=this.#p.on("rawresult",async s=>{s=await this.#w(s),await this.#O(s,!0)}),t=this.#p.on("rawdiff",async s=>{let r=new Set;for(let n of s)if(n.type==="delete"){if(!this.#f.has(n.oldHash))continue}else{let a=await this.#A(n.logicalRecord);this.#f.has(n.oldHash)?(n=a?{...n}:{...n,type:"delete"},r.add(n)):a&&(n={...n,type:"insert"},r.add(n))}r.size&&await this.#C(r)});this.#n=()=>{e(),t()}}async#w(e){let t=this.#l,s=this.#o,r=[];for(let[n,a]of e.entries())await this.#A(a)&&r.push([n,a]);if(s.diffing&&t.hasOrderByClause&&(this.#c.ordinality==="~"||this.#c.orderDirections==="~")&&(r=await this.#L(r)),t.hasOffsetClause||t.hasLimitClause){let n=await this.#i.evaluate(this.#s.limitClause().expr(),{},this.#a);r=r.slice(this.#E.offset,n)}return new Map(r)}async#A(e){for(let t of this.#E.filters)if(!await this.#i.evaluate(t,e,this.#a))return!1;return!0}async currentRendering(){let e=await this.currentRecords(),t=[],s=[];for(let[r,n]of e.entries()){let a=await this.#k(n);t.push(a),s.push(r)}return{rows:t,hashes:s}}async currentRecords(){if(!this.#S){let e;this.#p?(e=await this.#p.currentRecords(),e=await this.#w(e)):e=await this.#T(),await this.#O(e),this.#S=!0}return this.#f}async#T(e=null){let t=this.#o,s=this.#d;if(e&&t.requeryWrappedSelectivity){let a=u=>({...u,expr:{...u.expr,qualifier:void 0}}),o={nodeName:"BASIC_SELECT_STMT",select_list:{entries:this.#m.select_list.entries.map(a)},from_clause:{entries:[{nodeName:"FROM_ITEM",expr:{nodeName:"DERIVED_QUERY",expr:this.#m}}]},where_clause:{expr:e}};s=this.#s.constructor.fromJSON(o,this.#_)}else if(e){let a=this.#m,o=a.where_clause?.expr?{nodeName:"BINARY_EXPR",left:e,operator:"AND",right:a.where_clause.expr}:e;a={...a,where_clause:{nodeName:"WHERE_CLAUSE",expr:o}},s=this.#s.constructor.fromJSON(a,this.#_)}let r=await this.#e.query(s),n=new Map;for(let[a,o]of r.rows.entries()){let u=t.diffing?this.#j(o):`$${a}`;n.set(u,o)}return n}#P(e,t,s){return this.#o.ssr?e.key[t][s]:e[t][s]}#j(e){let t=[...this.#y.entries()].map(([s,r])=>{let n=r.keyColumns.map(a=>this.#P(e,s,a));return n.every(a=>a===null)?null:n});return this.#g(t)}#g(e){return JSON.stringify(e)}#I(e){return JSON.parse(e)}#R(e,t){this.#f.set(e,t)}#U(e){this.#f.delete(e)}#B(e){this.#f=new Map([...this.#f.entries()].map(([t,s])=>(e.has(t)&&(t=e.get(t)),[t,s])))}async#k(e){let t=Object.create(null);if(this.#o.ssr){if(!this.#E.filters.length)return e.ssr;let s=Object.values(e.ssr);for(let[r,n]of this.#s.selectList().entries().entries()){let a=s[r],o=n.alias()?.value()||"?column?";t[o]=a}return t}for(let s of this.#s.selectList()){let{alias:r,value:n}=await this.#i.evaluate(s,e,this.#a);t[r]=n}return t}#$(e){let t=new Map,s=new Map,r=new Set;for(let n of e){if(!(n.type==="insert"||n.type==="update"||n.type==="delete"))continue;let a=JSON.stringify([n.relation.namespace,n.relation.name]),o=[...this.#y.entries()].filter(([,g])=>g.relationHashes.has(a));if(!o.length||o.find(([,g])=>g.relationHashes.size>1))return!0;let u=o.map(([g])=>g);for(let g of u)r.add(g);let l=n.relation.keyColumns,m=n.key?Object.values(n.key):l.map(g=>n.new[g]),f=n.new?l.map(g=>n.new[g]):m.slice(0),p={...n,keyColumns:l,oldKeys:m,newKeys:f,relationHash:a,affectedAliases:u},d=this.#g([n.relation.namespace,n.relation.name,p.oldKeys]),h,_;if((_=t.get(d))||s.has(d)&&(_=t.get(d=s.get(d)))){if(_.type==="insert"&&p.type==="delete")continue;if(_.type==="delete"&&p.type==="insert"){let g={...p,type:"update",old:_.old};t.set(d,g);continue}if(_.type==="insert"&&p.type==="update"){let g={...p,oldKeys:_.oldKeys,old:null,type:"insert"};t.delete(d),t.set(d,g),(h=this.#g([n.relation.namespace,n.relation.name,p.newKeys]))!==d&&s.set(h,d);continue}if(_.type==="update"&&p.type==="update"){let g={...p,oldKeys:_.oldKeys,old:_.old};t.delete(d),t.set(d,g),(h=this.#g([n.relation.namespace,n.relation.name,p.newKeys]))!==d&&s.set(h,d);continue}if(_.type==="update"&&p.type==="delete"){t.delete(d),t.set(d,p);continue}}else p.type==="update"&&(h=this.#g([n.relation.namespace,n.relation.name,p.newKeys]))!==d&&s.set(h,d),t.set(d,p)}return[t,s,r]}async#J(e){let t=this.#l;if(this.#o.requeryMode==="wholistic")return await this.#D();let r=this.#$(e);if(r===!0)return await this.#D();if(t.isSingleTable){let[u]=r;return await this.#F(u)}let[n,a,o]=r;return await this.#G(n,a,o)}async#F(e){let t=new Set;for(let s of e.values()){if(s.type==="insert"){let r=this.#g([s.newKeys]),n={[s.affectedAliases[0]]:s.new};if(!(!this.#s.whereClause()||await this.#i.evaluate(this.#s.whereClause().expr(),n,this.#a)))continue;let o={type:"insert",newHash:r,logicalRecord:n};t.add(o)}if(s.type==="update"){let r=this.#g([s.oldKeys]),n=this.#g([s.newKeys]),a={[s.affectedAliases[0]]:s.new},o,u=!this.#s.whereClause()||await this.#i.evaluate(this.#s.whereClause().expr(),a,this.#a);this.#f.has(r)?o=u?{type:"update",oldHash:r,newHash:n,logicalRecord:a}:{type:"delete",oldHash:r}:u&&(o={type:"insert",newHash:n,logicalRecord:a}),o&&t.add(o)}if(s.type==="delete"){let r=this.#g([s.oldKeys]);if(this.#f.has(r)){let n={type:"delete",oldHash:r,logicalRecord:this.#f.get(r)};t.add(n)}}}return await this.#C(t)}async#G(e,t,s){let r=this.#o,n=(f,p,d,h=0)=>{if(p.length>1){let S=p.map((A,v)=>n(f,[A],[d[v]],h));return S.reduce((A,v)=>y.BinaryExpr.fromJSON({nodeName:"BINARY_EXPR",left:A,operator:"AND",right:v},this.#_),S.shift())}let _=r.requeryWrappedSelectivity?{nodeName:"BINARY_EXPR",left:{nodeName:"COLUMN_REF1",value:"key"},operator:"->",right:{nodeName:"BINARY_EXPR",left:{nodeName:"COLUMN_REF1",value:f},operator:"->>",right:{nodeName:"COLUMN_REF1",value:p[0]}}}:{nodeName:"COLUMN_REF1",value:p[0],qualifier:{nodeName:"TABLE_REF1",value:f}},g={nodeName:"NULL_LITERAL",value:"NULL"},E=y.BinaryExpr.fromJSON({nodeName:"BINARY_EXPR",left:_,operator:"IS",right:g},this.#_);if(h===0)return E;let N={nodeName:typeof d[0]=="number"?"NUMBER_LITERAL":"STRING_LITERAL",value:d[0]},x=y.BinaryExpr.fromJSON({nodeName:"BINARY_EXPR",left:_,operator:"=",right:N},this.#_);if(h===2){let S={nodeName:"BINARY_EXPR",left:E,operator:"OR",right:x};return y.RowConstructor.fromJSON({nodeName:"ROW_CONSTRUCTOR",entries:[S]},this.#_)}return x},a=new Map,o=[];for(let f of e.values()){let p=[],d=f.affectedAliases;f.type==="insert"&&(p=[d.map(_=>n(_,f.keyColumns,f.oldKeys,0)),d.map(_=>n(_,f.keyColumns,f.newKeys,2))]),f.type==="update"&&(p=[d.map(_=>n(_,f.keyColumns,f.oldKeys,2)),d.map(_=>n(_,f.keyColumns,f.newKeys,2))]),f.type==="delete"&&(p=[d.map(_=>n(_,f.keyColumns,f.oldKeys,2)),d.map(_=>n(_,f.keyColumns,f.newKeys,0))]);e:for(let[_,g]of this.#f.entries()){for(let E of p[0])if(!await this.#i.evaluate(E,g,this.#a))continue e;a.set(_,g)}let h=p[1].reduce((_,g)=>y.BinaryExpr.fromJSON({nodeName:"BINARY_EXPR",left:_,operator:"AND",right:g}),p[1].shift());o.push(h)}let u=o[0];if(o.length>1){let f=o.reduce((p,d)=>y.BinaryExpr.fromJSON({nodeName:"BINARY_EXPR",left:p,operator:"OR",right:d}),o.shift());r.requeryWrappedSelectivity?u=f:u=y.RowConstructor.fromJSON({nodeName:"ROW_CONSTRUCTOR",entries:[f]})}let l=(f,p)=>{let d=this.#I(f),h;for(let[_,g]of this.#y.entries()){if(s.has(_)){let E=g.relation,N,x;d[h]===null?p=p.filter(([S])=>{if(S[h]!==null&&(N=JSON.stringify([E.namespace,E.name,S[h]]))&&((x=e.get(N))||t.has(N)&&(x=e.get(N=t.get(N)))))return!0}):(N=JSON.stringify([E.namespace,E.name,d[h]]))&&(x=e.get(N))&&(p=p.filter(([S])=>x.type==="delete"?S[h]===null:z(x.newKeys,S[h])))}p=p.filter(([E])=>z(d[h],E[h])),h++}return p.length?[this.#g(p[0][0]),p[0][1]]:[]},m=await this.#T(u);return await this.#M(a,m,l)}async#D(){let e=await this.#T();return this.#o.diffing?await this.#M(this.#f,e):await this.#O(e,!0)}async#M(e,t,s=null){let r=new Set,n=()=>[...t.entries()].map(([o,u])=>[this.#I(o),u]),a=n();for(let[o,u]of e.entries()){if(t.has(o)){let m=t.get(o);t.delete(o),a=n();let f={type:"update",oldHash:o,newHash:o,logicalRecord:m};r.add(f);continue}if(s){let[m,f]=s(o,a);if(m){t.delete(m),a=n();let p={type:"update",oldHash:o,newHash:m,logicalRecord:f};r.add(p);continue}}let l={type:"delete",oldHash:o,logicalRecord:u};r.add(l)}for(let[o,u]of t.entries()){let l={type:"insert",newHash:o,logicalRecord:u};r.add(l)}return await this.#C(r)}async#C(e){if(!e?.size)return!1;let t=this.#l,s=new Map,r=new Map,n=new Map,a=new Set,o=t.hasLimitClause?await this.#i.evaluate(this.#s.limitClause().expr(),{},this.#a):0,u=async m=>{let f=await this.#k(m.logicalRecord);return{type:m.type,...m.type==="update"?{oldHash:m.oldHash,old:m.old}:{},newHash:m.newHash,new:f}};for(let m of e){if(m.type==="delete"){let p={type:m.type,oldHash:m.oldHash};this.#U(m.oldHash),s.set(m.oldHash,m),r.set(m.oldHash,p);continue}if(m.type==="update"&&m.newHash!==m.oldHash)n.set(m.oldHash,m.newHash);else if(m.type==="insert"&&o&&!t.hasOrderByClause&&this.#f.size===o){a.add(m);continue}let f=m.oldHash||m.newHash;this.#R(f,m.logicalRecord),s.set(f,m),r.set(f,await u(m))}n.size&&this.#B(n);let l=[];if(t.hasOrderByClause){let[m,f,p]=await this.#L(this.#f,!0);await this.#O(m);let d=[];if(o&&this.#f.size>=o){let g=f.slice(o);for(let[E,N]of g)this.#f.delete(E),d.push(E),s.get(E)?.type==="insert"?(s.delete(E),r.delete(E)):(s.set(E,{type:"delete",oldHash:E,old:N}),r.set(E,{type:"delete",oldHash:E}))}let h=p.map(g=>g[0]),_=f.map(g=>g[0]);for(let[g,E]of h.entries()){if(d.includes(E))continue;let N=_.indexOf(E),x=h[N];d.includes(x)&&(N=_.indexOf(x),x=h[N]),N!==g&&l.push([E,x])}}else for(let m of a){if(this.#f.size===o)break;this.#R(m.newHash,m.logicalRecord),s.set(m.newHash,m),r.set(m.newHash,await u(m))}return s.size&&this.emit("rawdiff",[...s.values()]),r.size&&this.emit("diff",[...r.values()]),l.length&&this.emit("swap",l),!0}async#O(e,t=!1){this.#f.clear();for(let[s,r]of e.entries())this.#R(s,r);t&&(this.emit("rawresult",new Map(this.#f)),this.emit("result",await this.currentRendering()))}async#L(e,t=!1){let s=Array.isArray(e)?e:[...e.entries()],r;this.#o.ssr?r=s.map(o=>({entry:o,keys:o[1].ord})):r=await Promise.all(s.map(async o=>{let u=await Promise.all(this.#N.map(l=>this.#i.evaluate(l.expr(),o[1],this.#a)));return{entry:o,keys:u}})),this.#i.applySorting(r,this.#N,this.#a);let n=r.map(o=>o.entry),a=Array.isArray(e)?n:new Map(n);return t?[a,n,s]:a}};var Qn=class{#e=new Set;#t;get size(){return this.#e.size}constructor(e){if(!(e instanceof Mt))throw new TypeError("driver must be an instance of AbstractSQLClient");this.#t=e}async query(...e){let[t,{callback:s,signal:r,...n}]=qe(...e);if(!(t instanceof y.BasicSelectStmt))throw new Error("Only SELECT statements are supported in live mode");if(!t.fromClause())throw new Error("Query has no FROM clause");let a=await this.createWindow(t,n),o=await a.currentRendering(),u=new Yn(o,()=>m.forEach(f=>f()),r),l=s||((f,p)=>u._apply(f,p)),m=["result","diff","swap"].map(f=>a.on(f,p=>l(f,p)));return u}async createWindow(e,t){let s=new Vn(this.#t,e,t),r=[...this.#e].sort((a,o)=>a.inheritanceDepth>o.inheritanceDepth?1:-1),n=[];for(let a of r){if(await s.inherit(a))break;n.unshift(a)}if(!s.parentWindow){await s.start();for(let a of n)if(await a.inherit(s))break}return this.#e.add(s),s.onClose(()=>{this.#e.delete(s),s.disconnect()}),s}};var Mt=class extends Rt{get dialect(){throw new Error("Not implemented")}#e;get realtimeClient(){return this.#e}constructor({capability:e={}}={}){super({capability:e}),this.#e=new Qn(this)}async parse(e,{alias:t=null,dynamicWhereMode:s=!1,...r}={}){if(!e)return;let n=f=>f.nodeName===y.BinaryExpr.NODE_NAME&&f.operator==="OR"||f instanceof y.BinaryExpr&&f.operator()==="OR"?{nodeName:y.RowConstructor.NODE_NAME,entries:[f]}:f;if(typeof e=="string"||typeof e=="object"&&typeof e.query=="string"){let f=await y.Script.parse(e.query||e,{dialect:r.dialect||this.dialect});if(f.length===1&&(f=f.entries()[0]),s){let p;if(f instanceof y.CompleteSelectStmt){if(t){let _=f.fromClause().entries()[0];p=(_.alias()||_.expr())?.value()}}else if(f instanceof y.UpdateStmt||f instanceof y.DeleteStmt){if(t){let _=f.tableExpr();p=(_.alias()||_.tableRef())?.value()}}else throw new Error("Dynamic where mode is only supported for SELECT, UPDATE, or DELETE statements.");let d=f.jsonfy(),h=d.where_clause?.expr;return _=>{if(_&&t&&p&&t!==p){let g=new te((E,N)=>{if(E instanceof y.ColumnRef1&&E.qualifier()?.identifiesAs(t)){let x=N();return{...x,qualifier:{...x.qualifier,value:p}}}return N()},null);_=_.jsonfy({},g)}return(!_||_===!0)&&(_={nodeName:y.BoolLiteral.NODE_NAME,value:"TRUE"}),h&&(_={nodeName:y.BinaryExpr.NODE_NAME,left:n(_),operator:"AND",right:n(h)}),d={...d,where_clause:{nodeName:y.WhereClause.NODE_NAME,expr:_}},y.Script.fromJSON({entries:[d]},{dialect:r.dialect,assert:!0}).entries()[0]}}return f}let a=f=>typeof f=="number"?{nodeName:y.NumberLiteral.NODE_NAME,value:f}:{nodeName:y.StringLiteral.NODE_NAME,value:f+""},o=e.name,u=e.namespace,l={nodeName:y.TableRef1.NODE_NAME,value:o,qualifier:u&&{nodeName:y.NamespaceRef.NODE_NAME,value:u}},m;switch(e.command||"select"){case"insert":let f=[].concat(e.payload);if(!(typeof f[0]=="object"&&f[0]))throw new Error("Invalid insert row format. Expected a non-null object.");let p=Object.keys(f[0]),d=p.map(E=>({nodeName:y.ColumnRef2.NODE_NAME,value:E}));m={nodeName:y.InsertStmt.NODE_NAME,table_ref:{...l,nodeName:y.TableRef2.NODE_NAME},pg_table_alias:t?{nodeName:y.Identifier.NODE_NAME,value:t}:void 0,column_list:{nodeName:y.ColumnsConstructor.NODE_NAME,entries:d},values_clause:{nodeName:y.ValuesConstructor.NODE_NAME,entries:[]}};for(let E of f){if(!(typeof E=="object"&&E))throw new Error("Invalid insert row format. Expected a non-null object.");let N=new Set(Object.keys(E));if(N.size!==p.length)throw new Error("Inconsistent column count across rows in insert payload");let x={nodeName:y.RowConstructor.NODE_NAME,entries:[]};for(let S of p){if(!N.has(S))throw new Error(`Missing column "${S}" in insert row`);x.entries.push(a(E[S]))}m.values_clause.entries.push(x)}break;case"update":let h=e.payload;if(Array.isArray(h))throw new Error("Batch update is not supported. Please provide a single payload object for update.");if(!(typeof h=="object"&&h))throw new Error("Invalid update payload format. Expected a non-null object.");m={nodeName:y.UpdateStmt.NODE_NAME,table_expr:{nodeName:y.TableAbstraction2.NODE_NAME,table_ref:l,alias:t?{nodeName:y.SelectItemAlias.NODE_NAME,value:t}:void 0},set_clause:{nodeName:y.SetClause.NODE_NAME,entries:[]}};let _=Object.keys(h);for(let E of _){let N={nodeName:y.AssignmentExpr.NODE_NAME,left:r.dialect==="mysql"?{nodeName:y.ColumnRef1.NODE_NAME,value:E}:{nodeName:y.ColumnRef2.NODE_NAME,value:E},operator:"=",right:a(h[E])};m.set_clause.entries.push(N)}break;case"delete":m={nodeName:y.DeleteStmt.NODE_NAME,table_expr:{nodeName:y.TableAbstraction2.NODE_NAME,table_ref:l,alias:t?{nodeName:y.SelectItemAlias.NODE_NAME,value:t}:void 0}};break;case"select":let g=(e.columns||["*"]).map(E=>({nodeName:y.SelectItem.NODE_NAME,expr:E==="*"?{nodeName:y.ColumnRef0.NODE_NAME,value:E}:{nodeName:y.ColumnRef1.NODE_NAME,value:E}}));m={nodeName:y.CompleteSelectStmt.NODE_NAME,select_list:{nodeName:y.SelectList.NODE_NAME,entries:g},from_clause:{nodeName:y.FromClause.NODE_NAME,entries:[{nodeName:y.FromItem.NODE_NAME,expr:l,alias:t?{nodeName:y.FromItemAlias.NODE_NAME,value:t}:void 0}]}};break;default:throw new Error("Invalid query input")}if(e.command!=="insert"){let f;if(typeof e.filters=="object"&&e.filters&&(f=Object.keys(e.filters).reduce((p,d)=>{let h={nodeName:y.ColumnRef1.NODE_NAME,value:d},_=a(e.filters[d]),g={nodeName:y.BinaryExpr.NODE_NAME,left:h,operator:"=",right:_};return p?{nodeName:y.BinaryExpr.NODE_NAME,left:p,operator:"AND",right:g}:g},null)),s)return p=>((!p||p===!0)&&(p={nodeName:y.BoolLiteral.NODE_NAME,value:"TRUE"}),f&&(p={nodeName:y.BinaryExpr.NODE_NAME,left:n(p),operator:"AND",right:f}),m={...m,where_clause:{nodeName:y.WhereClause.NODE_NAME,expr:p}},y.Script.fromJSON({entries:[m]},{dialect:r.dialect,assert:!0}).entries()[0]);f&&(m={...m,where_clause:{nodeName:y.WhereClause.NODE_NAME,expr:f}})}return y.Script.fromJSON({entries:[m]},{dialect:r.dialect,assert:!0}).entries()[0]}async resolve(e,t={}){if(!(e instanceof w))e=await this.parse(e,t);else if(!(e instanceof y.Script)&&!(e instanceof We))throw new TypeError("query must be a string or an instance of Script | AbstractStmt");if(e instanceof y.Script&&e.length===1&&(e=e.entries()[0]),e instanceof y.DDLStmt&&!e.returningClause?.()||e.originSchemas?.()?.length)return e;let s={},r=!1;return e.walkTree((n,a,o)=>{if(n instanceof y.DDLStmt&&!n.returningClause?.())return;if(n instanceof y.CTEItem){let m=n.alias()?._get("delim")?n.alias().value():n.alias()?.value().toLowerCase();return o.set(m,!0),n}if((!(n instanceof y.TableRef2)||n.parentNode instanceof y.ColumnIdent)&&(!(n instanceof y.TableRef1)||n.parentNode instanceof y.ColumnRef1))return n;let u=n.qualifier()?._get("delim")?n.qualifier().value():n.qualifier()?.value().toLowerCase()||"*",l=n._get("delim")?n.value():n.value().toLowerCase();u==="*"&&o.has(l)||(u in s||(s[u]=[]),s[u].includes(l)||(s[u].push(l),r=!0))},!0),r&&await this.schemaInference.provide(s),e.deSugar(!0,{},null,this.schemaInference)}async query(...e){let[t,s]=qe(...e),r=await this.resolve(t,s);if(s.live&&r.fromClause?.())return await this.#e.query(r,s);let n=await this._query(r,s);return new kt({rows:n.rows,rowCount:n.rowCount})}async cursor(...e){let[t,s]=qe(...e),r=await this.resolve(t,s);return await this._cursor(r,s)}async showCreate(e,t=!1){return await this._showCreate(e,t)}};var Re=class extends Rt{async parse(e,{alias:t=null,dynamicWhereMode:s=!1,...r}={}){}async resolve(e,t={}){}async request(...e){let[t,s]=qe(...e),r=await this.parse(t,s);return await this._request(r,s)}async stream(...e){let[t,s]=qe(...e),r=await this.parse(t,s);return await this._stream(r,s)}async showCreate(e,t=!1){return await this._showCreate(e,t)}};var ve=class extends Error{#e;get existing(){return this.#e}constructor(e,t){super(e),this.#e=t}};var Xn=class extends Ne{#e;#t;#r;#n;#i;#a;#s=[];#u=[];#l=new Map;#o=new Map;#c=new Map;get name(){return this.#e}get schema(){return this.#t}get parentNode(){return this.#r}get materialized(){return this.#n}get querySpec(){return this.#i}get options(){return this.#a}constructor(e,t,{materialized:s=!1,querySpec:r=null,...n}={}){super(),this.#e=e.name().value(),this.#t=e,this.#r=t,this.#n=s,this.#i=r,this.#a=n,this.#s=e.columns();let o=(this.#t.pkConstraint(!0)?.columns()||[]).map(u=>this.#t.get(u));this.#u=o.map(u=>u.name().value()),this.on("changefeed",u=>this.#r?.emit("changefeed",u))}get size(){return this.#o.size}async*[Symbol.asyncIterator](){for(let[,e]of this.#o.entries())yield e}async*entries(){for(let[e,t]of this.#o.entries())yield[e,t]}async _destroy(){this.#r=null}async#d(e){this.#c.has(e)||this.#c.set(e,1);let t=this.#c.get(e);return this.#c.set(e,t+1),t}async createKey(e,t,s=[]){if(this.#l.has(e))throw new Error(`[${this.#e}] Key ${e} already exists`);this.#l.set(e,{type:t,columns:s,entries:new Map})}async showKeys(e=null){if(e){if(!this.#l.has(e))throw new Error(`[${this.#e}] Key ${e} does not exist`);return[...this.#l.get(e).entries.keys()]}return[...this.#o.keys()]}async#m(e,t=!1){if(!t&&typeof e=="string")return e;let s=[];if(t)for(let n of this.#s){let a=n.name().value(),o=n.identityConstraint()||n.autoIncrementConstraint(),u=this.#u.includes(a),l=e[a];if(!l){if(o)l=await this.#d(a),e={...e,[a]:l};else if(u)throw new Error(`[${this.#e}] Missing value for primary key field ${a}`)}u&&s.push(l)}else if(this.#u.length)for(let n of this.#u){let a=e[n];if(!a)throw new Error(`[${this.#e}] Missing value for primary key field ${n}`);s.push(a)}let r;return s.length?r=JSON.stringify(s):r=JSON.stringify(Object.values(e)),[r,e]}async#h(e,t=null){if(t){if(!this.#l.has(t))throw new Error(`[${this.#e}] Key ${t} does not exist`);return this.#l.get(t).entries.get(e)}return e}async insert(e,{keyName:t=null,newKey:s=null}={},{transaction:r=null}={}){if(t&&s){let o=await this.#h(s,t);if(o){let u=this.#o.get(o);throw new ve(`[${this.#e}] Duplicate entry for key ${s} on index ${t}`,u)}}let n;if([n,e]=await this.#m(e,!0),this.#o.has(n))if(this.#u.length){let o=this.#o.get(n);throw new ve(`[${this.#e}] Duplicate entry for key ${n}`,o)}else{let o=n,u=0;for(;this.#o.has(n=`${o}${u}`);)u++}this.#o.set(n,e),t&&s&&this.#l.get(t).entries.set(s,n);let a={...e};return r?.emit("changefeed",{type:"insert",relation:{namespace:this.#r.name,name:this.#e,keyColumns:[...this.#u]},new:a}),r?Object.defineProperty(a,"XMAX",{value:0}):a}async update(e,t,{keyName:s=null,newKey:r=null}={},{transaction:n=null}={}){let a;s&&typeof e=="string"?a=await this.#h(e,s):typeof e=="object"&&e?[a]=await this.#m(e,!1):a=String(e);let o;[o,t]=await this.#m(t,!1);let u=this.#o.get(a);if(!u)throw new Error(`[${this.#e}] Record not found for ${key||o}${s?` of key ${s}`:""}`);if(this.#o.set(a,t),o!==a){let m=[...this.#o.entries()].map(([f,p])=>[f===a?o:f,p]);this.#o=new Map(m)}s&&(r&&this.#l.get(s).entries.delete(e),(r||o!==a)&&this.#l.get(s).entries.set(r||e,o));let l={...t};return n?.emit("changefeed",{type:"update",relation:{namespace:this.#r.name,name:this.#e,keyColumns:[...this.#u]},old:u,new:l}),n?Object.defineProperty(l,"XMAX",{value:n.txId}):l}async delete(e,{keyName:t=null}={},{transaction:s=null}={}){let r;t&&typeof e=="string"?r=await this.#h(e,t):typeof e=="object"&&e?[r]=await this.#m(e,!1):r=String(e);let n=this.#o.get(r);if(!n)throw new Error(`[${this.#e}] Record not found for ${key}${t?` of key ${t}`:""}`);this.#o.delete(r);let a={...n};return s?.emit("changefeed",{type:"delete",relation:{namespace:this.#r.name,name:this.#e,keyColumns:[...this.#u]},old:n}),s?Object.defineProperty(a,"XMAX",{value:s.txId}):a}async get(e,{keyName:t=null}={}){let s;return t&&typeof e=="string"?s=await this.#h(e,t):typeof e=="object"&&e?[s]=await this.#m(e,!1):s=String(e),this.#o.get(s)}async truncate(){this.#o.clear(),this.#l.clear()}};var Zn=class extends Ne{#e;#t;#r;#n;#i;#a;#s=new Map;get name(){return this.#e}get parentNode(){return this.#t}get type(){return this.#r}get mirrored(){return this.#n}get origin(){return this.#i}get options(){return this.#a}constructor(e,t,{type:s=null,mirrored:r=!1,origin:n=null,...a}={}){super(),this.#e=e,this.#t=t,this.#r=s,this.#n=r,this.#i=n,this.#a=a,this.on("changefeed",o=>this.#t?.emit("changefeed",o))}get size(){return this.#s.size}async _destroy(){this.#t=null}async tableNames(e={}){let t=[...this.#s.keys()];return"materialized"in e&&(t=t.filter(s=>{let r=this.#s.get(s);return!!e.materialized==!!r.materialized})),t}async createTable(e,{ifNotExists:t=!1,primaryKey:s="id",autoIncr:r=!0,dialect:n="postgres",...a}={}){if(typeof e=="string"){if(e={name:{value:e},entries:[]},s){let l={nodeName:y.ColumnSchema.NODE_NAME,name:{value:s},data_type:{value:"INT"},entries:[{nodeName:y.ColumnPKConstraint.NODE_NAME,value:"KEY"}]};r&&(n==="mysql"?l.entries.push({nodeName:y.MyColumnAutoIncrementModifier.NODE_NAME,value:"AUTO_INCREMENT"}):l.entries.push({nodeName:y.ColumnIdentityConstraint.NODE_NAME,by_default_kw:!0,as_identity_kw:!0})),e.entries.push(l)}e=y.TableSchema.fromJSON(e,{dialect:n})}else{if(!(e instanceof y.TableSchema))throw new Error("tableSchema must be an instance of TableSchema");if(e=e.clone(),e.name().qualifier?.()&&e.name().qualifier().value()!==this.#e)throw new Error(`Cannot create table ${e.name()} at namespace ${this.#e}`)}let o=e.name().value();if(this.#s.has(o)){if(t)return this.#s.get(o);throw new Error(`Table ${o} already exists`)}let u=new Xn(e,this,a);return this.#s.set(o,u),u}async dropTable(e,{ifExists:t=!1,cascade:s=!1}={}){let r=this.#s.get(e);if(!r){if(t)return null;throw new Error(`Table ${e} does not exist`)}if(r.size&&!s)throw new Error(`Table ${e} is not empty.`);return await r._destroy(),this.#s.delete(e),r}async getTable(e){let t=this.#s.get(e);if(!t)throw new Error(`Table ${e} does not exist`);return t}};var ea=class extends Ne{#e;#t;#r=new Map;#n;get defaultNamespace(){return this.#e}get options(){return this.#t}constructor({defaultNamespace:e="public",...t}={}){super(),this.#e=e,this.#t=t,e&&(this.#n=this.createNamespace(e,{ifNotExists:!0}))}async startTransaction(e="~tx"){let t=new Map,s=`${e}:${(0|Math.random()*9e6).toString(36)}`;return{txId:s,emit:(r,n)=>{t.has(r)||t.set(r,[]),t.get(r).push({...n,txId:s})},done:async()=>{for(let[r,n]of t.entries())this.emit(r,n);t.clear()}}}async namespaceNames(e={}){await this.#n;let t=[...this.#r.keys()];return"mirrored"in e&&(t=t.filter(s=>{let r=this.#r.get(s);return!!e.mirrored==!!r.mirrored})),t}async createNamespace(e,{ifNotExists:t=!1,...s}={}){if(await this.#n,this.#r.has(e)){if(t)return this.#r.get(e);throw new ve(`Schema/namespace ${e} already exists`)}let r=new Zn(e,this,s);return this.#r.set(e,r),r}async dropNamespace(e,{ifExists:t=!1,cascade:s=!1}={}){await this.#n;let r=this.#r.get(e);if(!r){if(t)return null;throw new Error(`Schema/namespace ${e} does not exist`)}if(r.size&&!s)throw new Error(`Schema/namespace ${e} is not empty.`);return await r._destroy(),this.#r.delete(e),r}async getNamespace(e){await this.#n;let t=this.#r.get(e);if(!t)throw new Error(`Schema/namespace ${e} does not exist`);return t}async showMirrors(e={}){let s=(await this.namespaceNames({mirrored:!0})).map(async r=>{let n=await this.getNamespace(r),o=(await n.tableNames(e)).map(async u=>{let l=await n.getTable(u);return[u,{materialized:l.materialized,querySpec:l.querySpec}]});return[r,{type:n.type,origin:n.origin,tables:new Map(await Promise.all(o))}]});return new Map(await Promise.all(s))}};var ti=Symbol.for("tbl_placeholder"),ta=Symbol.for("grouping_meta"),Ma=Symbol.for("window_meta"),ra=class extends Ne{#e;#t;#r;constructor(e,{dialect:t="postgres",...s}={}){super(),this.#e=e,this.#r={dialect:t,...s};let r=this;this.#t=new Dt(async function*(n,a,o){let u,l;if(n.isCorrelated()||!(l=o.cteRegistry?.get(u=n.stringify()))){let m={...o,lateralCtx:{...o.lateralCtx||{},...a},depth:o.depth+1};if(l=await r.#n(n.expr(),m),o.cteRegistry&&u){let f=l,p=[];o.cteRegistry.set(u,p),l=async function*(){for await(let d of f)p.push(d),yield d}()}}yield*l},this.#r)}async query(e,t={}){let s={options:{...this.#r,...t},transaction:await this.#e.startTransaction(),lateralCtx:null,cteRegistry:new Map,depth:0},r=await this.#n(e,s);if(await s.transaction.done(),r&&typeof r?.[Symbol.asyncIterator]=="function"&&t.bufferResultRows!==!1){let n=[];for await(let a of r)n.push(a);return{rows:n}}return typeof r=="number"&&t.bufferResultRows!==!1?{rowCount:r}:r}async#n(e,t){let s;for(let r of e instanceof y.Script&&e||[e])switch(r.NODE_NAME){case"CREATE_SCHEMA_STMT":s=await this.#i(r,t);break;case"ALTER_SCHEMA_STMT":s=await this.#a(r,t);break;case"DROP_SCHEMA_STMT":s=await this.#s(r,t);break;case"CREATE_TABLE_STMT":s=await this.#u(r,t);break;case"ALTER_TABLE_STMT":s=await this.#l(r,t);break;case"DROP_TABLE_STMT":s=await this.#o(r,t);break;case"CTE":s=await this.#c(r,t);break;case"INSERT_STMT":s=await this.#d(r,t);break;case"UPDATE_STMT":s=await this.#m(r,t);break;case"DELETE_STMT":s=await this.#h(r,t);break;case"TABLE_STMT":s=await this.#E(r,t);break;case"BASIC_SELECT_STMT":case"COMPLETE_SELECT_STMT":s=await this.#x(r,t);break;case"COMPOSITE_SELECT_STMT":s=await this.#b(r,t);break;default:throw new Error(`Unknown statement type: ${r.NODE_NAME}`)}return s}async#i(e,t){let s=e.name().value();if(!s)throw new Error("Cannot create a namespace with an empty name");let r={ifNotExists:!!e.ifNotExists()};if(await this.#e.createNamespace(s,r,t)&&e.pgEntries()?.length){if(ifNotExists)throw new Error("CREATE SCHEMA ... IF NOT EXISTS ... with entries is not supported");let a={..._queryCtx,nsName:s};for(let o of e.pgEntries())await this.#n(o,a)}return!0}async#a(e,t){throw new Error("ALTER SCHEMA is not supported yet in the in-memory StorageEngine")}async#s(e,t){let s=e.myName()?[e.myName().value()]:e.pgNames().map(a=>a.value()),r={ifExists:!!e.ifExists(),cascade:e.pgCascadeRule()==="CASCADE"},n;for(let a of s)n=!!await this.#e.dropNamespace(a,r,t);return n}async#u(e,t){if(e.temporaryKW())throw new Error("TEMPORARY tables are not supported yet in the in-memory StorageEngine");let s=e.argument(),r=s.name().qualifier()?.value()||t.nsName||this.#e.defaultNamespace;if(t.nsName&&r!==t.nsName)throw new Error(`Cannot create table ${s.name()} in namespace ${t.nsName} as it is qualified to namespace ${r}`);let n=await this.#e.getNamespace(r),a={ifNotExists:!!e.ifNotExists()};return!!await n.createTable(s,a,t)}async#l(e,t){throw new Error("ALTER TABLE is not supported yet in the in-memory StorageEngine")}async#o(e,t){if(e.myTemporaryKW())throw new Error("MySQL TEMPORARY tables are not supported yet in the in-memory StorageEngine");let s=e.names().map(a=>{let o=a.qualifier()?.value()||t.nsName||this.#e.defaultNamespace;return[a.value(),o]}),r={ifExists:!!e.ifExists(),cascade:e.cascadeRule()==="CASCADE"},n;for(let[a,o]of s)n=!!await(await this.#e.getNamespace(o)).dropTable(a,r,t);return n}async#c(e,t){let s=new Map(t.cteRegistry||[]);t={...t,cteRegistry:s};for(let r of e.declarations()){let n=r.alias().value();if(s?.has(n))throw new Error(`CTE name ${n} already exists in the current context`);let a=r.expr(),o=await this.#n(a,t);s.set(n,o)}return await this.#n(e.body(),t)}async#d(e,t){let s={};if(!Array.isArray(s.originSchemas=e.originSchemas()))throw new Error("Expected a pre-resolved query object with originSchemas() returning an array");let r=e.tableRef().qualifier()?.value()||this.#e.defaultNamespace,n=await this.#e.getNamespace(r),a=e.tableRef().value(),o=e.pgTableAlias()?.value()||a,u=await n.getTable(a),l=s.originSchemas[0],m=Object.fromEntries(l.columns().map(N=>[N.name().value(),N])),f=e.columnList()?.entries().map(N=>N.value())||Object.keys(m),p=Object.create(null);for(let[N,x]of Object.entries(m))p[N]=null,(s.cons=x.defaultConstraint())&&(p[N]=await this.#t.evaluate(s.cons.expr()));let d=[];if(s.valuesClause=e.valuesClause())for(let N of s.valuesClause){let x={...p},S={[o]:x};for(let[A,v]of N.entries().entries()){let b=f[A],O=m[b];if(v instanceof y.DefaultLiteral){let R=O.defaultConstraint();R&&(v=R.expr())}let T=await this.#t.evaluate(v,S,t);this.#p(x,O,T)}d.push(x)}else if((s.selectClause=e.selectClause())||(s.myTableClause=e.myTableClause())){let N={...t,depth:t.depth+1},x=s.myTableClause?this.#E(s.myTableClause,N):await this.#n(s.selectClause,N);for await(let S of x){let A={...p};for(let[v,b]of Object.values(S).entries()){let O=f[v],T=m[O];this.#p(A,T,b)}d.push(A)}}else if(e.pgDefaultValuesClause()){let N={...p};d.push(N)}else if(s.mySetClause=e.mySetClause()){let N=await this.#y({[o]:p},s.mySetClause,null,t);d.push(N[o])}let h=0,_=[],g=e.conflictHandlingClause(),E=e.returningClause();for(let N of d){let x;try{x=await u.insert(N,{},t)}catch(S){if(S instanceof ve&&g?.length)if(g.whereClause?.()&&!await this.evaluateWhereClause(g.whereClause(),[{[o]:S.existing}],t))x=null;else{let A=await this.#y({[o]:S.existing,EXCLUDED:N},g,s.originSchemas,t);x=await u.update(S.existing,A[o],{},t)}else if(S instanceof ve&&g?.doNothingKW?.())x=null;else throw S}if(E){if(x){let S=Object.create(null),A={[o]:x};for(let v of E){let{alias:b,value:O}=await this.#t.evaluate(v,A,t);S[b]=O}_.push(S)}}else h++}return E?async function*(){yield*_}():h}async#m(e,t){let s={};if(!Array.isArray(s.originSchemas=e.originSchemas()))throw new Error("Expected a pre-resolved query object with originSchemas() returning an array");let r,n,a;if(s.myUpdateList=e.myUpdateList())r=s.myUpdateList,n=e.joinClauses()||[],a=r.concat(n).map(p=>{let d=p.expr?.()||p.tableRef(),h=d.value(),_=p.alias()?.value()||h,g=d.qualifier()?.value()||this.#e.defaultNamespace;return[_,h,g]});else{let p=e.tableExpr();r=[p],n=(e.pgFromClause()?.entries()||[]).concat(e.joinClauses()||[]);let d=p.tableRef().qualifier()?.value()||this.#e.defaultNamespace,h=p.tableRef().value();a=[[p.alias()?.value()||h,h,d]]}let o=await this.evaluateFromItems(r,n,s.originSchemas,t);(s.whereClause=e.whereClause())&&(o=this.evaluateWhereClause(s.whereClause,o,t));let u=0,l=[],m=e.returningClause(),f=e.setClause();for await(let p of o){let d=await this.#y(p,f,s.originSchemas,t);for(let[h,_,g]of a){if(d[h]===p[h])continue;let N=await(await this.#e.getNamespace(g)).getTable(_);d[h]=await N.update(p[h],d[h],{},t)}if(m){let h=Object.create(null);for(let _ of m){let{alias:g,value:E}=await this.#t.evaluate(_,d,t);h[g]=E}l.push(h)}else u++}return m?async function*(){yield*l}():u}async#h(e,t){let s={};if(!Array.isArray(s.originSchemas=e.originSchemas()))throw new Error("Expected a pre-resolved query object with originSchemas() returning an array");let r,n,a;if(s.myDeleteList=e.myDeleteList()){r=(e.myFromClause()||e.usingClause())?.entries()||[],n=e.joinClauses()||[];let f=[...r,...n];a=s.myDeleteList.map(p=>{let d=f.find(E=>(E.alias()||E.expr()).identifiesAs(p)),h=d.expr(),_=h.value?.();if(!_)throw new Error(`Cannot delete from ${p}; ${d} isn't a table reference.`);let g=h.qualifier()?.value()||this.#e.defaultNamespace;return[p.value(),_,g]})}else{let f=e.tableExpr();r=[f],n=(e.pgUsingClause()?.entries()||[]).concat(e.joinClauses()||[]);let p=f.tableRef(),d=p.value(),h=f.alias()?.value()||d,_=p.qualifier()?.value()||this.#e.defaultNamespace;a=[[h,d,_]]}let o=await this.evaluateFromItems(r,n,s.originSchemas,t);(s.whereClause=e.whereClause())&&(o=this.evaluateWhereClause(s.whereClause,o,t));let u=0,l=[],m=e.returningClause();for await(let f of o){for(let[p,d,h]of a){let g=await(await this.#e.getNamespace(h)).getTable(d);f[p]=await g.delete(f[p],{},t)}if(m){let p=Object.create(null);for(let d of m){let{alias:h,value:_}=await this.#t.evaluate(d,f,t);p[h]=_}l.push(p)}else u++}return m?async function*(){yield*l}():u}async#y(e,t,s,r){let n={...e},a=Object.keys(e)[0],o=async(u,l,m)=>{if(m instanceof y.DefaultLiteral){let d=s.find(h=>h.identifiesAs(u)).columns().find(h=>h.identifiesAs(l)).defaultConstraint();d&&(m=d.expr())}let f=await this.#t.evaluate(m,e,r);n[u]={...n[u],[l]:f}};for(let u of t){let l=u.left(),m=u.right();if(l instanceof y.ColumnsConstructor){if(!(m instanceof y.RowConstructor))throw new Error(`Expected a RHS of type ROW_CONSTRUCTOR for a LHS of type COLUMNS_CONSTRUCTOR, but got ${m.NODE_NAME}`);for(let[f,p]of l.entries().entries()){let d=p.value(),h=m.entries()[f];if(!h)throw new Error(`Mismatched number of entries in SET clause: LHS has ${l.entries().length} but RHS has ${m.entries().length}`);await o(a,d,h)}}else{let f=l.value(),p=l.qualifier?.()?.value()||a;await o(p,f,m)}}return n}#p(e,t,s,r=!1){let n=t.name().value();return e[n]=s,e;return!t.identityConstraint()&&!t.autoIncrementConstraint()&&(_cons=t.nullConstraint())&&_cons.value()==="NOT"&&requireds.add(n),inputValue}async*#E(e,t){let s=e.tableRef(),r=s.value(),n=s.qualifier()?.value()||this.#e.defaultNamespace;yield*await(await this.#e.getNamespace(n)).getTable(r)}async*#x(e,t){let s={};if(!Array.isArray(s.originSchemas=e.originSchemas()))throw new Error("Expected a pre-resolved query object with originSchemas() returning an array");let r=await this.evaluateFromClause(e.fromClause(),e.joinClauses(),s.originSchemas,t);(s.whereClause=e.whereClause())&&(r=this.evaluateWhereClause(s.whereClause,r,t));let n=[],a=[];e.walkTree(d=>{if(!(d instanceof y.DerivedQuery||d instanceof y.ScalarSubquery))if(d instanceof y.AggrCallExpr)d.overClause()?a.push(d):n.push(d);else return d});let o=e.groupByClause(),u=e.havingClause(),l=e.selectList();if(o?.length){let d=this.#t.resolveScopedRefsInClause(o,l);r=this.evaluateGroupByClause(d,u,r,t)}else n.length&&(r=this.evaluateGlobalGroup(r));if(a.length){let d=new Map(e.windowClause()?.entries().map(h=>[h.name().value(),h.spec()])||[]);r=this.evaluateWindowing(a,d,r,t)}let m=e.orderByClause?.();if(m){let d=this.#t.resolveScopedRefsInClause(m,l);r=this.evaluateOrderByClause(d,r,t)}r=this.evaluateSelectList(l,r,t);let f=e.limitClause?.(),p=e.offsetClause?.();(f||p)&&(r=this.evaluateLimitClause(f,p,r,t)),yield*r}async evaluateFromClause(e,t,s,r){return e?.length?await this.evaluateFromItems(e.entries(),t,s,r):async function*(){yield{...r.lateralCtx||{}}}()}async evaluateFromItems(e,t,s,r){let n=[...e,...t||[]],a=d=>s.find(h=>d?h.identifiesAs(d):!h.name?.()),o=n[0],u=o.alias?.()?.value(),[l,m]=this.#S(o.expr?.(),r.options),f;if(m){let d=await l.client.parse(m.querySpec);f=l.client instanceof Re?await l.client.stream(d):await l.client.cursor(d)}let p=this.evaluateFromItem(o,a(u),{...r,remoteStream:f});for(let d=1;d<n.length;d++){let h=n[d-1].alias?.()?.value(),_=n[d],g=_.alias?.()?.value(),E=a(g),N=_.joinType?.()||(e.includes(_)?"CROSS":"INNER"),x=!!_.lateralKW?.(),S=_.conditionClause?.();if(!S&&_.naturalKW?.()){let O=a(h),T=O.columns?.()||O.entries(),k=(E.columns?.()||E.entries()).reduce((J,U)=>T.find(P=>P.identifiesAs(U))?J.concat({value:U.name().value(),delim:U._get("delim")}):J,[]);k.length&&(S=y.OnClause.fromJSON({expr:this.#_(k,h,g)},{assert:!0}))}let A,[v,b]=this.#S(_.expr?.(),r.options);if(b){let O;[p,O,S]=await this.#f(p,v,b,S,h,g,r),A=async(T,R)=>{let k=await O(T,R);return this.evaluateFromItem(_,E,{...r,lateralCtx:null,remoteStream:k})}}else if(x)A=O=>this.evaluateFromItem(_,E,{...r,lateralCtx:O});else{let O=this.evaluateFromItem(_,E,{...r,lateralCtx:null});A=this.#N(O)}p=this.evaluateJoin(p,{alias:g,isLateral:x},A,N,S,s,r)}return p}async#f(e,t,s,r,n,a,o){let u,l=s.querySpec.joinStrategy||{memoization:!1,pushdownSize:0};if(r&&l.pushdownSize){let m;if(r instanceof y.UsingClause){let p=[].concat(r.column()||r.columns());m=this.#_(p,n,a)}else m=r.expr();let f=await t.client.parse(s.querySpec,{alias:a,dynamicWhereMode:!0});if(Number(l.pushdownSize)>1){let p=l.pushdownSize,d=this.#N(e),h=d();e=d();let _=0,g=async()=>{let x,S=!1;for await(let A of h){_++;let v=await this.#t.evaluate(m,{...A,[a]:ti},o);if(v instanceof w?x=x?y.BinaryExpr.fromJSON({nodeName:y.BinaryExpr.NODE_NAME,left:x,operator:"OR",right:v},{assert:!0}):v:v&&(S=!0),_>1&&_%p===0)break}if(!(!x&&!S))return f(x)},E=await g(),N;u=async(x,S)=>((S===0||S>_)&&(S>_&&(E=await g()),E?N=t.client instanceof Re?await t.client.stream(E):await t.client.cursor(E):N=async function*(){}()),N)}else u=async p=>{let d=await this.#t.evaluate(m,{...p,[a]:ti},o);if(d instanceof w||(d=!!d)){let h=f(d);return t.client instanceof Re?await t.client.stream(h):await t.client.cursor(h)}return async function*(){}()},r=null}else{let m=await t.client.parse(s.querySpec);if(l.memoization){let f=t.client instanceof Re?await t.client.stream(m):await t.client.cursor(m);u=this.#N(f)}else u=async()=>t.client instanceof Re?await t.client.stream(m):await t.client.cursor(m)}return[e,u,r]}#S(e,t){if(!(e instanceof y.TableRef1)||e.resolution()!=="default")return[];if(!t.effectiveMirrorsSpec)return[];let s=e.qualifier()?.value()||this.#e.defaultNamespace,r=e.value(),n=t.effectiveMirrorsSpec.get(s),a=n?.tables.get(r);return[n,a]}#N(e,t=null){let s=[];return async function*(){if(s.length)yield*s;else for await(let r of e)t&&(r=t(r)),s.push(r),yield r}}#_(e,t,s){return e.reduce((r,n)=>{let a=n.jsonfy?.()||n,o={...a,nodeName:y.ColumnRef1.NODE_NAME,qualifier:{nodeName:y.TableRef1.NODE_NAME,value:t}},u={...a,nodeName:y.ColumnRef1.NODE_NAME,qualifier:{nodeName:y.TableRef1.NODE_NAME,value:s}},l=y.BinaryExpr.fromJSON({left:o,operator:"=",right:u});return r&&(l=y.BinaryExpr.fromJSON({left:r,operator:"AND",right:l})),l},null)}async*evaluateFromItem(e,t,s){if(e instanceof y.TableAbstraction2||e instanceof y.TableAbstraction1){let f=e.tableRef(),p=e.alias(),d=f.value(),h=p?.value()||d,_=f.qualifier()?.value()||this.#e.defaultNamespace,E=await(await this.#e.getNamespace(_)).getTable(d);for await(let N of E)yield{[h]:N};return}let r=e.expr(),n=e.alias()?.value()||"",a=t.length;if(r instanceof y.DerivedQuery){for await(let f of await this.#n(r.expr(),s)){let p=Object.entries(f),d=p.length;if(d!==a)throw new Error(`Expected number of columns from DerivedQuery function to be ${a} but got ${d}`);let h=Object.create(null);for(let[_,g]of p)this.#p(h,t._get("entries",_),g);yield{[n]:h}}return}if(r instanceof y.ValuesTableLiteral){for(let f of r.entries()){let p=f.length;if(p!==a)throw new Error(`Expected number of columns in ROW_CONSTRUCTOR to be ${a} but got ${p}`);let d=Object.create(null);for(let[h,_]of f.entries().entries())this.#p(d,t.entries()[h],await this.#t.evaluate(_,s.lateralCtx,s));yield{[n]:d}}return}let o=async f=>{let p=await this.#t.evaluate(f,s.lateralCtx,s),d;if(Symbol.asyncIterator in p)d=p[Symbol.asyncIterator]();else if(Symbol.iterator in p)d=async function*(){yield*p}();else throw new Error(`Function ${f.name()} did not return an iterable value or a promise of such thereof.`);return d},u=async(f,p)=>await o(f);if(r instanceof y.SRFExpr1){let f=r.callExpr(),p=r.qualif(),d=p.alias?.()?.value()||"";for await(let h of await u(f,p.columnDefs())){if(!Array.isArray(h)&&!(h&&typeof h=="object"))throw new Error(`Function ${f.name()} did not return an object or array value or a promise of such thereof.`);let _=Object.values(h),g=_.length;if(g!==a)throw new Error(`Expected number of columns from SRF function to be ${a} but got ${g}`);let E=Object.create(null);for(let N=0;N<g;N++)this.#p(E,t.entries()[N],_[N]);yield{[d]:E}}return}if(r instanceof y.SRFExpr2){let f=r.callExpr(),p=r.withOrdinality(),d=0;for await(let h of await o(f)){if(!Array.isArray(h)&&!(h&&typeof h=="object"))throw new Error(`Function ${f.name()} did not return an object or array value or a promise of such thereof.`);let _=Object.values(h);p&&_.push(++d);let g=_.length;if(g!==a)throw new Error(`Expected number of columns from SRF function to be ${a} but got ${g}`);let E=Object.create(null);for(let N=0;N<g;N++)this.#p(E,t.entries()[N],_[N]);yield{[n]:E}}return}if(r instanceof y.SRFExpr4){let f=r.withOrdinality(),p=[];for(let _ of r.entries()){if(!(_ instanceof y.SRFExpr3))throw new Error(`Expected SRFExpr3 but got ${_?.NODE_NAME}`);let g=_.callExpr(),E=_.qualif(),N=await u(g,E?.columnDefs());p.push({stream:N,callExpr:g})}let d=0,h={};for(;;){let _=0,g=!0,E=Object.create(null);for(let N=0;N<p.length;N++){let{stream:x,callExpr:S}=p[N],A=await x.next();if(A.done)for(let v=0;v<(h[N]||1);v++)this.#p(E,t.entries()[_],null,!0),_++;else{g=!1;let v=A.value;if(!Array.isArray(v)&&!(v&&typeof v=="object"))throw new Error(`Function ${S.name()} did not return an object or array value or a promise of such thereof.`);let b=Object.values(v);if(h[N]){if(h[N]!==b.length)throw new Error(`Inconsistent number of columns from SRF function: expected ${h[N]} but got ${b.length}`)}else if(h[N]=b.length,h[N]+_+(f?1:0)>a)throw new Error(`Number of columns from SRF function(s) (${h[N]+_+(f?1:0)}) exceeds expected: expected ${a}`);for(let O of b)this.#p(E,t.entries()[_],O),_++}}if(g)break;f&&(this.#p(E,t.entries()[_],d+1),_++),yield{[n]:E},d++}return}let l=r.value(),m;if(s.remoteStream)m=s.remoteStream;else if(r.resolution()==="cte"){if(m=s.cteRegistry?.get(l),!m)throw new Error(`Implied CTE ${l} does not exist in the current context`);if(typeof m[Symbol.asyncIterator]!="function")throw new Error(`Implied CTE ${l} does not return a record set`)}else{let f=r.qualifier()?.value()||this.#e.defaultNamespace;m=await(await this.#e.getNamespace(f)).getTable(l)}for await(let f of m){let p=Object.entries(f),d=p.length;if(d!==a)throw new Error(`Expected number of columns from ${n} to be ${a} but got ${d}`);let h=Object.create(null);for(let[_,g]of p)this.#p(h,t._get("entries",_),g);yield{...s.lateralCtx||{},[n]:h}}}async*evaluateJoin(e,{alias:t,isLateral:s},r,n,a,o,u){let l=h=>o.find(_=>_.identifiesAs(h)),m=(h,_)=>{for(let g of _){if(h[g])continue;let E=l(g),N=E.columns?.()||E.entries();h[g]=Object.fromEntries(N.map(x=>[x.name().value(),null]))}return h},f=new Set,p=new Map,d=0;for await(let h of e){for(let g of Object.keys(h))f.add(g);let _=!1;for await(let g of await r(h,d)){let E={...h,...g},N=()=>x||(x=s?JSON.stringify(g):g),x;!a||await this.#t.evaluate(a,E,u)?(_=!0,p.set(N(),!0),yield E):(n==="RIGHT"||n==="FULL")&&!p.has(N())&&p.set(N(),!1)}!_&&(n==="LEFT"||n==="FULL")&&(yield m({...h},[t])),d++}if(n==="RIGHT"||n==="FULL")for(let[h,_]of p.entries())_||(typeof h=="string"&&(h=JSON.parse(h)),yield m({...h},[...f]))}async*evaluateWhereClause(e,t,s){for await(let r of t)await this.#t.evaluate(e.expr(),r,s)&&(yield r)}async*evaluateGroupByClause(e,t,s,r){function n(f){return f instanceof y.RowConstructor?f.entries().flatMap(n):[f]}function a(f){if(f.groupingSets())return f.groupingSets().flatMap(a);if(f.rollupSet()){let p=f.rollupSet().entries(),d=[];for(let h=p.length;h>=0;h--)d.push(p.slice(0,h).flatMap(n));return d}if(f.cubeSet()){let p=f.cubeSet().entries(),d=p.length,h=[];for(let _=0;_<1<<d;_++){let g=[];for(let E=0;E<d;E++)_&1<<E&&g.push(p[E]);h.push(g.flatMap(n))}return h}return f.expr()?[n(f.expr())]:[[]]}function o(f){if(f.groupingSets())return f.groupingSets().flatMap(o);if(f.rollupSet())return[...f.rollupSet().entries()];if(f.cubeSet())return[...f.cubeSet().entries()];if(f.expr()){let p=f.expr();return p instanceof y.RowConstructor?p.entries():[p]}return[]}let u;e.every(f=>f.expr()&&!f.rollupSet()&&!f.cubeSet()&&!f.groupingSets())?u=[e.flatMap(f=>a(f)[0])]:u=e.flatMap(a);let l=new Map;for(let f=0;f<e.length;f++){let p=o(e[f]);l.set(f,p)}let m=new Map;for await(let f of s)for(let p=0;p<u.length;p++){let d=u[p],h=d.length?await Promise.all(d.map(E=>this.#t.evaluate(E,f,r))):[],_=0;for(let E=0;E<e.length;E++){let N=l.get(E)||[];if(N.length===0){_|=1<<E;continue}N.every(S=>d.includes(S))||(_|=1<<E)}let g=JSON.stringify([p,h]);m.has(g)||m.set(g,{window:[],mask:_,setIndex:p,keyVals:h,set:d}),m.get(g).window.push(f)}for(let{window:f,mask:p,setIndex:d,keyVals:h,set:_}of m.values()){let g={},E=new Map,N=S=>{let A=S.qualifier()?.value()||"",v=E.get(A)??new Set;v.add(S.value()),E.set(A,v)};for(let S of _)S instanceof y.ColumnRef1?N(S):S.walkTree(A=>(A instanceof y.ColumnRef1&&N(A),A));let x=new Map;for(let S=0;S<e.length;S++){let A=l.get(S)||[];for(let v of A)x.set(v,S)}for(let S of Object.keys(f[0])){let A={...f[0][S]};for(let v of Object.keys(A))E.get(S)?.has(v)||(A[v]=null);g[S]=A}g[ta]={window:f,frameStart:0,frameEnd:f.length-1,groupValues:h,groupingId:p,setIndex:d,exprIndex:x,isGrandTotal:_.length===0,groupingColumnsMap:E},!(t&&!await this.#t.evaluate(t.expr(),g,r))&&(yield g)}}async*evaluateGlobalGroup(e){let t=[];for await(let r of e)t.push(r);let s=t[0]?{...t[0]}:{};s[ta]={window:t,frameStart:0,frameEnd:t.length-1,groupValues:[],groupingId:0,setIndex:0,exprIndex:new Map},yield s}async*evaluateWindowing(e,t,s,r){let n=Array.isArray(s)?s:[];if(!Array.isArray(s))for await(let o of s)n.push(o);let a=new Map;for(let o of e){let u=o.overClause(),l;if(u instanceof y.WindowRef){let f=t.get(u.value());if(!f)throw new Error(`[${o}] Window '${u.value()}' not found`);l={partitionBy:f.partitionByClause(),orderBy:f.orderByClause(),frameSpec:f.frameSpec()}}else if(u instanceof y.WindowSpec){let f=u.superWindow()?t.get(u.superWindow().value()):null;l={partitionBy:u.partitionByClause()??f?.partitionByClause(),orderBy:u.orderByClause()??f?.orderByClause(),frameSpec:u.frameSpec()??f?.frameSpec()}}let m=JSON.stringify(l);a.has(m)||a.set(m,l),o.winHash=m}for(let[o,u]of a.entries()){let l=new Map,m=!!n[0]?.[ta],f=new WeakMap;for(let p of n){let d=p,h=p;m&&(h={...p[ta].window[0]},f.set(h,d));let _=await Promise.all(u.partitionBy?.map(E=>this.#t(E,h,r))??[]),g=JSON.stringify(_);if(!l.has(g)){let E=[];l.set(g,E)}l.get(g).push(h)}for(let p of l.values()){if(u.orderBy){let _=this.evaluateOrderByClause(u.orderBy.entries(),p,r,!0),g=[];for await(let E of _)g.push(E);p=g}let d=0,h=!!u.orderBy;for(let _ of p){let{row:g,keys:E}=h?_:{row:_,keys:[d]},N=m?f.get(g):g,{frameStart:x,frameEnd:S}=this.#v(u,p,d,h);N[Ma]||(N[Ma]={}),N[Ma][o]={window:h?p.map(A=>A.row):p,orderKeysHash:JSON.stringify(E),orderKeys:E,offset:d++,frameStart:x,frameEnd:S}}}}yield*n}#v(e,t,s,r=!1){let n=e.frameSpec,a=t.length;if(!n)return{frameStart:0,frameEnd:a-1};let o=n.specifier(),[u,l]=n.bounds()??[],m=0,f=a-1,p=d=>Math.min(Math.max(d,0),a-1);if(o==="ROWS"){if(!u||u.specifier()==="CURRENT ROW")m=s;else if(u.specifier()==="UNBOUNDED"&&u.dir()==="PRECEDING")m=0;else if(u.specifier()instanceof y.NumberLiteral){let d=u.specifier().value();m=p(u.dir()==="PRECEDING"?s-d:s+d)}if(!l||l.specifier()==="CURRENT ROW")f=s;else if(l.specifier()==="UNBOUNDED"&&l.dir()==="FOLLOWING")f=a-1;else if(l.specifier()instanceof y.NumberLiteral){let d=l.specifier().value();f=p(l.dir()==="FOLLOWING"?s+d:s-d)}}else if(o==="RANGE"){if(!e.orderBy)return{frameStart:0,frameEnd:a-1};let _=(S=>r?S.keys:[s])(t[s])[0],g=S=>r?S.keys[0]:s,E=s;for(;E>0&&g(t[E-1])===_;)E--;let N=s;for(;N<a-1&&g(t[N+1])===_;)N++;m=E,f=N;let x=(S,A)=>{if(S){if(S.specifier()==="UNBOUNDED"&&S.dir()==="PRECEDING")m=0;else if(S.specifier()==="UNBOUNDED"&&S.dir()==="FOLLOWING")f=a-1;else if(S.specifier()==="CURRENT ROW")A?m=E:f=N;else if(S.specifier()instanceof y.NumberLiteral){let v=S.specifier().value(),b=_+(S.dir()==="FOLLOWING"?v:-v);if(A){let O=0;for(;O<a&&g(t[O])<b;)O++;m=O}else{let O=a-1;for(;O>=0&&g(t[O])>b;)O--;f=O}}else if(S.specifier()instanceof y.TypedIntervalLiteral){let v=new Date(_).getTime(),b=S.specifier().applyToDate(new Date(v),S.dir());if(A){let O=0;for(;O<a&&new Date(g(t[O])).getTime()<b;)O++;m=O}else{let O=a-1;for(;O>=0&&new Date(g(t[O])).getTime()>b;)O--;f=O}}}};x(u,!0),x(l,!1)}else if(o==="GROUPS"){if(!e.orderBy)return{frameStart:0,frameEnd:a-1};let d=S=>JSON.stringify(r?S.keys:[s]),h=[],_=[0],g=d(t[0]);for(let S=1;S<a;S++){let A=d(t[S]);A===g?_.push(S):(h.push(_),_=[S],g=A)}h.push(_);let E=h.findIndex(S=>S.includes(s)),N=E,x=E;if(u){if(u.specifier()==="UNBOUNDED"&&u.dir()==="PRECEDING")N=0;else if(u.specifier()==="CURRENT ROW")N=E;else if(u.specifier()instanceof y.NumberLiteral){let S=u.specifier().value();N=p(E-S)}}if(l){if(l.specifier()==="UNBOUNDED"&&l.dir()==="FOLLOWING")x=h.length-1;else if(l.specifier()==="CURRENT ROW")x=E;else if(l.specifier()instanceof y.NumberLiteral){let S=l.specifier().value();x=p(E+S)}}m=h[N][0],f=h[x][h[x].length-1]}return{frameStart:m,frameEnd:f}}async*evaluateSelectList(e,t,s){for await(let r of t){let n=Object.create(null),a=1;for(let o of e){let{alias:u,value:l}=await this.#t.evaluate(o,r,s);n[u]&&s.depth&&(u+=a),n[u]=l,a++}yield n}}async*evaluateOrderByClause(e,t,s,r=!1){let n=Array.isArray(t)?t:[];if(!Array.isArray(t))for await(let o of t)n.push(o);let a=await Promise.all(n.map(async o=>{let u=await Promise.all(e.map(l=>this.#t.evaluate(l.expr(),o,s)));return{row:o,keys:u}}));this.#t.applySorting(a,e,s);for(let o of a)r?yield o:yield o.row}async*evaluateLimitClause(e,t,s,r){let n=e?await this.#t.evaluate(e.expr(),{},r):0,a=t?await this.#t.evaluate(t.expr(),{},r):e.myOffset()?await this.#t.evaluate(e.myOffset(),{},r):0,o=0,u=0;for await(let l of s)if(!(o++<a)){if(n&&u++>=n)break;yield l}}async*#b(e,t){let s=this;async function*r(b){if(b instanceof y.SelectStmt){yield*await s.#n(b,{...t,depth:t.depth+1});return}if(b instanceof y.TableStmt){yield*s.#E(b,{...t,depth:t.depth+1});return}let O=b.resultSchema(),T=b.jsonfy();b instanceof y.ValuesConstructor&&(T={...T,nodeName:"VALUES_TABLE_LITERAL"});let R=y.FromItem.fromJSON({nodeName:"FROM_ITEM",expr:T},{dialect:s.#r.dialect,assert:!0});e._adoptNodes(R);let k=s.evaluateFromItem(R,O,t);for await(let J of k)yield J[""]}let n=await r(e.left()),a=await r(e.right()),o=[],u=[];for await(let b of n)o.push(b);for await(let b of a)u.push(b);let l=e.left().resultSchema?.().entries()||[],m=e.right().resultSchema?.().entries()||[];if(l.length!==m.length)throw new Error(`Set operation column mismatch: left has ${l.length} columns, right has ${m.length}`);let f=l.map((b,O)=>{let T=m[O],R=b.dataType().value(),k=T.dataType().value(),J=this.#A(R,k);return{name:b.name().value()??`col${O+1}`,coercedType:J}}),p=[],d=[];for(let b of o)p.push(this.#w(b,f));for(let b of u)d.push(this.#w(b,f));let h=e.operator(),_=e.allOrDistinct()||"DISTINCT",g=[],E=b=>JSON.stringify(Object.values(b),(O,T)=>T==null?{__sql_null__:!0}:typeof T=="number"&&Number.isNaN(T)?{__sql_NaN__:!0}:T),N=Symbol("hash"),x=b=>{let O=new Map;for(let T of b){let R=T[N]??(T[N]=E(T));O.set(R,(O.get(R)||0)+1)}return O};if(h==="UNION")if(_==="ALL")g=[...p,...d];else{let b=new Map;for(let O of p)b.set(E(O),O);for(let O of d){let T=E(O);b.has(T)||b.set(T,O)}g=Array.from(b.values())}else if(h==="INTERSECT"){let b=x(p),O=x(d);if(_==="ALL")for(let[T,R]of b.entries()){let k=O.get(T)||0,J=Math.min(R,k),U=p.find(P=>E(P)===T);for(let P=0;P<J;P++)g.push({...U})}else for(let T of b.keys())if(O.has(T)){let R=p.find(k=>E(k)===T);g.push({...R})}}else if(h==="EXCEPT"){let b=x(p),O=x(d);if(_==="ALL")for(let[T,R]of b.entries()){let k=O.get(T)||0,J=Math.max(0,R-k),U=p.find(P=>E(P)===T);for(let P=0;P<J;P++)g.push({...U})}else for(let T of b.keys())if(!O.has(T)){let R=p.find(k=>E(k)===T);g.push({...R})}}let S=e.orderByClause();S&&(g=await this.evaluateSetOpOrderByClause(S.entries(),g,t));let A=e.limitClause(),v=e.offsetClause();(A||v)&&(g=await this.evaluateSetOpLimitClause(A,v,g,t)),yield*g}#w(e,t){let s=Object.values(e),r=Object.create(null);for(let n=0;n<t.length;n++){let{name:a,coercedType:o}=t[n],u=s[n];o==="numeric"?typeof u=="string"&&u!==""&&!isNaN(+u)&&(u=+u):o==="text"&&u!=null&&typeof u!="string"&&(u=String(u)),u===void 0&&(u=null),r[a]=u}return r}#A(e,t){if(!e&&!t)return null;if(!e)return t;if(!t||e===t)return e;let s=new Set(["smallint","integer","bigint","numeric","decimal","float","double"]);return s.has(e)&&s.has(t)?"numeric":e==="text"||t==="text"?"text":e==="boolean"&&t==="boolean"?"boolean":e}async evaluateSetOpOrderByClause(e,t,s){let r=await Promise.all(t.map(async n=>{let a=await Promise.all(e.map(o=>{let u,l=()=>{throw new Error(`[ORDER BY] The reference by offset ${o.expr()} does not resolve to a select list entry`)};if(o.expr()instanceof y.NumberLiteral){let m=Object.values(n),f=o.expr().value()-1;return(f<0||f>=m.length)&&l(),m[f]}return o.expr()?.resolution?.()==="scope"?((u=n[o.expr().value()])===void 0&&l(),u):this.#t.evaluate(o.expr(),{...s.lateralCtx||{}," ":n},s)}));return{row:n,keys:a}}));return this.#t.applySorting(r,e,s),r.map(n=>n.row)}async evaluateSetOpLimitClause(e,t,s,r){let n=e?await this.#t.evaluate(e.expr(),{},r):0,a=t?await this.#t.evaluate(t.expr(),{},r):e.myOffset()?await this.#t.evaluate(e.myOffset(),{},r):0;return s.slice(a,n?a+n:void 0)}};var ri=class extends Mt{#e;#t;#r;#n;#i=new Map;#a;get dialect(){return this.#e}get storageEngine(){return this.#t}constructor({dialect:e="postgres",capability:t={},onCreateRemoteClient:s=null,...r}={},n=null){super({capability:t}),this.#e=e,this.#t=n||new ea({dialect:e,...r}),this.#r=new ra(this.#t,{dialect:e,...r}),this.#n=s}async _connect(){}async _disconnect(){}async _query(e,t){let s=await this.#t.showMirrors({materialized:!1}),r=new Map;if(s.size){let n=0;e.walkTree(o=>{let u,l;if(o instanceof y.TableRef1&&(u=o.qualifier()?.value())&&(l=o.value())){let m=s.get(u),f=m?.tables.get(l);if(!f)return;r.has(u)||r.set(u,{type:m.type,origin:m.origin,tables:new Map}),r.get(u).tables.set(l,f),m.type==="API"||f?.querySpec.query||f.querySpec.namespace!==u?n=-1:n!==-1&&(n=1)}else return o},!0);let a;for(let o of r.values())a=await this.getRemoteClient(o.origin),o.client=a;if(n===1&&r.size===1)return await a.query(e,t)}return await this.#r.query(e,{...t,effectiveMirrorsSpec:r})}async _cursor(e,t){let s=!1;return{async*[Symbol.asyncIterator](){let{rows:r}=await this._query(e,t);for await(let n of r){if(s)return;yield n}},async close(){s=!0}}}async _showCreate(e,t=!1){e=st(e);let s=[];for(let r of await this.#t.namespaceNames()){let n=Object.entries(e).reduce((u,[l,m])=>Bt(r,[l])?u.concat(m):u,[]);if(!n.length)continue;let a={nodeName:y.NamespaceSchema.NODE_NAME,name:{nodeName:y.NamespaceIdent.NODE_NAME,value:r},entries:[]},o=await this.#t.getNamespace(r);for(let u of await o.tableNames()){if(!Bt(u,n))continue;let m=(await o.getTable(u)).schema.jsonfy();m.name.nodeName=y.TableIdent.NODE_NAME,m.name.qualifier={nodeName:y.NamespaceRef.NODE_NAME,value:r},(t?a.entries:s).push(y.TableSchema.fromJSON(m,{assert:!0,dialect:this.dialect}))}t&&s.push(y.NamespaceSchema.fromJSON(a,{dialect:this.dialect}))}return s}async _setupRealtime(){this.#a||(this.#a=this.#t.on("changefeed",e=>this._fanout(e)))}async _teardownRealtime(){this.#a?.(),this.#a=null}async subscribe(e,t){if(typeof e=="function")return super.subscribe(e);let s=await this.#t.showMirrors({materialized:!1});if(s.size){let r=[],n=st(e),a={},o={};for(let[u,l]of Object.entries(n)){let m=s.get(u)?.tables;if(m)for(let f of l){let p=m.get(f)?.querySpec.namespace||"*";p?(o[u]||(o[u]={}),o[u][p]||(o[u][p]=[]),o[u][p].push(f)):(a[u]||(a[u]=[]),a[u].push(f))}else a[u]=l}Object.keys(a).length&&r.push(await super.subscribe(a,t));for(let u in o){let l=await this.getRemoteClient(s.get(u).origin);r.push(await l.subscribe(o[u],m=>{m=m.map(f=>({...f,relation:{...f.relation,namespace:u}})),t(m)}))}return()=>r.forEach(u=>u())}return super.subscribe(e,t)}async federate(...e){let[t,s,r]=this.#d(!0,...e);return await this.#s(t,s,r)}async materialize(...e){let[t,s,r]=this.#d(!0,...e);return await this.#u(t,s,r)}async sync(...e){let[t,s,r]=this.#d(!1,...e);return await this.#l(t,s,r)}async getRemoteClient(e){if(!this.#n)throw new Error("Cannot process remote operation; missing options.onCreateRemoteClient");return this.#i.has(e)||this.#i.set(e,await this.#n(e)),this.#i.get(e)}async#s(e,t,s,r=null){let n=this.#t,a={transaction:await n.startTransaction("~sync~init")},o=await this.getRemoteClient(s);for(let[u,l]of e.entries()){let m=await n.createNamespace(u,{ifNotExists:t.ifNotExists,type:t.type,mirrored:!0,origin:s},a);for(let f of l){let p=await o.resolve(f),d=y.TableSchema.fromJSON({name:{nodeName:y.Identifier.NODE_NAME,value:f.name},entries:p.resultSchema().entries().map(_=>_.jsonfy())},{assert:!0}),h=await m.createTable(d,{ifNotExists:t.ifNotExists,materialized:!!r,querySpec:f},a);r&&await r(h,p,a,o)}}await a.transaction.done()}async#u(e,t,s){let r={keyName:"~sync"},n=[];return await this.#s(e,t,s,async(a,o,u,l)=>{await a.createKey(r.keyName);let m,f=[];if(t.live){let d=await l[l instanceof Re?"query":"request"](o,(h,_)=>this.#o(a,h,_),{live:!0});({rows:m,hashes:f}=d),n.push(d.abort.bind(d))}else m=await l[l instanceof Re?"cursor":"stream"](o);let p=0;for await(let d of m){try{await a.insert(d,f[p]&&{...r,newKey:f[p]},u)}catch(h){if(h instanceof ve)t.ifNotExists||await a.update(h.existing,d,f[p]&&{...r,newKey:f[p]},u);else throw h}p++}}),()=>n.forEach(a=>a())}async#l(e,t,s){let n=[await this.#u(e,{...t,live:!0},s)];for(let[a,o]of e.entries())for(let u of o)n.push(await this.subscribe({[a]:[u.name]},l=>this.#c(l,u,s)));return()=>n.forEach(a=>a())}async#o(e,t,s){let n={transaction:await this.#t.startTransaction("~sync~in")},a={keyName:"~sync"};if(t==="diff")for(let o of s)o.type==="update"&&(await e.get(o.newHash,a)?await e.update(o.oldHash,o.new,{...a,newKey:o.newHash},n):o={...o,type:"insert"}),o.type==="insert"&&await e.insert(o.new,{...a,newKey:o.newHash},n),o.type==="delete"&&await e.delete(o.newHash,a,n);if(t==="swap"){let o=new Map;for(let[u,l]of s){let m=o.get(u)||await e.get(u,a),f=await e.get(l,a);o.set(l,f),await e.update(l,m,a)}}if(t==="result"){let o=await e.showKeys(a.keyName),u=[...s.hashes,...o],l;for(let m=0;m<u.length;m++)if(!s.rows[m])await e.delete(u[m],a,n);else if(l=await e.get(u[m],a)){if(_eq(s.rows[m],l))continue;await e.update(u[m],s.rows[m],a,n)}else await e.insert(s.rows[m],{...a,newKey:u[m]},n)}await n.transaction.done()}async#c(e,t,s){let r=[];for(let n of e){if(n.txId.startsWith("~sync"))continue;let a={...t,command:n.type};if(n.type==="insert")a.payload=[{...t.filters||{},...n.new}];else if(n.type==="update"||n.type==="delete"){let o=n.key||Object.fromEntries(n.relation.keyColumns.map(u=>[u,n.old[u]]));a.filters={...t.filters||{},...o},n.type==="update"&&(a.payload=n.new)}r.push(a)}r.length}#d(e,...t){let s=t.shift(),r=t.pop(),n=t.pop()||{};if(!(typeof s=="object"&&s)||Array.isArray(s))throw new TypeError("Mirroring spec must be a non-array object spec");if(!r||!["object","string"].includes(typeof r))throw new TypeError("Origin spec must be a string or an object");let a=new Map;for(let o in s){a.set(o,new Set);for(let u of[].concat(s[o])){let l={};if(typeof u=="string")n.type==="API"?a.get(o).add({name:u}):a.get(o).add({namespace:o,name:u});else{let m;if(!(typeof u=="object"&&u)||!(m=Object.keys(u)).length||m.filter(f=>f!=="namespace"&&f!=="name"&&f!=="query"&&f!=="url"&&f!=="filters"&&f!=="joinStrategy").length)throw new SyntaxError(`Given table spec ${JSON.stringify(u)} invalid`);if(!u.name)throw new SyntaxError(`Missing attribute "name" in ${JSON.stringify(u)}`);if(n.type==="API"){if(u.query)throw new SyntaxError(`Unsupported attribute "query" in API-type mirror spec: ${JSON.stringify(u)}`);if(u.namespace||u.filters)throw new SyntaxError(`Mutually-exclusive attributes "namespace|filters" in ${JSON.stringify(u)}`);a.get(o).add({name:u.name,url:u.url,joinStrategy:u.joinStrategy})}else{if(u.url)throw new SyntaxError(`Unsupported attribute "url" in SQL-type mirror spec: ${JSON.stringify(u)}`);if(u.query){if(!e)throw new SyntaxError(`Arbitrary queries ${JSON.stringify(l)} not supported on this operation`);if(u.namespace||u.filters)throw new SyntaxError(`Mutually-exclusive attributes "namespace|filters" in ${JSON.stringify(u)}`);a.get(o).add({name:u.name,query:u.query,joinStrategy:u.joinStrategy})}else{if(u.filters&&typeof u.filters!="object")throw new SyntaxError(`Invalid attribute "filter" in ${JSON.stringify(u)}`);a.get(o).add({namespace:u.namespace||o,name:u.name,filters:u.filters,joinStrategy:u.joinStrategy})}}}}}return[a,n,r]}};})();
//# sourceMappingURL=flashql.js.map
