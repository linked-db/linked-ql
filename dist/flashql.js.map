{
  "version": 3,
  "sources": ["../node_modules/@webqit/util/js/isObject.js", "../node_modules/@webqit/util/js/isProxy.js", "../node_modules/@webqit/util/js/getProxyTarget.js", "../node_modules/@webqit/util/js/getProxyTrap.js", "../node_modules/@webqit/util/js/getType.js", "../node_modules/@webqit/util/js/instanceof.js", "../node_modules/@webqit/util/js/isArray.js", "../node_modules/@webqit/util/arr/intersect.js", "../node_modules/@webqit/util/js/internals.js", "../node_modules/@webqit/util/js/isBoolean.js", "../node_modules/@webqit/util/js/isTypeFunction.js", "../node_modules/@webqit/util/js/isClass.js", "../node_modules/@webqit/util/js/isNull.js", "../node_modules/@webqit/util/js/isUndefined.js", "../node_modules/@webqit/util/js/isTypeObject.js", "../node_modules/@webqit/util/js/isEmpty.js", "../node_modules/@webqit/util/js/isFunction.js", "../node_modules/@webqit/util/js/isNumber.js", "../node_modules/@webqit/util/js/isNumeric.js", "../node_modules/@webqit/util/js/isPlainArray.js", "../node_modules/@webqit/util/js/isPlainObject.js", "../node_modules/@webqit/util/js/isString.js", "../node_modules/@webqit/util/js/isTypeArray.js", "../node_modules/@webqit/util/arr/first.js", "../node_modules/@webqit/util/arr/last.js", "../node_modules/@webqit/util/arr/pushUnique.js", "../node_modules/@webqit/util/obj/getPrototypeChain.js", "../node_modules/@webqit/util/obj/getAllPropertyNames.js", "../node_modules/@webqit/util/obj/mergeCallback.js", "../node_modules/@webqit/util/obj/each.js", "../node_modules/@webqit/util/js/mixin.js", "../node_modules/@webqit/util/obj/merge.js", "../node_modules/@webqit/util/js/proxy.js", "../node_modules/@webqit/util/js/wq.js", "../node_modules/@webqit/util/js/index.js", "../node_modules/@webqit/util/str/after.js", "../node_modules/@webqit/util/arr/indexOfSet.js", "../node_modules/@webqit/util/arr/after.js", "../node_modules/@webqit/util/arr/afterLast.js", "../node_modules/@webqit/util/arr/all.js", "../node_modules/@webqit/util/arr/any.js", "../node_modules/@webqit/util/arr/sum.js", "../node_modules/@webqit/util/arr/avg.js", "../node_modules/@webqit/util/str/before.js", "../node_modules/@webqit/util/arr/before.js", "../node_modules/@webqit/util/arr/beforeLast.js", "../node_modules/@webqit/util/arr/following.js", "../node_modules/@webqit/util/arr/preceding.js", "../node_modules/@webqit/util/arr/between.js", "../node_modules/@webqit/util/arr/concatAfter.js", "../node_modules/@webqit/util/arr/concatAfterLast.js", "../node_modules/@webqit/util/arr/concatBefore.js", "../node_modules/@webqit/util/arr/concatBeforeLast.js", "../node_modules/@webqit/util/arr/from.js", "../node_modules/@webqit/util/arr/concatUnique.js", "../node_modules/@webqit/util/arr/crossJoin.js", "../node_modules/@webqit/util/arr/difference.js", "../node_modules/@webqit/util/arr/divide.js", "../node_modules/@webqit/util/arr/endsWith.js", "../node_modules/@webqit/util/arr/equals.js", "../node_modules/@webqit/util/arr/equals2D.js", "../node_modules/@webqit/util/arr/remove.js", "../node_modules/@webqit/util/arr/exclude.js", "../node_modules/@webqit/util/arr/filter.js", "../node_modules/@webqit/util/arr/flatten.js", "../node_modules/@webqit/util/arr/followingLast.js", "../node_modules/@webqit/util/arr/inSequence.js", "../node_modules/@webqit/util/arr/lastIndexOfSet.js", "../node_modules/@webqit/util/arr/max.js", "../node_modules/@webqit/util/arr/mid.js", "../node_modules/@webqit/util/arr/min.js", "../node_modules/@webqit/util/arr/precedingLast.js", "../node_modules/@webqit/util/arr/rand.js", "../node_modules/@webqit/util/arr/replace.js", "../node_modules/@webqit/util/arr/slice.js", "../node_modules/@webqit/util/arr/sort.js", "../node_modules/@webqit/util/arr/startsWith.js", "../node_modules/@webqit/util/arr/unique.js", "../node_modules/@webqit/util/arr/index.js", "../node_modules/@webqit/observer/src/util.js", "../node_modules/@webqit/observer/src/core/Registration.js", "../node_modules/@webqit/observer/src/core/ListenerRegistration.js", "../node_modules/@webqit/observer/src/core/Registry.js", "../node_modules/@webqit/observer/src/core/Descriptor.js", "../node_modules/@webqit/observer/src/core/ListenerRegistry.js", "../node_modules/@webqit/observer/src/core/TrapsRegistration.js", "../node_modules/@webqit/observer/src/core/TrapsRegistry.js", "../node_modules/@webqit/observer/src/actors.js", "../node_modules/@webqit/observer/src/main.js", "../node_modules/@webqit/observer/src/index.js", "../src/lang/abstracts/AbstractNode.js", "../src/lang/abstracts/util.js", "../src/lang/toktypes.js", "../src/lang/TokenStream.js", "../src/lang/registry.js", "../src/entry/abstracts/util.js", "../src/lang/cte/index.js", "../src/lang/cte/constructs/PGCycleClause.js", "../src/lang/cte/constructs/PGSearchClause.js", "../src/lang/abstracts/ResultSchemaMixin.js", "../src/lang/abstracts/OriginSchemasMixin.js", "../src/lang/abstracts/AbstractStmt.js", "../src/lang/abstracts/AbstractNonDDLStmt.js", "../src/lang/Transformer.js", "../src/lang/cte/CTE.js", "../src/lang/cte/CTEItem.js", "../src/lang/expr/ref/Identifier.js", "../src/lang/cte/CTEItemAlias.js", "../src/lang/ddl/index.js", "../src/lang/abstracts/AbstractNodeList.js", "../src/lang/abstracts/AbstractDiff.js", "../src/lang/ddl/column/ColumnDiff.js", "../src/lang/abstracts/AbstractSchema.js", "../src/lang/ddl/column/ColumnSchema.js", "../src/lang/ddl/constraint/constructs/FKMatchRule.js", "../src/lang/ddl/constraint/constructs/FKDeleteRule.js", "../src/lang/ddl/constraint/constructs/FKUpdateRule.js", "../src/lang/ddl/constraint/constructs/PGIndexParameters.js", "../src/lang/ddl/constraint/constructs/PGIndexParamInclude.js", "../src/lang/ddl/constraint/constructs/PGIndexParamUsing.js", "../src/lang/ddl/constraint/constructs/PGIndexParamWith.js", "../src/lang/ddl/constraint/ConstraintSchema.js", "../src/lang/ddl/constraint/constructs/PGTableEXConstraintItem.js", "../src/lang/ddl/constraint/constructs/ReferentialAction.js", "../src/lang/ddl/constraint/CheckConstraint.js", "../src/lang/ddl/constraint/ColumnDefaultConstraint.js", "../src/lang/ddl/constraint/ColumnExpressionConstraint.js", "../src/lang/ddl/constraint/ColumnFKConstraint.js", "../src/lang/ddl/constraint/MYColumnAutoIncrementModifier.js", "../src/lang/ddl/constraint/ColumnIdentityConstraint.js", "../src/lang/ddl/constraint/ColumnNullConstraint.js", "../src/lang/ddl/constraint/ColumnPKConstraint.js", "../src/lang/ddl/constraint/ColumnUKConstraint.js", "../src/lang/ddl/constraint/MYColumnCommentModifier.js", "../src/lang/ddl/constraint/MYColumnOnUpdateModifier.js", "../src/lang/ddl/constraint/MYColumnVisibilityModifier.js", "../src/lang/ddl/constraint/PGTableEXConstraint.js", "../src/lang/ddl/constraint/TableFKConstraint.js", "../src/lang/ddl/constraint/TablePKConstraint.js", "../src/lang/ddl/constraint/TableUKConstraint.js", "../src/lang/abstracts/PathMixin.js", "../src/lang/expr/index.js", "../src/lang/abstracts/TypeSysMixin.js", "../src/lang/expr/AbstractClassicExpr.js", "../src/lang/expr/abstraction/ParenExpr.js", "../src/lang/expr/abstraction/RowConstructor.js", "../src/lang/dql/TA/DerivedQuery.js", "../src/lang/expr/abstraction/ScalarSubquery.js", "../src/lang/expr/abstraction/TypedRowConstructor.js", "../src/lang/expr/call/constructs/PGFilterClause.js", "../src/lang/expr/call/constructs/PGWithinGroupClause.js", "../src/lang/expr/call/CallExpr.js", "../src/lang/expr/call/AggrCallExpr.js", "../src/lang/expr/case/CaseExpr.js", "../src/lang/expr/case/CaseBranch.js", "../src/lang/expr/etc/CastExpr.js", "../src/lang/expr/op/BinaryExpr.js", "../src/lang/expr/etc/ExtractExpr.js", "../src/lang/expr/etc/PredicateExpr.js", "../src/lang/expr/etc/QuantitativeExpr.js", "../src/lang/expr/literals/AbstractLiteral.js", "../src/lang/expr/literals/BitLiteral.js", "../src/lang/expr/literals/BoolLiteral.js", "../src/lang/expr/literals/DefaultLiteral.js", "../src/lang/expr/literals/HexLiteral.js", "../src/lang/expr/literals/NullLiteral.js", "../src/lang/expr/literals/NumberLiteral.js", "../src/lang/expr/literals/StringLiteral.js", "../src/lang/expr/literals/TypedLiteral.js", "../src/lang/expr/literals/TypedDateLiteral.js", "../src/lang/expr/literals/TypedIntervalLiteral.js", "../src/lang/expr/literals/TypedTimeLiteral.js", "../src/lang/expr/literals/TypedTimestampLiteral.js", "../src/lang/expr/literals/TypedTimeZoneLiteral.js", "../src/lang/expr/literals/UnknownLiteral.js", "../src/lang/abstracts/SugarMixin.js", "../src/lang/expr/literals/AbstractLQJsonLiteral.js", "../src/lang/expr/literals/LQArrayLiteral.js", "../src/lang/expr/literals/LQObjectLiteral.js", "../src/lang/expr/literals/LQObjectProperty.js", "../src/lang/expr/literals/PGTypedArrayLiteral.js", "../src/lang/expr/op/AtTimeZoneExpr.js", "../src/lang/expr/op/BetweenExpr.js", "../src/lang/expr/op/DistinctFromExpr.js", "../src/lang/expr/op/InExpr.js", "../src/lang/expr/op/PGCastExpr2.js", "../src/lang/expr/op/UnaryExpr.js", "../src/lang/expr/ref/abstracts/ErrorRefUnknown.js", "../src/lang/expr/ref/abstracts/ErrorRefAmbiguous.js", "../src/lang/expr/ref/abstracts/AbstractClassicRef.js", "../src/lang/expr/ref/ColumnRef1.js", "../src/lang/expr/ref/ColumnRef0.js", "../src/lang/expr/ref/abstracts/ErrorFKInvalid.js", "../src/lang/expr/ref/abstracts/AbstractMagicRef.js", "../src/lang/expr/ref/ColumnRef2.js", "../src/lang/expr/ref/LQBackBackRef.js", "../src/lang/expr/ref/LQBackRef.js", "../src/lang/expr/ref/LQBackRefAbstraction.js", "../src/lang/expr/ref/LQBackRefEndpoint.js", "../src/lang/expr/ref/LQDeepDeepRef1.js", "../src/lang/expr/ref/LQDeepDeepRef2.js", "../src/lang/expr/ref/LQDeepRef1.js", "../src/lang/expr/ref/LQDeepRef2.js", "../src/lang/expr/ref/NamespaceRef.js", "../src/lang/expr/ref/TableRef1.js", "../src/lang/expr/ref/TableRef0.js", "../src/lang/expr/ref/TableRef2.js", "../src/lang/expr/ref/WindowRef.js", "../src/lang/expr/var/BindVar.js", "../src/lang/expr/var/SystemVar.js", "../src/lang/expr/var/UserVar.js", "../src/lang/expr/Expr.js", "../src/lang/ddl/ident/ColumnIdent.js", "../src/lang/ddl/ident/NamespaceIdent.js", "../src/lang/ddl/ident/TableIdent.js", "../src/lang/ddl/index/IndexDiff.js", "../src/lang/ddl/index/IndexSchema.js", "../src/lang/ddl/namespace/SchemaDiff.js", "../src/lang/ddl/namespace/NamespaceSchema.js", "../src/lang/ddl/table/TableDiff.js", "../src/lang/ddl/table/TableSchema.js", "../src/lang/ddl/DDLStmt.js", "../src/lang/ddl/CreateSchemaStmt.js", "../src/lang/ddl/DropSchemaStmt.js", "../src/lang/ddl/CreateTableStmt.js", "../src/lang/ddl/DropTableStmt.js", "../src/lang/dml/index.js", "../src/lang/dml/clauses/MYOnDuplicateKeyUpdateClause.js", "../src/lang/dml/clauses/MYPartitionClause.js", "../src/lang/dml/clauses/PGConflictTarget.js", "../src/lang/dml/clauses/PGConflictTargetIndexSpec.js", "../src/lang/dml/clauses/PGDefaultValuesClause.js", "../src/lang/dml/clauses/PGOnConflictClause.js", "../src/lang/dql/clauses/SelectList.js", "../src/lang/dml/clauses/ReturningClause.js", "../src/lang/dml/clauses/PGWhereCurrentClause.js", "../src/lang/dml/clauses/SetClause.js", "../src/lang/dml/clauses/UsingFromClause.js", "../src/lang/dml/constructors/ColumnsConstructor.js", "../src/lang/dml/constructors/ValuesConstructor.js", "../src/lang/dml/expr/AssignmentExpr.js", "../src/lang/dml/expr/ConfigAssignmentExpr.js", "../src/lang/dml/expr/ConfigAssignmentExprAlt1.js", "../src/lang/dml/expr/ConfigAssignmentExprAlt2.js", "../src/lang/dml/expr/MYVarAssignmentExpr.js", "../src/lang/dml/expr/KW.js", "../src/lang/dml/TA/TableAbstraction2.js", "../src/lang/dml/TA/TableAbstraction1.js", "../src/lang/abstracts/SelectorStmtMixin.js", "../src/lang/dml/DMLStmt.js", "../src/lang/dml/DeleteStmt.js", "../src/lang/abstracts/PayloadStmtMixin.js", "../src/lang/dml/InsertStmt.js", "../src/lang/dml/MYSetStmt.js", "../src/lang/dml/PGSetStmt.js", "../src/lang/dml/UpdateStmt.js", "../src/lang/dml/UpsertStmt.js", "../src/lang/dql/index.js", "../src/lang/dql/clauses/DistinctClause.js", "../src/lang/dql/clauses/ForClause.js", "../src/lang/dql/clauses/FromClause.js", "../src/lang/dql/clauses/GroupByClause.js", "../src/lang/dql/clauses/GroupingElement.js", "../src/lang/dql/clauses/HavingClause.js", "../src/lang/dql/TA/FromItem.js", "../src/lang/dql/clauses/JoinClause.js", "../src/lang/dql/clauses/LimitClause.js", "../src/lang/dql/clauses/OffsetClause.js", "../src/lang/dql/clauses/OnClause.js", "../src/lang/dql/clauses/OrderByClause.js", "../src/lang/dql/clauses/OrderElement.js", "../src/lang/dql/clauses/PartitionByClause.js", "../src/lang/dql/clauses/PGFetchClause.js", "../src/lang/dql/clauses/PGOrderOperator.js", "../src/lang/dql/clauses/UsingClause.js", "../src/lang/dql/clauses/WhereClause.js", "../src/lang/dql/clauses/WindowClause.js", "../src/lang/dql/clauses/WindowDeclaration.js", "../src/lang/dql/clauses/WindowFrameSpec.js", "../src/lang/dql/clauses/WindowFrameBound.js", "../src/lang/dql/clauses/WindowSpec.js", "../src/lang/dql/TA/FromItemAlias.js", "../src/lang/dql/TA/SelectItem.js", "../src/lang/dql/TA/SelectItemAlias.js", "../src/lang/dql/TA/SRFExpr1.js", "../src/lang/dql/TA/SRFExpr2.js", "../src/lang/dql/TA/SRFExpr3.js", "../src/lang/dql/TA/SRFExpr4.js", "../src/lang/dql/TA/SRFExprDDL1.js", "../src/lang/dql/TA/SRFExprDDL2.js", "../src/lang/dql/TA/ValuesTableLiteral.js", "../src/lang/dql/SelectStmt.js", "../src/lang/dql/BasicSelectStmt.js", "../src/lang/dql/CompleteSelectStmt.js", "../src/lang/dql/CompositeSelectStmt.js", "../src/lang/dql/TableStmt.js", "../src/lang/qualif/index.js", "../src/lang/qualif/AggrNotation.js", "../src/lang/qualif/LQVersionSpec.js", "../src/lang/type/index.js", "../src/lang/type/DataType.js", "../src/lang/abstracts/JSONSchema.js", "../src/lang/StdStmt.js", "../src/lang/Script.js", "../src/lang/index.js", "../src/entry/abstracts/SimpleEmitter.js", "../src/lang/SchemaInference.js", "../src/entry/abstracts/AbstractClient.js", "../src/entry/Result.js", "../src/proc/realtime/RealtimeResult.js", "../src/flashql/ExprEngine.js", "../src/proc/realtime/QueryWindow.js", "../src/proc/realtime/RealtimeClient.js", "../src/entry/abstracts/AbstractSQLClient.js", "../src/flashql/fetch/AbstractFetchClient.js", "../src/flashql/ConflictError.js", "../src/flashql/TableStorage.js", "../src/flashql/StorageNamespace.js", "../src/flashql/StorageEngine.js", "../src/flashql/QueryEngine.js", "../src/flashql/FlashQL.js"],
  "sourcesContent": ["\n/**\n * Tells if val is pure object.\n *\n * @param object\t \tval\n *\n * @return bool\n */\nexport default function(val) {\n\treturn !Array.isArray(val) && typeof val === 'object' && val;\n};\n", "\n/**\n * @imports\n */\nimport _isObject from './isObject.js';\n\n/**\n * Tells if a given object instance has been proxied.\n *\n * @param mixed\t\tinput\n *\n * @return bool\n */\nexport default function(input) {\n\treturn (_isObject(input) && input.__proxyTargetByCommons) || false;\n};\n", "\n/**\n * @imports\n */\nimport _isProxy from './isProxy.js';\n\n/**\n * Returns the proxy's target object as earlier saved.\n *\n * @param mixed\t\tproxy\n *\n * @return mixed\n */\nexport default function(instance) {\n\treturn _isProxy(instance) ? instance.__proxyTargetByCommons : undefined;\n};\n", "\n/**\n * @imports\n */\nimport _isProxy from './isProxy.js';\n\n/**\n * Returns the proxy's trap object as earlier saved.\n *\n * @param mixed\t\tproxy\n *\n * @return mixed\n */\nexport default function(instance) {\n\treturn _isProxy(instance) ? instance.__proxyTrapByCommons : undefined;\n};\n", "\n/**\n * Returns the val's type.\n *\n * @param string \tval\n *\n * @return string\n */\nexport default function(val) {\n\treturn typeof val;\n};\n", "\n/**\n * Instanceof that supports our multi-inheritance implementstion.\n *\n * @param object\t \tobj1\n * @param object\t \tclassB\n *\n * @return bool\n */\nexport default function(obj, classB) {\n\tif (!obj) {\n\t\treturn false;\n\t}\n\tif (obj instanceof classB) {\n\t\treturn true;\n\t}\n\tvar mixinTest = classA => {\n\t\twhile (classA && classA !== Function.prototype) {\n\t\t\tif (classA === classB || (classA.prototypes && classA.prototypes.reduce((prevAns, prototype) => prevAns || (prototype === classB) || mixinTest(prototype), false))) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tclassA = Object.getPrototypeOf(classA);\n\t\t}\n\t\treturn false;\n\t};\n\treturn mixinTest(obj.constructor);\n};\n", "\n/**\n * Tells if val is of type \"array\".\n *\n * @param object\t \tval\n *\n * @return bool\n */\nexport default function(val) {\n\treturn Array.isArray(val);\n};\n", "\n/**\n * @imports\n */\nimport _isArray from '../js/isArray.js';\n\n/**\n * Returns the intersection of two arrays;\n * optionally using a custom matching function.\n *\n * @param array \tarr\n * @param array\t \tarr2\n * @param function \tcallback\n *\n * @return array\n */\nexport default function(arr, arr2, callback = null) {\n\treturn !_isArray(arr2) ? [] : arr.filter(val1 => callback \n\t\t? arr2.filter(val2 => callback(val1, val2)).length \n\t\t: arr2.indexOf(val1) !== -1\n\t);\n};\n", "/**\n * @imports\n */\nimport _intersect from '../arr/intersect.js';\n\n/**\n * Creates and/or returns an \"internals\" object for the given object.\n * \n * @param Any obj\n * @param String namespace\n * \n * @return Object\n */\nexport default function internals(obj, ...namespaces) {\n    if (!globalThis.webqit) { globalThis.webqit = {}; }\n    if (!globalThis.webqit.refs) {\n        Object.defineProperty(globalThis.webqit, 'refs', {value: new ObservableMap})\n    }\n    if (!arguments.length) return globalThis.webqit.refs;\n    let itnls = globalThis.webqit.refs.get(obj);\n    if (!itnls) {\n        itnls = new ObservableMap;\n        globalThis.webqit.refs.set(obj, itnls);\n    }\n    let _ns, _itnls;\n    while ((_ns = namespaces.shift())) {\n        if ((_itnls = itnls) && !(itnls = itnls.get(_ns))) {\n            itnls = new ObservableMap;\n            _itnls.set(_ns, itnls);\n        }\n    }\n    return itnls;\n}\n\nclass ObservableMap extends Map {\n    constructor( ...args ) {\n        super( ...args );\n        this.observers = new Set;\n    }\n    set( key, value ) {\n        let returnValue = super.set( key, value );\n        this.fire( 'set', key, value, key );\n        return returnValue;\n    }\n    delete( key ) {\n        let returnValue = super.delete( key );\n        this.fire( 'delete', key );\n        return returnValue;\n    }\n    has( key ) {\n        this.fire( 'has', key );\n        return super.has( key );\n    }\n    get( key ) {\n        this.fire( 'get', key );\n        return super.get( key );\n    }\n    keyNames() { return Array.from( super.keys() ); }\n    observe( type, key, callback ) {\n        const entry = { type, key, callback };\n        this.observers.add( entry );\n        return () => this.observers.delete( entry );\n    }\n    unobserve( type, key, callback ) {\n        if ( Array.isArray( type ) || Array.isArray( key ) ) {\n            throw new Error( `The \"type\" and \"key\" arguments can only be strings.` );\n        }\n        for ( let entry of this.observers ) {\n            if ( !( _intersection( [ type, '*' ], entry.type ) && _intersection( [ key, '*' ], entry.key ) && entry.callback === callback ) ) continue;\n            this.observers.delete( entry );\n        }\n    }\n    fire( type, key, ...args ) {\n        // IMPORTANT: Array.from() must be used so that new additions to this.observers\n        // during the loop aren't picked up!\n        for ( let entry of this.observers ) {\n            if ( !( _intersection( [ type, '*' ], entry.type ) && _intersection( [ key, '*' ], entry.key ) ) ) continue;\n            entry.callback( ...args );\n        }\n    }\n}\n\nconst _intersection = ( a, b ) => {\n    if ( Array.isArray( b ) ) return _intersect( a, b ).length;\n    return a.includes( b );\n}\n", "\n/**\n * Tells if val is undefined or is of type \"boolean\".\n *\n * @param string \tval\n *\n * @return bool\n */\nexport default function(val) {\n\treturn val === true || val === false;\n};\n", "\n/**\n * Tells if val is of type \"function\".\n * This holds true for both regular functions and classes.\n *\n * @param object\t \tval\n *\n * @return bool\n */\nexport default function(val) {\n\treturn typeof val === 'function';\n};\n", "\n/**\n * @imports\n */\nimport _isTypeFunction from './isTypeFunction.js';\n\n/**\n * Tells if val is of type \"class\".\n *\n * @param object \t\tval\n *\n * @return bool\n */\nexport default function(val) {\n\treturn _isTypeFunction(val) && /^class\\s?/.test(Function.prototype.toString.call(val));\n};\n", "\n/**\n * Tells if val is undefined or is null.\n *\n * @param string \tval\n *\n * @return bool\n */\nexport default function(val) {\n\treturn val === null || val === '';\n};\n", "\n/**\n * Tells if val is undefined or is of type \"undefined\".\n *\n * @param string \tval\n *\n * @return bool\n */\nexport default function(val) {\n\treturn arguments.length && (val === undefined || typeof val === 'undefined');\n};\n", "\n/**\n * @imports\n */\nimport _isTypeFunction from './isTypeFunction.js';\n\n/**\n * Tells if val is of type \"object\".\n * This holds true for anything object, including built-ins.\n *\n * @param object\t \tval\n *\n * @return bool\n */\nexport default function(val) {\n\treturn Array.isArray(val) || (typeof val === 'object' && val) || _isTypeFunction(val);\n};\n", "\n/**\n * @imports\n */\nimport _isNull from './isNull.js';\nimport _isUndefined from './isUndefined.js';\nimport _isTypeObject from './isTypeObject.js';\n\n/**\n * Tells if val is empty in its own type.\n * This holds true for NULLs, UNDEFINED, FALSE, 0,\n * objects without keys, empty arrays.\n *\n * @param string \tval\n *\n * @return bool\n */\nexport default function(val) {\n\treturn _isNull(val) || _isUndefined(val) || val === false || val === 0 \n\t\t|| (_isTypeObject(val) && !Object.keys(val).length);\n};\n", "\n/**\n * @imports\n */\nimport _isTypeFunction from './isTypeFunction.js';\n\n/**\n * Tells if val is of type \"function\".\n *\n * @param object \t\tval\n *\n * @return bool\n */\nexport default function(val) {\n\treturn _isTypeFunction(val) || (val && {}.toString.call(val) === '[object function]');\n};\n", "\n/**\n * Tells if val is of type \"number\".\n *\n * @param string \tval\n *\n * @return bool\n */\nexport default function(val) {\n\treturn val instanceof Number || (typeof val === 'number');\n};\n", "\n/**\n * @imports\n */\nimport _isNumber from './isNumber.js';\n/**\n * Tells if val is of type \"string\" or a numeric string.\n * This holds true for both numbers and numeric strings.\n *\n * @param string \tval\n *\n * @return bool\n */\nexport default function(val) {\n\treturn _isNumber(val) || (val !== true && val !== false && val !== null && val !== '' && !isNaN(val * 1));\n};\n", "\n/**\n * @imports\n */\nimport _isArray from './isArray.js';\n\n/**\n * Tells if an object is direct instance of Array.prototype.\n * Quite useful in differentiating array-extension instances from plain arrays ([]).\n *\n * @param object \tobj\n *\n * @return bool\n */\nexport default function(obj) {\n\treturn _isArray(obj) && Object.getPrototypeOf(obj) === Array.prototype;\n};\n", "\n/**\n * @imports\n */\nimport _isObject from './isObject.js';\n\n/**\n * Tells if an object is direct instance of Object.prototype.\n * Quite useful in differentiating native objects and class instances from plain objects ({}).\n *\n * @param object \tobj\n *\n * @return bool\n */\nexport default function(obj) {\n\treturn _isObject(obj) && Object.getPrototypeOf(obj) === Object.prototype;\n};\n", "\n/**\n * Tells if val is of type \"string\".\n *\n * @param string \tval\n *\n * @return bool\n */\nexport default function(val) {\n\treturn val instanceof String || (typeof val === 'string' && val !== null);\n};\n", "\n/**\n * @imports\n */\nimport _isString from './isString.js';\nimport _isUndefined from './isUndefined.js';\n\n/**\n * Tells if val is \"array-like\".\n * This holds true for anything that has a length property.\n *\n * @param object\t \tval\n *\n * @return bool\n */\nexport default function(val) {\n\treturn !_isString(val) && !_isUndefined(val.length);\n};\n", "\n/**\n * Returns THE FIRST ENTRY OR A NUMBER OF ENTRIES counting forward from the begining.\n *\n * @param array \tarr\n * @param int\t \tamount\n *\n * @return mixed|array\n */\nexport default function(arr, amount = 1) {\n\tvar count = 0;\n\tarr.forEach(itm => {\n\t\tcount ++;\n\t});\n\tvar firsts = arr.slice(arr.length - count, amount);\n\treturn arguments.length > 1 ? firsts : firsts[0];\n};\n", "\n/**\n * @imports\n */\nimport _first from './first.js';\n\n/**\n * Returns THE LAST ENTRY OR A NUMBER OF ENTRIES counting forward to the end.\n *\n * @param array \tarr\n * @param int\t \tamount\n *\n * @return mixed|array\n */\nexport default function(arr, amount = 1) {\n\treturn arguments.length > 1\n\t\t? _first(arr.slice().reverse(), amount).reverse()\n\t\t: _first(arr.slice().reverse());\n};\n", "\n/**\n * Adds an item if not already exist.\n *\n * @param array \tarr\n * @param array\t \t...itms\n *\n * @return array\n */\nexport default function(arr, ...items) {\n\titems.forEach(itm => {\n\t\tif (arr.indexOf(itm) < 0) {\n\t\t\tarr.push(itm);\n\t\t}\n\t});\n\treturn arr;\n};\n", "\n/**\n * @imports\n */\nimport _isArray from '../js/isArray.js';\n\n/**\n * Returns the prototype chain.\n *\n * @param object \t\tobj\n * @param object\t \tuntil\n *\n * @return bool\n */\nexport default function(obj, until) {\n\tuntil = until || Object.prototype;\n\tuntil = until && !_isArray(until) ? [until] : until;\n\t// We get the chain of inheritance\n\tvar prototypalChain = [];\n\tvar obj = obj;\n\twhile((obj && (!until || until.indexOf(obj) < 0) && obj.name !== 'default')) {\n\t\tprototypalChain.push(obj);\n\t\tobj = obj ? Object.getPrototypeOf(obj) : null;\n\t}\n\treturn prototypalChain;\n};\n", "\n/**\n * @imports\n */\nimport _pushUnique from '../arr/pushUnique.js';\nimport _getPrototypeChain from './getPrototypeChain.js';\n\n/**\n * Eagerly retrieves object members all down the prototype chain.\n *\n * @param object\t \tobj\n * @param object\t \tuntil\n *\n * @return array\n */\nexport default function(obj, until) {\n\tvar keysAll = [];\n\t_getPrototypeChain(obj, until).forEach(obj => {\n\t\t_pushUnique(keysAll, ...Object.getOwnPropertyNames(obj));\n\t});\n\treturn keysAll;\n};\n", "\n/**\n * @imports\n */\nimport _isArray from '../js/isArray.js';\nimport _isFunction from '../js/isFunction.js';\nimport _isObject from '../js/isObject.js';\nimport _isTypeObject from '../js/isTypeObject.js';\nimport _isNumeric from '../js/isNumeric.js';\nimport _getAllPropertyNames from './getAllPropertyNames.js';\n\n/**\n  * Merges values from subsequent arrays/objects first array/object;\n  * optionally recursive\n  *\n  * @param array ...objs\n  *\n  * @return void\n  */\nexport default function mergeCallback(objs, callback, deepProps = false, isReplace = false, withSymbols = false) {\n\tvar depth = 0;\n\tvar obj1 = objs.shift();\n\tif (_isNumeric(obj1) || obj1 === true || obj1 === false) {\n\t\tdepth = obj1;\n\t\tobj1 = objs.shift();\n\t}\n\tif (!objs.length) {\n\t\tthrow new Error('_merge() requires two or more array/objects.');\n\t}\n\tobjs.forEach((obj2, i) => {\n\t\tif (!_isTypeObject(obj2) && !_isFunction(obj2)) {\n\t\t\treturn;\n\t\t}\n\t\t(deepProps ? _getAllPropertyNames(obj2) : Object.keys(obj2)).forEach(key => {\n\t\t\tif (!callback(key, obj1, obj2, i)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar valAtObj1 = obj1[key];\n\t\t\tvar valAtObj2 = obj2[key];\n\t\t\tif (((_isArray(valAtObj1) && _isArray(valAtObj2)) || (_isObject(valAtObj1) && _isObject(valAtObj2))) \n\t\t\t&& (depth === true || depth > 0)) {\n\t\t\t\t// RECURSE...\n\t\t\t\tobj1[key] = _isArray(valAtObj1) && _isArray(valAtObj2) ? [] : {};\n\t\t\t\tmergeCallback([_isNumeric(depth) ? depth - 1 : depth, obj1[key], valAtObj1, valAtObj2], callback, deepProps, isReplace, withSymbols);\n\t\t\t} else {\n\t\t\t\tif (_isArray(obj1) && _isArray(obj2)) {\n\t\t\t\t\tif (isReplace) {\n\t\t\t\t\t\tobj1[key] = valAtObj2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tobj1.push(valAtObj2);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// In case we're setting a read-only property\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (withSymbols) {\n\t\t\t\t\t\t\tObject.defineProperty(obj1, key, Object.getOwnPropertyDescriptor(obj2, key));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tobj1[key] = obj2[key];\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch(e) {}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n\treturn obj1;\n};\n", "\n/**\n * @imports\n */\nimport _isTypeObject from '../js/isTypeObject.js';\nimport _isNumeric from '../js/isNumeric.js';\n\n/**\n * Loops thru obj flatly with a callback function.\n * Stops when callback returns a non-undefined value.\n *\n * @param array|object \t\t\tobj \t\t\tThe array or object to iterate.\n * @param function \t\t\t\tcallback \t\tThe callback function.\n *\n * @return mixed|null\t\t\tAny non-null return from callback\n */\nexport default function(obj, callback) {\n\tvar returnValue = undefined;\n\tif (_isTypeObject(obj)) {\n\t\tObject.keys(obj).forEach((k, i) => {\n\t\t\tif (returnValue !== false) {\n\t\t\t\treturnValue = callback(_isNumeric(k) ? parseFloat(k) : k, obj[k], i);\n\t\t\t}\n\t\t});\n\t}\n\treturn returnValue;\n};\n", "\n/**\n * @imports\n */\nimport _isArray from './isArray.js';\nimport _isFunction from './isFunction.js';\nimport _arrLast from '../arr/last.js';\nimport _mergeCallback from '../obj/mergeCallback.js';\nimport _each from '../obj/each.js';\n\n/**\n * A multi-inheritance implementstion.\n *\n * @param array\t \t...classes\n *\n * @return object\n */\nconst Implementations = new Map;\nexport default function mixin(...classes) {\n\t\n\tvar Traps = {};\n\tvar RetrnDirective = 'last';\n\tif (_isArray(arguments[0])) {\n\t\tclasses = arguments[0];\n\t\tTraps = arguments[1];\n\t\tif (arguments[2]) {\n\t\t\tRetrnDirective = arguments[2];\n\t\t}\n\t}\n\t// -----------------------\n\tvar Base = _arrLast(classes);\n\tvar supersMap = {};\n\t// -----------------------\n\t// Create the Mixin\n\t// ...with a special constructor.\n\t// -----------------------\n\tvar Mixin = class {\n\t\tconstructor(...args) {\n\t\t\tclasses.forEach((_class, i) => {\n\t\t\t\tReflect.construct(_class, args, this.constructor);\n\t\t\t});\n\t\t}\n\t};\n\t// -----------------------\n\t// Implement a special handler of the \"instanceof\" operator.\n\t// -----------------------\n\tclasses.forEach((_class, i) => {\n\t\tif (!Implementations.has(_class)) {\n\t\t\tImplementations.set(_class, []);\n\t\t\ttry {\n\t\t\t\tvar originalInstanceChecker = _class[Symbol.hasInstance];\n\t\t\t\tObject.defineProperty(_class, Symbol.hasInstance, {value: function(instance) {\n\t\t\t\t\tif (originalInstanceChecker.call(this, instance)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tif (Implementations.has(this)) {\n\t\t\t\t\t\treturn Implementations.get(this).reduce((yes, _mixin) => yes || (instance instanceof _mixin), false);\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}});\n\t\t\t} catch (e) {\n\t\t\t\tthrow new Error('Cannot mixin the class at index ' + i + '. Class may already have been configured for instance checks somewhere.');\n\t\t\t}\n\t\t}\n\t\tImplementations.get(_class).push(Mixin);\n\t});\n\t// ---------------------\n\t// Mixin both static and instance properties and methods\n\t// ---------------------\n\tclasses.forEach(_class => {\n\t\t// Copy const members\n\t\t_mergeCallback([Mixin, _class], (key, obj1, obj2) => ![\n\t\t\t'name', 'prototype', 'prototypes', 'length', 'caller', 'callee', 'arguments', 'constructor', 'apply', \"bind\", 'call', 'toString',/**/\n\t\t].includes(key), true/*deepProps*/);\n\t\t_mergeCallback([Mixin.prototype, _class.prototype], (key, obj1, obj2) => {\n\t\t\tif (!['prototype', 'prototypes'].includes(key)) {\n\t\t\t\tif (_isFunction(obj2[key])) {\n\t\t\t\t\tif (_isArray(supersMap[key])) {\n\t\t\t\t\t\tsupersMap[key].push(obj2[key]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsupersMap[key] = [obj2[key]];\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}, true/*deepProps*/);\n\t});\n\t// Extend (proxy) methods\n\t_each(supersMap, (name, supers) => {\n\t\tif (name === 'constructor') {\n\t\t\treturn;\n\t\t}\n\t\t// NOTE: this must not be defined as an arrow function\n\t\t// for the benefit of the \"this\".\n\t\tMixin.prototype[name] = function(...args) {\n\t\t\tif (Object.hasOwnProperty(Traps, name) && _isFunction(Traps[name])) {\n\t\t\t\t// Wrap a call to the trap...\n\t\t\t\t// So mixin supers are passed to traps\n\t\t\t\treturn Traps[name].call(this, supers, ...args);\n\t\t\t} else {\n\t\t\t\t// Call each super and return\n\t\t\t\t// the last one's return value\n\t\t\t\tvar supersReturnValues = [];\n\t\t\t\tsupers.forEach(supr => {\n\t\t\t\t\tsupersReturnValues.push(supr.call(this, ...args));\n\t\t\t\t})\n\t\t\t\treturn _arrLast(supersReturnValues);\n\t\t\t}\n\t\t};\n\t});\n\treturn Mixin;\n};", "\n/**\n * @imports\n */\nimport _mergeCallback from './mergeCallback.js';\n\n/**\n  * Merges values from subsequent arrays/objects first array/object;\n  * optionally recursive\n  *\n  * @param array ...objs\n  *\n  * @return void\n  */\nexport default function(...objs) {\n\treturn _mergeCallback(objs, (k, obj1, obj2) => {\n\t\treturn true;\n\t}, false/*deepProps*/, false/*isReplace*/, false/*withSymbols*/);\n};\n", "\n/**\n * @imports\n */\nimport _merge from '../obj/merge.js';\n\n/**\n * Creats a proxy and keeps special reference to it.\n *\n * @param object\t target\n * @param object\t trap\n *\n * @return Proxy\n */\nexport default function(target, trap) {\n\tvar trapByCommons = {\n\t\tget: (target, prop) => {\n\t\t\tif (prop === '__proxyTargetByCommons') {\n\t\t\t\treturn target;\n\t\t\t}\n\t\t\tif (prop === '__proxyTrapByCommons') {\n\t\t\t\treturn trap;\n\t\t\t}\n\t\t\treturn trap.get ? trap.get(target, prop) : target[prop];\n\t\t},\n\t};\n\treturn new Proxy(target, _merge({}, trap, trapByCommons));\n};\n", "export default function wq(obj, ...namespaces) {\n    if (!obj || !['object', 'function'].includes(typeof obj)) {\n        throw new Error(`Argument #1 must be of type object`);\n    }\n    let wq = obj[Symbol.for('wq')];\n    if (!wq) {\n        wq = new WQInternals;\n        Object.defineProperty(obj, Symbol.for('wq'), {\n            value: wq,\n            // Defaults, but to be explicit...\n            enumerable: false,\n            configurable: false,\n            writable: false\n        });\n    }\n    if (!namespaces.length) {\n        return wq;\n    }\n    let _ns, _wq;\n    while ((_ns = namespaces.shift())) {\n        if ((_wq = wq) && !(wq = wq.get(_ns))) {\n            wq = new WQInternals;\n            _wq.set(_ns, wq);\n        }\n    }\n    return wq;\n}\n\nclass WQInternals extends Map {}", "\n/**\n * @imports\n */\nimport _getProxyTarget from './getProxyTarget.js';\nimport _getProxyTrap from './getProxyTrap.js';\nimport _getType from './getType.js';\nimport _instanceof from './instanceof.js';\nimport _internals from './internals.js';\nimport _isArray from './isArray.js';\nimport _isBoolean from './isBoolean.js';\nimport _isClass from './isClass.js';\nimport _isEmpty from './isEmpty.js';\nimport _isFunction from './isFunction.js';\nimport _isNull from './isNull.js';\nimport _isNumber from './isNumber.js';\nimport _isNumeric from './isNumeric.js';\nimport _isObject from './isObject.js';\nimport _isPlainArray from './isPlainArray.js';\nimport _isPlainObject from './isPlainObject.js';\nimport _isProxy from './isProxy.js';\nimport _isString from './isString.js';\nimport _isTypeArray from './isTypeArray.js';\nimport _isTypeFunction from './isTypeFunction.js';\nimport _isTypeObject from './isTypeObject.js';\nimport _isUndefined from './isUndefined.js';\nimport _mixin from './mixin.js';\nimport _proxy from './proxy.js';\nimport _wq from './wq.js';\n\n/**\n * @exports\n * \"js\" category of modules.\n */\nexport {\n\t_getProxyTarget,\n\t_getProxyTrap,\n\t_getType,\n\t_instanceof,\n\t_internals,\n\t_isArray,\n\t_isBoolean,\n\t_isClass,\n\t_isEmpty,\n\t_isFunction,\n\t_isNull,\n\t_isNumber,\n\t_isNumeric,\n\t_isObject,\n\t_isPlainArray,\n\t_isPlainObject,\n\t_isProxy,\n\t_isString,\n\t_isTypeArray,\n\t_isTypeFunction,\n\t_isTypeObject,\n\t_isUndefined,\n\t_mixin,\n\t_proxy,\n\t_wq,\n};\n", "\n/**\n * Return the remainder of a string after a given value.\n *\n * @param  string  subject\n * @param  string  search\n * @param  bool\t   afterLast\n *\n * @return string\n */\nexport default function(subject, search, afterLast = false) {\n\tif (search == '') {\n\t\treturn subject;\n\t}\n\tvar pos = afterLast ? subject.lastIndexOf(search) : subject.indexOf(search);\n\tif (pos === -1) {\n\t\treturn '';\n\t}\n\treturn subject.substr(pos + search.length);\n};\n", "\n/**\n * Returns the index of subset array \"b\" in array \"a\".\n * \n * @param {Array} a \n * @param {Array} b \n * @param {Int} fromInex \n * @param {Bool} last\n * \n * @returns Int\n */\nexport default function indexOfSet(a, b, fromInex = null, last = false) {\n    if (b.length > a.length) return -1;\n\treturn (typeof fromInex === 'number' ? (last ? a.slice(0, (fromInex + 1) + (fromInex < 0 ? a.length : 0)) : a.slice(fromInex)) : a).reduce((cursors, value, i) => {\n        var [ index, cursorA, cursorB ] = cursors;\n        if (!last && index > -1) {\n            return [index, cursorA, cursorB];\n        }\n        var _cursorB = cursorB + 1;\n        var _cursors = value === b[_cursorB] ? (_cursorB === 0 ? [i, 0] : [cursorA, _cursorB]) : [-1, -1];\n        if (_cursors[1] === b.length - 1) {\n            // Reset B cursor\n            _cursors[1] = -1;\n            if (_cursors[0] > -1) {\n                return [_cursors[0]].concat(_cursors);\n            }\n        }\n        return [index].concat(_cursors);\n    }, [-1, -1, -1])[0] + (last || typeof fromInex !== 'number' ? 0 : (fromInex > -1 ? fromInex : a.length - fromInex));\n}", "\n/**\n * @imports\n */\nimport _after from '../str/after.js';\nimport _indexOfSet from './indexOfSet.js';\n\n/**\n * Returns members of array \"a\" after the array \"b\" subset.\n *\n * @param {Array} a \n * @param {Array} b \n * @param {Int} fromInex \n * @param {Bool} last \n * \n * @returns Bool\n */\nexport default function after(a, b, fromInex = null, last = false) {\n\tvar subsetIndex = _indexOfSet(a, b, fromInex, last);\n\treturn subsetIndex === -1 ? [] : a.slice(subsetIndex + b.length);\n}", "\n/**\n * @imports\n */\nimport _after from './after.js';\n\n/**\n * Returns members of array \"a\" after the last array \"b\" subset.\n *\n * @param {Array} a \n * @param {Array} b \n * @param {Int} fromInex \n * \n * @returns Bool\n */\nexport default function afterLast(a, b, fromInex = null) {\n\treturn _after(a, b, fromInex, true);\n}", "\n/**\n * Tells if ALL items pass the test.\n *\n * @param array \tarr\n * @param function \tcallback\n *\n * @return bool\n */\nexport default function(arr, callback) {\n\treturn arr.reduce((prevTest, itm, i) => prevTest && callback(itm, i), true);\n};\n", "\n/**\n * Tells if ANY items pass the test.\n *\n * @param array \tarr\n * @param function \tcallback\n *\n * @return bool\n */\nexport default function(arr, callback) {\n\treturn arr.reduce((prevTest, itm, i) => prevTest || callback(itm, i), false);\n};\n", "\n/**\n * Sums an array of numbers.\n *\n * @param array \tarr\n *\n * @return number\n */\nexport default function(arr) {\n\tarr = arr.slice();\n\treturn arr.reduce((total, v) => total + v, arr.shift());\n};\n", "\n/**\n * @imports\n */\nimport _sum from './sum.js';\n\n/**\n * Gets the average of an array of numbers.\n *\n * @param array \tarr\n *\n * @return number\n */\nexport default function(arr) {\n\treturn arr.length ? _sum(arr) / arr.length : 0;\n};", "\n/**\n * Return the part of a string before a given value.\n *\n * @param  string  subject\n * @param  string  search\n * @param  bool\t   beforeLast\n *\n * @return string\n */\nexport default function(subject, search, beforeLast = false) {\n\tif (search == '') {\n\t\treturn subject;\n\t}\n\tvar pos = beforeLast ? subject.lastIndexOf(search) : subject.indexOf(search);\n\tif (pos === -1) {\n\t\treturn subject;\n\t}\n\treturn subject.substr(0, pos);\n};\n", "\n/**\n * @imports\n */\nimport _before from '../str/before.js';\nimport _indexOfSet from './indexOfSet.js';\n\n/**\n * Returns members of array \"a\" before the array \"b\" subset.\n *\n * @param {Array} a \n * @param {Array} b \n * @param {Int} fromInex \n * @param {Bool} last \n * \n * @returns Bool\n */\nexport default function before(a, b, fromInex = null, last = false) {\n\tvar subsetIndex = _indexOfSet(a, b, fromInex, last);\n\treturn subsetIndex === -1 ? [] : a.slice(0, subsetIndex);\n}", "\n/**\n * @imports\n */\nimport _before from './before.js';\n\n/**\n * Returns members of array \"a\" before the last array \"b\" subset.\n *\n * @param {Array} a \n * @param {Array} b \n * @param {Int} fromInex \n * \n * @returns Bool\n */\nexport default function beforeLast(a, b, fromInex = null) {\n\treturn _before(a, b, fromInex, true);\n}", "\n/**\n * @imports\n */\nimport _isUndefined from '../js/isUndefined.js';\nimport _isFunction from '../js/isFunction.js';\n\n/**\n * 1. Returns the ENTRY following (either the FIRST or the LAST instance of) the reference.\n * 2. Returns A NUMBER OF ENTRIES counting forwards from (either the FIRST or the LAST instance of) the given reference.\n *\n * @param array \t\tarr\n * @param mixed\t \t\treference\n * @param int|bool \t\tlength\n * @param bool|function\t loop\n * @param bool\t \t\tlastReference\n *\n * @return mixed|array\n */\nexport default function(arr, reference, length = false, loop = false, lastReference = false) {\n\tif (arr.indexOf(reference) === -1) {\n\t\treturn length ? [] : undefined;\n\t}\n\tvar amount = length === true ? arr.length - 1 : (length === false ? 1 : length);\n\tvar from = lastReference ? arr.lastIndexOf(reference) + 1 : arr.indexOf(reference) + 1;\n\tvar after = !_isUndefined(reference) ? arr.slice(from, from + amount) : [];\n\tif (loop && after.length < amount && after.length < arr.length) {\n\t\tif (!_isFunction(loop) || loop(amount - after.length)) {\n\t\t\tafter = after.concat(arr.slice(0, amount - after.length));\n\t\t}\n\t};\n\treturn length ? after : after[0];\n};\n", "\n/**\n * @imports\n */\nimport _isUndefined from '../js/isUndefined.js';\nimport _isFunction from '../js/isFunction.js';\n\n/**\n * 1. Returns the ENTRY preceding (either the FIRST or the LAST instance of) the reference.\n * 2. Returns A NUMBER OF ENTRIES counting backwards from (either the FIRST or the LAST instance of) the given reference.\n *\n * @param array \t\tarr\n * @param mixed\t \t\treference\n * @param int|bool \t\tlength\n * @param bool|function\tloop\n * @param bool\t \t\tlastReference\n *\n * @return mixed|array\n */\nexport default function(arr, reference, length = false, loop = false, lastReference = false) {\n\tif (arr.indexOf(reference) === -1) {\n\t\treturn length ? [] : undefined;\n\t}\n\tvar amount = length === true ? arr.length - 1 : (length === false ? 1 : length);\n\tvar arr = arr.slice().reverse();\n\tvar from = lastReference ? arr.lastIndexOf(reference) + 1 : arr.indexOf(reference) + 1;\n\tvar before = !_isUndefined(reference) ? arr.slice(from, from + amount) : [];\n\tif (loop && before.length < amount && before.length < arr.length) {\n\t\tif (!_isFunction(loop) || loop(amount - before.length)) {\n\t\t\tbefore = before.concat(arr.slice(0, amount - before.length));\n\t\t}\n\t};\n\treturn length ? before : before[0];\n};\n", "\n/**\n * @imports\n */\nimport _following from './following.js';\nimport _preceding from './preceding.js';\nimport _isFunction from '../js/isFunction.js';\n\n/**\n * Returns ALL THE ENTRIES from (either the FIRST or the LAST instance of) the given reference UNTIL reference2,\n * in ltr/rtl direction.\n *\n * @param array \t\tarr\n * @param mixed\t \t\treference\n * @param mixed\t \t\treference2\n * @param bool\t \t\trtl\n * @param bool|function\tloop\n * @param bool\t \t\tlastReference\n *\n * @return array\n */\nexport default function(arr, reference, reference2, rtl = false, loop = false, lastReference = false) {\n\tvar from = lastReference ? arr.lastIndexOf(reference) : arr.indexOf(reference);\n\tvar to = lastReference ? arr.lastIndexOf(reference2) : arr.indexOf(reference2);\n\tif (rtl) {\n\t\tvar length = to > from \n\t\t\t? from/*the begining backward*/ + arr.length - to/*the other half*/\n\t\t\t: from - to;\n\t\treturn _preceding(arr, reference, length, remainder => {\n\t\t\treturn _isFunction(loop) ? loop(remainder, 'preceeding') : loop;\n\t\t}, lastReference);\n\t};\n\tvar length = to < from \n\t\t? arr.length - from - 1/*the remainder forward*/ + to + 1/*the other half*/\n\t\t: to - from;\n\treturn _following(arr, reference, length, remainder => {\n\t\t\treturn _isFunction(loop) ? loop(remainder, 'following') : loop;\n\t\t}, lastReference);\n};\n", "\n/**\n * Adds A LIST OF ITEMS after the FIRST instance of the given reference.\n *\n * @param array \tarr\n * @param mixed\t \treference\n * @param array\t \titms\n * @param bool\t \tlastReference\n *\n * @return array\n */\nexport default function(arr, reference, itms, lastReference = false) {\n\tvar secondHalf = arr.splice(lastReference ? arr.lastIndexOf(reference) + 1 : arr.indexOf(reference) + 1);\n\titms.concat(secondHalf).forEach(function(itm) {\n\t\tarr.push(itm);\n\t});\n\treturn arr;\n};\n", "\n/**\n * @imports\n */\nimport _concatAfter from './concatAfter.js';\n\n/**\n * Adds A LIST OF ITEMS after the LAST instance of the given reference.\n *\n * @param array \tarr\n * @param mixed\t \treference\n * @param array\t \titms\n *\n * @return array\n */\nexport default function(arr, reference, itms) {\n\treturn _concatAfter(arr, itms, reference, true/*lastReference*/);\n};\n", "\n/**\n * Adds A LIST OF ITEMS before the FIRST instance of the given reference.\n *\n * @param array \tarr\n * @param mixed\t \treference\n * @param array\t \titms\n * @param bool\t \tlastReference\n *\n * @return array\n */\nexport default function(arr, reference, itms, lastReference = false) {\n\tvar secondHalf = arr.splice(lastReference ? arr.lastIndexOf(reference) : arr.indexOf(reference));\n\titms.concat(secondHalf).forEach(function(itm) {\n\t\tarr.push(itm);\n\t});\n\treturn arr;\n};\n", "\n/**\n * @imports\n */\nimport _concatBefore from './concatBefore.js';\n\n/**\n * Adds A LIST OF ITEMS before the LAST instance of the given reference.\n *\n * @param array \tarr\n * @param mixed\t \treference\n * @param array\t \titms\n *\n * @return array\n */\nexport default function(arr, reference, itms) {\n\treturn _concatBefore(arr, reference, itms, true/*lastReference*/);\n};\n", "\n/**\n * @imports\n */\nimport _isArray from '../js/isArray.js';\nimport _isTypeArray from '../js/isTypeArray.js';\nimport _isEmpty from '../js/isEmpty.js';\nimport _isObject from '../js/isObject.js';\n\n/**\n * Casts an array-like object to an array.\n *\n * @param mixed \tval\n * @param bool\t \tcastObject\n *\n * @return array\n */\nexport default function(val, castObject = true) {\n\tif (_isArray(val)) {\n\t\treturn val;\n\t};\n\tif (!castObject && _isObject(val)) {\n\t\treturn [val];\n\t};\n\tif (val !== false && val !== 0 && _isEmpty(val)) {\n\t\treturn [];\n\t};\n\tif (_isTypeArray(val)) {\n\t\treturn Array.prototype.slice.call(val);\n\t};\n\tif (_isObject(val)) {\n\t\treturn Object.values(val);\n\t};\n\treturn [val];\n};\n", "\n/**\n * @imports\n */\nimport _pushUnique from './pushUnique.js';\nimport _from from './from.js';\n\n/**\n * Adds items that do not already exist.\n *\n * @param array \tarr\n * @param array\t \t...arrs\n *\n * @return array\n */\nexport default function(arr, ...arrs) {\n\tarrs.forEach(_arr => {\n\t\t_arr.forEach(itm => _pushUnique(arr, ..._from(_arr)));\n\t});\n\treturn arr;\n};\n", "\n/**\n * @imports\n */\nimport _arrFrom from './from.js';\n\n/**\n * Accepts an array where each entry is a segment of a path\n * (where each segment may be a compound segment (multiple possible values)),\n * returns an array of paths with compound segments exploded.\n * \n * ['a', 'b', 'c'] \t\t\t\t\t=> \t[ ['a', 'b', 'c'] ]\n * [ ['a'], 'b', ['c1', 'c2'] ] \t=> \t[\n * \t\t\t\t\t\t\t\t\t\t\t['a', 'b', 'c1']\n * \t\t\t\t\t\t\t\t\t\t\t['a', 'b', 'c2']\n * \t\t\t\t\t\t\t\t\t\t]\n * [ ['a'], 'b', ['c1', 'c2', 'c3] ]=> \t[\n * \t\t\t\t\t\t\t\t\t\t\t['a', 'b', 'c1']\n * \t\t\t\t\t\t\t\t\t\t\t['a', 'b', 'c2']\n * \t\t\t\t\t\t\t\t\t\t\t['a', 'b', 'c3']\n * \t\t\t\t\t\t\t\t\t\t]\n *\n * @param array \tarr\n *\n * @return number\n */\nexport default function(arr) {\n\treturn arr.reduce((currTable, column) => {\n\t\tvar newTable = [];\n\t\tcurrTable.forEach(row => {\n\t\t\t_arrFrom(column).forEach(column => {\n\t\t\t\tvar _row = row.slice();\n\t\t\t\t_row.push(column);\n\t\t\t\tnewTable.push(_row);\n\t\t\t});\n\t\t});\n\t\treturn newTable;\n\t}, [[]]);\n};", "\n/**\n * @imports\n */\nimport _isArray from '../js/isArray.js';\n\n/**\n * Returns the difference of two arrays;\n * optionally using a custom matching function.\n *\n * @param array \tarr\n * @param array\t \tarr2\n * @param function \tcallback\n *\n * @return array\n */\nexport default function(arr, arr2, callback = null) {\n\treturn !_isArray(arr2) ? [] : arr.filter(val1 => callback \n\t\t? arr2.filter(val2 => callback(val1, val2)).length \n\t\t: arr2.indexOf(val1) === -1\n\t);\n};\n", "\n/**\n * Makes a separation between items that pass a callback test and those that fail.\n *\n * @param array\t \t\t\t\tarr\n * @param function\t\t\t\tcallback\n *\t *\n * @return array\n */\nexport default function(arr, callback) {\n\tvar passes = [];\n\tvar failures = [];\n\tvar length = arr.length;\n\tfor (var i = 0; i < length; i++) {\n\t\tif (callback(arr[i])) {\n\t\t\tpasses.push(arr[i]);\n\t\t} else {\n\t\t\tfailures.push(arr[i]);\n\t\t};\n\t};\n\treturn [passes, failures];\n};\n", "\n/**\n * Tells if the array \"a\" ends with array \"b\".\n *\n * @param {Array} a \n * @param {Array} b \n * @param {Bool} dotSafe \n * \n * @returns Bool\n */\nexport default function startsWith(a, b, dotSafe = null) {\n\treturn dotSafe || (dotSafe !== false && a.dotSafe && b.dotSafe) \n\t\t? ('.' + a.join('.')).endsWith('.' + b.join('.')) \n\t\t: (a = a.slice(a.length - b.length)) && b.reduce((prev, value, i) => prev && value === a[i], true);\n}", "\n/**\n * Tells if two arrays are shallow equals.\n * \n * @param {Array} a \n * @param {Array} b \n * @param {Bool} dotSafe\n * \n * @returns Bool\n */\nexport default function equals(a, b, dotSafe = null) {\n\treturn dotSafe || (dotSafe !== false && a.dotSafe && b.dotSafe) \n\t\t? a.join('.') === b.join('.') \n\t\t: a.length === b.length && a.reduce((prev, value, i) => prev && value === b[i], true);\n}", "\n/**\n * @imports\n */\nimport _all from './all.js';\nimport _equals from './equals.js';\n\n/**\n * Tells if two arrays are up to z-level equals.\n *\n * @param {Array} a \n * @param {Array} b \n * @param {Bool} dotSafe \n * \n * @returns Bool\n */\nexport default function equals2D(a, b, dotSafe = null) {\n\treturn a.length === b.length && _all(a, (_a, i) => _equals(_a, b[i], dotSafe || (dotSafe !== false && a.dotSafe && b.dotSafe)));\n}", "\n/**\n * Removes instances of reference up to <limit> times.\n *\n * @param array \tarr\n * @param mixed\t \titm\n * @param int|bool \tlimit\n *\n * @return array\n */\nexport default function(arr, itm, limit = false) {\n\tvar i = arr.indexOf(itm);\n\twhile (i > -1 && (limit || limit === false)) {\n\t\tarr.splice(i, 1);\n\t\tif (limit > 0) {\n\t\t\tlimit --;\n\t\t};\n\t\ti = arr.indexOf(itm);\n\t};\n\treturn arr;\n};\n", "\n/**\n * @imports\n */\nimport _remove from './remove.js';\n\n/**\n * Removes all instances of each item.\n *\n * @param array \tarr\n * @param array\t \titms\n *\n * @return array\n */\nexport default function(arr, ...itms) {\n\titms.forEach(itm => _remove(arr, itm));\n\treturn arr;\n};\n", "\n/**\n * @imports\n */\nimport _divide from './divide.js';\n\n/**\n * Returns a list of items that pass a callback test.\n *\n * @param array\t \t\t\t\tarr\n * @param function\t\t\t\tcallback\n *\t *\n * @return array\n */\nexport default function(arr, callback) {\n\treturn _divide(arr, callback)[0];\n};\n", "\n/**\n * @imports\n */\nimport _isArray from '../js/isArray.js';\nimport _isObject from '../js/isObject.js';\nimport _isNumeric from '../js/isNumeric.js';\n\n/**\n * Flattens a nested array to the given depth.\n *\n * @param array \tarr\n * @param int \t \tdepth\n * @param bool \t \twithObjects\n *\n * @return array\n */\nconst _flatten = function(arr, depth = 1, withObjects = true) {\n\tif (!_isNumeric(depth) || depth <= 0) {\n\t\treturn arr;\n\t};\n\tif (!_isArray(arr) && _isObject(arr) && withObjects) {\n\t\tarr = Object.values(arr);\n\t};\n\tif (!_isArray(arr)) {\n\t\treturn arr;\n\t};\n\treturn arr.reduce((acc, val) => _isArray(val) || (_isObject(val) && withObjects) \n\t\t? acc.concat(_flatten(!_isArray(val) ? Object.values(val) : val, depth - 1, withObjects)) \n\t\t: acc.concat(val), []);\n};\n\n/**\n * @exports\n */\nexport default _flatten;", "\n/**\n * @imports\n */\nimport _following from './following.js';\n\n/**\n * Alias of _following() but uses last instance of reference.\n *\n * @param array \t\tarr\n * @param mixed\t \t\treference\n * @param int|bool \t\tlength\n * @param bool|function\tloop\n *\n * @return mixed|array\n */\nexport default function(arr, reference, length = false, loop = false) {\n\treturn _following(arr, reference, length, loop, true/*lastReference*/);\n};\n", "\n/**\n * @imports\n */\nimport _isArray from '../js/isArray.js';\nimport _isObject from '../js/isObject.js';\nimport _isBoolean from '../js/isBoolean.js';\nimport _isNumber from '../js/isNumber.js';\n\n/**\n * Calls callback with each item in the list and waits inbetween for each callback's promise to resolve.\n * The delay parameter may be used solely as the wait or as an addition to the promise-based wait.\n *\n * @param int|string|object \tinterval\n *\n * @return new Promise\n */\nexport default function(arr, callback, timing) {\n\tif (!_isArray(arr)) {\n\t\treturn;\n\t};\n\tif (_isObject(timing)) {\n\t\tvar sync = timing.sync || false;\n\t\tvar delay = timing.delay || 0;\n\t\tvar delayAlways = timing.delayAlways || false;\n\t} else {\n\t\tvar sync = _isBoolean(timing) || timing === 'last' ? timing : false;\n\t\tvar delay = _isNumber(timing) ? timing : 0;\n\t\tvar delayAlways = false;\n\t};\n\tvar items = arr;\n\tvar promise = new Promise(function(resolve, reject) {\n\t\tif (items.length) {\n\t\t\tvar call = function(i) {\n\t\t\t\tvar advance = () => {\n\t\t\t\t\t// Delay first before asking items.length\n\t\t\t\t\t// Good for progressivly adding new items\n\t\t\t\t\t// -----------------------\n\t\t\t\t\tif (delayAlways) {\n\t\t\t\t\t\tif (delay) {\n\t\t\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\t\t\tif (items.length > i + 1) {\n\t\t\t\t\t\t\t\t\tcall(i + 1);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tresolve()\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}, delay);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (items.length > i + 1) {\n\t\t\t\t\t\t\t\tcall(i + 1);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tresolve()\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t};\n\t\t\t\t\t// Ask items.length first before delay\n\t\t\t\t\t// Good for when delay should only be BETWEEN items\n\t\t\t\t\t// -----------------------\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (items.length > i + 1) {\n\t\t\t\t\t\t\tif (delay) {\n\t\t\t\t\t\t\t\tsetTimeout(() => {call(i + 1);}, delay);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcall(i + 1);\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresolve()\n\t\t\t\t\t\t};\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t\tvar ret = callback(items[i]);\n\t\t\t\tif (ret instanceof Promise && (sync === true || (sync === 'last' && i === items.length - 1))) {\n\t\t\t\t\t// On any of the outcomes...\n\t\t\t\t\tret.then(advance);\n\t\t\t\t\tret.catch(advance);\n\t\t\t\t} else {\n\t\t\t\t\tadvance();\n\t\t\t\t};\n\t\t\t};\n\t\t\tcall(0);\n\t\t} else {\n\t\t\tresolve();\n\t\t};\n\t});\n\treturn promise;\n};\n", "/**\n * \n * @imports\n */\nimport _indexOfSet from './indexOfSet.js';\n\n/**\n * Returns the last index of subset array \"b\" in array \"a\".\n * \n * @param {Array} a \n * @param {Array} b \n * @param {Int} fromInex \n * \n * @returns Int\n */\nexport default function lastIndexOfSet(a, b, fromInex = null) {\n\treturn _indexOfSet(a, b, fromInex, true);\n}", "\n/**\n * Gets the maximum of an array of numbers.\n *\n * @param array \tarr\n *\n * @return number\n */\nexport default function(arr) {\n\tarr = arr.slice();\n\treturn arr.reduce((v1, v2) => Math.max(v1, v2), arr.shift());\n};\n", "\n/**\n * Returns the middle item of an array.\n *\n * @param array \tarr\n * @param bool \t\tall\n *\n * @return any\n */\nexport default function(arr, all = false) {\n\tvar mid = [];\n\tif (arr.length) {\n\t\tif (arr.length % 2) {\n\t\t\tvar start = Math.round(arr.length / 2) - 1;\n\t\t\tmid = arr.slice(start, start + 1);\n\t\t} else {\n\t\t\tvar start = (arr.length / 2) - 1;\n\t\t\tmid = arr.slice(start, start + 2);\n\t\t}\n\t}\n\treturn all ? mid : mid[0];\n};\n", "\n/**\n * Gets the minimum of an array of numbers.\n *\n * @param array \tarr\n *\n * @return number\n */\nexport default function(arr) {\n\tarr = arr.slice();\n\treturn arr.reduce((v1, v2) => Math.min(v1, v2), arr.shift());\n};\n", "\n/**\n * @imports\n */\nimport _preceding from './preceding.js';\n\n/**\n * Alias of _preceding() but uses last instance of reference.\n *\n * @param array \t\tarr\n * @param mixed\t \t\treference\n * @param int|bool \t\tlength\n * @param bool|function\tloop\n *\n * @return mixed|array\n */\nexport default function(arr, reference, length = false, loop = false) {\n\treturn _preceding(arr, reference, length, loop, true/*lastReference*/);\n};\n", "\n/**\n * Gets one or more random values from an array.\n *\n * @param array \tarr\n * @param int\t \tamount\n *\n * @return mixed|array\n */\nexport default function(arr, amount = 1) {\n\tvar result = [];\n\tvar rand = null;\n\twhile (result.length < amount && (rand = arr[Math.floor(Math.random() * arr.length)]) && result.indexOf(rand) === -1) {\n\t\tresult.push(rand);\n\t};\n\treturn arguments.length > 1 ? result : result[0];\n};\n", "\n/**\n * @imports\n */\nimport _each from '../obj/each.js';\n\n/**\n * Removes an item.\n *\n * @param array \tarr\n * @param array\t \titms\n * @param array\t \treplacements\n *\n * @return array\n */\nexport default function(arr, itms, replacements = []) {\n\tif (arguments.length === 2) {\n\t\titms.forEach((itm, i) => {arr[i] = itm;});\n\t\treturn arr;\n\t};\n\t_each(itms, (k, reference) => {\n\t\tvar i = arr.indexOf(reference);\n\t\tif (i !== -1) {\n\t\t\tarr[i] = replacements[k];\n\t\t};\n\t});\n\treturn arr;\n};\n", "\n/**\n * Array slicing with support for negative offsets.\n *\n * @param array\t \t\t\t\tarr\n * @param array\t \t\t\t\toffset\n * @param array\t \t\t\t\tlengthOrOffset2\n *\t *\n * @return array\n */\nexport default function(arr, offset = 0, lengthOrOffset2 = null) {\n\tif (arguments.length > 1) {\n\t\toffset = offset < 0 ? (arr.length + offset)/*subtraction eventually*/ : offset;\n\t\tif (arguments.length > 2) {\n\t\t\tlengthOrOffset2 = lengthOrOffset2 < 0 ? (arr.length + lengthOrOffset2)/*subtraction eventually*/ - offset : lengthOrOffset2;\n\t\t};\n\t};\n\treturn arr.slice(offset, lengthOrOffset2);\n};\n", "\n/**\n * @imports\n */\nimport _isString from '../js/isString.js';\n\n/**\n * Sorts a list performantly.\n *\n * @param array\t \t\t\t\t\tarr\n * @param string\t \t\t\t\torder\t\t\tASC|DESC \n * @param function\t\t\t\t\tcallback\n *\n * @return array\n */\nexport default function(arr, order, callback = null) {\n\tvar _arr = [];\n\t// Make a shallow copy\n\tvar length = arr.length;\n\tfor (var i = 0; i < length; i ++) {\n\t\t_arr.push({index: i, value: callback ? callback(arr[i]) : arr[i]});\n\t};\n\t_arr.sort(function(a, b) {\n\t\t// Using localeCompare if possible\n\t\tif (_isString(a.value) && \"\".localeCompare) {\n\t\t\treturn a.value.localeCompare(b.value);\n\t\t};\n\t\treturn a.value === b.value ? 0 : a.value > b.value ? 1 : -1;\n\t});\n\tif ((order || '').trim().toLowerCase() === 'desc') {\n\t\t_arr = _arr.reverse();\n\t};\n\t// Fill the order with actual values\n\treturn _arr.map(itm => arr[itm.index]);\n};\n", "\n/**\n * Tells if the array \"a\" starts with array \"b\".\n *\n * @param {Array} a \n * @param {Array} b \n * @param {Bool} dotSafe \n * \n * @returns Bool\n */\nexport default function startsWith(a, b, dotSafe = null) {\n\treturn dotSafe || (dotSafe !== false && a.dotSafe && b.dotSafe) \n\t\t? (a.join('.') + '.').startsWith(b.join('.') + '.') \n\t\t: b.reduce((prev, value, i) => prev && value === a[i], true);\n}", "\n/**\n * Returns a list of unique items.\n *\n * @param array\t \t\t\t\tarr\n *\t *\n * @return array\n */\nexport default function(arr) {\n\tconst distinct = (value, index, self) => {\n\t\treturn self.indexOf(value) === index;\n\t};\n\treturn arr.filter(distinct);\n};\n", "\n/**\n * @imports\n * \"arr\" category of modules.\n */\nimport _after from './after.js';\nimport _afterLast from './afterLast.js';\nimport _all from './all.js';\nimport _any from './any.js';\nimport _avg from './avg.js';\nimport _before from './before.js';\nimport _beforeLast from './beforeLast.js';\nimport _between from './between.js';\nimport _concatAfter from './concatAfter.js';\nimport _concatAfterLast from './concatAfterLast.js';\nimport _concatBefore from './concatBefore.js';\nimport _concatBeforeLast from './concatBeforeLast.js';\nimport _concatUnique from './concatUnique.js';\nimport _crossJoin from './crossJoin.js';\nimport _difference from './difference.js';\nimport _divide from './divide.js';\nimport _endsWith from './endsWith.js';\nimport _equals from './equals.js';\nimport _equals2D from './equals2D.js';\nimport _exclude from './exclude.js';\nimport _filter from './filter.js';\nimport _first from './first.js';\nimport _flatten from './flatten.js';\nimport _following from './following.js';\nimport _followingLast from './followingLast.js';\nimport _from from './from.js';\nimport _indexOfSet from './indexOfSet.js';\nimport _inSequence from './inSequence.js';\nimport _intersect from './intersect.js';\nimport _last from './last.js';\nimport _lastIndexOfSet from './lastIndexOfSet.js';\nimport _max from './max.js';\nimport _mid from './mid.js';\nimport _min from './min.js';\nimport _preceding from './preceding.js';\nimport _precedingLast from './precedingLast.js';\nimport _pushUnique from './pushUnique.js';\nimport _rand from './rand.js';\nimport _remove from './remove.js';\nimport _replace from './replace.js';\nimport _slice from './slice.js';\nimport _sort from './sort.js';\nimport _startsWith from './startsWith.js';\nimport _sum from './sum.js';\nimport _unique from './unique.js';\n\n/**\n * @exports\n */\nexport {\n\t_after,\n\t_afterLast,\n\t_all,\n\t_any,\n\t_avg,\n\t_before,\n\t_beforeLast,\n\t_between,\n\t_concatAfter,\n\t_concatAfterLast,\n\t_concatBefore,\n\t_concatBeforeLast,\n\t_concatUnique,\n\t_crossJoin,\n\t_difference,\n\t_divide,\n\t_endsWith,\n\t_equals,\n\t_equals2D,\n\t_exclude,\n\t_filter,\n\t_first,\n\t_flatten,\n\t_following,\n\t_followingLast,\n\t_from,\n\t_indexOfSet,\n\t_inSequence,\n\t_intersect,\n\t_last,\n\t_lastIndexOfSet,\n\t_max,\n\t_mid,\n\t_min,\n\t_preceding,\n\t_precedingLast,\n\t_pushUnique,\n\t_rand,\n\t_remove,\n\t_replace,\n\t_slice,\n\t_sort,\n\t_startsWith,\n\t_sum,\n\t_unique,\n}\n", "\n/**\n * @imports\n */\nimport { _wq as __wq } from '@webqit/util/js/index.js';\n\nexport const _wq = ( target, ...args ) => __wq( target, 'observerAPI', ...args );\n\nexport const _await = ( value, callback ) => value instanceof Promise ? value.then( callback ) : callback( value );\n\nexport const env = {};\n", "\n/**\n * ---------------------------\n * The Registration class\n * ---------------------------\n */\n\nexport default class Registration {\n\t\n\t/**\n\t * Initializes the instance.\n\t *\n\t * @param Registry\t\t\tregistry\n\t * @param object\t\t\tdfn\n\t *\n\t * @return void\n\t */\n\tconstructor( registry, dfn ) {\n\t\tthis.registry = registry;\n\t\tObject.assign( this, { ...dfn, target: registry.target } );\n\t\tif ( this.params.signal ) {\n\t\t\tthis.params.signal.addEventListener( 'abort', () => this.remove() );\n\t\t}\n\t}\n\n\t/**\n\t * Sets a \"disconnected\" flag on the Registration.\n\t *\n\t * @return void\n\t */\n\tremove() {\n\t\tthis.removed = true;\n\t\treturn this.registry.removeRegistration( this );\n\t}\n}", "\n/**\n * @imports\n */\nimport { _from as _arrFrom } from '@webqit/util/arr/index.js';\nimport Registration from './Registration.js';\nimport { _await, env } from '../util.js';\n\n/**\n * ---------------------------\n * The ListenerRegistration class\n * ---------------------------\n */\n\nexport default class ListenerRegistration extends Registration {\n\t\n\t/**\n\t * @constructor\n\t */\n\tconstructor() {\n\t\tsuper( ...arguments );\n\t\tthis.emit.currentRegistration = this;\n\t\tObject.defineProperty( this, 'abortController', { value: new AbortController } );\n\t\tObject.defineProperty( this, 'signal', { value: this.abortController.signal } );\n\t\tenv.setMaxListeners?.( 0, this.signal );\n\t}\n\n\t/**\n\t * De-registers the instance.\n\t * \n\t * @return Void\n\t */\n\tremove() {\n\t\tthis.abortController.abort();\n\t\tsuper.remove();\n\t}\n\n\t/**\n\t * Calls the observer's handler function\n\t * on matching with the event's fields.\n\t *\n\t * @param Array\t\t\t \t\tevents\n\t *\n\t * @return Any\n\t */\n\tfire( events ) {\n\t\tif ( this.emit.recursionTarget && ![ 'inject', 'force-async', 'force-sync' ].includes( this.params.recursions ) ) return;\n\t\tlet matches = events, filter = this.filter;\n\t\tif ( filter !== Infinity && ( filter = _arrFrom( filter, false ) ) ) {\n\t\t\tmatches = events.filter( event => filter.includes( event.key ) );\n\t\t}\n\t\tif ( this.params.diff ) {\n\t\t\tmatches = matches.filter( event => event.type !== 'set' || event.value !== event.oldValue );\n\t\t}\n\t\tif ( !matches.length ) return;\n\t\tif ( [ 'inject', 'defer' ].includes( this.params.recursions ) ) {\n\t\t\tif ( this.emit.recursionTarget ) {\n\t\t\t\tthis.emit.recursionTarget.push( ...matches );\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.emit.recursionTarget = this.params.recursions === 'inject' ? matches : [];\n\t\t}\n\t\tconst $ret = this.filter === Infinity || Array.isArray( this.filter )\n\t\t\t? this.emit( matches, this )\n\t\t\t: this.emit( matches[ 0 ], this );\n\t\t// NOTEL: on calling emit(), this registration has expired and a new one active!!!\n\t\treturn _await( $ret, ret => {\n\t\t\tconst recursions = this.emit.recursionTarget;\n\t\t\tdelete this.emit.recursionTarget;\n\t\t\tif ( this.params.recursions === 'defer' ) {\n\t\t\t\tif ( recursions?.length ) return this.emit.currentRegistration.fire( recursions );\n\t\t\t}\n\t\t\treturn ret;\n\t\t} );\n\t}\n}\n", "\n/**\n * @imports\n */\nimport { _isTypeObject, _getType } from '@webqit/util/js/index.js';\nimport { _from as _arrFrom, _intersect, _equals as _arrEquals } from '@webqit/util/arr/index.js';\nimport { _wq } from '../util.js';\n\n/**\n * ---------------------------\n * The Registry class\n * ---------------------------\n */\n\nexport default class Registry {\n\t\n\t/**\n\t * Initializes the instance.\n\t *\n\t * @param object\ttarget\n\t * \n\t * @return void\n\t */\n\tconstructor( target ) {\n\t\tthis.target = target;\n\t\tthis.entries = [];\n\t}\n\t\n\t/**\n\t * Adds an Registration instance\n\t * with optional tags.\n\t *\n\t * @param Registration\t\tregistration\n\t *\n\t * @return Registration\n\t */\n\taddRegistration( registration ) {\n\t\tthis.entries.push( registration );\n\t\treturn registration;\n\t}\n\t\n\t/**\n\t * Removes registrations by reference.\n\t *\n\t * @param Registration\t\tregistration\n\t *\n\t * @return void\n\t */\n\tremoveRegistration( registration ) {\n\t\tthis.entries = this.entries.filter( _entry => _entry !== registration );\n\t}\n\t\t\n\t/**\n\t * Returns a observer-specific object embedded on an element.\n\t *\n\t * @param string\t\ttype\n\t * @param array|object\ttarget\n\t * @param bool      \tcreateIfNotExists\n\t * @param string      \tnamespace\n\t *\n\t * @return Registry\n\t */\n\tstatic _getInstance( type, target, createIfNotExists = true, namespace = this.__namespace ) {\n\t\tif ( !_isTypeObject( target ) ) throw new Error( `Subject must be of type object; \"${ _getType( target ) }\" given!` );\n\t\tlet ImplementationClass = this;\n\t\tif ( namespace && _wq( globalThis, 'observerAPI', 'namespaces' ).has( type + '-' + namespace ) ) {\n\t\t\tImplementationClass = _wq( globalThis, 'observerAPI', 'namespaces' ).get( type + '-' + namespace );\n\t\t\ttype += '-' + namespace\n\t\t}\n\t\tif ( !_wq( target, 'registry' ).has( type ) && createIfNotExists ) {\n\t\t\t_wq( target, 'registry' ).set( type, new ImplementationClass( target ) );\n\t\t}\n\t\treturn _wq( target, 'registry' ).get( type );\n\t}\n\n\t/**\n\t * Extend a Fireable Class with a namespace.\n\t *\n\t * @param string\t\tnamespace\n\t * @param class      \tImplementationClass\n\t *\n\t * @return void|class\n\t */\n\tstatic _namespace( type, namespace, ImplementationClass = null ) {\n\t\ttype += '-' + namespace;\n\t\tif ( arguments.length === 2 ) return _wq( globalThis, 'observerAPI', 'namespaces' ).get( type );\n\t\tif ( !( ImplementationClass.prototype instanceof this ) ) {\n\t\t\tthrow new Error( `The implementation of the namespace ${ this.name }.${ namespace } must be a subclass of ${ this.name }.` );\n\t\t}\n\t\t_wq( globalThis, 'observerAPI', 'namespaces' ).set( type, ImplementationClass );\n\t\tImplementationClass.__namespace = namespace;\n\t}\n}", "\n/**\n * ---------------------------\n * The Descriptor class\n * ---------------------------\n */\n\nexport default class Descriptor {\n\t\n\t/**\n\t * Initializes the instance.\n\t *\n\t * @param array|object\ttarget\n\t * @param object\t\tdfn\n\t *\n\t * @return void\n\t */\n\tconstructor( target, dfn ) {\n\t\tthis.target = target;\n\t\tif ( !( dfn.operation ) ) throw new Error( 'Descriptor operation must be given in definition!' );\n\t\tObject.assign( this, dfn );\n\t}\n}", "\n/**\n * @imports\n */\nimport ListenerRegistration from './ListenerRegistration.js';\nimport Registry from './Registry.js';\nimport { _await } from '../util.js';\nimport Descriptor from './Descriptor.js';\n\n/**\n * ---------------------------\n * The ListenerRegistry class\n * ---------------------------\n */\n\nexport default class ListenerRegistry extends Registry {\n\n\tstatic getInstance( target, createIfNotExists = true, namespace = null ) {\n\t\treturn super._getInstance( 'listeners', ...arguments );\n\t}\n\n\tstatic namespace( namespace, ImplementationClass = null ) {\n\t\treturn super._namespace( 'listeners', ...arguments );\n\t}\n\n\t/**\n\t * @constructor\n\t */\n\tconstructor( target ) {\n\t\tsuper( target );\n\t\tthis.batches = [];\n\t}\n\t\n\t/**\n\t * @addRegistration\n\t */\n\taddRegistration( filter, emit, params ) {\n\t\treturn super.addRegistration( new ListenerRegistration( this, { filter, emit, params } ) );\n\t}\n\t\n\t/**\n\t * Fires all observers with the given evt (change).\n\t *\n\t * @param Arrayn events\n\t *\n\t * @return Void\n\t */\n\temit( events, { eventsArePropertyDescriptors = false, eventIsArrayMethodDescriptor = false } = {} ) {\n\t\tif ( this.batches.length ) {\n\t\t\tconst arrayMethodName = this.batches[ 0 ].params.arrayMethodName;\n\t\t\tthis.batches[ 0 ].snapshots.push( {\n\t\t\t\tevents: [ ...events ],\n\t\t\t\tarrayMethodName, // Typically from array operations\n\t\t\t\teventsArePropertyDescriptors, // Typically from defineProperty() operations\n\t\t\t\teventIsArrayMethodDescriptor // Typically from array method operations\n\t\t\t} );\n\t\t\treturn\n\t\t}\n\t\tthis.$emit( this.entries, [ {\n\t\t\tevents, \n\t\t\teventsArePropertyDescriptors, // Typically from defineProperty() operations\n\t\t\teventIsArrayMethodDescriptor // Typically from array method operations\n\t\t} ] );\n\t}\n\n\t$emit( listeners, snapshots ) {\n\t\t// Analyse listener modes\n\t\tlet listenersLength = 0,\n\t\tlistenersAskingEventsWithPropertyDescriptors = 0,\n\t\tlistenersAskingArrayMethodDescriptors = 0;\n\t\tfor ( const listener of listeners ) {\n\t\t\tlistenersLength += 1;\n\t\t\tif ( listener.params.withPropertyDescriptors ) {\n\t\t\t\tlistenersAskingEventsWithPropertyDescriptors += 1;\n\t\t\t}\n\t\t\tif ( listener.params.withArrayMethodDescriptors ) {\n\t\t\t\tlistenersAskingArrayMethodDescriptors += 1;\n\t\t\t}\n\t\t}\n\t\t// Sort events\n\t\tconst events_with_PropertyDescriptors_with_ArrayMethodDescriptors = [], events_with_PropertyDescriptors_without_ArrayMethodDescriptors = [];\n\t\tconst events_without_PropertyDescriptors_with_ArrayMethodDescriptors = [], events_without_PropertyDescriptors_without_ArrayMethodDescriptors = [];\n\t\tfor ( const snapshot of snapshots ) {\n\t\t\tconst arrayMethodName = snapshot.arrayMethodName;\n\t\t\tconst eventsArePropertyDescriptors = snapshot.eventsArePropertyDescriptors;\n\t\t\tconst eventIsArrayMethodDescriptor = snapshot.eventIsArrayMethodDescriptor;\n\t\t\tfor ( const event of snapshot.events ) {\n\t\t\t\tif ( arrayMethodName ) {\n\t\t\t\t\tevent.operation = arrayMethodName;\n\t\t\t\t}\n\t\t\t\t// Some opting in to PropertyDescriptors\n\t\t\t\tif ( listenersAskingEventsWithPropertyDescriptors ) {\n\t\t\t\t\t//if ( !arrayMethodName ) { }\n\t\t\t\t\tlistenersAskingArrayMethodDescriptors && // Some opting in to ArrayMethodDescriptors\n\t\t\t\t\tevents_with_PropertyDescriptors_with_ArrayMethodDescriptors.push( event );\n\t\t\t\t\tif ( !eventIsArrayMethodDescriptor ) {\n\t\t\t\t\t\tlistenersAskingArrayMethodDescriptors !== listenersLength && // Some opting out of ArrayMethodDescriptors\n\t\t\t\t\t\tevents_with_PropertyDescriptors_without_ArrayMethodDescriptors.push( event );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Some opting out of PropertyDescriptors\n\t\t\t\tif ( listenersAskingEventsWithPropertyDescriptors !== listenersLength ) {\n\t\t\t\t\tlet $event = event;\n\t\t\t\t\tif ( eventsArePropertyDescriptors ) {\n\t\t\t\t\t\tconst { target, type, ...details } = event;\n\t\t\t\t\t\t$event = new Descriptor( target, { type: 'set', ...details } );\n\t\t\t\t\t\tObject.defineProperty( $event, 'value', 'get' in details.value ? { get: () => details.value.get() } : { value: details.value.value } )\n\t\t\t\t\t\tif ( details.oldValue ) {\n\t\t\t\t\t\t\tObject.defineProperty( $event, 'oldValue', 'get' in details.oldValue ? { get: () => details.oldValue.get() } : { value: details.oldValue.value } )\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//if ( !arrayMethodName/*Although eedless as is typically mutually exclusive to eventsArePropertyDescriptors*/ ) { }\n\t\t\t\t\tlistenersAskingArrayMethodDescriptors && // Some opting in to ArrayMethodDescriptors\n\t\t\t\t\tevents_without_PropertyDescriptors_with_ArrayMethodDescriptors.push( $event );\n\t\t\t\t\tif ( !eventIsArrayMethodDescriptor ) { // Although eedless as is typically already implied by eventsArePropertyDescriptors\n\t\t\t\t\t\tlistenersAskingArrayMethodDescriptors !== listenersLength && // Some opting out of ArrayMethodDescriptors\n\t\t\t\t\t\tevents_without_PropertyDescriptors_without_ArrayMethodDescriptors.push( $event );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Dispatch\n\t\tfor ( const listener of listeners ) {\n\t\t\tif ( listener.params.withPropertyDescriptors ) {\n\t\t\t\tif ( listener.params.withArrayMethodDescriptors ) {\n\t\t\t\t\tevents_with_PropertyDescriptors_with_ArrayMethodDescriptors.length &&\n\t\t\t\t\tlistener.fire( events_with_PropertyDescriptors_with_ArrayMethodDescriptors );\n\t\t\t\t} else {\n\t\t\t\t\tevents_with_PropertyDescriptors_without_ArrayMethodDescriptors.length &&\n\t\t\t\t\tlistener.fire( events_with_PropertyDescriptors_without_ArrayMethodDescriptors );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif ( listener.params.withArrayMethodDescriptors ) {\n\t\t\t\t\tevents_without_PropertyDescriptors_with_ArrayMethodDescriptors.length &&\n\t\t\t\t\tlistener.fire( events_without_PropertyDescriptors_with_ArrayMethodDescriptors );\n\t\t\t\t} else {\n\t\t\t\t\tevents_without_PropertyDescriptors_without_ArrayMethodDescriptors.length &&\n\t\t\t\t\tlistener.fire( events_without_PropertyDescriptors_without_ArrayMethodDescriptors );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Fires all observers with the given evt (change).\n\t *\n\t * @param Arrayn events\n\t *\n\t * @return Void\n\t */\n\tbatch( callback, params = {} ) {\n\t\tthis.batches.unshift( { entries: [ ...this.entries ], snapshots: [], params } );\n\t\tconst returnValue = callback();\n\t\treturn _await( returnValue, returnValue => {\n\t\t\tconst batch = this.batches.shift();\n\t\t\tif ( !batch.snapshots.length ) return returnValue;\n\t\t\tthis.$emit( batch.entries, batch.snapshots );\n\t\t\treturn returnValue;\n\t\t} );\n\t}\n\n}\n", "\n/**\n * @imports\n */\nimport Registration from './Registration.js';\n\n/**\n * ---------------------------\n * The TrapsRegistration class\n * ---------------------------\n */\n\nexport default class TrapsRegistration extends Registration {\n\t\n\t/**\n\t * Calls the observer's handler function\n\t * on matching with the descriptor's fields.\n\t *\n\t * @param Descriptor\t\t\t \tdescriptor\n\t * @param function\t\t\t\t\tnext\n\t * @param mixed\t\t\t\t\t \trecieved\n\t *\n\t * @return void\n\t */\n\texec( descriptor, next, recieved ) {\n\t\tif ( this.running || !this.traps[ descriptor.operation ] ) {\n\t\t\treturn next( ...Array.prototype.slice.call( arguments, 2 ) );\n\t\t}\n\t\tthis.running = true;\n\t\treturn this.traps[ descriptor.operation ]( descriptor, recieved, ( ...args ) => {\n\t\t\tthis.running = false;\n\t\t\treturn next( ...args );\n\t\t} );\n\t}\n}", "\n/**\n * @imports\n */\nimport TrapsRegistration from './TrapsRegistration.js';\nimport Registry from './Registry.js';\n\n/**\n * ---------------------------\n * The TrapsRegistry class\n * ---------------------------\n */\n\nexport default class TrapsRegistry extends Registry {\n\n\tstatic getInstance( target, createIfNotExists = true, namespace = null ) {\n\t\treturn super._getInstance( 'traps', ...arguments );\n\t}\n\n\tstatic namespace( namespace, ImplementationClass = null ) {\n\t\treturn super._namespace( 'traps', ...arguments );\n\t}\n\t\n\t/**\n\t * @inheritdoc\n\t */\n\taddRegistration( dfn ) {\n\t\treturn super.addRegistration( new TrapsRegistration( this, dfn ) );\n\t}\n\n\t/**\n\t * Fires all interceptors with the given action.\n\t *\n\t * @param Descriptor\t\tdescriptor\n\t * @param function\t\t\tdefaultHandler\n\t *\n\t * @return mixed\n\t */\n\temit( descriptor, defaultHandler = null ) {\n\t\tconst $this = this;\n\t\treturn ( function next( index, ..._args ) {\n\t\t\tconst registration = $this.entries[ index ];\n\t\t\tif ( registration ) {\n\t\t\t\treturn registration.exec( descriptor, ( ...args ) => {\n\t\t\t\t\treturn next( index + 1, ...args );\n\t\t\t\t}/*next*/, ..._args );\n\t\t\t}\n\t\t\treturn defaultHandler ? defaultHandler( descriptor, ..._args ) : _args[ 0 ];\n\t\t} )( 0 );\n\t}\n}", "\n/**\n * @imports\n */\nimport { _from as _arrFrom } from '@webqit/util/arr/index.js';\nimport { _isClass, _isFunction, _isTypeObject, _getType } from '@webqit/util/js/index.js';\nimport { set, deleteProperty, has, get, ownKeys, defineProperty, getOwnPropertyDescriptor } from \"./main.js\";\nimport { apply, construct, getPrototypeOf, setPrototypeOf, isExtensible, preventExtensions } from \"./main.js\";\nimport { _wq } from './util.js';\n\n/* ---------------ACCESSORIZE METHODS--------------- */\n\n/**\n * Accessorizes props.\n *\n * @param Array|Object\ttarget\n * @param String|Array\tprops\n * @param Object\t\tparams\n *\n * @return Array\n */\nconst symWQOriginal = Symbol('wqOriginal');\nexport function accessorize( target, props, params = {} ) {\n    target = resolveTarget( target );\n    const accessorizedProps = _wq( target, 'accessorizedProps' );\n    // ---------\n    function getDescriptorDeep( prop ) {\n        let descriptor, proto = target;\n        do {\n            descriptor = Object.getOwnPropertyDescriptor( proto, prop );\n        } while ( !descriptor && ( proto = Object.getPrototypeOf( proto ) ) );\n        return descriptor \n            ? { proto, descriptor } \n            : { descriptor: { value: undefined, configurable: true, enumerable: true, writable: true } };\n    }\n    // ---------\n    function accessorizeProp( prop ) {\n        if ( accessorizedProps.has( prop + '' ) ) return true;\n        // ------------------\n        // Current Descriptor Record\n        const currentDescriptorRecord = getDescriptorDeep( prop );\n        currentDescriptorRecord.getValue = function( withPropertyDescriptors = false ) {\n            if ( withPropertyDescriptors ) return this.descriptor;\n            return this.descriptor.get ? this.descriptor.get() : this.descriptor.value;\n        };\n        currentDescriptorRecord.setValue = function( value, withPropertyDescriptors = false ) {\n            this.dirty = true;\n            if ( withPropertyDescriptors ) { this.descriptor = value; return; }\n            return this.descriptor.set ? this.descriptor.set( value ) !== false : ( this.descriptor.value = value, true );\n        };\n        currentDescriptorRecord.intact = function() {\n            const currentDescriptor = Object.getOwnPropertyDescriptor( target, prop );\n            return currentDescriptor?.get === accessorization.get \n                && currentDescriptor?.set === accessorization.set\n                && accessorizedProps.get( prop + '' ) === this;\n        };\n        currentDescriptorRecord.restore = function() {\n            if ( !this.intact() ) return false;\n            if ( ( this.proto && this.proto !== target ) || ( !this.proto && !this.dirty ) ) { delete target[ prop ]; }\n            else { Object.defineProperty( target, prop, this.descriptor ); }\n            accessorizedProps.delete( prop + '' );\n            return true;\n        };\n        accessorizedProps.set( !isNaN( prop ) ? parseInt( prop ) : prop, currentDescriptorRecord );\n        // ------------------\n        // enumerable, configurable\n        const { enumerable = true } = currentDescriptorRecord.descriptor;\n        const accessorization = { enumerable, configurable: true };\n        // set, get\n        if ( ( 'value' in currentDescriptorRecord.descriptor ) || currentDescriptorRecord.descriptor.set ) {\n            accessorization.set = function ( value ) { return set( this, prop, value, params ); };\n        }\n        if ( ( 'value' in currentDescriptorRecord.descriptor ) || currentDescriptorRecord.descriptor.get ) {\n            accessorization.get = function () { return get( this, prop, params ); };\n        }\n        try {\n            Object.defineProperty( target, prop, accessorization );\n            return true;\n        } catch( e ) {\n            accessorizedProps.delete( prop + '' );\n            return false;\n        }\n    }\n    const _props = Array.isArray( props ) ? props : (\n        props === undefined ? Object.keys( target ) : [ props ]\n    );\n    const statuses = _props.map( accessorizeProp );\n    return props === undefined || Array.isArray( props ) \n        ? statuses \n        : statuses[ 0 ];\n}\n\n/**\n * Unaccessorizes previously accessorized props.\n *\n * @param Array|Object\ttarget\n * @param String|Array\tprops\n * @param Object\t\tparams\n *\n * @return Array\n */\nexport function unaccessorize( target, props, params = {} ) {\n    target = resolveTarget( target );\n    const accessorizedProps = _wq( target, 'accessorizedProps' );\n    function unaccessorizeProp( prop ) {\n        if ( !accessorizedProps.has( prop + '' ) ) return true;\n        return accessorizedProps.get( prop + '' ).restore();\n    }\n    const _props = Array.isArray( props ) ? props : (\n        props === undefined ? Object.keys( target ) : [ props ]\n    );\n    const statuses = _props.map( unaccessorizeProp );\n    return props === undefined || Array.isArray( props ) \n        ? statuses \n        : statuses[ 0 ];\n}\n\n/* ---------------PROXY METHODS--------------- */\n\n/**\n * Returns an object as a proxy and binds all instance methods\n * to the proxy instead of the object itself.\n *\n * @param Array|Object\t\ttarget\n * @param Object\t\t    params\n * @param Function\t\t    extendCallback\n *\n * @return Proxy\n */\nexport function proxy( target, params = {}, extendCallback = undefined ) {\n    // Resolve target\n    const originalTarget = resolveTarget( target );\n    // Return same proxy instance?\n    if ( typeof params.membrane === 'boolean' ) throw new Error( `The params.membrane parameter cannot be of type boolean.` );\n    if ( params.membrane && _wq( originalTarget, 'membraneRef' ).has( params.membrane ) ) { return _wq( originalTarget, 'membraneRef' ).get( params.membrane ); }\n    const traps = {\n        apply: ( target, thisArgument, argumentsList ) => apply( target, thisArgument, argumentsList, undefined, params ),\n        construct:  ( target, argumentsList, newTarget = null ) => construct( target, argumentsList, newTarget, params ),\n        defineProperty:  ( target, propertyKey, attributes ) => defineProperty( target, propertyKey, attributes, params ),\n        deleteProperty: ( target, propertyKey ) => deleteProperty( target, propertyKey, params ),\n        get: ( target, propertyKey, receiver = null ) => {\n            if ( propertyKey === symWQOriginal ) {\n                return originalTarget;\n            }\n            const $params = { ...params, receiver };\n            const returnValue = get( target, propertyKey, $params );\n            // Auto-wrap array methods\n            if ( Array.isArray( target ) && typeof returnValue === 'function' && !/^class\\s?/.test(Function.prototype.toString.call( returnValue ) ) ) {\n                return proxy( returnValue, { ...params, arrayMethodName: propertyKey, membrane: receiver/* the instance obj that will be the thisArgument at apply(). Much like function.bind() */ }, extendCallback );\n            }\n            // Auto-wrap others if so specified\n            if ( params.chainable && _isTypeObject( returnValue ) && propertyKey !== 'prototype' && !( typeof returnValue === 'function' && /^class\\s?|\\{\\s\\[native\\scode\\]\\s\\}$/.test(Function.prototype.toString.call( returnValue ) ) ) ) {\n                return proxy( returnValue, params, extendCallback );\n            }\n            return returnValue;\n        },\n        getOwnPropertyDescriptor: ( target, propertyKey ) => getOwnPropertyDescriptor( target, propertyKey, params ),\n        getPrototypeOf: target => getPrototypeOf( target, params ),\n        has: ( target, propertyKey ) => has( target, propertyKey, params ),\n        isExtensible: target => isExtensible( target, params ),\n        ownKeys: target => ownKeys( target, params ),\n        preventExtensions: target => preventExtensions( target, params ),\n        set: ( target, propertyKey, value, receiver = null ) => set( target, propertyKey, value, { ...params, receiver } ),\n        setPrototypeOf: ( target, prototype ) => setPrototypeOf( target, prototype, params ),\n    };\n    // Extend...\n    const $traps = extendCallback?.( traps ) || traps;\n    // Create proxy\n    const $proxy = new Proxy( originalTarget, $traps );\n    if ( params.membrane ) { _wq( originalTarget, 'membraneRef' ).set( params.membrane, $proxy ); }\n\treturn $proxy;\n}\n\n/**\n * Returns the original object earlier proxied by proxy().\n *\n * @param Proxy|Any\t\ttarget\n *\n * @return Any\n */\nexport function unproxy( target ) {\n    // Proxy targets are mapped to their own instances internally\n    return target && target[ symWQOriginal ] || target;\n}\n\n/* ---------------HELPERS--------------- */\n\n/** \n * Ensures target object is an object or array.\n *\n * @param Array|Object\ttarget\n *\n * @return Array|Object\n */\nfunction resolveTarget( target ) {\n\tif ( !target || !_isTypeObject( target ) ) throw new Error('Target must be of type object!');\n\treturn unproxy( target );\n}\n", "import { _isObject, _isTypeObject, _isFunction, _getType } from '@webqit/util/js/index.js';\nimport { _from as _arrFrom } from '@webqit/util/arr/index.js';\nimport { _wq, _await, env } from './util.js';\nimport ListenerRegistry from './core/ListenerRegistry.js';\nimport TrapsRegistry from './core/TrapsRegistry.js';\nimport Descriptor from './core/Descriptor.js';\nimport { unproxy } from './actors.js';\n\n/* ---------------SPECIAL APIs--------------- */\n\n/**\n * Creates a Path array instance from arguments.\n * \n * @param Array\t            ...segments\n *\n * @return Path\n */\nclass Path extends Array {}\nexport function path( ...segments ) {\n    return new Path( ...segments );\n}\n\n/**\n * Creates a \"Subtree\" directive.\n * \n * @return Subtree\n */\nclass Subtree extends Array {}\nexport function subtree() {\n    return new Subtree;\n}\n\n/**\n * Creates an \"Infinity\" directive.\n * \n * @return Infinity\n */\nexport function any() {\n    return Infinity;\n}\n\n/**\n * Reduces a path array against handler.\n * \n * @param Array|Object\t    target\n * @param Array\t            path\n * @param Function\t        receiver\n * @param Function\t        final\n * @param Object\t        params\n * \n * @example reduce( object, [ segement1, segement2 ], observe, ( value, flags ) => {}, params );\n *\n * @return Any\n */\nexport function reduce( target, path, receiver, final = x => x, params = {} ) {\n    const _isSubtree = path instanceof Subtree;\n    if ( !_isSubtree && !path?.length ) return;\n    return ( function eat( target, path, $params, $isSubtree ) {\n        const isSubtree = $isSubtree || path[ $params.level ] instanceof Subtree;\n        const segment = isSubtree ? Infinity : path[ $params.level ];\n        const isLastSegment = isSubtree ? false : $params.level === path.length - 1;\n        if ( target instanceof Descriptor && target.operation !== 'get' ) {\n            // Always probe event-generated trees\n            $params = { ...$params, probe: 'always' };\n        } else if ( $params.probe !== 'always' ) {\n            // Probe until (before) last segment\n            $params = { ...$params, probe: !isLastSegment };\n        }\n        // ---------------\n        return receiver( target, segment, ( result, ...args ) => {\n            // -----------\n            const addTrail = ( desc ) => {\n                if ( !( desc instanceof Descriptor ) ) return;\n                desc.path = 'key' in desc ? [ desc.key ] : [];\n                if ( target instanceof Descriptor ) {\n                    desc.path = 'key' in desc ? target.path.concat( desc.key ) : target.path.slice( 0 );\n                    Object.defineProperty( desc, 'context', { get: () => target, configurable: true } );\n                }\n            };\n            const flags = args[ 0 ] || {};\n            const advance = ( result ) => {\n                if ( result instanceof Descriptor && 'argumentsList' in result ) {\n                    return;\n                }\n                const $value = resolveObj( result/* a Descriptor who's value could be proxied */, false );\n                return _await( $value/* could be a promise */, $value => {\n                    if ( result instanceof Descriptor ) {\n                        result.value = $value; // Update to (fulfilled), unproxied, value\n                    } else {\n                        result = $value;\n                    }\n                    return eat( result, path, { ...$params, ...flags, keyInParent: result.key, level: $params.level + 1, }, isSubtree );\n                } );\n            };\n            // -----------\n            if ( isPropsList( segment ) && Array.isArray( result ) ) {\n                result.forEach( addTrail );\n                if ( isLastSegment ) {\n                    return final( result, ...args );\n                }\n                if ( isSubtree && result[ 0 ] instanceof Descriptor && ( result[ 0 ].operation !== 'get' || params.asGet ) ) {\n                    final( result, ...args );\n                }\n                for ( const entry of result ) {\n                    advance( entry );\n                }\n                return;\n            }\n            // -----------\n            addTrail( result );\n            if ( isLastSegment ) {\n                return final( result, ...args );\n            }\n            return advance( result );\n            // -----------\n        }, $params );\n    } )( target, path.slice( 0 ), { ...params, level: 0 }, _isSubtree );\n}\n\n/**\n * Adds an observer to a target's registry.\n *\n * @param Array|Object\t    target\n * @param String|Object\t    prop\n * @param Function\t        receiver\n * @param Object\t\t    params\n *\n * @return AbortController\n */\nexport function observe( target, prop, receiver, params = {} ) {\n    // ---------------\n    const originalTarget = resolveObj( target, !params.level );\n\tif ( _isFunction( arguments[ 1 ] ) ) {\n        [ , receiver, params = {} ] = arguments;\n        prop = Infinity;\n\t}\n\tif ( !_isFunction( receiver ) ) throw new Error( `Handler must be a function; \"${ _getType( receiver ) }\" given!` );\n    if ( prop instanceof Path || prop instanceof Subtree ) return reduce( originalTarget, prop, observe, receiver, params );\n    // ---------------\n    params = { ...params, descripted: true };\n    delete params.live;\n    if ( !_isTypeObject( originalTarget ) ) return params.probe && get( originalTarget, prop, receiver, params ) || undefined;\n    // ---------------\n    const emit = bind( originalTarget, prop, receiver, params );\n    if ( params.probe ) {\n        return get( originalTarget, prop, emit, params );\n    }\n    return emit();\n}\n\n/**\n * Adds an interceptor object to a target's registry.\n *\n * @param Array|Object\t    target\n * @param Object\t        traps\n * @param Object\t\t    params\n *\n * @return AbortRegistry\n */\nexport function intercept( target, traps, params = {} ) {\n    // ---------------\n    const originalTarget = resolveObj( target );\n    if ( !_isObject( traps ) ) {\n        [ /*target*/, /*operation*/, /*handler*/, params = {} ] = arguments;\n        traps = { [ arguments[ 1 ] ]: arguments[ 2 ] };\n    }\n    // ---------------\n    return TrapsRegistry.getInstance( originalTarget, true, params.namespace ).addRegistration( { traps, params } );\n}\n\n/* ---------------QUERY APIs--------------- */\n\n/**\n * Performs a \"getOwnPropertyDescriptor\" operation.\n *\n * @param Array|Object\t    target\n * @param String|Number\t    prop\n * @param Function\t        receiver\n * @param Object\t\t    params\n *\n * @return Any\n */\nexport function getOwnPropertyDescriptor( target, prop, receiver = x => x, params = {} ) {\n    return exec( target, 'getOwnPropertyDescriptor', { key: prop }, receiver, params );\n}\n\n/**\n * Performs a \"getOwnPropertyDescriptors\" operation.\n * @note this isn't part of the standard Reflect API.\n *\n * @param Array|Object\t    target\n * @param String|Number\t    prop\n * @param Function\t        receiver\n * @param Object\t\t    params\n *\n * @return Any\n */\nexport function getOwnPropertyDescriptors( target, prop, receiver = x => x, params = {} ) {\n    return exec( target, 'getOwnPropertyDescriptors', { key: prop }, receiver, params );\n}\n\n/**\n * Performs a \"getPrototypeOf\" operation.\n *\n * @param Array|Object\t    target\n * @param Function\t        receiver\n * @param Object\t\t    params\n *\n * @return Any\n */\nexport function getPrototypeOf( target, receiver = x => x, params = {} ) {\n    return exec( target, 'getPrototypeOf', {}, receiver, params );\n}\n\n/**\n * Performs a \"isExtensible\" operation.\n *\n * @param Array|Object\t    target\n * @param Function\t        receiver\n * @param Object\t\t    params\n *\n * @return Any\n */\nexport function isExtensible( target, receiver = x => x, params = {} ) {\n    return exec( target, 'isExtensible', {}, receiver, params );\n}\n\n/**\n * Performs a \"ownKeys\" operation.\n *\n * @param Array|Object\t    target\n * @param Function\t        receiver\n * @param Object\t\t    params\n *\n * @return Any\n */\nexport function ownKeys( target, receiver = x => x, params = {} ) {\n    return exec( target, 'ownKeys', {}, receiver, params );\n}\n\n/**\n * Performs an operation of the given \"type\".\n *\n * @param Array|Object\t    target\n * @param String|Number\t    prop\n * @param Function\t        receiver\n * @param Object\t\t    params\n *\n * @return Any\n */\nexport function has( target, prop, receiver = x => x, params = {} ) {\n    return exec( target, 'has', { key: prop }, receiver, params );\n}\n\n/**\n * Performs a get operation.\n *\n * @param Array|Object\t    target\n * @param String|Number\t    prop\n * @param Function\t        receiver\n * @param Object\t        params\n *\n * @return Any\n */\nexport function get( target, prop, receiver = x => x, params = {} ) {\n    // ---------------\n    let isLive;\n    const originalTarget = resolveObj( target, !params.level );\n    if ( _isObject( receiver ) ) {\n        [ params, receiver ] = [ receiver, x => x ];\n    } else if ( params.live ) { isLive = true; }\n    if ( prop instanceof Path || prop instanceof Subtree ) return reduce( originalTarget, prop, get, receiver, { ...params, asGet: true } );\n    // ---------------\n    return resolveProps( originalTarget, prop, props => {\n        const related = [ ...props ];\n        return ( function next( results, _props, _done ) {\n            if ( !_props.length ) return _done( results );\n            const prop = _props.shift();\n            if ( ![ 'string', 'number', 'symbol' ].includes( typeof prop ) ) {\n                throw new Error( `Property name/key ${ prop } invalid.` );\n            }\n            // ---------\n            function defaultGet( descriptor, value = undefined ) {\n                const _next = value => ( descriptor.value = value, next( [ ...results, params.live || params.descripted ? descriptor : value ]/** not using concat() as value may be an array */, _props, _done ) );\n                if ( arguments.length > 1 ) return _next( value );\n                if ( !_isTypeObject( originalTarget ) ) return _next( originalTarget?.[ descriptor.key ] );\n                const accessorizedProps = _wq( originalTarget, 'accessorizedProps', false );\n                const accessorization = accessorizedProps && accessorizedProps.get( descriptor.key );\n                if ( accessorization && accessorization.intact() ) {\n                    return _next( accessorization.getValue( params.withPropertyDescriptors ) );\n                }\n                if ( params.withPropertyDescriptors ) {\n                    const desc = Object.getOwnPropertyDescriptor( originalTarget, descriptor.key );\n                    return _next( desc );\n                }\n                return _next( Reflect.get( originalTarget, descriptor.key/*, ...( params.receiver ? [ params.receiver ] : [] )*//*Throws Illegal invocation error ffor DOM nodes, e.g.*/ ) );\n            }\n            // ---------\n            const descriptor = new Descriptor( originalTarget, {\n                type: 'get',\n                key: prop,\n                value: undefined,\n                operation: 'get',\n                related,\n            } );\n            if ( !_isTypeObject( originalTarget ) ) return defaultGet( descriptor );\n            const trapsRegistry = TrapsRegistry.getInstance( originalTarget, false, params.namespace );\n            if ( trapsRegistry ) {\n                return trapsRegistry.emit( descriptor, defaultGet );\n            }\n            return defaultGet( descriptor );\n        } )( [], props.slice( 0 ), results => {\n            const result_s = isPropsList( prop/*original*/ ) ? results : results[ 0 ];\n            if ( isLive && _isTypeObject( originalTarget ) ) {\n                const emit = bind( originalTarget, prop, receiver, params, target.key );\n                return emit( result_s );\n            }\n            return receiver( result_s );\n        } );\n    }, params );\n}\n\n/* ---------------MUTATION APIs--------------- */\n\n/**\n * Performs a batch operation.\n * \n * @param Object\t        target\n * @param Function\t        callback\n * @param Object\t        params\n *\n * @return Void\n */\nexport function batch( target, callback, params = {} ) {\n    const originalTarget = resolveObj( target );\n    return ListenerRegistry.getInstance( originalTarget, true, params.namespace ).batch( callback, params );\n}\n\n/**\n * Performs a mirror operation.\n * \n * @param Object\t        source\n * @param Object\t        target\n * @param Object\t        params\n *\n * @return Void\n */\nexport function map( source, target, params = {} ) {\n    target = resolveObj( target );\n    source = resolveObj( source );\n    const only = ( params.only || [] ).slice( 0 ), except = ( params.except || [] ).slice( 0 );\n    const sourceKeys = Object.keys( params.spread ? [ ...source ] : source ).map( k => !isNaN( k ) ? parseInt( k ) : k );\n    const filteredKeys = only.length ? only.filter( k => sourceKeys.includes( k ) ) : sourceKeys.filter( k => !except.includes( k ) );\n    const resolveKey = k => { \n        if ( !Array.isArray( target ) || isNaN( k ) ) return k;\n        return k - except.filter( i => i < k ).length;\n    };\n    const doSet = key => {\n        const descriptor = getOwnPropertyDescriptor( source, key, params );\n        if ( ( 'value' in descriptor ) && descriptor.writable && descriptor.enumerable && descriptor.configurable ) {\n            set( target, resolveKey( key ), descriptor.value, params );\n        } else if ( descriptor.enumerable || params.onlyEnumerable === false ) { defineProperty( target, key, { ...descriptor, configurable: true }, params ); }\n    };\n    batch( target, () => {\n        filteredKeys.forEach( doSet );\n    } );\n    return observe( source, mutations => {\n        //batch( target, () => {\n            mutations.filter( m => only.length ? only.includes( m.key ) : !except.includes( m.key ) ).forEach( m => {\n                if ( m.type === 'delete' ) return deleteProperty( target, resolveKey( m.key ), params );\n                if ( m.type === 'def' ) {\n                    if ( m.value.enumerable || params.onlyEnumerable === false ) {\n                        defineProperty( target, resolveKey( m.key ), { ...m.value, configurable: true }, params );\n                    }\n                    return;\n                }\n                doSet( m.key );\n            } );\n        //}, params );\n    }, { ...params, withPropertyDescriptors: true } );\n}\n\n/**\n * Performs a set operation.\n * \n * @param Object\t        target\n * @param String|Number\t    prop\n * @param Any\t            value\n * @param Function\t        receiver\n * @param Object\t        params\n * @param Bool\t            def\n *\n * @return Any\n */\nexport function set( target, prop, value, receiver = x => x, params = {}, def = false ) {\n    // ---------------\n    const originalTarget = resolveObj( target );\n    let entries = [ [ prop, value ] ];\n    if ( _isObject( prop ) ) {\n        [ /*target*/, /*hash*/, receiver = x => x, params = {}, def = false ] = arguments;\n        entries = Object.entries( prop );\n    }\n    if ( _isObject( receiver ) ) { [ def, params, receiver ] = [ typeof params === 'boolean' ? params : def, receiver, x => x ]; }\n    // ---------------\n    const related = entries.map( ( [ prop ] ) => prop );\n    return ( function next( descriptors, entries, _done ) {\n        if ( !entries.length ) return _done( descriptors );\n        const [ prop, value ] = entries.shift();\n        // ---------\n        function defaultSet( descriptor, status = undefined ) {\n            const _next = status => ( descriptor.status = status, next( descriptors.concat( descriptor ), entries, _done ) );\n            if ( arguments.length > 1 ) return _next( descriptor, status );\n            const accessorizedProps = _wq( originalTarget, 'accessorizedProps', false );\n            const accessorization = accessorizedProps && accessorizedProps.get( descriptor.key );\n            if ( descriptor.type === 'def' ) {\n                if ( accessorization && !accessorization.restore() ) _next( false );\n                Object.defineProperty( originalTarget, descriptor.key, descriptor.value );\n                return _next( true );\n            }\n            if ( accessorization && accessorization.intact() ) {\n                return _next( accessorization.setValue( descriptor.value ) );\n            }\n            return _next( Reflect.set( originalTarget, descriptor.key, descriptor.value ) );\n        }\n        // ---------\n        function exec( isUpdate, oldValue ) {\n            if ( params.diff && value === oldValue ) return next( descriptors, entries, _done );\n            const descriptor = new Descriptor( originalTarget, {\n                type: def ? 'def' : 'set',\n                key: prop,\n                value,\n                isUpdate,\n                oldValue,\n                related: [ ...related ],\n                operation: def ? 'defineProperty' : 'set',\n                detail: params.detail,\n            } );\n            const trapsRegistry = TrapsRegistry.getInstance( originalTarget, false, params.namespace );\n            return trapsRegistry \n                ? trapsRegistry.emit( descriptor, defaultSet ) \n                : defaultSet( descriptor );\n        }\n        // ---------\n        return has( originalTarget, prop, exists => {\n            if ( !exists ) return exec( exists );\n            if ( prop === 'length' && Array.isArray( originalTarget ) && _wq( originalTarget ).has( '$length' ) ) {\n                return exec( true, _wq( originalTarget ).get( '$length' ) );\n            }\n            const $params = { ...params, withPropertyDescriptors: def };\n            return get( originalTarget, prop, oldValue => exec( exists, oldValue ), $params );\n        }, params );\n        // ---------\n    } )( [], entries.slice( 0 ), descriptors => {\n        const listenerRegistry = ListenerRegistry.getInstance( originalTarget, false, params.namespace );\n        if ( listenerRegistry ) listenerRegistry.emit( descriptors, { eventsArePropertyDescriptors: !!def } );\n        return receiver(\n            isPropsList( prop/*original*/ ) ? descriptors.map( opr => opr.status ) : descriptors[ 0 ]?.status\n        );\n    } );\n}\n\n/**\n * Performs a defineProperty operation.\n * \n * @param Object\t        target\n * @param String|Number\t    prop\n * @param Object\t        descriptor\n * @param Function\t        receiver\n * @param Object\t        params\n *\n * @return Any\n */\nexport function defineProperty( target, prop, descriptor, receiver = x => x, params = {} ) {\n    return set( target, prop, descriptor, receiver, params, true/*def*/ );\n}\n\n/**\n * Performs a defineProperties operation.\n * @note this isn't part of the standard Reflect API.\n * \n * @param Object\t        target\n * @param Object\t        descriptors\n * @param Function\t        receiver\n * @param Object\t        params\n *\n * @return Any\n */\nexport function defineProperties( target, descriptors, receiver = x => x, params = {} ) {\n    return set( target, descriptors, receiver, params, true/*def*/ );\n}\n\n/**\n * Performs a delete operation.\n * \n * @param Object\t        target\n * @param String|Number\t    prop\n * @param Function\t        receiver\n * @param Object\t        params\n *\n * @return Any\n */\nexport function deleteProperty( target, prop, receiver = x => x, params = {} ) {\n    // ---------------\n    const originalTarget = resolveObj( target );\n    if ( _isObject( receiver ) ) { [ params, receiver ] = [ receiver, x => x ]; }\n    // ---------------\n    const props = _arrFrom( prop, false ), related = [ ...props ];\n    return ( function next( descriptors, props, _done ) {\n        if ( !props.length ) return _done( descriptors );\n        const prop = props.shift();\n        // ---------\n        function defaultDel( descriptor, status = undefined ) {\n            const _next = status => ( descriptor.status = status, next( descriptors.concat( descriptor ), props, _done ) );\n            if ( arguments.length > 1 ) return _next( descriptor, status );\n            const accessorizedProps = _wq( originalTarget, 'accessorizedProps', false );\n            const accessorization = accessorizedProps && accessorizedProps.get( descriptor.key );\n            if ( accessorization && !accessorization.restore() ) _next( false );\n            return _next( Reflect.deleteProperty( originalTarget, descriptor.key ) );\n        }\n        // ---------\n        function exec( oldValue ) {\n            const descriptor = new Descriptor( originalTarget, {\n                type: 'delete',\n                key: prop,\n                oldValue,\n                related: [ ...related ],\n                operation: 'deleteProperty',\n                detail: params.detail,\n            } );\n            const trapsRegistry = TrapsRegistry.getInstance( originalTarget, false, params.namespace );\n            return trapsRegistry \n                ? trapsRegistry.emit( descriptor, defaultDel ) \n                : defaultDel( descriptor );\n        }\n        // ---------\n        return get( originalTarget, prop, exec, params );\n        // ---------\n    } )( [], props.slice( 0 ), descriptors => {\n        const listenerRegistry = ListenerRegistry.getInstance( originalTarget, false, params.namespace );\n        if ( listenerRegistry ) listenerRegistry.emit( descriptors );\n        return receiver(\n            isPropsList( prop/*original*/ ) ? descriptors.map( opr => opr.status ) : descriptors[ 0 ].status\n        );\n    } );\n}\n\n/**\n * @alias deleteProperty()\n */\nexport function deleteProperties( target, props, receiver = x => x, params = {} ) {\n    return deleteProperty( ...arguments );\n}\n\n/* ---------------EFFECT APIs--------------- */\n\n/**\n * Performs a \"construct\" operation.\n *\n * @param Array|Object\t    target\n * @param Array\t\t\t    argumentsList\n * @param Object\t\t    newTarget\n * @param Function\t        receiver\n * @param Object\t\t    params\n *\n * @return Any\n */\nexport function construct( target, argumentsList, newTarget = null, receiver = x => x, params = {} ) {\n    return exec( target, 'construct', arguments.length > 2 ? { argumentsList, newTarget } : { argumentsList }, receiver, params );\n}\n\n/**\n * Performs an \"apply\" operation.\n *\n * @param Array|Object\t    target\n * @param Any\t            thisArgument\n * @param Array\t            argumentsList\n * @param Function\t        receiver\n * @param Object\t\t    params\n *\n * @return Any\n */\nexport function apply( target, thisArgument, argumentsList, receiver = x => x, params = {} ) {\n    const originalThis = unproxy( thisArgument );\n    let returnValue;\n    if ( Array.isArray( thisArgument ) ) {\n        if ( params.arrayMethodName ) {\n            const descriptor = new Descriptor( originalThis, {\n                operation: params.arrayMethodName,\n                argumentsList\n            } );\n            const listenerRegistry = ListenerRegistry.getInstance( originalThis, false, params.namespace );\n            listenerRegistry?.emit( [ descriptor ], { eventIsArrayMethodDescriptor: true } );\n        }\n        _wq( originalThis ).set( '$length', originalThis.length );\n        returnValue = batch(\n            originalThis,\n            () => exec( target, 'apply', { thisArgument/*proxy wrappers allowed; in fact is why it works*/, argumentsList }, receiver, params ),\n            params\n        );\n        _wq( originalThis ).delete( '$length' );\n    } else {\n        returnValue = exec( target, 'apply', { thisArgument: originalThis, argumentsList }, receiver, params );\n    }\n    return returnValue;\n}\n\n/**\n * Performs a \"setPrototypeOf\" operation.\n *\n * @param Array|Object\t    target\n * @param Anyr\t            proto\n * @param Function\t        receiver\n * @param Object\t\t    params\n *\n * @return Any\n */\nexport function setPrototypeOf( target, proto, receiver = x => x, params = {} ) {\n    return exec( target, 'setPrototypeOf', { proto }, receiver, params );\n}\n\n/**\n * Performs a \"preventExtension\" operation.\n *\n * @param Array|Object\t    target\n * @param Function\t        receiver\n * @param Object\t\t    params\n *\n * @return Any\n */\nexport function preventExtensions( target, receiver = x => x, params = {} ) {\n    return exec( target, 'preventExtensions', {}, receiver, params );\n}\n\n/* ---------------HELPER APIs--------------- */\n\n/**\n * Adds an observer to a target's registry.\n *\n * @param Array|Object\t    target\n * @param String|Object\t    prop\n * @param Function\t        receiver\n * @param Object\t\t    params\n *\n * @return Function: AbortController\n */\nfunction bind( target, prop, receiver, params = {} ) {\n    const controller = new AbortController;\n    env.setMaxListeners?.( 0, controller.signal );\n    if ( params.signal ) { params.signal.addEventListener( 'abort', () => controller.abort() ); }\n    const $params = { ...params, signal: controller.signal };\n    const listenerRegistry = ListenerRegistry.getInstance( target, true, $params.namespace );\n    const childRegistrations = new Map;\n    return function emit( descriptor_s = [], prevRegistration = null ) {\n        let flags, registrationNext, isExisting;\n        if ( isPropsList( prop ) ) {\n            if ( prevRegistration ) {\n                isExisting = true;\n                registrationNext = prevRegistration;\n                for ( const descriptor of descriptor_s ) {\n                    childRegistrations.get( descriptor.key )?.remove();\n                    childRegistrations.delete( descriptor.key );\n                }\n            } else {\n                registrationNext = listenerRegistry.addRegistration( prop, emit, $params );\n            }\n            flags = { signal: registrationNext.signal, childRegistrations };\n        } else {\n            prevRegistration?.remove();\n            registrationNext = listenerRegistry.addRegistration( prop, emit, $params );\n            flags = { signal: registrationNext.signal };\n        }\n        // ------------------\n        if ( $params.childRegistrations && $params.keyInParent ) {\n            $params.childRegistrations.set( $params.keyInParent, registrationNext );\n        }\n        // ------------------\n        if ( arguments.length ) {\n            const handlerReturnValue = receiver( descriptor_s, flags );\n            if ( arguments.length > 1 ) return handlerReturnValue;\n        }\n        return controller;\n    };\n}\n\n/**\n * Performs an operation of the given \"type\".\n *\n * @param Array|Object\t    target\n * @param String\t\t    operation\n * @param Object\t\t    payload\n * @param Function\t        receiver\n * @param Object\t\t    params\n *\n * @return Any\n */\nfunction exec( target, operation, payload = {}, receiver = x => x, params = {} ) {\n    // ---------\n    target = resolveObj( target );\n    if ( _isObject( receiver ) ) { [ params, receiver ] = [ receiver, x => x ]; }    \n    // ---------\n    function defaultExec( descriptor, result ) {\n        if ( arguments.length > 1 ) return receiver( result );\n        return receiver( ( Reflect[ operation ] || Object[ operation ] )( target, ...Object.values( payload ) ) );\n    }\n    // ---------\n    const descriptor = new Descriptor( target, { operation, ...payload } );\n    const trapsRegistry = TrapsRegistry.getInstance( target, false, params.namespace );\n    if ( trapsRegistry ) {\n        return trapsRegistry.emit( descriptor, defaultExec );\n    }\n    return defaultExec( descriptor );\n}\n\n// Asks if prop is a multi-result field\nfunction isPropsList( prop ) {\n    return prop === Infinity || Array.isArray( prop );\n}\n\n// Resolves obj down to it's self\nfunction resolveObj( obj, assert = true, probePropertyDescriptors = true ) {\n\tif ( ( !obj || !_isTypeObject( obj ) ) && assert ) throw new Error( `Object must be of type object or array! \"${ _getType( obj ) }\" given.` );\n    if ( obj instanceof Descriptor ) {\n        if ( obj.type === 'def' && probePropertyDescriptors ) {\n            obj = typeof obj.value.get === 'function' ? obj.value.get() : obj.value.value;\n        } else {\n            obj = obj.value;\n        }\n    }\n\treturn obj && unproxy( obj );\n}\n\n// Resolves prop down to actual keys\nfunction resolveProps( obj, prop, receiver, params = {} ) {\n    if ( prop === Infinity ) {\n        if ( params.level && !_isTypeObject( obj ) ) return receiver( [] );\n        return receiver( Object.entries( Object.getOwnPropertyDescriptors( obj ) ).filter( ( [ , p ] ) => p.writable !== false && !p.get && !p.set ).map( ( [ name ] ) => name ) );\n    }\n    return receiver( _arrFrom( prop, false ) );\n}\n", "\n/**\n * @imports\n */\nimport * as main from './main.js';\nimport * as actors from './actors.js';\n\nconst Observer = { ...main, ...actors };\n\nexport default Observer;", "import { _isObject } from '@webqit/util/js/index.js';\r\nimport { _eq, _toCapsSnake } from './util.js';\r\nimport { TokenStream } from '../TokenStream.js';\r\nimport { TOK_TYPES } from '../toktypes.js';\r\nimport { registry } from '../registry.js';\r\n\r\n/**\r\n * parse(str, { ... })|fromJSON(json, {\r\n *   dialect,\r\n * \t mysqlAnsiQuotes\r\n *   mysqlNoBackslashEscapes,\r\n *   assert\r\n * })\r\n * \r\n * stringify({\r\n *   prettyPrint,\r\n * \t startingIndentLevel,\r\n *   autoLineBreakThreshold,\r\n *   pruneOptionalParens,\r\n *   tabSpaces\r\n * })\r\n * \r\n * jsonfy({\r\n *   nodeNames,\r\n *   toDialect,\r\n *   deSugar,\r\n *   reverseRef,\r\n *   memoizeDimensionalInsertSelect,\r\n * })\r\n */\r\n\r\nexport class AbstractNode {\r\n\r\n\tstatic get NODE_NAME() { return _toCapsSnake(this.name); }\r\n\tget NODE_NAME() { return this.constructor.NODE_NAME; }\r\n\r\n\t#ast;\r\n\tget _ast() { return this.#ast; }\r\n\r\n\t#options;\r\n\tget options() {\r\n\t\tconst options = this.#options || this.#parentNode?.options || { dialect: 'postgres' };\r\n\t\treturn options;\r\n\t}\r\n\r\n\t#parentNode;\r\n\tget parentNode() { return this.#parentNode; }\r\n\r\n\tget statementNode() { return this.#parentNode?.statementNode; }\r\n\r\n\tget rootNode() { return this.#parentNode?.rootNode || this; }\r\n\r\n\tconstructor(ast = {}, options = {}) {\r\n\t\tthis.#ast = ast;\r\n\t\tthis.#options = options;\r\n\t\tfor (const node_s of Object.values(this.#ast)) {\r\n\t\t\tthis._adoptNodes(...[].concat(node_s));\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * -----------\r\n\t * AST API\r\n\t * -----------\r\n\t */\r\n\r\n\t_keys() { return Object.keys(this.#ast).filter((k) => this.#ast[k] !== undefined); }\r\n\r\n\t_has(fieldName, index = undefined, cs = undefined) {\r\n\t\tif (!(fieldName in this.#ast)) return false;\r\n\t\tif (typeof index === 'number') {\r\n\t\t\treturn typeof this.#ast[fieldName][index] !== 'undefined';\r\n\t\t}\r\n\t\tif (index) {\r\n\t\t\treturn this.#ast[fieldName].some((n) => n.identifiesAs?.(index, cs));\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\t_get(fieldName, index = undefined, cs = undefined) {\r\n\t\tif (!(fieldName in this.#ast)) return;\r\n\t\tif (typeof index !== 'undefined' && !Array.isArray(this.#ast[fieldName])) {\r\n\t\t\tthrow new Error(`Can't use index in field \"${fieldName}\"; not an array.`)\r\n\t\t}\r\n\t\tlet value = this.#ast[fieldName];\r\n\t\tif (typeof index === 'number') {\r\n\t\t\tvalue = value[index];\r\n\t\t} else if (index) {\r\n\t\t\tvalue = value.find((n) => n.identifiesAs?.(index, cs));\r\n\t\t}\r\n\t\treturn value;\r\n\t}\r\n\r\n\t_set(fieldName, indexOrValue, valueOnIndex = undefined, cs = undefined) {\r\n\t\tconst index = arguments.length > 2 ? indexOrValue : undefined;\r\n\t\tconst value = arguments.length > 2 ? valueOnIndex : indexOrValue;\r\n\t\tconst existing = typeof index !== 'undefined' ? this._get(fieldName, index, cs) : undefined;\r\n\t\tif (existing) {\r\n\t\t\tthis._unadoptNodes(...[].concat(existing));\r\n\t\t}\r\n\t\tif (typeof index !== 'undefined') {\r\n\t\t\tthis.#ast[fieldName] = !existing\r\n\t\t\t\t? this.#ast[fieldName].concat(value)\r\n\t\t\t\t: this.#ast[fieldName].reduce((all, n) => {\r\n\t\t\t\t\tif (n === existing) return all.concat(value);\r\n\t\t\t\t\treturn all.concat(n);\r\n\t\t\t\t}, []);\r\n\t\t} else {\r\n\t\t\tthis.#ast[fieldName] = value;\r\n\t\t}\r\n\t\tthis._adoptNodes(...[].concat(value));\r\n\t\treturn true;\r\n\t}\r\n\r\n\t_delete(fieldName, index = undefined, cs = undefined) {\r\n\t\tif (!(fieldName in this.#ast)) return false;\r\n\t\tif (typeof index !== 'undefined' && !Array.isArray(this.#ast[fieldName])) {\r\n\t\t\tthrow new Error(`Can't use index in field \"${fieldName}\"; not an array.`)\r\n\t\t}\r\n\t\tif (typeof index !== 'undefined') {\r\n\t\t\tthis.#ast[fieldName] = this.#ast[fieldName].reduce((all, n, i) => {\r\n\t\t\t\tconst matches = typeof index === 'number' ? i === index : n.identifiesAs?.(index, cs);\r\n\t\t\t\tif (matches) {\r\n\t\t\t\t\tthis._unadoptNodes(n);\r\n\t\t\t\t\treturn all;\r\n\t\t\t\t}\r\n\t\t\t\treturn all.concat(n);\r\n\t\t\t}, []);\r\n\t\t} else {\r\n\t\t\tthis._unadoptNodes(...[].concat(this.#ast[fieldName]));\r\n\t\t\tthis.#ast[fieldName] = Array.isArray(this.#ast[fieldName]) ? [] : undefined;\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\t_add(fieldName, ...args) {\r\n\t\tif (!Array.isArray(this.#ast[fieldName])) {\r\n\t\t\tthrow new Error(`Can't add on field \"${fieldName}\"; not an array.`)\r\n\t\t}\r\n\t\tthis._adoptNodes(...args);\r\n\t\tthis.#ast[fieldName] = this.#ast[fieldName].concat(args);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t_adoptNodes(...nodes) {\r\n\t\tfor (const node of nodes) {\r\n\t\t\tif (!(node instanceof AbstractNode)) continue;\r\n\t\t\tif (node.#parentNode && node.#parentNode !== this) {\r\n\t\t\t\tconst activeTrailStr = `${this.NODE_NAME}`;\r\n\t\t\t\tthrow new Error(`[${activeTrailStr}] Illegal node operation`);\r\n\t\t\t}\r\n\t\t\tnode.#parentNode = this;\r\n\t\t}\r\n\t}\r\n\r\n\t_unadoptNodes(...nodes) {\r\n\t\tfor (const node of nodes) {\r\n\t\t\tif (!(node instanceof AbstractNode)) continue;\r\n\t\t\tif (node.#parentNode !== this) {\r\n\t\t\t\tconst activeTrailStr = `${this.NODE_NAME}`;\r\n\t\t\t\tthrow new Error(`[${activeTrailStr}] Illegal node operation`);\r\n\t\t\t}\r\n\t\t\tnode.#parentNode = null;\r\n\t\t}\r\n\t}\r\n\r\n\tclimbTree(visitor) {\r\n\t\tif (!this.#parentNode) return;\r\n\t\treturn visitor(this.#parentNode, () => {\r\n\t\t\treturn this.#parentNode.climbTree(visitor);\r\n\t\t});\r\n\t}\r\n\r\n\twalkTree(visitor, crossStmt = false, scope = null) {\r\n\t\tconst visit = (value, key, scope) => {\r\n\t\t\tif (!(value instanceof AbstractNode)\r\n\t\t\t\t&& !Array.isArray(value)) return;\r\n\r\n\t\t\tconst _scope = new Map(scope || []);\r\n\t\t\tconst result = visitor(value, key, _scope);\r\n\t\t\tif (result !== value) return;\r\n\r\n\t\t\tif (Array.isArray(value)) {\r\n\t\t\t\tvalue.map((v, k) => visit(v, k, _scope));\r\n\t\t\t} else if (crossStmt || value.statementNode !== value) {\r\n\t\t\t\tvalue.walkTree(visitor, crossStmt, _scope);\r\n\t\t\t}\r\n\t\t};\r\n\t\tfor (const [key, value] of Object.entries(this.#ast)) {\r\n\t\t\tvisit(value, key, scope);\r\n\t\t}\r\n\t}\r\n\r\n\tcontainsNode(possibleChild) {\r\n\t\tif (!possibleChild) return false;\r\n\t\treturn this === possibleChild.parentNode || this.containsNode(possibleChild.parentNode);\r\n\t}\r\n\r\n\tidentifiesAs(value, cs = false) {\r\n\t\tif (typeof value === 'undefined') return false;\r\n\t\tif (typeof value?.jsonfy === 'function') {\r\n\t\t\treturn _eq(this.jsonfy({ nodeNames: false }), value.jsonfy({ nodeNames: false }), cs);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * -----------\r\n\t * TRANSFORMATION API\r\n\t * -----------\r\n\t */\r\n\r\n\tstatic morphsTo() { return this; }\r\n\r\n\tclone(options = {}, transformer = null, schemaInference = null) {\r\n\t\tconst resultJson = this.jsonfy(options, transformer, schemaInference);\r\n\t\tconst Classes = [this.constructor].concat(this.constructor.morphsTo());\r\n\t\tconst instance = Classes.reduce((prev, C) => prev || C.fromJSON(resultJson, { dialect: options.toDialect || this.options.dialect }), undefined);\r\n\t\treturn instance;\r\n\t}\r\n\r\n\tdeSugar(transformSpec, options = {}, transformer = null, schemaInference = null) {\r\n\t\toptions = { ...options, deSugar: transformSpec/* overrridingly */ };\r\n\t\treturn this.clone(options, transformer, schemaInference);\r\n\t}\r\n\r\n\ttoDialect(dialect, options = {}, transformer = null, schemaInference = null) {\r\n\t\toptions = { ...options, toDialect: dialect/* overrridingly */ };\r\n\t\treturn this.clone(options, transformer, schemaInference);\r\n\t}\r\n\r\n\t/**\r\n\t * -----------\r\n\t * JSON API\r\n\t * -----------\r\n\t */\r\n\r\n\tstatic get syntaxRules() { return []; }\r\n\r\n\tstatic compileASTSchemaFromSyntaxRules({ dialect = 'postgres' } = {}) {\r\n\t\tif (!this._astSchemaCompileCache) {\r\n\t\t\tthis._astSchemaCompileCache = new Map;\r\n\t\t}\r\n\t\tconst cacheKey = `${this.NODE_NAME}:${dialect}`;\r\n\t\tif (!this._astSchemaCompileCache.has(cacheKey)) {\r\n\t\t\tlet result, syntaxRules = this.syntaxRules, rulesArray = [].concat(syntaxRules);\r\n\t\t\tif (rulesArray.length === 1 && Array.isArray(rulesArray[0].type) && !rulesArray[0].as) {\r\n\t\t\t\tresult = rulesArray[0];\r\n\t\t\t} else {\r\n\t\t\t\tresult = this._compileASTSchemaFromSyntaxRules(syntaxRules, dialect, { trail: [this.NODE_NAME] });\r\n\t\t\t}\r\n\t\t\tthis._astSchemaCompileCache.set(cacheKey, result);\r\n\t\t}\r\n\t\treturn this._astSchemaCompileCache.get(cacheKey);\r\n\t}\r\n\r\n\tstatic _compileASTSchemaFromSyntaxRules(syntaxRules, dialect = 'postgres', { trail = [], schemaSet = new Set([new Map]), assertionTrail = { dependencies: new Set, optional: false, assert: false } } = {}) {\r\n\t\tconst rulesArray = Array.isArray(syntaxRules) ? syntaxRules : [syntaxRules];\r\n\t\tconst newDependencyTrail = new Set(assertionTrail.dependencies);\r\n\t\tconst cloneSchemaSet = (schemaSet) => new Set([...schemaSet].map((sch) => new Map(sch)));\r\n\t\tfor (const [i, rule] of rulesArray.entries()) {\r\n\t\t\tif (rule.dialect && rule.dialect !== dialect) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tconst {\r\n\t\t\t\ttype,\r\n\t\t\t\tas: exposure,\r\n\t\t\t\tif: inference = assertionTrail.inference,\r\n\t\t\t\tvalue,\r\n\t\t\t\tarity,\r\n\t\t\t\tsingletons,\r\n\t\t\t\tmodifier,\r\n\t\t\t\tbooleanfy,\r\n\t\t\t\toptional = assertionTrail.optional,\r\n\t\t\t\tassert = assertionTrail.assert,\r\n\t\t\t\tsyntax,\r\n\t\t\t\tsyntaxes,\r\n\t\t\t\t...rest\r\n\t\t\t} = rule;\r\n\t\t\tconst activeTrail = trail.concat(`${Array.isArray(syntaxRules) ? i : ''}${exposure ? `<${exposure}>` : ''}` || []);\r\n\t\t\tconst activeTrailStr = activeTrail.join('.');\r\n\t\t\tconst unsupportedAttrs = _getUnsupportedRuleAttrs(rest);\r\n\t\t\tif (unsupportedAttrs.length) {\r\n\t\t\t\tthrow new SyntaxError(`[${activeTrailStr}] Unsupported attributes in rule: \"${unsupportedAttrs.join('\", \"')}\".`);\r\n\t\t\t}\r\n\t\t\tconst isTokenRule = typeof type === 'string' && type[0] === type[0].toLowerCase();\r\n\t\t\tif (exposure) {\r\n\t\t\t\t// 1. Validate rule\r\n\t\t\t\tif (!type) throw new SyntaxError(`[${activeTrailStr}] Field rules must have a \"type\" attribute of type string.`);\r\n\t\t\t\tif (syntax || syntaxes) throw new SyntaxError(`[${activeTrailStr}] Field rules (\"${exposure}\") can not have a \"syntax\" or \"syntaxes\" attribute.`);\r\n\t\t\t\tif (exposure === '.') {\r\n\t\t\t\t\tif (!isTokenRule) throw new SyntaxError(`[${activeTrailStr}] Terminal Node rules must be token-typed rules.`);\r\n\t\t\t\t\tif (optional) throw new SyntaxError(`[${activeTrailStr}] Terminal Node rules can not be optional.`);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (modifier) throw new SyntaxError(`[${activeTrailStr}] Only Terminal Node rules can have a \"modifier\" attribute.`);\r\n\t\t\t\t}\r\n\t\t\t\tif (isTokenRule) {\r\n\t\t\t\t\tif (![undefined, null].includes(arity)) throw new SyntaxError(`[${activeTrailStr}] Token rules can not be item-based.`);\r\n\t\t\t\t\tif (!TOK_TYPES[type]) throw new SyntaxError(`[${activeTrailStr}] Unknown token type \"${type}\".`);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (value) throw new SyntaxError(`[${activeTrailStr}] Only token rules can have a \"value\" attribute.`);\r\n\t\t\t\t\tfor (const t of [].concat(type)) {\r\n\t\t\t\t\t\tif (!registry[t]) throw new SyntaxError(`[${activeTrailStr}] Unknown node type \"${t}\".`);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (![undefined, null].includes(arity)) {\r\n\t\t\t\t\t\tif (_isObject(arity)) {\r\n\t\t\t\t\t\t\tconst keys = Object.keys(arity);\r\n\t\t\t\t\t\t\tif (keys.some((k) => !['min', 'max', 'eager'].includes(k) || (typeof arity[k] !== (k === 'eager' ? 'boolean' : 'number')))) {\r\n\t\t\t\t\t\t\t\tthrow new SyntaxError(`Invalid arity object \"{ ${keys.join(', ')} }\" for field \"${exposure}\". Only \"min: <number>\", \"max: <number>\" and \"eager: <bool>\" expected.`);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else if ([].concat(arity).some((a) => typeof a !== 'number')) {\r\n\t\t\t\t\t\t\tthrow new SyntaxError(`[${activeTrailStr}] Invalid arity value \"${[].concat(arity).join(', ')}\" for field \"${exposure}\". Number(s) expected.`);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// 2. Compose schema\r\n\t\t\t\tconst fieldSchema = { rulePath: activeTrailStr, type };\r\n\t\t\t\tif (value) fieldSchema.value = value;\r\n\t\t\t\tif (modifier) fieldSchema.modifier = modifier;\r\n\t\t\t\tif (booleanfy) fieldSchema.booleanfy = booleanfy;\r\n\t\t\t\tif (![undefined, null].includes(arity)) fieldSchema.arity = arity;\r\n\t\t\t\tif (singletons) fieldSchema.singletons = singletons;\r\n\t\t\t\tif (optional) fieldSchema.optional = true;\r\n\t\t\t\tif (assert) fieldSchema.assert = assert;\r\n\t\t\t\tif (inference) fieldSchema.if = inference;\r\n\t\t\t\tif (optional && assertionTrail.dependencies.size) {\r\n\t\t\t\t\tfieldSchema.dependencies = Array.from(assertionTrail.dependencies);\r\n\t\t\t\t}\r\n\t\t\t\t// 3. Expose\r\n\t\t\t\t// Earlier rules have populated schemas\r\n\t\t\t\tfor (const schema of schemaSet) {\r\n\t\t\t\t\tschema.set(exposure, fieldSchema);\r\n\t\t\t\t}\r\n\t\t\t\tif (exposure !== '.' && optional && !rule.optional) {\r\n\t\t\t\t\t// Optional context but rule NOT optional within context\r\n\t\t\t\t\tnewDependencyTrail.add(exposure);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (syntax || syntaxes) {\r\n\t\t\t\tconst newAssertionTrail = {\r\n\t\t\t\t\tdependencies: newDependencyTrail,\r\n\t\t\t\t\toptional,\r\n\t\t\t\t\tassert,\r\n\t\t\t\t\tinference,\r\n\t\t\t\t};\r\n\t\t\t\tif (syntax) {\r\n\t\t\t\t\tschemaSet = this._compileASTSchemaFromSyntaxRules(syntax, dialect, { trail: activeTrail.concat('syntax'), schemaSet, assertionTrail: newAssertionTrail });\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tconst newSchemaSet = new Set;\r\n\t\t\t\tfor (const [j, syntax] of syntaxes.entries()) {\r\n\t\t\t\t\tconst schemaSetClone = cloneSchemaSet(schemaSet);\r\n\t\t\t\t\tconst schemaSetCloneResult = this._compileASTSchemaFromSyntaxRules(syntax, dialect, { trail: activeTrail.concat('syntaxes', j), schemaSet: schemaSetClone, assertionTrail: newAssertionTrail });\r\n\t\t\t\t\tfor (const resultSchema of schemaSetCloneResult) {\r\n\t\t\t\t\t\tnewSchemaSet.add(resultSchema);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tschemaSet = newSchemaSet;\r\n\t\t\t}\r\n\t\t}\r\n\t\tconst schemasArray = Array.from(schemaSet);\r\n\t\tfor (let i = 0; i < schemasArray.length; i++) {\r\n\t\t\tconst schemaA = schemasArray[i];\r\n\t\t\tconst schemaAObj = Object.fromEntries(schemaA);\r\n\t\t\tif (!schemaA.size) {\r\n\t\t\t\tschemaSet.delete(schemaA);\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tfor (let j = i + 1; j < schemasArray.length; j++) {\r\n\t\t\t\tconst schemaB = schemasArray[j];\r\n\t\t\t\tconst schemaBObj = Object.fromEntries(schemaB);\r\n\t\t\t\tif (_eq(schemaAObj, schemaBObj, 'cs', 'rulePath')) {\r\n\t\t\t\t\tschemaSet.delete(schemaB);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn schemaSet;\r\n\t}\r\n\r\n\tstatic fromJSON(inputJson, options = {}, callback = null) {\r\n\r\n\t\t// This runs first: giving \"Expr\" - a polymorphic interface to run\r\n\t\tconst astSchema = this.compileASTSchemaFromSyntaxRules(options);\r\n\t\t// 1. Handle polymorphic interfaces\r\n\t\tif (Array.isArray(astSchema.type)) {\r\n\t\t\tfor (const type of astSchema.type) {\r\n\t\t\t\tconst NodeClass = registry[type];\r\n\t\t\t\tconst result = NodeClass.fromJSON(inputJson, options, callback);\r\n\t\t\t\tif (result) return result;\r\n\t\t\t}\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t// ----------\r\n\t\t// Pre compilation...\r\n\t\t// ----------\r\n\t\t// 1. Handle pre-formed nodes\r\n\t\tif (inputJson instanceof AbstractNode) {\r\n\t\t\tif (inputJson instanceof this) return inputJson;\r\n\t\t\tinputJson = inputJson.jsonfy();\r\n\t\t}\r\n\t\t// 2. Handle typed JSON objects\r\n\t\tif (!_isObject(inputJson)) return;\r\n\t\tlet hardCodedNodeName = null;\r\n\t\tif ('nodeName' in inputJson) {\r\n\t\t\tif (inputJson.nodeName && inputJson.nodeName !== this.NODE_NAME) {\r\n\t\t\t\treturn; // API mismatch\r\n\t\t\t}\r\n\t\t\t({ nodeName: hardCodedNodeName, ...inputJson } = inputJson);\r\n\t\t}\r\n\t\t// ----------\r\n\t\t// Compilation...\r\n\t\t// ----------\r\n\t\t// ...defs first\r\n\t\tlet lastAssertion;\r\n\t\tconst $decideThrow = (message, rulePath = null, assertsGrep = false) => {\r\n\t\t\tif (!hardCodedNodeName && options.assert !== true && !(options.assert instanceof RegExp && options.assert.test(activeTrailStr))) return;\r\n\t\t\tif (rulePath) {\r\n\t\t\t\tmessage = `[${rulePath}] ${message}`;\r\n\t\t\t}\r\n\t\t\tif (assertsGrep) {\r\n\t\t\t\tlastAssertion = message;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tthrow new Error(message);\r\n\t\t};\r\n\t\tconst matchTokenRule = (fieldSchema, fieldJson) => {\r\n\t\t\t// Match any predefined value list\r\n\t\t\tif (fieldSchema.value !== undefined) {\r\n\t\t\t\tconst expectedValue = fieldSchema.booleanfy ? [true, false] : fieldSchema.value;\r\n\t\t\t\treturn [].concat(expectedValue).includes(fieldJson.value);\r\n\t\t\t}\r\n\t\t\t// Match standard\r\n\t\t\treturn TOK_TYPES[fieldSchema.type].match?.(fieldJson, options) !== false;\r\n\t\t}\r\n\t\tconst resolveField = (fieldSchema, fieldValue) => {\r\n\t\t\tfor (const type of [].concat(fieldSchema.type)) {\r\n\t\t\t\tconst isTokenRule = typeof type === 'string' && type[0] === type[0].toLowerCase();\r\n\t\t\t\tif (isTokenRule) {\r\n\t\t\t\t\tif (matchTokenRule(fieldSchema, { value: fieldValue }) === true) return fieldValue;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tconst node = registry[type].fromJSON(fieldValue, { ...options, assert: false });\r\n\t\t\t\t\tif (node) return node;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\tconst acquireField = (resultAST, fieldName, fieldSchema, assertsGrep = false) => {\r\n\t\t\t// 1. Validate dependencies\r\n\t\t\tif (fieldSchema.dependencies?.length) {\r\n\t\t\t\tfor (const depField of fieldSchema.dependencies) {\r\n\t\t\t\t\tif (!(depField in resultAST)) {\r\n\t\t\t\t\t\t$decideThrow(`Missing dependency field \"${depField}\" required by \"${fieldName}\"`, fieldSchema.rulePath, assertsGrep);\r\n\t\t\t\t\t\treturn false; // API mismatch\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (fieldSchema.if && !_inferenceMatch(fieldSchema.if, resultAST, fieldSchema.rulePath)) {\r\n\t\t\t\treturn true; // Much like optional\r\n\t\t\t}\r\n\t\t\t// 2. Acquire entries\r\n\t\t\tif (![undefined, null].includes(fieldSchema.arity)) {\r\n\t\t\t\tif (inputJson[fieldName] === undefined) {\r\n\t\t\t\t\t// Undefined at all or empty\r\n\t\t\t\t\tif (fieldSchema.optional) {\r\n\t\t\t\t\t\tresultAST[fieldName] = undefined; // Show up\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t$decideThrow(`Missing required field \"${fieldName}\"`, fieldSchema.rulePath, assertsGrep);\r\n\t\t\t\t\treturn false; // API mismatch\r\n\t\t\t\t}\r\n\t\t\t\tif (!Array.isArray(inputJson[fieldName])) {\r\n\t\t\t\t\t$decideThrow(`Field \"${fieldName}\" must be an array`, fieldSchema.rulePath, assertsGrep);\r\n\t\t\t\t\treturn false; // Defined but API mismatch\r\n\t\t\t\t}\r\n\t\t\t\tif (fieldSchema.arity !== Infinity) {\r\n\t\t\t\t\tconst count = inputJson[fieldName].length;\r\n\t\t\t\t\tif (_isObject(fieldSchema.arity)) {\r\n\t\t\t\t\t\tif ('min' in fieldSchema.arity && count < fieldSchema.arity.min) {\r\n\t\t\t\t\t\t\t$decideThrow(`A minimum of ${fieldSchema.arity.min} argument(s) expected but got ${count}`, fieldSchema.rulePath, assertsGrep);\r\n\t\t\t\t\t\t\treturn false; // API mismatch\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif ('max' in fieldSchema.arity && count > fieldSchema.arity.max) {\r\n\t\t\t\t\t\t\t$decideThrow(`A maximum of ${fieldSchema.arity.max} argument(s) expected but got ${count}`, fieldSchema.rulePath, assertsGrep);\r\n\t\t\t\t\t\t\treturn false; // API mismatch\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if (![].concat(fieldSchema.arity).includes(count)) {\r\n\t\t\t\t\t\t$decideThrow(`Exactly ${[].concat(fieldSchema.arity).join(' or ')} argument(s) expected but got ${count}`, fieldSchema.rulePath, assertsGrep);\r\n\t\t\t\t\t\treturn false; // API mismatch\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tconst resultArray = inputJson[fieldName].map((entry) => resolveField(fieldSchema, entry)).filter((n) => n !== undefined);\r\n\t\t\t\tconst resultLenth = resultArray.length;\r\n\t\t\t\t// Some items resolved and some didn't?: Raise integrity error\r\n\t\t\t\tif (inputJson[fieldName].length > resultLenth) {\r\n\t\t\t\t\t// If resolution failed for all items...\r\n\t\t\t\t\tif (!resultLenth) {\r\n\t\t\t\t\t\t$decideThrow(`Failed to resolve any argument for \"${fieldName}\"`, fieldSchema.rulePath, assertsGrep);\r\n\t\t\t\t\t\treturn false; // API mismatch\r\n\t\t\t\t\t}\r\n\t\t\t\t\t$decideThrow(`Failed to resolve some arguments for \"${fieldName}\"`, fieldSchema.rulePath, assertsGrep);\r\n\t\t\t\t\treturn false; // API mismatch\r\n\t\t\t\t}\r\n\t\t\t\tif (fieldSchema.singletons) {\r\n\t\t\t\t\tconst havingDuplicate = resultArray.find((e, i) => {\r\n\t\t\t\t\t\treturn resultArray.slice(i + 1).some((_e) => {\r\n\t\t\t\t\t\t\treturn fieldSchema.singletons === 'BY_KEY'\r\n\t\t\t\t\t\t\t\t? _e.identifiesAs?.(e)\r\n\t\t\t\t\t\t\t\t: _e instanceof e.constructor;\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t});\r\n\t\t\t\t\tif (havingDuplicate) {\r\n\t\t\t\t\t\t$decideThrow(`Duplicate entry of type \"${havingDuplicate.constructor.name}\"`, fieldSchema.rulePath, assertsGrep);\r\n\t\t\t\t\t\treturn false; // API mismatch\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tresultAST[fieldName] = resultArray;\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\t// 3. Acquire classic field\r\n\t\t\tif (inputJson[fieldName] === undefined) {\r\n\t\t\t\tif (fieldSchema.optional) {\r\n\t\t\t\t\tresultAST[fieldName] = fieldSchema.booleanfy ? false : undefined; // Optional undefined\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t\t$decideThrow(`Missing required field \"${fieldName}\"`, fieldSchema.rulePath, assertsGrep);\r\n\t\t\t\treturn false; // API mismatch\r\n\t\t\t}\r\n\t\t\tconst result = resolveField(fieldSchema, inputJson[fieldName]);\r\n\t\t\tif (result === undefined) {\r\n\t\t\t\t$decideThrow(`Failed to resolve field \"${fieldName}\"`, fieldSchema.rulePath, assertsGrep);\r\n\t\t\t\treturn false; // API mismatch\r\n\t\t\t}\r\n\t\t\tresultAST[fieldName] = result;\r\n\t\t\treturn true;\r\n\t\t};\r\n\t\t// On to the AST composition based on first match\r\n\t\tpaths_loop: for (const $astSchema of (astSchema instanceof Map ? [astSchema] : astSchema)) {\r\n\t\t\tconst resultAST = Object.create(null);\r\n\t\t\tconst astSchema = new Map($astSchema);\r\n\t\t\tlet $inputJson = inputJson;\r\n\t\t\t// Acquire root AST fields\r\n\t\t\tif (astSchema.has('.')) {\r\n\t\t\t\tconst rootRule = astSchema.get('.');\r\n\t\t\t\tconst tokSchema = TOK_TYPES[rootRule.type];\r\n\t\t\t\t// Transfer relevant attributes from \"inputJson\" to \"resultAST\"\r\n\t\t\t\t// This effectively removes root-token-level attributes from \"inputJson\" before the next step below\r\n\t\t\t\tif ([undefined, null].includes($inputJson.value)) {\r\n\t\t\t\t\tcontinue paths_loop;\r\n\t\t\t\t}\r\n\t\t\t\t({ value: resultAST.value, ...$inputJson } = $inputJson);\r\n\t\t\t\tfor (const attr of Object.keys(tokSchema)) {\r\n\t\t\t\t\tif (typeof tokSchema[attr] === 'function') continue;\r\n\t\t\t\t\tif (attr in $inputJson) {\r\n\t\t\t\t\t\t({ [attr]: resultAST[attr], ...$inputJson } = $inputJson);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (matchTokenRule(rootRule, resultAST) === false) {\r\n\t\t\t\t\tcontinue paths_loop;\r\n\t\t\t\t}\r\n\t\t\t\tastSchema.delete('.');\r\n\t\t\t}\r\n\t\t\t// Acquire other AST fields\r\n\t\t\tfor (const fieldName of new Set(Object.keys($inputJson).concat(...astSchema.keys()))) {\r\n\t\t\t\t// Handle early mismatch\r\n\t\t\t\tif (!astSchema.has(fieldName)) {\r\n\t\t\t\t\tif (inputJson[fieldName] === undefined) {\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcontinue paths_loop; // To next schema; API mismatch\r\n\t\t\t\t}\r\n\t\t\t\tconst fieldSchema = astSchema.get(fieldName);\r\n\t\t\t\tif (acquireField(resultAST, fieldName, fieldSchema, true) === false) {\r\n\t\t\t\t\tcontinue paths_loop; // To next schema; API mismatch\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// Done here. First match!!!\r\n\t\t\tif (typeof callback === 'function') {\r\n\t\t\t\treturn callback(resultAST, options);\r\n\t\t\t}\r\n\t\t\treturn new this(resultAST, options);\r\n\t\t}\r\n\t\t$decideThrow(`Failed to match any schema${lastAssertion ? `. ${lastAssertion}` : ''}`, this.NODE_NAME);\r\n\t}\r\n\r\n\t// -----------\r\n\r\n\ttoJSON() { return this.jsonfy(); }\r\n\r\n\tjsonfy(options = {}, transformer = null, schemaInference = null) {\r\n\r\n\t\tconst jsonfy = (key, value, relevantTransformer) => {\r\n\r\n\t\t\tconst defaultTransform = (options1 = options, childTransformer = relevantTransformer) => {\r\n\t\t\t\tif (Array.isArray(value)) {\r\n\t\t\t\t\treturn value.reduce((entries, value, i) => {\r\n\t\t\t\t\t\tconst result = jsonfy(i, value, childTransformer);\r\n\t\t\t\t\t\tif (result === undefined) return entries;\r\n\t\t\t\t\t\treturn entries.concat(result);\r\n\t\t\t\t\t}, []);\r\n\t\t\t\t}\r\n\t\t\t\tif (value instanceof AbstractNode) {\r\n\t\t\t\t\treturn value.jsonfy(options1, childTransformer, schemaInference);\r\n\t\t\t\t}\r\n\t\t\t\treturn value;\r\n\t\t\t};\r\n\r\n\t\t\tif (value === undefined) return;\r\n\t\t\t\r\n\t\t\tconst result = relevantTransformer\r\n\t\t\t\t? relevantTransformer.transform(value, defaultTransform, key, options)\r\n\t\t\t\t: defaultTransform();\r\n\r\n\t\t\tif (result instanceof AbstractNode) {\r\n\t\t\t\tthrow new Error(`\"jsonfy\" transforms must return plain JSON objects.`);\r\n\t\t\t}\r\n\r\n\t\t\treturn result;\r\n\t\t};\r\n\r\n\t\treturn {\r\n\t\t\t...(options.nodeNames !== false ? { nodeName: this.NODE_NAME } : {}),\r\n\t\t\t...Object.fromEntries(Object.entries(this.#ast).reduce((resultEntries, [fieldName, value]) => {\r\n\r\n\t\t\t\tconst result = jsonfy(fieldName, value, transformer);\r\n\t\t\t\tif (result === undefined) return resultEntries;\r\n\r\n\t\t\t\treturn [...resultEntries, [fieldName, result]];\r\n\t\t\t}, [])),\r\n\t\t};\r\n\t}\r\n\r\n\t/**\r\n\t * -----------\r\n\t * PARSER API\r\n\t * -----------\r\n\t */\r\n\r\n\tstatic async toStream(input, options = {}) {\r\n\t\tconst tokenStream = !(input instanceof TokenStream)\r\n\t\t\t? await TokenStream.create(input, { structured: true, spaces: true, ...options })\r\n\t\t\t: input;\r\n\t\tif (!tokenStream.current() && !tokenStream.done) {\r\n\t\t\tawait tokenStream.next();\r\n\t\t}\r\n\t\treturn tokenStream;\r\n\t}\r\n\r\n\tstatic async parse(input, { left = undefined, minPrecedence = 0, trail = [], ...options } = {}) {\r\n\t\tconst tokenStream = await this.toStream(input, options);\r\n\t\tconst savepoint = tokenStream.savepoint();\r\n\t\tconst syntaxRules = this.syntaxRules;\r\n\t\t// 1. Resolve polymorphic interfaces\r\n\t\tlet result, rulesArray;\r\n\t\tif ((rulesArray = [].concat(syntaxRules)).length === 1 && Array.isArray(rulesArray[0].type) && !rulesArray[0].as) {\r\n\t\t\tif (rulesArray[0].expression) {\r\n\t\t\t\tresult = await this._parseAsExpression(tokenStream, rulesArray[0].type, { exprClass: rulesArray[0].expression, left, minPrecedence, trail: trail.concat(this.NODE_NAME), ...options });\r\n\t\t\t} else {\r\n\t\t\t\tresult = await this._parseFromTypes(tokenStream, rulesArray[0].type, { left, minPrecedence, trail: trail.concat(this.NODE_NAME), ...options });\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t// 2. Resolve full syntax rules\r\n\t\t\tconst resultAST = await this._parseFromRules(tokenStream, syntaxRules, { left, minPrecedence, trail: trail.concat(this.NODE_NAME), ...options });\r\n\t\t\tif (resultAST) {\r\n\t\t\t\tresult = new this(resultAST, { ...options, dialect: tokenStream.options.dialect });\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (!result) tokenStream.restore(savepoint);\r\n\t\treturn result;\r\n\t}\r\n\r\n\tstatic async _parseAsExpression(tokenStream, types, { exprClass = 1, left = undefined, minPrecedence, trail, ...options }) {\r\n\t\tif (left) throw new Error(`TODO`);\r\n\t\tleft = await this._parseFromTypes(tokenStream, types, { minPrecedence, trail, ...options });\r\n\t\twhile (left) {\r\n\t\t\t// Compose binary expressions (e.g., col + 2)\r\n\t\t\tconst operator = await tokenStream.match('operator');\r\n\t\t\tif (!operator || operator.prec < minPrecedence) break;\r\n\t\t\tif (operator.isSetOp && exprClass !== 2) break;\r\n\t\t\tconst newLeft = await this._parseFromTypes(tokenStream, types, {\r\n\t\t\t\tleft,\r\n\t\t\t\tminPrecedence,\r\n\t\t\t\ttrail,\r\n\t\t\t\t...options\r\n\t\t\t});\r\n\t\t\tif (!newLeft) return left;\r\n\t\t\tleft = newLeft;\r\n\t\t}\r\n\t\treturn left;\r\n\t}\r\n\r\n\tstatic async _parseFromRules(tokenStream, syntaxRules, { left, minPrecedence, trail, ...options }, resultAST = {}) {\r\n\t\tconst rulesArray = Array.isArray(syntaxRules) ? syntaxRules : [syntaxRules];\r\n\t\tlet numSkippedRules_dialectWise = 0;\r\n\t\tlet newMinPrecedence = minPrecedence; // Default being 0\r\n\r\n\t\tfor (const [i, rule] of rulesArray.entries()) {\r\n\t\t\tif (rule.dialect && rule.dialect !== tokenStream.options.dialect) {\r\n\t\t\t\tnumSkippedRules_dialectWise++;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\t// -----\r\n\t\t\t// Rule destructuring...\r\n\t\t\t// -----\r\n\r\n\t\t\tconst {\r\n\t\t\t\trequiredSpacing,\r\n\t\t\t\tpeek,\r\n\t\t\t\ttype, // Usable in combination with \"syntax\", \"syntaxes\" for type === \"*_block\"\r\n\t\t\t\tvalue, // Token value matching\r\n\t\t\t\tsyntax, // Mutually-exclusive with \"syntaxes\" and \"type\" - except for type === \"*_block\"\r\n\t\t\t\tsyntaxes, // Mutually-exclusive with \"syntax\" and \"type\" - except for type === \"*_block\"\r\n\t\t\t\tas: exposure,\r\n\t\t\t\tif: inference,\r\n\t\t\t\tarity,\r\n\t\t\t\toptionalParens,\r\n\t\t\t\tsingletons,\r\n\t\t\t\titemSeparator,\r\n\t\t\t\toptional = false,\r\n\t\t\t\tassert = false,\r\n\t\t\t\tbooleanfy,\r\n\t\t\t\t...rest\r\n\t\t\t} = rule;\r\n\r\n\t\t\tconst activeTrail = trail.concat(`${Array.isArray(syntaxRules) ? i : ''}${exposure ? `<${exposure}>` : ''}` || []);\r\n\t\t\tconst activeTrailStr = activeTrail.join('.');\r\n\t\t\tconst unsupportedAttrs = _getUnsupportedRuleAttrs(rest);\r\n\t\t\tif (unsupportedAttrs.length) {\r\n\t\t\t\tthrow new SyntaxError(`[${activeTrailStr}] Unsupported attributes in rule: \"${unsupportedAttrs.join('\", \"')}\".`);\r\n\t\t\t}\r\n\t\t\tconst isTokenRule = typeof type === 'string' && type[0] === type[0].toLowerCase();\r\n\t\t\tconst supportsLeft = exposure && !isTokenRule && rulesArray[i + 1]?.type === 'operator' || (rulesArray[i + 1]?.type === 'punctuation' && rulesArray[i + 1]?.value === '.');\r\n\t\t\t// -----\r\n\t\t\t// Definitions...\r\n\t\t\t// -----\r\n\t\t\tconst acquireLeft = async () => {\r\n\t\t\t\tif (Array.isArray(peek) && !await peekToken(-1)) return;\r\n\t\t\t\tfor (const name of [].concat(type)) {\r\n\t\t\t\t\tif (left instanceof registry[name]) {\r\n\t\t\t\t\t\tresultAST[exposure] = left;\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn false;\r\n\t\t\t};\r\n\t\t\tconst matchSpacing = () => {\r\n\t\t\t\tconst current = tokenStream.current();\r\n\t\t\t\treturn (\r\n\t\t\t\t\t(requiredSpacing === false && !current?.spaceBefore) ||\r\n\t\t\t\t\t(requiredSpacing === true && current?.spaceBefore) ||\r\n\t\t\t\t\t(requiredSpacing === '\\n' && /\\n/.test(current?.spaceBefore))\r\n\t\t\t\t);\r\n\t\t\t};\r\n\t\t\tconst peekToken = async (adjustBy = 0) => {\r\n\t\t\t\tif (adjustBy) return await tokenStream.match(...[peek[0] + adjustBy, ...peek.slice(1)]);\r\n\t\t\t\treturn await tokenStream.match/*NOTE: not peek()*/(...peek);\r\n\t\t\t};\r\n\t\t\tconst eatToken = async () => {\r\n\t\t\t\tlet op;\r\n\t\t\t\tif ((op = await tokenStream.match('operator')) && op.prec < minPrecedence) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tconst tok = await tokenStream.eat(type, type.endsWith('_block') ? undefined : value);\r\n\t\t\t\tif (tok?.type === 'operator') {\r\n\t\t\t\t\tnewMinPrecedence = tok.prec + (tok.assoc === 'right' ? 0 : 1);\r\n\t\t\t\t}\r\n\t\t\t\treturn tok;\r\n\t\t\t};\r\n\t\t\tconst parseNode = async (activeTokenStream, newMinPrecedence) => {\r\n\t\t\t\tif (Array.isArray(type)) {\r\n\t\t\t\t\treturn await this._parseFromTypes(activeTokenStream, type, { minPrecedence: newMinPrecedence, trail: activeTrail, ...options });\r\n\t\t\t\t}\r\n\t\t\t\tconst NodeClass = registry[type];\r\n\t\t\t\tif (!NodeClass) throw new SyntaxError(`[${activeTrailStr}] Unknown node type <${type}>.`);\r\n\t\t\t\treturn await NodeClass.parse(activeTokenStream, { minPrecedence: newMinPrecedence, trail: activeTrail, ...options });\r\n\t\t\t};\r\n\t\t\tconst $decideThrow = (activeTokenStream, message, tokenStreamPosition = false, forceThrow = false) => {\r\n\t\t\t\tif (!assert && !forceThrow && options.assert !== true && !(options.assert instanceof RegExp && options.assert.test(activeTrailStr))) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tif (tokenStreamPosition) {\r\n\t\t\t\t\tconst current = activeTokenStream.current() || activeTokenStream.previous();\r\n\t\t\t\t\tconst proximityTerm = activeTokenStream.current() ? (tokenStreamPosition === 1 ? ':' : ' near') : ' by';\r\n\t\t\t\t\tmessage += !current ? `${proximityTerm} end of stream` : `${proximityTerm}${typeof current.value === 'string' ? ` \"${current.value}\"` : ''} (${current.type}) at <line ${current.line}, column ${current.column}>`;\r\n\t\t\t\t}\r\n\t\t\t\tthrow new SyntaxError(`[${activeTrailStr}] ${message}.`);\r\n\t\t\t};\r\n\r\n\t\t\t// -----\r\n\t\t\t// Validation...\r\n\t\t\t// -----\r\n\r\n\t\t\tif (type) {\r\n\t\t\t\tif (left) {\r\n\t\t\t\t\tif (!supportsLeft) return;\r\n\t\t\t\t\t// left === false is typically passed from PathMixin()\r\n\t\t\t\t\tif (!await acquireLeft()) return;\r\n\t\t\t\t\tleft = null;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t} else if (left === false && supportsLeft) {\r\n\t\t\t\t\tif (optional) {\r\n\t\t\t\t\t\tleft = null;\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// 2. Exit on any of the following...\r\n\t\t\t// Exit if a certain prop isn't in AST\r\n\t\t\tif (inference && !_inferenceMatch(inference, resultAST, activeTrailStr)) {\r\n\t\t\t\tcontinue; // Much like optional\r\n\t\t\t}\r\n\t\t\t// Exit if spacing doesn't match\r\n\t\t\tif (requiredSpacing !== undefined && !matchSpacing()) {\r\n\t\t\t\t$decideThrow(tokenStream, 'Required spacing mismatch', true);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\t// Exit if look-ahead fails\r\n\t\t\tif (Array.isArray(peek) && !await peekToken()) {\r\n\t\t\t\t$decideThrow(tokenStream, 'Peek failure', true);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// -----\r\n\t\t\t// Parsing...\r\n\t\t\t// -----\r\n\r\n\t\t\t// 1. Terminal node rules...\r\n\t\t\tif (exposure === '.') {\r\n\t\t\t\tif (!type || !isTokenRule) throw new SyntaxError(`[${activeTrailStr}] Terminal node rules must be token-typed rules.`);\r\n\t\t\t\tconst tok = await eatToken();\r\n\t\t\t\tif (!tok) {\r\n\t\t\t\t\t$decideThrow(tokenStream, `Token of type \"${type}\"${value ? ` and value \"${value}\"` : ''} expected but got \"${tokenStream.current()?.type}\"`, true);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tlet _type, line, column, spaceBefore, prec, assoc, resultType, rest;\r\n\t\t\t\t({ type: _type, line, column, spaceBefore, prec, assoc, resultType, ...rest } = tok);\r\n\t\t\t\tObject.assign(resultAST, rest);\r\n\t\t\t\tcontinue; // To next rule\r\n\t\t\t}\r\n\r\n\t\t\t// 2. Block rules... Unwrapped for the next set of evaluation...\r\n\t\t\tlet activeTokenStream = tokenStream;\r\n\t\t\tif (typeof type === 'string' && type.endsWith('_block')) {\r\n\t\t\t\tif (!(activeTokenStream = (await eatToken())?.value)) {\r\n\t\t\t\t\tif (optional) {\r\n\t\t\t\t\t\tcontinue; // To next rule\r\n\t\t\t\t\t}\r\n\t\t\t\t\t$decideThrow(tokenStream, `Token of type \"${type}\" expected but got \"${tokenStream.current()?.type}\"`, true);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tnewMinPrecedence = 0; // IMPORTANT: minPrecedence don't apply to blocks\r\n\t\t\t\tif (!activeTokenStream.current() && !activeTokenStream.done) {\r\n\t\t\t\t\tawait activeTokenStream.next();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// 3. Variadic field rules...\r\n\t\t\tif (![undefined, null].includes(arity)) {\r\n\t\t\t\tif (!exposure) throw new SyntaxError(`[${activeTrailStr}] Multi-argument field rules must have a \"as\" attribute.`);\r\n\t\t\t\tif (!type) throw new SyntaxError(`[${activeTrailStr}] Multi-argument field rules must have a \"type\" attribute.`);\r\n\t\t\t\tif (isTokenRule) throw new SyntaxError(`[${activeTrailStr}] Multi-argument field rules must be node-typed rules.`);\r\n\r\n\t\t\t\tlet entry, entries = [], itemMinPrecedence = newMinPrecedence;\r\n\t\t\t\tif (itemSeparator?.type === 'operator') {\r\n\t\t\t\t\t// Use the binding power of the itemSeparator\r\n\t\t\t\t\tconst relevantOperatorDef = itemSeparator.value && (\r\n\t\t\t\t\t\tactiveTokenStream.options.operators?.classic.get(itemSeparator.value) || activeTokenStream.options.operators?.compound.get(itemSeparator.value)\r\n\t\t\t\t\t);\r\n\t\t\t\t\tif (relevantOperatorDef?.prec) {\r\n\t\t\t\t\t\titemMinPrecedence = relevantOperatorDef?.prec + 1;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\twhile ((entry = await parseNode(activeTokenStream, itemMinPrecedence))) {\r\n\t\t\t\t\tif (singletons) {\r\n\t\t\t\t\t\tconst isDuplicate = singletons === 'BY_KEY'\r\n\t\t\t\t\t\t\t? entries.some((e) => e.identifiesAs?.(entry))\r\n\t\t\t\t\t\t\t: entries.some((e) => e instanceof entry.constructor);\r\n\t\t\t\t\t\tif (isDuplicate) {\r\n\t\t\t\t\t\t\t$decideThrow(activeTokenStream, `Duplicate entry of type \"${entry.constructor.name}\"`, true, true);\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tentries.push(entry);\r\n\t\t\t\t\tif (_isObject(arity) && arity.eager === false && entries.length === arity.max) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (itemSeparator && !await activeTokenStream.eat(\r\n\t\t\t\t\t\titemSeparator.type,\r\n\t\t\t\t\t\titemSeparator.value\r\n\t\t\t\t\t)) break;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (arity !== Infinity) {\r\n\t\t\t\t\tconst count = entries.length;\r\n\t\t\t\t\tif (!count && optional) {\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tconst current = activeTokenStream.current();\r\n\t\t\t\t\tconst currentAsUnexpected = current ? `. Unexpected ${current.type}${typeof current.value === 'string' ? ` \"${current.value}\"` : ''}` : '';\r\n\t\t\t\t\tif (_isObject(arity)) {\r\n\t\t\t\t\t\tif ('min' in arity && count < arity.min) {\r\n\t\t\t\t\t\t\t$decideThrow(activeTokenStream, `A minimum of ${arity.min} argument(s) expected but got ${count}${currentAsUnexpected}`, true);\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif ('max' in arity && count > arity.max) {\r\n\t\t\t\t\t\t\t$decideThrow(activeTokenStream, `A maximum of ${arity.max} argument(s) expected but got ${count}${currentAsUnexpected}`, true);\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if (![].concat(arity).includes(count)) {\r\n\t\t\t\t\t\t$decideThrow(activeTokenStream, `Exactly ${[].concat(arity).join(' or ')} argument(s) expected but got ${count}${currentAsUnexpected}`, true);\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tresultAST[exposure] = entries;\r\n\t\t\t\tcontinue; // To next rule\r\n\t\t\t}\r\n\r\n\t\t\t// 4. Classic rules...\r\n\t\t\tlet result;\r\n\t\t\tif (syntax) {\r\n\t\t\t\tconst savepoint = activeTokenStream.savepoint();\r\n\t\t\t\tresult = await this._parseFromRules(activeTokenStream, syntax, { left, minPrecedence: newMinPrecedence, trail: activeTrail.concat('syntax'), ...options });\r\n\t\t\t\tif (result === undefined) {\r\n\t\t\t\t\tactiveTokenStream.restore(savepoint);\r\n\t\t\t\t} else if (left) {\r\n\t\t\t\t\tleft = null;\r\n\t\t\t\t}\r\n\t\t\t} else if (syntaxes) {\r\n\t\t\t\tfor (const [j, syntax] of syntaxes.entries()) {\r\n\t\t\t\t\tconst savepoint = activeTokenStream.savepoint();\r\n\t\t\t\t\tresult = await this._parseFromRules(activeTokenStream, syntax, { left, minPrecedence: newMinPrecedence, trail: activeTrail.concat('syntaxes', j), ...options });\r\n\t\t\t\t\tif (result === undefined) {\r\n\t\t\t\t\t\tactiveTokenStream.restore(savepoint);\r\n\t\t\t\t\t} else break;\r\n\t\t\t\t}\r\n\t\t\t\tif (result !== undefined && left) {\r\n\t\t\t\t\tleft = null;\r\n\t\t\t\t}\r\n\t\t\t} else if (!(typeof type === 'string' && type.endsWith('_block'))) {\r\n\t\t\t\tresult = isTokenRule\r\n\t\t\t\t\t? (await eatToken())?.value\r\n\t\t\t\t\t: await parseNode(activeTokenStream, newMinPrecedence);\r\n\t\t\t} else if (!type) {\r\n\t\t\t\tthrow new SyntaxError(`[${activeTrailStr}] Rules must have a \"type\", \"syntax\" or \"syntaxes\" attribute.`);\r\n\t\t\t}\r\n\r\n\t\t\tif (result === undefined && !optional) {\r\n\t\t\t\t$decideThrow(activeTokenStream, type ? 'Unexpected token' : null, 1);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif (typeof type === 'string' && type.endsWith('_block')\r\n\t\t\t\t&& !activeTokenStream.done\r\n\t\t\t\t&& activeTokenStream.current()) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif (exposure) {\r\n\t\t\t\tif (booleanfy) {\r\n\t\t\t\t\tresult = result !== undefined;\r\n\t\t\t\t}\r\n\t\t\t\tresultAST[exposure] = result;\r\n\t\t\t} else if (syntax || syntaxes) {\r\n\t\t\t\tObject.assign(resultAST, result);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (numSkippedRules_dialectWise === rulesArray.length) {\r\n\t\t\t// IMPORTANT: Hard-exit to prevent returning a false positive, empty, resultAST\r\n\t\t\treturn;\r\n\t\t}\r\n\t\treturn resultAST;\r\n\t}\r\n\r\n\tstatic async _parseFromTypes(tokenStream, types, { left, minPrecedence, trail, ...options }) {\r\n\t\tfor (const type of types) {\r\n\t\t\tconst isTokenRule = typeof type === 'string' && type[0] === type[0].toLowerCase();\r\n\r\n\t\t\tif (isTokenRule) {\r\n\t\t\t\tif (await tokenStream.match(type)) {\r\n\t\t\t\t\treturn await tokenStream.eat();\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tconst NodeClass = registry[type];\r\n\t\t\t\tif (!NodeClass) throw new SyntaxError(`[${this.NODE_NAME}] Unknown node type \"${type}\".`);\r\n\t\t\t\tconst result = await NodeClass.parse(tokenStream, { left, minPrecedence, trail, ...options });\r\n\t\t\t\tif (result !== undefined) return result;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// -----------\r\n\r\n\ttoString() { return this.stringify(); }\r\n\r\n\tstringify(options = {}) {\r\n\t\t// Main\r\n\t\tconst rendering = this._stringifyFromRules(this.constructor.syntaxRules, { trail: [this.NODE_NAME], ...options });\r\n\t\treturn rendering;\r\n\t}\r\n\r\n\t_stringifyFromRules(syntaxRules, { trail = [], startingIndentLevel = 0, autoLineBreakThreshold = 60, ...options }, renderingStats = null) {\r\n\t\t// Formatters\r\n\t\tconst $space = () => ' ';\r\n\t\tconst $lineBreak = (indentLevel) => {\r\n\t\t\treturn `\\n${(\r\n\t\t\t\toptions.tabSpaces === 4 ? '\\t' : ' '.repeat(options.tabSpaces || 2)\r\n\t\t\t).repeat(indentLevel)}`;\r\n\t\t};\r\n\r\n\t\tconst resultTokens = [];\r\n\t\tconst rulesArray = [].concat(syntaxRules);\r\n\t\tlet numSkippedRules_optionalWise = 0;\r\n\r\n\t\tfor (const [i, rule] of rulesArray.entries()) {\r\n\t\t\tif (rule.dialect && rule.dialect !== this.options.dialect) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\t// -----\r\n\t\t\t// Rule destructuring...\r\n\t\t\t// -----\r\n\r\n\t\t\tconst {\r\n\t\t\t\trequiredSpacing,\r\n\t\t\t\ttype,\r\n\t\t\t\tvalue,\r\n\t\t\t\tbooleanfy,\r\n\t\t\t\tsyntax,\r\n\t\t\t\tsyntaxes,\r\n\t\t\t\tas: exposure,\r\n\t\t\t\tif: inference,\r\n\t\t\t\tarity,\r\n\t\t\t\titemSeparator,\r\n\t\t\t\toptional = false,\r\n\t\t\t\tautoSpacing = requiredSpacing,\r\n\t\t\t\toptionalParens,\r\n\t\t\t\tautoIndent = false,\r\n\t\t\t\tautoIndentAdjust = 0,\r\n\t\t\t} = rule;\r\n\r\n\t\t\tconst activeTrail = trail.concat(`${Array.isArray(syntaxRules) ? i : ''}${exposure ? `<${exposure}>` : ''}` || []);\r\n\t\t\tconst activeTrailStr = activeTrail.join('.');\r\n\t\t\tlet $autoIndent = autoIndent;\r\n\r\n\t\t\tif (inference && !_inferenceMatch(inference, this.#ast, this.NODE_NAME)) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tconst activeOptions = {\r\n\t\t\t\tstartingIndentLevel: startingIndentLevel + (autoIndent ? 1 : 0) + autoIndentAdjust,\r\n\t\t\t\tautoLineBreakThreshold,\r\n\t\t\t\t...options\r\n\t\t\t};\r\n\r\n\t\t\tlet rendering;\r\n\t\t\tif (![undefined, null].includes(arity)) {\r\n\t\t\t\tlet shouldRender = false; // Until we match items to syntax's arity\r\n\r\n\t\t\t\tconst entries = this._get(exposure);\r\n\t\t\t\tconst count = entries?.length || 0;\r\n\r\n\t\t\t\tif (typeof autoIndent === 'number' && count < autoIndent) {\r\n\t\t\t\t\tactiveOptions.startingIndentLevel -= 1;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (entries) {\r\n\t\t\t\t\tif (!(shouldRender = arity === Infinity)) {\r\n\t\t\t\t\t\tif (_isObject(arity)) {\r\n\t\t\t\t\t\t\tshouldRender = (!('min' in arity) || count >= arity.min)\r\n\t\t\t\t\t\t\t\t&& (!('max' in arity) || count <= arity.max);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tshouldRender = [].concat(arity).includes(count)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (shouldRender) {\r\n\t\t\t\t\tconst itemsRendering = entries.map((entry) => entry.stringify(activeOptions));\r\n\t\t\t\t\t$autoIndent = autoIndent === true\r\n\t\t\t\t\t\t|| (typeof autoIndent === 'number' && entries.length >= autoIndent)\r\n\t\t\t\t\t\t|| autoSpacing === '\\n';\r\n\t\t\t\t\t// Determine item spacing...\r\n\t\t\t\t\tconst renderingsStr = itemsRendering.join(' ');\r\n\t\t\t\t\tconst $autoItemSpacing = activeOptions.prettyPrint && $autoIndent && (renderingsStr.length > autoLineBreakThreshold || renderingsStr.includes('\\n'))\r\n\t\t\t\t\t\t? $lineBreak(activeOptions.startingIndentLevel)\r\n\t\t\t\t\t\t: $space();\r\n\t\t\t\t\t// Compose separator\r\n\t\t\t\t\tlet $itemSeparator = itemSeparator ? this._stringifyTerminal(itemSeparator, activeOptions) : '';\r\n\t\t\t\t\tif (/^\\w+$/.test($itemSeparator)) {\r\n\t\t\t\t\t\t$itemSeparator = `${$autoItemSpacing}${$itemSeparator}${$autoItemSpacing}`;\r\n\t\t\t\t\t} else if ($itemSeparator === ';' && activeOptions.prettyPrint) {\r\n\t\t\t\t\t\t$itemSeparator = `${$itemSeparator}\\n${$autoItemSpacing}`;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t$itemSeparator = `${$itemSeparator}${$autoItemSpacing}`;\r\n\t\t\t\t\t}\r\n\t\t\t\t\trendering = itemsRendering.join($itemSeparator);\r\n\t\t\t\t}\r\n\t\t\t} else if (syntax) {\r\n\t\t\t\trendering = this._stringifyFromRules(syntax, { trail: activeTrail.concat('syntax'), ...activeOptions }, renderingStats);\r\n\t\t\t} else if (syntaxes) {\r\n\r\n\t\t\t\tlet highestRenderingScore = -1;\r\n\r\n\t\t\t\tfor (const [j, syntax] of syntaxes.entries()) {\r\n\t\t\t\t\tconst newRenderingStats = { score: 0 };\r\n\t\t\t\t\tconst $rendering = this._stringifyFromRules(syntax, { trail: activeTrail.concat('syntaxes', j), ...activeOptions }, newRenderingStats);\r\n\t\t\t\t\tif (typeof $rendering === 'string' && newRenderingStats.score > highestRenderingScore) {\r\n\t\t\t\t\t\trendering = $rendering;\r\n\t\t\t\t\t\thighestRenderingScore = newRenderingStats.score;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (renderingStats) { renderingStats.score += highestRenderingScore; }\r\n\t\t\t} else {\r\n\t\t\t\tif (exposure) {\r\n\t\t\t\t\tlet fieldValue = this._get(exposure === '.' ? 'value' : exposure);\r\n\t\t\t\t\tconst hasExpectedValue = value !== undefined && value !== null;\r\n\t\t\t\t\tif (hasExpectedValue && booleanfy) {\r\n\t\t\t\t\t\tif (fieldValue === true) {\r\n\t\t\t\t\t\t\tfieldValue = value;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (hasExpectedValue) {\r\n\t\t\t\t\t\tif ([].concat(value).includes(fieldValue)) {\r\n\t\t\t\t\t\t\tif (renderingStats) {\r\n\t\t\t\t\t\t\t\trenderingStats.score++;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tfieldValue = undefined;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (fieldValue !== undefined) {\r\n\t\t\t\t\t\tif (fieldValue instanceof AbstractNode) {\r\n\t\t\t\t\t\t\tfieldValue = fieldValue.stringify(activeOptions);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tconst $rule = exposure === '.'\r\n\t\t\t\t\t\t\t? { ...rule, ...this.#ast }\r\n\t\t\t\t\t\t\t: { ...rule, value: fieldValue };\r\n\t\t\t\t\t\trendering = this._stringifyTerminal($rule, activeOptions);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\t\t\t\t\trendering = this._stringifyTerminal(rule, activeOptions);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// -----\r\n\r\n\t\t\tif (type === 'paren_block' && optionalParens) {\r\n\t\t\t\tif (!rendering?.trim()) {\r\n\t\t\t\t\tif (optionalParens === true || options.pruneOptionalParens) {\r\n\t\t\t\t\t\tif (renderingStats) {\r\n\t\t\t\t\t\t\trenderingStats.score++;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tnumSkippedRules_optionalWise++;\r\n\t\t\t\t\t\tcontinue; // Skip this rule\r\n\t\t\t\t\t}\r\n\t\t\t\t\trendering = '';\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (rendering === undefined) {\r\n\t\t\t\tif (optional) {\r\n\t\t\t\t\tnumSkippedRules_optionalWise++;\r\n\t\t\t\t\tcontinue; // Skip this rule\r\n\t\t\t\t}\r\n\t\t\t\treturn; // Exit whole rule sequence\r\n\t\t\t}\r\n\t\t\tif (exposure && renderingStats) {\r\n\t\t\t\trenderingStats.score++;\r\n\t\t\t}\r\n\r\n\t\t\t// Add \"block\" tags?\r\n\t\t\tlet autoSpaceIgnore = false;\r\n\t\t\tconst hitsAutoLineBreakThreshold = rendering.length > autoLineBreakThreshold || /**/rendering.includes('\\n');\r\n\t\t\tif (typeof type === 'string' && type.endsWith('_block')) {\r\n\t\t\t\tconst blockAutoLineBreakMode = activeOptions.prettyPrint && autoIndent && hitsAutoLineBreakThreshold;\r\n\t\t\t\tconst delims = { brace_block: '{}', bracket_block: '[]', paren_block: '()' }[type];\r\n\r\n\t\t\t\trendering = [\r\n\t\t\t\t\tdelims[0],\r\n\t\t\t\t\tblockAutoLineBreakMode && !/^\\s/.test(rendering) ? $lineBreak(startingIndentLevel + 1) : (delims[0] === '{' ? $space() : ''),\r\n\t\t\t\t\trendering,\r\n\t\t\t\t\tblockAutoLineBreakMode || /^\\s/.test(rendering) ? $lineBreak(startingIndentLevel) : (delims[1] === '}' ? $space() : ''),\r\n\t\t\t\t\tdelims[1],\r\n\t\t\t\t].join('');\r\n\t\t\t} else if (activeOptions.prettyPrint && $autoIndent && (resultTokens.length || hitsAutoLineBreakThreshold) && rendering !== '') {\r\n\r\n\t\t\t\trendering = [\r\n\t\t\t\t\t$lineBreak(startingIndentLevel + (autoSpacing === '\\n' ? 0 : 1)),\r\n\t\t\t\t\trendering,\r\n\t\t\t\t].join('');\r\n\r\n\t\t\t\tautoSpaceIgnore = true;\r\n\t\t\t}\r\n\t\t\t// Space this chunk?\r\n\t\t\tconst precedingTok = resultTokens[resultTokens.length - 1];\r\n\t\t\tif (rendering !== ''\r\n\t\t\t\t&& !autoSpaceIgnore\r\n\t\t\t\t&& resultTokens.length\r\n\t\t\t\t// \"Do\" autoSpacing didnt already end with a space character\r\n\t\t\t\t&& !/\\s$/.test(precedingTok)\r\n\t\t\t\t// \"Force\" autoSpacing if previous token ends as alphanumeric and new token (rendering) starts as alphanumeric\r\n\t\t\t\t&& (Array.isArray(autoSpacing) ? autoSpacing.includes(precedingTok) : autoSpacing !== false)) {\r\n\t\t\t\tif (autoSpacing === '\\n' && activeOptions.prettyPrint) {\r\n\t\t\t\t\tresultTokens.push($lineBreak(startingIndentLevel));\r\n\t\t\t\t} else {\r\n\t\t\t\t\tresultTokens.push($space());\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tresultTokens.push(rendering);\r\n\t\t}\r\n\t\tif (resultTokens.length || numSkippedRules_optionalWise === rulesArray.length) {\r\n\t\t\treturn resultTokens.join('');\r\n\t\t}\r\n\t}\r\n\r\n\t_stringifyTerminal(tok, options = {}) {\r\n\t\tswitch (tok.type) {\r\n\t\t\tcase 'data_type': return this._stringifyDataType(tok, options);\r\n\t\t\tcase 'identifier': return this._stringifyIdentifier(tok, options);\r\n\t\t\tcase 'keyword': return this._stringifyKeyword(tok, options);\r\n\t\t\tcase 'operator': return this._stringifyOperator(tok, options);\r\n\t\t\tcase 'punctuation': return this._stringifyPunctuation(tok, options);\r\n\t\t\tcase 'bind_var': return this._stringifyBindVar(tok, options);\r\n\t\t\tcase 'version_spec': return `@${tok.value}`;\r\n\t\t}\r\n\t\tif (!Array.isArray(tok.type)) {\r\n\t\t\tif (tok.type.endsWith('_literal')) {\r\n\t\t\t\treturn this._stringifyLiteral(tok, options);\r\n\t\t\t}\r\n\t\t\tif (tok.type.endsWith('_var')) {\r\n\t\t\t\treturn this._stringifyVariable(tok, options);\r\n\t\t\t}\r\n\t\t\tif (tok.type.endsWith('_comment')) {\r\n\t\t\t\treturn this._stringifyComment(tok, options);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn String(tok.value);\r\n\t}\r\n\r\n\t_stringifyIdentifier(tok) {\r\n\t\tconst { value } = tok;\r\n\t\tconst delimChars = ['\"'];\r\n\t\t// ------------\r\n\t\t// Resolve from mysqlAnsiQuotes if mysql...\r\n\t\tif (this.options.dialect === 'mysql') {\r\n\t\t\tif (this.options.mysqlAnsiQuotes) {\r\n\t\t\t\tdelimChars.push('`'); // Backticks is ALSO identifier delim\r\n\t\t\t} else {\r\n\t\t\t\tdelimChars.fill('`'); // Backticks is ONLY identifier delim\r\n\t\t\t}\r\n\t\t}\r\n\t\t// Use tok-specified delim if valid\r\n\t\tconst delimChar = delimChars.includes(tok.delim)\r\n\t\t\t? tok.delim // Choose this one\r\n\t\t\t: delimChars[0];\r\n\t\t// ------------\r\n\t\tconst shouldQuote = tok.delim\r\n\t\t\t|| /^\\d/.test(value)\r\n\t\t\t|| !/^(\\*|[\\w]+)$/.test(value);\r\n\t\treturn shouldQuote\r\n\t\t\t? `${delimChar}${String(value || '').replace(new RegExp(delimChar, 'g'), delimChar.repeat(2))}${delimChar}`\r\n\t\t\t: value;\r\n\t}\r\n\r\n\t_stringifyKeyword(tok) { return String(tok.value); }\r\n\r\n\t_stringifyOperator(tok) {\r\n\t\tif (tok.value === ':' && this.#parentNode?.isProperty) {\r\n\t\t\treturn '\\\\:';\r\n\t\t}\r\n\t\treturn String(tok.value);\r\n\t}\r\n\r\n\t_stringifyPunctuation(tok) { return String(tok.value); }\r\n\r\n\t_stringifyDataType(tok) { return String(tok.value); }\r\n\r\n\t_stringifyLiteral(tok, options) {\r\n\t\tconst { value } = tok;\r\n\t\t// ------------\r\n\t\tswitch (tok.type) {\r\n\t\t\tcase 'bit_literal': return this._stringifyBitLiteral(tok, options);\r\n\t\t\tcase 'hex_literal': return this._stringifyHexLiteral(tok, options);\r\n\t\t\tcase 'number_literal': return this._stringifyNumberLiteral(tok, options);\r\n\t\t\tcase 'string_literal': return this._stringifyStringLiteral(tok, options);\r\n\t\t\tcase 'bool_literal': return /^true$/i.test(value + '') ? 'TRUE' : 'FALSE';\r\n\t\t\tcase 'null_literal': return 'NULL';\r\n\t\t}\r\n\t\treturn String(value);\r\n\t}\r\n\r\n\t_stringifyBindVar(tok) {\r\n\t\tconst { value } = tok;\r\n\t\t// ------------\r\n\t\tif (this.options.dialect === 'mysql') {\r\n\t\t\treturn `?`;\r\n\t\t}\r\n\t\treturn `$${value}`;\r\n\t}\r\n\r\n\t_stringifyBitLiteral(tok) {\r\n\t\tconst { value } = tok;\r\n\t\t// ------------\r\n\t\tif (this.options.dialect === 'mysql') {\r\n\t\t\treturn `0b${value}`;\r\n\t\t}\r\n\t\treturn `B'${value}'`;\r\n\t}\r\n\r\n\t_stringifyHexLiteral(tok) {\r\n\t\tconst { value } = tok;\r\n\t\t// ------------\r\n\t\tif (this.options.dialect === 'mysql') {\r\n\t\t\treturn `0x${value}`;\r\n\t\t}\r\n\t\treturn `X'${value}'`;\r\n\t}\r\n\r\n\t_stringifyNumberLiteral(tok) {\r\n\t\tconst { value } = tok;\r\n\t\t// ------------\r\n\t\treturn String(value);\r\n\t}\r\n\r\n\t_stringifyStringLiteral(tok) {\r\n\t\tlet { value } = tok;\r\n\t\tconst delimChars = [\"'\"];\r\n\t\tlet escChar = null;\r\n\t\t// ------------\r\n\t\t// Resolve from dialect...\r\n\t\tif (this.options.dialect === 'postgres' && tok.delim?.startsWith('$')) {\r\n\t\t\tdelimChars.fill(tok.delim); // OVERRIDE\r\n\t\t} else if (this.options.dialect === 'mysql' && !this.options.mysqlAnsiQuotes) {\r\n\t\t\tdelimChars.push('\"'); // Double quotes is ALSO string delim\r\n\t\t}\r\n\t\t// Use tok-specified delim if valid\r\n\t\tconst delimChar = delimChars.includes(tok.delim)\r\n\t\t\t? tok.delim // Choose this one\r\n\t\t\t: delimChars[0];\r\n\t\t// Using backslash escaping?\r\n\t\tif (this.options.dialect === 'mysql' && !this.options.mysqlNoBackslashEscapes\r\n\t\t\t|| this.options.dialect === 'postgres' && tok.modifier === 'E') {\r\n\t\t\tescChar = '\\\\'; // In which case: the delim plus [\\\\\\0\\b\\r\\n\\t\\x1A] are backslashed/encoded\r\n\t\t}\r\n\t\t// ------------\r\n\t\t// Is Postgres dollar-quoted string?\r\n\t\tif (delimChar.length > 1) { // e.g. for $$string$$\r\n\t\t\treturn `${delimChar}${value}${delimChar}`;\r\n\t\t}\r\n\t\tif (!escChar) {\r\n\t\t\tescChar = delimChar;\r\n\t\t} else if (escChar === '\\\\') {\r\n\t\t\tconst defs = {\r\n\t\t\t\t'\\\\': '\\\\\\\\', // from backslash char itself\r\n\t\t\t\t'\\0': '\\\\0', // from NUL byte (ASCII 0)\r\n\t\t\t\t'\\b': '\\\\b', // from backspace (ASCII 8)\r\n\t\t\t\t'\\f': '\\\\f', // from form feed\r\n\t\t\t\t'\\n': '\\\\n', // from newline\r\n\t\t\t\t'\\r': '\\\\r', // from carriage return\r\n\t\t\t\t'\\t': '\\\\t', // from tab\r\n\t\t\t\t'\\v': '\\\\v', // from vertical tab\r\n\t\t\t\t'\\x1A': '\\\\Z' // from ASCII 26 (SUB / Control+Z) - as represented in JS\r\n\t\t\t};\r\n\t\t\tvalue = value.replace(/[\\\\\\0\\b\\r\\n\\t\\x1A]/g, (match) => defs[match]);\r\n\t\t}\r\n\t\tvalue = `${delimChar}${(value || '').replace(new RegExp(delimChar, 'g'), `${escChar}${delimChar}`)}${delimChar}`;\r\n\t\treturn tok.modifier\r\n\t\t\t? `${tok.modifier}${value}`\r\n\t\t\t: value;\r\n\t}\r\n\r\n\t_stringifyVariable(tok) {\r\n\t\tconst { type, value } = tok;\r\n\t\t// ------------\r\n\t\tif (this.options.dialect === 'mysql') {\r\n\t\t\treturn `${type === 'system_var' ? '@@' : '@'}${value}`;\r\n\t\t}\r\n\t\treturn `${this.#parentNode?.isProperty ? '\\\\:' : ':'}${value}`;\r\n\t}\r\n\r\n\t_stringifyComment(tok, options = {}) {\r\n\t\tconst { value } = tok;\r\n\t\t// ------------\r\n\t\tif (tok.type === 'block_comment') {\r\n\t\t\tconst indent = '  '.repeat(options.startingIndentLevel || 0);\r\n\t\t\tconst lines = value.trim().split('\\n').map((line) => line.trim());\r\n\t\t\tconst formatted = [\r\n\t\t\t\t`${indent}/**`,\r\n\t\t\t\t...lines.map((line) => `${indent} * ${line}`),\r\n\t\t\t\t`${indent} */`\r\n\t\t\t];\r\n\t\t\treturn formatted.join('\\n');\r\n\t\t}\r\n\t\t// ------------\r\n\t\tconst delimChars = ['--'];\r\n\t\tif (this.options.dialect === 'mysql') {\r\n\t\t\tdelimChars.push('#');\r\n\t\t}\r\n\t\tconst delimChar = delimChars.includes(tok.delim)\r\n\t\t\t? tok.delim\r\n\t\t\t: delimChars[0];\r\n\t\treturn `${delimChar} ${value}`;\r\n\t}\r\n}\r\n\r\nconst _getUnsupportedRuleAttrs = (rule) => {\r\n\treturn Object.keys(rule).filter((k) => !supportedRuleAttrs.has(k));\r\n};\r\nconst supportedRuleAttrs = new Set([\r\n\t'dialect',\r\n\t// 1. Pretty-printing\r\n\t'autoSpacing',\r\n\t'optionalParens',\r\n\t'autoIndent',\r\n\t'autoIndentAdjust',\r\n\t// 2. Type system: token and node\r\n\t'type',\r\n\t// 2.1 Token matching\r\n\t'value',\r\n\t'delim',\r\n\t'modifier',\r\n\t// 2.2 Compound matching\r\n\t'syntax',\r\n\t'syntaxes',\r\n\t// 3. AST fields\r\n\t'as',\r\n\t'booleanfy',\r\n\t'if',\r\n\t// 4. Variadic fields\r\n\t'arity',\r\n\t'itemSeparator',\r\n\t'singletons',\r\n\t'keyed',\r\n\t// 5. Other attributes\r\n\t'requiredSpacing',\r\n\t'peek',\r\n\t'optional',\r\n\t'assert',\r\n]);\r\n\r\nconst _inferenceMatch = (inference, resultAST, activeTrailStr) => {\r\n\treturn [].concat(inference).some((criteria) => {\r\n\t\tif (_isObject(criteria)) {\r\n\t\t\treturn Object.entries(criteria).every(([key, value]) => {\r\n\t\t\t\tlet exp = true;\r\n\t\t\t\tif (key.startsWith('!')) {\r\n\t\t\t\t\tkey = key.slice(1);\r\n\t\t\t\t\texp = false;\r\n\t\t\t\t}\r\n\t\t\t\treturn (\r\n\t\t\t\t\tArray.isArray(value) ? value.includes(resultAST[key]) : resultAST[key] === value\r\n\t\t\t\t) === exp;\r\n\t\t\t});\r\n\t\t}\r\n\t\tif (typeof criteria !== 'string') throw new SyntaxError(`[${activeTrailStr}] A specifier of type string or object expected in inferenceMatch but got ${criteria === null ? 'null' : `type ${typeof criteria}`}`);\r\n\t\tlet exp = true;\r\n\t\tif (criteria.startsWith('!')) {\r\n\t\t\tcriteria = criteria.slice(1);\r\n\t\t\texp = false;\r\n\t\t}\r\n\t\treturn (![undefined, null, false].includes(resultAST[criteria])) === exp;\r\n\t});\r\n};", "import { _isObject } from '@webqit/util/js/index.js';\n\nexport function _eq(a, b, cs = false, ignoreList = null) {\n    if (Array.isArray(a) && Array.isArray(b)) {\n        return a.length === b.length && (b = b.slice(0).sort())\n            && a.slice(0).sort().every((x, i) => _eq(x, b[i], cs, ignoreList));\n    }\n    if (typeof a?.jsonfy === 'function') a = a.jsonfy();\n    if (typeof b?.jsonfy === 'function') b = b.jsonfy();\n    if (_isObject(a) && _isObject(b)) {\n        const temp = {\n            indexs_a: Object.keys(a),\n            indexs_b: Object.keys(b),\n        };\n        if (ignoreList?.length) {\n            const $ignoreList = [].concat(ignoreList);\n            temp.indexs_a = temp.indexs_a.filter((k) => !$ignoreList.includes(k));\n            temp.indexs_b = temp.indexs_b.filter((k) => !$ignoreList.includes(k));\n        }\n        return temp.indexs_a.length === temp.indexs_b.length\n            && temp.indexs_a.reduce((prev, k) => prev && _eq(a[k], b[k], cs, ignoreList), true);\n    }\n    if (typeof a === 'string' && typeof b === 'string' && cs === false) {\n        return a.toLowerCase() === b.toLowerCase();\n    }\n    return a === b;\n}\n\nexport function _toCapsSnake(str) {\n    // Handle cases like \"myVariableName\" -> \"my_Variable_Name\"\n    // This regex looks for a lowercase letter or digit followed by an uppercase letter.\n    // It inserts an underscore between them.\n    let result = str.replace(/([a-z0-9])([A-Z])/g, '$1_$2');\n\n    // Handle cases like \"HTMLParser\" -> \"HTML_Parser\" or \"APICall\" -> \"API_Call\"\n    // This regex looks for an uppercase letter followed by another uppercase letter\n    // which is then followed by a lowercase letter. This targets the transition\n    // from an acronym to a new word.\n    // Example: In \"HTMLParser\", it matches 'L' and then 'P' (uppercase) followed by 'a' (lowercase).\n    // It inserts an underscore between the first uppercase letter and the second.\n    result = result.replace(/([A-Z])([A-Z][a-z])/g, '$1_$2');\n\n    // Convert the entire string to uppercase.\n    return result.toUpperCase();\n}", "/**\n * Token types:\n * Noted that some delims and modifiers are dialect-dependent, and those are correctly handle by the tokenizer.\n  * Note too that emitted tokens may have a \"spaceBefore\" field when options.spaces === true.\n  * Lastly, \"line\" and \"column\" fields are guaranteed to be emitted by the tokenizer.\n */\nexport const TOK_TYPES = {\n  // Data type names\n  // e.g. VARCHAR, INT, \"custom_type\"\n  data_type: {\n    type: 'data_type',\n    value: undefined,\n    resolve() { return this; }\n  },\n  // Identifiers, optionally delimited\n  // e.g. user_id, \"UserName\", `table$1`\n  identifier: {\n    type: 'identifier',\n    value: undefined,\n    delim: [undefined],\n    resolve({ dialect, mysqlAnsiQuotes } = {}) {\n      return {\n        ...this,\n        delim: this.delim.concat(\n          dialect === 'mysql' ? (mysqlAnsiQuotes ? ['\"', '`'] : ['`']) : ['\"']\n        ),\n      };\n    }\n  },\n  // Any of the predefined keywords\n  // e.g. 'SELECT', 'FROM', 'WHERE'\n  keyword: {\n    type: 'keyword',\n    value: undefined,\n    resolve() { return this; }\n  },\n  // Operators, with precedence and associativity\n  // e.g. '+', '-', '||', 'AND', '::'\n  operator: {\n    type: 'operator',\n    value: undefined,\n    prec: undefined, // number\n    assoc: undefined, // string\n    resultType: undefined, // string\n    resolve() { return this; }\n  },\n  // Punctuation (., ,, :, ;, etc.)\n  // e.g. '.', ',', ':', ';', '(', ')'\n  punctuation: {\n    type: 'punctuation',\n    value: undefined,\n    resolve() { return this; }\n  },\n  // String literals, with required delim and optional modifier (e.g. E for Postgres, N for mysql)\n  // e.g. 'Hello', \"World\", $$foo$$, $tag$bar$tag$\n  string_literal: {\n    type: 'string_literal',\n    value: undefined,\n    delim: [\"'\"],\n    modifier: [undefined],\n    resolve({ dialect, mysqlAnsiQuotes } = {}) {\n      return {\n        ...this,\n        delim: this.delim.concat(\n          dialect === 'mysql' ? (!mysqlAnsiQuotes ? ['\"'] : []) : [/^(\\$\\$|\\$[a-zA-Z_][a-zA-Z0-9_]*\\$)$/]\n        ),\n        modifier: this.modifier.concat(\n          dialect === 'mysql' ? ['N'] : ['E']\n        ),\n      };\n    }\n  },\n  // Numbers (integer, float, exponential, etc.)\n  // e.g. 42, -3.14, 2e10, .004\n  number_literal: {\n    type: 'number_literal',\n    value: undefined,\n    match({ value }) {\n      // Match type \"number_literal\": 42, 3.14, .5, 5., 1e9, -2.7E-3, +0.001e+2\n      if (!/^[+-]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:[eE][+-]?\\d+)?$/.test(value)) return false;\n      return true;\n    }\n  },\n  // NULL Literal: NULL\n  null_literal: {\n    type: 'null_literal',\n    value: undefined,\n    resolve() { return this; }\n  },\n  // UNKNOWN Literal: NULL\n  unknown_literal: {\n    type: 'unknown_literal',\n    value: undefined,\n    resolve() { return this; }\n  },\n  // Bool Literals: TRUE | FALSE\n  bool_literal: {\n    type: 'bool_literal',\n    value: undefined,\n    resolve() { return this; }\n  },\n  // HEX Literals: 0xFF | X'FF'\n  hex_literal: {\n    type: 'hex_literal',\n    value: undefined,\n    resolve() { return this; }\n  },\n  // BIT Literals: 0b0101 | B'0101'\n  bit_literal: {\n    type: 'bit_literal',\n    value: undefined,\n    resolve() { return this; }\n  },\n  // Bindings (e.g. $1, ?, etc.), with required delim\n  // e.g. $1, $user, ?\n  bind_var: {\n    type: 'bind_var',\n    value: undefined,\n    delim: [],\n    resolve({ dialect } = {}) {\n      return {\n        ...this,\n        delim: this.delim.concat(dialect === 'mysql' ? ['?'] : ['$'])\n      };\n    }\n  },\n  // Version tags\n  // e.g. my_db@1_3, my_db@^2_1, my_db@~7_6, my_db @=3_4, my_db@<3, my_db@>4, my_db@<=3, my_db@>=4\n  version_spec: {\n    type: 'version_spec',\n    value: undefined,\n    delim: [undefined, \"'\"],\n    resolve() { return this; }\n  },\n  // User variables, with optional delim\n  // e.g. :foo, @bar, @'user var'\n  user_var: {\n    type: 'user_var',\n    value: undefined,\n    delim: [undefined],\n    resolve({ dialect } = {}) {\n      return {\n        ...this,\n        delim: this.delim.concat(dialect === 'mysql' ? [\"'\"] : [])\n      };\n    }\n  },\n  // MySQL system variables, with required notation\n  // e.g. @@baz\n  system_var: {\n    type: 'system_var',\n    value: undefined,\n    resolve() { return this; }\n  },\n  // Nest token type: \"brace\"\n  brace_block: {\n    type: 'brace_block',\n    value: undefined, // TokenStream\n    resolve() { return this; }\n  },\n  // Nest token type: \"bracket\"\n  bracket_block: {\n    type: 'bracket_block',\n    value: undefined, // TokenStream\n    resolve() { return this; }\n  },\n  // Nest token type: \"paren\"\n  parent_block: {\n    type: 'paren_block',\n    value: undefined, // TokenStream\n    resolve() { return this; }\n  },\n  // Block comments\n  // e.g. /* This is a comment */\n  block_comment: {\n    type: 'block_comment',\n    value: undefined,\n    resolve() { return this; }\n  },\n  // Line comments, with required delim (e.g. /*, --, #)\n  // e.g. -- This is a comment\n  line_comment: {\n    type: 'line_comment',\n    value: undefined,\n    delim: ['--'],\n    resolve({ dialect } = {}) {\n      return {\n        ...this,\n        delim: this.delim.concat(dialect === 'mysql' ? ['#'] : [])\n      };\n    }\n  },\n};\n\n// Lookup registries, organized by: statements, clauses, operators, keywords, dataTypes\n// Each registry is split into: common (standard/shared), postgres, mysql\n\nexport const statements = {\n  common: [\n    // DDL\n    'ALTER',\n    'CREATE',\n    'DROP',\n    // DML\n    'SELECT',\n    'INSERT',\n    'UPSERT',\n    'UPDATE',\n    'MERGE',\n    'DELETE',\n    // Transactions\n    'BEGIN',\n    'COMMIT',\n    'ROLLBACK',\n    'RELEASE',\n    // Utility\n    'DESCRIBE',\n    'EXPLAIN',\n    'USE'\n  ],\n  postgres: [\n    'ANALYZE',\n    'CLUSTER',\n    'COMMENT ON',\n    'REFRESH',\n    'REINDEX',\n    'VACUUM'\n  ],\n  mysql: [\n    'ANALYZE',\n    'FLUSH',\n    'LOCK',\n    'OPTIMIZE',\n    'RENAME',\n    'REPAIR',\n    'RESET',\n    'SET',\n    'SHOW',\n    'TRUNCATE',\n    'UNLOCK'\n  ]\n};\n\nexport const keywords = {\n  common: [\n    'ALL', 'ON', 'NO', 'KEY', 'ANY', 'AS', 'BY', 'ASC', 'CASE', 'CAST',\n    'DEFAULT', 'DESC', 'DO', 'DISTINCT', 'ELSE', 'END', 'ESCAPE', 'EXISTS',\n    'FIRST', 'LAST', 'FOLLOWING', 'FOR', 'HAVING', 'FILTER', 'SHARE', 'UNIQUE',\n    'JOIN', 'SEPARATOR', 'SKIP', 'LOCKED', 'NOWAIT', 'OF', 'RECURSIVE',\n    'LIMIT', 'LOAD', 'NEXT', 'NOTHING', 'NULLS', 'OFFSET', 'ONLY', 'TIES',\n    'OVER', 'PARTITION', 'PRECEDING', 'RANGE', 'RETURNING', 'ROW', 'ROWS', 'INCLUDE', 'EXCLUDE',\n    'SET', 'SOME', 'THEN', 'USING', 'MATERIALIZED', 'MODE', 'TEMPORARY', 'MATCH', 'PARTIAL', 'SIMPLE',\n    'WITHIN', 'BOTH', 'CHECK', 'PRIMARY', 'FOREIGN', 'CONSTRAINT', 'REFERENCES', 'INHERITS',\n    'DATABASE', 'TABLE', 'COLUMN', 'INDEX', 'SEQUENCE', 'TRIGGER', 'VIEW', 'SAVEPOINT',\n    'VALUES', 'WHEN', 'WHERE', 'WINDOW', 'WITH', 'WITHOUT', 'TO', 'TABLESPACE', 'INTO',\n    'FROM', 'GROUP', 'ORDER', 'PARTITION', 'BREADTH', 'DEPTH', 'GENERATED', 'ALWAYS',\n    'INNER', 'LEFT', 'RIGHT', 'OUTER', 'FULL', 'CROSS', 'NATURAL', 'NO OTHERS', 'NO INHERIT',\n    'ROLLUP', 'UNBOUNDED', 'CURRENT ROW', 'GROUPS', 'IGNORE', 'RESPECT', 'CHARACTER SET',\n    'NO ACTION', 'SET NULL', 'SET DEFAULT', 'RESTRICT', 'CASCADE', 'STORED', 'GIST',\n    'SCHEMA'\n  ],\n  postgres: [\n    'ARRAY', 'GROUPING SETS', 'CUBE', 'TABLESAMPLE', 'REPEATABLE', 'SEARCH',\n    'LATERAL', 'ORDINALITY', 'OVERLAPS', 'SIMILAR', 'BERNOULLI', 'SYSTEM',\n    'UNLOGGED', 'PERFORM', 'CURRENT OF', 'EXTENSION',\n    'IMMUTABLE', 'STABLE', 'VOLATILE', 'CYCLE', 'CONFLICT', 'TEMP',\n    'TIME ZONE', 'FETCH', 'LOCAL', 'IDENTITY', 'DEFERRABLE', 'INITIALLY', 'DEFERRED', 'IMMEDIATE',\n    'AUTHORIZATION', 'CURRENT_ROLE', 'CURRENT_USER', 'SESSION_USER'\n  ],\n  mysql: [\n    'LOCK', 'RENAME', 'REPLACE', 'SHOW', 'UNLOCK', 'VIRTUAL', 'VISIBLE', 'INVISIBLE',\n    'HIGH_PRIORITY', 'CACHE', 'SQL_CACHE', 'SQL_NO_CACHE', 'STRAIGHT_JOIN', 'COMMENT',\n    'DATABASES', 'TABLES', 'COLUMNS', 'PROCEDURE', 'FUNCTION',\n    'AUTO_INCREMENT', 'CHARACTER SET', 'ENGINE', 'VALUE', 'DUPLICATE',\n  ]\n};\n\nexport const functionNames = {\n  common: [\n    'NOW', 'CURRENT_DATE', 'CURRENT_TIME', 'CURRENT_TIMESTAMP',\n    'IF', 'NULLIF', 'IFNULL',\n    'COALESCE', 'GREATEST', 'LEAST', 'CONCAT', 'GROUPING',\n    'CONCAT_WS', 'FORMAT', 'UNNEST',\n    'MD5', 'SHA1',\n    'ST_ASTEXT', 'ST_ASGEOJSON', 'ST_GEOMFROMTEXT',\n    'ST_WITHIN', 'ST_CONTAINS', 'ST_INTERSECTS', 'ST_DISTANCE', 'ST_BUFFER'\n  ],\n  postgres: [\n    'MAKE_DATE', 'MAKE_TIME', 'MAKE_TIMESTAMP',\n    'TO_JSON', 'TO_JSONB', 'JSON_TYPEOF', 'JSONB_TYPEOF',\n    'JSON_BUILD_ARRAY', 'JSONB_BUILD_ARRAY', 'JSON_BUILD_OBJECT', 'JSONB_BUILD_OBJECT',\n    'JSON_POPULATE_RECORD', 'JSONB_POPULATE_RECORD', 'JSON_PATH_QUERY', 'JSON_PATH_EXISTS'\n  ],\n  mysql: [\n    'CURDATE', 'CURTIME', 'SYSDATE', 'STR_TO_DATE', 'MAKEDATE', 'MAKETIME',\n    'JSON_ARRAY', 'JSON_OBJECT', 'JSON_EXTRACT', 'JSON_UNQUOTE',\n    'JSON_SET', 'JSON_INSERT', 'JSON_REPLACE', 'JSON_REMOVE',\n    'JSON_SEARCH', 'JSON_CONTAINS', 'JSON_CONTAINS_PATH',\n    'JSON_KEYS', 'JSON_ARRAY_APPEND', 'JSON_ARRAY_INSERT',\n    'JSON_DEPTH', 'JSON_LENGTH', 'JSON_MERGE_PRESERVE',\n    'JSON_MERGE_PATCH', 'JSON_PRETTY', 'JSON_STORAGE_FREE'\n  ]\n};\n\nexport const aggrFunctionNames = {\n  common: [\n    'COUNT', 'SUM', 'AVG', 'MIN', 'MAX',\n    'COVAR_POP', 'COVAR_SAMP', 'CORR',\n    'ROW_NUMBER',\n    'BIT_AND', 'BIT_OR',\n    'STDDEV_POP', 'STDDEV_SAMP', 'VAR_POP', 'VAR_SAMP', 'VARIANCE', 'STD',\n    'LEAD', 'LAG', 'NTILE', 'FIRST_VALUE', 'LAST_VALUE',\n  ],\n  postgres: [\n    'ARRAY_AGG', 'STRING_AGG', 'REGR_SLOPE',\n    'PERCENTILE_CONT', 'PERCENTILE_DISC', 'MODE',\n    'RANK', 'DENSE_RANK',\n    'EVERY', 'BOOL_AND', 'BOOL_OR',\n    'JSON_AGG',\n    'JSON_OBJECT_AGG', 'JSONB_OBJECT_AGG',\n    'XMLAGG',\n  ],\n  mysql: [\n    'GROUP_CONCAT',\n    'BIT_XOR',\n    'JSON_ARRAYAGG',\n    'JSON_OBJECTAGG',\n  ]\n};\n\nexport const dataTypes = {\n  common: [\n    'SMALLINT', 'INTEGER', 'INT', 'BIGINT',\n    'DECIMAL', 'DEC', 'NUMERIC', 'REAL', 'FLOAT',\n    'DATE', 'TIME', 'TIMESTAMP', 'INTERVAL',\n    'CHAR', 'CHARACTER', 'VARCHAR', 'TEXT',\n    'BINARY', 'VARBINARY', 'BOOLEAN', 'JSON',\n    'GEOMETRY', 'POINT', 'LINESTRING', 'POLYGON',\n    'DOUBLE PRECISION', 'CHARACTER VARYING', 'BYTEA',\n    'ENUM',\n  ],\n  postgres: [\n    'SERIAL', 'BIGSERIAL', 'MONEY', 'BIT',\n    'CIDR', 'INET', 'MACADDR', 'MACADDR8', 'TIMESTAMPTZ', 'TIMETZ',\n    'TSVECTOR', 'TSQUERY', 'UUID', 'XML',\n    'INT4RANGE', 'INT8RANGE', 'NUMRANGE',\n    'TSRANGE', 'TSTZRANGE', 'DATERANGE',\n    'BOX', 'PATH', 'CIRCLE', 'LINE', 'LSEG', 'POLYGON',\n    'OID', 'BIT VARYING', 'JSONB'/*, TODO'NAME'*/, 'REGCLASS',\n  ],\n  mysql: [\n    'TINYINT', 'MEDIUMINT', 'BIT', 'YEAR', 'DATETIME',\n    'TINYTEXT', 'QUERY', 'MEDIUMTEXT', 'LONGTEXT',\n    'TINYBLOB', 'BLOB', 'MEDIUMBLOB', 'LONGBLOB',\n    'GEOMETRYCOLLECTION', 'MULTIPOINT', 'MULTILINESTRING', 'MULTIPOLYGON',\n    'BOOL'\n  ]\n};\n\nexport const operators = {\n  common: [\n    // Custom/graph-style\n    ['<~', { prec: 100, assoc: 'left', resultType: ':right' }],\n    ['~>', { prec: 100, assoc: 'right', resultType: ':right' }],\n    ['BETWEEN', { prec: 85, assoc: 'left', resultType: 'boolean' }],\n    ['NOT', { prec: 80, assoc: 'right', resultType: 'boolean' }],\n    // Arithmetic\n    ['*', { prec: 70, assoc: 'left', resultType: 'number' }],\n    ['/', { prec: 70, assoc: 'left', resultType: 'number' }],\n    ['%', { prec: 70, assoc: 'left', resultType: 'number' }],\n    ['+', { prec: 60, assoc: 'left', resultType: 'number' }],\n    ['-', { prec: 60, assoc: 'left', resultType: 'number' }],\n    // Bitwise\n    ['&', { prec: 60, assoc: 'left', resultType: 'number' }],\n    ['|', { prec: 60, assoc: 'left', resultType: 'number' }],\n    ['<<', { prec: 60, assoc: 'left', resultType: 'number' }],\n    ['>>', { prec: 60, assoc: 'left', resultType: 'number' }],\n    // Comparison\n    ['=', { prec: 50, assoc: 'left', resultType: 'boolean' }],\n    ['!=', { prec: 50, assoc: 'left', resultType: 'boolean' }],\n    ['<>', { prec: 50, assoc: 'left', resultType: 'boolean' }],\n    ['<', { prec: 50, assoc: 'left', resultType: 'boolean' }],\n    ['<=', { prec: 50, assoc: 'left', resultType: 'boolean' }],\n    ['>', { prec: 50, assoc: 'left', resultType: 'boolean' }],\n    ['>=', { prec: 50, assoc: 'left', resultType: 'boolean' }],\n    ['IS', { prec: 50, assoc: 'left', resultType: 'boolean' }],\n    ['IS NOT', { prec: 50, assoc: 'left', resultType: 'boolean' }],\n    ['DISTINCT FROM', { prec: 50, assoc: 'left', resultType: 'boolean' }],\n    // Pattern / membership\n    ['IN', { prec: 50, assoc: 'left', resultType: 'boolean' }],\n    ['LIKE', { prec: 50, assoc: 'left', resultType: 'boolean' }],\n    // Logical\n    ['AND', { prec: 40, assoc: 'left', resultType: 'boolean' }],\n    ['OR', { prec: 30, assoc: 'left', resultType: 'boolean' }],\n    // Set operators\n    ['INTERSECT', { prec: 20, assoc: 'left', resultType: 'set', isSetOp: true }],\n    ['UNION', { prec: 10, assoc: 'left', resultType: 'set', isSetOp: true }],\n    ['EXCEPT', { prec: 10, assoc: 'left', resultType: 'set', isSetOp: true }]\n  ],\n  postgres: [\n    ['COLLATE', { prec: 83, assoc: 'left', resultType: 'string' }],\n    ['||', { prec: 60, assoc: 'left', resultType: 'string' }],\n    ['::', { prec: 97, assoc: 'left', resultType: 'casted' }],\n    ['AT', { prec: 95, assoc: 'left', resultType: 'timestamptz' }],\n    ['^', { prec: 90, assoc: 'left', resultType: 'number' }],\n    ['#', { prec: 60, assoc: 'left', resultType: 'number' }],\n    // JSON/JSONB\n    ['->', { prec: 80, assoc: 'left', resultType: 'json' }],\n    ['->>', { prec: 80, assoc: 'left', resultType: 'text' }],\n    ['#>', { prec: 80, assoc: 'left', resultType: 'json' }],\n    ['#>>', { prec: 80, assoc: 'left', resultType: 'text' }],\n    ['@>', { prec: 80, assoc: 'left', resultType: 'boolean' }],\n    ['<@', { prec: 80, assoc: 'left', resultType: 'boolean' }],\n    ['?', { prec: 80, assoc: 'left', resultType: 'boolean' }],\n    ['?|', { prec: 80, assoc: 'left', resultType: 'boolean' }],\n    ['?&', { prec: 80, assoc: 'left', resultType: 'boolean' }],\n    ['-@', { prec: 80, assoc: 'left', resultType: 'boolean' }],\n    ['#-', { prec: 80, assoc: 'left', resultType: 'json' }],\n    ['@?', { prec: 80, assoc: 'left', resultType: 'boolean' }],\n    ['@@', { prec: 80, assoc: 'left', resultType: 'boolean' }],\n    ['ILIKE', { prec: 50, assoc: 'left', resultType: 'boolean' }],\n    ['~', { prec: 50, assoc: 'left', resultType: 'boolean' }],\n    ['!~', { prec: 50, assoc: 'left', resultType: 'boolean' }],\n    ['~*', { prec: 50, assoc: 'left', resultType: 'boolean' }],\n    ['!~*', { prec: 50, assoc: 'left', resultType: 'boolean' }],\n    ['SIMILAR TO', { prec: 50, assoc: 'left', resultType: 'boolean' }],\n    // GIS/PostGIS\n    ['&&', { prec: 60, assoc: 'left', resultType: 'boolean' }],\n    ['<->', { prec: 60, assoc: 'left', resultType: 'number' }],\n    ['@', { prec: 60, assoc: 'left', resultType: 'geometry' }],\n    ['&<', { prec: 60, assoc: 'left', resultType: 'boolean' }],\n    ['&>', { prec: 60, assoc: 'left', resultType: 'boolean' }],\n    ['|-', { prec: 60, assoc: 'left', resultType: 'boolean' }],\n    ['-|', { prec: 60, assoc: 'left', resultType: 'boolean' }],\n    ['<<', { prec: 60, assoc: 'left', resultType: 'boolean' }],\n    ['>>', { prec: 60, assoc: 'left', resultType: 'boolean' }],\n    ['<<|', { prec: 60, assoc: 'left', resultType: 'boolean' }],\n    ['|>>', { prec: 60, assoc: 'left', resultType: 'boolean' }],\n    ['&<|', { prec: 60, assoc: 'left', resultType: 'boolean' }],\n    ['|&>', { prec: 60, assoc: 'left', resultType: 'boolean' }],\n    ['~=', { prec: 50, assoc: 'left', resultType: 'boolean' }],\n    ['?#', { prec: 60, assoc: 'left', resultType: 'boolean' }],\n    ['?-', { prec: 60, assoc: 'left', resultType: 'boolean' }],\n    ['?-|', { prec: 60, assoc: 'left', resultType: 'boolean' }],\n    ['?|', { prec: 60, assoc: 'left', resultType: 'boolean' }],\n    ['?||', { prec: 60, assoc: 'left', resultType: 'boolean' }],\n    ['#', { prec: 60, assoc: 'left', resultType: 'number' }],\n    ['##', { prec: 60, assoc: 'left', resultType: 'geometry' }],\n    ['@-@', { prec: 60, assoc: 'left', resultType: 'number' }]\n  ],\n  mysql: [\n    ['DIV', { prec: 70, assoc: 'left', resultType: 'number' }],\n    ['MOD', { prec: 70, assoc: 'left', resultType: 'number' }],\n    ['BINARY', { prec: 90, assoc: 'right', resultType: 'binary' }],\n    ['^', { prec: 80, assoc: 'left', resultType: 'number' }],\n    ['~', { prec: 85, assoc: 'right', resultType: 'number' }],\n    ['<=>', { prec: 50, assoc: 'left', resultType: 'boolean' }],\n    ['REGEXP', { prec: 50, assoc: 'left', resultType: 'boolean' }],\n    ['RLIKE', { prec: 50, assoc: 'left', resultType: 'boolean' }],\n    ['!', { prec: 80, assoc: 'right', resultType: 'boolean' }],\n    ['XOR', { prec: 40, assoc: 'left', resultType: 'boolean' }],\n    ['&&', { prec: 40, assoc: 'left', resultType: 'boolean' }],\n    ['||', { prec: 30, assoc: 'left', resultType: 'boolean' }],\n    [':=', { prec: 10, assoc: 'right', resultType: ':right' }],\n    ['SOUNDS LIKE', { prec: 50, assoc: 'left', resultType: 'boolean' }]\n  ]\n};\n", "import * as toktypes from './toktypes.js';\n\nclass TokenStreamState {\n    buffer = '';\n    cursor = 0;\n    line = 1;\n    column = 1;\n    mysqlBindingIndex = 0;\n    nestingContext = [];\n    nextTokenEscape = 0;\n    next(by = 1, isLf = false) {\n        if (isLf) {\n            this.line++;\n            this.column = 0; // To immediately become 1 below\n        }\n        this.column += by;\n        this.cursor += by;\n        if (this.nextTokenEscape === 1) {\n            this.nextTokenEscape = 2;\n        } else if (this.nextTokenEscape === 2) {\n            this.nextTokenEscape = 0;\n        }\n    }\n}\n\nexport class TokenStream {\n\n    #iterator;\n    #options;\n    #locked = false;\n    #started = false;\n    #done = false;\n\n    #rootSavepoint = null;\n    #history = [];\n    #current;\n    #peeks = [];\n\n    constructor(iterator, { state: _, ...options } = {}) {\n        this.#iterator = iterator;\n        this.#options = options;\n    }\n\n    [Symbol.asyncIterator]() {\n        return this; // Make it an async iterator\n    }\n\n    get options() { return this.#options; }\n\n    get locked() { return this.#locked; }\n\n    get started() { return this.#started; }\n\n    get done() { return this.#done && !this.#peeks.length; }\n\n    previous() {\n        return this.#history[this.#history.length - 1];\n    }\n\n    current() {\n        return this.#current;\n    }\n\n    async next() {\n        this.#assertNotLocked('next()');\n        this.#started = true;\n        let value, done = false;\n        if (this.#peeks.length) {\n            this.#historyPush(this.#current);\n            this.#current = this.#peeksShift();\n            value = this.#current;\n        } else {\n            ({ value, done } = await this.#iterator.next());\n            this.#historyPush(this.#current);\n            this.#current = value;\n            this.#done = done;\n        }\n        if (this.#rootSavepoint !== null && value?.type.endsWith('_block')) {\n            value.value.savepoint();\n        }\n        return { value, done };\n    }\n\n    async match($type, $value = undefined) {\n        const [peek, type, value] = typeof arguments[0] === 'number'\n            ? arguments\n            : [0, $type, $value];\n        const match = (tok) => {\n            return tok && (\n                (Array.isArray(type) ? type.includes(tok.type) : type === tok.type) && (\n                    value === undefined || (Array.isArray(value) ? (value.includes(tok.value) || value.includes(undefined)) : value === tok.value)\n                )\n            ) && tok || undefined;\n        };\n        if (peek === Infinity) {\n            // Match progressively\n            let i = 0, tok;\n            while (tok = await this.peek(i++)) {\n                if (match(tok)) return tok;\n            }\n            return;\n        }\n        return match(\n            peek ? await this.peek(peek) : this.current()\n        );\n    }\n\n    async peek(length = 1) {\n        if (length === 0) return this.#current;\n        let $length = length - this.#peeks.length;\n        while ($length) {\n            const next = await this.#iterator.next();\n            if (next.done) break;\n            this.#peeksPush(next.value);\n            $length--;\n        }\n        const tok = this.#peeks[length - 1];\n        return tok;\n    }\n\n    async eat(type = undefined, value = undefined) {\n        const tok = !type ? this.current() : await this.match(type, value);\n        if (tok) (await this.next())?.value; // advance\n        return tok;\n    }\n\n    async expect(type, value = undefined) {\n        const tok = await this.eat(type, value);\n        if (!tok) throw new Error(`Expected token: ${type}${value ? ` (${value})` : ''}`);\n        return tok;\n    }\n\n    // Normal token flow\n\n    #historyPush(tok) {\n        // this.#history.push() <-- tok (this.#current)\n        if (tok?.type.endsWith('_block')) {\n            //tok.value.#locked = true;\n        }\n        if (this.#rootSavepoint !== null) {\n            this.#history.push(tok);\n        } else {\n            this.#history = [tok];\n        }\n    }\n\n    #peeksShift() {\n        // tok (this.#current) <-- this.#peeks.shift()\n        const tok = this.#peeks.shift();\n        if (tok?.type.endsWith('_block')) {\n            tok.value.#locked = false;\n        }\n        return tok;\n    }\n\n    // Reverse token flow\n\n    #historyPop() {\n        // this.#history.pop() --> tok (this.#current)\n        const tok = this.#history.pop();\n        if (tok?.type.endsWith('_block')) {\n            //tok.value.#locked = false;\n            tok.value.restore(tok.value.#rootSavepoint);\n        }\n        return tok;\n    }\n\n    #peeksUnshift(tok) {\n        // tok (this.#current) --> this.#peeks.unshift()\n        if (tok?.type.endsWith('_block')) {\n            tok.value.restore(tok.value.#rootSavepoint);\n            tok.value.#locked = true;\n        }\n        this.#peeks.unshift(tok);\n    }\n\n    // Peeking token flow\n\n    #peeksPush(tok) {\n        if (tok?.type.endsWith('_block')) {\n            tok.value.#locked = true;\n        }\n        this.#peeks.push(tok);\n    }\n\n    #assertNotLocked(method) {\n        if (this.#locked) {\n            throw new Error(`Can't execute ${method}; TokenStream is locked`);\n        }\n    }\n\n    savepoint() {\n        this.#assertNotLocked('savepoint()');\n        const point = this.#history.length;\n        if (this.#rootSavepoint === null) {\n            this.#rootSavepoint = point;\n        }\n        return point;\n    }\n\n    savepointStatus() {\n        return this.#rootSavepoint !== null\n            ? this.#history.length\n            : null;\n    }\n\n    restore(toIndex) {\n        this.#assertNotLocked('restore()');\n        if (this.#rootSavepoint === null || typeof toIndex !== 'number' || toIndex > this.#history.length) {\n            throw new Error(`Invalid restore point ${toIndex}${this.#rootSavepoint === null ? '. Not in savepoint mode' : ''}`);\n        }\n        while (toIndex < this.#history.length) {\n            if (this.#current) {\n                this.#peeksUnshift(this.#current);\n            }\n            this.#current = this.#historyPop();\n        }\n    }\n\n    commit(toIndex) {\n        this.#assertNotLocked('commit()');\n        if (toIndex !== this.#rootSavepoint) return;\n        let tok;\n        while (toIndex < this.#history.length && (tok = this.#historyPop())) {\n            if (tok.type.endsWith('_block')) {\n                tok.value.commit(tok.value.#rootSavepoint);\n            }\n        }\n        this.#rootSavepoint = null;\n    }\n\n    // Returns ToeknStream\n    static async create(input, { dialect = 'postgres', state = new TokenStreamState, ...options } = {}) {\n        if (Array.isArray(input) && input.every((s) => typeof s === 'object' && s?.type) && (input = input.slice())) {\n            return new this(\n                input[Symbol.iterator](),\n                { dialect, ...options },\n            );\n        }\n        // Normalize options. Consumers of the instance (i.e. parsers) might benefit from it\n        if (!options.normalized) {\n            options = normalizeOptions({ dialect, ...options, normalized: true });\n        }\n        return new this(\n            await this.createIterator(input, { dialect, state, ...options, extendedAPI: true }),\n            { dialect, ...options },\n        );\n    }\n\n    // Factory input -> to stream\n    static toIterator(input) {\n        if (typeof input[Symbol.asyncIterator] === 'function') {\n            return typeof input.next === 'function' ? input : input[Symbol.asyncIterator]();\n        }\n        if (typeof input[Symbol.iterator] === 'function' && typeof input !== 'string' && !(input instanceof String)) {\n            return typeof input.next === 'function' ? input : input[Symbol.iterator]();\n        }\n        return (function* () { yield input + ''; })();\n    }\n\n    // Returns Iterator\n    static async * createIterator(input, { dialect = 'postgres', state = new TokenStreamState, ...options } = {}) {\n\n        // Normalize input to stream\n        const stream = this.toIterator(input);\n        // Validate \"dialect\" and \"state\" input\n        if (!['postgres', 'mysql'].includes(dialect)) {\n            throw new Error(`Unknown dialect: ${dialect}`);\n        }\n        if (!(state instanceof TokenStreamState)) {\n            throw new Error('options.state must be an instance of TokenStreamState');\n        }\n        // Normalize options. Should it not have come from this.create()\n        if (!options.normalized) {\n            options = normalizeOptions({ dialect, ...options, normalized: true });\n        } else {\n            options = { dialect, ...options };\n        }\n        // Local state\n        const localState = {\n            token: null,\n            prevEmittedToken: null,\n            nextTokenSpaceBefore: '',\n            multiwordBuffer: [],\n        };\n        // Route token normalization\n        const $finalizeToken = (token, forceYield = false) => {\n            if (!token) return [];\n            const result = finalizeToken(token, { options, state, localState }, forceYield);\n            return result;\n        };\n\n        // Iterate over the input stream chunk by chunk\n        let chunk = { value: '' };\n        do {\n            state.buffer += chunk.value || ''/*when done*/;\n            let char;\n            while (char = state.buffer[state.cursor]) {\n\n                const possiblyChunked = state.buffer[state.cursor + 1] === undefined && !chunk.done;\n                const charIsWhitespace = whitespace.has(char);\n                const $throw = () => {\n                    throw new SyntaxError(`Unexpected token: ${char} at line ${state.line}, column ${state.column}`);\n                }\n\n                /**\n                 * ----------\n                 * PART A:\n                 * Feed or terminate sequences\n                 */\n\n                // ----------\n                // Feed (with validation) or terminate special literals.\n                // !ORDER: Note that because we're handling the ending of non-delimited \"literals\" here, (by whitespace)\n                // this block must run before the generic whitespace-handling block below\n                // Meanhwile, we're also using the opportunity to handle delimited ones's ending\n                if (localState.token?.type === 'hex_literal' || localState.token?.type === 'bit_literal') {\n                    const isEndTag = localState.token.delim ? char === localState.token.delim : charIsWhitespace;\n                    if (isEndTag) {\n                        yield* $finalizeToken(localState.token);\n                        localState.token = null;\n                        if (charIsWhitespace && options.spaces) {\n                            localState.nextTokenSpaceBefore += char;\n                        }\n                    } else {\n                        const type = localState.token?.type;\n                        if (type === 'hex_literal') {\n                            if (!/[0-9A-Fa-f]/.test(char)) $throw();\n                        } else {\n                            if (!/[01]/.test(char)) $throw();\n                        }\n                        localState.token.value += char;\n                    }\n                    state.next();\n                    continue;\n                }\n\n                // ----------\n                // Feed (with validation) or terminate \"version_specs\".\n                // !ORDER: Note that because we're handling the ending of non-delimited \"version_specs\" here, (by whitespace or dot)\n                // this block must run before the generic whitespace-handling block below\n                // Meanhwile, we're also using the opportunity to handle delimited ones's ending\n                if (localState.token?.type === 'version_spec') {\n                    const isEndQuote = localState.token.delim && char === localState.token.delim;\n                    const isEndTag = isEndQuote || (charIsWhitespace || char === '.' || char === ',' || char === ';' || char === ')');\n                    if (isEndTag) {\n                        yield* $finalizeToken(localState.token);\n                        localState.token = null;\n                    } else if (localState.token.value) {\n                        if (char === '=') {\n                            // \"=\" only allowed as @=2_4, @<=4, @>=2\n                            if (!['<', '>'].includes(localState.token.value)) $throw();\n                        } else if (char === '_') {\n                            // \"_\" only allowed as digits separator\n                            if (!/\\d$/.test(localState.token.value)) $throw();\n                        } else if (!/\\d/.test(char)) $throw();\n                        localState.token.value += char;\n                    } else {\n                        localState.token.value += char;\n                    }\n                    if (!isEndTag || isEndQuote) {\n                        state.next();\n                        continue;\n                    }\n                }\n\n                // ----------\n                // Whitespace and Linebreaks end sequences\n                // but:\n                // - whitespace is contigious with strings, delimited idents, and comments\n                // - line breaks end single-line comments\n                // !ORDER: Handle this early, but after the \"literals\" block above.\n                if (charIsWhitespace) {\n                    const isString = localState.token?.type === 'string_literal';\n                    const isDelimitedIdent = localState.token?.type === 'identifier' && localState.token.delim;\n                    const isBlockComment = localState.token?.type === 'block_comment';\n                    const isLineComment = localState.token?.type === 'line_comment';\n                    if (isString || isDelimitedIdent || isBlockComment || isLineComment && !(\n                        char === '\\r' || char === '\\n')\n                    ) {\n                        // Not a single-line comment ending. Treat as contigious!\n                        localState.token.value += char;\n                    } else {\n                        // Whitespace starting...? End current token!\n                        const prevChar = state.buffer[state.cursor - 1];\n                        if (!whitespace.has(prevChar) && localState.token) {\n                            yield* $finalizeToken(localState.token);\n                            localState.token = null;\n                        }\n                        if (options.spaces) {\n                            localState.nextTokenSpaceBefore += char;\n                        }\n                    }\n                    if (char === '\\n' || char === '\\r') {\n                        state.next(1, true);\n                    } else {\n                        state.next();\n                    }\n                    continue;\n                }\n\n                // ----------\n                // Handle backslahes in strings when in backslah-escaping mode\n                // - or when in nested context and is a Double Colon-escaping position\n                // !ORDER: Handle backslashes early.\n                if (char === '\\\\') {\n                    if (possiblyChunked) break; // We need to look ahead to know if this is comment ending\n                    let nextChar = state.buffer[state.cursor + 1];\n                    // String char escaping...\n                    const strings_inBackslashEscapeMode = localState.token?.type === 'string_literal' && (options.dialect === 'mysql' ? !options.mysqlNoBackslashEscapes : localState.token.modifier === 'E');\n                    const strings_atEscapePosition = nextChar === localState.token?.delim || nextChar === '\\\\' || nextChar === '0' || nextChar === 'b' || nextChar === 'f' || nextChar === 'n' || nextChar === 'r' || nextChar === 't' || nextChar === 'v' || nextChar === 'Z';\n                    if (strings_inBackslashEscapeMode && strings_atEscapePosition) {\n                        nextChar = {\n                            '\\\\': '\\\\', // to backslash char itself, here for completeness\n                            '0': '\\0', // to NUL byte (ASCII 0)\n                            'b': '\\b', // to backspace (ASCII 8)\n                            'f': '\\f', // to form feed\n                            'n': '\\n', // to newline\n                            'r': '\\r', // to carriage return\n                            't': '\\t', // to tab\n                            'v': '\\v', // to vertical tab\n                            'Z': '\\x1A', // to ASCII 26 (SUB / Control+Z) - represented as \\x1A in JS\n                        }[nextChar] || nextChar;\n                        localState.token.value += nextChar;\n                        state.next(2);\n                        continue;\n                    }\n                    state.nextTokenEscape = 1;\n                    state.next();\n                    continue;\n                }\n\n                // ----------\n                // Feed or terminate:\n                // - block_comment\n                // - string_literal\n                // - delimited identifier\n                // - delimited user_var\n                if (localState.token?.type === 'block_comment'\n                    || localState.token?.type === 'line_comment' // For feeding\n                    || localState.token?.type === 'string_literal'\n                    || (localState.token?.type === 'identifier' && localState.token.delim)\n                    || (localState.token?.type === 'user_var' && localState.token.delim)/*MySQL @'user-var'*/) {\n                    let tokenEndSteps;\n                    if (localState.token.type === 'block_comment') {\n                        if (char === '*') {\n                            if (possiblyChunked) break; // We need to look ahead to know if this is comment ending\n                            const nextChar = state.buffer[state.cursor + 1];\n                            tokenEndSteps = nextChar === '/' ? 2 : 0; // 2 chars for end tag, 0 otherwise: not a comment end\n                        }\n                    } else if (char === localState.token.delim) {\n                        // Two contiqious delims is escape when is identifier\n                        const twoContiqiousDelimsIsEscape = localState.token.type === 'identifier'\n                            // Or for strings, when not using backslash as escape\n                            || localState.token.type === 'string_literal' && (options.dialect === 'mysql' ? options.mysqlNoBackslashEscapes : localState.token.modifier !== 'E');\n                        // Do escaping if so\n                        if (twoContiqiousDelimsIsEscape) {\n                            if (possiblyChunked) break; // We need to look ahead to know if this is an quote escape quote\n                            const nextChar = state.buffer[state.cursor + 1];\n                            if (nextChar === char) {\n                                localState.token.value += char; // Pick one of the two quotes\n                                state.next(2); // and eat the other\n                                continue;\n                            }\n                        }\n                        // End token otherwise: char === localState.token.delim\n                        tokenEndSteps = 1;\n                    } else if (localState.token.type === 'string_literal' && localState.token.delim.startsWith('$')/*postgres*/ && char === '$') {\n                        // Specially catch Postgres' dollar-delims\n                        const cursor = state.cursor + 1;\n                        if (state.buffer.slice(cursor - localState.token.delim.length, cursor) === localState.token.delim) {\n                            localState.token.value = localState.token.value.slice(0, - localState.token.delim.length + 1);\n                            tokenEndSteps = 1;\n                        }\n                    }\n                    if (tokenEndSteps) {\n                        yield* $finalizeToken(localState.token);\n                        localState.token = null;\n                        state.next(tokenEndSteps);\n                        continue;\n                    }\n                    // Feed ongoing sequence\n                    localState.token.value += char;\n                    state.next();\n                    continue;\n                }\n\n                // ----------\n                // Handle closing nesting delims:\n                // - }\n                // - ]\n                // - )\n                if (state.nestingContext.length && char === { '{': '}', '[': ']', '(': ')' }[state.nestingContext[0]]) {\n                    yield* $finalizeToken(localState.token, true);\n                    state.nestingContext.shift();\n                    if (options.structured) {\n                        state.next(); // Eat the end tag\n                        localState.nestingEndTagSeen = true;\n                        return;\n                    }\n                    localState.token = null;\n                }\n\n                /**\n                 * ----------\n                 * PART B:\n                 * Start or restart sequences\n                 */\n\n                // ----------\n                // Start\n                // - comments\n                // - strings\n                // - identifiers\n                let tokenStart, tokenStartBacksteps = 0, tokenStartForwardsteps = 0;\n\n                if (options.dialect === 'postgres') {\n                    // Postgres' dollars :)\n                    if (localState.token?.type === 'pg_possible_dollar_delim' || char === '$') {\n                        // Catch the beginning of Postgres' dollar-delims\n                        if (localState.token?.type === 'pg_possible_dollar_delim') {\n                            if (char === '$') {\n                                const { type: _, value, delim: __, ...restTok } = localState.token;\n                                localState.token = { type: 'string_literal', value: '', delim: `$${value}$`, ...restTok };\n                            } else {\n                                localState.token.value += char;\n                            }\n                            state.next();\n                            continue;\n                        }\n                        if (possiblyChunked) break; // We need to look ahead to know if this is bind_var or...\n                        const nextChar = state.buffer[state.cursor + 1];\n                        if (/[0-9]/.test(nextChar)) {\n                            tokenStart = { type: 'bind_var' };\n                        } else {\n                            // ...possible dollar-delimited string\n                            tokenStart = { type: 'pg_possible_dollar_delim', delim: char };\n                        }\n                    }\n                } else if (options.dialect === 'mysql') {\n                    // MySQL's questions :)\n                    if (char === '?') {\n                        tokenStart = { type: 'bind_var' };\n                    }\n                    // MySQL's hash comments :)\n                    if (char === '#') {\n                        tokenStart = { type: 'line_comment', delim: char };\n                    }\n                    // MySQL's backflips :)\n                    if (char === '`') {\n                        tokenStart = { type: 'identifier', delim: char };\n                    }\n                }\n\n                // Strings and ansi-delimited identifers\n                if (char === \"'\") {\n                    const modifierPattern = new RegExp(`(@)$|^\\\\W?(${options.dialect === 'postgres' ? 'E|X|B' : 'N|X'})$`, 'i');\n                    const modifierMatch = state.buffer.slice(Math.max(state.cursor - 2, 0), state.cursor).match(modifierPattern);\n                    const modifier = modifierMatch?.[1] || modifierMatch?.[2];\n                    // First try to match LinkedQL version tag\n                    if (modifier === '@' && localState.prevEmittedToken?.type === 'identifier') {\n                        if (possiblyChunked) break; // We need to look ahead to properly determine if variable\n                        const nextChar = state.buffer[state.cursor + 1];\n                        if (/[\\^~=\\d<>!]/.test(nextChar)) {\n                            // Resolve to @'1_1_tags'\n                            tokenStart = { type: 'version_spec', delim: char };\n                            tokenStartBacksteps = 1;\n                        }\n                    }\n                    // Otherwise, resolve to:\n                    // E'new\\\\nline' (postgres)\n                    // N'unicode' (mysql)\n                    // X'FF' (mysql && postgres)\n                    // B'0101' (postgres)\n                    // @'mysql-user-var' (mysql)\n                    if (!tokenStart) {\n                        if (modifier && (modifier !== '@' || options.dialect === 'mysql')) {\n                            const type = /^(E|N)/i.test(modifier) ? 'string_literal' : (\n                                modifier === '@' ? 'user_var' : (modifier === 'X' ? 'hex_' : 'bit_') + 'literal'\n                            );\n                            tokenStart = { type, ...(type === 'string_literal' ? { modifier: modifier.toUpperCase() } : {}), delim: char };\n                            tokenStartBacksteps = modifier === '@' ? 1 : modifier.length;\n                        } else {\n                            tokenStart = { type: 'string_literal', delim: char };\n                        }\n                    }\n                } else if (char === '\"') {\n                    const type = options.dialect !== 'mysql' || options.mysqlAnsiQuotes ? 'identifier' : 'string_literal';\n                    tokenStart = { type, delim: char };\n                }\n\n                if (char === '@') {\n                    // LinkedQL version tag or MySQL user/system variable?\n                    if (possiblyChunked) break; // We need to look ahead to properly determine if variable\n                    const nextChar = state.buffer[state.cursor + 1];\n                    if ((localState.token || localState.prevEmittedToken)?.type === 'identifier' && /[\\^~=\\d<>!]/.test(nextChar)) {\n                        // LinkedQL @1_1_tags\n                        tokenStart = { type: 'version_spec' };\n                    } else if (options.dialect === 'mysql') {\n                        // MySQL's varieties :)\n                        if (nextChar === '@') {\n                            // MySQL system variables\n                            tokenStart = { type: 'system_var' };\n                            tokenStartForwardsteps = 1;\n                        } else if (/[a-zA-Z_$]/.test(nextChar)) {\n                            // MySQL user-defined variables\n                            tokenStart = { type: 'user_var' };\n                        }\n                    }\n                }\n\n                // Comments\n                if (char === '/' || char === '-') {\n                    if (possiblyChunked) break; // We need to look ahead to know if this is comment starting\n                    const nextChar = state.buffer[state.cursor + 1];\n                    if (char === '/' && nextChar === '*') {\n                        tokenStart = { type: 'block_comment' };\n                        tokenStartForwardsteps = 1;\n                    } else if (char === '-' && nextChar === '-') {\n                        tokenStart = { type: 'line_comment', delim: char + nextChar };\n                        tokenStartForwardsteps = 1;\n                    }\n                }\n\n                // Start token\n                if (tokenStart) {\n                    if (localState.token && !tokenStartBacksteps) {\n                        yield* $finalizeToken(localState.token);\n                    }\n                    localState.token = { type: tokenStart.type, value: '', ...tokenStart, line: state.line, column: tokenStartBacksteps ? state.column - tokenStartBacksteps : state.column };\n                    state.next(1 + tokenStartForwardsteps);\n                    continue;\n                }\n\n                // ----------\n                // Start nesting:\n                // - {\n                // - [\n                // - (\n                if (char === '{' || char === '[' || char === '(') {\n                    // When we encounter an opening nesting delim, we enter sub-tokenization\n                    yield* $finalizeToken(localState.token);\n                    localState.token = null;\n                    state.nestingContext.unshift(char);\n                    if (options.structured) {\n                        state.next();\n                        const groupToken = {\n                            type: { '{': 'brace_block', '[': 'bracket_block', '(': 'paren_block' }[char],\n                            value: await this[options.extendedAPI ? 'create' : 'createIterator'](stream, { state, ...options }),\n                            line: state.line,\n                            column: state.column,\n                        };\n                        yield* $finalizeToken(groupToken);\n                        if (options.extendedAPI) {\n                            await groupToken.value.peek(Infinity);\n                        } else {\n                            while (!(await groupToken.value.next()).done);\n                        }\n                        continue;\n                    }\n                }\n\n                /**\n                 * ----------\n                 * PART C:\n                 * Handle more nuanced sequences\n                 */\n\n                if (/[0-9]/.test(char)) {\n                    // A number \"literal\" or MySQL's HEX \"literal\" or Postgres' BIN \"literal\"\n                    // Passed along if this is part of an \"identifier\", \"bind_var\", \"version_spec\", \"*_literal\", or  \"*_var\" sequence\n                    if (localState.token?.type !== 'identifier' && localState.token?.type !== 'bind_var' && localState.token?.type !== 'version_spec' && !localState.token?.type.endsWith('_literal') && !localState.token?.type.endsWith('_var')) {\n                        yield* $finalizeToken(localState.token);\n                        if (/*HEX: 0xFF*/char === '0') {\n                            if (possiblyChunked) break; // We need to look ahead to know if this is an X\n                            const $type = state.buffer[state.cursor + 1]?.toUpperCase();\n                            if (($type === 'X' || $type === 'B') && options.dialect === 'mysql') {\n                                localState.token = { type: ($type === 'X' ? 'hex_' : 'bit_') + 'literal', value: '', line: state.line, column: state.column };\n                                state.next(2);\n                                continue;\n                            }\n                        }\n                        localState.token = { type: 'number_literal', value: char, line: state.line, column: state.column };\n                        state.next();\n                        continue;\n                    }\n                } else if (/[a-zA-Z_]/.test(char)) {\n                    // Alphanumeric sequences that start as \"identifier\" but could translate to \"keywords\", \"identifiers\", or even \"operators\"\n                    // Passed along if this is part of a \"identifier\" or \"*_var\" sequence or is the \"E\" in Scientific number notations\n                    if (localState.token?.type !== 'identifier' && !localState.token?.type.endsWith('_var') && !(localState.token?.type === 'number_literal'\n                        && /*EXP: 30e2*/(/\\d$/.test(localState.token.value) && /E/i.test(char)))) {\n                        // Throw if in mid-number sequence\n                        if (localState.token?.type === 'number_literal') $throw();\n                        yield* $finalizeToken(localState.token);\n                        // Start identifier\n                        localState.token = { type: 'identifier', value: char, line: state.line, column: state.column };\n                        state.next();\n                        continue;\n                    }\n                } else {\n                    // Handle punctuations and operators\n                    let type = 'operator';\n                    if (char === ';'\n                        || char === ','\n                        || char === ':'\n                        || char === '{'\n                        || char === '}'\n                        || char === '['\n                        || char === ']'\n                        || char === '('\n                        || char === ')') {\n                        if (char === ':' && (state.nestingContext[0] !== '{' || state.nextTokenEscape)) {\n                            type = 'operator'; // Postgres' colon is an operator, not a punctuation\n                        } else {\n                            type = 'punctuation';\n                        }\n                        if (options.dialect === 'postgres' && char === ':' && type === 'operator' && localState.token?.type !== 'operator') {\n                            const previousChar = state.buffer[state.cursor - 1];\n                            if (possiblyChunked) break; // We need to look ahead to know if this is number starting\n                            const nextChar = state.buffer[state.cursor + 1];\n                            if (previousChar !== ':' && /[a-zA-Z_]/.test(nextChar) && options.PL_SQL !== false) {\n                                type = 'user_var'; // PL/SQL variable\n                                char = '';\n                            }\n                        }\n                    } else if (char === '.') {\n                        if (localState.token?.type === 'number_literal') {\n                            // Mid-number punctuation; floats\n                            if (localState.token.value.includes('.')) $throw();\n                            type = 'number_literal'; // e.g. 2.4\n                        } else {\n                            // Pre-number punctuation? Same floats?\n                            if (possiblyChunked) break; // We need to look ahead to know if this is number starting or a punctuation\n                            const nextChar = state.buffer[state.cursor + 1];\n                            if (/\\d/.test(nextChar)) {\n                                type = 'number_literal'; // e.g. \".004\"\n                            } else {\n                                // Other punctuation. Standalone token:\n                                // e.g. tbl.col, tbl.*, db@<3_2.\"000-u\".id\n                                type = 'punctuation'; // e.g. \"tbl.col\", \"tbl . col\"\n                                // Or maybe MySQL special var punctuation?\n                                if (localState.token?.type === 'system_var') {\n                                    type = 'system_var'; // e.g. \"@@session. autocommit\"\n                                }\n                            }\n                        }\n                    } else if (char === '+' || char === '-') {\n                        if (localState.token?.type === 'number_literal' && /E$/i.test(localState.token.value)) {\n                            // Scientific number notation; EXP: 30e-2\n                            if (/\\+|\\-/.test(localState.token.value)) $throw();\n                            type = 'number_literal';\n                        }\n                    }\n\n                    // Feed an ongoing sequence or terminate that and start a new one?\n                    if (localState.token?.type !== type || type === 'punctuation' || (\n                        type === 'operator' && !options.operators.classic.has(`${localState.token.value}${char}`) /*not a valid operator afterall? e.g. \"=-\"*/\n                    )) {\n                        yield* $finalizeToken(localState.token);\n                        localState.token = { type, value: char, line: state.line, column: state.column };\n                        state.next();\n                        continue;\n                    }\n\n                    // Passed thru to feed an ongoing sequence\n                }\n\n                localState.token.value += char;\n                state.next();\n            }\n\n            if (chunk.done) break;\n            // Update buffer to handle overflow and continue from next chunk\n            state.buffer = state.buffer.slice(state.cursor);\n            state.cursor = 0;\n        } while (chunk = await stream.next());\n\n        if (localState.token) {\n            if (\n                (localState.token.type === 'operator' && localState.token.value !== '*')\n                || localState.token.type === 'number_literal' && /E$/i.test(localState.token.value)\n                || localState.token.type === 'block_comment'\n                || localState.token.type === 'pg_possible_dollar_delim'\n                || (\n                    ['string_literal', 'hex_literal', 'bit_literal', 'identifier', 'version_spec', 'user_var'].includes(localState.token.type)\n                    && localState.token.delim\n                )) {\n                throw new SyntaxError(`Unterminated ${localState.token.type} at line ${state.line}, column ${state.column}`);\n            }\n            yield* $finalizeToken(localState.token, true);\n        }\n        if (state.nestingContext.length && !localState.nestingEndTagSeen) {\n            throw new SyntaxError(`Unterminated nesting \"${state.nestingContext[0]}\" at line ${state.line}, column ${state.column}`);\n        }\n    }\n}\n\n// Lookups\nconst whitespace = new Set([' ', '\\f', '\\n', '\\r', '\\t', '\\v',]);\n\n// Normalize options\nfunction normalizeOptions(options) {\n    // Build the following list into our formats\n    const addMultiWord = (targetMap, prefix, tok, token) => {\n        tok.split(' ').reduce((_tok, chunk) => {\n            _tok = _tok ? `${_tok} ${chunk}` : chunk;\n            targetMap.set(_tok, token);\n            return _tok;\n        }, prefix);\n    };\n    for (const tokenCategory of ['statements', 'functionNames', 'aggrFunctionNames', 'keywords', 'operators', 'dataTypes']) {\n        const $tokenCategory = ['statements', 'functionNames', 'aggrFunctionNames'].includes(tokenCategory) ? 'keywords' : tokenCategory;\n        const tokenRegistry = options[$tokenCategory] || { classic: new Map, compound: new Map };\n        for (const tokenDialectBranch of ['common', options.dialect === 'mysql' ? 'mysql' : 'postgres']) {\n            const entries = toktypes[tokenCategory][tokenDialectBranch];\n            for (const entry of entries) {\n                const [value, token] = Array.isArray(entry) ? [entry[0], { ...entry[1], value: entry[0] }] : [entry, { value: entry }];\n                if (value.includes(' ')) {\n                    addMultiWord(tokenRegistry.compound, '', value, token);\n                } else {\n                    tokenRegistry.classic.set(value, token);\n                }\n            }\n        }\n        options = { ...options, [$tokenCategory]: tokenRegistry };\n    }\n    return options;\n}\n\n// Finalize tokens\nfunction finalizeToken(token, { options, state, localState }, forceYield = false) {\n    if (localState.nextTokenSpaceBefore) {\n        const { type, ...tok } = token;\n        token = { type, spaceBefore: localState.nextTokenSpaceBefore, ...tok };\n        localState.nextTokenSpaceBefore = '';\n    }\n    if (token.type === 'block_comment' || token.type === 'line_comment') {\n        return finalizeComment(token, { options });\n    }\n    let finalToken, identResolution = false;\n    if (options.dialect === 'mysql' && token.type === 'bind_var') {\n        finalToken = [{ ...token, value: `${++state.mysqlBindingIndex}` }];\n    } else if (token.type === 'operator') {\n        // Add operator definition details\n        const { line, column, ...restTok } = token;\n        finalToken = [{\n            ...restTok,\n            ...(options.operators.classic.get(token.value) || {}),\n            line,\n            column,\n        }];\n    } else if (token.type === 'identifier' && !token.delim) {\n        finalToken = finalizeIdentifier(token, { options, state, localState }, forceYield);\n        identResolution = true;\n    }\n    if (!finalToken/*Without asking length*/) {\n        finalToken = [token];\n    }\n    // -----\n    if (finalToken?.length) {\n        localState.prevEmittedToken = finalToken[0];\n    } else {\n        localState.prevEmittedToken = token;\n    }\n    // -----\n    if (!identResolution && finalToken.length && localState.multiwordBuffer.length) {\n        return localState.multiwordBuffer.splice(0).concat(finalToken);\n    }\n    return finalToken;\n}\n\n// Finalize comment tokens\nfunction finalizeComment(token, { options }) {\n    if (!options.comments) return [];\n    if (token.type === 'block_comment') {\n        token = { ...token, value: token.value.split('\\n').map((s) => s.replace(/^[ ]+\\*[ ]+?/, '').trim()).join('\\n') };\n    } else {\n        token = { ...token, value: token.value.trim() };\n    }\n    return [token];\n}\n\n// Finalize \"literal\" tokens\nfunction finalizeIdentifier(token, { options, state, localState }, forceYield = false) {\n    let finalToken,\n        multiwordBufferLength = localState.multiwordBuffer.length;\n    // Yield or build multiword operators\n    const wordSoFar = (\n        multiwordBufferLength ? localState.multiwordBuffer.map((tok) => tok.value).concat(token.value).join(' ') : token.value\n    ).toUpperCase();\n\n    const findInBranch = (branch) => {\n        for (const tokenCategory of ['keywords', 'operators', 'dataTypes']) {\n            const matchResult = options[tokenCategory][branch].get(wordSoFar);\n            if (matchResult) return [tokenCategory, matchResult];\n        }\n        return [];\n    };\n\n    const resolveTok = (matchResult) => {\n        let { type: _, spaceBefore, line, column, ...restTok } = token;\n        if (multiwordBufferLength) {\n            spaceBefore = localState.multiwordBuffer[0].spaceBefore;\n            line = localState.multiwordBuffer[0].line;\n            column = localState.multiwordBuffer[0].column;\n        }\n        const tok = {\n            type: tokenCategory === 'dataTypes' ? 'data_type' : tokenCategory.replace(/s$/, ''),\n            ...(spaceBefore ? { spaceBefore } : {}),\n            ...restTok,\n            ...matchResult, // Final value in here and overriding restTok.value\n            value: wordSoFar,\n            line, // \"line\" and \"column\" coming last now\n            column\n        };\n        return tok;\n    };\n\n    const processExactMatch = (matchResult) => {\n        const tok = resolveTok(matchResult);\n        if (multiwordBufferLength) {\n            finalToken = [tok];\n            localState.multiwordBuffer.splice(0);\n            multiwordBufferLength = 0;\n        } else {\n            finalToken = [tok];\n        }\n    };\n    const processPartialMatch = (matchResult) => {\n        const tok = resolveTok(matchResult);\n        localState.multiwordBuffer.push(tok);\n        finalToken = [];\n    };\n\n    let multiwordMatched = false;\n    let [tokenCategory, matchResult] = findInBranch('compound');\n    if (matchResult?.value === wordSoFar) {\n        processExactMatch(matchResult);\n        multiwordMatched = true;\n    } else if (matchResult) {\n        // first (e.g. DISTINCT kw vs DISTINCT FROM op)\n        const [tokenCategory2, matchResult2] = findInBranch('classic');\n        if (matchResult2 && tokenCategory2 !== tokenCategory) {\n            [tokenCategory, matchResult] = [tokenCategory2, matchResult2];\n        }\n        if (forceYield) {\n            processExactMatch(matchResult);\n        } else {\n            processPartialMatch(matchResult);\n        }\n        multiwordMatched = true;\n    } else {\n        [tokenCategory, matchResult] = findInBranch('classic');\n        if (matchResult) {\n            processExactMatch(matchResult);\n            multiwordMatched = true;\n        }\n    }\n    if (!multiwordMatched && multiwordBufferLength) {\n        const existing = localState.multiwordBuffer.splice(0);\n        const current = finalizeToken(token, { options, state, localState });\n        return [...existing, ...current];\n    }\n    // Treat as identifier\n    if (!finalToken && /^(TRUE|FALSE|NULL|UNKNOWN)$/i.test(token.value)) {\n        const { type: _, ...tok } = token;\n        finalToken = [{\n            type: /UNKNOWN/.test(token.value) ? 'unknown_literal' : (/NULL/i.test(token.value) ? 'null_literal' : 'bool_literal'),\n            ...tok,\n            value: token.value.toUpperCase(),\n        }];\n    }\n    return finalToken;\n}\n", "export const registry = Object.create(null);\n", "import { AbstractNode } from '../../lang/abstracts/AbstractNode.js';\nimport { _eq } from '../../lang/abstracts/util.js';\nimport { registry } from '../../lang/registry.js';\n\nexport function normalizeRelationSelectorArg(selector, flatten = false) {\n    if (selector === '*') {\n        selector = { ['*']: ['*'] };\n    } else if (Array.isArray(selector) && selector.length) {\n        selector = selector.reduce((ss, s, i) => {\n            let keys;\n            if (!(typeof s === 'object' && s)\n                || !(keys = Object.keys(s)).length\n                || keys.filter((k) => k !== 'namespace' && k !== 'tables' && k !== 'name').length) {\n                throw new SyntaxError(`Given selector ${JSON.stringify(selector)} invalid at index ${i}`);\n            }\n            const namespace = s.namespace || '*';\n            const tables = s.tables || s.name || '*';\n            return { ...ss, [namespace]: [...new Set((ss[namespace] || []).concat(tables))] };\n        }, {});\n    } else if (typeof selector === 'object' && selector && Object.keys(selector).length) {\n        selector = Object.fromEntries(Object.entries(selector).map(([k, v]) => [k, [].concat(v)]));\n    } else {\n        throw new SyntaxError(`Given selector ${JSON.stringify(selector)} invalid`);\n    }\n    if (flatten) {\n        selector = new Set(Object.entries(selector).reduce((all, [namespace, tables]) => {\n            return all.concat([].concat(tables).map((table) => JSON.stringify([namespace, table])));\n        }, []));\n    }\n    return selector;\n}\n\nexport function parseRelationSelectors(enums) {\n    const [names, _names, patterns, _patterns] = enums.reduce(([names, _names, patterns, _patterns], e) => {\n        if (/^!%|^!.+%$/.test(e)) return [names, _names, patterns, _patterns.concat(e.slice(1))];\n        if (/^%|%$/.test(e)) return [names, _names, patterns.concat(e), _patterns];\n        if (/^!/.test(e)) return [names, _names.concat(e.slice(1)), patterns, _patterns];\n        return [names.concat(e), _names, patterns, _patterns];\n    }, [[], [], [], []]);\n    return [names, _names, patterns, _patterns];\n}\n\nexport function matchRelationSelector(ident, enums) {\n    const [names, _names, patterns, _patterns] = parseRelationSelectors(enums);\n    const $names = names.length ? names.includes(ident) || (names.length === 1 && names[0] === '*') : false;\n    const $_names = _names.length ? !_names.includes(ident) : false;\n    const $patterns = patterns.length ? patterns.some((s) => (new RegExp(s.replace('%', '.+?')).test(ident))) : false;\n    const $_patterns = _patterns.length ? !_patterns.some((s) => (new RegExp(s.replace('%', '.+?')).test(ident))) : false;\n    return [$names, $_names, $patterns, $_patterns].some((s) => s);\n}\n\n// ------------------------\n\nexport function normalizeQueryArgs(...args) {\n    let query, options = {};\n    if (typeof args[0] === 'object' && args[0] && typeof args[0].query === 'string') {\n        ({ query: query, ...options } = args[0]);\n    } else if (typeof args[0] === 'object' && args[0] && typeof args[0].text/* node_postgres compat */ === 'string') {\n        ({ text: query, ...options } = args[0]);\n    } else if (typeof args[0] === 'object' && args[0] && typeof args[0].url/* AbstractFetchClient compat */ === 'string') {\n        ({ url: query, ...options } = args[0]);\n    } else {\n        query = args.shift();\n        if (Array.isArray(args[0])) {\n            options.values = args.shift();\n        }\n        if (typeof args[0] === 'function') {\n            options.callback = args.shift();\n        }\n        if (typeof args[0] === 'object' && args[0]) {\n            options = { ...options, ...args.shift() };\n        }\n    }\n    return [query, options];\n}\n\n// ------------------------\n\nexport function matchExpr(a, b, _op = null) {\n\n    if (Array.isArray(a) && Array.isArray(b)) {\n        if (a.length !== b.length) return false;\n        for (const [i, _a] of a.entries()) {\n            if (!matchExpr(_a, b[i])) return false;\n        }\n        return true;\n    }\n\n    if (!(a instanceof AbstractNode) || !(b instanceof AbstractNode)) {\n        return _eq(a, b);\n    }\n\n    if (!(a instanceof b.constructor)\n        && !(b instanceof a.constructor)) return false;\n\n    if (a instanceof registry.BinaryExpr) {\n        const matchOperators = (ops) => [a, b].every((x) => ops.includes(x.operator()));\n\n        let logicalOp;\n        if (matchOperators([logicalOp = 'AND'])\n            || matchOperators([logicalOp = 'OR'])\n            || _op === 'AND~' && (a.operator() === 'AND' || b.operator() === 'AND') && (logicalOp = 'AND')) {\n            const aSplit = splitLogicalExpr(a, logicalOp);\n            const bSplit = splitLogicalExpr(b, logicalOp);\n            return matchLogicalSplits(aSplit, bSplit, _op || logicalOp);\n        }\n\n        if (matchOperators(['=', '=='])\n            || matchOperators(['!=', '<>'])\n            || (a.operator() === b.operator() && ['IS', 'IS NOT', 'DISTINCT FROM'].includes(a.operator()))) {\n            return matchExpr(a.left(), b.left()) && matchExpr(a.right(), b.right())\n                || matchExpr(a.right(), b.left()) && matchExpr(a.left(), b.right());\n        }\n\n        if (a.operator() === '<' && b.operator() === '>'\n            || a.operator() === '<=' && b.operator() === '>='\n            || a.operator() === '>' && b.operator() === '<'\n            || a.operator() === '>=' && b.operator() === '<=') {\n            return matchExpr(a.right(), b.left()) && matchExpr(a.left(), b.right());\n        }\n    }\n\n    const aKeys = new Set(a._keys().filter((k) => a._get(k) !== undefined));\n    const bKeys = new Set(b._keys().filter((k) => b._get(k) !== undefined));\n    if (aKeys.size !== bKeys.size) return false;\n    for (const k of new Set([...aKeys, ...bKeys])) {\n        if (!aKeys.has(k) || !bKeys.has(k)) return false;\n        if (!matchExpr(a._get(k), b._get(k))) return false;\n    }\n\n    return true;\n}\n\nexport function matchLogicalSplits(a, b, op = 'AND') {\n    if (op === 'OR') {\n        for (const [i, _a] of a.entries()) {\n            if (!matchExpr(_a, b[i])) return false;\n        }\n        return true;\n    }\n    const bSplit = new Set(b);\n    top: for (const _a of a) {\n        for (const _b of bSplit) {\n            if (matchExpr(_a, _b)) {\n                bSplit.delete(_b);\n                continue top;\n            }\n        }\n        return false;\n    }\n    if (op === 'AND~') return bSplit;\n    return bSplit.size === 0;\n}\n\nexport function splitLogicalExpr(expr, op = 'AND') {\n    if (expr instanceof registry.BinaryExpr\n        && expr.operator() === op) {\n        const lefts = splitLogicalExpr(expr.left(), op);\n        return lefts.concat(expr.right());\n    }\n    return [expr];\n}\n", "export * from './constructs/index.js';\nexport { CTE } from './CTE.js';\nexport { CTEItem } from './CTEItem.js';\nexport { CTEItemAlias } from './CTEItemAlias.js';\n", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class PGCycleClause extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return {\n            dialect: 'postgres',\n            syntax: [\n                { type: 'keyword', value: 'CYCLE' },\n                {\n                    assert: true,\n                    syntax: [\n                        { type: 'ColumnRef1', as: 'column_names', arity: { min: 1 }, itemSeparator, assert: true, autoIndent: 2 },\n                        { type: 'keyword', value: 'SET' },\n                        { type: 'ColumnRef1', as: 'mark_col_name' },\n                        {\n                            optional: true,\n                            syntax: [\n                                { type: 'keyword', value: 'TO' },\n                                { type: 'Expr', as: 'mark_value' },\n                                { type: 'keyword', value: 'DEFAULT' },\n                                { type: 'Expr', as: 'mark_default' },\n                            ]\n                        },\n                        { type: 'keyword', value: 'USING' },\n                        { type: 'ColumnRef1', as: 'path_col_name' },\n                    ]\n                },\n            ]\n        };\n    }\n\n    /* AST API */\n\n    breadthOrDepthFirst() { return this._get('breadth_or_depth_first'); }\n\n    columnNames() { return this._get('column_names'); }\n\n    markColName() { return this._get('mark_col_name'); }\n\n    markValue() { return this._get('mark_value'); }\n\n    markDefault() { return this._get('mark_default'); }\n\n    pathColName() { return this._get('path_col_name'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class PGSearchClause extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return {\n            dialect: 'postgres',\n            syntax: [\n                { type: 'keyword', value: 'SEARCH' },\n                {\n                    assert: true,\n                    syntax: [\n                        { type: 'keyword', as: 'breadth_or_depth_first', value: ['BREADTH', 'DEPTH'] },\n                        { type: 'keyword', value: 'FIRST' },\n                        { type: 'keyword', value: 'BY' },\n                        { type: 'ColumnRef1', as: 'column_names', arity: { min: 1 }, itemSeparator, assert: true, autoIndent: 2 },\n                        { type: 'keyword', value: 'SET' },\n                        { type: 'ColumnRef1', as: 'seq_col_name' },\n                    ]\n                }\n            ]\n        };\n    }\n\n    /* AST API */\n\n    breadthOrDepthFirst() { return this._get('breadth_or_depth_first'); }\n\n    columnNames() { return this._get('column_names'); }\n\n    seqColName() { return this._get('seq_col_name'); }\n}", "import { AbstractNode } from './AbstractNode.js';\n\nexport const ResultSchemaMixin = (Class) => class extends Class {\n\n\t#result_schema;\n\n\tresultSchema() { return this.#result_schema; }\n\n\tstatic fromJSON(inputJson, options = {}, callback = null) {\n\t\tif (!inputJson || inputJson instanceof AbstractNode) {\n\t\t\treturn super.fromJSON(inputJson, options, callback);\n\t\t}\n\t\tconst { result_schema, ...restJson } = inputJson;\n\t\tconst instance = super.fromJSON(restJson, options, callback);\n\t\tif (instance && result_schema) {\n\t\t\tif (!(result_schema instanceof AbstractNode)) {\n\t\t\t\tthrow new Error(`Invalid Schema object passed at inputJson.result_schema`);\n\t\t\t}\n\t\t\tinstance.#result_schema = result_schema;\n\t\t}\n\t\treturn instance;\n\t}\n\n\tjsonfy(options = {}, transformer = null, schemaInference = null) {\n\t\tlet resultJson = super.jsonfy(options, transformer, schemaInference);\n\t\tif (this.#result_schema && options.resultSchemas !== false) {\n\t\t\tresultJson = {\n\t\t\t\t...resultJson,\n\t\t\t\tresult_schema: this.#result_schema,\n\t\t\t};\n\t\t}\n\t\treturn resultJson;\n\t}\n}", "import { AbstractNode } from './AbstractNode.js';\nimport { registry } from '../registry.js';\n\nexport const OriginSchemasMixin = (Class) => class extends Class {\n\n\t#origin_schemas;\n\n\toriginSchemas() { return this.#origin_schemas; }\n\n\tstatic fromJSON(inputJson, options = {}, callback = null) {\n\t\tif (!inputJson || inputJson instanceof AbstractNode) {\n\t\t\treturn super.fromJSON(inputJson, options, callback);\n\t\t}\n\t\tconst { origin_schemas, ...restJson } = inputJson;\n\t\tconst instance = super.fromJSON(restJson, options, callback);\n\t\tif (instance && origin_schemas) {\n\t\t\tif (!Array.isArray(origin_schemas)) {\n\t\t\t\tthrow new Error(`Invalid list passed at inputJson.origin_schemas`);\n\t\t\t}\n\t\t\tinstance.#origin_schemas = origin_schemas;\n\t\t}\n\t\treturn instance;\n\t}\n\n\tjsonfy(options = {}, transformer = null, schemaInference = null) {\n\t\tlet resultJson = super.jsonfy(options, transformer, schemaInference);\n\t\tif (this.#origin_schemas && options.originSchemas !== false) {\n\t\t\tresultJson = {\n\t\t\t\t...resultJson,\n\t\t\t\torigin_schemas: this.#origin_schemas,\n\t\t\t};\n\t\t}\n\t\treturn resultJson;\n\t}\n\n\tgetOriginSchemas(transformer) {\n\t\tconst originSchemas = [];\n\t\tlet foundJSONSchema = false;\n\t\tfor (const { resultSchema } of transformer.statementContext.artifacts.get('tableSchemas')) {\n\t\t\tif (resultSchema instanceof registry.JSONSchema) {\n\t\t\t\tif (foundJSONSchema) {\n\t\t\t\t\t// Not expect; not valid SQL; but however\n\t\t\t\t\tthrow new Error(`Multiple anonymous origin schemas detected`);\n\t\t\t\t}\n\t\t\t\tfoundJSONSchema = true;\n\t\t\t}\n\t\t\toriginSchemas.push(resultSchema);\n\t\t}\n\t\treturn originSchemas;\n\t}\n}", "import { AbstractNode } from './AbstractNode.js';\n\nexport class AbstractStmt extends AbstractNode {\n    \n    get statementNode() { return this; }\n\n    /* JSON API */\n\n\t#uuid;\n\n    get uuid() {\n        if (!this.#uuid) {\n            this.#uuid = `$query${(0 | Math.random() * 9e6).toString(36)}`;\n        }\n        return this.#uuid;\n    }\n\n\tstatic fromJSON(inputJson, options = {}, callback = null) {\n\t\tif (inputJson instanceof AbstractNode) {\n\t\t\treturn super.fromJSON(inputJson, options, callback);\n\t\t}\n\t\tconst { uuid, ...restJson } = inputJson;\n\t\tconst instance = super.fromJSON(restJson, options, callback);\n\t\tif (instance) {\n\t\t\tinstance.#uuid = uuid;\n\t\t}\n\t\treturn instance;\n\t}\n\n\tjsonfy(options = {}, transformer = null, schemaInference = null) {\n\t\tlet resultJson = super.jsonfy(options, transformer, schemaInference);\n\t\tif (this.#uuid) {\n\t\t\tresultJson = {\n\t\t\t\tuuid: this.#uuid,\n\t\t\t\t...resultJson,\n\t\t\t};\n\t\t}\n\t\treturn resultJson;\n\t}\n}", "import { ResultSchemaMixin } from './ResultSchemaMixin.js';\r\nimport { OriginSchemasMixin } from '../abstracts/OriginSchemasMixin.js';\r\nimport { AbstractStmt } from './AbstractStmt.js';\r\n\r\nexport class AbstractNonDDLStmt extends ResultSchemaMixin(OriginSchemasMixin(AbstractStmt)) {\r\n\r\n\trenderBindings(values) {\r\n\t\tif (!Array.isArray(values)) throw new Error(`Values must be an array`);\r\n\t\tconst queryBindings = [...this.queryBindings()];\r\n\t\tfor (let i = 0; i < values.length; i++) {\r\n\t\t\tconst bindings = queryBindings.filter(b => b.offset() === i+1);\r\n\t\t\tif (!bindings.length) throw new Error(`No bindings exists at offset #${i}`);\r\n\t\t\tbindings.forEach(b => b.value(values[i]));\r\n\t\t}\r\n\t}\r\n\r\n\tnormalizeBindings(dedupe = false) {\r\n\t\tconst queryBindings = [...this.queryBindings()];\r\n\t\tif (!dedupe) {\r\n\t\t\tqueryBindings.forEach((b, i) => b.offset(i+1));\r\n\t\t\treturn queryBindings;\r\n\t\t}\r\n\t\tlet redundants = new Map, $offset = 1;\r\n\t\tfor (const b of queryBindings) {\r\n\t\t\tif (b.offset() === 0 || !redundants.has(b.offset())) {\r\n\t\t\t\tconst newOffset = $offset++;\r\n\t\t\t\tredundants.set(b.offset(), newOffset);\r\n\t\t\t\tb.offset(newOffset);\r\n\t\t\t} else b.offset(redundants.get(b.offset())).withDetail('redundant', true);\r\n\t\t}\r\n\t\treturn queryBindings.filter(b => !b.getDetail('redundant'));\r\n\t}\r\n}\r\n", "import { registry } from './registry.js';\n\nexport class Transformer {\n\n    #callback;\n    get cb() { return this.#callback; }\n\n    #rands = new Map;\n    #hashes = new Map;\n\n    #parentTransformer;\n    get parentTransformer() { return this.#parentTransformer; }\n\n    #statementNode;\n    get statementNode() { return this.#statementNode; }\n\n    get statementContext() {\n        if (this.#isStatementContext) return this;\n        return this.#parentTransformer.statementContext;\n    }\n\n    get rootContext() {\n        return this.#parentTransformer?.rootContext || this;\n    }\n\n    #isStatementContext;\n    get isStatementContext() { return this.#isStatementContext; }\n\n    #artifacts = new Map([\n        ['outputSchemas', new Set],\n        ['tableSchemas', new Set],\n        ['selectorDimensions', new Map],\n        ['payloadDimensions', new Set],\n    ]);\n    get artifacts() { return this.#artifacts; }\n\n    constructor(callback, parentTransformer = null, statementNode = null) {\n        this.#callback = callback;\n        this.#parentTransformer = parentTransformer;\n        this.#statementNode = statementNode;\n        this.#isStatementContext = !parentTransformer\n            || statementNode !== parentTransformer.statementNode;\n    }\n\n    rand(type, { asSalt = false, rands = this.#rands } = {}) {\n        rands.set(type, !rands.has(type) ? 0 : rands.get(type) + 1);\n        return `${asSalt ? '~' : '$'}${type}~${rands.get(type)}`;\n    }\n\n    hash(value, type, { hashes = this.#hashes } = {}) {\n        if (!hashes.has(value)) {\n            hashes.set(value, this.rand(type));\n        }\n        return hashes.get(value);\n    }\n\n    transform(node, defaultTransform, key, options0, originatingContext = this) {\n\n        const $defaultTransform = (options1 = options0, childTransformer = originatingContext) => {\n\n            // From parentTransformer:\n            // implicitly inherit current instance for sub-transforms\n            if (typeof options1 === 'function') {\n                childTransformer = new Transformer(options1, childTransformer, this.#statementNode);\n                options1 = options0;\n            }\n\n            // If this.transform() was called from a subquery scope identified by originatingContext\n            if (originatingContext.statementNode !== this.#statementNode) {\n                // don't call handlers in this scope\n                return defaultTransform(options1, childTransformer);\n            }\n\n            return this.#callback(node, (options2 = options1) => {\n\n                // From callback:\n                // implicitly inherit current instance for sub-transforms\n                if (typeof options2 === 'function') {\n                    childTransformer = new Transformer(options2, childTransformer, this.#statementNode);\n                    options2 = options1;\n                }\n\n                return defaultTransform(options2, childTransformer);\n            }, key, options1);\n        };\n\n        if (this.#parentTransformer) {\n            // Call parentTransformer and pass originating scope\n            return this.#parentTransformer.transform(node, $defaultTransform, key, options0, originatingContext);\n        }\n\n        return $defaultTransform();\n    }\n}", "import { AbstractNonDDLStmt } from '../abstracts/AbstractNonDDLStmt.js';\nimport { Transformer } from '../Transformer.js';\nimport { registry } from '../registry.js';\n\nexport class CTE extends AbstractNonDDLStmt {\n\n    /* SYNTAX RULES */\n\n    static get _bodyTypes() {\n        return [\n            'SelectStmt',\n            'TableStmt',\n            'InsertStmt',\n            'UpsertStmt',\n            'UpdateStmt',\n            'DeleteStmt',\n            'ValuesConstructor',\n        ];\n    }\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'keyword', value: 'WITH' },\n            { type: 'keyword', as: 'recursive', value: 'RECURSIVE', booleanfy: true, optional: true },\n            { type: 'CTEItem', as: 'declarations', arity: { min: 1 }, itemSeparator, assert: true, autoIndent: 2 },\n            { type: this._bodyTypes, as: 'body', assert: true, autoSpacing: '\\n' },\n        ];\n    }\n\n    /* AST API */\n\n    recursive() { return this._get('recursive'); }\n\n    declarations() { return this._get('declarations'); }\n\n    body() { return this._get('body'); }\n\n    /* JSON API */\n\n    jsonfy(options = {}, transformer = null, schemaInference = null) {\n        if (!options.deSugar) return super.jsonfy(options, transformer, schemaInference);\n\n        let outerResultSchema;\n\n        transformer = new Transformer((node, defaultTransform, keyHint) => {\n            // Process body nodes\n            if (keyHint === 'body' && node.parentNode === this) {\n                const bodyResultJson = defaultTransform();\n\n                outerResultSchema = bodyResultJson.result_schema;\n\n                return bodyResultJson;\n            }\n\n            return defaultTransform();\n        }, transformer, this);\n\n        // Run transform\n        const resultJson = super.jsonfy(options, transformer, schemaInference);\n        return {\n            ...resultJson,\n            result_schema: outerResultSchema,\n        };\n    }\n}", "import { AbstractNonDDLStmt } from '../abstracts/AbstractNonDDLStmt.js';\nimport { Transformer } from '../Transformer.js';\nimport { registry } from '../registry.js';\n\nexport class CTEItem extends AbstractNonDDLStmt {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'CTEItemAlias', as: 'alias', assert: true },\n            { type: 'keyword', value: 'AS' },\n            {\n                optional: true,\n                dialect: 'postgres',\n                syntaxes: [\n                    [\n                        { type: 'operator', as: 'not_materialized_kw', value: 'NOT', booleanfy: true },\n                        { type: 'keyword', value: 'MATERIALIZED', assert: true },\n                    ],\n                    { type: 'keyword', as: 'materialized', value: 'MATERIALIZED', booleanfy: true },\n                ],\n            },\n            {\n                type: 'paren_block',\n                syntax: { type: ['SelectStmt', 'InsertStmt', 'UpsertStmt', 'UpdateStmt', 'DeleteStmt', 'TableStmt', 'ValuesConstructor'], as: 'expr', autoIndent: true },\n            },\n            { type: 'PGSearchClause', as: 'search_clause', optional: true },\n            { type: 'PGCycleClause', as: 'cycle_clause', optional: true },\n        ];\n    }\n\n    /* AST API */\n\n    alias() { return this._get('alias'); }\n\n    notMaterializedKW() { return this._get('not_materialized_kw'); }\n\n    materialized() { return this._get('materialized'); }\n\n    expr() { return this._get('expr'); }\n\n    searchClause() { return this._get('search_clause'); }\n\n    cycleClause() { return this._get('cycle_clause'); }\n\n    /* JSON API */\n\n    jsonfy(options = {}, transformer = null, schemaInference = null) {\n        let resultJson = super.jsonfy(options, transformer, schemaInference);\n        if (options.deSugar) {\n\n            const namespaceIdent = {\n                nodeName: registry.Identifier.NODE_NAME,\n                value: resultJson.alias.value,\n                delim: resultJson.alias.delim,\n            };\n\n            let resultSchema = resultJson.expr.result_schema;\n\n            if (resultSchema instanceof registry.TableSchema) {\n                resultSchema = resultSchema.clone({ renameTo: namespaceIdent });\n            } else {\n                resultSchema = registry.TableSchema.fromJSON({\n                    name: namespaceIdent,\n                    entries: resultSchema?.entries().map((s) => s.jsonfy()) || [],\n                });\n            }\n\n            if (resultJson.alias.columns?.length) {\n                if (resultJson.alias.columns.length !== resultSchema.length) {\n                    throw new SyntaxError(`[${this}] Number of column aliases must match number of result columns.`);\n                }\n                resultSchema = resultSchema.clone({}, new Transformer((node, defaultTransform, key) => {\n                    if (typeof key === 'number' && node.parentNode === resultSchema) {\n                        if (node instanceof registry.ColumnSchema) {\n                            return node.jsonfy({ renameTo: resultJson.alias.columns[key] });\n                        }\n                        return {\n                            ...node.jsonfy(),\n                            nodeName: registry.ColumnSchema.NODE_NAME,\n                            name: resultJson.alias.columns[key],\n                        };\n                    }\n                    return defaultTransform();\n                }));\n            }\n\n            transformer.statementContext.artifacts.get('tableSchemas').add({ type: 'CTEItem', resultSchema });\n\n            resultJson = {\n                ...resultJson,\n                result_schema: resultSchema,\n            };\n        }\n\n        return resultJson;\n    }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\nimport { _eq } from '../../abstracts/util.js';\n\nexport class Identifier extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() { return { type: 'identifier', as: '.' }; }\n\n    static get syntaxPriority() { return -1; }\n\n    /* AST API */\n\n    value() { return this._get('value'); }\n\n    /* API */\n\n    identifiesAs(ident, cs = undefined) {\n        if (ident instanceof Identifier) {\n\t\t\treturn _eq(this.value(), ident.value(), cs === undefined ? (this._has('delim') || ident._has('delim')) : cs);\n\t\t}\n        if (typeof ident === 'string') {\n            return _eq(this._get('value'), ident, cs === undefined ? this._has('delim') : cs);\n        }\n        return super.identifiesAs(ident, cs);\n    }\n}", "import { Identifier } from '../expr/ref/Identifier.js';\n\nexport class CTEItemAlias extends Identifier {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { ...[].concat(super.syntaxRules)[0] },\n            {\n                type: 'paren_block',\n                syntax: { type: 'Identifier', as: 'columns', arity: { min: 1 }, itemSeparator, assert: true },\n                if: 'value',\n                optional: true,\n                optionalParens: true,\n            }\n        ];\n    }\n\n    /* AST API */\n\n    columns() { return this._get('columns'); }\n}", "export * from './column/index.js';\nexport * from './constraint/index.js';\nexport * from './ident/index.js';\nexport * from './index/index.js';\nexport * from './namespace/index.js';\nexport * from './table/index.js';\nexport { CreateSchemaStmt } from './CreateSchemaStmt.js';\nexport { DropSchemaStmt } from './DropSchemaStmt.js';\nexport { CreateTableStmt } from './CreateTableStmt.js';\nexport { DropTableStmt } from './DropTableStmt.js';\nexport { DDLStmt } from './DDLStmt.js'\n", "import { AbstractNode } from './AbstractNode.js';\n\nexport class AbstractNodeList extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() { return []; }\n\n    // API\n\n    get length() { return (this._get('entries') || []).length; }\n\n    [Symbol.iterator]() { return (this._get('entries') || [])[Symbol.iterator](); }\n\n    ['entries']() { return (this._get('entries') || []).slice(0); }\n\n    delete(index) { return this._delete('entries', index); }\n\n    get(index) { return this._get('entries', index); }\n\n    set(index, value) { return this._set('entries', index, value); }\n\n    has(index) { return this._has('entries', index); }\n\n    add(...args) { return this._add('entries', ...args); }\n}", "import { AbstractNodeList } from './AbstractNodeList.js';\n\nexport class AbstractDiff extends AbstractNodeList {\n\n    /* AST API */\n}", "import { AbstractDiff } from '../../abstracts/AbstractDiff.js';\n\nexport class ColumnDiff extends AbstractDiff {}", "import { AbstractNodeList } from './AbstractNodeList.js';\nimport { AbstractNode } from './AbstractNode.js';\nimport { registry } from '../registry.js';\n\nexport class AbstractSchema extends AbstractNodeList {\n\n    /* AST API */\n\n    name() { return this._get('name'); }\n\n    /* API */\n\n    identifiesAs(value, ...args) {\n        return this.name()?.identifiesAs(\n            value instanceof AbstractSchema ? value.name() : value,\n            ...args\n        );\n    }\n\n    /* JSON API */\n\n    static fromJSON(inputJson, options = {}, callback = null) {\n        if (inputJson instanceof AbstractNode) {\n            return super.fromJSON(inputJson, options, callback);\n        }\n        const { ddl_name, ...restJson } = inputJson;\n        const node = super.fromJSON(restJson, options, callback);\n        if (ddl_name && node) {\n            const iddlNameIdent = [registry.NamespaceIdent, registry.TableIdent, registry.ColumnIdent].reduce((prev, Class) => prev || Class.fromJSON(ddl_name), null);\n            node._set('ddl_name', iddlNameIdent);\n        }\n        return node;\n    }\n\n    jsonfy({ renameTo, ...options } = {}, transformer = null, schemaInference = null) {\n        let resultJson = super.jsonfy(options, transformer, schemaInference);\n        if (renameTo) {\n            if (renameTo instanceof AbstractNode) {\n                throw new Error(`options.renameTo must be a JSON value.`);\n            }\n            if (resultJson.name?.value && !resultJson.ddl_name) {\n                resultJson = { ...resultJson, ddl_name: resultJson.name };\n            }\n            return { ...resultJson, name: renameTo };\n        }\n        return resultJson;\n    }\n}", "import { AbstractSchema } from '../../abstracts/AbstractSchema.js';\nimport { registry } from '../../registry.js';\n\nexport class ColumnSchema extends AbstractSchema {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const type = [\n            'CheckConstraint',\n            'ColumnDefaultConstraint',\n            'ColumnExpressionConstraint',\n            'ColumnFKConstraint',\n            'ColumnIdentityConstraint',\n            'ColumnNullConstraint',\n            'ColumnPKConstraint',\n            'ColumnUKConstraint',\n            'MYColumnAutoIncrementModifier',\n            'MYColumnCommentModifier',\n            'MYColumnOnUpdateModifier',\n            'MYColumnVisibilityModifier',\n        ];\n        return [\n            { type: ['ColumnIdent', 'Identifier'/* to support mock names */], as: 'name' },\n            { type: 'DataType', as: 'data_type'/*, assert: true (SRFExprDDL1 needs to be able to check out)*/ },\n            { type, as: 'entries', arity: Infinity, singletons: true, optional: true },\n\n        ];\n    }\n\n    /* AST API */\n\n    dataType() { return this._get('data_type'); }\n\n    /* API */\n\n    defaultConstraint() {\n        for (const cons of this) {\n            if (cons instanceof registry.ColumnDefaultConstraint) return cons;\n        }\n    }\n\n    expressionConstraint() {\n        for (const cons of this) {\n            if (cons instanceof registry.ColumnExpressionConstraint) return cons;\n        }\n    }\n\n    identityConstraint() {\n        for (const cons of this) {\n            if (cons instanceof registry.ColumnIdentityConstraint) return cons;\n        }\n    }\n\n    autoIncrementConstraint() {\n        for (const cons of this) {\n            if (cons instanceof registry.MYColumnAutoIncrementModifier) return cons;\n        }\n    }\n\n    nullConstraint() {\n        for (const cons of this) {\n            if (cons instanceof registry.ColumnNullConstraint) return cons;\n        }\n    }\n\n    pkConstraint(normalized = false) {\n        for (const cons of this) {\n            if (cons instanceof registry.ColumnPKConstraint) return cons;\n        }\n        if (normalized && this.parentNode instanceof registry.TableSchema) {\n            const pkConstraint = this.parentNode.pkConstraint(false);\n            const pkColumns = pkConstraint?.columns() || [];\n            if (pkColumns.length === 1 && pkColumns[0].identifiesAs(this.name())) {\n                const { nodeName, columns, ...cJson } = pkConstraint.jsonfy();\n                const instance = registry.ColumnPKConstraint.fromJSON(cJson);\n                this._adoptNodes(instance);\n                return instance;\n            }\n        }\n    }\n\n    fkConstraint(normalized = false) {\n        for (const cons of this) {\n            if (cons instanceof registry.ColumnFKConstraint) return cons;\n        }\n        if (normalized && this.parentNode instanceof registry.TableSchema) {\n            const { nodeName, columns, ...cJson } = this.parentNode.fkConstraints(false).find((c) => {\n                const columns = c.columns();\n                return columns.length === 1 && columns[0].identifiesAs(this.name());\n            })?.jsonfy() || {};\n            if (nodeName) {\n                const instance = registry.ColumnFKConstraint.fromJSON(cJson);\n                this._adoptNodes(instance);\n                return instance;\n            }\n        }\n    }\n\n    ukConstraint(normalized = false) {\n        for (const cons of this) {\n            if (cons instanceof registry.ColumnUKConstraint) return cons;\n        }\n        if (normalized && this.parentNode instanceof registry.TableSchema) {\n            const { nodeName, columns, ...cJson } = this.parentNode.ukConstraints(false).find((c) => {\n                const columns = c.columns();\n                return columns.length === 1 && columns[0].identifiesAs(this.name());\n            })?.jsonfy() || {};\n            if (nodeName) {\n                const instance = registry.ColumnUKConstraint.fromJSON(cJson);\n                this._adoptNodes(instance);\n                return instance;\n            }\n        }\n    }\n\n    ckConstraint(normalized = false) {\n        for (const cons of this) {\n            if (cons instanceof registry.CheckConstraint) return cons;\n        }\n        if (normalized && this.parentNode instanceof registry.TableSchema) {\n            let instance = this.parentNode.ckConstraints(false).find((c) => {\n                const columns = c.columns();\n                return columns.length === 1 && columns[0].identifiesAs(this.name());\n            });\n            if (instance = instance?.clone()) {\n                this._adoptNodes(instance);\n                return instance;\n            }\n        }\n    }\n\n    jsonfy({ normalized = false, ...options } = {}, transformer = null, schemaInference = null) {\n        let resultJson = super.jsonfy(options, transformer, schemaInference);\n        if (normalized) {\n            let tableLevelConstraints = [];\n            for (const x of ['pk', 'fk', 'uk', 'ck']) {\n                const method = `${x}Constraint`;\n                if (!this[method]()) {\n                    tableLevelConstraints.push(this[method](true)?.jsonfy());\n                }\n            }\n            if ((tableLevelConstraints = tableLevelConstraints.filter((s) => s)).length) {\n                return {\n                    ...resultJson,\n                    entries: resultJson.entries.concat(tableLevelConstraints)\n                }\n            }\n        }\n        return resultJson;\n    }\n}\n", "import { AbstractNode } from '../../../abstracts/AbstractNode.js';\n\nexport class FKMatchRule extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', value: 'MATCH' },\n            { type: 'keyword', as: 'value', value: ['FULL', 'PARTIAL', 'SIMPLE'], assert: true },\n        ];\n    }\n\n    /*. AST API */\n\n    value() { return this._get('value'); }\n}", "import { AbstractNode } from '../../../abstracts/AbstractNode.js';\n\nexport class FKDeleteRule extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', value: 'ON' },\n            { type: 'keyword', value: 'DELETE' },\n            { type: 'ReferentialAction', as: 'action', assert: true },\n        ];\n    }\n\n    /*. AST API */\n\n    action() { return this._get('action'); }\n}", "import { AbstractNode } from '../../../abstracts/AbstractNode.js';\n\nexport class FKUpdateRule extends AbstractNode {\n    \n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', value: 'ON' },\n            { type: 'keyword', value: 'UPDATE' },\n            { type: 'ReferentialAction', as: 'action', assert: true },\n        ];\n    }\n\n    /*. AST API */\n\n    action() { return this._get('action'); }\n}", "import { AbstractNodeList } from '../../../abstracts/AbstractNodeList.js';\n\nexport class PGIndexParameters extends AbstractNodeList {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: ['PGIndexParamInclude', 'PGIndexParamUsing', 'PGIndexParamWith'], as: 'entries', arity: Infinity, singletons: true },\n        ];\n    }\n}", "import { AbstractNodeList } from '../../../abstracts/AbstractNodeList.js';\n\nexport class PGIndexParamInclude extends AbstractNodeList {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'keyword', value: 'INCLUDE' },\n            {\n                type: 'paren_block',\n                syntax: { type: 'ColumnRef2', as: 'entries', arity: { min: 1 }, itemSeparator },\n            }\n        ];\n    }\n}", "import { AbstractNode } from '../../../abstracts/AbstractNode.js';\n\nexport class PGIndexParamUsing extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', value: 'USING' },\n            { type: 'keyword', value: 'INDEX' },\n            { type: 'keyword', value: 'TABLESPACE' },\n            { type: 'identifier', as: '.' },\n        ];\n    }\n}", "import { AbstractNodeList } from '../../../abstracts/AbstractNodeList.js';\n\nexport class PGIndexParamWith extends AbstractNodeList {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'keyword', value: 'WITH' },\n            {\n                type: 'paren_block',\n                syntax: { type: 'ConfigAssignmentExprAlt2', as: 'entries', arity: { min: 1 }, itemSeparator },\n            }\n        ];\n    }\n}", "import { AbstractSchema } from '../../abstracts/AbstractSchema.js';\nimport { registry } from '../../registry.js';\n\nexport class ConstraintSchema extends AbstractSchema {\n\n    /* SYNTAX RULES */\n\n    static buildSyntaxRules(rules) {\n        return [\n            {\n                optional: true,\n                syntax: [\n                    { type: 'keyword', value: 'CONSTRAINT' },\n                    { type: 'Identifier', as: 'name', assert: true },\n                ]\n            },\n            ...\n            rules,\n            {\n                optional: true,\n                dialect: 'postgres',\n                syntaxes: [\n                    [\n                        { type: 'operator', as: 'pg_deferrable', value: 'NOT' },\n                        { type: 'keyword', value: 'DEFERRABLE' },\n                    ],\n                    { type: 'keyword', as: 'pg_deferrable', value: 'DEFERRABLE' },\n                ],\n            },\n            {\n                optional: true,\n                dialect: 'postgres',\n                syntax: [\n                    { type: 'keyword', value: 'INITIALLY' },\n                    { type: 'keyword', as: 'pg_deferred', value: ['DEFERRED', 'IMMEDIATE'] },\n                ],\n            },\n        ];\n    }\n\n    static get syntaxRules() {\n        return {\n            type: [\n                // Table-only constraints must match first\n                'TableFKConstraint',\n                'TablePKConstraint',\n                'TableUKConstraint',\n                // then, non-table-only constraints\n                'CheckConstraint',\n                'ColumnDefaultConstraint',\n                'ColumnExpressionConstraint',\n                'ColumnFKConstraint',\n                'ColumnIdentityConstraint',\n                'ColumnNullConstraint',\n                'ColumnPKConstraint',\n                'ColumnUKConstraint',\n            ],\n        };\n    }\n\n    get isColumnLevel() { return this.parentNode instanceof registry.ColumnSchema; }\n\n    /* AST API */\n\n    pgDeferrable() { return this._get('pg_deferrable'); }\n\n    pgDeferred() { return this._get('pg_deferred'); }\n}", "import { ConstraintSchema } from '../ConstraintSchema.js';\n\nexport class PGTableEXConstraintItem extends ConstraintSchema {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            {\n                syntaxes: [\n                    { type: 'ColumnRef2', as: 'expr' },\n                    { type: 'ParenExpr', as: 'expr' },\n                ],\n            },\n            {\n                optional: true,\n                syntax: [\n                    { type: 'operator', value: 'COLLATE' },\n                    { type: 'string_literal', as: 'collation', assert: true },\n                ],\n            },\n            {\n                optional: true,\n                syntax: [\n                    { type: 'Identifier', as: 'opclass' },\n                    {\n                        optional: true,\n                        type: 'paren_block',\n                        syntax: { type: 'ConfigAssignmentExpr', as: 'opclass_parameters', arity: { min: 1 }, itemSeparator, assert: true },\n                    },\n                ],\n            },\n            { type: 'keyword', value: ['ASC', 'DESC'], as: 'dir', optional: true },\n            {\n                optional: true,\n                syntax: [\n                    { type: 'keyword', value: 'NULLS' },\n                    { type: 'keyword', as: 'nulls_spec', value: ['FIRST', 'LAST'], assert: true },\n                ]\n            },\n            { type: 'keyword', value: 'WITH' },\n            { type: 'operator', as: 'operator' },\n        ];\n    }\n\n    /* AST API */\n\n    expr() { return this._get('expr'); }\n\n    collation() { return this._get('collation'); }\n\n    opclass() { return this._get('opclass'); }\n\n    opclassParameters() { return this._get('opclass_parameters'); }\n\n    dir() { return this._get('dir'); }\n\n    nullsSpec() { return this._get('nulls_spec'); }\n\n    operator() { return this._get('operator'); }\n}", "import { AbstractNode } from '../../../abstracts/AbstractNode.js';\n\nexport class ReferentialAction extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return {\n            syntaxes: [\n                { type: 'keyword', as: 'value', value: ['NO ACTION', 'RESTRICT', 'CASCADE'] },\n                [\n                    { type: 'keyword', as: 'value', value: ['SET NULL', 'SET DEFAULT'] },\n                    {\n                        optional: true,\n                        dialect: 'postgres',\n                        type: 'paren_block',\n                        syntax: { type: 'Identifier', as: 'columns', arity: { min: 1 }, itemSeparator },\n                    }\n                ],\n            ],\n        };\n    }\n\n    /*. AST API */\n\n    value() { return this._get('value'); }\n\n    columns() { return this._get('columns'); }\n}", "import { registry } from '../../registry.js';\nimport { ConstraintSchema } from './ConstraintSchema.js';\n\nexport class CheckConstraint extends ConstraintSchema {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return this.buildSyntaxRules([\n            { type: 'keyword', value: 'CHECK' },\n            {\n                type: 'paren_block',\n                syntax: { type: 'Expr', as: 'expr', assert: true },\n                assert: true,\n            },\n            { type: 'keyword', as: 'no_inherit_kw', value: 'NO INHERIT', optional: true }\n        ]);\n    }\n\n    /* AST API */\n\n    expr() { return this._get('expr'); }\n\n    noInheritKW() { return this._get('no_inherit_kw'); }\n\n    /* API */\n\n    columns() {\n        const columns = [];\n        this.expr()?.walkTree((node) => {\n            if (node instanceof registry.ColumnRef1) {\n                columns.push(registry.ColumnRef2.fromJSON({ value: node.value() }))\n            } else return node;\n        });\n        return columns;\n    }\n}", "import { ConstraintSchema } from './ConstraintSchema.js';\n\nexport class ColumnDefaultConstraint extends ConstraintSchema {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return this.buildSyntaxRules([\n            { type: 'keyword', value: 'DEFAULT' },\n            { type: 'Expr', as: 'expr', assert: true, dialect: 'postgres' },\n            { type: ['NumberLiteral', 'StringLiteral', 'NullLiteral', 'BoolLiteral', 'CallExpr', 'RowConstructor'], as: 'expr', assert: true, dialect: 'mysql' },\n        ]);\n    }\n\n    /* AST API */\n\n    expr() { return this._get('expr'); }\n}", "import { ConstraintSchema } from './ConstraintSchema.js';\n\nexport class ColumnExpressionConstraint extends ConstraintSchema {\n\n\t/* SYNTAX RULES */\n\n\tstatic get syntaxRules() {\n\t\treturn this.buildSyntaxRules([\n\t\t\t{\n\t\t\t\tdialect: 'postgres',\n\t\t\t\tsyntax: [\n\t\t\t\t\t{ type: 'keyword', value: 'GENERATED' },\n\t\t\t\t\t{ type: 'keyword', value: 'ALWAYS' },\n\t\t\t\t\t{ type: 'keyword', value: 'AS' },\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: 'paren_block',\n\t\t\t\t\t\tsyntax: { type: 'Expr', as: 'expr', assert: true },\n\t\t\t\t\t},\n\t\t\t\t\t{ type: 'keyword', as: 'stored', value: 'STORED', assert: true },\n\t\t\t\t],\n\t\t\t},\n\t\t\t{\n\t\t\t\tdialect: 'mysql',\n\t\t\t\tsyntax: [\n\t\t\t\t\t{\n\t\t\t\t\t\toptional: true,\n\t\t\t\t\t\tsyntax: [\n\t\t\t\t\t\t\t{ type: 'keyword', as: 'my_generated_kw', value: 'GENERATED', booleanfy: true },\n\t\t\t\t\t\t\t{ type: 'keyword', value: 'ALWAYS' },\n\t\t\t\t\t\t],\n\t\t\t\t\t},\n\t\t\t\t\t{ type: 'keyword', value: 'AS' },\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: 'paren_block',\n\t\t\t\t\t\tsyntax: { type: 'Expr', as: 'expr', assert: true },\n\t\t\t\t\t},\n\t\t\t\t\t{ type: 'keyword', as: 'stored', value: ['STORED', 'VIRTUAL'], optional: true },\n\t\t\t\t],\n\t\t\t},\n\t\t]);\n\t}\n\n\t/* AST API */\n\n\tmyGeneratedKW() { return this._get('my_generated_kw'); }\n\n\texpr() { return this._get('expr'); }\n\n\tstored() { return this._get('stored'); }\n}", "import { ConstraintSchema } from './ConstraintSchema.js';\nimport { registry } from '../../registry.js';\n\nconst {\n    ColumnSchema,\n    ColumnRef2,\n} = registry;\n\nexport class ColumnFKConstraint extends ConstraintSchema {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return this.buildSyntaxRules([\n            { type: 'keyword', value: 'REFERENCES' },\n            { type: 'TableRef2', as: 'target_table', assert: true },\n            {\n                dialect: 'postgres',\n                optional: true,\n                type: 'paren_block',\n                syntax: { type: 'Identifier', as: 'target_columns', arity: 1, itemSeparator, singletons: 'BY_KEY', assert: true },\n            },\n            {\n                dialect: 'mysql',\n                type: 'paren_block',\n                syntax: { type: 'Identifier', as: 'target_columns', arity: 1, itemSeparator, singletons: 'BY_KEY', assert: true },\n            },\n            { type: ['FKMatchRule', 'FKDeleteRule', 'FKUpdateRule'], as: 'referential_rules', arity: Infinity, singletons: true },\n\n        ]);\n    }\n\n    /* AST API */\n\n    targetTable() { return this._get('target_table'); }\n\n    targetColumns() { return this._get('target_columns'); }\n\n    referentialRules() { return this._get('referential_rules'); }\n\n    /* API */\n\n    columns() {\n        return this.parentNode instanceof ColumnSchema\n            ? [ColumnRef2.fromJSON({ value: this.parentNode.name().value() })]\n            : [];\n    }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\nimport { ColumnIdentityConstraint } from './ColumnIdentityConstraint.js';\n\nexport class MYColumnAutoIncrementModifier extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            dialect: 'mysql',\n            syntax: { type: 'keyword', as: '.', value: 'AUTO_INCREMENT' },\n        };\n    }\n\n    /* JSON RULES */\n\n    jsonfy(options = {}, transformer = null, schemaInference = null) {\n        return (options.toDialect || this.options.dialect) === 'postgres'\n            ? (new ColumnIdentityConstraint).jsonfy(options, transformer, schemaInference)\n            : super.jsonfy(options, transformer, schemaInference);\n    }\n}", "import { MYColumnAutoIncrementModifier } from './MYColumnAutoIncrementModifier.js';\nimport { ConstraintSchema } from './ConstraintSchema.js';\n\nexport class ColumnIdentityConstraint extends ConstraintSchema {\n\n\t/* SYNTAX RULES */\n\n\tstatic get syntaxRules() {\n\t\treturn this.buildSyntaxRules([\n\t\t\t{ type: 'keyword', value: 'GENERATED' },\n\t\t\t{\n\t\t\t\tsyntaxes: [\n\t\t\t\t\t{ type: 'keyword', as: 'always_kw', value: 'ALWAYS', booleanfy: true },\n\t\t\t\t\t{\n\t\t\t\t\t\tsyntax: [\n\t\t\t\t\t\t\t{ type: 'keyword', as: 'by_default_kw', value: 'BY', booleanfy: true },\n\t\t\t\t\t\t\t{ type: 'keyword', value: 'DEFAULT', assert: true },\n\t\t\t\t\t\t],\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t},\n\t\t\t{\n\t\t\t\toptional: true,\n\t\t\t\tsyntax: [\n\t\t\t\t\t{ type: 'keyword', as: 'as_identity_kw', value: 'AS', booleanfy: true },\n\t\t\t\t\t{ type: 'keyword', value: 'IDENTITY', assert: true },\n\t\t\t\t]\n\t\t\t}\n\t\t]);\n\t}\n\n\t/* AST API */\n\n\talwaysKW() { return this._get('always_kw'); }\n\n\tbyDefaultKW() { return this._get('by_default_kw'); }\n\n\tasIdentityKW() { return this._get('as_identity_kw'); }\n\n\t/* JSON API */\n\n\tjsonfy(options = {}, transformer = null, schemaInference = null) {\n\t\treturn (options.toDialect || this.options.dialect) === 'mysql'\n\t\t\t? (new MYColumnAutoIncrementModifier).jsonfy(options, transformer, schemaInference)\n\t\t\t: super.jsonfy(options, transformer, schemaInference);\n\t}\n}", "import { ConstraintSchema } from './ConstraintSchema.js';\n\nexport class ColumnNullConstraint extends ConstraintSchema {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return this.buildSyntaxRules([\n            {\n                syntaxes: [\n                    [\n                        { type: 'operator', as: '.', value: 'NOT' },\n                        { type: 'null_literal', value: 'NULL' },\n                    ],\n                    { type: 'null_literal', as: '.', value: 'NULL' },\n                ]\n            }\n        ]);\n    }\n\n    /* AST API */\n\n    value() { return this._get('value'); }\n}", "import { ConstraintSchema } from './ConstraintSchema.js';\nimport { registry } from '../../registry.js';\n\nexport class ColumnPKConstraint extends ConstraintSchema {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return this.buildSyntaxRules([\n            { type: 'keyword', value: 'PRIMARY' },\n            { type: 'keyword', as: '.', value: 'KEY', assert: true },\n            { type: 'PGIndexParameters', as: 'pg_index_parameters', optional: true, dialect: 'postgres' },\n        ]);\n    }\n\n    /* AST API */\n\n    primaryKW() { return this._get('primary_kw'); }\n\n    pgIndexParameters() { return this._get('pg_index_parameters'); }\n\n    /* API */\n\n    columns() {\n        return this.parentNode instanceof registry.ColumnSchema\n            ? [registry.ColumnRef2.fromJSON({ value: this.parentNode.name().value() })]\n            : [];\n    }\n}", "import { ConstraintSchema } from './ConstraintSchema.js';\nimport { registry } from '../../registry.js';\n\nexport class ColumnUKConstraint extends ConstraintSchema {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return this.buildSyntaxRules([\n            { type: 'keyword', value: 'UNIQUE' },\n            { type: 'keyword', as: 'my_key_kw', value: ['KEY', 'INDEX'], optional: true, dialect: 'mysql' },\n            {\n                optional: true,\n                dialect: 'postgres',\n                syntaxes: [\n                    [\n                        { type: 'keyword', value: 'NULLS' },\n                        { type: 'operator', as: 'pg_nulls_distinct', value: 'NOT' },\n                        { type: 'keyword', value: 'DISTINCT', assert: true },\n                    ],\n                    [\n                        { type: 'keyword', value: 'NULLS' },\n                        { type: 'keyword', as: 'pg_nulls_distinct', value: 'DISTINCT', assert: true },\n                    ],\n                ]\n            },\n            { type: 'PGIndexParameters', as: 'pg_index_parameters', optional: true, dialect: 'postgres' }\n        ]);\n    }\n\n    /* AST API */\n\n    myKeyKW() { return this._get('my_key_kw'); }\n\n    pgNullsDistinct() { return this._get('pg_nulls_distinct'); }\n\n    pgIndexParameters() { return this._get('pg_index_parameters'); }\n\n    /* API */\n\n    columns() {\n        const {\n            ColumnSchema,\n            ColumnRef2,\n        } = registry;\n        return this.parentNode instanceof ColumnSchema\n            ? [ColumnRef2.fromJSON({ value: this.parentNode.name().value() })]\n            : [];\n    }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class MYColumnCommentModifier extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            dialect: 'mysql',\n            syntax: [\n                { type: 'keyword', value: 'COMMENT' },\n                { type: 'string_literal', as: '.' },\n            ],\n        };\n    }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class MYColumnOnUpdateModifier extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            dialect: 'mysql',\n            syntax: [\n                { type: 'keyword', value: 'ON' },\n                { type: 'keyword', value: 'UPDATE' },\n                { type: 'keyword', as: '.' },\n            ],\n        };\n    }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class MYColumnVisibilityModifier extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            dialect: 'mysql',\n            syntaxes: [\n                { type: 'keyword', as: '.', value: 'VISIBLE' },\n                { type: 'keyword', as: '.', value: 'INVISIBLE' },\n            ],\n        };\n    }\n}", "import { ConstraintSchema } from './ConstraintSchema.js';\n\nexport class PGTableEXConstraint extends ConstraintSchema {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return {\n            dialect: 'postgres',\n            syntax: this.buildSyntaxRules([\n                { type: 'keyword', value: 'EXCLUDE' },\n                {\n                    optional: true,\n                    syntax: [\n                        { type: 'keyword', value: 'USING' },\n                        { type: 'keyword', as: 'index_method', assert: true },\n                    ],\n                },\n                {\n                    type: 'paren_block',\n                    syntax: { type: 'PGTableEXConstraintItem', as: 'entries', arity: { min: 1 }, itemSeparator, assert: true },\n                    assert: true,\n                },\n                { type: 'PGIndexParameters', as: 'pg_index_parameters', optional: true },\n                {\n                    optional: true,\n                    syntax: [\n                        { type: 'keyword', value: 'WHERE' },\n                        {\n                            type: 'paren_block',\n                            syntax: { type: 'Expr', as: 'where_predicate', assert: true },\n                            assert: true,\n                        }\n                    ],\n                }\n            ])\n        };\n    }\n\n    /* AST API */\n\n    indexMethod() { return this._get('index_method'); }\n\n    entries() { return this._get('entries'); }\n\n    pgIndexParameters() { return this._get('pg_index_parameters'); }\n\n    wherePredicate() { return this._get('where_predicate'); }\n}", "import { ConstraintSchema } from './ConstraintSchema.js';\n\nexport class TableFKConstraint extends ConstraintSchema {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return this.buildSyntaxRules([\n            { type: 'keyword', value: 'FOREIGN' },\n            { type: 'keyword', value: 'KEY', assert: true },\n            {\n                type: 'paren_block',\n                syntax: { type: 'ColumnRef2', as: 'columns', arity: { min: 1 }, itemSeparator, assert: true, singletons: 'BY_KEY' },\n            },\n            { type: 'keyword', value: 'REFERENCES' },\n            { type: 'TableRef2', as: 'target_table', assert: true },\n            {\n                dialect: 'postgres',\n                optional: true,\n                type: 'paren_block',\n                syntax: { type: 'Identifier', as: 'target_columns', arity: { min: 1 }, itemSeparator, singletons: 'BY_KEY', assert: true },\n            },\n            {\n                dialect: 'mysql',\n                type: 'paren_block',\n                syntax: { type: 'Identifier', as: 'target_columns', arity: { min: 1 }, itemSeparator, singletons: 'BY_KEY', assert: true },\n            },\n            { type: ['FKMatchRule', 'FKDeleteRule', 'FKUpdateRule'], as: 'referential_rules', arity: Infinity, assert: true, singletons: true },\n        ]);\n    }\n\n    /* AST API */\n\n    columns() { return this._get('columns'); }\n\n    targetTable() { return this._get('target_table'); }\n\n    targetColumns() { return this._get('target_columns'); }\n\n    referentialRules() { return this._get('referential_rules'); }\n}\n", "import { ConstraintSchema } from './ConstraintSchema.js';\n\nexport class TablePKConstraint extends ConstraintSchema {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return this.buildSyntaxRules([\n            { type: 'keyword', value: 'PRIMARY' },\n            { type: 'keyword', as: '.', value: 'KEY', assert: true },\n            {\n                type: 'paren_block',\n                syntax: { type: 'ColumnRef2', as: 'columns', arity: { min: 1 }, itemSeparator, singletons: 'BY_KEY', assert: true },\n                assert: true,\n            },\n            { type: 'PGIndexParameters', as: 'pg_index_parameters', optional: true, dialect: 'postgres' },\n        ]);\n    }\n\n    /* AST API */\n\n    columns() { return this._get('columns'); }\n    \n    pgIndexParameters() { return this._get('pg_index_parameters'); }\n}", "import { ConstraintSchema } from './ConstraintSchema.js';\n\nexport class TableUKConstraint extends ConstraintSchema {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return this.buildSyntaxRules([\n            { type: 'keyword', value: 'UNIQUE' },\n            { type: 'keyword', as: 'my_key_kw', value: ['KEY', 'INDEX'], optional: true, dialect: 'mysql' },\n            {\n                optional: true,\n                dialect: 'postgres',\n                syntaxes: [\n                    [\n                        { type: 'keyword', value: 'NULLS' },\n                        { type: 'operator', as: 'pg_nulls_distinct', value: 'NOT' },\n                        { type: 'keyword', value: 'DISTINCT', assert: true },\n                    ],\n                    [\n                        { type: 'keyword', value: 'NULLS' },\n                        { type: 'keyword', as: 'pg_nulls_distinct', value: 'DISTINCT', assert: true },\n                    ],\n                ]\n            },\n            {\n                type: 'paren_block',\n                syntax: { type: 'ColumnRef2', as: 'columns', arity: { min: 1 }, itemSeparator, singletons: 'BY_KEY', assert: true },\n                assert: true,\n            },\n            { type: 'PGIndexParameters', as: 'pg_index_parameters', optional: true, dialect: 'postgres' }\n        ]);\n    }\n\n    /* AST API */\n\n    myKeyKW() { return this._get('my_key_kw'); }\n\n    pgNullsDistinct() { return this._get('pg_nulls_distinct'); }\n\n    columns() { return this._get('columns'); }\n\n    pgIndexParameters() { return this._get('pg_index_parameters'); }\n}", "export const PathMixin = (Class) => class extends Class {\n\n\t/* SYNTAX RULES */\n\n\tstatic get _qualifierType() { return 'Identifier'; }\n\n\tstatic buildSyntaxRules(baseRule = null) {\n\t\treturn [\n\t\t\t{\n\t\t\t\toptional: true,\n\t\t\t\tsyntax: [\n\t\t\t\t\t{ type: this._qualifierType, as: 'qualifier' },\n\t\t\t\t\t{ type: 'punctuation', value: '.', autoSpacing: false },\n\t\t\t\t],\n\t\t\t},\n\t\t\tbaseRule ||\n\t\t\t{ ...[].concat(super.syntaxRules)[0], autoSpacing: false },\n\t\t];\n\t}\n\n\tstatic get syntaxRules() { return this.buildSyntaxRules(); }\n\n\tstatic get syntaxPriority() { return -1; }\n\n\t/* AST API */\n\n\tqualifier() { return this._get('qualifier'); }\n\n\t/* API */\n\n\tidentifiesAs(ident, cs = undefined) {\n\t\tconst result = super.identifiesAs(ident, cs);\n\t\tif (result && this.qualifier() && ident.qualifier?.()) {\n\t\t\treturn this.qualifier().identifiesAs(ident.qualifier(), cs);\n\t\t}\n\t\treturn result;\n\t}\n\n\tstatic async _parseFromRules(tokenStream, syntaxRules, { left = undefined, minPrecedence = 0, trail, ...options }, resultAST = {}) {\n\t\tif (left) return super._parseFromRules(tokenStream, syntaxRules, { left, minPrecedence, trail, ...options }, resultAST);\n\t\tconst qualifierTokens = [];\n\n\t\twhile (true) {\n\t\t\tif (await tokenStream.match(1, 'punctuation', '.')) {\n\t\t\t\tqualifierTokens.push(await tokenStream.eat());\n\t\t\t} else if (await tokenStream.match(1, 'version_spec') && await tokenStream.match(2, 'punctuation', '.')) {\n\t\t\t\tqualifierTokens.push(await tokenStream.eat());\n\t\t\t\tqualifierTokens.push(await tokenStream.eat());\n\t\t\t} else break;\n\t\t\t// Determine whether to eat the punctuation ahead of another loop\n\t\t\tif (await tokenStream.match(2, 'punctuation', '.') || (await tokenStream.match(2, 'version_spec') && await tokenStream.match(3, 'punctuation', '.'))) {\n\t\t\t\tqualifierTokens.push(await tokenStream.eat());\n\t\t\t}\n\t\t}\n\n\t\tconst qualifierExposure = 'qualifier';\n\t\tif (qualifierTokens.length) {\n\t\t\tconst qualifierTypes = [].concat(this._qualifierType);\n\t\t\tconst qualifierStream = await this.toStream(qualifierTokens, options);\n\t\t\tconst qualifierOptions = { minPrecedence, trail: trail.concat(this.NODE_NAME, `<${qualifierExposure}>`), ...options };\n\t\t\tleft = await this._parseFromTypes(qualifierStream, qualifierTypes, qualifierOptions);\n\t\t} else {\n\t\t\tleft = false; // Explicitly set to false to prevent super.parse() trying parsing the qualifier rule\n\t\t}\n\n\t\treturn await super._parseFromRules(tokenStream, syntaxRules, { left, minPrecedence, trail, ...options }, resultAST);\n\t}\n}", "export * from './abstraction/index.js';\nexport * from './call/index.js';\nexport * from './case/index.js';\nexport * from './etc/index.js';\nexport * from './literals/index.js';\nexport * from './op/index.js';\nexport * from './ref/index.js';\nexport * from './abstraction/index.js';\nexport * from './var/index.js';\nexport { LQBackRefAbstraction } from './ref/LQBackRefAbstraction.js';\nexport { RowConstructor } from './abstraction/RowConstructor.js';\nexport { ScalarSubquery } from './abstraction/ScalarSubquery.js';\nexport { TypedRowConstructor } from './abstraction/TypedRowConstructor.js';\nexport { Expr } from './Expr.js';                                                              \n", "import { registry } from '../registry.js';\n\nexport const TypeSysMixin = (Class) => class extends Class {\n\n\tdataType() { return registry.DataType.fromJSON({ value: 'TEXT' }); };\n}", "import { TypeSysMixin } from '../abstracts/TypeSysMixin.js';\nimport { AbstractNode } from '../abstracts/AbstractNode.js';\n\nexport class AbstractClassicExpr extends TypeSysMixin(AbstractNode) {}", "import { AbstractClassicExpr } from '../AbstractClassicExpr.js';\n\nexport class ParenExpr extends AbstractClassicExpr {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            type: 'paren_block',\n            syntax: { type: 'Expr', as: 'expr' },\n            autoIndent: true,\n        };\n    }\n\n    static get syntaxPriority() { return -1; }\n\n    /* AST API */\n\n    expr() { return this._get('expr'); }\n\n    exprUnwrapped() {\n        const expr = this._get('expr');\n        if (expr instanceof ParenExpr) {\n            return expr.exprUnwrapped();\n        }\n        return expr;\n    }\n\n    /* TYPESYS */\n\n    dataType() { return this.expr()?.dataType(); }\n}", "import { TypeSysMixin } from '../../abstracts/TypeSysMixin.js';\nimport { ResultSchemaMixin } from '../../abstracts/ResultSchemaMixin.js';\nimport { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\nimport { registry } from '../../registry.js';\n\nexport class RowConstructor extends ResultSchemaMixin(TypeSysMixin(AbstractNodeList)) {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return {\n            syntax: [\n                {\n                    type: 'paren_block',\n                    syntax: {\n                        type: [\n                            'DerivedQuery'/* to support dimensional RHS in DML, and should appear before Expr.RowConstructor */,\n                            'ValuesTableLiteral',\n                            'Expr',\n                        ], as: 'entries', arity: Infinity, itemSeparator, autoIndent: 10\n                    },\n                },\n            ],\n        };\n    }\n\n    static get syntaxPriority() { return 49; } // Below all () shapes like LQBackRefAbstraction but above DerivedQuery \n\n    /* API */\n\n    exprUnwrapped() {\n        if (this._get('entries')?.length === 1 && this._get('entries')[0] instanceof RowConstructor) {\n            return this._get('entries')[0].exprUnwrapped();\n        }\n        return this;\n    }\n\n    /* TYPESYS */\n\n    dataType() { return registry.DataType.fromJSON({ value: 'SET' }); }\n\n    /* JSON API */\n\n    jsonfy(options = {}, transformer = null, schemaInference = null) {\n        let resultJson = super.jsonfy(options, transformer, schemaInference);\n        if (options.deSugar?.rowConstructorSchemas || options.forceDeSugar) {\n\n            const entriesNode = this.entries() || [];\n            const entriesJson = resultJson.entries || [];\n\n            const resultSchemas = entriesJson.map((entry, i) => {\n                const ident = { nodeName: registry.Identifier.NODE_NAME, value: i };\n                if (entry.result_schema instanceof registry.ColumnSchema) {\n                    return entry.result_schema.clone({ renameTo: ident });\n                }\n                return registry.ColumnSchema.fromJSON({\n                    name: ident,\n                    data_type: entriesNode[i].dataType().jsonfy(),\n                });\n            });\n\n            resultJson = {\n                ...resultJson,\n                result_schema: registry.JSONSchema.fromJSON({ entries: resultSchemas }, { assert: true }),\n            };\n        }\n\n        return resultJson;\n    }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\nimport { ResultSchemaMixin } from '../../abstracts/ResultSchemaMixin.js';\nimport { ParenExpr } from '../../expr/abstraction/ParenExpr.js';\n\nexport class DerivedQuery extends ResultSchemaMixin(ParenExpr) {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            type: 'paren_block',\n            syntax: { type: ['SelectStmt', 'TableStmt', 'CTE'], as: 'expr', autoIndent: true },\n\n        };\n    }\n\n    static get syntaxPriority() { return -1; }\n\n    /* TYPESYS API */\n\n    dataType() { return this.expr()?.dataType(); }\n\n    #is_correlated = false;\n\n    isCorrelated() { return this.#is_correlated; }\n\n    /* JSON API */\n\n    static fromJSON(inputJson, options = {}, callback = null) {\n        if (!inputJson || inputJson instanceof AbstractNode) {\n            return super.fromJSON(inputJson, options, callback);\n        }\n        const { is_correlated, ...restJson } = inputJson;\n        const instance = super.fromJSON(restJson, options, callback);\n        if (instance && is_correlated) {\n            if (typeof is_correlated !== 'boolean') {\n                throw new Error(`Invalid value passed at inputJson.is_correlated`);\n            }\n            instance.#is_correlated = is_correlated;\n        }\n        return instance;\n    }\n\n    jsonfy(options = {}, transformer = null, schemaInference = null) {\n        const statementContextArtifacts = transformer?.statementContext?.artifacts || new Map;\n        statementContextArtifacts.set('derivedQueryCorrelationFlag', null);\n\n        let resultJson = super.jsonfy(options, transformer, schemaInference);\n\n        const correlationFlag = statementContextArtifacts.get('derivedQueryCorrelationFlag');\n        statementContextArtifacts.delete('derivedQueryCorrelationFlag');\n\n        if (options.deSugar) {\n            const resultSchema = resultJson.expr?.result_schema;\n            resultJson = {\n                ...resultJson,\n                is_correlated: !!correlationFlag,\n                result_schema: resultSchema,\n            };\n        } else {\n            resultJson = {\n                ...resultJson,\n                is_correlated: this.#is_correlated,\n            };\n        }\n\n        return resultJson;\n    }\n}", "import { DerivedQuery } from '../../dql/TA/DerivedQuery.js';\nimport { registry } from '../../registry.js';\n\nexport class ScalarSubquery extends DerivedQuery {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            type: 'paren_block',\n            syntax: { type: ['SelectStmt', 'CTE'], as: 'expr' },\n            autoIndent: true,\n        };\n    }\n\n    static get syntaxPriority() { return 48; } // Below RowConstructor\n\n    /* TYPESYS API */\n\n    dataType() {\n        if (this.resultSchema()) {\n            return this.resultSchema().dataType();\n        }\n        return registry.DataType.fromJSON({ value: 'TEXT' });\n    }\n\n    /* JSON API */\n\n    jsonfy(options = {}, transformer = null, schemaInference = null) {\n        let resultJson = super.jsonfy(options, transformer, schemaInference);\n        if (options.deSugar) {\n            let resultSchema = resultJson.expr?.result_schema;\n            if (resultSchema?.length !== 1) {\n                throw new Error(`Scalar subqueries must return a scalar value.`);\n            }\n            resultSchema = resultSchema.entries()[0];\n            resultJson = {\n                ...resultJson,\n                result_schema: resultSchema,\n            };\n        }\n        return resultJson;\n    }\n}", "import { RowConstructor } from './RowConstructor.js';\n\nexport class TypedRowConstructor extends RowConstructor {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', value: 'ROW' },\n            ...[].concat(super.syntaxRules)\n        ];\n    }\n\n    static get syntaxPriority() { return 52; } // Above CallExpr\n}", "import { AbstractNode } from '../../../abstracts/AbstractNode.js';\n\nexport class PGFilterClause extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            dialect: 'postgres',\n            syntax: [\n                { type: 'keyword', value: 'FILTER' },\n                {\n                    type: 'paren_block',\n                    syntax: { type: 'WhereClause', as: 'where_clause' },\n                    assert: true,\n                    autoIndent: true\n                }\n            ]\n        };\n    }\n\n    static get syntaxPriority() { return -1; }\n\n    /* AST API */\n\n    whereClause() { return this._get('where_clause'); }\n}", "import { AbstractNode } from '../../../abstracts/AbstractNode.js';\n\nexport class PGWithinGroupClause extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            dialect: 'postgres',\n            syntax: [\n                { type: 'keyword', value: 'WITHIN' },\n                { type: 'keyword', value: 'GROUP' },\n                {\n                    type: 'paren_block',\n                    syntax: { type: 'OrderByClause', as: 'order_by_clause' },\n                    assert: true,\n                    autoIndent: true,\n                },\n            ]\n        };\n    }\n\n    static get syntaxPriority() { return -1; }\n\n    /* AST API */\n\n    orderByClause() { return this._get('order_by_clause'); }\n}", "import { ResultSchemaMixin } from '../../abstracts/ResultSchemaMixin.js';\nimport { AbstractClassicExpr } from '../AbstractClassicExpr.js';\n\nexport class CallExpr extends ResultSchemaMixin(AbstractClassicExpr) {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n\n        return {\n            syntaxes: [\n                {\n                    peek: [0, 'keyword', [\n                        'NOW', 'CURRENT_DATE', 'CURRENT_TIME', 'CURRENT_TIMESTAMP',\n                        'IF', 'NULLIF', 'IFNULL',\n                        'COALESCE', 'GREATEST', 'LEAST', 'CONCAT',\n                        'CONCAT_WS', 'FORMAT',\n                        'MD5', 'SHA1',\n                        'TO_JSON', 'TO_JSONB', 'JSON_TYPEOF', 'JSONB_TYPEOF',\n                        'JSON_BUILD_ARRAY', 'JSONB_BUILD_ARRAY', 'JSON_BUILD_OBJECT', 'JSONB_BUILD_OBJECT',\n                        'JSON_POPULATE_RECORD', 'JSONB_POPULATE_RECORD', 'JSON_PATH_QUERY', 'JSON_PATH_EXISTS',\n                        'JSON_ARRAY', 'JSON_OBJECT', 'JSON_EXTRACT', 'JSON_UNQUOTE',\n                        'JSON_SET', 'JSON_INSERT', 'JSON_REPLACE', 'JSON_REMOVE',\n                        'JSON_SEARCH', 'JSON_CONTAINS', 'JSON_CONTAINS_PATH',\n                        'JSON_KEYS', 'JSON_ARRAY_APPEND', 'JSON_ARRAY_INSERT',\n                        'JSON_DEPTH', 'JSON_LENGTH', 'JSON_MERGE_PRESERVE',\n                        'JSON_MERGE_PATCH', 'JSON_PRETTY', 'JSON_STORAGE_FREE',\n                        'ST_ASTEXT', 'ST_ASGEOJSON', 'ST_GEOMFROMTEXT',\n                        'ST_WITHIN', 'ST_CONTAINS', 'ST_INTERSECTS', 'ST_DISTANCE', 'ST_BUFFER',\n                        'MAKE_DATE', 'MAKE_TIME', 'MAKE_TIMESTAMP', 'ARRAY',\n                        'CURDATE', 'CURTIME', 'SYSDATE', 'STR_TO_DATE', 'MAKEDATE', 'MAKETIME',\n                    ]],\n                    syntaxes: [\n\n                        // ---------- \uD83E\uDDEE Cross-dialect scalar functions (fixed arity)\n\n                        [\n                            { type: 'keyword', as: 'name', value: ['CURRENT_DATE', 'CURRENT_TIME', 'CURRENT_TIMESTAMP'] },\n                            {\n                                type: 'paren_block',\n                                syntax: { type: 'Expr', as: 'arguments', arity: 0, itemSeparator, assert: true },\n                                optional: true,\n                                optionalParens: true,\n                                autoSpacing: false\n                            }\n                        ],\n                        [\n                            { type: 'keyword', as: 'name', value: ['NOW'] },\n                            {\n                                type: 'paren_block',\n                                syntax: { type: 'Expr', as: 'arguments', arity: 0, itemSeparator, assert: true },\n                                optional: true,\n                                autoSpacing: false\n                            }\n                        ],\n                        [\n                            { type: 'keyword', as: 'name', value: ['IF', 'NULLIF', 'IFNULL'] },\n                            {\n                                type: 'paren_block',\n                                syntax: { type: 'Expr', as: 'arguments', arity: { min: 2, max: 3 }, itemSeparator, assert: true },\n                                autoSpacing: false\n                            }\n                        ],\n\n                        // ---------- \uD83D\uDCD0 Cross-dialect scalar functions (variadic)\n\n                        [\n                            { type: 'keyword', as: 'name', value: ['COALESCE', 'GREATEST', 'LEAST', 'CONCAT'] },\n                            {\n                                type: 'paren_block',\n                                syntax: { type: 'Expr', as: 'arguments', arity: { min: 1 }, itemSeparator, assert: true },\n                                autoSpacing: false\n                            }\n                        ],\n                        [\n                            { type: 'keyword', as: 'name', value: ['CONCAT_WS', 'FORMAT'] },\n                            {\n                                type: 'paren_block',\n                                syntax: { type: 'Expr', as: 'arguments', arity: { min: 2 }, itemSeparator, assert: true },\n                                autoSpacing: false\n                            }\n                        ],\n                        [\n                            { type: 'keyword', as: 'name', value: ['MD5', 'SHA1'] },\n                            {\n                                type: 'paren_block',\n                                syntax: { type: 'Expr', as: 'arguments', arity: 1, itemSeparator, assert: true },\n                                autoSpacing: false\n                            }\n                        ],\n\n                        // ---------- \uD83D\uDFE9 Spatial functions (PostgreSQL & MySQL)\n\n                        [\n                            { type: 'keyword', as: 'name', value: ['ST_ASTEXT', 'ST_ASGEOJSON', 'ST_GEOMFROMTEXT'] },\n                            {\n                                type: 'paren_block',\n                                syntax: { type: 'Expr', as: 'arguments', arity: 1, itemSeparator, assert: true },\n                                autoSpacing: false\n                            }\n                        ],\n                        [\n                            { type: 'keyword', as: 'name', value: ['ST_WITHIN', 'ST_CONTAINS', 'ST_INTERSECTS', 'ST_DISTANCE', 'ST_BUFFER'] },\n                            {\n                                type: 'paren_block',\n                                syntax: { type: 'Expr', as: 'arguments', arity: 2, itemSeparator, assert: true },\n                                autoSpacing: false\n                            }\n                        ],\n\n                        // ---------- \uD83D\uDFEB PostgreSQL JSON functions\n\n                        {\n                            dialect: 'postgres',\n                            syntax: [\n                                { type: 'keyword', as: 'name', value: ['TO_JSON', 'TO_JSONB', 'JSON_TYPEOF', 'JSONB_TYPEOF'] },\n                                {\n                                    type: 'paren_block',\n                                    syntax: { type: 'Expr', as: 'arguments', arity: 1, itemSeparator, assert: true },\n                                    autoSpacing: false\n                                }\n                            ]\n                        },\n                        {\n                            dialect: 'postgres',\n                            syntax: [\n                                { type: 'keyword', as: 'name', value: ['JSON_BUILD_ARRAY', 'JSONB_BUILD_ARRAY', 'JSON_BUILD_OBJECT', 'JSONB_BUILD_OBJECT'] },\n                                {\n                                    type: 'paren_block',\n                                    syntax: { type: 'Expr', as: 'arguments', arity: { min: 0 }, itemSeparator, assert: true },\n                                    autoSpacing: false\n                                }\n                            ]\n                        },\n                        {\n                            dialect: 'postgres',\n                            syntax: [\n                                { type: 'keyword', as: 'name', value: ['JSON_POPULATE_RECORD', 'JSONB_POPULATE_RECORD', 'JSON_PATH_QUERY', 'JSON_PATH_EXISTS'] },\n                                {\n                                    type: 'paren_block',\n                                    syntax: { type: 'Expr', as: 'arguments', arity: 2, itemSeparator, assert: true },\n                                    autoSpacing: false\n                                }\n                            ]\n                        },\n                        {\n                            dialect: 'postgres',\n                            syntax: [\n                                { type: 'keyword', as: 'name', value: ['ARRAY'] },\n                                {\n                                    type: 'paren_block',\n                                    syntax: { type: 'SelectStmt', as: 'arguments', arity: 1, itemSeparator, assert: true },\n                                    autoIndent: true,\n                                    autoSpacing: true\n                                }\n                            ]\n                        },\n\n                        // ---------- \uD83D\uDFEB PostgreSQL Date functions\n\n                        {\n                            dialect: 'postgres',\n                            syntax: [\n                                { type: 'keyword', as: 'name', value: ['MAKE_DATE', 'MAKE_TIME', 'MAKE_TIMESTAMP'] },\n                                {\n                                    type: 'paren_block',\n                                    syntax: { type: 'Expr', as: 'arguments', arity: Infinity, itemSeparator, assert: true },\n                                    autoSpacing: false\n                                }\n                            ]\n                        },\n\n                        // ---------- \uD83D\uDFE7 MySQL JSON functions\n\n                        {\n                            dialect: 'mysql',\n                            syntax: [\n                                {\n                                    type: 'keyword', as: 'name', value: [\n                                        'JSON_ARRAY', 'JSON_OBJECT', 'JSON_EXTRACT', 'JSON_UNQUOTE',\n                                        'JSON_SET', 'JSON_INSERT', 'JSON_REPLACE', 'JSON_REMOVE',\n                                        'JSON_SEARCH', 'JSON_CONTAINS', 'JSON_CONTAINS_PATH',\n                                        'JSON_KEYS', 'JSON_ARRAY_APPEND', 'JSON_ARRAY_INSERT',\n                                        'JSON_DEPTH', 'JSON_LENGTH', 'JSON_MERGE_PRESERVE',\n                                        'JSON_MERGE_PATCH', 'JSON_PRETTY', 'JSON_STORAGE_FREE'\n                                    ]\n                                },\n                                {\n                                    type: 'paren_block',\n                                    syntax: { type: 'Expr', as: 'arguments', arity: { min: 1 }, itemSeparator, assert: true },\n                                    autoSpacing: false\n                                }\n                            ]\n                        },\n\n                        // ---------- \uD83D\uDFE7 MySQL Date functions\n\n                        {\n                            dialect: 'mysql',\n                            syntax: [\n                                { type: 'keyword', as: 'name', value: ['CURDATE', 'CURTIME', 'SYSDATE'] },\n                                {\n                                    type: 'paren_block',\n                                    syntax: { type: 'Expr', as: 'arguments', arity: 0, itemSeparator, optional: true, assert: true },\n                                    autoSpacing: false\n                                }\n                            ]\n                        },\n                        {\n                            dialect: 'mysql',\n                            syntax: [\n                                { type: 'keyword', as: 'name', value: 'STR_TO_DATE' },\n                                {\n                                    type: 'paren_block',\n                                    syntax: { type: 'Expr', as: 'arguments', arity: 2, itemSeparator, assert: true },\n                                    autoSpacing: false\n                                }\n                            ]\n                        },\n                        {\n                            dialect: 'mysql',\n                            syntax: [\n                                { type: 'keyword', as: 'name', value: ['MAKEDATE', 'MAKETIME'] },\n                                {\n                                    type: 'paren_block',\n                                    syntax: { type: 'Expr', as: 'arguments', arity: 2, itemSeparator, assert: true },\n                                    autoSpacing: false\n                                }\n                            ]\n                        }\n                    ]\n                },\n\n                // ---------- \uD83E\uDDE0 Fallback: general call syntax\n\n                [\n                    { type: 'keyword', as: 'name' },\n                    {\n                        type: 'paren_block',\n                        syntax: { type: 'Expr', as: 'arguments', arity: Infinity, itemSeparator },\n                        autoSpacing: false\n                    }\n                ],\n                [\n                    { type: 'identifier', as: 'name' },\n                    {\n                        type: 'paren_block',\n                        syntax: { type: 'Expr', as: 'arguments', arity: Infinity, itemSeparator },\n                        autoSpacing: false\n                    }\n                ]\n            ]\n        };\n    }\n\n    static get syntaxPriority() { return 51; }\n\n    /* AST API */\n\n    name() { return this._get('name'); }\n\n    arguments() { return this._get('arguments'); }\n}\n", "import { CallExpr } from './CallExpr.js';\n\nexport class AggrCallExpr extends CallExpr {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n\n        // Optional modifiers and clauses\n        const optional_distinct_modifier = { type: 'keyword', as: 'distinct', value: 'DISTINCT', booleanfy: true, optional: true };\n        const optional_separator_arg = {\n            optional: true,\n            syntax: [\n                { type: 'keyword', value: 'SEPARATOR' },\n                { type: 'Expr', as: 'separator', assert: true }\n            ]\n        };\n        const optional_order_by_clause = { type: 'OrderByClause', as: 'order_by_clause', optional: true };\n        const optional_filter_clause_postgres = { type: 'PGFilterClause', as: 'pg_filter_clause', optional: true, dialect: 'postgres' };\n        const optional_within_group_clause_postgres = { type: 'PGWithinGroupClause', as: 'pg_within_group_clause', optional: true, dialect: 'postgres' };\n        const optional_null_handling_directive = {\n            optional: true,\n            syntax: [\n                { type: 'keyword', as: 'null_handling', value: ['IGNORE', 'RESPECT'] },\n                { type: 'keyword', value: 'NULLS', assert: true }\n            ]\n        };\n        const optional_over_clause = {\n            optional: true,\n            syntax: [\n                { type: 'keyword', value: 'OVER' },\n                { type: ['WindowRef', 'WindowSpec'], as: 'over_clause', assert: true }\n            ]\n        };\n\n        // The syntax compositions\n        return {\n            peek: [0, 'keyword', [\n                'COUNT', 'SUM', 'AVG', 'MIN', 'MAX',\n                'ARRAY_AGG', 'STRING_AGG', 'GROUP_CONCAT',\n                'REGR_SLOPE', 'COVAR_POP', 'COVAR_SAMP', 'CORR',\n                'PERCENTILE_CONT', 'PERCENTILE_DISC', 'MODE',\n                'RANK', 'DENSE_RANK', 'ROW_NUMBER',\n                'EVERY', 'BOOL_AND', 'BOOL_OR',\n                'BIT_AND', 'BIT_OR', 'BIT_XOR',\n                'JSON_AGG', 'JSON_ARRAYAGG', 'JSON_OBJECT_AGG', 'JSONB_OBJECT_AGG', 'JSON_OBJECTAGG',\n                'STDDEV_POP', 'STDDEV_SAMP', 'VAR_POP', 'VAR_SAMP', 'VARIANCE', 'STD',\n                'XMLAGG', 'LEAD', 'LAG', 'NTILE', 'FIRST_VALUE', 'LAST_VALUE'\n            ]],\n            syntaxes: [\n\n                // ---------- \uD83D\uDD22 Basic aggregates\n\n                [ // COUNT(), COUNT(*)\n                    { type: 'keyword', as: 'name', value: 'COUNT' },\n                    {\n                        type: 'paren_block',\n                        syntax: [\n                            { dialect: 'postgres', type: 'ColumnRef0', as: 'arguments', arity: 1, assert: false/* note: to give syntax2 a chance */, itemSeparator },\n                            { dialect: 'mysql', type: 'ColumnRef0', as: 'arguments', arity: Infinity, assert: false/* note: to give syntax2 a chance */, itemSeparator, optional: true }\n                        ],\n                        autoSpacing: false,\n                    },\n                    { ...optional_filter_clause_postgres },\n                    { ...optional_over_clause },\n                ],\n                [ // COUNT|SUM|AVG|MIN|MAX([DISTINCT] expr) [FILTER (...)] [OVER (...)]\n                    { type: 'keyword', as: 'name', value: ['COUNT', 'SUM', 'AVG', 'MIN', 'MAX'] },\n                    {\n                        type: 'paren_block',\n                        syntax: [\n                            { ...optional_distinct_modifier },\n                            { type: 'Expr', as: 'arguments', arity: 1, itemSeparator, assert: true }\n                        ],\n                        autoSpacing: false,\n                    },\n                    { ...optional_filter_clause_postgres },\n                    { ...optional_over_clause },\n                ],\n\n                // ---------- \uD83E\uDDF5 List / string aggregates\n\n                {\n                    dialect: 'postgres',\n                    syntax: [ // ARRAY_AGG()\n                        { type: 'keyword', as: 'name', value: 'ARRAY_AGG' },\n                        {\n                            type: 'paren_block',\n                            syntax: [\n                                { ...optional_distinct_modifier },\n                                { type: 'Expr', as: 'arguments', arity: { min: 1 }, itemSeparator, assert: true },\n                                { ...optional_order_by_clause },\n                            ],\n                            autoSpacing: false,\n                        },\n                        { ...optional_filter_clause_postgres },\n                        { ...optional_over_clause },\n                    ]\n                },\n                {\n                    dialect: 'postgres',\n                    syntax: [ // STRING_AGG()\n                        { type: 'keyword', as: 'name', value: 'STRING_AGG' },\n                        {\n                            type: 'paren_block',\n                            syntax: [\n                                { ...optional_distinct_modifier },\n                                { type: 'Expr', as: 'arguments', arity: 2, itemSeparator, assert: true },\n                                { ...optional_order_by_clause },\n                                { ...optional_separator_arg },\n                            ],\n                            autoSpacing: false,\n                        },\n                        { ...optional_filter_clause_postgres },\n                        { ...optional_over_clause },\n                    ]\n                },\n                {\n                    dialect: 'mysql',\n                    syntax: [ // GROUP_CONCAT()\n                        { type: 'keyword', as: 'name', value: 'GROUP_CONCAT' },\n                        {\n                            type: 'paren_block',\n                            syntax: [\n                                { ...optional_distinct_modifier },\n                                { type: 'Expr', as: 'arguments', arity: { min: 1 }, itemSeparator, assert: true },\n                                { ...optional_order_by_clause },\n                                { ...optional_separator_arg },\n                            ],\n                            autoSpacing: false,\n                        },\n                        { ...optional_over_clause },\n                    ]\n                },\n\n                // ---------- \uD83D\uDCC8 Statistical aggregates\n\n                {\n                    dialect: 'postgres',\n                    syntax: [ // REGR_SLOPE() [FILTER (...)] [OVER (...)]\n                        { type: 'keyword', as: 'name', value: 'REGR_SLOPE' },\n                        {\n                            type: 'paren_block',\n                            syntax: { type: 'Expr', as: 'arguments', arity: 2, itemSeparator, assert: true },\n                            autoSpacing: false,\n                        },\n                        { ...optional_filter_clause_postgres },\n                        { ...optional_over_clause },\n                    ]\n                },\n                [ // COVAR_POP|COVAR_SAMP|CORR() [FILTER (...)] [OVER (...)]\n                    { type: 'keyword', as: 'name', value: ['COVAR_POP', 'COVAR_SAMP', 'CORR'] },\n                    {\n                        type: 'paren_block',\n                        syntax: { type: 'Expr', as: 'arguments', arity: 2, itemSeparator, assert: true },\n                        autoSpacing: false,\n                    },\n                    { ...optional_filter_clause_postgres },\n                    { ...optional_over_clause },\n                ],\n\n                // ---------- \uD83D\uDCD0 Ordered-set aggregates (PostgreSQL only)\n\n                {\n                    dialect: 'postgres',\n                    syntax: [ // PERCENTILE_CONT|PERCENTILE_DISC(expr) [FILTER (...)] [WITHIN GROUP (...)]\n                        { type: 'keyword', as: 'name', value: ['PERCENTILE_CONT', 'PERCENTILE_DISC'] },\n                        {\n                            type: 'paren_block',\n                            syntax: { type: 'Expr', as: 'arguments', arity: 1, itemSeparator, assert: true },\n                            autoSpacing: false,\n                        },\n                        { ...optional_filter_clause_postgres },\n                        { ...optional_within_group_clause_postgres, optional: false/* OVERRIDE for \"required\" */ },\n                    ]\n                },\n                {\n                    dialect: 'postgres',\n                    syntax: [ // MODE() [FILTER (...)] [WITHIN GROUP (...)]\n                        { type: 'keyword', as: 'name', value: 'MODE' },\n                        {\n                            type: 'paren_block',\n                            syntax: { type: 'Expr', as: 'arguments', arity: 0, itemSeparator, assert: true },\n                            autoSpacing: false,\n                        },\n                        { ...optional_filter_clause_postgres },\n                        { ...optional_within_group_clause_postgres, optional: false/* OVERRIDE for \"required\" */ },\n                    ]\n                },\n                {\n                    dialect: 'postgres',\n                    syntax: [ // RANK|DENSE_RANK() [FILTER (...)] [OVER (...)]\n                        { type: 'keyword', as: 'name', value: ['RANK', 'DENSE_RANK'] },\n                        {\n                            type: 'paren_block',\n                            syntax: { type: 'Expr', as: 'arguments', arity: 0, itemSeparator, assert: true },\n                            autoSpacing: false,\n                        },\n                        { ...optional_filter_clause_postgres },\n                        { ...optional_over_clause, optional: false },\n                    ]\n                },\n                [ // ROW_NUMBER() [OVER (...)]\n                    { type: 'keyword', as: 'name', value: 'ROW_NUMBER' },\n                    {\n                        type: 'paren_block',\n                        syntax: { type: 'Expr', as: 'arguments', arity: 0, itemSeparator, assert: true },\n                        autoSpacing: false,\n                    },\n                    { ...optional_over_clause, optional: false },\n                ],\n\n                // ---------- \uD83E\uDDE0 Boolean aggregates\n\n                {\n                    dialect: 'postgres',\n                    syntax: [ // EVERY|BOOL_AND|BOOL_OR([DISTINCT] expr) [FILTER (...)] [OVER (...)]\n                        { type: 'keyword', as: 'name', value: ['EVERY', 'BOOL_AND', 'BOOL_OR'] },\n                        {\n                            type: 'paren_block',\n                            syntax: [\n                                { ...optional_distinct_modifier },\n                                { type: 'Expr', as: 'arguments', arity: 1, itemSeparator, assert: true }\n                            ],\n                            autoSpacing: false,\n                        },\n                        { ...optional_filter_clause_postgres },\n                        { ...optional_over_clause },\n                    ]\n                },\n\n                // ---------- \uD83D\uDCE6 JSON aggregates\n\n                {\n                    dialect: 'postgres',\n                    syntax: [ // JSON_AGG([DISTINCT] expr) [FILTER (...)] [OVER (...)]\n                        { type: 'keyword', as: 'name', value: 'JSON_AGG' },\n                        {\n                            type: 'paren_block',\n                            syntax: [\n                                { ...optional_distinct_modifier },\n                                { type: 'Expr', as: 'arguments', arity: { min: 1 }, itemSeparator, assert: true }\n                            ],\n                            autoSpacing: false,\n                        },\n                        { ...optional_filter_clause_postgres },\n                        { ...optional_over_clause },\n                    ]\n                },\n                {\n                    dialect: 'mysql',\n                    syntax: [ // JSON_ARRAYAGG([DISTINCT] expr) [OVER (...)]\n                        { type: 'keyword', as: 'name', value: 'JSON_ARRAYAGG' },\n                        {\n                            type: 'paren_block',\n                            syntax: [\n                                { ...optional_distinct_modifier },\n                                { type: 'Expr', as: 'arguments', arity: { min: 1 }, itemSeparator, assert: true }\n                            ],\n                            autoSpacing: false,\n                        },\n                        { ...optional_over_clause },\n                    ]\n                },\n\n                // ---------- \uD83D\uDCE6 Others 1\n\n                {\n                    dialect: 'mysql',\n                    syntax: [ // BIT_XOR (MySQL only)\n                        { type: 'keyword', as: 'name', value: 'BIT_XOR' },\n                        {\n                            type: 'paren_block',\n                            syntax: [\n                                { ...optional_distinct_modifier },\n                                { type: 'Expr', as: 'arguments', arity: 1, itemSeparator, assert: true }\n                            ],\n                            autoSpacing: false,\n                        },\n                        { ...optional_over_clause },\n                    ]\n                },\n                [ // BIT_AND, BIT_OR (PostgreSQL + MySQL)\n                    { type: 'keyword', as: 'name', value: ['BIT_AND', 'BIT_OR'] },\n                    {\n                        type: 'paren_block',\n                        syntax: [\n                            { ...optional_distinct_modifier },\n                            { type: 'Expr', as: 'arguments', arity: 1, itemSeparator, assert: true }\n                        ],\n                        autoSpacing: false,\n                    },\n                    { ...optional_filter_clause_postgres },\n                    { ...optional_over_clause },\n                ],\n\n                // ---------- \uD83D\uDCE6 Others 2\n\n                {\n                    dialect: 'postgres',\n                    syntax: [\n                        { type: 'keyword', as: 'name', value: ['JSON_OBJECT_AGG', 'JSONB_OBJECT_AGG'] },\n                        {\n                            type: 'paren_block',\n                            syntax: [\n                                { ...optional_distinct_modifier },\n                                { type: 'Expr', as: 'arguments', arity: 2, itemSeparator, assert: true } // key, value\n                            ],\n                            autoSpacing: false,\n                        },\n                        { ...optional_filter_clause_postgres },\n                        { ...optional_over_clause },\n                    ]\n                },\n                {\n                    dialect: 'mysql',\n                    syntax: [\n                        { type: 'keyword', as: 'name', value: 'JSON_OBJECTAGG' },\n                        {\n                            type: 'paren_block',\n                            syntax: [\n                                { ...optional_distinct_modifier },\n                                { type: 'Expr', as: 'arguments', arity: 2, itemSeparator, assert: true } // key, value\n                            ],\n                            autoSpacing: false,\n                        },\n                        { ...optional_over_clause },\n                    ]\n                },\n\n                // ---------- \uD83D\uDCE6 Others 3\n\n                [\n                    { type: 'keyword', as: 'name', value: ['STDDEV_POP', 'STDDEV_SAMP', 'VAR_POP', 'VAR_SAMP', 'VARIANCE', 'STD'] },\n                    {\n                        type: 'paren_block',\n                        syntax: [\n                            { ...optional_distinct_modifier },\n                            { type: 'Expr', as: 'arguments', arity: 1, itemSeparator, assert: true }\n                        ],\n                        autoSpacing: false,\n                    },\n                    { ...optional_filter_clause_postgres },\n                    { ...optional_over_clause },\n                ],\n\n                // ---------- \uD83D\uDCE6 Others 4\n\n                {\n                    dialect: 'postgres',\n                    syntax: [\n                        { type: 'keyword', as: 'name', value: 'XMLAGG' },\n                        {\n                            type: 'paren_block',\n                            syntax: [\n                                { type: 'Expr', as: 'arguments', arity: 1, itemSeparator, assert: true },\n                                { ...optional_order_by_clause }\n                            ],\n                            autoSpacing: false,\n                        },\n                        { ...optional_filter_clause_postgres },\n                        { ...optional_over_clause },\n                    ]\n                },\n\n                // ---------- \uD83D\uDCE6 Others 5\n\n                [\n                    { type: 'keyword', as: 'name', value: ['LEAD', 'LAG'] },\n                    {\n                        type: 'paren_block',\n                        syntax: { type: 'Expr', as: 'arguments', arity: { max: 3 }, itemSeparator, optional: true, assert: true },\n                        autoSpacing: false,\n                    },\n                    { ...optional_null_handling_directive },\n                    { ...optional_over_clause },\n                ],\n                [\n                    { type: 'keyword', as: 'name', value: ['NTILE', 'FIRST_VALUE', 'LAST_VALUE'] },\n                    {\n                        type: 'paren_block',\n                        syntax: { type: 'Expr', as: 'arguments', arity: 1, itemSeparator, assert: true },\n                        autoSpacing: false,\n                    },\n                    { ...optional_over_clause, optional: false },\n                ],\n            ]\n        };\n    }\n\n    /* AST API */\n\n    distinct() { return this._get('distinct'); }\n\n    orderByClause() { return this._get('order_by_clause'); }\n\n    separator() { return this._get('separator'); }\n\n    overClause() { return this._get('over_clause'); }\n\n    // -- Postgres\n\n    pgFilterClause() { return this._get('pg_filter_clause'); }\n\n    pgWithinGroupClause() { return this._get('pg_within_group_clause'); }\n}", "import { TypeSysMixin } from '../../abstracts/TypeSysMixin.js';\nimport { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\n\nexport class CaseExpr extends TypeSysMixin(AbstractNodeList) {\n\n    /* DEFS */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', value: 'CASE' },\n            { type: 'Expr', as: 'subject', optional: true },\n            { type: 'CaseBranch', as: 'entries', arity: { min: 1 }, assert: true, autoIndent: 2 },\n            {\n                optional: true,\n                syntax: [\n                    { type: 'keyword', value: 'ELSE' },\n                    { type: 'Expr', as: 'alternate', autoIndent: true },\n                ],\n                autoSpacing: '\\n',\n            },\n            { type: 'keyword', value: 'END', autoSpacing: '\\n' },\n        ];\n    }\n\n    /* AST API */\n\n    subject() { return this._get('subject'); }\n    \n    branches() { return this.entries(); }\n\n    alternate() { return this._get('alternate'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class CaseBranch extends AbstractNode {\n\n    /* DEFS */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', value: 'WHEN' },\n            { type: 'Expr', as: 'condition' },\n            { type: 'keyword', value: 'THEN' },\n            { type: 'Expr', as: 'consequent' }\n        ];\n    }\n\n    static get syntaxPriority() { return -1; }\n\n    /* AST API */\n\n    condition() { return this._get('condition'); }\n\n    consequent() { return this._get('consequent'); }\n}", "import { AbstractClassicExpr } from '../AbstractClassicExpr.js';\n\nexport class CastExpr extends AbstractClassicExpr {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', value: 'CAST' },\n            {\n                type: 'paren_block',\n                syntax: [\n                    { type: 'Expr', as: 'expr' },\n                    { type: 'keyword', value: 'AS' },\n                    { type: 'DataType', as: 'data_type', assert: true },\n                ],\n                assert: true,\n                autoSpacing: false,\n            }\n        ];\n    }\n\n    /* AST API */\n\n    expr() { return this._get('expr'); }\n\n    dataType() { return this._get('data_type'); }\n}", "import { AbstractClassicExpr } from '../AbstractClassicExpr.js';\nimport { operators } from '../../toktypes.js';\nimport { registry } from '../../registry.js';\n\nexport class BinaryExpr extends AbstractClassicExpr {\n\n    /* DEFS */\n\n    static get syntaxRules() {\n        return [\n            { type: 'Expr', as: 'left', peek: [1, 'operator', ['NOT', undefined/* IMPORTANT */]] },\n            { type: 'operator', as: 'negation', value: 'NOT', booleanfy: true, optional: true },\n            { type: 'operator', as: 'operator' },\n            { type: 'Expr', as: 'right' },\n        ];\n    }\n\n    static get syntaxPriority() { return 0; }\n\n    /* AST API */\n\n    left() { return this._get('left'); }\n\n    negation() { return this._get('negation'); }\n\n    operator() { return this._get('operator'); }\n\n    right() { return this._get('right'); }\n\n    /* TYPESYS API */\n\n    dataType() {\n        const operator = this.operator();\n        if (!operator) return this.left()?.dataType();\n\n        const toDialect = this.options.dialect;\n        const operatorMap = new Map(operators.common.concat(operators[toDialect]));\n        const resultType = operatorMap.get(operator)?.resultType;\n        if (!resultType) return;\n\n        if (resultType === ':right') {\n            return this.right()?.dataType();\n        }\n        if (resultType === ':left') {\n            return this.left()?.dataType();\n        }\n        return registry.DataType.fromJSON({ value: resultType.toUpperCase() });\n    }\n}", "import { BinaryExpr } from '../op/BinaryExpr.js';\n\nexport class ExtractExpr extends BinaryExpr {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', value: 'EXTRACT' },\n            {\n                type: 'paren_block',\n                syntax: [\n                    { type: 'Expr', as: 'left' },\n                    { type: 'keyword', value: 'FROM' },\n                    { type: 'Expr', as: 'right', assert: true },\n                ],\n                autoSpacing: false\n            }\n        ];\n    }\n    \n    /* AST API */\n\n    left() { return this._get('left'); }\n\n    right() { return this._get('right'); }\n}", "import { registry } from '../../registry.js';\nimport { AbstractClassicExpr } from '../AbstractClassicExpr.js';\n\nexport class PredicateExpr extends AbstractClassicExpr {\n\n    /* DEFS */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', as: 'predicate', value: ['EXISTS'] },\n            { type: 'ScalarSubquery', as: 'expr' },\n        ];\n    }\n\n    /* AST API */\n\n    predicate() { return this._get('predicate'); }\n\n    expr() { return this._get('expr'); }\n\n    /* TYPESYS API */\n\n    dataType() { return registry.DataType.fromJSON({ value: 'BOOLEAN' }); }\n}\n", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class QuantitativeExpr extends AbstractNode {\n\n    /* DEFS */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', as: 'quantifier', value: ['ALL', 'ANY', 'SOME'] },\n            {\n                syntaxes: [\n                    { type: 'DerivedQuery', as: 'expr' },\n                    { type: 'paren_block', syntax: { type: 'Expr', as: 'expr' } }\n                ],\n            }\n        ];\n    }\n\n    /* AST API */\n\n    quantifier() { return this._get('quantifier'); }\n\n    expr() { return this._get('expr'); }\n}\n", "import { AbstractClassicExpr } from '../AbstractClassicExpr.js';\n\nexport class AbstractLiteral extends AbstractClassicExpr {\n\n    /* SYNTAX RULES */\n\n    static get syntaxPriority() { return 49; }\n    \n    /* AST API */\n\n    value() { return this._get('value'); }\n}", "import { AbstractLiteral } from './AbstractLiteral.js';\nimport { registry } from '../../registry.js';\n\nexport class BitLiteral extends AbstractLiteral {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() { return { type: 'bit_literal', as: '.' }; }\n\n    /* TYPESYS API */\n\n    dataType() { return registry.DataType.fromJSON({ value: 'BINARY' }); }\n}", "import { AbstractLiteral } from './AbstractLiteral.js';\nimport { registry } from '../../registry.js';\n\nexport class BoolLiteral extends AbstractLiteral {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() { return { type: 'bool_literal', as: '.' }; }\n\n    /* TYPESYS API */\n\n    dataType() { return registry.DataType.fromJSON({ value: 'BOOLEAN' }); }\n}", "import { AbstractLiteral } from './AbstractLiteral.js';\n\nexport class DefaultLiteral extends AbstractLiteral {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() { return { type: 'keyword', as: '.', value: 'DEFAULT' }; }\n}", "import { AbstractLiteral } from './AbstractLiteral.js';\nimport { registry } from '../../registry.js';\n\nexport class HexLiteral extends AbstractLiteral {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() { return { type: 'hex_literal', as: '.' }; }\n\n    /* TYPESYS API */\n\n    dataType() { return registry.DataType.fromJSON({ value: 'BINARY' }); }\n}", "import { AbstractLiteral } from './AbstractLiteral.js';\n\nexport class NullLiteral extends AbstractLiteral {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() { return { type: 'null_literal', as: '.' }; }\n}", "import { AbstractLiteral } from './AbstractLiteral.js';\nimport { registry } from '../../registry.js';\n\nexport class NumberLiteral extends AbstractLiteral {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() { return { type: 'number_literal', as: '.' }; }\n\n    /* TYPESYS API */\n\n    dataType() { return registry.DataType.fromJSON({ value: 'INT' }); }\n}", "import { AbstractLiteral } from './AbstractLiteral.js';\nimport { registry } from '../../registry.js';\n\nexport class StringLiteral extends AbstractLiteral {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() { return { type: 'string_literal', as: '.' }; }\n    \n    /* AST API */\n\n    qualifier() { return this._get('qualifier'); }\n\n    /* TYPESYS API */\n\n    dataType() { return registry.DataType.fromJSON({ value: 'TEXT' }); }\n}", "import { AbstractClassicExpr } from '../AbstractClassicExpr.js';\nimport { registry } from '../../registry.js';\n\nexport class TypedLiteral extends AbstractClassicExpr {\n\n\t/* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'data_type', as: 'data_type' },\n            { type: 'string_literal', as: 'value' },\n        ];\n    }\n\n    static get syntaxPriority() { return 50; }\n\n    /* AST API */\n\n    dataType() { return registry.DataType.fromJSON({ value: this._get('data_type') }); }\n\n    value() { return this._get('value'); }\n}", "import { TypedLiteral } from './TypedLiteral.js';\n\nexport class TypedDateLiteral extends TypedLiteral {\n\n\t/* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'data_type', as: 'data_type', value: 'DATE' },\n            { type: 'string_literal', as: 'value' },\n        ];\n    }\n}", "import { TypedLiteral } from './TypedLiteral.js';\n\nexport class TypedIntervalLiteral extends TypedLiteral {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'data_type', as: 'data_type', value: 'INTERVAL' },\n            {\n                syntaxes: [\n                    { type: 'string_literal', as: 'value' },\n                    { type: 'number_literal', as: 'value', dialect: 'mysql' },\n                ]\n            },\n            {\n                optional: true,\n                syntax: [\n                    { type: 'keyword', as: 'unit', value: ['YEAR', 'MONTH', 'DAY', 'HOUR', 'MINUTE', 'SECOND'] },\n                    {\n                        optional: true,\n                        syntax: [\n                            { type: 'keyword', value: 'TO' },\n                            { type: 'keyword', as: 'to_unit', value: ['YEAR', 'MONTH', 'DAY', 'HOUR', 'MINUTE', 'SECOND'], assert: true },\n                        ]\n                    },\n                ]\n            },\n        ];\n    }\n\n    /* AST API */\n\n    unit() { return this._get('unit'); }\n\n    toUnit() { return this._get('to_unit'); }\n\n    /**\n     * Parse a Postgres/MySQL-style INTERVAL literal into component parts.\n     * Returns an object like { years, months, days, hours, minutes, seconds }\n     */\n    parseInterval() {\n        const val = this._get('value');\n        if (!val) return {};\n\n        let str = '';\n        if (val.type === 'string_literal') {\n            str = val.value.toString().trim();\n        } else if (val.type === 'number_literal') {\n            // MySQL form: INTERVAL 3 HOUR\n            const num = val.value;\n            const unit = (this.unit() || '').toUpperCase();\n            return this.#unitToParts(num, unit);\n        }\n\n        const sign = str.startsWith('-') ? -1 : 1;\n        if (sign === -1) str = str.slice(1).trim();\n\n        const parts = { years: 0, months: 0, days: 0, hours: 0, minutes: 0, seconds: 0 };\n\n        const unit = this.unit() ? this.unit().toUpperCase() : null;\n        const toUnit = this.toUnit() ? this.toUnit().toUpperCase() : null;\n\n        // ----- Handle ranges -----\n        if (unit && toUnit) {\n            const range = `${unit} TO ${toUnit}`;\n\n            switch (range) {\n                case 'YEAR TO MONTH': {\n                    const [y, m] = str.split('-').map(Number);\n                    parts.years = y;\n                    parts.months = m;\n                    return this.#applySign(parts, sign);\n                }\n                case 'DAY TO HOUR': {\n                    const [d, h] = str.split(/\\s+/);\n                    parts.days = Number(d);\n                    parts.hours = Number(h);\n                    return this.#applySign(parts, sign);\n                }\n                case 'DAY TO MINUTE': {\n                    const [d, hm] = str.split(/\\s+/);\n                    parts.days = Number(d);\n                    const [h, m] = hm.split(':').map(Number);\n                    parts.hours = h;\n                    parts.minutes = m;\n                    return this.#applySign(parts, sign);\n                }\n                case 'DAY TO SECOND': {\n                    const [d, hms] = str.split(/\\s+/);\n                    parts.days = Number(d);\n                    const [h, m, s] = hms.split(':').map(Number);\n                    parts.hours = h;\n                    parts.minutes = m;\n                    parts.seconds = s;\n                    return this.#applySign(parts, sign);\n                }\n                case 'HOUR TO MINUTE': {\n                    const [h, m] = str.split(':').map(Number);\n                    parts.hours = h;\n                    parts.minutes = m;\n                    return this.#applySign(parts, sign);\n                }\n                case 'HOUR TO SECOND': {\n                    const [h, m, s] = str.split(':').map(Number);\n                    parts.hours = h;\n                    parts.minutes = m;\n                    parts.seconds = s;\n                    return this.#applySign(parts, sign);\n                }\n                case 'MINUTE TO SECOND': {\n                    const [m, s] = str.split(':').map(Number);\n                    parts.minutes = m;\n                    parts.seconds = s;\n                    return this.#applySign(parts, sign);\n                }\n            }\n        }\n\n        // ----- Fallback: general composite parsing -----\n        const tokens = str.split(/\\s+/);\n\n        for (let i = 0; i < tokens.length; i++) {\n            const token = tokens[i];\n\n            // Time literal HH:MM:SS(.FFF)\n            if (/^\\d{1,2}:\\d{1,2}(:\\d{1,2}(\\.\\d+)?)?$/.test(token)) {\n                const [h, m, s] = token.split(':').map(Number);\n                if (!isNaN(h)) parts.hours += h;\n                if (!isNaN(m)) parts.minutes += m;\n                if (!isNaN(s)) parts.seconds += s;\n                continue;\n            }\n\n            const num = parseFloat(token);\n            if (!isNaN(num)) {\n                const u = (tokens[i + 1] || '').toUpperCase();\n                if (u) {\n                    const mapped = this.#unitToParts(num, u);\n                    for (const [k, v] of Object.entries(mapped)) parts[k] += v;\n                    i++;\n                }\n            }\n        }\n\n        return this.#applySign(parts, sign);\n    }\n\n    #unitToParts(num, unit) {\n        const parts = {};\n        switch (unit) {\n            case 'YEAR': parts.years = num; break;\n            case 'MONTH': parts.months = num; break;\n            case 'DAY': parts.days = num; break;\n            case 'HOUR': parts.hours = num; break;\n            case 'MINUTE': parts.minutes = num; break;\n            case 'SECOND': parts.seconds = num; break;\n            default: break;\n        }\n        return parts;\n    }\n\n    #applySign(parts, sign) {\n        for (const k of Object.keys(parts)) {\n            parts[k] *= sign;\n        }\n        return parts;\n    }\n\n    /**\n     * Apply interval to a base date.\n     */\n    applyToDate(baseDate, dir = 'FOLLOWING') {\n        const parts = this.parseInterval();\n        const d = new Date(baseDate);\n        const sign = dir === 'FOLLOWING' ? 1 : -1;\n\n        if (parts.years) d.setFullYear(d.getFullYear() + sign * parts.years);\n        if (parts.months) d.setMonth(d.getMonth() + sign * parts.months);\n        if (parts.days) d.setDate(d.getDate() + sign * parts.days);\n        if (parts.hours) d.setHours(d.getHours() + sign * parts.hours);\n        if (parts.minutes) d.setMinutes(d.getMinutes() + sign * parts.minutes);\n        if (parts.seconds) d.setSeconds(d.getSeconds() + sign * parts.seconds);\n\n        return d.getTime();\n    }\n}", "import { TypedLiteral } from './TypedLiteral.js';\n\nexport class TypedTimeLiteral extends TypedLiteral {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'data_type', as: 'data_type', value: 'TIME' },\n            { type: 'string_literal', as: 'value' },\n            {\n                optional: true,\n                dialect: 'postgres',\n                syntax: [\n                    { type: 'keyword', as: 'pg_with_tz', value: ['WITH', 'WITHOUT'] },\n                    { type: 'keyword', value: 'TIME ZONE', assert: true },\n                ]\n            },\n        ];\n    }\n\n    /* AST API */\n\n    pgWithTZ() { return this._get('pg_with_tz'); }\n}", "import { TypedLiteral } from './TypedLiteral.js';\n\nexport class TypedTimestampLiteral extends TypedLiteral {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'data_type', as: 'data_type', value: 'TIMESTAMP', dialect: 'postgres' },\n            { type: 'data_type', as: 'data_type', value: ['TIMESTAMP', 'DATETIME'], dialect: 'mysql' },\n            { type: 'string_literal', as: 'value' },\n            {\n                optional: true,\n                dialect: 'postgres',\n                syntax: [\n                    { type: 'keyword', as: 'pg_with_tz', value: ['WITH', 'WITHOUT'] },\n                    { type: 'keyword', value: 'TIME ZONE', assert: true },\n                ]\n            }\n        ];\n    }\n\n    /* AST API */\n\n    pgWithTZ() { return this._get('pg_with_tz'); }\n}", "import { TypedLiteral } from './TypedLiteral.js';\nimport { registry } from '../../registry.js';\n\nexport class TypedTimeZoneLiteral extends TypedLiteral {\n\n\t/* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', value: 'TIME ZONE' },\n            { type: 'Expr', as: 'value' },\n        ];\n    }\n}", "import { AbstractLiteral } from './AbstractLiteral.js';\n\nexport class UnknownLiteral extends AbstractLiteral {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() { return { type: 'unknown_literal', as: '.' }; }\n }", "export const SugarMixin = Class => class extends Class {\n    get isSugar() { return true; }\n}", "import { SugarMixin } from '../../abstracts/SugarMixin.js';\nimport { TypeSysMixin } from '../../abstracts/TypeSysMixin.js';\nimport { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\nimport { registry } from '../../registry.js';\n\nexport class AbstractLQJsonLiteral extends SugarMixin(TypeSysMixin(AbstractNodeList)) {\n\n    dataType() { return registry.DataType.fromJSON({ value: 'JSON' }); }\n}", "import { AbstractLQJsonLiteral } from './AbstractLQJsonLiteral.js';\nimport { registry } from '../../registry.js';\n\nexport class LQArrayLiteral extends AbstractLQJsonLiteral {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return {\n            syntax: [\n                {\n                    type: 'bracket_block',\n                    syntax: { type: 'Expr', as: 'entries', arity: Infinity, itemSeparator, autoIndent: 2 },\n                },\n            ],\n        };\n    }\n\n    static morphsTo() { return registry.CallExpr; }\n\n    /* JSON API */\n\n    jsonfy(options = {}, transformer = null, schemaInference = null) {\n        let resultJson = super.jsonfy(options, transformer, schemaInference);\n        if (options.deSugar) {\n            const resultSchemas = [];\n\n            resultJson = {\n                nodeName: registry.CallExpr.NODE_NAME,\n                name: (options.toDialect || this.options.dialect) === 'mysql' ? 'JSON_ARRAY' : 'JSON_BUILD_ARRAY',\n                arguments: resultJson.entries.map((e, i) => {\n\n                    let resultSchema = e.result_schema;\n                    const namespaceIdent = { value: i, nodeName: registry.Identifier.NODE_NAME };\n\n                    if (resultSchema instanceof registry.ColumnSchema) {\n                        resultSchema = resultSchema.clone({ renameTo: namespaceIdent });\n                    } else {\n                        resultSchema = registry.ColumnSchema.fromJSON({\n                            name: namespaceIdent,\n                            data_type: this.entries()[i].dataType().jsonfy(),\n                        });\n                    }\n                    resultSchemas.push(resultSchema);\n\n                    return e;\n                }),\n                result_schema: registry.JSONSchema.fromJSON({ entries: resultSchemas }, { assert: true })\n            };\n        }\n\n        return resultJson;\n    }\n}", "import { AbstractLQJsonLiteral } from './AbstractLQJsonLiteral.js';\nimport { registry } from '../../registry.js';\nimport { _eq } from '../../abstracts/util.js';\n\nexport class LQObjectLiteral extends AbstractLQJsonLiteral {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return {\n            syntax: [\n                {\n                    type: 'brace_block',\n                    syntax: { type: 'LQObjectProperty', as: 'entries', arity: Infinity, itemSeparator, autoIndent: 3 },\n                },\n            ],\n        };\n    }\n\n    static morphsTo() { return registry.CallExpr; }\n\n    /* JSON API */\n\n    jsonfy(options = {}, transformer = null, schemaInference = null) {\n        let resultJson = super.jsonfy(options, transformer, schemaInference);\n        if (options.deSugar) {\n\n            const entries = resultJson.entries.reduce((result, propertyJson) => {\n                if (propertyJson.star_ref) {\n                    for (const ref of propertyJson.star_ref.result_schema) {\n                        const newPropertyJson = {\n                            key: { value: ref.value(), delim: ref._get('delim') },\n                            value: ref.jsonfy(),\n                        };\n                        result = result.reduce((result, existing) => {\n                            if (_eq(newPropertyJson.key.value, existing.key.value, newPropertyJson.key.delim || existing.key.delim)) {\n                                return result;\n                            }\n                            return result.concat(existing);\n                        }, []);\n                        result = result.concat(newPropertyJson);\n                    }\n                    return result;\n                }\n                return result.concat(propertyJson);\n            }, []);\n\n            const resultSchemas = [];\n\n            resultJson = {\n                nodeName: registry.CallExpr.NODE_NAME,\n                name: (options.toDialect || this.options.dialect) === 'mysql' ? 'JSON_OBJECT' : 'JSON_BUILD_OBJECT',\n                arguments: entries.reduce((args, propertyJson, i) => {\n\n                    let resultSchema = propertyJson.value.result_schema;\n                    const namespaceIdent = { ...propertyJson.key, nodeName: registry.Identifier.NODE_NAME };\n\n                    if (resultSchema instanceof registry.ColumnSchema) {\n                        resultSchema = resultSchema.clone({ renameTo: namespaceIdent });\n                    } else {\n                        resultSchema = registry.ColumnSchema.fromJSON({\n                            name: namespaceIdent,\n                            data_type: this.entries()[i].value()?.dataType().jsonfy() || { nodeName: registry.DataType.NODE_NAME, value: 'TEXT' },\n                        });\n                    }\n                    \n                    resultSchemas.push(resultSchema);\n\n                    return args.concat(\n                        { ...propertyJson.key, nodeName: registry.StringLiteral.NODE_NAME },\n                        { ...propertyJson.value }\n                    );\n\n                }, []),\n                result_schema: registry.JSONSchema.fromJSON({ entries: resultSchemas }, { assert: true })\n            };\n        }\n\n        return resultJson;\n    }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\nimport { registry } from '../../registry.js';\n\nexport class LQObjectProperty extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            syntaxes: [\n                { type: 'ColumnRef0', as: 'star_ref' },\n                [\n                    { type: 'SelectItemAlias', as: 'key' },\n                    {\n                        optional: true,\n                        syntax: [\n                            { type: 'punctuation', value: ':' },\n                            { type: 'Expr', as: 'value', assert: true },\n                        ],\n                        autoSpacing: false,\n                    },\n                ]\n            ]\n        };\n    }\n\n    static get syntaxPriority() { return -1; }\n\n    get isProperty() { return true; }\n\n    /* AST API */\n\n    starRef() { return this._get('star_ref'); }\n\n    key() { return this._get('key'); }\n\n    value() { return this._get('value'); }\n\n    /* DESUGARING API */\n\n    jsonfy(options = {}, transformer = null, schemaInference = null) {\n        if (options.deSugar && !this.starRef()) {\n\n            const keyNode = this.key();\n            let asAggr, keyJson = transformer\n                ? transformer.transform(keyNode, ($options = options) => keyNode.jsonfy($options), 'key', options)\n                : keyNode.jsonfy(options);\n            if (keyJson.is_aggr) ({ is_aggr: asAggr, ...keyJson } = keyJson);\n\n            let valueNode = this.value();\n            if (!valueNode) {\n                valueNode = registry.ColumnRef1.fromJSON({ ...keyJson, nodeName: undefined });\n                this._adoptNodes(valueNode);\n            }\n\n            let defaultTransform;\n\n            if (asAggr && !(valueNode instanceof registry.LQDeepRef1)) {\n                // Note the below where we wrap value in an aggr call\n                defaultTransform = ($options = options, childTransformer = transformer) => ({\n                    nodeName: registry.AggrCallExpr.NODE_NAME,\n                    name: (options.toDialect || this.options.dialect) === 'mysql' ? 'JSON_ARRAYAGG' : 'JSON_AGG',\n                    arguments: [valueNode.jsonfy($options, childTransformer, schemaInference)],\n                });\n            } else {\n                // Note the below where we derive value, if not specified, from key\n                defaultTransform = ($options = options, childTransformer = transformer) => {\n                    return valueNode.jsonfy($options, childTransformer, schemaInference);\n                };\n            }\n\n            const valueJson = transformer\n                ? transformer.transform(valueNode, defaultTransform, 'value', { ...options, asAggr })\n                : defaultTransform();\n\n            // plus, we'll drop the is_aggr flag\n            return {\n                nodeName: LQObjectProperty.NODE_NAME,\n                key: keyJson,\n                value: valueJson\n            };\n        }\n        return super.jsonfy(options, transformer, schemaInference);\n    }\n}", "import { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\nimport { registry } from '../../registry.js';\n\nexport class PGTypedArrayLiteral extends AbstractNodeList {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return {\n            dialect: 'postgres',\n            syntax: [\n                { type: 'keyword', value: 'ARRAY' },\n                {\n                    type: 'bracket_block',\n                    syntax: { type: 'Expr', as: 'entries', arity: Infinity, itemSeparator, autoIndent: 2 },\n                    autoSpacing: false,\n                },\n            ],\n        };\n    }\n\n    static morphsTo() { return registry.CallExpr; }\n\n    /* TYPESYS API */\n\n    dataType() { return registry.DataType.fromJSON({ value: 'JSON' }); }\n\n    /* JSON API */\n\n    jsonfy(options = {}, transformer = null, schemaInference = null) {\n        let resultJson = super.jsonfy(options, transformer, schemaInference);\n        if ((options.toDialect || this.options.dialect) === 'mysql') {\n            resultJson = {\n                nodeName: registry.CallExpr.NODE_NAME,\n                name: 'JSON_ARRAY',\n                arguments: resultJson.entries,\n            };\n        }\n        return resultJson;\n    }\n}", "import { BinaryExpr } from './BinaryExpr.js';\nimport { registry } from '../../registry.js';\n\nexport class AtTimeZoneExpr extends BinaryExpr {\n\n    /* DEFS */\n\n    static get syntaxRules() {\n        return [\n            { type: 'Expr', as: 'left', peek: [1, 'operator', 'AT'] },\n            { type: 'operator', as: 'operator', value: 'AT' },\n            {\n                syntaxes: [\n                    { type: 'TypedTimeZoneLiteral', as: 'right' },\n                    { type: 'keyword', as: 'right', value: 'LOCAL' }\n                ]\n            }\n        ];\n    }\n\n    static get syntaxPriority() { return 0; }\n\n    /* AST API */\n\n    left() { return this._get('left'); }\n\n    right() { return this._get('right'); }\n\n    /* TYPESYS API */\n\n    dataType() { return registry.DataType.fromJSON({ value: 'TIME ZONE' }); }\n}", "import { BinaryExpr } from './BinaryExpr.js';\n\nexport class BetweenExpr extends BinaryExpr {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'operator', value: 'AND' };\n        return [\n            { type: 'Expr', as: 'left', peek: [1, 'operator', ['NOT', 'BETWEEN']] },\n            { type: 'operator', as: 'negation', value: 'NOT', booleanfy: true, optional: true },\n            { type: 'operator', as: 'operator', value: 'BETWEEN' },\n            { type: 'Expr', as: 'right', arity: { min: 2, max: 2, eager: false }, itemSeparator, assert: true },\n        ];\n    }\n}", "import { BinaryExpr } from './BinaryExpr.js';\n\nexport class DistinctFromExpr extends BinaryExpr {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'Expr', as: 'left', peek: [1, 'operator', ['IS', 'IS NOT']] },\n            { type: 'operator', as: 'logic', value: ['IS', 'IS NOT'] },\n            { type: 'operator', as: 'operator', value: 'DISTINCT FROM' },\n            { type: 'Expr', as: 'right', assert: true },\n        ];\n    }\n\n    /* AST API */\n\n    logic() { return this._get('logic'); }\n}", "import { BinaryExpr } from './BinaryExpr.js';\n\nexport class InExpr extends BinaryExpr {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'Expr', as: 'left', peek: [1, 'operator', ['NOT', 'IN']] },\n            { type: 'operator', as: 'negation', value: 'NOT', booleanfy: true, optional: true },\n            { type: 'operator', as: 'operator', value: 'IN' },\n            { type: ['DerivedQuery', 'RowConstructor', 'TypedRowConstructor'], as: 'right', assert: true },\n        ];\n    }\n}", "import { BinaryExpr } from './BinaryExpr.js';\n\nexport class PGCastExpr2 extends BinaryExpr {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            dialect: 'postgres',\n            syntax: [\n                { type: 'Expr', as: 'left', peek: [1, 'operator', '::'] },\n                { type: 'operator', as: 'operator', value: '::', autoSpacing: false },\n                { type: 'DataType', as: 'right', assert: true, autoSpacing: false },\n            ]\n        };\n    }\n\n    /* TYPESYS API */\n\n    expr() { return this.left(); }\n\n    dataType() { return this.right(); }\n}", "import { AbstractClassicExpr } from '../AbstractClassicExpr.js';\nimport { registry } from '../../registry.js';\n\nexport class UnaryExpr extends AbstractClassicExpr {\n\n    /* DEFS */\n\n    static get syntaxRules() {\n        return [\n            { type: 'operator', as: 'operator', value: ['-', '+', 'NOT'] },\n            { type: 'Expr', as: 'operand', autoSpacing: ['NOT'] },\n        ];\n    }\n\n    static get syntaxPriority() { return 1;/* higher than BinaryExpr */ }\n\n    /* AST API */\n\n    operator() { return this._get('operator'); }\n\n    operand() { return this._get('operand'); }\n\n    /* TYPESYS API */\n\n    dataType() {\n        const operator = this.operator();\n        if (!operator) return super.dataType();\n        return registry.DataType.fromJSON({ value: operator === 'NOT' ? 'BOOLEAN' : 'NUMBER' });\n    }\n}", "export class ErrorRefUnknown extends Error {}", "export class ErrorRefAmbiguous extends Error {}", "import { ErrorRefUnknown } from './ErrorRefUnknown.js';\nimport { ErrorRefAmbiguous } from './ErrorRefAmbiguous.js';\nimport { AbstractNode } from '../../../abstracts/AbstractNode.js';\nimport { ResultSchemaMixin } from '../../../abstracts/ResultSchemaMixin.js';\nimport { TypeSysMixin } from '../../../abstracts/TypeSysMixin.js';\nimport { Identifier } from '../Identifier.js';\n\nexport class AbstractClassicRef extends ResultSchemaMixin(TypeSysMixin(Identifier)) {\n\n    #resolution;\n\n    resolution() { return this.#resolution; }\n\n    lookup(transformer, schemaInference) { return []; }\n\n    resolve(transformer, schemaInference) {\n        const resultSet = this.lookup(null, transformer, schemaInference) || [];\n        const objectType = this.constructor.name.match(/namespace/i) ? 'Namespace' : (this.constructor.name.match(/table/i) ? 'Table' : 'Column');\n        if (resultSet.length > 1) {\n            throw new ErrorRefAmbiguous(`[${this.parentNode?.parentNode || this.parentNode || this}] ${objectType} ${this} is ambiguous. (Is it ${resultSet.join(' or ')}?)`);\n        } else if (!resultSet.length) {\n            throw new ErrorRefUnknown(`[${this.parentNode?.parentNode || this.parentNode || this}] ${objectType} ${this} does not exist.`);\n        }\n        return resultSet[0];\n    }\n\n\tstatic fromJSON(inputJson, options = {}, callback = null) {\n\t\tif (!inputJson || inputJson instanceof AbstractNode) {\n\t\t\treturn super.fromJSON(inputJson, options, callback);\n\t\t}\n\t\tconst { resolution, ...restJson } = inputJson;\n\t\tconst instance = super.fromJSON(restJson, options, callback);\n\t\tif (instance && resolution) {\n\t\t\tif (typeof resolution !== 'string') {\n\t\t\t\tthrow new Error(`Invalid \"resolution\" hint passed at inputJson.resolution`);\n\t\t\t}\n\t\t\tinstance.#resolution = resolution;\n\t\t}\n\t\treturn instance;\n\t}\n\n\tjsonfy(options = {}, transformer = null, schemaInference = null) {\n\t\tlet resultJson = super.jsonfy(options, transformer, schemaInference);\n\t\tif (this.#resolution) {\n\t\t\tresultJson = {\n\t\t\t\t...resultJson,\n\t\t\t\tresolution: this.#resolution,\n\t\t\t};\n\t\t}\n\t\treturn resultJson;\n\t}\n}", "import { AbstractClassicRef } from './abstracts/AbstractClassicRef.js';\nimport { AbstractNode } from '../../abstracts/AbstractNode.js';\nimport { PathMixin } from '../../abstracts/PathMixin.js';\nimport { registry } from '../../registry.js';\n\nexport class ColumnRef1 extends PathMixin(AbstractClassicRef) {\n\n    /* SYNTAX RULES */\n\n    static get _qualifierType() {\n        return [\n            'TableRef1'/* must come first being primary */,\n            'LQBackRefAbstraction'\n        ];\n    }\n\n    static get syntaxRules() {\n        return this.buildSyntaxRules({ type: 'identifier', as: '.', autoSpacing: false });\n    }\n\n    static get syntaxPriority() { return 51; } // above LQBackRefAbstraction\n\n    static morphsTo() { return registry.ColumnRef2; }\n\n    /* API */\n\n    dataType() { return this.resultSchema()?.dataType() || super.dataType(); }\n\n    // ----------------\n\n    canReferenceOutputColumns() {\n        return this.climbTree((parentNode, up) => {\n            if (parentNode instanceof registry.SelectStmt) return false;\n            if (parentNode instanceof registry.GroupByClause) return parentNode;\n            if (parentNode instanceof registry.HavingClause) return parentNode;\n            if (parentNode instanceof registry.OrderByClause) return parentNode;\n            return up();\n        });\n    }\n\n    lookup(deepMatchCallback = null, transformer = null, schemaInference = null) {\n        if (!transformer && !schemaInference) return [];\n\n        const name = this._get('value');\n        const inGrepMode = (!name || name === '*') && !deepMatchCallback;\n        let resultSet = [];\n\n        const resolve = (columnSchema, qualifierJson = undefined, resolution = 'default') => {\n\n            if (!(columnSchema instanceof registry.ColumnSchema)) return false;\n            if (name && name !== '*' && !columnSchema.identifiesAs(this)) return false;\n\n            let result;\n            if (deepMatchCallback && !(result = deepMatchCallback(columnSchema, qualifierJson, resolution))) return false;\n            if (result instanceof AbstractNode || Array.isArray(result)) return result;\n\n            const resultSchema = columnSchema.clone({ normalized: true });\n            columnSchema.parentNode?._adoptNodes(resultSchema);\n\n            const resolvedColumnRef1 = ColumnRef1.fromJSON({\n                ...columnSchema.name().jsonfy({ nodeNames: false }),\n                resolution,\n                qualifier: qualifierJson,\n                result_schema: resultSchema,\n            });\n            this.parentNode._adoptNodes(resolvedColumnRef1);\n\n            return resolvedColumnRef1;\n        };\n\n        // 1. Resolve system refs statically\n        const systemColumns = (this.options.dialect || 'postgres') === 'postgres'\n            ? ['CTID', 'OID', 'XMIN', 'XMAX', 'TABLEOID']\n            : [];\n        if (systemColumns.includes(name?.toUpperCase())) {\n            const columnSchema = registry.ColumnSchema.fromJSON({\n                name: { nodeName: registry.Identifier.NODE_NAME, value: name },\n                data_type: { nodeName: registry.DataType.NODE_NAME, value: 'INT' },\n            }, { assert: true });\n            return [].concat(resolve(columnSchema, undefined, 'system') || []);\n        }\n\n        // 2. Resolve from outputSchemas first?\n        if (this.canReferenceOutputColumns() && transformer) {\n            // Resolve from outputSchemas first\n            let statementContext = transformer.statementContext\n            for (const columnSchema of statementContext.artifacts.get('outputSchemas')) {\n                resultSet = resultSet.concat(resolve(columnSchema, undefined, 'scope') || []);\n                if (!inGrepMode && resultSet.length) break; // Matching current instance only\n            }\n        }\n\n        // 3. Resolve normally\n        if (inGrepMode || !resultSet.length) {\n            // Resolve normally\n            const tempTableRef = new registry.TableRef1(this.qualifier()?.jsonfy() || {});\n            this._adoptNodes(tempTableRef);\n            resultSet = resultSet.concat(tempTableRef.lookup(\n                (tableSchema, qualifierJson = undefined, resolution = undefined) => {\n\n                    return tableSchema._get('entries').reduce((prev, columnSchema) => {\n                        if (tableSchema instanceof registry.JSONSchema) {\n                            // An unaliased derived query\n                            return prev.concat(resolve(columnSchema) || []);\n                        }\n                        const newQualifierJson = {\n                            ...tableSchema.name().jsonfy({ nodeNames: false }),\n                            resolution,\n                            qualifier: qualifierJson,\n                            result_schema: tableSchema,\n                        };\n                        return prev.concat(resolve(columnSchema, newQualifierJson) || []);\n                    }, []);\n\n                },\n                transformer,\n                schemaInference,\n            ));\n        }\n\n        if (name === '*') {\n            const compositeResult = registry.ColumnRef0.fromJSON({\n                value: this.value(),\n                result_schema: registry.JSONSchema.fromJSON({ entries: resultSet.map((s) => s.clone()) }, { assert: true }),\n            });\n            this.parentNode._adoptNodes(compositeResult);\n            resultSet = [compositeResult];\n        }\n\n        return resultSet;\n    }\n\n    jsonfy({ toKind = 1, ...options } = {}, transformer = null, schemaInference = null) {\n        let resultJson;\n        if (options.deSugar && (\n            ((options.deSugar === true || options.deSugar.columnQualifiers) && !this.qualifier())\n            || !this.resultSchema()\n        ) && (transformer || schemaInference)) {\n            // Column qualification or schema resolution...\n            const resolved = this.resolve(transformer, schemaInference);\n            if (resolved.value?.() !== this.value()) {\n                // Resolved from scope\n                return resolved.jsonfy();\n            }\n            resultJson = resolved.jsonfy(/* IMPORTANT */);\n            // Case normalization...\n            if ((options.deSugar === true || options.deSugar.normalizeCasing) && !resultJson.delim) {\n                resultJson = { ...resultJson, value: resultJson.resolution === 'system' ? resultJson.value.toUpperCase() : resultJson.value.toLowerCase() };\n            }\n            // Drop qualifier...\n            if (!(options.deSugar === true || options.deSugar.columnQualifiers) && !this.qualifier()) {\n                resultJson = { ...resultJson, qualifier: undefined };\n            }\n        } else {\n            resultJson = super.jsonfy(options, transformer, schemaInference);\n            if (toKind === 2) {\n                resultJson = {\n                    ...resultJson,\n                    nodeName: registry.ColumnRef2.NODE_NAME,\n                };\n                delete resultJson.qualifier;\n            }\n        }\n        return resultJson;\n    }\n}", "import { ColumnRef1 } from './ColumnRef1.js';\nimport { registry } from '../../registry.js';\n\nexport class ColumnRef0 extends ColumnRef1 {\n\n    /* SYNTAX RULES */\n\n    static get _qualifierType() { return ['TableRef1']; }\n\n    static get syntaxRules() {\n        return this.buildSyntaxRules({ type: 'operator', as: '.', value: '*', autoSpacing: false });\n    }\n\n    static get syntaxPriority() { return -1; }\n\n    /* API */\n\n    dataType() { return registry.DataType.fromJSON({ value: 'SET' }); }\n}", "export class ErrorFKInvalid extends Error {\n\n    constructor(message) {\n        super(message);\n        this.name = 'ErrorFKInvalid';\n    }\n\n}", "import { ErrorFKInvalid } from './ErrorFKInvalid.js';\nimport { SugarMixin } from '../../../abstracts/SugarMixin.js';\nimport { BinaryExpr } from '../../op/BinaryExpr.js';\n\nexport class AbstractMagicRef extends SugarMixin(BinaryExpr) {\n\n    rhsTable(transformer, schemaInference) {\n        const resolveOperand = this.operand()?.resolve(transformer, schemaInference);\n        const fk = resolveOperand.resultSchema()/* ColumnSchema */?.fkConstraint(true);\n        if (!fk) {\n            throw new ErrorFKInvalid(`[${this.parentNode || this}] Column ${this.operand()} is not a foreign key.`);\n        }\n        return fk.targetTable()?.resolve(null/*transformer*/, schemaInference);\n    }\n\n\trhsSchema(transformer, schemaInference) { return this.rhsTable(transformer, schemaInference)?.resultSchema(); }\n}", "import { AbstractClassicRef } from './abstracts/AbstractClassicRef.js';\nimport { AbstractMagicRef } from './abstracts/AbstractMagicRef.js';\nimport { AbstractNode } from '../../abstracts/AbstractNode.js';\nimport { registry } from '../../registry.js';\n\nexport class ColumnRef2 extends AbstractClassicRef {\n\n    /* SYNTAX RULES */\n\n    static get syntaxPriority() { return -1; }\n\n    static morphsTo() { return registry.ColumnRef1; }\n\n    /* SCHEMA API */\n\n    dataType() { return this.resultSchema()?.dataType() || super.dataType(); }\n\n    lookup(deepMatchCallback, transformer = null, schemaInference = null) {\n        if (!transformer && !schemaInference) return [];\n\n        const name = this._get('value');\n        const inGrepMode = !name && !deepMatchCallback;\n        let resultSet = [];\n\n        const resolve = (columnSchema) => {\n            if (!(columnSchema instanceof registry.ColumnSchema)) return false;\n            if (name && !columnSchema.identifiesAs(this)) return false;\n            let result;\n            if (deepMatchCallback && !(result = deepMatchCallback(columnSchema))) return false;\n            if (result instanceof AbstractNode || Array.isArray(result)) return result;\n\n            const resultSchema = columnSchema.clone({ normalized: true });\n            columnSchema.parentNode._adoptNodes(resultSchema);\n\n            const resolvedColumnRef2 = ColumnRef2.fromJSON({\n                ...columnSchema.name().jsonfy({ nodeNames: false }),\n                result_schema: resultSchema\n            });\n            this.parentNode._adoptNodes(resolvedColumnRef2);\n\n            return resolvedColumnRef2;\n        };\n\n        let tableSchemasInScope;\n        if (this.parentNode instanceof AbstractMagicRef) {\n            if (this === this.parentNode.operand()) {\n                tableSchemasInScope = [this.parentNode.parentNode.rhsSchema(transformer, schemaInference)];\n            } else {\n                tableSchemasInScope = [this.parentNode.rhsSchema(transformer, schemaInference)];\n            }\n        } else {\n            tableSchemasInScope = this.climbTree((superParentNode, up) => {\n                if (superParentNode instanceof registry.InsertStmt || superParentNode instanceof registry.UpdateStmt) {\n                    let tableSchemas = [...transformer.statementContext.artifacts.get('tableSchemas')].map((t) => t.resultSchema);\n                    // For UPDATEs, and of cos INSERTs, postgres target columns are resolved from just the target table\n                    if (this.options.dialect !== 'mysql') {\n                        tableSchemas = tableSchemas.slice(0, 1);\n                    }\n                    return tableSchemas;\n                }\n                if (superParentNode instanceof registry.TableSchema) {\n                    return [superParentNode];\n                }\n                return up();\n            });\n        }\n\n        outer: for (const tableSchema of tableSchemasInScope || []) {\n            for (const columnSchema of tableSchema) {\n                resultSet = resultSet.concat(resolve(columnSchema) || []);\n                if (!inGrepMode && resultSet.length) break outer; // Matching current instance only\n            }\n        }\n\n        return resultSet;\n    }\n\n    jsonfy({ toKind = 2, ...options } = {}, transformer = null, schemaInference = null) {\n        if (options.deSugar\n            && !this.resultSchema()\n            && (transformer || schemaInference)) {\n            return this.resolve(transformer, schemaInference).jsonfy(/* IMPORTANT */);\n        }\n        let resultJson = super.jsonfy(options, transformer, schemaInference);\n        if (toKind === 1) {\n            resultJson = {\n                ...resultJson,\n                nodeName: registry.ColumnRef1.NODE_NAME,\n            };\n            delete resultJson.qualifier; // by LQ_BACK_REF_ENDPOINT\n        }\n        return resultJson;\n    }\n}", "import { AbstractMagicRef } from './abstracts/AbstractMagicRef.js';\nimport { registry } from '../../registry.js';\n\nexport class LQBackBackRef extends AbstractMagicRef {\n\n\t/* SYNTAX RULES */\n\n\tstatic get _leftType() {\n\t\treturn [\n\t\t\t'LQBackRefEndpoint'/* must come first to prevent left-recursion */,\n\t\t\t'LQBackBackRef'\n\t\t];\n\t} // for inheritance\n\n\tstatic get syntaxRules() {\n\t\treturn [\n\t\t\t{ type: this._leftType, as: 'left', peek: [1, 'operator', '<~'] },\n\t\t\t{ type: 'operator', value: '<~' },\n\t\t\t{ type: 'ColumnRef2', as: 'right', peek: [1, 'operator', '<~'] },\n\t\t];\n\t}\n\n\tstatic get syntaxPriority() { return 1; }\n\n\tstatic morphsTo() { return [registry.LQDeepRef1, registry.LQDeepRef2, registry.LQDeepDeepRef1, registry.LQDeepDeepRef2]; }\n\n\t/* API */\n\n\toperand() { return this.right(); }\n\n\tendpoint() { return this.left() instanceof LQBackBackRef ? this.left().endpoint() : this.left(); }\n\n\t/* JSON API */\n\n\tjsonfy({ reverseRef = false, toKind = 1, ...options } = {}, transformer = null, schemaInference = null) {\n\t\tif (reverseRef) {\n\t\t\treturn {\n\t\t\t\tnodeName: toKind === 2 \n\t\t\t\t\t? (reverseRef === Infinity ? registry.LQDeepDeepRef2.NODE_NAME : registry.LQDeepRef2.NODE_NAME)\n\t\t\t\t\t: (reverseRef === Infinity ? registry.LQDeepDeepRef1.NODE_NAME : registry.LQDeepRef1.NODE_NAME),\n\t\t\t\tleft: this.right().jsonfy({ toKind: reverseRef !== Infinity ? 1 : 2, ...options }),\n\t\t\t\tright: this.left() instanceof registry.LQBackRefEndpoint\n\t\t\t\t\t? { nodeName: registry.ColumnRef2.NODE_NAME, value: this.left().value(), delim: this.left()._get('delim') }\n\t\t\t\t\t: this.left().jsonfy({ reverseRef: Infinity, toKind, ...options }),\n\t\t\t};\n\t\t}\n\t\treturn super.jsonfy(options, transformer, schemaInference);\n\t}\n}", "import { LQBackBackRef } from './LQBackBackRef.js';\nimport { ErrorFKInvalid } from './abstracts/ErrorFKInvalid.js';\nimport { ErrorRefAmbiguous } from './abstracts/ErrorRefAmbiguous.js';\nimport { ErrorRefUnknown } from './abstracts/ErrorRefUnknown.js';\nimport { registry } from '../../registry.js';\n\nexport class LQBackRef extends LQBackBackRef {\n\n\t/* SYNTAX RULES */\n\n\tstatic get syntaxRules() {\n\t\treturn [\n\t\t\t{ type: this._leftType, as: 'left', peek: [1, 'operator', '<~'] },\n\t\t\t{ type: 'operator', value: '<~' },\n\t\t\t{ type: 'TableRef2', as: 'right' }\n\t\t];\n\t}\n\n\tstatic get syntaxPriority() { return 0; }\n\n\t/* SCHEMA API */\n\n\trhsTable(transformer, schemaInference) {\n\t\tif (!schemaInference) return;\n\t\tconst tableRefs = this.right()?.lookup(null, null/*transformer*/, schemaInference) || [];\n\t\tif (!tableRefs.length) {\n\t\t\tthrow new ErrorRefUnknown(`[${this.parentNode || this}] Implied RHS table ${this.right()} does not exist.`);\n\t\t}\n\t\treturn tableRefs[0];\n\t}\n\n\tresolve(transformer, schemaInference, toKind = 1) {\n\t\tif (!transformer || !schemaInference) return;\n\t\tconst left = this.left();\n\n\t\tconst qualifiedLeftEndpoint = left instanceof LQBackBackRef\n\t\t\t? left.endpoint()\n\t\t\t: left;\n\t\tconst leftEndpointQualifier = qualifiedLeftEndpoint.qualifier();\n\n\t\tconst unqualifiedLeftEndpoint = registry.ColumnRef2.fromJSON({\n\t\t\t...qualifiedLeftEndpoint.jsonfy({ nodeNames: false }),\n\t\t\tqualifier: undefined\n\t\t});\n\n\t\tconst resolvedLeftEndpoint = qualifiedLeftEndpoint/* original */.resolve(transformer, schemaInference);\n\n\t\tconst leftFk = resolvedLeftEndpoint.resultSchema()/* ColumnSchema */.fkConstraint(true);\n\t\tif (!leftFk) throw new ErrorFKInvalid(`[${this.parentNode || this}] Endpoint column ${unqualifiedLeftEndpoint} is not a foreign key.`);\n\t\tconst leftEndpointTable = leftFk.targetTable();\n\n\t\tlet qualifiedLeftOperand;\n\t\tconst resolve = (ddlName, tableSchema) => {\n\t\t\tconst pkColumnRef2 = tableSchema.pkConstraint(true)?.columns()[0]?.resolve(transformer, schemaInference);\n\t\t\tif (!pkColumnRef2) throw new ErrorFKInvalid(`[${this.parentNode || this}] The referenced LHS table ${ddlName} does not have a primary key.`);\n\n\t\t\tconst $qualifiedLeftOperand = registry.ColumnRef1.fromJSON({\n\t\t\t\tqualifier: { ...tableSchema.name().jsonfy({ nodeNames: false }), result_schema: tableSchema },\n\t\t\t\tvalue: pkColumnRef2.value(),\n\t\t\t\tdelim: pkColumnRef2._get('delim'),\n\t\t\t\tresult_schema: pkColumnRef2.resultSchema()\n\t\t\t});\n\n\t\t\tif (qualifiedLeftOperand) throw new ErrorRefAmbiguous(`[${this.parentNode || this}]: The referenced endpoint for foreign key ${unqualifiedLeftEndpoint} is ambiguous. (Is it ${qualifiedLeftOperand} or ${$qualifiedLeftOperand}?)`);\n\t\t\tqualifiedLeftOperand = $qualifiedLeftOperand;\n\t\t};\n\n\t\tlet statementContext = transformer.statementContext\n\t\touter: do {\n\t\t\tfor (const { type, resultSchema: tableSchema } of statementContext.artifacts.get('tableSchemas')) {\n\t\t\t\tif (type === 'CTEItem') continue;\n\t\t\t\tconst ddlName = tableSchema._get('ddl_name') || tableSchema.name(); // Must match leftEndpointTable\n\t\t\t\tif (leftEndpointQualifier) {\n\t\t\t\t\tif (!tableSchema.identifiesAs(leftEndpointQualifier)) continue;\n\t\t\t\t\tif (!leftEndpointTable.identifiesAs(ddlName)) {\n\t\t\t\t\t\tthrow new ErrorFKInvalid(`[${this.parentNode || this}] The endpoint table implied by ${leftEndpointQualifier} (${ddlName}) is not the actual target (${leftEndpointTable}) of the foreign key column ${unqualifiedLeftEndpoint}.`);\n\t\t\t\t\t}\n\t\t\t\t\tresolve(ddlName, tableSchema);\n\t\t\t\t\tbreak outer;\n\t\t\t\t} else if (leftEndpointTable.identifiesAs(ddlName)) {\n\t\t\t\t\tresolve(ddlName, tableSchema);\n\t\t\t\t}\n\t\t\t}\n\t\t} while (!qualifiedLeftOperand && (statementContext = statementContext.parentTransformer?.statementContext))\n\n\t\tif (!qualifiedLeftOperand) {\n\t\t\tthrow new ErrorRefUnknown(`[${this.parentNode || this}] Ref does not correlate with current query.`);\n\t\t}\n\n\t\tconst qualifiedRightTable = this.rhsTable(transformer, schemaInference);\n\t\tconst unqualifiedRightOperand = left instanceof LQBackBackRef\n\t\t\t? left.clone({ reverseRef: true, toKind })\n\t\t\t: unqualifiedLeftEndpoint.constructor.fromJSON({\n\t\t\t\t...unqualifiedLeftEndpoint.jsonfy(),\n\t\t\t\tresult_schema: qualifiedRightTable.resultSchema()._get('entries', unqualifiedLeftEndpoint)\n\t\t\t});\n\n\t\treturn {\n\t\t\tlhsOperand: qualifiedLeftOperand, // ColumnRef1\n\t\t\trhsOperand: unqualifiedRightOperand.clone({ toKind }), // ColumnRef2\n\t\t\trhsTable: qualifiedRightTable, // TableRef2\n\t\t};\n\t}\n}\n", "import { ParenExpr } from '../abstraction/ParenExpr.js';\n\nexport class LQBackRefAbstraction extends ParenExpr {\n\n\t/* SYNTAX RULES */\n\n\tstatic get syntaxRules() {\n\t\treturn {\n\t\t\ttype: 'paren_block',\n\t\t\tsyntaxes: [\n\t\t\t\t{ type: 'Expr', as: 'expr', peek: [1, 'operator', '<~'] }, // (fk <~ fk2 <~ tbl)\n\t\t\t\t{ type: 'Expr', as: 'expr', peek: [2, 'operator', '<~'] }, // ((alias) fk <~ fk2 <~ tbl)\n\t\t\t],\n\t\t};\n\t}\n\n\tstatic get syntaxPriority() { return 51; } // Above RowConstructor\n\n\t/* AST API */\n\n\texpr() { return this._get('expr'); }\n}", "import { ColumnRef2 } from './ColumnRef2.js';\n\nexport class LQBackRefEndpoint extends ColumnRef2 {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n\t\t\t{\n\t\t\t\toptional: true,\n                type: 'paren_block',\n\t\t\t\tsyntax: { type: 'Identifier', as: 'qualifier' },\n\t\t\t},\n\t\t\t{ ...[].concat(super.syntaxRules)[0], peek: [1, 'operator', '<~'] },\n\t\t];\n    }\n\n    static get syntaxPriority() { return 52; } // Above ColumnRef1\n\n    static morphsTo() { return ColumnRef2; }\n    \n    /* API */\n\n    qualifier() { return this._get('qualifier'); }\n}", "import { AbstractMagicRef } from './abstracts/AbstractMagicRef.js';\nimport { registry } from '../../registry.js';\n\nexport class LQDeepDeepRef1 extends AbstractMagicRef {\n\n\t/* SYNTAX RULES */\n\n\tstatic get _rightType() { return ['LQDeepDeepRef1', 'LQObjectLiteral', 'LQArrayLiteral', 'RowConstructor', 'ColumnRef2']; } // for inheritance\n\n\tstatic get syntaxRules() {\n\t\treturn [\n\t\t\t{ type: ['ColumnRef2', 'LQBackRefAbstraction'], as: 'left', peek: [1, 'operator', '~>'] },\n\t\t\t{ type: 'operator', value: '~>' },\n\t\t\t{ type: this._rightType, as: 'right' },\n\t\t];\n\t}\n\n\tstatic get syntaxPriority() { return -1; }\n\n\tstatic morphsTo() { return [registry.LQDeepRef1, registry.LQDeepRef2, registry.LQDeepDeepRef1, registry.LQDeepDeepRef2]; }\n\n\t/* API */\n\n\toperand() { return this.left(); }\n\n\tendpoint() { return this.right() instanceof LQDeepDeepRef1 ? this.right().endpoint() : this.right(); }\n\n\t/* JSON API */\n\n\tjsonfy({ toDeepRef = false, toKind = 1, ...options } = {}, transformer = null, schemaInference = null) {\n\t\tif (toDeepRef || toKind === 1 || toKind === 2) {\n\t\t\tconst altsMap = [\n\t\t\t\tregistry.LQDeepRef1.NODE_NAME, registry.LQDeepRef2.NODE_NAME,\n\t\t\t\tregistry.LQDeepDeepRef1.NODE_NAME, registry.LQDeepDeepRef2.NODE_NAME\n\t\t\t];\n\n\t\t\tlet currentIndex = altsMap.indexOf(this.NODE_NAME);\n\t\t\tif (toDeepRef && currentIndex > 1) {\n\t\t\t\tcurrentIndex -= 2;\n\t\t\t}\n\n\t\t\tconst NODE_NAME = altsMap[(currentIndex + 1) % 2 === toKind % 2\n\t\t\t\t? currentIndex\n\t\t\t\t: (toKind % 2 // its 1 or 3\n\t\t\t\t\t? currentIndex - 1\n\t\t\t\t\t: currentIndex + 1)];\n\n\t\t\treturn {\n\t\t\t\tnodeName: NODE_NAME,\n\t\t\t\tleft: this.left().jsonfy({ toKind: currentIndex > 1 ? 2 : 1 }), // Left is always ColumnRef1 for DeepRef, but ColumnRef2 for DeepDeepRef\n\t\t\t\tright: this.right().jsonfy({ toKind: this.right() instanceof LQDeepDeepRef1 ? toKind : undefined }),\n\t\t\t};\n\t\t}\n\n\t\treturn super.jsonfy(options, transformer, schemaInference);\n\t}\n}", "import { LQDeepDeepRef1 } from './LQDeepDeepRef1.js';\nimport { registry } from '../../registry.js';\n\nexport class LQDeepDeepRef2 extends LQDeepDeepRef1 {\n\n\t/* SYNTAX RULES */\n\n\tstatic get _rightType() { return ['LQDeepDeepRef2', 'ColumnRef2', 'ColumnsConstructor']; } // for inheritance\n\n\t/* JSON API */\n\n\tjsonfy({ toDeepRef = false, toKind = 2, ...options } = {}, transformer = null, schemaInference = null) {\n\t\treturn super.jsonfy({ toDeepRef, toKind, ...options }, transformer = null, schemaInference);\n\t}\n}", "import { LQDeepDeepRef1 } from './LQDeepDeepRef1.js';\nimport { registry } from '../../registry.js';\n\nexport class LQDeepRef1 extends LQDeepDeepRef1 {\n\n\t/* SYNTAX RULES */\n\n\tstatic get syntaxRules() {\n\t\treturn [\n\t\t\t{\n\t\t\t\tsyntaxes: [\n\t\t\t\t\t[\n\t\t\t\t\t\t{ type: ['ColumnRef1', 'LQBackRefAbstraction'], as: 'left', peek: [1, 'operator', '~>'] }, // fk ~> col | (fk2 <~ fk1 <~ tbl) ~> col\n\t\t\t\t\t\t{ type: 'operator', value: '~>' },\n\t\t\t\t\t],\n\t\t\t\t\t[\n\t\t\t\t\t\t{ type: 'ColumnRef1', as: 'left', peek: [3, 'operator', '~>'] }, // tbl.fk ~> col | (fk2 <~ fk1 <~ tbl).fk ~> col\n\t\t\t\t\t\t{ type: 'operator', value: '~>' },\n\t\t\t\t\t]\n\t\t\t\t]\n\t\t\t},\n\t\t\t{ type: this._rightType, as: 'right' },\n\t\t];\n\t}\n\n\tstatic get syntaxPriority() { return 1; }\n\n\t/* API */\n\n\trhsTable(transformer, schemaInference) {\n\t\tif (this.left()?.qualifier?.() instanceof registry.LQBackRefAbstraction) {\n\t\t\treturn this._normalize().rhsTable(transformer, schemaInference);\n\t\t}\n\t\tif (this.left() instanceof registry.LQBackRefAbstraction) {\n\t\t\treturn this.left().expr()/* LQBackRef */.rhsTable(transformer, schemaInference);\n\t\t}\n\t\treturn super.rhsTable(transformer, schemaInference);\n\t}\n\n\t_normalize() {\n\t\tconst left = this.left();\n\t\tconst right = this.right();\n\t\tconst lhsOperandJson = left.qualifier().jsonfy();\n\t\tconst rhsOperandJson = { ...left.jsonfy(), qualifier: undefined, nodeName: registry.ColumnRef2.NODE_NAME };\n\t\tconst deepRef = LQDeepRef1.fromJSON({\n\t\t\tleft: lhsOperandJson,\n\t\t\tright: { nodeName: LQDeepDeepRef1.NODE_NAME, left: rhsOperandJson, right: right.jsonfy() }\n\t\t});\n\t\tthis._adoptNodes(deepRef);\n\t\treturn deepRef;\n\t}\n\n\tresolve(transformer, schemaInference, toKind = 1) {\n\t\tif (!transformer || !schemaInference) return;\n\t\tif (this.left()?.qualifier?.() instanceof registry.LQBackRefAbstraction) {\n\t\t\treturn this._normalize().resolve(transformer, schemaInference, toKind);\n\t\t}\n\n\t\tlet detail;\n\t\tif (this.right() instanceof registry.ColumnRef2) {\n\t\t\tdetail = this.right().clone({ toKind });\n\t\t} else if (this.right() instanceof registry.LQDeepDeepRef1) {\n\t\t\tdetail = this.right().clone({ toDeepRef: true, toKind });\n\t\t} else {\n\t\t\tdetail = this.right();\n\t\t}\n\n\t\tif (this.left() instanceof registry.LQBackRefAbstraction) {\n\t\t\tconst resolution = this.left().expr().resolve(transformer, schemaInference, toKind);\n\t\t\treturn { ...resolution, detail };\n\t\t}\n\n\t\tconst qualifiedLeftOperand = this.left().resolve(transformer, schemaInference);\n\n\t\tconst qualifiedRightTable = this.rhsTable(transformer, schemaInference);\n\n\t\tconst unqualifiedRightOperand = qualifiedRightTable.resultSchema().pkConstraint(true)?.columns()[0]?.resolve(transformer, schemaInference);\n\t\tif (!unqualifiedRightOperand) throw new Error(`[${this.parentNode || this}] The referenced RHS table ${qualifiedRightTable} does not have a primary key.`);\n\n\t\treturn {\n\t\t\tlhsOperand: qualifiedLeftOperand, // ColumnRef1\n\t\t\trhsOperand: unqualifiedRightOperand.clone({ toKind }), // ColumnRef2\n\t\t\trhsTable: qualifiedRightTable, // TableRef2\n\t\t\tdetail,\n\t\t};\n\t}\n}", "import { LQDeepRef1 } from './LQDeepRef1.js';\n\nexport class LQDeepRef2 extends LQDeepRef1 {\n\n\t/* SYNTAX RULES */\n\t\n\tstatic get _rightType() { return ['LQDeepDeepRef2', 'ColumnRef2', 'ColumnsConstructor']; } // for inheritance\n\n\tstatic get syntaxPriority() { return -1; }\n\n\t/* JSON API */\n\n\tresolve(transformer, schemaInference, toKind = 2) {\n\t\treturn super.resolve(transformer, schemaInference, toKind);\n\t}\n\n\tjsonfy({ toDeepRef = false, toKind = 2, ...options } = {}, transformer = null, schemaInference = null) {\n\t\treturn super.jsonfy({ toDeepRef, toKind, ...options }, transformer, schemaInference);\n\t}\n}", "import { AbstractClassicRef } from './abstracts/AbstractClassicRef.js';\nimport { AbstractNode } from '../../abstracts/AbstractNode.js';\nimport { registry } from '../../registry.js';\n\nexport class NamespaceRef extends AbstractClassicRef {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'identifier', as: '.' },\n            { type: 'LQVersionSpec', as: 'version_spec', optional: true, autoSpacing: false }\n        ];\n    }\n\n    static get syntaxPriority() { return -1; }\n\n    /* AST API */\n\n    versionSpec() { return this._get('version_spec'); }\n\n    /* API */\n\n    lookup(deepMatchCallback = null, transformer = null, schemaInference = null) {\n        if (!schemaInference) return [];\n\n        const name = this._get('value');\n        const inGrepMode = !name && !deepMatchCallback;\n        let resultSet = [];\n\n        const resolve = (namespaceSchema) => {\n            if (!(namespaceSchema instanceof registry.NamespaceSchema)) return false;\n            if (name && !namespaceSchema.identifiesAs(this)) return false;\n            let result;\n            if (deepMatchCallback && !(result = deepMatchCallback(namespaceSchema))) return false;\n            if (result instanceof AbstractNode || Array.isArray(result)) return result;\n\n            const resolvedNamespaceRef1 = registry.ColumnRef2.fromJSON({\n                ...namespaceSchema.name().jsonfy({ nodeNames: false }),\n                result_schema: namespaceSchema\n            });\n            this.parentNode._adoptNodes(resolvedNamespaceRef1);\n\n            return resolvedNamespaceRef1;\n        };\n\n        for (const namespaceSchema of schemaInference.catalog) {\n            resultSet = resultSet.concat(resolve(namespaceSchema) || []);\n            if (!inGrepMode && resultSet.length) break; // Matching current instance only\n        }\n\n        return resultSet;\n    }\n\n    jsonfy(options = {}, transformer = null, schemaInference = null) {\n        let resultJson;\n        if (options.deSugar\n            && !this.resultSchema()\n            && schemaInference) {\n            // Schema resolution...\n            resultJson = this.resolve(transformer, schemaInference).jsonfy(/* IMPORTANT */);\n        } else {\n            resultJson = super.jsonfy(options, transformer, schemaInference);\n        }\n        // Case normalization...\n        if ((options.deSugar === true || options.deSugar?.normalizeCasing) && !resultJson.delim) {\n            resultJson = { ...resultJson, value: resultJson.value.toLowerCase() };\n        }\n        // Drop version specs...\n        if ((options.deSugar === true || options.deSugar?.dropVersionSpecs) && resultJson.version_spec) {\n            resultJson = { ...resultJson, version_spec: undefined };\n        }\n        return resultJson;\n    }\n}\n", "import { AbstractClassicRef } from './abstracts/AbstractClassicRef.js';\nimport { AbstractNode } from '../../abstracts/AbstractNode.js';\nimport { PathMixin } from '../../abstracts/PathMixin.js';\nimport { registry } from '../../registry.js';\n\nexport class TableRef1 extends PathMixin(AbstractClassicRef) {\n\n\t/* SYNTAX RULES */\n\n\tstatic get _qualifierType() { return 'NamespaceRef'; }\n\n\tstatic get syntaxRules() {\n\t\treturn this.buildSyntaxRules({\n\t\t\tsyntax: [\n\t\t\t\t{ type: 'identifier', as: '.' },\n\t\t\t\t{ type: 'LQVersionSpec', as: 'version_spec', optional: true, autoSpacing: false }\n\t\t\t],\n\t\t\tautoSpacing: false,\n\t\t});\n\t}\n\n\t/* AST API */\n\n\tversionSpec() { return this._get('version_spec'); }\n\n\t/* API */\n\n\tdataType() { return registry.DataType.fromJSON({ value: 'SET' }); }\n\n\t// ----------------\n\n\tcanReferenceInlineTables() { return true; }\n\n\tlookup(deepMatchCallback = null, transformer = null, schemaInference = null) {\n\t\tif (!transformer && !schemaInference) return [];\n\n\t\tconst name = this._get('value');\n\t\tconst inGrepMode = (!name || name === '*') && (!deepMatchCallback || this.parentNode?.value?.() === '*');\n\n\t\tconst isFromItemRef = this.parentNode instanceof registry.FromItem;\n\t\tconst enclosingDerivedQuery = this.statementNode?.parentNode instanceof registry.DerivedQuery\n\t\t\t? this.statementNode?.parentNode\n\t\t\t: null;\n\t\tconst canTraverseUp = isFromItemRef // Can reference CTE\n\t\t\t|| !enclosingDerivedQuery \n\t\t\t|| !(enclosingDerivedQuery.parentNode instanceof registry.FromItem)\n\t\t\t|| !(enclosingDerivedQuery.parentNode/* FromItem */.parentNode/* FromClause */?.parentNode/* SelectStmt */ instanceof registry.SelectStmt)\n\t\t\t|| enclosingDerivedQuery.parentNode.lateralKW();\n\n\t\tlet resultSet = [];\n\n\t\tconst resolve = (tableSchema, qualifierJson = undefined, resolution = 'default') => {\n\t\t\tif (tableSchema instanceof registry.JSONSchema && (!name || name === '*') && deepMatchCallback) {\n\t\t\t\t// We're trying to resolve a column,\n\t\t\t\t// and this is an \"unaliased\" derived query coming from statementContext.artifacts.get('tableSchemas')\n\t\t\t\treturn deepMatchCallback(tableSchema, qualifierJson, resolution);\n\t\t\t}\n\t\t\tif (!(tableSchema instanceof registry.TableSchema)) return false;\n\t\t\tif (name && name !== '*' && !tableSchema.identifiesAs(this)) return false;\n\n\t\t\tlet result;\n\t\t\tif (deepMatchCallback && !(result = deepMatchCallback(tableSchema, qualifierJson, resolution))) return false;\n\t\t\tif (result instanceof AbstractNode || Array.isArray(result)) return result;\n\n\t\t\tconst resolvedTableRef = this.constructor.fromJSON({\n\t\t\t\t...tableSchema.name().jsonfy({ nodeNames: false }),\n\t\t\t\tresolution,\n\t\t\t\tqualifier: qualifierJson,\n\t\t\t\tresult_schema: tableSchema,\n\t\t\t});\n\t\t\tthis.parentNode?._adoptNodes(resolvedTableRef);\n\n\t\t\treturn resolvedTableRef;\n\t\t};\n\n\t\t// 1. Resolve system refs statically\n\t\tconst systemTableRefs = (this.options.dialect || 'postgres') === 'postgres'\n\t\t\t? ['EXCLUDED']\n\t\t\t: [];\n\t\tif (systemTableRefs.includes(name?.toUpperCase()) && transformer) {\n\t\t\tconst tableSchema = [...transformer.statementContext.artifacts.get('tableSchemas')][0].resultSchema.clone({\n\t\t\t\trenameTo: { nodeName: registry.Identifier.NODE_NAME, value: name },\n\t\t\t});\n\t\t\treturn [].concat(resolve(tableSchema, undefined, 'system') || []);\n\t\t}\n\n\t\t// 2. Resolve from InlineTables first?\n\t\tif (this.canReferenceInlineTables() && transformer) {\n\t\t\tlet statementContext = transformer.statementContext;\n\t\t\tlet originalType, inSuperScopeNow, queryScopes = new Set;\n\t\t\tdo {\n\t\t\t\tinSuperScopeNow = statementContext !== transformer.statementContext;\n\t\t\t\tif (!isFromItemRef) {\n\t\t\t\t\tqueryScopes.add(statementContext);\n\t\t\t\t}\n\t\t\t\tfor (const { type, resultSchema: tableSchema } of statementContext.artifacts.get('tableSchemas')) {\n\t\t\t\t\tif (isFromItemRef) {\n\t\t\t\t\t\tif (type !== 'CTEItem') continue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (type === 'CTEItem') continue;\n\t\t\t\t\t\tif (originalType && originalType !== 'dml' && type === 'dml') {\n\t\t\t\t\t\t\t// The nested SELECT in an \"INSERT ... SELECT\" shouldn't see the INSERT\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!originalType) {\n\t\t\t\t\t\t\toriginalType = type;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tresultSet = resultSet.concat(resolve(\n\t\t\t\t\t\ttableSchema,\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\ttype === 'CTEItem'\n\t\t\t\t\t\t\t? 'cte'\n\t\t\t\t\t\t\t: (inSuperScopeNow ? 'scope' : 'default')\n\t\t\t\t\t) || []);\n\t\t\t\t\tif (resultSet.length && !inGrepMode) {\n\t\t\t\t\t\tfor (const queryScope of queryScopes) {\n\t\t\t\t\t\t\tif (!queryScope.artifacts.has('derivedQueryCorrelationFlag')) continue;\n\t\t\t\t\t\t\tqueryScope.artifacts.set('derivedQueryCorrelationFlag', true);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} while (canTraverseUp && (inGrepMode || !resultSet.length) && (statementContext = statementContext.parentTransformer?.statementContext))\n\t\t}\n\n\t\t// 3. Resolve normally\n\t\tif (!deepMatchCallback/* we're not trying to qualify a column */ && (inGrepMode || !resultSet.length)) {\n\t\t\tconst tempNamespaceRef = new registry.NamespaceRef(this.qualifier()?.jsonfy() || {});\n            this._adoptNodes(tempNamespaceRef);\n\t\t\tresultSet = resultSet.concat(tempNamespaceRef.lookup(\n\t\t\t\t(namespaceSchema) => {\n\n\t\t\t\t\treturn namespaceSchema._get('entries').reduce((prev, tableSchema) => {\n\t\t\t\t\t\t//if (prev.length && !inGrepMode) return prev;\n\t\t\t\t\t\tconst newQualifierJson = {\n\t\t\t\t\t\t\t...namespaceSchema.name().jsonfy({ nodeNames: false }),\n\t\t\t\t\t\t\tresult_schema: namespaceSchema\n\t\t\t\t\t\t};\n\t\t\t\t\t\treturn prev.concat(resolve(tableSchema, newQualifierJson) || []);\n\t\t\t\t\t}, []);\n\n\t\t\t\t},\n\t\t\t\ttransformer,\n\t\t\t\tschemaInference,\n\t\t\t));\n\t\t}\n\n\t\tif (name === '*') {\n\t\t\tconst compositeResult = registry.TableRef0.fromJSON({\n\t\t\t\tvalue: this.value(),\n\t\t\t\tresult_schema: registry.JSONSchema.fromJSON({ entries: resultSet.map((s) => s.clone()) }, { assert: true }),\n\t\t\t});\n\t\t\tthis.parentNode._adoptNodes(compositeResult);\n\t\t\tresultSet = [compositeResult];\n\t\t}\n\n\t\treturn resultSet;\n\t}\n\n\tjsonfy(options = {}, transformer = null, schemaInference = null) {\n\t\tlet resultJson;\n\t\tif (options.deSugar && (\n\t\t\t((options.deSugar === true || options.deSugar.tableQualifiers) && !this.qualifier())\n\t\t\t|| !this.resultSchema()\n\t\t) && (transformer || schemaInference)) {\n\t\t\t// Table qualification or schema resolution...\n\t\t\tresultJson = this.resolve(transformer, schemaInference).jsonfy(/* IMPORTANT */);\n\t\t\t// Case normalization...\n\t\t\tif ((options.deSugar === true || options.deSugar.normalizeCasing) && !resultJson.delim) {\n\t\t\t\tresultJson = { ...resultJson, value: resultJson.resolution === 'system' ? resultJson.value.toUpperCase() : resultJson.value.toLowerCase() };\n\t\t\t}\n\t\t\t// Drop qualifier...\n\t\t\tif (!(options.deSugar === true || options.deSugar.tableQualifiers) && !this.qualifier()) {\n\t\t\t\tresultJson = { ...resultJson, qualifier: undefined };\n\t\t\t}\n\t\t} else {\n\t\t\tresultJson = super.jsonfy(options, transformer, schemaInference);\n\t\t}\n\t\t// Drop version specs...\n\t\tif ((options.deSugar === true || options.deSugar?.dropVersionSpecs) && resultJson.version_spec) {\n\t\t\tresultJson = { ...resultJson, version_spec: undefined };\n\t\t}\n\t\treturn resultJson;\n\t}\n}", "import { TableRef1 } from './TableRef1.js';\nimport { registry } from '../../registry.js';\n\nexport class TableRef0 extends TableRef1 {\n\n    /* SYNTAX RULES */\n\n    static get _qualifierType() { return ['NamespaceRef']; }\n\n    static get syntaxRules() {\n        return this.buildSyntaxRules({ type: 'operator', as: '.', value: '*', autoSpacing: false });\n    }\n\n    static get syntaxPriority() { return -1; }\n\n    /* API */\n\n    dataType() { return registry.DataType.fromJSON({ value: 'SET' }); }\n}", "import { TableRef1 } from './TableRef1.js';\n\nexport class TableRef2 extends TableRef1 {\n\n    canReferenceInlineTables() { return false; }\n}", "import { Identifier } from './Identifier.js';\n\nexport class WindowRef extends Identifier {\n    \n    /* SYNTAX RULES */\n\n    static get syntaxPriority() { return -1; }\n}", "import { AbstractClassicExpr } from '../AbstractClassicExpr.js';\n\nexport class BindVar extends AbstractClassicExpr {\n\n\t/* SYNTAX RULES */\n\n    static get syntaxRules() { return { type: 'bind_var', as: '.' }; }\n\n    /* AST API */\n\n    value() { return this._get('value'); }\n}", "import { AbstractClassicExpr } from '../AbstractClassicExpr.js';\n\nexport class SystemVar extends AbstractClassicExpr {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() { return { type: 'system_var', as: '.' }; }\n\n    /* AST API */\n\n    value() { return this._get('value'); }\n}", "import { AbstractClassicExpr } from '../AbstractClassicExpr.js';\n\nexport class UserVar extends AbstractClassicExpr {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() { return { type: 'user_var', as: '.' }; }\n\n    /* AST API */\n\n    value() { return this._get('value'); }\n}", "import { AbstractClassicExpr } from './AbstractClassicExpr.js';\nimport * as exprs from './index.js';\n\nexport class Expr extends AbstractClassicExpr {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return { type: ExprNamesInOrder, expression: 1 };\n    }\n\n    /* API */\n\n    static [Symbol.hasInstance](instance) {\n        return instance instanceof AbstractClassicExpr || instance.constructor.name in exprs;\n    }\n}\n\nconst ExprNames = Object.keys(exprs);\nconst ExprNamesInOrder = ExprNames.filter((k) => {\n    return exprs[k] !== Expr && exprs[k].syntaxPriority !== -1;\n}).sort((a, b) => {\n    const comp = (exprs[b].syntaxPriority ?? 100) - (exprs[a].syntaxPriority ?? 100);\n    if (comp === 0) return exprs[b].prototype.isPrototypeOf(exprs[a].prototype) ? -1 : 1;\n    return comp;\n});\n", "import { PathMixin } from '../../abstracts/PathMixin.js';\nimport { Identifier } from '../../expr/index.js';\n\nexport class ColumnIdent extends PathMixin(Identifier) {\n\n    /* SYNTAX RULES */\n\n    static get _qualifierType() { return 'TableRef2'; }\n}", "import { Identifier } from '../../expr/ref/Identifier.js';\n\nexport class NamespaceIdent extends Identifier {}\n", "import { PathMixin } from '../../abstracts/PathMixin.js';\nimport { Identifier } from '../../expr/index.js';\n\nexport class TableIdent extends PathMixin(Identifier) {\n\n\t/* SYNTAX RULES */\n\t\n\tstatic get _qualifierType() { return 'NamespaceRef'; }\n}", "import { AbstractDiff } from '../../abstracts/AbstractDiff.js';\n\nexport class IndexDiff extends AbstractDiff {}", "import { AbstractSchema } from '../../abstracts/AbstractSchema.js';\n\nexport class IndexSchema extends AbstractSchema {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'Identifier', as: 'name', assert: true },\n        ];\n    }\n}", "import { AbstractDiff } from '../../abstracts/AbstractDiff.js';\n\nexport class SchemaDiff extends AbstractDiff {}", "import { AbstractSchema } from '../../abstracts/AbstractSchema.js';\nimport { registry } from '../../registry.js';\n\nexport class NamespaceSchema extends AbstractSchema {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'NamespaceIdent', as: 'name', assert: true },\n            {\n                type: 'paren_block',\n                syntax: { type: 'TableSchema', as: 'entries', arity: Infinity, itemSeparator, singletons: 'BY_KEY', autoIndent: true },\n            },\n        ];\n    }\n\n    /* API */\n\n    tables() {\n        const result = [];\n        for (const entry of this) {\n            if (!(entry instanceof registry.TableSchema)) continue;\n            result.push(entry);\n        }\n        return result;\n    }\n}", "import { AbstractDiff } from '../../abstracts/AbstractDiff.js';\n\nexport class TableDiff extends AbstractDiff {}", "import { AbstractSchema } from '../../abstracts/AbstractSchema.js';\nimport { Transformer } from '../../Transformer.js';\nimport { registry } from '../../registry.js';\n\nexport class TableSchema extends AbstractSchema {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        const type = ['TablePKConstraint', 'TableFKConstraint', 'TableUKConstraint', 'PGTableEXConstraint', 'CheckConstraint', 'ColumnSchema'/* must come last */, 'IndexSchema'];\n        return [\n            { type: ['TableIdent', 'Identifier'/* to support mock names */], as: 'name' },\n            {\n                type: 'paren_block',\n                syntaxes: [\n                    { type, as: 'entries', arity: Infinity, itemSeparator, singletons: 'BY_KEY', optional: true, dialect: 'postgres', autoIndent: true },\n                    { type, as: 'entries', arity: { min: 1 }, itemSeparator, singletons: 'BY_KEY', dialect: 'mysql', autoIndent: true },\n                ],\n            },\n        ];\n    }\n\n    /* API */\n\n    columns() {\n        const result = [];\n        for (const entry of this) {\n            if (!(entry instanceof registry.ColumnSchema)) continue;\n            result.push(entry);\n        }\n        return result;\n    }\n\n    pkConstraint(normalized = false) {\n        for (const entry of this) {\n            if (entry instanceof registry.TablePKConstraint) return entry;\n            let pk;\n            if (normalized\n                && entry instanceof registry.ColumnSchema\n                && (pk = entry.pkConstraint())) {\n                const instance = registry.TablePKConstraint.fromJSON({\n                    ...pk.jsonfy(),\n                    nodeName: undefined,\n                    columns: [registry.ColumnRef2.fromJSON({ value: entry.name().value() })]\n                });\n                this._adoptNodes(instance);\n                return instance;\n            }\n        }\n    }\n\n    fkConstraints(normalized = false) {\n        const result = [];\n        for (const entry of this) {\n            if (entry instanceof registry.TableFKConstraint) {\n                result.push(entry);\n            }\n            let fk;\n            if (normalized\n                && entry instanceof registry.ColumnSchema\n                && (fk = entry.fkConstraint())) {\n                const instance = registry.TableFKConstraint.fromJSON({\n                    ...fk.jsonfy(),\n                    nodeName: undefined,\n                    columns: [registry.ColumnRef2.fromJSON({ value: entry.name().value() })]\n                });\n                this._adoptNodes(instance);\n                result.push(instance);\n            }\n        }\n        return result;\n    }\n\n    ukConstraints(normalized = false) {\n        const result = [];\n        for (const entry of this) {\n            if (entry instanceof registry.TableUKConstraint) {\n                result.push(entry);\n            }\n            let uk;\n            if (normalized\n                && entry instanceof registry.ColumnSchema\n                && (uk = entry.ukConstraint())) {\n                const instance = registry.TableUKConstraint.fromJSON({\n                    ...uk.jsonfy(),\n                    nodeName: undefined,\n                    columns: [registry.ColumnRef2.fromJSON({ value: entry.name().value() })]\n                });\n                this._adoptNodes(instance);\n                result.push(instance);\n            }\n        }\n        return result;\n    }\n\n    ckConstraints(normalized = false) {\n        const result = [];\n        for (const entry of this) {\n            if (entry instanceof registry.CheckConstraint) {\n                result.push(entry);\n            }\n            let ck;\n            if (normalized\n                && entry instanceof registry.ColumnSchema\n                && (ck = entry.ckConstraint()?.clone())) {\n                this._adoptNodes(ck);\n                result.push(ck);\n            }\n        }\n        return result;\n    }\n\n    jsonfy({ normalized = false, ...options } = {}, transformer = null, schemaInference = null) {\n        const columnLockedConstraints = [];\n\n        const consMap = {\n            [registry.ColumnPKConstraint.NODE_NAME]: registry.TablePKConstraint.NODE_NAME,\n            [registry.ColumnFKConstraint.NODE_NAME]: registry.TableFKConstraint.NODE_NAME,\n            [registry.ColumnUKConstraint.NODE_NAME]: registry.TableUKConstraint.NODE_NAME,\n            [registry.CheckConstraint.NODE_NAME]: registry.CheckConstraint.NODE_NAME,\n        };\n\n        if (normalized) {\n            transformer = new Transformer((node, defaultTransform) => {\n                if (node?.NODE_NAME in consMap && node.parentNode instanceof registry.ColumnSchema) {\n                    columnLockedConstraints.push({\n                        ...node.jsonfy(),\n                        nodeName: consMap[node.NODE_NAME],\n                        ...(!(node instanceof registry.CheckConstraint) ? { columns: [registry.ColumnRef2.fromJSON({ value: node.parentNode.name().value() })] } : {})\n                    });\n                    return; // Exclude from original column\n                }\n                return defaultTransform();\n            }, transformer);\n        }\n\n        let resultJson = super.jsonfy(options, transformer, schemaInference);\n\n        if (normalized) {\n            resultJson = {\n                ...resultJson,\n                entries: resultJson.entries.concat(columnLockedConstraints)\n            }\n        }\n\n        return resultJson;\n    }\n}", "import { AbstractStmt } from '../abstracts/AbstractStmt.js';\r\n\r\nexport class DDLStmt extends AbstractStmt {\r\n    \r\n\r\n    /* SYNTAX RULES */\r\n\r\n    static get syntaxRules() { return { type: ['CreateSchemaStmt', 'DropSchemaStmt', 'CreateTableStmt', 'DropTableStmt'] }; }\r\n\r\n    /** API */\r\n    \r\n    jsonfy({ deSugar, ...options } = {}, transformer = null, schemaInference = null) {\r\n        if (this.returningClause?.()) {\r\n            options = { deSugar, ...options };\r\n        }\r\n        return super.jsonfy(options, transformer, schemaInference);\r\n    }\r\n}\r\n", "import { DDLStmt } from './DDLStmt.js';\n\nexport class CreateSchemaStmt extends DDLStmt {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const mameRule = { type: ['NamespaceIdent', 'Identifier'/* to support mock names */], as: 'name' };\n        const pgAuthorizationRule = {\n            syntax: [\n                { type: 'keyword', value: 'AUTHORIZATION' },\n                {\n                    syntaxes: [\n                        { type: 'keyword', as: 'pg_authorization', value: ['CURRENT_ROLE', 'CURRENT_USER', 'SESSION_USER'] },\n                        { type: 'Identifier', as: 'pg_authorization' },\n                    ]\n                }\n            ]\n        };\n        const pgOptionalEntiresRule = { type: ['CreateTableStmt'], as: 'pg_entries', arity: Infinity, optional: true, dialect: 'postgres' };\n        return [\n            { type: 'keyword', value: 'CREATE' },\n            { type: 'keyword', value: 'SCHEMA', dialect: 'postgres' },\n            { type: 'keyword', value: ['SCHEMA', 'DATABASE'], dialect: 'mysql' },\n            {\n                dialect: 'postgres',\n                syntaxes: [\n                    [\n                        { type: 'keyword', as: 'if_not_exists', value: 'IF', booleanfy: true },\n                        { type: 'operator', value: 'NOT' },\n                        { type: 'keyword', value: 'EXISTS' },\n                        {\n                            syntaxes: [\n                                [\n                                    { ...mameRule },\n                                    { ...pgAuthorizationRule, optional: true },\n                                ],\n                                { ...pgAuthorizationRule },\n                            ]\n                        }\n                    ],\n                    [\n                        { ...mameRule },\n                        { ...pgAuthorizationRule, optional: true },\n                        { ...pgOptionalEntiresRule }\n                    ],\n                    [\n                        { ...pgAuthorizationRule },\n                        { ...pgOptionalEntiresRule }\n                    ]\n                ]\n            },\n            {\n                dialect: 'mysql',\n                syntax: [\n                    {\n                        optional: true,\n                        syntax: [\n                            { type: 'keyword', as: 'if_not_exists', value: 'IF', booleanfy: true },\n                            { type: 'operator', value: 'NOT' },\n                            { type: 'keyword', value: 'EXISTS' },\n                        ]\n                    },\n                    { ...mameRule },\n                    // TODO: mysql create options (like DEFAULT CHARACTER SET utf8)\n                ]\n            },\n        ];\n    }\n\n    /* AST API */\n\n    ifNotExists() { return this._get('if_not_exists'); }\n\n    name() { return this._get('name'); }\n\n    pgAuthorization() { return this._get('pg_authorization'); }\n\n    pgEntries() { return this._get('pg_entries'); }\n}", "import { DDLStmt } from './DDLStmt.js';\n\nexport class DropSchemaStmt extends DDLStmt {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'keyword', value: 'DROP' },\n            { type: 'keyword', value: 'SCHEMA', dialect: 'postgres' },\n            { type: 'keyword', value: ['SCHEMA', 'DATABASE'], dialect: 'mysql' },\n            {\n                optional: true,\n                syntax: [\n                    { type: 'keyword', as: 'if_exists', value: 'IF', booleanfy: true },\n                    { type: 'keyword', value: 'EXISTS' },\n                ]\n            },\n            { type: ['NamespaceIdent', 'Identifier'/* to support mock names */], as: 'pg_names', arity: { min: 1 }, itemSeparator, dialect: 'postgres' },\n            { type: ['NamespaceIdent', 'Identifier'/* to support mock names */], as: 'my_name', dialect: 'mysql' },\n            { type: 'keyword', as: 'pg_cascade_rule', value: ['CASCADE', 'RESTRICT'], optional: true, dialect: 'postgres' },\n        ];\n    }\n\n    /* AST API */\n\n    ifExists() { return this._get('if_exists'); }\n\n    pgNames() { return this._get('pg_names'); }\n\n    myName() { return this._get('my_name'); }\n\n    pgCascadeRule() { return this._get('pg_cascade_rule'); }\n}", "import { DDLStmt } from './DDLStmt.js';\n\nexport class CreateTableStmt extends DDLStmt {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', value: 'CREATE' },\n            {\n                optional: true,\n                syntaxes: [\n                    { type: 'keyword', as: 'temporary_kw', value: 'TEMPORARY', booleanfy: true },\n                    { type: 'keyword', as: 'temporary_kw', value: 'TEMP', booleanfy: true, dialect: 'postgres' },\n                ],\n            },\n            { type: 'keyword', value: 'TABLE' },\n            {\n                optional: true,\n                syntax: [\n                    { type: 'keyword', as: 'if_not_exists', value: 'IF', booleanfy: true },\n                    { type: 'operator', value: 'NOT' },\n                    { type: 'keyword', value: 'EXISTS' },\n                ],\n            },\n            { type: 'TableSchema', as: 'argument' },\n            { type: ['ConfigAssignmentExprAlt1', 'ConfigAssignmentExprAlt2'], as: 'my_create_options', arity: Infinity, dialect: 'mysql' }\n        ];\n    }\n\n    /* AST API */\n\n    temporaryKW() { return this._get('temporary_kw'); }\n\n    ifNotExists() { return this._get('if_not_exists'); }\n\n    argument() { return this._get('argument'); }\n\n    myCreateOptions() { return this._get('my_create_options'); }\n}", "import { DDLStmt } from './DDLStmt.js';\n\nexport class DropTableStmt extends DDLStmt {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'keyword', value: 'DROP' },\n            { type: 'keyword', as: 'my_temporary_kw', value: 'TEMPORARY', booleanfy: true, optional: true, dialect: 'mysql' },\n            { type: 'keyword', value: 'TABLE' },\n            {\n                optional: true,\n                syntax: [\n                    { type: 'keyword', as: 'if_exists', value: 'IF', booleanfy: true },\n                    { type: 'keyword', value: 'EXISTS' },\n                ]\n            },\n            { type: ['TableIdent', 'Identifier'/* to support mock names */], as: 'names', arity: { min: 1 }, itemSeparator },\n            { type: 'keyword', as: 'cascade_rule', value: ['CASCADE', 'RESTRICT'], optional: true },\n        ];\n    }\n\n    /* AST API */\n\n    myTemporaryKW() { return this._get('my_temporary_kw'); }\n\n    ifExists() { return this._get('if_exists'); }\n\n    names() { return this._get('names'); }\n\n    cascadeRule() { return this._get('cascade_rule'); }\n}", "export * from './clauses/index.js';\nexport * from './constructors/index.js';\nexport * from './expr/index.js';\nexport * from './TA/index.js';\nexport { DeleteStmt } from './DeleteStmt.js';\nexport { InsertStmt } from './InsertStmt.js';\nexport { MYSetStmt } from './MYSetStmt.js';\nexport { PGSetStmt } from './PGSetStmt.js';\nexport { UpdateStmt } from './UpdateStmt.js';\nexport { UpsertStmt } from './UpsertStmt.js';\n", "import { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\n\nexport class MYOnDuplicateKeyUpdateClause extends AbstractNodeList {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return {\n            dialect: 'mysql',\n            syntax: [\n                { type: 'keyword', value: 'ON' },\n                { type: 'keyword', value: 'DUPLICATE' },\n                { type: 'keyword', value: 'KEY' },\n                { type: 'keyword', value: 'UPDATE' },\n                { type: 'AssignmentExpr', as: 'entries', arity: { min: 1 }, itemSeparator, assert: true, autoIndent: true },\n            ]\n        };\n    }\n}", "import { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\n\nexport class MYPartitionClause extends AbstractNodeList {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return {\n            dialect: 'mysql',\n            syntax: [\n                { type: 'keyword', value: 'PARTITION' },\n                { type: 'Identifier', as: 'entries', arity: { min: 1 }, itemSeparator, assert: true }\n            ],\n        };\n    }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class PGConflictTarget extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return {\n            syntaxes: [\n                [\n                    { type: 'keyword', value: 'ON' },\n                    { type: 'keyword', value: 'CONSTRAINT' },\n                    { type: 'Identifier', as: 'constraint_name', assert: true }\n                ],\n                [\n                    {\n                        type: 'paren_block',\n                        syntax: { type: 'PGConflictTargetIndexSpec', as: 'index_list', arity: { min: 1 }, itemSeparator, assert: true },\n                        autoIndent: true,\n                    },\n                    { type: 'WhereClause', as: 'where_clause', optional: true, autoIndent: true },\n                ],\n            ],\n        };\n    }\n\n    /* AST API */\n\n    constraintName() { return this._get('constraint_name'); }\n\n    indexList() { return this._get('index_list'); }\n\n    whereClause() { return this._get('where_clause'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class PGConflictTargetIndexSpec extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            {\n                syntaxes: [\n                    { type: 'ColumnRef2', as: 'column_name' },\n                    { type: 'paren_block', syntax: { type: 'Expr', as: 'expr', assert: true }, autoIndent: true },\n                    { type: 'CallExpr', as: 'expr' }, // Must come after the parens option\n                ],\n            },\n            {\n                optional: true,\n                syntax: [\n                    { type: 'operator', value: 'COLLATE' },\n                    { type: 'string_literal', as: 'collation', assert: true },\n                ],\n            },\n            { type: 'Identifier', as: 'opclass', optional: true },\n        ];\n    }\n\n    /* AST API */\n\n    columnName() { return this._get('column_name'); }\n\n    expr() { return this._get('expr'); }\n\n    collation() { return this._get('collation'); }\n\n    opclass() { return this._get('opclass'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class PGDefaultValuesClause extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            dialect: 'postgres',\n            syntax: [\n                { type: 'keyword', as: '.', value: 'DEFAULT' },\n                { type: 'keyword', value: 'VALUES' },\n            ]\n        };\n    }\n}", "import { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\n\nexport class PGOnConflictClause extends AbstractNodeList {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return {\n            dialect: 'postgres',\n            syntax: [\n                { type: 'keyword', value: 'ON' },\n                { type: 'keyword', value: 'CONFLICT' },\n                {\n                    syntaxes: [\n                        [\n                            { type: 'PGConflictTarget', as: 'conflict_target', optional: true },\n                            { type: 'keyword', as: 'do_nothing_kw', value: 'DO', booleanfy: true },\n                            { type: 'keyword', value: 'NOTHING' },\n                        ],\n                        [\n                            { type: 'PGConflictTarget', as: 'conflict_target' },\n                            { type: 'keyword', value: 'DO' },\n                            { type: 'keyword', value: 'UPDATE' },\n                            { type: 'keyword', value: 'SET' },\n                            { type: 'AssignmentExpr', as: 'entries', arity: { min: 1 }, itemSeparator, assert: true, autoIndent: true },\n                            { type: 'WhereClause', as: 'where_clause', optional: true, autoIndent: true },\n                        ],\n                    ],\n                }\n            ],\n        };\n    }\n\n    /* AST API */\n\n    conflictTarget() { return this._get('conflict_target'); }\n\n    doNothingKW() { return this._get('do_nothing_kw'); }\n\n    whereClause() { return this._get('where_clause'); }\n}", "import { ResultSchemaMixin } from '../../abstracts/ResultSchemaMixin.js';\nimport { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\nimport { registry } from '../../registry.js';\nimport { _eq } from '../../abstracts/util.js';\n\nexport class SelectList extends ResultSchemaMixin(AbstractNodeList) {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return { type: 'SelectItem', as: 'entries', arity: { min: 1 }, itemSeparator, assert: true, autoIndent: 2 };\n    }\n\n    /* JSON API */\n\n    jsonfy(options = {}, transformer = null, schemaInference = null) {\n        let resultJson = super.jsonfy(options, transformer, schemaInference);\n        if (!options.deSugar) return resultJson;\n\n        let resolvedOutputList = [];\n\n        const shouldFlattenUnaliasedRootObjects = (options.deSugar === true || options.deSugar?.flattenUnaliasedRootObjects);\n        const shouldDedupe = false;\n\n        const addOutputItem = (itemJson) => {\n            if (shouldDedupe) {\n                resolvedOutputList = resolvedOutputList.reduce((result, existing) => {\n                    if (itemJson.alias && existing.alias && _eq(itemJson.alias.value, existing.alias.value, itemJson.alias.delim || existing.alias.delim)) {\n                        return result;\n                    }\n                    return result.concat(existing);\n                }, []);\n            }\n            resolvedOutputList = resolvedOutputList.concat(itemJson);\n        };\n\n        for (const [i, selectItemJson] of resultJson.entries.entries()) {\n\n            if (selectItemJson.expr.value === '*') {\n                for (const columnRef of selectItemJson.result_schema) {\n                    const exprJson = columnRef.jsonfy();\n                    const aliasJson = { nodeName: registry.SelectItemAlias.NODE_NAME, as_kw: true, value: exprJson.value, delim: exprJson.delim };\n                    addOutputItem({\n                        nodeName: registry.SelectItem.NODE_NAME,\n                        expr: exprJson,\n                        alias: aliasJson,\n                        result_schema: exprJson.result_schema.clone(),\n                        _originalStarJson: selectItemJson\n                    });\n                }\n            } else if (shouldFlattenUnaliasedRootObjects\n                && this.entries()[i]/* original */.expr() instanceof registry.LQObjectLiteral\n                && !this.entries()[i]/* original */.alias()) {\n                // Start by making pairs of arguments\n                const [argPairs] = selectItemJson.expr.arguments.reduce(([argPairs, key], value) => {\n                    if (!key) return [argPairs, value];\n                    return [[...argPairs, [key, value]]];\n                }, [[]]);\n\n                const resultSchemas = selectItemJson.expr.result_schema.entries();\n\n                for (let i = 0; i < argPairs.length; i++) {\n                    addOutputItem({\n                        nodeName: registry.SelectItem.NODE_NAME,\n                        expr: argPairs[i][1],\n                        alias: { ...argPairs[i][0], nodeName: registry.SelectItemAlias.NODE_NAME, as_kw: true },\n                        result_schema: resultSchemas[i],\n                    });\n                }\n            } else {\n                addOutputItem(selectItemJson);\n            }\n        }\n\n        return {\n            ...resultJson,\n            entries: resolvedOutputList,\n        };\n    }\n\n    finalizeJSON(resultJson, transformer, schemaInference, options) {\n        const shouldDeSugarStars = (options.deSugar === true || options.deSugar?.expandStarRefs);\n        let starsFound;\n\n        const [\n            selectItems,\n            outputSchemas\n        ] = resultJson.entries.reduce(([a, b], { _originalStarJson, ...fieldJson }) => {\n\n            if (_originalStarJson) {\n                starsFound = true;\n            }\n\n            if (_originalStarJson && !shouldDeSugarStars) {\n                if (!_originalStarJson.result_schema) {\n                    _originalStarJson.result_schema = registry.JSONSchema.fromJSON({ entries: [] }, { assert: true });\n                }\n                _originalStarJson.result_schema._add('entries', fieldJson.result_schema);\n                return [\n                    a.concat(_originalStarJson),\n                    b.concat(fieldJson.result_schema.clone())\n                ];\n            }\n\n            if (!fieldJson.result_schema) {\n                const fieldNode = registry.SelectItem.fromJSON(fieldJson, this.options);\n                this._adoptNodes(fieldNode);\n                fieldJson = fieldNode.jsonfy(options, transformer, schemaInference);\n            }\n\n            return [\n                a.concat(fieldJson),\n                b.concat(fieldJson.result_schema.clone())\n            ];\n        }, [[], []]);\n\n        // Apply now\n        resultJson = {\n            ...resultJson,\n            entries: starsFound && !shouldDeSugarStars ? [...new Set(selectItems)] : selectItems,\n            result_schema: registry.JSONSchema.fromJSON({ entries: outputSchemas }, { assert: true }),\n        };\n        transformer.statementContext.artifacts.set('outputSchemas', new Set(outputSchemas));\n\n        return resultJson;\n    }\n}", "import { SelectList } from '../../dql/clauses/SelectList.js';\n\nexport class ReturningClause extends SelectList {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', value: 'RETURNING' },\n            ...[].concat(super.syntaxRules),\n        ];\n    }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class PGWhereCurrentClause extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            dialect: 'postgres',\n            syntax: [\n                { type: 'keyword', value: 'WHERE' },\n                { type: 'keyword', value: 'CURRENT OF' },\n                { type: 'identifier', as: 'cursor_name', assert: true }\n            ]\n        };\n    }\n\n    /* AST API */\n\n    cursorName() { return this._get('cursor_name'); }\n}", "import { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\n\nexport class SetClause extends AbstractNodeList {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'keyword', value: 'SET' },\n            { type: 'AssignmentExpr', as: 'entries', arity: { min: 1 }, itemSeparator, assert: true, autoIndent: 2 },\n        ];\n    }\n}", "import { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\n\nexport class UsingFromClause extends AbstractNodeList {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'keyword', value: 'USING' },\n            { type: 'FromItem', as: 'entries', arity: { min: 1 }, itemSeparator, assert: true }\n        ];\n    }\n}", "import { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\n\nexport class ColumnsConstructor extends AbstractNodeList {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return {\n            syntax: [\n                {\n                    type: 'paren_block',\n                    syntax: { type: ['LQDeepRef2', 'ColumnRef2'], as: 'entries', arity: Infinity, itemSeparator, autoIndent: 10 },\n                },\n            ],\n        };\n    }\n\n    static get syntaxPriority() { return -1; }\n}", "import { ResultSchemaMixin } from '../../abstracts/ResultSchemaMixin.js';\nimport { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\n\nexport class ValuesConstructor extends ResultSchemaMixin(AbstractNodeList) {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return {\n            syntaxes: [\n                [\n                    { type: 'keyword', value: 'VALUES' },\n                    { type: ['TypedRowConstructor', 'RowConstructor'], as: 'entries', arity: { min: 1 }, itemSeparator, assert: true, autoIndent: 2 }\n                ],\n                {\n                    dialect: 'mysql',\n                    syntax: [\n                        { type: 'keyword', value: ['VALUES', 'VALUE'] },\n                        { type: ['TypedRowConstructor', 'RowConstructor'], as: 'entries', arity: { min: 1 }, itemSeparator, assert: true, autoIndent: 2 }\n                    ]\n                },\n            ],\n        };\n    }\n\n    static get syntaxPriority() { return -1; }\n\n    /* JSON API */\n\n    jsonfy(options = {}, transformer = null, schemaInference = null) {\n        let resultJson = super.jsonfy({ ...options, forceDeSugar: options.deSugar }, transformer, schemaInference);\n        if (options.deSugar) {\n            const row1_resultSchema = resultJson.entries?.[0]?.result_schema;\n            resultJson = {\n                ...resultJson,\n                result_schema: row1_resultSchema?.clone()\n            };\n        }\n        return resultJson;\n    }\n}", "import { BinaryExpr } from '../../expr/op/BinaryExpr.js';\n\nexport class AssignmentExpr extends BinaryExpr {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: ['LQDeepRef2', 'ColumnsConstructor', 'ColumnRef2'], as: 'left', dialect: 'postgres' },\n            { type: ['LQDeepRef2', 'ColumnRef1'], as: 'left', dialect: 'mysql' },\n            { type: 'operator', as: 'operator', value: '=' },\n            { type: ['ValuesTableLiteral'/* For deep dimensional inserts */, 'DerivedQuery', 'Expr'], as: 'right' },\n        ];\n    }\n}", "import { BinaryExpr } from '../../expr/op/BinaryExpr.js';\n\nexport class ConfigAssignmentExpr extends BinaryExpr {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', as: 'my_default_kw', value: 'DEFAULT', booleanfy: true, dialect: 'mysql', optional: true },\n            {\n                syntaxes: [\n                    { type: 'keyword', as: 'left' },\n                    { type: 'identifier', as: 'left' },\n                ],\n            },\n            { type: 'operator', as: 'operator', value: '=' },\n            { type: ['Expr', 'KW'], as: 'right' },\n        ];\n    }\n\n    /* API */\n\n    myDefaultKW() { return this._get('my_default_kw'); }\n}", "import { BinaryExpr } from '../../expr/op/BinaryExpr.js';\n\nexport class ConfigAssignmentExprAlt1 extends BinaryExpr {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', as: 'my_default_kw', value: 'DEFAULT', booleanfy: true, dialect: 'mysql', optional: true },\n            {\n                syntaxes: [\n                    { type: 'keyword', as: 'left' },\n                    { type: 'identifier', as: 'left' },\n                ],\n            },\n            { type: 'operator', as: 'operator', value: '=', optional: true },\n            { type: ['Expr', 'KW'], as: 'right' },\n        ];\n    }\n\n    /* API */\n\n    myDefaultKW() { return this._get('my_default_kw'); }\n}", "import { BinaryExpr } from '../../expr/op/BinaryExpr.js';\n\nexport class ConfigAssignmentExprAlt2 extends BinaryExpr {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', as: 'default_kw', value: 'DEFAULT', booleanfy: true, optional: true },\n            {\n                syntaxes: [\n                    { type: 'keyword', as: 'left' },\n                    { type: 'identifier', as: 'left' },\n                ],\n            },\n            {\n                optional: true,\n                syntax: [\n                    { type: 'operator', as: 'operator', value: '=' },\n                    { type: ['Expr', 'KW'], as: 'right' },\n                ],\n            }\n        ];\n    }\n\n    /* API */\n\n    myDefaultKW() { return this._get('my_default_kw'); }\n}", "import { BinaryExpr } from '../../expr/op/BinaryExpr.js';\n\nexport class MYVarAssignmentExpr extends BinaryExpr {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: ['UserVar', 'SystemVar'], as: 'left' },\n            { type: 'operator', as: 'operator', value: ['=', ':='] },\n            { type: 'Expr', as: 'right' },\n        ];\n    }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class KW extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() { return { type: 'keyword', as: '.' }; }\n\n    /* AST API */\n\n    value() { return this._get('value'); }\n}", "import { ResultSchemaMixin } from '../../abstracts/ResultSchemaMixin.js';\nimport { AbstractNode } from '../../abstracts/AbstractNode.js';\nimport { registry } from '../../registry.js';\n\nexport class TableAbstraction2 extends ResultSchemaMixin(AbstractNode) {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', as: 'pg_only_kw', value: 'ONLY', optional: true, dialect: 'postgres' },\n            { type: 'TableRef1', as: 'table_ref', assert: true },\n            { type: 'operator', as: 'pg_star_ref', value: '*', booleanfy: true, optional: true, dialect: 'postgres' },\n            { type: 'SelectItemAlias', as: 'alias', optional: true },\n        ];\n    }\n\n    /* AST API */\n\n    tableRef() { return this._get('table_ref'); }\n\n    alias() { return this._get('alias'); }\n\n    // -- Postgres\n\n    pgOnlyKW() { return this._get('pg_only_kw'); }\n\n    pgStarRef() { return this._get('pg_star_ref'); }\n\n    /* SCHEMA API */\n\n    deriveAlias() {\n        let derivedAlias;\n        if (this.alias()) {\n            derivedAlias = this.alias();\n        } else {\n            derivedAlias = registry.SelectItemAlias.fromJSON({\n                as_kw: true,\n                value: this.tableRef().value(),\n                delim: this.tableRef()._get('delim'),\n            });\n        }\n        return derivedAlias;\n    }\n\n    jsonfy(options = {}, transformer = null, schemaInference = null) {\n        let resultJson = super.jsonfy(options, transformer, schemaInference);\n        if (options.deSugar) {\n\n            const derivedAliasJson = resultJson.alias || this.deriveAlias().jsonfy();\n\n            const namespaceIdent = {\n                nodeName: registry.Identifier.NODE_NAME,\n                value: derivedAliasJson.value,\n                delim: derivedAliasJson.delim,\n            };\n\n            let resultSchema = resultJson.table_ref.result_schema.clone({ renameTo: namespaceIdent });\n            if (resultJson.alias) {\n                resultSchema = resultSchema.clone({ renameTo: { nodeName: registry.Identifier.NODE_NAME, value: resultJson.alias.value, delim: resultJson.alias.delim } });\n            }\n\n            transformer.statementContext.artifacts.get('tableSchemas').add({ resultSchema });\n\n            const applicableAliasJson = (options.deSugar === true || options.deSugar?.tableAliases)\n                && derivedAliasJson\n                || resultJson.alias;\n            resultJson = {\n                ...resultJson,\n                alias: applicableAliasJson,\n                result_schema: resultSchema,\n            };\n        }\n\n        return resultJson;\n    }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\nimport { ResultSchemaMixin } from '../../abstracts/ResultSchemaMixin.js';\nimport { registry } from '../../registry.js';\n\nexport class TableAbstraction1 extends ResultSchemaMixin(AbstractNode) {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'TableRef1', as: 'table_ref' },\n            {\n                optional: true,\n                dialect: 'mysql',\n                syntax: [\n                    { type: 'punctuation', value: '.', autoSpacing: false },\n                    { type: 'operator', as: 'my_star_ref', value: '*', booleanfy: true, autoSpacing: false },\n                ],\n            },\n            { type: 'SelectItemAlias', as: 'alias', optional: true },\n        ];\n    }\n\n    /* AST API */\n\n    tableRef() { return this._get('table_ref'); }\n\n    myStarRef() { return this._get('my_star_ref'); }\n\n    alias() { return this._get('alias'); }\n\n    /* SCHEMA API */\n\n    deriveAlias() {\n        let derivedAlias;\n        if (this.alias()) {\n            derivedAlias = this.alias();\n        } else {\n            derivedAlias = registry.SelectItemAlias.fromJSON({\n                as_kw: true,\n                value: this.tableRef().value(),\n                delim: this.tableRef()._get('delim'),\n            });\n        }\n        return derivedAlias;\n    }\n\n    jsonfy(options = {}, transformer = null, schemaInference = null) {\n        let resultJson = super.jsonfy(options, transformer, schemaInference);\n        if (options.deSugar) {\n\n            const derivedAliasJson = resultJson.alias || this.deriveAlias().jsonfy();\n\n            const namespaceIdent = {\n                nodeName: registry.Identifier.NODE_NAME,\n                value: derivedAliasJson.value,\n                delim: derivedAliasJson.delim,\n            };\n\n            let resultSchema = resultJson.table_ref.result_schema.clone({ renameTo: namespaceIdent });\n            if (resultJson.alias) {\n                resultSchema = resultSchema.clone({ renameTo: { nodeName: registry.Identifier.NODE_NAME, value: resultJson.alias.value, delim: resultJson.alias.delim } });\n            }\n\n            transformer.statementContext.artifacts.get('tableSchemas').add({ resultSchema });\n\n            const applicableAliasJson = (options.deSugar === true || options.deSugar?.tableAliases)\n                && derivedAliasJson\n                || resultJson.alias;\n            resultJson = {\n                ...resultJson,\n                alias: applicableAliasJson,\n                result_schema: resultSchema,\n            };\n        }\n\n        return resultJson;\n    }\n}", "import { Transformer } from '../Transformer.js';\nimport { registry } from '../registry.js';\nimport { _eq } from './util.js';\n\nexport const SelectorStmtMixin = (Class) => class extends Class {\n\n    get isSelectorStmt() { return true; }\n\n    /* DESUGARING API */\n\n    jsonfy(options = {}, transformer = null, schemaInference = null) {\n        if (!options.deSugar) return super.jsonfy(options, transformer, schemaInference);\n\n        const {\n            ColumnRef1,\n            ColumnRef2,\n            AggrCallExpr,\n            LQBackRefAbstraction,\n            LQDeepRef1,\n            LQBackRef,\n        } = registry;\n\n        transformer = new Transformer((node, defaultTransform, keyHint, { deSugar/* EXCLUSION */, asAggr/* EXCLUSION */, ...$options }) => {\n\n            const isSpecialColumnRef1 = (node) => {\n                return node instanceof ColumnRef1\n                    && node.qualifier() instanceof LQBackRefAbstraction;\n            };\n\n            const specialColumnRef1ToDeepRef = (columnRef) => {\n                const lhsOperandJson = columnRef.qualifier().jsonfy();\n                const rhsOperandJson = { ...columnRef.jsonfy(), qualifier: undefined, nodeName: ColumnRef2.NODE_NAME };\n                const deepRef = LQDeepRef1.fromJSON({\n                    left: lhsOperandJson,\n                    right: rhsOperandJson\n                });\n                columnRef.parentNode._adoptNodes(deepRef);\n                return deepRef;\n            };\n\n            const toAggr = (nodeJson) => {\n                return {\n                    nodeName: AggrCallExpr.NODE_NAME,\n                    name: ($options.toDialect || this.options.dialect) === 'mysql' ? 'JSON_ARRAYAGG' : 'JSON_AGG',\n                    arguments: [nodeJson],\n                };\n            };\n\n            // 1. DeSugar special column refs \"(fk <~ tbl).col\" to deep refs\n            if (isSpecialColumnRef1(node)) {\n                node = specialColumnRef1ToDeepRef(node);\n            }\n\n            // 2. DeSugar deep refs to bare column refs\n            if (node instanceof LQDeepRef1) {\n                let { select, detail } = this.createSelectorDimension(node, transformer, schemaInference, { ...$options, asAggr });\n                const detailJson = asAggr\n                    ? toAggr(detail.jsonfy())\n                    : detail.jsonfy();\n                return select(detailJson);\n            }\n\n            // ...and for when we still hit back refs \"fk <~ tbl\"\n            if (node instanceof LQBackRef || node instanceof LQBackRefAbstraction) {\n                if (node instanceof LQBackRefAbstraction) {\n                    node = node.expr();\n                }\n                const { alias } = this.createSelectorDimension(node, transformer, schemaInference, $options);\n                return alias();\n            }\n\n            // Other\n            return defaultTransform();\n        }, transformer, this/* IMPORTANT */);\n\n        return super.jsonfy(options, transformer, schemaInference);\n    }\n\n    createSelectorDimension(LQRef, transformer, schemaInference, { asAggr = false, ...$options } = {}) {\n        const { lhsOperand, rhsOperand, rhsTable, detail } = LQRef.resolve(transformer, schemaInference);\n        const selectorDimensions = transformer.statementContext.artifacts.get('selectorDimensions');\n\n        const {\n            CompleteSelectStmt,\n            DerivedQuery,\n            FromClause,\n            JoinClause,\n            OnClause,\n            GroupByClause,\n            GroupingElement,\n            FromItem,\n            SelectList,\n            SelectItem,\n            FromItemAlias,\n            SelectItemAlias,\n            TableRef1,\n            ColumnRef1,\n            BinaryExpr,\n        } = registry;\n\n        const $dimensionID = `dimension${asAggr ? '/g' : ''}|${[lhsOperand, rhsOperand, rhsTable].join('|')}`;\n        const dimensionID = transformer.statementContext.hash($dimensionID, 'join');\n\n        if (selectorDimensions?.has(dimensionID)) {\n            return { ...selectorDimensions.get(dimensionID), detail };\n        }\n\n        const rands = new Map;\n\n        // Mask \"rhsOperand\"\n        const rhsOperandMask = transformer.rand('key', rands);\n        const rhsOperandJson = rhsOperand.jsonfy();\n        const fieldSpec = {\n            nodeName: SelectItem.NODE_NAME,\n            expr: rhsOperandJson,\n            alias: { nodeName: SelectItemAlias.NODE_NAME, as_kw: true, value: rhsOperandMask },\n        };\n\n        // Compose:\n        // - LEFT JOIN ( SELECT [fieldSpec] FROM <rhsTable> [GROUP BY]? )\n        // - AS <dimensionID>\n        // - ON <dimensionID>.<rhsOperandMask> = <lhsOperand>\n        const joinJson = {\n            nodeName: JoinClause.NODE_NAME,\n            join_type: 'LEFT',\n            expr: {\n                nodeName: DerivedQuery.NODE_NAME,\n                // SELECT <fieldSpec>\n                expr: {\n                    nodeName: CompleteSelectStmt.NODE_NAME,\n                    select_list: { nodeName: SelectList.NODE_NAME, entries: [fieldSpec] },\n                    // FROM <rhsTable>\n                    from_clause: {\n                        nodeName: FromClause.NODE_NAME,\n                        entries: [{ nodeName: FromItem.NODE_NAME, expr: rhsTable.jsonfy({ ...$options, deSugar: null }) }]\n                    },\n                    // GROUP BY <rhsOperandMask>\n                    group_by_clause: asAggr ? {\n                        nodeName: GroupByClause.NODE_NAME,\n                        entries: [{ nodeName: GroupingElement.NODE_NAME, expr: { nodeName: ColumnRef1.NODE_NAME, value: rhsOperandMask } }]\n                    } : undefined,\n                }\n            },\n            // AS <dimensionID>\n            alias: { nodeName: FromItemAlias.NODE_NAME, as_kw: true, value: dimensionID },\n            // ON <dimensionID>.<rhsOperandMask> = <lhsOperand>\n            condition_clause: {\n                nodeName: OnClause.NODE_NAME,\n                expr: {\n                    nodeName: BinaryExpr.NODE_NAME,\n                    operator: '=',\n                    left: lhsOperand.jsonfy({ ...$options, deSugar: null }, transformer, schemaInference),\n                    right: {\n                        nodeName: ColumnRef1.NODE_NAME,\n                        qualifier: { nodeName: TableRef1.NODE_NAME, value: dimensionID },\n                        value: rhsOperandMask\n                    },\n                }\n            },\n        };\n\n        // Join ALias as Table ref...\n        const alias = () => ({ nodeName: TableRef1.NODE_NAME, value: dimensionID });\n\n        // Add entry...\n        const select = (detail) => {\n            const selectAlias = transformer.rand('ref', rands);\n\n            // Compose:\n            // - [...detail] AS <selectAlias>\n            joinJson.expr.expr.select_list.entries.push({\n                nodeName: SelectItem.NODE_NAME,\n                expr: detail,\n                alias: { nodeName: SelectItemAlias.NODE_NAME, as_kw: true, value: selectAlias },\n            });\n\n            return {\n                nodeName: ColumnRef1.NODE_NAME,\n                qualifier: { nodeName: TableRef1.NODE_NAME, value: dimensionID },\n                value: selectAlias,\n            };\n        };\n\n        const selectorDimension = { id: dimensionID, type: 'join', query: joinJson, alias, select, detail };\n\n        selectorDimensions.set(dimensionID, selectorDimension);\n\n        return selectorDimension;\n    }\n\n    finalizeSelectorJSON(resultJson, transformer, schemaInference, options) {\n        let rewrittenJoinEntries;\n        [\n            resultJson,\n            rewrittenJoinEntries,\n        ] = this.preprocessSelectorDimensions(resultJson, transformer, schemaInference, options);\n        \n        resultJson = {\n            ...resultJson,\n            join_clauses: resultJson.join_clauses?.slice(0) || [],\n        };\n\n        for (const joinJson of rewrittenJoinEntries) {\n            const joinNode = registry.JoinClause.fromJSON(joinJson, this.options);\n            this._adoptNodes(joinNode);\n\n            const joinJson2 = transformer.transform(joinNode, ($options = options, childTransformer = transformer) => {\n                return joinNode.jsonfy($options, childTransformer, schemaInference);\n            }, null, options);\n\n            resultJson.join_clauses.push(joinJson2);\n        }\n\n        return resultJson;\n    }\n\n    preprocessSelectorDimensions(resultJson, transformer, schemaInference, options) {\n\n        const selectorDimensions = transformer.statementContext.artifacts.get('selectorDimensions');\n        if (!selectorDimensions.size) {\n            return [resultJson, []];\n        }\n        \n        if (this.options.dialect === 'postgres' && (this instanceof registry.DeleteStmt || this instanceof registry.UpdateStmt)) {\n            if (resultJson.where_clause?.cursor_name) {\n                throw new Error(`Deep/Back Refs are currently not supported with a \"WHERE CURRENT OF...\" statement`);\n            }\n\n            const {\n                DerivedQuery,\n                CompleteSelectStmt,\n                SelectList,\n                SelectItem,\n                FromItemAlias,\n                FromClause,\n                WhereClause,\n                TableRef1,\n                BinaryExpr,\n                FromItem,\n            } = registry;\n\n            const rand = transformer.rand('join');\n\n            // Each table involved in a Deep/BackRef should have a corresponding entry\n            // in the \"FROM\" list where we have the chance to establish our JOIN\n            // with a corresponding extra \"WHERE\" clause that correlates the generated table with the original table\n\n            const tableExpr = resultJson.table_expr;\n\n            const tblAliasOriginal = tableExpr.alias.value;\n            const tblAliasOriginal_delim = tableExpr.alias.delim;\n            const tblAliasRewrite = `${rand}:${tblAliasOriginal}`;\n\n            const pkConstraint = tableExpr.result_schema.pkConstraint(true);\n            const pkColumnRef = pkConstraint?.columns()[0].jsonfy({ toKind: 1 });\n\n            let pgGeneratedFromItem;\n            let pgGeneratedWhereClause\n\n            const createCorrelationExpr = (columnRef) => {\n                return {\n                    nodeName: BinaryExpr.NODE_NAME,\n                    left: {\n                        ...columnRef, qualifier: {\n                            nodeName: TableRef1.NODE_NAME,\n                            value: tblAliasOriginal,\n                            delim: tblAliasOriginal_delim\n                        },\n                    },\n                    operator: '=',\n                    right: {\n                        ...columnRef, qualifier: {\n                            nodeName: TableRef1.NODE_NAME,\n                            value: tblAliasRewrite\n                        },\n                    },\n                };\n            };\n\n            let selectItems;\n            const createOrPatchAFromEntry = (columnRef) => {\n                if (!_eq(columnRef.qualifier.value, tblAliasOriginal, columnRef.qualifier.delim || tblAliasOriginal_delim)) {\n                    return columnRef;\n                }\n\n                if (!pgGeneratedFromItem) {\n                    // Compose:\n                    // - ( SELECT [] FROM <tblRefOriginal> )\n                    // - AS <tblAliasRewrite>\n                    const fromItem = {\n                        nodeName: FromItem.NODE_NAME,\n                        expr: {\n                            nodeName: DerivedQuery.NODE_NAME,\n                            expr: {\n                                // SELECT <...>\n                                nodeName: CompleteSelectStmt.NODE_NAME,\n                                select_list: { nodeName: SelectList.NODE_NAME, entries: [] },\n                                from_clause: {\n                                    // FROM <tblRefOriginal>\n                                    nodeName: FromClause.NODE_NAME,\n                                    entries: [{\n                                        nodeName: FromItem.NODE_NAME,\n                                        expr: tableExpr.table_ref,\n                                    }],\n                                },\n                            },\n                        },\n                        // AS <tblAliasRewrite>\n                        alias: { nodeName: FromItemAlias.NODE_NAME, as_kw: true, value: tblAliasRewrite },\n                    };\n\n                    selectItems = fromItem.expr.expr.select_list.entries;\n\n                    // Compose:\n                    // - WHERE <tblAliasOriginal.colRefOriginal> = <tblAliasRewrite.colRefRewrite>\n                    if (pkColumnRef) {\n                        selectItems.push({\n                            nodeName: SelectItem.NODE_NAME,\n                            expr: pkColumnRef,\n                        });\n                        pgGeneratedWhereClause = {\n                            nodeName: WhereClause.NODE_NAME,\n                            expr: createCorrelationExpr(pkColumnRef),\n                        };\n                    }\n                    // Declare entry...\n                    pgGeneratedFromItem = fromItem;\n                }\n\n                // 1. Select the rewritten ref\n                if (!selectItems.find((fieldJson) => _eq(fieldJson.expr.value, columnRef.value, fieldJson.expr.delim || columnRef.delim))) {\n                    selectItems.push({ nodeName: SelectItem.NODE_NAME, expr: columnRef });\n                }\n\n                // 2. Use ewritten ref for correlation in the absence of a primary key\n                if (!pkColumnRef) {\n                    let whereExpr = createCorrelationExpr(columnRef);\n                    if (pgGeneratedWhereClause) {\n                        whereExpr = {\n                            nodeName: BinaryExpr.NODE_NAME,\n                            left: pgGeneratedWhereClause.expr,\n                            operator: 'AND',\n                            right: whereExpr\n                        };\n                    }\n                    pgGeneratedWhereClause = {\n                        nodeName: WhereClause.NODE_NAME,\n                        expr: whereExpr,\n                    };\n                }\n\n                return {\n                    ...columnRef,\n                    qualifier: { nodeName: TableRef1.NODE_NAME, value: tblAliasRewrite },\n                };\n            };\n\n            // (1)\n            // Rewrite original references to FROM entry references\n            const rewrittenJoinEntries = [];\n            for (const [, { query: joinJson }] of selectorDimensions) {\n                rewrittenJoinEntries.push({\n                    ...joinJson,\n                    condition_clause: {\n                        ...joinJson.condition_clause,\n                        expr: {\n                            ...joinJson.condition_clause.expr,\n                            left: createOrPatchAFromEntry(joinJson.condition_clause.expr.left)\n                        },\n                    },\n                });\n            }\n\n            // (2)\n            // Inject the \"FROM\" list generated by createOrPatchAFromEntry()\n            const [fromClause, fromClauseClass] = this instanceof registry.DeleteStmt\n                ? ['pg_using_clause', 'UsingFromClause']\n                : ['pg_from_clause', 'FromClause'];\n\n            if (pgGeneratedFromItem) {\n                const fromItemNode = FromItem.fromJSON(pgGeneratedFromItem, this.options);\n                this._adoptNodes(fromItemNode);\n\n                resultJson = {\n                    ...resultJson,\n                    [fromClause]: {\n                        nodeName: registry[fromClauseClass].NODE_NAME,\n                        entries: (resultJson[fromClause]?.entries || []).concat(\n                            fromItemNode.jsonfy(options, transformer, schemaInference)\n                        ),\n                    },\n                    where_clause: !resultJson.where_clause ? pgGeneratedWhereClause : {\n                        nodeName: WhereClause.NODE_NAME,\n                        expr: {\n                            nodeName: BinaryExpr.NODE_NAME,\n                            left: pgGeneratedWhereClause.expr,\n                            operator: 'AND',\n                            right: resultJson.where_clause.expr,\n                        },\n                    },\n                };\n            }\n\n            return [\n                resultJson,\n                rewrittenJoinEntries,\n            ];\n        }\n\n        return [\n            resultJson,\n            [...selectorDimensions].map(([, { query: joinJson }]) => joinJson),\n        ];\n    }\n}\n", "import { AbstractNonDDLStmt } from '../abstracts/AbstractNonDDLStmt.js';\r\nimport { registry } from '../registry.js';\r\n\r\nexport class DMLStmt extends AbstractNonDDLStmt {\r\n\r\n    /* SYNTAX RULES */\r\n\r\n    static get syntaxRules() { return { type: ['InsertStmt', 'UpsertStmt', 'UpdateStmt', 'DeleteStmt'] }; }\r\n\r\n    finalizeOutputJSON(resultJson, transformer, schemaInference, options) {\r\n\r\n        if (resultJson.returning_clause) {\r\n            // 1. Re-resolve output list for cases of just-added deep refs in returning_clause\r\n            // wherein schemas wouldn't have been resolvable at the time\r\n            // 2. Finalize output list for the last time, honouring given deSugaring level with regards to star selects \"*\"\r\n            // and ofcos finalize output schemas\r\n            const returningClauseJson = this.returningClause().finalizeJSON(resultJson.returning_clause, transformer, schemaInference, options);\r\n            // Apply now\r\n            resultJson = {\r\n                ...resultJson,\r\n                returning_clause: returningClauseJson,\r\n                result_schema: returningClauseJson.result_schema,\r\n            };\r\n        } else {\r\n            resultJson = {\r\n                ...resultJson,\r\n                result_schema: registry.JSONSchema.fromJSON({ entries: [] }, this.options),\r\n            };\r\n        }\r\n\r\n        return resultJson;\r\n    }\r\n}\r\n", "import { SelectorStmtMixin } from '../abstracts/SelectorStmtMixin.js';\nimport { Transformer } from '../Transformer.js';\nimport { DMLStmt } from './DMLStmt.js';\n\nexport class DeleteStmt extends SelectorStmtMixin(DMLStmt) {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'keyword', value: 'DELETE' },\n            {\n                assert: true,\n                syntaxes: [\n                    {\n                        dialect: 'postgres',\n                        syntax: [\n                            { type: 'keyword', value: 'FROM' },\n                            { type: 'TableAbstraction2', as: 'table_expr' },\n                            { type: 'UsingFromClause', as: 'pg_using_clause', optional: true, autoIndent: true },\n                            { type: 'JoinClause', as: 'join_clauses', arity: Infinity, optional: true, autoIndent: true },\n                            { type: ['PGWhereCurrentClause', 'WhereClause'], as: 'where_clause', optional: true, autoIndent: true },\n                            { type: 'ReturningClause', as: 'returning_clause', optional: true, autoIndent: true },\n                        ],\n                    },\n                    {\n                        dialect: 'mysql',\n                        syntax: [\n                            { type: 'Identifier', as: 'my_delete_list', arity: { min: 1 }, itemSeparator },\n                            { type: 'FromClause', as: 'my_from_clause', autoIndent: true },\n                            { type: 'JoinClause', as: 'join_clauses', arity: Infinity, optional: true, autoIndent: true },\n                            { type: 'WhereClause', as: 'where_clause', optional: true, autoIndent: true },\n                        ],\n                    },\n                    {\n                        dialect: 'mysql',\n                        syntax: [\n                            { type: 'keyword', value: 'FROM' },\n                            { type: 'Identifier', as: 'my_delete_list', arity: { min: 1 }, itemSeparator },\n                            { type: 'UsingFromClause', as: 'my_using_clause', autoIndent: true },\n                            { type: 'JoinClause', as: 'join_clauses', arity: Infinity, optional: true, autoIndent: true },\n                            { type: 'WhereClause', as: 'where_clause', optional: true, autoIndent: true },\n                        ],\n                    },\n                    {\n                        dialect: 'mysql',\n                        syntax: [\n                            { type: 'keyword', value: 'FROM' },\n                            { type: 'TableAbstraction2', as: 'table_expr' },\n                            { type: 'MYPartitionClause', as: 'my_partition_clause', optional: true, autoIndent: true },\n                            { type: 'WhereClause', as: 'where_clause', optional: true, autoIndent: true },\n                            { type: 'OrderByClause', as: 'my_order_by_clause', optional: true, dialect: 'mysql', autoIndent: true },\n                            { type: 'LimitClause', as: 'my_limit_clause', optional: true, dialect: 'mysql', autoIndent: true },\n                        ],\n                    }\n                ],\n            },\n        ];\n    }\n\n    /* AST API */\n\n    tableExpr() { return this._get('table_expr'); }\n\n    joinClauses() { return this._get('join_clauses'); }\n\n    whereClause() { return this._get('where_clause'); }\n\n    returningClause() { return this._get('returning_clause'); }\n\n    // -- Postgres\n\n    pgUsingClause() { return this._get('pg_using_clause'); }\n\n    // -- MySQL\n\n    myUsingClause() { return this._get('my_using_clause'); }\n\n    myPartitionClause() { return this._get('my_partition_clause'); }\n\n    myDeleteList() { return this._get('my_delete_list'); }\n\n    myFromClause() { return this._get('my_from_clause'); }\n\n    myOrderByClause() { return this._get('my_order_by_clause'); }\n\n    myLimitClause() { return this._get('my_limit_clause'); }\n\n    /* JSON API */\n\n    jsonfy(options = {}, transformer = null, schemaInference = null) {\n        if (!options.deSugar) return super.jsonfy(options, transformer, schemaInference);\n\n        transformer = new Transformer((node, defaultTransform) => {\n            return defaultTransform();\n        }, transformer, this/* IMPORTANT */);\n\n        let resultJson = super.jsonfy(options, transformer, schemaInference);\n\n        // Order ouput JSON\n        if ((options.toDialect || this.options.dialect) === 'mysql') {\n            resultJson = {\n                uuid: resultJson.uuid,\n                nodeName: resultJson.nodeName,\n                my_delete_list: resultJson.my_delete_list,\n                my_from_clause: resultJson.my_from_clause,\n                my_using_clause: resultJson.my_using_clause,\n                join_clauses: resultJson.join_clauses,\n                where_clause: resultJson.where_clause,\n                // last syntax\n                table_expr: resultJson.table_expr,\n                my_partition_clause: resultJson.my_partition_clause,\n                my_order_by_clause: resultJson.my_order_by_clause,\n                my_limit_clause: resultJson.my_limit_clause,\n                // Both...\n                returning_clause: resultJson.returning_clause,\n                result_schema: resultJson.result_schema,\n            };\n        } else {\n            resultJson = {\n                uuid: resultJson.uuid,\n                nodeName: resultJson.nodeName,\n                table_expr: resultJson.table_expr,\n                pg_using_clause: resultJson.pg_using_clause,\n                join_clauses: resultJson.join_clauses,\n                where_clause: resultJson.where_clause,\n                returning_clause: resultJson.returning_clause,\n                result_schema: resultJson.result_schema,\n            };\n        }\n\n        // 1. Finalize output JSON\n\t\tresultJson = this.finalizeOutputJSON(resultJson, transformer, schemaInference, options);\n        // 2. Finalize generated JOINS\n        resultJson = this.finalizeSelectorJSON(resultJson, transformer, schemaInference, options);\n        \n        resultJson = {\n\t\t\t...resultJson,\n\t\t\torigin_schemas: this.getOriginSchemas(transformer),\n\t\t};\n        \n        return resultJson;\n    }\n}", "import { Transformer } from '../Transformer.js';\nimport { registry } from '../registry.js';\nimport { _eq } from './util.js';\n\nexport const PayloadStmtMixin = (Class) => class extends Class {\n\n\tget isPayloadStmt() { return true; }\n\n\tstatic morphsTo() { return registry.CTE; }\n\n\t/* DESUGARING API */\n\n\tjsonfy(options = {}, transformer = null, schemaInference = null) {\n\t\tif (!options.deSugar) return super.jsonfy(options, transformer, schemaInference);\n\n\t\tconst {\n\t\t\tLQDeepRef2,\n\t\t\tAssignmentExpr,\n\t\t\tDerivedQuery,\n\t\t\tColumnsConstructor,\n\t\t\tValuesConstructor,\n\t\t\tTypedRowConstructor,\n\t\t\tRowConstructor,\n\t\t} = registry;\n\n\t\tconst specials = ['column_list', 'pg_default_values_clause', 'values_clause', 'select_clause'].map((s) => this._get(s));\n\t\tconst [columnList, pgDefaultValuesClause, valuesClause, selectClause] = specials;\n\t\tconst hasTopLevelDeepRefs = columnList?.entries().some((c) => c instanceof LQDeepRef2);\n\n\t\t// --- ASSIGNMENT EXPRS ---------------\n\n\t\tconst ignoreList = hasTopLevelDeepRefs ? new Set(specials) : new Set;\n\t\ttransformer = new Transformer((node, defaultTransform, keyHint, { deSugar/* EXCLUSION */, ...$options }) => {\n\n\t\t\t// IMPORTANT!!! The bellow tells the default jsonfier to ignore the nodes we'll handle manually\n\t\t\tif (ignoreList.has(node)) {\n\t\t\t\treturn; // Exclude in output\n\t\t\t}\n\n\t\t\t// We want to only desugar AssignmentExpr\n\t\t\tif (!(node instanceof AssignmentExpr)) {\n\t\t\t\treturn defaultTransform();\n\t\t\t}\n\n\t\t\t// Is this assignment expr from within \"conflict_handling_clause\"?\n\t\t\tconst conflictHandlingClauseContext = !!this._get('conflict_handling_clause')?.containsNode(node);\n\t\t\tif (conflictHandlingClauseContext && this.options.dialect !== 'postgres') {\n\t\t\t\treturn defaultTransform();\n\t\t\t}\n\n\t\t\tconst $$options = { ...$options, conflictHandlingClauseContext };\n\n\t\t\t// Handle bare assignment exoressions\n\t\t\tif (node.left() instanceof LQDeepRef2) {\n\t\t\t\tconst [[deSugaredLhs], [[deSugaredRhs]]] = this.deSugarPayload(\n\t\t\t\t\tColumnsConstructor.fromJSON({ entries: [node.left().jsonfy()] }),\n\t\t\t\t\t[[node.right()]],\n\t\t\t\t\ttransformer,\n\t\t\t\t\tschemaInference,\n\t\t\t\t\t$$options,\n\t\t\t\t);\n\t\t\t\tif (!deSugaredLhs) return; // Exclude in output\n\t\t\t\treturn {\n\t\t\t\t\tnodeName: AssignmentExpr.NODE_NAME,\n\t\t\t\t\toperator: '=',\n\t\t\t\t\tleft: deSugaredLhs,\n\t\t\t\t\tright: deSugaredRhs,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Handle compound assignment exoressions\n\t\t\tif (node.left() instanceof ColumnsConstructor // Postgres\n\t\t\t\t&& node.left().entries().some((c) => c instanceof LQDeepRef2)) {\n\n\t\t\t\tconst columnList = node.left();\n\t\t\t\tlet deSugaredLhs,\n\t\t\t\t\tdeSugaredRhs;\n\n\t\t\t\tif (node.right() instanceof RowConstructor/* Still passes even for TypedRowConstructor */) {\n\t\t\t\t\t[deSugaredLhs, [deSugaredRhs]] = this.deSugarPayload(\n\t\t\t\t\t\tcolumnList,\n\t\t\t\t\t\t[node.right().entries()],\n\t\t\t\t\t\ttransformer,\n\t\t\t\t\t\tschemaInference,\n\t\t\t\t\t\t$$options,\n\t\t\t\t\t);\n\t\t\t\t\tdeSugaredRhs = { nodeName: TypedRowConstructor.NODE_NAME/* To be really formal */, entries: deSugaredRhs };\n\t\t\t\t} else if (node.right() instanceof DerivedQuery) {\n\t\t\t\t\t[deSugaredLhs, deSugaredRhs] = this.deSugarPayload(\n\t\t\t\t\t\tcolumnList,\n\t\t\t\t\t\tnode.right().expr(),\n\t\t\t\t\t\ttransformer,\n\t\t\t\t\t\tschemaInference,\n\t\t\t\t\t\t$$options,\n\t\t\t\t\t);\n\t\t\t\t\tdeSugaredRhs = { nodeName: DerivedQuery.NODE_NAME, expr: deSugaredRhs };\n\t\t\t\t} else {\n\t\t\t\t\t[deSugaredLhs, [deSugaredRhs]] = this.deSugarPayload(\n\t\t\t\t\t\tcolumnList,\n\t\t\t\t\t\t[[node.right()]],\n\t\t\t\t\t\ttransformer,\n\t\t\t\t\t\tschemaInference,\n\t\t\t\t\t\t$$options,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif (!deSugaredLhs.length) return; // Exclude in output\n\t\t\t\treturn {\n\t\t\t\t\tnodeName: AssignmentExpr.NODE_NAME,\n\t\t\t\t\toperator: '=',\n\t\t\t\t\tleft: { nodeName: ColumnsConstructor.NODE_NAME, entries: deSugaredLhs },\n\t\t\t\t\tright: deSugaredRhs,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn defaultTransform();\n\t\t}, transformer, this/* IMPORTANT */);\n\n\t\t// Base JSON\n\t\tlet resultJson = super.jsonfy(options, transformer, schemaInference);\n\n\t\t// --- TOP-LEVEL COLUMNS:VALUES/SELECT ---------------\n\n\t\t// Manually jsonfy these\n\t\tif (hasTopLevelDeepRefs) {\n\t\t\tconst [deSugaredLhs, deSugaredRhs] = this.deSugarPayload(\n\t\t\t\tcolumnList,\n\t\t\t\tpgDefaultValuesClause || valuesClause?.entries().map((rowSet) => rowSet.entries()) || selectClause,\n\t\t\t\ttransformer,\n\t\t\t\tschemaInference,\n\t\t\t\toptions,\n\t\t\t);\n\n\t\t\tresultJson = {\n\t\t\t\t...resultJson,\n\t\t\t\tcolumn_list: { nodeName: ColumnsConstructor.NODE_NAME, entries: deSugaredLhs },\n\t\t\t};\n\n\t\t\tif (pgDefaultValuesClause && Array.isArray(deSugaredRhs) || valuesClause) {\n\t\t\t\tconst rowsJson = deSugaredRhs.map((rowSetJson) => ({ nodeName: TypedRowConstructor.NODE_NAME/* Most cross-dialect */, entries: rowSetJson }));\n\t\t\t\tresultJson = {\n\t\t\t\t\t...resultJson,\n\t\t\t\t\tvalues_clause: { nodeName: ValuesConstructor.NODE_NAME, entries: rowsJson },\n\t\t\t\t};\n\t\t\t} else if (pgDefaultValuesClause) {\n\t\t\t\tresultJson = { ...resultJson, pg_default_values_clause: deSugaredRhs };\n\t\t\t} else {\n\t\t\t\tresultJson = { ...resultJson, select_clause: deSugaredRhs };\n\t\t\t}\n\t\t}\n\n\t\treturn resultJson;\n\t}\n\n\tdeSugarPayload(columns, values, transformer, schemaInference, { conflictHandlingClauseContext = false, deSugar, ...$options } = {}) {\n\t\tconst payloadDimensions = transformer.statementContext.artifacts.get('payloadDimensions');\n\n\t\tconst {\n\t\t\tLQDeepRef2,\n\t\t\tTableRef1,\n\t\t\tColumnRef1,\n\t\t\tSelectItemAlias,\n\t\t\tColumnRef2,\n\t\t\tColumnsConstructor,\n\t\t\tTypedRowConstructor,\n\t\t\tRowConstructor,\n\t\t\tDefaultLiteral,\n\t\t\tSelectStmt,\n\t\t\tCompleteSelectStmt,\n\t\t\tPGDefaultValuesClause,\n\t\t\tSelectList,\n\t\t\tSelectItem,\n\t\t\tFromClause,\n\t\t\tFromItem,\n\t\t} = registry;\n\n\t\tconst jsonfy = (node, _deSugar = deSugar) => {\n\t\t\treturn node.jsonfy({ ...$options, deSugar: _deSugar }, transformer, schemaInference);\n\t\t};\n\n\t\t// (1): Columns\n\t\tconst deSugarColumnsList = (columnList, dimensionsMap) => {\n\t\t\treturn columnList.entries().reduce((columnList, columnRef, columnOffset) => {\n\t\t\t\tif (columnRef instanceof LQDeepRef2) {\n\n\t\t\t\t\tconst dimension = this.createPayloadDimension(columnRef, transformer, schemaInference, { conflictHandlingClauseContext, ...$options });\n\t\t\t\t\tdimensionsMap.set(columnOffset, dimension);\n\n\t\t\t\t\tif (dimension.refMode === 'dependency' && dimension.lhsOperandJson) {\n\t\t\t\t\t\treturn columnList.concat({\n\t\t\t\t\t\t\tnodeName: ColumnRef2.NODE_NAME,\n\t\t\t\t\t\t\tvalue: dimension.lhsOperandJson.value,\n\t\t\t\t\t\t\tdelim: dimension.lhsOperandJson.delim,\n\t\t\t\t\t\t\tresult_schema: dimension.lhsOperandJson.result_schema,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\treturn columnList;\n\t\t\t\t}\n\n\t\t\t\treturn columnList.concat(jsonfy(columnRef));\n\t\t\t}, []);\n\t\t};\n\n\t\t// (2.a): Default Values\n\t\tconst deSugarValuesFromDefaultValues = (pgDefaultValuesClause, dimensionsMap) => {\n\t\t\tconst valuesRow = columns.entries().reduce((valuesRow, columnRef, columnOffset) => {\n\t\t\t\tconst valueJson = dimensionsMap.has(columnOffset)\n\t\t\t\t\t? dimensionsMap.get(columnOffset).offload(pgDefaultValuesClause)\n\t\t\t\t\t: { nodeName: DefaultLiteral.NODE_NAME, value: 'DEFAULT' };\n\t\t\t\treturn valueJson\n\t\t\t\t\t? valuesRow.concat(valueJson)\n\t\t\t\t\t: valuesRow;\n\t\t\t}, []);\n\n\t\t\tif (columns.length - valuesRow.length === dimensionsMap.size) {\n\t\t\t\t// There were no depencies; only dependents\n\t\t\t\treturn pgDefaultValuesClause.jsonfy();\n\t\t\t}\n\n\t\t\t// There were depencies\n\t\t\treturn [valuesRow];\n\t\t};\n\n\t\t// (2.b): Values\n\t\tconst deSugarValuesFromValues = (valuesEntries, dimensionsMap) => {\n\t\t\treturn valuesEntries.map((valuesRow, rowOffset) => {\n\t\t\t\treturn valuesRow.reduce((valuesRow, valueNode, columnOffset) => {\n\t\t\t\t\tlet valueJson;\n\t\t\t\t\tif (columns.get(columnOffset) instanceof LQDeepRef2 && valueNode instanceof DefaultLiteral) {\n\t\t\t\t\t\tvalueJson = dimensionsMap.get(columnOffset).offload(\n\t\t\t\t\t\t\tPGDefaultValuesClause.fromJSON({ value: 'DEFAULT' }, this.options),\n\t\t\t\t\t\t\trowOffset\n\t\t\t\t\t\t);\n\t\t\t\t\t} else if (dimensionsMap.has(columnOffset)) {\n\t\t\t\t\t\tvalueJson = dimensionsMap.get(columnOffset).offload(valueNode, rowOffset);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalueJson = jsonfy(valueNode);\n\t\t\t\t\t}\n\t\t\t\t\treturn valueJson\n\t\t\t\t\t\t? valuesRow.concat(valueJson)\n\t\t\t\t\t\t: valuesRow;\n\t\t\t\t}, []);\n\t\t\t});\n\t\t};\n\n\t\t// (2.c): Select\n\t\tconst deSugarValuesFromSelect = (selectStmt, dimensionsMap) => {\n\t\t\t// Declare base SELECT and select list\n\t\t\tlet baseSelect = { ...jsonfy(selectStmt, 2), result_schema: undefined };\n\t\t\tlet baseSelectItems = baseSelect.select_list.entries;\n\n\t\t\tif (baseSelectItems.length !== columns.length) {\n\t\t\t\tthrow new Error(`Select list (${baseSelectItems.length}) does not match columns length (${columns.length})`);\n\t\t\t}\n\n\t\t\t// Create a CTE entry?\n\t\t\tlet memoSelect;\n\t\t\tif (!conflictHandlingClauseContext\n\t\t\t\t&& baseSelect.from_clause\n\t\t\t\t&& !/^[`\"]\\$memo~.+[`\"]$/.test(selectStmt.fromClause().entries()[0].expr() + '')) {\n\t\t\t\tconst memoSelectAlias = transformer.rootContext.rand('memo');\n\t\t\t\tmemoSelect = {\n\t\t\t\t\t...baseSelect,\n\t\t\t\t\tuuid: memoSelectAlias,\n\t\t\t\t\tselect_list: { nodeName: SelectList.NODE_NAME, entries: [rowNumberExpr('$row_number~a')] },\n\t\t\t\t};\n\t\t\t\tpayloadDimensions.add({ refMode: 'memo', query: memoSelect });\n\n\t\t\t\tconst newBaseSelectFromItem = { nodeName: FromItem.NODE_NAME, expr: { nodeName: TableRef1.NODE_NAME, value: memoSelectAlias } };\n\t\t\t\tbaseSelect = {\n\t\t\t\t\tnodeName: CompleteSelectStmt.NODE_NAME,\n\t\t\t\t\tselect_list: { nodeName: SelectList.NODE_NAME, entries: [] },\n\t\t\t\t\tfrom_clause: { nodeName: FromClause.NODE_NAME, entries: [newBaseSelectFromItem] },\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Resolve base select list\n\t\t\tconst rewriteAgainstMemoSelect = (fieldJson, obfuscateAlias = false) => {\n\t\t\t\tif (!memoSelect) return fieldJson;\n\t\t\t\tif (fieldJson.alias && obfuscateAlias) {\n\t\t\t\t\tfieldJson = {\n\t\t\t\t\t\t...fieldJson,\n\t\t\t\t\t\talias: { ...fieldJson.alias, value: fieldJson.alias.value + transformer.rand('rand', { asSalt: true }) },\n\t\t\t\t\t};\n\t\t\t\t} else if (!fieldJson.alias) {\n\t\t\t\t\tfieldJson.alias = { nodeName: SelectItemAlias.NODE_NAME, as_kw: true, value: transformer.rand('value') };\n\t\t\t\t}\n\t\t\t\tmemoSelect.select_list.entries.push(fieldJson);\n\t\t\t\treturn {\n\t\t\t\t\tnodeName: SelectItem.NODE_NAME,\n\t\t\t\t\texpr: { nodeName: ColumnRef1.NODE_NAME, value: fieldJson.alias.value, delim: fieldJson.alias.delim },\n\t\t\t\t};\n\t\t\t};\n\n\t\t\tconst newBaseSelectList = baseSelectItems.reduce((selectList, fieldJson, columnOffset) => {\n\t\t\t\tif (dimensionsMap.has(columnOffset)) {\n\t\t\t\t\tlet subSelectItems;\n\n\t\t\t\t\tif ([TypedRowConstructor.NODE_NAME, RowConstructor.NODE_NAME].includes(fieldJson.expr.nodeName)) {\n\t\t\t\t\t\tsubSelectItems = fieldJson.expr.entries.map((entryJson) => {\n\t\t\t\t\t\t\treturn rewriteAgainstMemoSelect({\n\t\t\t\t\t\t\t\tnodeName: SelectItem.NODE_NAME,\n\t\t\t\t\t\t\t\texpr: entryJson,\n\t\t\t\t\t\t\t\talias: fieldJson.alias,\n\t\t\t\t\t\t\t}, true);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (!(columns.get(columnOffset).right() instanceof ColumnsConstructor)) {\n\t\t\t\t\t\t\tsubSelectItems = [{\n\t\t\t\t\t\t\t\tnodeName: SelectItem.NODE_NAME,\n\t\t\t\t\t\t\t\texpr: { nodeName: TypedRowConstructor.NODE_NAME, entries: subSelectItems.map((s) => s.expr) },\n\t\t\t\t\t\t\t}];\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsubSelectItems = [rewriteAgainstMemoSelect(fieldJson)];\n\t\t\t\t\t}\n\n\t\t\t\t\tconst valueNode = SelectStmt.fromJSON({\n\t\t\t\t\t\t...baseSelect,\n\t\t\t\t\t\tselect_list: { nodeName: SelectList.NODE_NAME, entries: subSelectItems },\n\t\t\t\t\t}, this.options);\n\n\t\t\t\t\tfieldJson = dimensionsMap.get(columnOffset).offload(valueNode);\n\n\t\t\t\t\tif (fieldJson) {\n\t\t\t\t\t\tconst lhsOperandJson = dimensionsMap.get(columnOffset).lhsOperandJson;\n\t\t\t\t\t\treturn selectList.concat({\n\t\t\t\t\t\t\tnodeName: SelectItem.NODE_NAME,\n\t\t\t\t\t\t\texpr: fieldJson,\n\t\t\t\t\t\t\talias: { nodeName: SelectItemAlias.NODE_NAME, as_kw: true, value: lhsOperandJson.value, delim: lhsOperandJson.delim }\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\treturn selectList;\n\t\t\t\t}\n\n\t\t\t\tif (!fieldJson.alias) {\n\t\t\t\t\tconst correspondingColumn = columns.get(columnOffset);\n\t\t\t\t\tfieldJson = {\n\t\t\t\t\t\t...fieldJson,\n\t\t\t\t\t\talias: { nodeName: SelectItemAlias.NODE_NAME, as_kw: true, value: correspondingColumn.value(), delim: correspondingColumn._get('delim') },\n\t\t\t\t\t};\n\t\t\t\t};\n\n\t\t\t\treturn selectList.concat(rewriteAgainstMemoSelect(fieldJson));\n\t\t\t}, []);\n\n\t\t\tbaseSelect = {\n\t\t\t\t...baseSelect,\n\t\t\t\tselect_list: {\n\t\t\t\t\tnodeName: SelectList.NODE_NAME,\n\t\t\t\t\tentries: newBaseSelectList,\n\t\t\t\t},\n\t\t\t}\n\n\t\t\treturn baseSelect;\n\t\t};\n\n\t\t// Process...\n\t\tconst dimensionsMap = new Map;\n\t\tconst deSugaredLhs = deSugarColumnsList(columns, dimensionsMap);\n\n\t\tconst deSugaredRhs = values instanceof PGDefaultValuesClause\n\t\t\t? deSugarValuesFromDefaultValues(values, dimensionsMap)\n\t\t\t: (values instanceof SelectStmt\n\t\t\t\t? deSugarValuesFromSelect(values, dimensionsMap)\n\t\t\t\t: deSugarValuesFromValues(values, dimensionsMap));\n\n\t\tdimensionsMap.clear();\n\n\t\treturn [deSugaredLhs, deSugaredRhs];\n\t}\n\n\tcreatePayloadDimension(LQRefColumn, transformer, schemaInference, { conflictHandlingClauseContext = false, ...$options } = {}) {\n\t\tconst { lhsOperand, rhsOperand, rhsTable, detail } = LQRefColumn.resolve(transformer, schemaInference, 2);\n\t\tconst payloadDimensions = transformer.statementContext.artifacts.get('payloadDimensions');\n\n\t\tconst {\n\t\t\tLQDeepRef2,\n\t\t\tLQBackRefAbstraction,\n\t\t\tReturningClause,\n\t\t\tColumnRef2,\n\t\t\tColumnRef1,\n\t\t\tTableRef1,\n\t\t\tSelectList,\n\t\t\tSelectItem,\n\t\t\tSelectItemAlias,\n\t\t\tAssignmentExpr,\n\t\t\tColumnsConstructor,\n\t\t\tTypedRowConstructor,\n\t\t\tRowConstructor,\n\t\t\tPGDefaultValuesClause,\n\t\t\tValuesConstructor,\n\t\t\tValuesTableLiteral,\n\t\t\tDefaultLiteral,\n\t\t\tSelectStmt,\n\t\t\tWhereClause,\n\t\t\tCompleteSelectStmt,\n\t\t\tScalarSubquery,\n\t\t\tDerivedQuery,\n\t\t\tFromItem,\n\t\t\tFromClause,\n\t\t\tSetClause,\n\t\t\tBinaryExpr,\n\t\t\tBoolLiteral,\n\t\t\tNumberLiteral,\n\t\t\tUpdateStmt,\n\t\t\tTableAbstraction2,\n\t\t} = registry;\n\n\t\tconst baseUUID = transformer.rootContext.hash(this, 'main');\n\t\tconst jsonfy = (node) => {\n\t\t\treturn node.jsonfy($options, transformer, schemaInference);\n\t\t};\n\n\t\tconst lhsOperandJson = jsonfy(lhsOperand);\n\t\tconst rhsOperandJson = jsonfy(rhsOperand);\n\t\tconst rhsTableJson = jsonfy(rhsTable);\n\n\t\tconst lhsOperand1Json = lhsOperand.jsonfy({ toKind: 1 });\n\t\tconst rhsOperand1Json = rhsOperand.jsonfy({ toKind: 1 });\n\t\tconst rhsTable1Json = { ...rhsTableJson, nodeName: TableRef1.NODE_NAME };\n\t\tconst refMode = LQRefColumn.left() instanceof LQBackRefAbstraction\n\t\t\t? 'dependent'\n\t\t\t: 'dependency';\n\t\tconst isDeepRef = detail instanceof LQDeepRef2;\n\n\t\t// Figure the expected payload structure\n\t\tlet columnsConstructorJson;\n\t\tif (detail instanceof ColumnsConstructor) {\n\t\t\tcolumnsConstructorJson = jsonfy(detail);\n\t\t} else if (detail instanceof ColumnRef2 || detail instanceof LQDeepRef2) {\n\t\t\tcolumnsConstructorJson = { nodeName: ColumnsConstructor.NODE_NAME, entries: [jsonfy(detail)] };\n\t\t} else {\n\t\t\tthrow new Error(`Invalid columns spec: ${LQRefColumn}`);\n\t\t}\n\n\t\t// Payload structure length validity\n\t\tconst columnsLength = columnsConstructorJson.entries.length;\n\t\tconst dimensionValidateRowLength = (rowNode, result_schema = null) => {\n\t\t\tif (isDeepRef) return rowNode;\n\t\t\tlet rowLength = 1;\n\t\t\tif (result_schema) {\n\t\t\t\trowLength = result_schema.length;\n\t\t\t} else if (rowNode instanceof RowConstructor || rowNode instanceof SelectStmt) {\n\t\t\t\trowLength = rowNode.length;\n\t\t\t} else if (rowNode instanceof SelectStmt) {\n\t\t\t\trowLength = rowNode.length;\n\t\t\t} else if (rowNode instanceof DerivedQuery) {\n\t\t\t\trowLength = rowNode.expr().length;\n\t\t\t}\n\t\t\tif (rowLength > columnsLength) throw new Error(`[${rowNode}] Payload has more columns than target columns: ${detail}.`);\n\t\t\tif (rowLength < columnsLength) throw new Error(`[${rowNode}] Payload has fewer columns than target columns: ${detail}.`);\n\t\t\treturn rowNode;\n\t\t};\n\n\t\t// Compose:\n\t\t// - (SELECT <sourceCol> FROM <sourceUuid> WHERE <rand> = <sourceRowIndex>)\n\t\tconst createForeignBinding = (sourceUuid, sourceCol, sourceRowIndex = null, innerFilter = null) => {\n\t\t\tlet whereExpr;\n\t\t\tlet whereExprRhs;\n\n\t\t\tif (typeof sourceRowIndex === 'number') {\n\t\t\t\twhereExprRhs = { nodeName: NumberLiteral.NODE_NAME, value: sourceRowIndex + 1 };\n\t\t\t} else if (sourceRowIndex) {\n\t\t\t\twhereExprRhs = sourceRowIndex;\n\t\t\t}\n\n\t\t\tif (whereExprRhs) {\n\t\t\t\twhereExpr = {\n\t\t\t\t\tnodeName: BinaryExpr.NODE_NAME,\n\t\t\t\t\tleft: { nodeName: ColumnRef1.NODE_NAME, value: '$row_number~b' },\n\t\t\t\t\toperator: '=',\n\t\t\t\t\tright: whereExprRhs,\n\t\t\t\t};\n\t\t\t} else if (innerFilter) {\n\t\t\t\twhereExpr = {\n\t\t\t\t\tnodeName: BinaryExpr.NODE_NAME,\n\t\t\t\t\tleft: { nodeName: ColumnRef1.NODE_NAME, value: innerFilter },\n\t\t\t\t\toperator: 'IS',\n\t\t\t\t\tright: { nodeName: BoolLiteral.NODE_NAME, value: 'TRUE' },\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tconst tableSpec = {\n\t\t\t\tnodeName: FromItem.NODE_NAME,\n\t\t\t\texpr: { nodeName: TableRef1.NODE_NAME, value: whereExprRhs ? `${sourceUuid}~indices` : sourceUuid },\n\t\t\t};\n\n\t\t\tconst selectStmt = {\n\t\t\t\tnodeName: CompleteSelectStmt.NODE_NAME,\n\t\t\t\tselect_list: { nodeName: SelectList.NODE_NAME, entries: [{ nodeName: SelectItem.NODE_NAME, expr: { ...sourceCol, qualifier: undefined } }] },\n\t\t\t\tfrom_clause: { nodeName: FromClause.NODE_NAME, entries: [tableSpec] },\n\t\t\t\twhere_clause: whereExpr && { nodeName: WhereClause.NODE_NAME, expr: whereExpr },\n\t\t\t};\n\n\t\t\treturn { nodeName: ScalarSubquery.NODE_NAME, expr: selectStmt };\n\t\t};\n\n\t\t// --- UPDATE -------------\n\n\t\tif (this instanceof UpdateStmt || conflictHandlingClauseContext) {\n\n\t\t\t// UPDATE t1 SET (a, (fk <~ fk <~ t2) ~> (a, b)) = ROW(2, ROW(44, 33))\n\t\t\t// UPDATE t1 SET (a, (fk <~ fk <~ t2) ~> a) = ROW(2, ROW(44, 33))\n\t\t\t// UPDATE t1 SET (a, (fk <~ fk <~ t2) ~> a) = (SELECT a, b FROM t3)\n\t\t\t// UPDATE t1 SET (a, fk ~> fk ~> (a, b)) = ROW(2, ROW(44, 33))\n\t\t\t// UPDATE t1 SET (a, fk ~> fk ~> a) = ROW(2, ROW(44, 33))\n\t\t\t// UPDATE t1 SET (a, fk ~> fk ~> a) = (SELECT a, b FROM t3)\n\n\t\t\t// Here we want to compose:\n\t\t\t// - WHERE <rhsOperandJson> IN (SELECT <lhsOperandJson> FROM <baseUUID> [WHERE <conflict_based_update> IS TRUE]? )\n\t\t\tconst onConflictUpdatedStatusAlias = conflictHandlingClauseContext\n\t\t\t\t? `${baseUUID}_conflict_based_update` : null;\n\n\t\t\tconst whereClause = {\n\t\t\t\tnodeName: BinaryExpr.NODE_NAME,\n\t\t\t\tleft: rhsOperand1Json,\n\t\t\t\toperator: 'IN',\n\t\t\t\tright: createForeignBinding(baseUUID, lhsOperandJson, null, onConflictUpdatedStatusAlias),\n\t\t\t};\n\n\t\t\tconst query = {\n\t\t\t\tuuid: transformer.rootContext.rand(refMode),\n\t\t\t\tnodeName: UpdateStmt.NODE_NAME,\n\t\t\t\ttable_expr: { nodeName: TableAbstraction2.NODE_NAME, table_ref: rhsTable1Json },\n\t\t\t\tset_clause: { nodeName: SetClause.NODE_NAME, entries: [] },\n\t\t\t\twhere_clause: { nodeName: WhereClause.NODE_NAME, expr: whereClause },\n\t\t\t};\n\n\t\t\tconst offload = (payload) => {\n\t\t\t\tif (payload instanceof ValuesTableLiteral) {\n\t\t\t\t\tthrow new Error(`Single-row payload structure expected for column structure: ${detail}. Recieved ${payload.NODE_NAME}.`);\n\t\t\t\t}\n\t\t\t\tif (query.set_clause.entries.length) {\n\t\t\t\t\tthrow new Error(`Unexpected multiple offload() call on ${LQRefColumn}`);\n\t\t\t\t}\n\n\t\t\t\t// Carry deep values forward\n\t\t\t\tlet payloadJson = jsonfy(payload);\n\t\t\t\tif (isDeepRef && !(payload instanceof PGDefaultValuesClause)) {\n\t\t\t\t\tpayload = TypedRowConstructor.fromJSON({ entries: [payloadJson] }, this.options);\n\t\t\t\t\tpayloadJson = jsonfy(payload);\n\t\t\t\t}\n\n\t\t\t\tif (payload instanceof SelectStmt) {\n\t\t\t\t\tpayloadJson = { nodeName: DerivedQuery.NODE_NAME, expr: payloadJson, result_schema: payloadJson.result_schema };\n\t\t\t\t\tdimensionValidateRowLength(payload, payloadJson.result_schema);\n\t\t\t\t} else if (payload instanceof DerivedQuery) {\n\t\t\t\t\tdimensionValidateRowLength(payload, payloadJson.result_schema);\n\t\t\t\t} else if (payload instanceof RowConstructor) {\n\t\t\t\t\tdimensionValidateRowLength(payload);\n\t\t\t\t} else if (!(payload instanceof PGDefaultValuesClause)) {\n\t\t\t\t\tpayloadJson = { nodeName: TypedRowConstructor.NODE_NAME/* most formal */, entries: [payloadJson] };\n\t\t\t\t}\n\n\t\t\t\tquery.set_clause.entries.push({\n\t\t\t\t\tnodeName: AssignmentExpr.NODE_NAME,\n\t\t\t\t\tleft: columnsConstructorJson,\n\t\t\t\t\toperator: '=',\n\t\t\t\t\tright: payloadJson,\n\t\t\t\t});\n\n\t\t\t\tif (refMode === 'dependency') {\n\t\t\t\t\treturn lhsOperand1Json;\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tconst payloadDimension = {\n\t\t\t\trefMode,\n\t\t\t\tquery,\n\t\t\t\toffload,\n\t\t\t\tlhsOperandJson,\n\t\t\t\tconflictHandlingClauseContext\n\t\t\t};\n\t\t\tpayloadDimensions.add(payloadDimension);\n\n\t\t\treturn payloadDimension;\n\t\t}\n\n\t\t// --- INSERT/UPSERT -------------\n\n\t\tconst queries = [];\n\n\t\t// This is for all INSERT types\n\t\tconst dimensionPushRow = (query, payload, fKBindingJson = null) => {\n\t\t\tif (payload instanceof PGDefaultValuesClause) {\n\t\t\t\tif (fKBindingJson) {\n\t\t\t\t\tconst lastIndex = query.column_list.entries.length - 1;\n\t\t\t\t\tquery.values_clause.entries.push({\n\t\t\t\t\t\tnodeName: TypedRowConstructor.NODE_NAME/* most formal */,\n\t\t\t\t\t\tentries: query.column_list.entries.map((c, i) => {\n\t\t\t\t\t\t\treturn i === lastIndex\n\t\t\t\t\t\t\t\t? fKBindingJson\n\t\t\t\t\t\t\t\t: { nodeName: DefaultLiteral.NODE_NAME, value: 'DEFAULT' };\n\t\t\t\t\t\t}),\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tdelete query.values_clause;\n\t\t\t\t\tquery.pg_default_values_clause = jsonfy(payload);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdimensionValidateRowLength(payload);\n\t\t\t\tlet rowJson = jsonfy(payload);\n\t\t\t\tif (!(payload instanceof RowConstructor)) {\n\t\t\t\t\trowJson = { nodeName: TypedRowConstructor.NODE_NAME/* most formal */, entries: [rowJson] };\n\t\t\t\t}\n\t\t\t\tif (fKBindingJson) {\n\t\t\t\t\trowJson = { ...rowJson, entries: rowJson.entries.concat(fKBindingJson) };\n\t\t\t\t}\n\t\t\t\tquery.values_clause.entries.push(rowJson);\n\t\t\t}\n\t\t};\n\n\t\t// BackRefing INSERTS\n\t\tif (refMode === 'dependent') {\n\n\t\t\t// INSERT INTO t1 (a, (fk <~ fk <~ t2) ~> (a, b)) VALUES (2, ROW(44, 33)), (3, ROW(11, 22))\n\t\t\t// INSERT INTO t1 (a, (fk <~ fk <~ t2) ~> a) VALUES (2, 44), (3, 11)\n\t\t\t// INSERT INTO t1 (a, (fk <~ fk <~ t2) ~> a) SELECT a, b FROM t3\n\n\t\t\tconst queryTemplate = () => ({\n\t\t\t\tuuid: transformer.rootContext.rand(refMode),\n\t\t\t\tnodeName: this.NODE_NAME,\n\t\t\t\ttable_ref: rhsTableJson,\n\t\t\t\tcolumn_list: ColumnsConstructor.fromJSON({ entries: columnsConstructorJson.entries.concat(rhsOperandJson) }).jsonfy(),\n\t\t\t});\n\n\t\t\tconst selectForeignBinding = (selectJson, fKBindingJson) => {\n\t\t\t\tconst fkField = {\n\t\t\t\t\tnodeName: SelectItem.NODE_NAME,\n\t\t\t\t\texpr: fKBindingJson,\n\t\t\t\t\talias: rhsOperand instanceof ColumnRef2\n\t\t\t\t\t\t? { nodeName: SelectItemAlias.NODE_NAME, as_kw: true, value: rhsOperand.value(), delim: rhsOperand._get('delim') }\n\t\t\t\t\t\t: undefined,\n\t\t\t\t};\n\t\t\t\treturn {\n\t\t\t\t\t...selectJson,\n\t\t\t\t\tselect_list: { ...selectJson.select_list, entries: selectJson.select_list.entries.concat(fkField) },\n\t\t\t\t};\n\t\t\t};\n\n\t\t\tconst offload = (payload, correlationRhs = null) => {\n\n\t\t\t\tif (!queries.length) {\n\t\t\t\t\tqueries.push(queryTemplate());\n\t\t\t\t}\n\t\t\t\tlet currentQuery = queries[queries.length - 1];\n\n\t\t\t\tif (payload instanceof SelectStmt) {\n\t\t\t\t\t// Meaning we're from a literal INSERT ... SELECT statement, not an INSERT ... VALUES (+SELECT) statement\n\t\t\t\t\t// and this time, we want to correlate with base query's row number\n\t\t\t\t\tcorrelationRhs = {\n\t\t\t\t\t\tnodeName: ColumnRef1.NODE_NAME,\n\t\t\t\t\t\tvalue: '$row_number~a',\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tconst fKBindingJson = createForeignBinding(baseUUID, lhsOperandJson, correlationRhs);\n\n\t\t\t\t// Scenario 2:\n\t\t\t\t// When the base query is an INSERT ... VALUES (+DerivedQuery)\n\t\t\t\tlet isDerivedQuery;\n\t\t\t\tif (payload instanceof DerivedQuery) {\n\t\t\t\t\tpayload = payload.expr();\n\t\t\t\t\t// For when preceding offload() was scenario 2 or 3\n\t\t\t\t\tif (currentQuery.select_clause || currentQuery.values_clause) {\n\t\t\t\t\t\tcurrentQuery = queryTemplate();\n\t\t\t\t\t\tqueries.push(currentQuery);\n\t\t\t\t\t}\n\t\t\t\t\tisDerivedQuery = true;\n\t\t\t\t}\n\n\t\t\t\t// Scenario 1 or 2:\n\t\t\t\t// When the base query is an INSERT ... SELECT\n\t\t\t\t// or when the preceding scenario is the case\n\t\t\t\tif (payload instanceof SelectStmt) {\n\t\t\t\t\tlet selectJson = jsonfy(payload);\n\t\t\t\t\tif (!isDerivedQuery && !isDeepRef) {\n\t\t\t\t\t\t// Fully qualify output names to match target column names. Not necessary at the LinkedQL level\n\t\t\t\t\t\tselectJson = deriveSelectAliasesFromColumns(selectJson, columnsConstructorJson);\n\t\t\t\t\t}\n\t\t\t\t\tdimensionValidateRowLength(payload, selectJson.result_schema);\n\t\t\t\t\tcurrentQuery.select_clause = selectForeignBinding(selectJson, fKBindingJson);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Scenario 3:\n\t\t\t\t// When base query is INSERT ... VALUES\n\n\t\t\t\t// For when preceding offload() was scenario 2\n\t\t\t\tif (currentQuery.select_clause) {\n\t\t\t\t\tcurrentQuery = queryTemplate();\n\t\t\t\t\tqueries.push(currentQuery);\n\t\t\t\t}\n\t\t\t\tif (!currentQuery.values_clause) {\n\t\t\t\t\tcurrentQuery.values_clause = { nodeName: ValuesConstructor.NODE_NAME, entries: [] };\n\t\t\t\t}\n\n\t\t\t\t// Carry deep values forward\n\t\t\t\tif (isDeepRef && !(payload instanceof PGDefaultValuesClause)) {\n\t\t\t\t\tpayload = TypedRowConstructor.fromJSON({ entries: [jsonfy(payload)] });\n\t\t\t\t}\n\n\t\t\t\tif (payload instanceof ValuesTableLiteral) {\n\t\t\t\t\tfor (const rowNode of payload.entries()) {\n\t\t\t\t\t\tdimensionPushRow(currentQuery, rowNode, fKBindingJson);\n\t\t\t\t\t}\n\t\t\t\t} else dimensionPushRow(currentQuery, payload, fKBindingJson);\n\t\t\t};\n\n\t\t\tconst payloadDimension = {\n\t\t\t\trefMode,\n\t\t\t\tqueries,\n\t\t\t\toffload,\n\t\t\t\tlhsOperandJson,\n\t\t\t};\n\n\t\t\tpayloadDimensions.add(payloadDimension);\n\n\t\t\treturn payloadDimension;\n\t\t}\n\n\t\t// INSERT INTO t1 (a, t2 ~> fk ~> (a, b)) VALUES (2, ROW(44, 33)), (3, ROW(11, 22))\n\t\t// INSERT INTO t1 (a, t2 ~> fk ~> a) VALUES (2, 44), (3, 11)\n\t\t// INSERT INTO t1 (a, t2 ~> fk ~> a) SELECT a, b FROM t3\n\n\t\t// The binding elements...\n\t\tconst rhsOperandPKJson = { nodeName: ColumnRef1.NODE_NAME, value: rhsOperand.value(), delim: rhsOperand._get('delim') };\n\n\t\tconst queryTemplate = () => ({\n\t\t\tuuid: transformer.rootContext.rand(refMode),\n\t\t\tnodeName: this.NODE_NAME,\n\t\t\ttable_ref: rhsTableJson,\n\t\t\tcolumn_list: columnsConstructorJson,\n\t\t\treturning_clause: {\n\t\t\t\tnodeName: ReturningClause.NODE_NAME,\n\t\t\t\tentries: [{ nodeName: SelectItem.NODE_NAME, expr: rhsOperand1Json }],\n\t\t\t},\n\t\t});\n\n\t\tconst offload = (payload) => {\n\n\t\t\tif (payload instanceof ValuesTableLiteral) {\n\t\t\t\tthrow new Error(`Single-row payload structure expected for column structure: ${LQRefColumn.right()}. Recieved ${payload.NODE_NAME}.`);\n\t\t\t}\n\n\t\t\tif (!queries.length) {\n\t\t\t\tqueries.push(queryTemplate());\n\t\t\t}\n\t\t\tlet currentQuery = queries[queries.length - 1];\n\n\t\t\tlet isDerivedQuery = false;\n\n\t\t\t// Scenario 2:\n\t\t\t// When the base query is an INSERT ... VALUES (+DerivedQuery)\n\t\t\tif (payload instanceof DerivedQuery) {\n\t\t\t\tpayload = payload.expr();\n\t\t\t\t// For when preceding offload() was scenario 2 or 3\n\t\t\t\tif (currentQuery.select_clause || currentQuery.values_clause) {\n\t\t\t\t\tcurrentQuery = queryTemplate();\n\t\t\t\t\tqueries.push(currentQuery);\n\t\t\t\t}\n\t\t\t\tisDerivedQuery = true;\n\t\t\t}\n\n\t\t\t// Scenario 1 or 2:\n\t\t\t// When the base query is an INSERT ... SELECT\n\t\t\t// or when the preceding scenario is the case\n\t\t\tif (payload instanceof SelectStmt) {\n\n\t\t\t\tlet selectJson = jsonfy(payload);\n\t\t\t\tlet correlationRhs;\n\n\t\t\t\tif (!isDerivedQuery) {\n\t\t\t\t\tif (!isDeepRef) {\n\t\t\t\t\t\t// Fully qualify output names to match target column names. Not necessary at the LinkedQL level\n\t\t\t\t\t\tselectJson = deriveSelectAliasesFromColumns(selectJson, columnsConstructorJson);\n\t\t\t\t\t}\n\t\t\t\t\t// Meaning we're from a literal INSERT ... SELECT statement, not an INSERT ... VALUES (+SELECT) statement\n\t\t\t\t\t// and this time, we want to correlate with base query's row number\n\t\t\t\t\tcorrelationRhs = { nodeName: ColumnRef1.NODE_NAME, value: '$row_number~a' };\n\t\t\t\t}\n\n\t\t\t\tdimensionValidateRowLength(payload, selectJson.result_schema);\n\t\t\t\tcurrentQuery.select_clause = selectJson;\n\n\t\t\t\treturn createForeignBinding(currentQuery.uuid, rhsOperandPKJson, correlationRhs);\n\t\t\t}\n\n\t\t\t// Scenario 3:\n\t\t\t// When base query is INSERT ... VALUES\n\n\t\t\t// For when preceding offload() was scenario 2\n\t\t\tif (currentQuery.select_clause) {\n\t\t\t\tcurrentQuery = queryTemplate();\n\t\t\t\tqueries.push(currentQuery);\n\t\t\t}\n\t\t\tif (!currentQuery.values_clause) {\n\t\t\t\tcurrentQuery.values_clause = { nodeName: ValuesConstructor.NODE_NAME, entries: [] };\n\t\t\t}\n\n\t\t\t// Carry deep values forward\n\t\t\tif (isDeepRef && !(payload instanceof PGDefaultValuesClause)) {\n\t\t\t\tpayload = TypedRowConstructor.fromJSON({ entries: [jsonfy(payload)] });\n\t\t\t}\n\n\t\t\tdimensionPushRow(currentQuery, payload);\n\n\t\t\tlet correlationRhs;\n\t\t\tif (currentQuery.values_clause) {\n\t\t\t\t// Meaning we're from an INSERT ... VALUES statement, not an INSERT ... DEFAULT VALUES statement\n\t\t\t\t// and this this time, currentQuery's row offset is what we use\n\t\t\t\tcorrelationRhs = currentQuery.values_clause.entries.length - 1;\n\t\t\t}\n\n\t\t\treturn createForeignBinding(currentQuery.uuid, rhsOperandPKJson, correlationRhs);\n\t\t};\n\n\t\tconst payloadDimension = {\n\t\t\trefMode,\n\t\t\tqueries,\n\t\t\toffload,\n\t\t\tlhsOperandJson,\n\t\t\trhsOperandJson: rhsOperand1Json\n\t\t};\n\n\t\tpayloadDimensions.add(payloadDimension);\n\n\t\treturn payloadDimension;\n\t}\n\n\tfinalizePayloadJSON(resultJson, transformer, schemaInference, options) {\n\n\t\tconst payloadDimensions = transformer.statementContext.artifacts.get('payloadDimensions');\n\t\tif (!payloadDimensions.size) {\n\t\t\treturn resultJson;\n\t\t}\n\n\t\tconst {\n\t\t\tColumnRef0,\n\t\t\tColumnRef1,\n\t\t\tTableRef1,\n\t\t\tFromItem,\n\t\t\tFromClause,\n\t\t\tAggrCallExpr,\n\t\t\tReturningClause,\n\t\t\tSelectList,\n\t\t\tSelectItem,\n\t\t\tSelectItemAlias,\n\t\t\tNumberLiteral,\n\t\t\tBinaryExpr,\n\t\t\tCTE,\n\t\t\tCTEItem,\n\t\t\tCTEItemAlias,\n\t\t\tCompleteSelectStmt,\n\t\t\tUpdateStmt,\n\t\t} = registry;\n\n\t\tconst baseUUID = transformer.rootContext.hash(this, 'main');\n\t\tconst cte = { nodeName: CTE.NODE_NAME, declarations: [], body: null };\n\t\tconst $transformer = transformer;//new Transformer((node, defaultTransform) => defaultTransform(), null, this);\n\n\t\t// Promote a query to a CTEItem\n\t\tconst toCTEItem = (dimensionID, queryJson, indices = [], transformer = $transformer) => {\n\n\t\t\tlet cteItemJson = CTEItem.fromJSON({\n\t\t\t\tnodeName: CTEItem.NODE_NAME,\n\t\t\t\talias: { nodeName: CTEItemAlias.NODE_NAME, value: dimensionID },\n\t\t\t\texpr: queryJson,\n\t\t\t}, this.options).jsonfy(options, transformer, schemaInference);\n\n\t\t\t// Desugar query and flatten if itself a CTE\n\t\t\tif (cteItemJson.expr?.nodeName === CTE.NODE_NAME) {\n\t\t\t\tcte.declarations.push(...cteItemJson.expr.declarations);\n\n\t\t\t\tif (this instanceof UpdateStmt && cteItemJson.expr.body.nodeName === CompleteSelectStmt.NODE_NAME) {\n\t\t\t\t\t// This is a stray \"SELECT COUNT(*)\" statement owing to how dependencies are rendered in the CTE as dependents\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tcteItemJson = {\n\t\t\t\t\tnodeName: CTEItem.NODE_NAME,\n\t\t\t\t\talias: { nodeName: CTEItemAlias.NODE_NAME, value: dimensionID },\n\t\t\t\t\texpr: cteItemJson.expr.body,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Compose declaration and add...\n\t\t\tcte.declarations.push(cteItemJson);\n\n\t\t\tif (!indices.length) return;\n\n\t\t\tcte.declarations.push(CTEItem.fromJSON({\n\t\t\t\tnodeName: CTEItem.NODE_NAME,\n\t\t\t\talias: { nodeName: CTEItemAlias.NODE_NAME, value: `${dimensionID}~indices` },\n\t\t\t\texpr: flipSelectFromWithRowNumbers(indices, dimensionID),\n\t\t\t}, this.options).jsonfy(options, transformer, schemaInference));\n\t\t};\n\n\t\t// Process entries in stringent order\n\t\tconst dependents = [],\n\t\t\tdeferedDependencies = [],\n\t\t\tlefts = [];\n\n\t\tlet onConflictUpdatedStatusRequired = false;\n\t\tconst originalReturningList = resultJson.returning_clause?.entries || [];\n\n\t\tfor (const { refMode, query: $query, queries, lhsOperandJson, rhsOperandJson, conflictHandlingClauseContext } of payloadDimensions) {\n\t\t\tfor (const { uuid, ...query } of ($query && [$query] || queries)) {\n\t\t\t\tif (refMode === 'dependent' || (this instanceof UpdateStmt && refMode === 'dependency') || conflictHandlingClauseContext) { // Defer dependents\n\n\t\t\t\t\tif (!lefts.find((existing) => _eq(existing.expr.value, lhsOperandJson.value))) {\n\t\t\t\t\t\tconst fieldExpr = { nodeName: SelectItem.NODE_NAME, expr: lhsOperandJson };\n\t\t\t\t\t\tif (originalReturningList.find((existing) => _eq((existing.alias || existing.expr).value, lhsOperandJson.value))) {\n\t\t\t\t\t\t\tfieldExpr.alias = { nodeName: SelectItemAlias.NODE_NAME, as_kw: true, value: transformer.rand('key') };\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlefts.push(fieldExpr);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (conflictHandlingClauseContext) {\n\t\t\t\t\t\tonConflictUpdatedStatusRequired = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tdependents.push({ uuid, ...query });\n\t\t\t\t} else if (refMode === 'dependency') {\n\t\t\t\t\tconst wherePredicate = [{ nodeName: SelectItem.NODE_NAME, expr: rhsOperandJson }];\n\n\t\t\t\t\tif (resultJson.select_clause) {\n\t\t\t\t\t\tdeferedDependencies.push({ uuid, wherePredicate, ...query }); // Dependencies that themselves depend on memo\n\t\t\t\t\t} else if (query.pg_default_values_clause || query.select_clause) {\n\t\t\t\t\t\ttoCTEItem(uuid, query);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttoCTEItem(uuid, query, wherePredicate);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ttoCTEItem(uuid, query);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// (1): Process dependencies with memo\n\t\tfor (const { uuid, wherePredicate, ...query } of deferedDependencies) {\n\t\t\ttoCTEItem(uuid, query, wherePredicate);\n\t\t}\n\n\t\t// (2): Process dependents\n\t\tif (dependents.length) {\n\n\t\t\t// Rewrite returning clause\n\t\t\tconst cteReturningList = [];\n\t\t\tconst newOuterReturningList = [];\n\t\t\tfor (let fieldExpr of originalReturningList) {\n\t\t\t\tif (!fieldExpr.alias) {\n\t\t\t\t\tfieldExpr = {\n\t\t\t\t\t\t...fieldExpr,\n\t\t\t\t\t\talias: { nodeName: SelectItemAlias.NODE_NAME, as_kw: true, value: transformer.rand('key') },\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tcteReturningList.push(fieldExpr);\n\t\t\t\tnewOuterReturningList.push({ ...fieldExpr, expr: { nodeName: ColumnRef1.NODE_NAME, value: fieldExpr.alias.value, delim: fieldExpr.alias.delim } });\n\t\t\t}\n\n\t\t\t// Add conflict_based_update?\n\t\t\tif (onConflictUpdatedStatusRequired) {\n\t\t\t\tconst onConflictUpdatedStatusAlias = `${baseUUID}_conflict_based_update`;\n\t\t\t\tcteReturningList.push({\n\t\t\t\t\tnodeName: SelectItem.NODE_NAME,\n\t\t\t\t\texpr: {\n\t\t\t\t\t\tnodeName: BinaryExpr.NODE_NAME,\n\t\t\t\t\t\tleft: { nodeName: ColumnRef1.NODE_NAME, value: 'XMAX' },\n\t\t\t\t\t\toperator: '!=',\n\t\t\t\t\t\tright: { nodeName: NumberLiteral.NODE_NAME, value: '0' },\n\t\t\t\t\t},\n\t\t\t\t\talias: { nodeName: SelectItemAlias.NODE_NAME, as_kw: true, value: onConflictUpdatedStatusAlias },\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Compose binding and add...\n\t\t\tconst cteReturningClause = { nodeName: ReturningClause.NODE_NAME, entries: [...cteReturningList, ...lefts/* NOTE: cteReturningList may contain \"*\" */] };\n\n\t\t\t// Base query as CTE item\n\t\t\t// If UpdateStmt or onConflictUpdatedStatusRequired, we do not pass lefts\n\t\t\tif (this instanceof UpdateStmt || onConflictUpdatedStatusRequired) {\n\t\t\t\ttoCTEItem(baseUUID, { ...resultJson, returning_clause: cteReturningClause });\n\t\t\t} else if (resultJson.pg_default_values_clause) {\n\t\t\t\ttoCTEItem(baseUUID, { ...resultJson, returning_clause: cteReturningClause });\n\t\t\t} else {\n\t\t\t\ttoCTEItem(baseUUID, { ...resultJson, returning_clause: cteReturningClause }, lefts);\n\t\t\t}\n\n\t\t\t// Process dependents... after having done the above\n\t\t\tfor (const { uuid, ...query } of dependents) {\n\t\t\t\ttoCTEItem(uuid, query);\n\t\t\t}\n\n\t\t\t// Derive final body...\n\t\t\tlet selectItems = newOuterReturningList;\n\n\t\t\tif (!selectItems.length) {\n\t\t\t\tselectItems = [{\n\t\t\t\t\tnodeName: SelectItem.NODE_NAME,\n\t\t\t\t\texpr: { nodeName: AggrCallExpr.NODE_NAME, name: 'COUNT', arguments: [{ nodeName: ColumnRef0.NODE_NAME, value: '*' }] },\n\t\t\t\t\talias: { nodeName: SelectItemAlias.NODE_NAME, as_kw: true, value: 'COUNT' },\n\t\t\t\t}];\n\t\t\t}\n\n\t\t\tconst tableSpec = { nodeName: FromItem.NODE_NAME, expr: { nodeName: TableRef1.NODE_NAME, value: baseUUID } };\n\n\t\t\tcte.body = CompleteSelectStmt.fromJSON({\n\t\t\t\tnodeName: CompleteSelectStmt.NODE_NAME,\n\t\t\t\tselect_list: { nodeName: SelectList.NODE_NAME, entries: selectItems },\n\t\t\t\tfrom_clause: { nodeName: FromClause.NODE_NAME, entries: [tableSpec] },\n\t\t\t}, this.options).jsonfy(options, $transformer, schemaInference);\n\t\t} else {\n\t\t\t// Use resultJson as-is\n\t\t\tconst Classes = [this.constructor].concat(this.constructor.morphsTo()); // InsertStmt/UpsertStmt\n\t\t\tconst instance = Classes.reduce((prev, C) => prev || C.fromJSON(resultJson, this.options), undefined);\n\t\t\tcte.body = instance.jsonfy(options, $transformer, schemaInference);\n\t\t}\n\n\t\treturn { ...cte, origin_schemas: cte.body.origin_schemas, result_schema: cte.body.result_schema };\n\t}\n}\n\nconst deriveSelectAliasesFromColumns = (selectJson, columnsConstructorJson) => {\n\tconst newSelectList = selectJson.select_list.entries.reduce((selectList, fieldJson, columnOffset) => {\n\t\tif (!fieldJson.alias) {\n\t\t\tconst correspondingColumn = columnsConstructorJson.entries[columnOffset];\n\t\t\tfieldJson = {\n\t\t\t\t...fieldJson,\n\t\t\t\talias: { nodeName: registry.SelectItemAlias.NODE_NAME, as_kw: true, value: correspondingColumn.value, delim: correspondingColumn.delim },\n\t\t\t}\n\t\t}\n\t\treturn selectList.concat(fieldJson);\n\t}, []);\n\treturn {\n\t\t...selectJson,\n\t\tselect_list: {\n\t\t\t...selectJson.select_list,\n\t\t\tentries: newSelectList,\n\t\t},\n\t};\n};\n\nconst flipSelectFromWithRowNumbers = (selectItems, fromName) => {\n\tconst rowNumberJson = rowNumberExpr('$row_number~b');\n\n\tselectItems = selectItems.map((fieldJson) => {\n\t\tif (fieldJson.alias) {\n\t\t\t// Flip expr/alias\n\t\t\treturn {\n\t\t\t\t...fieldJson,\n\t\t\t\texpr: { ...fieldJson.expr, value: fieldJson.alias.value, delim: fieldJson.alias.delim, qualifier: undefined },\n\t\t\t\talias: { ...fieldJson.alias, value: fieldJson.expr.value, delim: fieldJson.expr.delim },\n\t\t\t};\n\t\t}\n\t\treturn fieldJson.expr.nodeName === registry.ColumnRef0.NODE_NAME ? i : {\n\t\t\t...fieldJson,\n\t\t\texpr: { ...fieldJson.expr, qualifier: undefined },\n\t\t\talias: { nodeName: registry.SelectItemAlias.NODE_NAME, as_kw: true, value: fieldJson.expr.value, delim: fieldJson.expr.delim },\n\t\t};\n\t}).concat(rowNumberJson);\n\n\tconst fromItemJson = {\n\t\tnodeName: registry.FromItem.NODE_NAME,\n\t\texpr: { nodeName: registry.TableRef1.NODE_NAME, value: fromName },\n\t};\n\n\treturn {\n\t\tnodeName: registry.CompleteSelectStmt.NODE_NAME,\n\t\tselect_list: { nodeName: registry.SelectList.NODE_NAME, entries: selectItems },\n\t\tfrom_clause: { nodeName: registry.FromClause.NODE_NAME, entries: [fromItemJson] },\n\t};\n};\n\nconst rowNumberExpr = (alias) => ({\n\tnodeName: registry.SelectItem.NODE_NAME,\n\texpr: { nodeName: registry.AggrCallExpr.NODE_NAME, name: 'ROW_NUMBER', arguments: [], over_clause: { nodeName: registry.WindowSpec.NODE_NAME } },\n\talias: { nodeName: registry.SelectItemAlias.NODE_NAME, as_kw: true, value: alias || 3 },\n});", "import { PayloadStmtMixin } from '../abstracts/PayloadStmtMixin.js';\nimport { DMLStmt } from './DMLStmt.js';\nimport { Transformer } from '../Transformer.js';\nimport { registry } from '../registry.js';\n\nexport class InsertStmt extends PayloadStmtMixin(DMLStmt) {\n\n\t/* SYNTAX RULES */\n\n\tstatic get _clause() { return 'INSERT'; }\n\n\tstatic get syntaxRules() {\n\t\tconst optional_alias_postgres = {\n\t\t\toptional: true,\n\t\t\tsyntax: [\n\t\t\t\t{ type: 'keyword', value: 'AS', booleanfy: true },\n\t\t\t\t{ type: 'Identifier', as: 'pg_table_alias', assert: true }\n\t\t\t]\n\t\t};\n\n\t\tconst optional_alias_mysql = {\n\t\t\toptional: true,\n\t\t\tdialect: 'mysql',\n\t\t\tif: ['!select_clause', '!my_table_clause'],\n\t\t\tsyntax: [\n\t\t\t\t{ type: 'keyword', value: 'AS' },\n\t\t\t\t{ type: 'FromItemAlias', as: 'my_row_alias', assert: true }\n\t\t\t]\n\t\t};\n\n\t\treturn [\n\t\t\t{ type: 'keyword', value: this._clause },\n\t\t\t{ type: 'keyword', value: 'INTO' },\n\t\t\t{\n\t\t\t\tassert: true,\n\t\t\t\tsyntax: [\n\t\t\t\t\t{\n\t\t\t\t\t\tdialect: 'postgres',\n\t\t\t\t\t\tsyntax: [\n\t\t\t\t\t\t\t{ type: 'TableRef2', as: 'table_ref' },\n\t\t\t\t\t\t\t{ ...optional_alias_postgres },\n\t\t\t\t\t\t\t{ type: 'ColumnsConstructor', as: 'column_list', optional: true, autoIndent: true, },\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tsyntaxes: [\n\t\t\t\t\t\t\t\t\t{ type: 'PGDefaultValuesClause', as: 'pg_default_values_clause' },\n\t\t\t\t\t\t\t\t\t{ type: 'ValuesConstructor', as: 'values_clause' },\n\t\t\t\t\t\t\t\t\t{ type: 'SelectStmt', as: 'select_clause' },\n\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\tautoSpacing: '\\n'\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t...(this._clause === 'INSERT' ? [{ type: 'PGOnConflictClause', as: 'conflict_handling_clause', optional: true, autoSpacing: '\\n' }] : []),\n\t\t\t\t\t\t\t{ type: 'ReturningClause', as: 'returning_clause', optional: true, autoSpacing: '\\n' },\n\t\t\t\t\t\t],\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tdialect: 'mysql',\n\t\t\t\t\t\tsyntax: [\n\t\t\t\t\t\t\t{ type: 'TableRef2', as: 'table_ref' },\n\t\t\t\t\t\t\t{ type: 'MYPartitionClause', as: 'my_partition_clause', optional: true, autoIndent: true },\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tsyntaxes: [\n\t\t\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t\t{ type: 'ColumnsConstructor', as: 'column_list', optional: true, autoIndent: true },\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tsyntaxes: [\n\t\t\t\t\t\t\t\t\t\t\t\t{ type: 'ValuesConstructor', as: 'values_clause' },\n\t\t\t\t\t\t\t\t\t\t\t\t{ type: 'SelectStmt', as: 'select_clause' },\n\t\t\t\t\t\t\t\t\t\t\t\t{ type: 'TableStmt', as: 'my_table_clause' },\n\t\t\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\t\t\tautoSpacing: '\\n'\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\t{ type: 'SetClause', as: 'my_set_clause', autoSpacing: '\\n' },\n\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{ ...optional_alias_mysql },\n\t\t\t\t\t\t\t...(this._clause === 'INSERT' ? [{ type: 'MYOnDuplicateKeyUpdateClause', as: 'conflict_handling_clause', optional: true, autoSpacing: '\\n' }] : []),\n\t\t\t\t\t\t\t{ type: 'ReturningClause', as: 'returning_clause', optional: true, autoSpacing: '\\n' },\n\t\t\t\t\t\t],\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t}\n\t\t];\n\t}\n\n\t/* AST API */\n\n\ttableRef() { return this._get('table_ref'); }\n\n\tcolumnList() { return this._get('column_list'); }\n\n\tvaluesClause() { return this._get('values_clause'); }\n\n\tselectClause() { return this._get('select_clause'); }\n\n\tconflictHandlingClause() { return this._get('conflict_handling_clause'); }\n\n\treturningClause() { return this._get('returning_clause'); }\n\n\t// -- Postgres\n\n\tpgTableAlias() { return this._get('pg_table_alias'); }\n\n\tpgDefaultValuesClause() { return this._get('pg_default_values_clause'); }\n\n\t// -- MySQL\n\n\tmyRowAlias() { return this._get('my_row_alias'); }\n\n\tmyPartitionClause() { return this._get('my_partition_clause'); }\n\n\tmySetClause() { return this._get('my_set_clause'); }\n\n\tmyTableClause() { return this._get('my_table_clause'); }\n\n\t/* JSON API */\n\n\tjsonfy(options = {}, transformer = null, schemaInference = null) {\n\t\tif (!options.deSugar) return super.jsonfy(options, transformer, schemaInference);\n\n\t\ttransformer = new Transformer((node, defaultTransform) => {\n\t\t\t// Process table abstraction nodes\n\t\t\tif (node instanceof registry.TableRef2) {\n\t\t\t\tlet subResultJson = defaultTransform();\n\n\t\t\t\tlet resultSchema = subResultJson.result_schema;\n\t\t\t\tif (subResultJson.pg_table_alias) {\n\t\t\t\t\tresultSchema = resultSchema.clone({ renameTo: subResultJson.pg_table_alias });\n\t\t\t\t}\n\n\t\t\t\ttransformer.statementContext.artifacts.get('tableSchemas').add({ type: 'dml', resultSchema });\n\n\t\t\t\treturn subResultJson;\n\t\t\t}\n\t\t\treturn defaultTransform();\n\t\t}, transformer, this/* IMPORTANT */);\n\n\t\tlet resultJson = super.jsonfy(options, transformer, schemaInference);\n\t\tconst toDialect = options.toDialect || this.options.dialect;\n\n\t\t// Order ouput JSON\n\t\tif (toDialect === 'mysql') {\n\t\t\tresultJson = {\n\t\t\t\tuuid: resultJson.uuid,\n\t\t\t\tnodeName: resultJson.nodeName,\n\t\t\t\ttable_ref: resultJson.table_ref,\n\t\t\t\tmy_partition_clause: resultJson.my_partition_clause,\n\t\t\t\tcolumn_list: resultJson.column_list,\n\t\t\t\tvalues_clause: resultJson.values_clause,\n\t\t\t\tselect_clause: resultJson.select_clause,\n\t\t\t\tmy_table_clause: resultJson.my_table_clause,\n\t\t\t\tmy_set_clause: resultJson.my_set_clause,\n\t\t\t\tmy_row_alias: resultJson.my_row_alias,\n\t\t\t\tconflict_handling_clause: resultJson.conflict_handling_clause,\n\t\t\t\treturning_clause: resultJson.returning_clause,\n\t\t\t\tresult_schema: resultJson.result_schema,\n\t\t\t};\n\t\t} else {\n\t\t\tresultJson = {\n\t\t\t\tuuid: resultJson.uuid,\n\t\t\t\tnodeName: resultJson.nodeName,\n\t\t\t\ttable_ref: resultJson.table_ref,\n\t\t\t\tpg_table_alias: resultJson.pg_table_alias,\n\t\t\t\tcolumn_list: resultJson.column_list,\n\t\t\t\tpg_default_values_clause: resultJson.pg_default_values_clause,\n\t\t\t\tvalues_clause: resultJson.values_clause,\n\t\t\t\tselect_clause: resultJson.select_clause,\n\t\t\t\tconflict_handling_clause: resultJson.conflict_handling_clause,\n\t\t\t\treturning_clause: resultJson.returning_clause,\n\t\t\t\tresult_schema: resultJson.result_schema,\n\t\t\t};\n\t\t}\n\n        if (resultJson.conflict_handling_clause?.entries\n\t\t\t&& !resultJson.conflict_handling_clause.entries.length) {\n            // All assignments were BackRefs and have been offloaded\n            const pkConstraint = resultJson.table_ref.result_schema.pkConstraint(true);\n            const pkColumn = pkConstraint.columns()[0];\n            resultJson = {\n                ...resultJson,\n                conflict_handling_clause: {\n                    ...resultJson.conflict_handling_clause,\n                    entries: [{\n                        nodeName: registry.AssignmentExpr.NODE_NAME,\n                        left: pkColumn.jsonfy(),\n                        operator: '=',\n                        right: pkColumn.jsonfy({ toKind: 1 })\n                    }],\n                },\n            };\n        }\n\n\t\tif (toDialect === 'postgres'\n\t\t\t&& !resultJson.pg_table_alias\n\t\t\t&& (options.deSugar === true || Number(options.deSugar?.tableAliases) === 1)) {\n\t\t\tresultJson = {\n\t\t\t\t...resultJson,\n\t\t\t\tpg_table_alias: {\n\t\t\t\t\tnodeName: registry.Identifier.NODE_NAME,\n\t\t\t\t\tvalue: resultJson.table_ref.value,\n\t\t\t\t\tdelim: resultJson.table_ref.delim\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\n\t\t// 1. Finalize output JSON\n\t\tresultJson = this.finalizeOutputJSON(resultJson, transformer, schemaInference, options);\n\t\tresultJson = {\n\t\t\t...resultJson,\n\t\t\torigin_schemas: this.getOriginSchemas(transformer),\n\t\t};\n\t\t// 2. Finalize generated JOINS. Must come last\n\t\tresultJson = this.finalizePayloadJSON(resultJson, transformer, schemaInference, options);\n\t\t\n\t\treturn resultJson;\n\t}\n}", "import { AbstractNodeList } from '../abstracts/AbstractNodeList.js';\n\nexport class MYSetStmt extends AbstractNodeList {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return {\n            dialect: 'mysql',\n            syntax: [\n                { type: 'keyword', value: 'SET' },\n                { type: 'MYVarAssignmentExpr', as: 'entries', arity: { min: 1 }, itemSeparator, assert: true, autoIndent: 2 },\n            ]\n        };\n    }\n\n    /** API */\n\n    jsonfy({ deSugar, ...options } = {}, transformer = null, schemaInference = null) {\n        return super.jsonfy(options, transformer, schemaInference);\n    }\n}", "import { BinaryExpr } from '../expr/op/BinaryExpr.js';\n\nexport class PGSetStmt extends BinaryExpr {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return {\n            dialect: 'postgres',\n            syntax: [\n                { type: 'keyword', value: 'SET' },\n                { type: 'identifier', as: 'scope_kw', value: ['LOCAL', 'SESSION'], optional: true },\n                {\n                    syntaxes: [\n                        { type: 'keyword', as: 'left' },\n                        { type: 'identifier', as: 'left' },\n                    ],\n                },\n                {\n                    optional: true,\n                    syntaxes: [\n                        { type: 'operator', as: 'operator', value: '=' },\n                        { type: 'keyword', as: 'operator', value: 'TO' }\n                    ],\n                },\n                { type: ['Expr', 'KW'], as: 'right', arity: { min: 1 }, itemSeparator, assert: true, autoIndent: 2 },\n            ]\n        };\n    }\n\n    /* API */\n\n    scopeKW() { return this._get('scope_kw'); }\n\n    /** API */\n\n    jsonfy({ deSugar, ...options } = {}, transformer = null, schemaInference = null) {\n        return super.jsonfy(options, transformer, schemaInference);\n    }\n}", "import { SelectorStmtMixin } from '../abstracts/SelectorStmtMixin.js';\nimport { PayloadStmtMixin } from '../abstracts/PayloadStmtMixin.js';\nimport { DMLStmt } from './DMLStmt.js';\nimport { Transformer } from '../Transformer.js';\nimport { registry } from '../registry.js';\n\nexport class UpdateStmt extends PayloadStmtMixin/* Must be outer as can morph to a CTE */(SelectorStmtMixin(DMLStmt)) {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'keyword', value: 'UPDATE' },\n            {\n                assert: true,\n                syntaxes: [\n                    {\n                        dialect: 'postgres',\n                        syntax: [\n                            { type: 'TableAbstraction2', as: 'table_expr' },\n                            { type: 'SetClause', as: 'set_clause', autoSpacing: '\\n' },\n                            { type: 'FromClause', as: 'pg_from_clause', optional: true, dialect: 'postgres', autoSpacing: '\\n' },\n                            { type: 'JoinClause', as: 'join_clauses', arity: Infinity, optional: true, autoSpacing: '\\n' },\n                            { type: ['PGWhereCurrentClause', 'WhereClause'], as: 'where_clause', optional: true, autoSpacing: '\\n' },\n                            { type: 'ReturningClause', as: 'returning_clause', optional: true, autoSpacing: '\\n' },\n                        ],\n                    },\n                    {\n                        dialect: 'mysql',\n                        syntax: [\n                            { type: 'TableAbstraction2', as: 'table_expr' },\n                            { type: 'SetClause', as: 'set_clause', autoSpacing: '\\n' },\n                            { type: 'WhereClause', as: 'where_clause', optional: true, autoSpacing: '\\n' },\n                            { type: 'OrderByClause', as: 'my_order_by_clause', optional: true, autoSpacing: '\\n' },\n                            { type: 'LimitClause', as: 'my_limit_clause', optional: true, autoSpacing: '\\n' },\n                            { type: 'ReturningClause', as: 'returning_clause', optional: true, autoSpacing: '\\n' },\n                        ],\n                    },\n                    {\n                        dialect: 'mysql',\n                        syntax: [\n                            { type: 'TableAbstraction1', as: 'my_update_list', arity: { min: 1 }, itemSeparator },\n                            { type: 'JoinClause', as: 'join_clauses', arity: Infinity, optional: true, autoSpacing: '\\n' },\n                            { type: 'SetClause', as: 'set_clause', autoSpacing: '\\n' },\n                            { type: 'WhereClause', as: 'where_clause', optional: true, autoSpacing: '\\n' },\n                            { type: 'ReturningClause', as: 'returning_clause', optional: true, autoSpacing: '\\n' },\n                        ],\n                    },\n                ]\n            }\n        ];\n    }\n\n    /* AST API */\n\n    tableExpr() { return this._get('table_expr'); }\n\n    joinClauses() { return this._get('join_clauses'); }\n\n    setClause() { return this._get('set_clause'); }\n\n    whereClause() { return this._get('where_clause'); }\n\n    returningClause() { return this._get('returning_clause'); }\n\n    // Postgres\n\n    pgFromClause() { return this._get('pg_from_clause'); }\n\n    // MySQL\n\n    myUpdateList() { return this._get('my_update_list'); }\n\n    myOrderByClause() { return this._get('my_order_by_clause'); }\n\n    myLimitClause() { return this._get('my_limit_clause'); }\n\n    /* JSON API */\n\n    jsonfy(options = {}, transformer = null, schemaInference = null) {\n        if (!options.deSugar) return super.jsonfy(options, transformer, schemaInference);\n\n        const deferedTransforms = { set_clause: null };\n        transformer = new Transformer((node, defaultTransform) => {\n            // Defer SelectItem resolution\n            if (node instanceof registry.SetClause) {\n                deferedTransforms.set_clause = defaultTransform;\n                return; // Exclude for now\n            }\n            return defaultTransform();\n        }, transformer, this/* IMPORTANT */);\n\n        let resultJson = super.jsonfy(options, transformer, schemaInference);\n        resultJson = { ...resultJson, set_clause: deferedTransforms.set_clause() };\n\n        // Order ouput JSON\n        if ((options.toDialect || this.options.dialect) === 'mysql') {\n            resultJson = {\n                uuid: resultJson.uuid,\n                nodeName: resultJson.nodeName,\n                table_expr: resultJson.table_expr,\n                my_update_list: resultJson.my_update_list,\n                join_clauses: resultJson.join_clauses,\n                set_clause: resultJson.set_clause,\n                where_clause: resultJson.where_clause,\n                my_order_by_clause: resultJson.my_order_by_clause,\n                my_limit_clause: resultJson.my_limit_clause,\n                returning_clause: resultJson.returning_clause,\n                result_schema: resultJson.result_schema,\n            };\n        } else {\n            resultJson = {\n                uuid: resultJson.uuid,\n                nodeName: resultJson.nodeName,\n                table_expr: resultJson.table_expr,\n                set_clause: resultJson.set_clause,\n                pg_from_clause: resultJson.pg_from_clause,\n                join_clauses: resultJson.join_clauses,\n                where_clause: resultJson.where_clause,\n                returning_clause: resultJson.returning_clause,\n                result_schema: resultJson.result_schema,\n            };\n        }\n\n        if (!resultJson.set_clause?.entries.length) {\n            // All assignments were BackRefs and have been offloaded\n            const pkConstraint = resultJson.table_expr.result_schema.pkConstraint(true);\n            const pkColumn = pkConstraint.columns()[0];\n            resultJson = {\n                ...resultJson,\n                set_clause: {\n                    ...resultJson.set_clause,\n                    entries: [{\n                        nodeName: registry.AssignmentExpr.NODE_NAME,\n                        left: pkColumn.jsonfy(),\n                        operator: '=',\n                        right: pkColumn.jsonfy({ toKind: 1 })\n                    }],\n                },\n            };\n        }\n\n        // 1. Finalize output JSON\n\t\tresultJson = this.finalizeOutputJSON(resultJson, transformer, schemaInference, options);\n        // 2. Finalize generated JOINS. Must come first\n        resultJson = this.finalizeSelectorJSON(resultJson, transformer, schemaInference, options);\n        resultJson = {\n\t\t\t...resultJson,\n\t\t\torigin_schemas: this.getOriginSchemas(transformer),\n\t\t};\n        // 3. Finalize entire query rewrite - returning a CTE\n        resultJson = this.finalizePayloadJSON(resultJson, transformer, schemaInference, options);\n\n        return resultJson;\n    }\n}", "import { SugarMixin } from '../abstracts/SugarMixin.js';\nimport { InsertStmt } from './InsertStmt.js';\nimport { registry } from '../registry.js';\nimport { _eq } from '../abstracts/util.js';\n\nexport class UpsertStmt extends SugarMixin(InsertStmt) {\n\n\t/* SYNTAX RULES */\n\n\tstatic get _clause() { return 'UPSERT'; }\n\n\tstatic morphsTo() { return [InsertStmt].concat(super.morphsTo()); }\n\n\t/* DESUGARING API */\n\n\tfinalizePayloadJSON(resultJson, transformer, schemaInference, options) {\n\t\tif (resultJson.conflict_handling_clause) {\n\t\t\tthrow new Error(`An explicit conflict handling clause is forbidden on the UPSERT statement.`);\n\t\t}\n\n\t\tconst tableSchema = [...transformer.statementContext.artifacts.get('tableSchemas')].map((t) => t.resultSchema)[0];\n\t\tconst toDialect = options.toDialect || this.options.dialect;\n\n\t\tlet columnNamesJson;\n\t\tif (resultJson.my_set_clause) {\n\t\t\tcolumnNamesJson = resultJson.my_set_clause.entries.map((e) => ({ value: e.left.value, delim: e.left.delim }));\n\t\t} else if (resultJson.column_list) {\n\t\t\tcolumnNamesJson = resultJson.column_list.entries.map((e) => ({ value: e.value, delim: e.delim }));\n\t\t} else {\n\t\t\tcolumnNamesJson = tableSchema.columns().map((c) => c.name().jsonfy({ nodeNames: false }));\n\t\t}\n\n\t\tconst conflictHandlingClause = {\n\t\t\tnodeName: toDialect === 'mysql'\n\t\t\t\t? registry.MYOnDuplicateKeyUpdateClause.NODE_NAME\n\t\t\t\t: registry.PGOnConflictClause.NODE_NAME,\n\t\t\tentries: columnNamesJson.map((c) => ({\n\t\t\t\tnodeName: registry.AssignmentExpr.NODE_NAME,\n\t\t\t\tleft: {\n\t\t\t\t\tnodeName: toDialect === 'mysql'\n\t\t\t\t\t\t? registry.ColumnRef1.NODE_NAME\n\t\t\t\t\t\t: registry.ColumnRef2.NODE_NAME,\n\t\t\t\t\t...c,\n\t\t\t\t},\n\t\t\t\toperator: '=',\n\t\t\t\tright: toDialect === 'mysql' ? {\n\t\t\t\t\tnodeName: registry.CallExpr.NODE_NAME,\n\t\t\t\t\tname: 'VALUES',\n\t\t\t\t\targuments: [{\n\t\t\t\t\t\tnodeName: registry.ColumnRef1.NODE_NAME,\n\t\t\t\t\t\t...c,\n\t\t\t\t\t}],\n\t\t\t\t} : {\n\t\t\t\t\t...c,\n\t\t\t\t\tnodeName: registry.ColumnRef1.NODE_NAME,\n\t\t\t\t\tqualifier: { value: 'EXCLUDED' },\n\t\t\t\t}\n\t\t\t})),\n\t\t};\n\n\t\tif (toDialect === 'postgres') {\n\t\t\tconst uniqueKeysColumnSets = [].concat(tableSchema.pkConstraint(true) || []).concat(tableSchema.ukConstraints(true)).map((k) => k.columns().map((c) => c.jsonfy()));\n\t\t\tif (!uniqueKeysColumnSets.length) {\n\t\t\t\tthrow new Error(`Table ${this.tableRef()} has no unique keys defined to process an UPSERT operation. You may want to perform a direct INSERT operation.`);\n\t\t\t}\n\n\t\t\tconst firstUniqueKeysColumnSet = uniqueKeysColumnSets.find((colSet) => colSet.find((k) => columnNamesJson.find((c) => _eq(k.value, c.value, k.delim || c.delim)))) || uniqueKeysColumnSets[0];\n\n\t\t\tconflictHandlingClause.conflict_target = {\n\t\t\t\tnodeName: registry.PGConflictTarget.NODE_NAME,\n\t\t\t\tindex_list: firstUniqueKeysColumnSet.map((c) => ({\n\t\t\t\t\tnodeName: registry.PGConflictTargetIndexSpec.NODE_NAME,\n\t\t\t\t\tcolumn_name: c\n\t\t\t\t})),\n\t\t\t};\n\t\t}\n\t\t\n\t\treturn super.finalizePayloadJSON({\n\t\t\t...resultJson,\n\t\t\tnodeName: InsertStmt.NODE_NAME,\n\t\t\tconflict_handling_clause: conflictHandlingClause\n\t\t}, transformer, schemaInference, options);\n\t}\n}", "export * from './clauses/index.js';\nexport * from './TA/index.js';\nexport { CompleteSelectStmt } from './CompleteSelectStmt.js';\nexport { BasicSelectStmt } from './BasicSelectStmt.js';\nexport { CompositeSelectStmt } from './CompositeSelectStmt.js';\nexport { SelectStmt } from './SelectStmt.js';\nexport { TableStmt } from './TableStmt.js';\n", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class DistinctClause extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return {\n            syntaxes: [\n                {\n                    dialect: 'postgres',\n                    syntax: [\n                        { type: 'keyword', value: 'DISTINCT' },\n                        { type: 'keyword', value: 'ON' },\n                        {\n                            type: 'paren_block',\n                            syntax: { type: 'Expr', as: 'pg_distinct_on_list', arity: { min: 1 }, itemSeparator, assert: true }\n                        },\n                    ],\n                },\n                { type: 'keyword', as: 'all_or_distinct', value: ['ALL', 'DISTINCT'] },\n            ]\n        };\n    }\n\n    /* AST API */\n\n    allOrDistinct() { return this._get('all_or_distinct'); }\n\n    // -- Postgres\n\n    pgDistinctOnList() { return this._get('pg_distinct_on_list'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class ForClause extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'keyword', value: 'FOR' },\n            {\n                optional: true,\n                dialect: 'postgres',\n                syntaxes: [\n                    [\n                        { type: 'keyword', as: 'pg_no_key_kw', value: 'NO', booleanfy: true },\n                        { type: 'keyword', value: 'KEY', if: 'pg_no_key_kw', assert: true }\n                    ],\n                    { type: 'keyword', as: 'pg_key_kw', value: 'KEY', booleanfy: true },\n                ],\n            },\n            { type: 'keyword', as: 'intent_kw', value: ['UPDATE', 'SHARE'], assert: true },\n            {\n                optional: true,\n                syntax: [\n                    { type: 'keyword', value: 'OF' },\n                    { type: 'TableRef2', as: 'table_names', arity: { min: 1 }, itemSeparator, assert: true }\n                ],\n            },\n            {\n                optional: true,\n                syntaxes: [\n                    [\n                        { type: 'keyword', as: 'skip_locked_kw', value: 'SKIP', booleanfy: true },\n                        { type: 'keyword', value: 'LOCKED', assert: true }\n                    ],\n                    { type: 'keyword', as: 'nowait_kw', value: 'NOWAIT', booleanfy: true },\n                    {\n                        dialect: 'mysql',\n                        syntax: [\n                            { type: 'keyword', as: 'my_lock_in_share_mode', value: 'LOCK', booleanfy: true },\n                            { type: 'operator', value: 'IN', assert: true },\n                            { type: 'keyword', value: 'SHARE', assert: true },\n                            { type: 'keyword', value: 'MODE', assert: true },\n                        ],\n                    },\n                ],\n            }\n        ];\n    }\n\n    /* AST API */\n\n    intentKW() { return this._get('intent_kw'); }\n\n    tableNames() { return this._get('table_names'); }\n\n    skipLockedKW() { return this._get('skip_locked_kw'); }\n\n    nowaitKW() { return this._get('nowait_kw'); }\n\n    // -- Postgres\n\n    pgKeyKW() { return this._get('pg_key_kw'); }\n\n    pgNoKeyKW() { return this._get('pg_no_key_kw'); }\n\n    // -- MySQL\n\n    myLockInShareMode() { return this._get('my_lock_in_share_mode'); }\n}", "import { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\n\nexport class FromClause extends AbstractNodeList {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'keyword', value: 'FROM' },\n            { type: 'FromItem', as: 'entries', arity: { min: 1 }, itemSeparator, assert: true }\n        ];\n    }\n}", "import { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\n\nexport class GroupByClause extends AbstractNodeList {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'keyword', value: 'GROUP' },\n            { type: 'keyword', value: 'BY', assert: true },\n            { type: 'keyword', as: 'all_or_distinct', value: ['ALL', 'DISTINCT'], optional: true },\n            { type: 'GroupingElement', as: 'entries', arity: { min: 1 }, itemSeparator, assert: true, autoIndent: 2 },\n            {\n                optional: true,\n                autoIndent: true,\n                syntax: [\n                    { type: 'keyword', as: 'with_rollup', value: 'WITH', booleanfy: true },\n                    { type: 'keyword', value: 'ROLLUP', assert: true },\n                ]\n            },\n        ];\n    }\n\n    /* AST API */\n\n    allOrDistinct() { return this._get('all_or_distinct'); }\n\n    withRollup() { return this._get('with_rollup'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class GroupingElement extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return {\n            syntaxes: [\n                [\n                    { type: 'keyword', value: 'GROUPING SETS' },\n                    {\n                        type: 'paren_block', syntax:\n                            { type: 'GroupingElement', as: 'grouping_sets', arity: { min: 1 }, itemSeparator, assert: true, autoIndent: 2 },\n                        autoIndent: true\n                    }\n                ],\n                [\n                    { type: 'keyword', value: 'ROLLUP' },\n                    { type: 'RowConstructor', as: 'rollup_set', assert: true },\n                ],\n                [\n                    { type: 'keyword', value: 'CUBE' },\n                    { type: 'RowConstructor', as: 'cube_set', assert: true },\n                ],\n                { type: 'Expr', as: 'expr' },\n            ]\n        };\n    }\n\n    /* AST API */\n\n    groupingSets() { return this._get('grouping_sets'); }\n\n    rollupSet() { return this._get('rollup_set'); }\n\n    cubeSet() { return this._get('cube_set'); }\n\n    expr() { return this._get('expr'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class HavingClause extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', value: 'HAVING' },\n            { type: 'Expr', as: 'expr', assert: true }\n        ];\n    }\n\n    static get syntaxPriority() { return -1; }\n\n    /* AST API */\n\n    expr() { return this._get('expr'); }\n}", "import { ResultSchemaMixin } from '../../abstracts/ResultSchemaMixin.js';\nimport { AbstractNode } from '../../abstracts/AbstractNode.js';\nimport { Transformer } from '../../Transformer.js';\nimport { registry } from '../../registry.js';\n\nexport class FromItem extends ResultSchemaMixin(AbstractNode) {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n\n        const optional_table_sample_clause_postgres = {\n            optional: true,\n            dialect: 'postgres',\n            syntax: [\n                { type: 'keyword', value: 'TABLESAMPLE' },\n                {\n                    syntaxes: [\n                        [\n                            { type: 'keyword', as: 'pg_sampling_method', value: ['BERNOULLI', 'SYSTEM'] },\n                            { type: 'paren_block', syntax: { type: 'Expr', as: 'pg_sampling_arguments', arity: 1, itemSeparator, assert: true } },\n                        ],\n                        [\n                            { type: 'identifier', as: 'pg_sampling_method' },\n                            { type: 'paren_block', syntax: { type: 'Expr', as: 'pg_sampling_arguments', arity: Infinity, itemSeparator, assert: true } },\n                        ],\n                    ],\n                    assert: true,\n                },\n                {\n                    optional: true,\n                    syntax: [\n                        { type: 'keyword', value: 'REPEATABLE' },\n                        { type: 'paren_block', syntax: { type: 'Expr', as: 'pg_repeatable_seed' }, assert: true },\n                    ]\n                }\n            ]\n        };\n\n        return {\n            syntaxes: [\n                // SRFTableDef1, SRFTableDef2, SRFTableDef3, SRFTableDef4\n                [\n                    { type: 'keyword', as: 'lateral_kw', value: 'LATERAL', booleanfy: true, optional: true },\n                    { type: 'SRFExpr1', as: 'expr' },\n                ],\n                [\n                    { type: 'keyword', as: 'lateral_kw', value: 'LATERAL', booleanfy: true, optional: true },\n                    { type: ['SRFExpr2', 'SRFExpr4'], as: 'expr' },\n                    { type: 'FromItemAlias', as: 'alias', optional: true },\n                ],\n                // DerivedQuery, ValuesTableLiteral\n                [\n                    { type: 'keyword', as: 'lateral_kw', value: 'LATERAL', booleanfy: true, optional: true },\n                    { type: ['DerivedQuery', 'ValuesTableLiteral'], as: 'expr', dialect: 'postgres' },\n                    { type: 'DerivedQuery', as: 'expr', dialect: 'mysql' },\n                    { type: 'FromItemAlias', as: 'alias', optional: true },\n                ],\n                // TableRef1\n                [\n                    { type: 'keyword', as: 'pg_only_kw', value: 'ONLY', optional: true, dialect: 'postgres' },\n                    { type: ['TableRef1', 'TableRef2'], as: 'expr' },\n                    { type: 'operator', as: 'pg_star_ref', value: '*', booleanfy: true, optional: true, dialect: 'postgres' },\n                    { type: 'FromItemAlias', as: 'alias', optional: true },\n                    { ...optional_table_sample_clause_postgres },\n                ],\n            ],\n        };\n    }\n\n    /* AST API */\n\n    lateralKW() { return this._get('lateral_kw'); }\n\n    expr() { return this._get('expr'); }\n\n    alias() { return this._get('alias'); }\n\n    // -- Postgres\n\n    pgOnlyKW() { return this._get('pg_only_kw'); }\n\n    pgStarRef() { return this._get('pg_star_ref'); }\n\n    pgSamplingMethod() { return this._get('pg_sampling_method'); }\n\n    pgSamplingArguments() { return this._get('pg_sampling_arguments'); }\n\n    pgRepeatableSeed() { return this._get('pg_repeatable_seed'); }\n\n    /* SCHEMA API */\n\n    deriveAlias() {\n        let derivedAliasJson;\n        if (this.alias()?.value()) {\n            derivedAliasJson = { as_kw: true, value: this.alias().value(), delim: this.alias()._get('delim') };\n        } else if (this.expr() instanceof registry.TableRef1 || this.expr() instanceof registry.TableRef2) {\n            derivedAliasJson = { as_kw: true, value: this.expr().value(), delim: this.expr()._get('delim') };\n        } else if (this.expr() instanceof registry.SRFExpr1\n            && this.expr().qualif() instanceof registry.SRFExprDDL2) {\n            derivedAliasJson = { as_kw: true, value: this.expr().qualif().alias().value(), delim: this.expr().qualif().alias()._get('delim') };\n        }\n        if (derivedAliasJson) {\n            return registry.FromItemAlias.fromJSON(derivedAliasJson);\n        }\n    }\n\n    jsonfy(options = {}, transformer = null, schemaInference = null) {\n        let resultJson = super.jsonfy(options, transformer, schemaInference);\n        if (options.deSugar) {\n\n            const derivedAliasJson = resultJson.alias || this.deriveAlias()?.jsonfy();\n\n            const namespaceIdent = derivedAliasJson?.value && {\n                nodeName: registry.Identifier.NODE_NAME,\n                value: derivedAliasJson.value,\n                delim: derivedAliasJson.delim,\n            };\n\n            let resultSchema = resultJson.expr.result_schema;\n\n\n            if (resultSchema instanceof registry.TableSchema) {\n                resultSchema = resultSchema.clone({ renameTo: namespaceIdent });\n            } else if (namespaceIdent) {\n                resultSchema = registry.TableSchema.fromJSON({\n                    name: namespaceIdent,\n                    entries: resultSchema?.entries().map((s) => s.jsonfy()) || [],\n                }, { assert: true });\n            }\n            \n            if (resultJson.alias?.columns?.length) {\n                if (resultJson.alias.columns.length !== resultSchema.length) {\n                    throw new SyntaxError(`[${this}] Number of column aliases must match number of result columns.`);\n                }\n                resultSchema = resultSchema.clone({}, new Transformer((node, defaultTransform, key) => {\n                    if (typeof key === 'number' && node.parentNode === resultSchema) {\n                        if (node instanceof registry.ColumnSchema) {\n                            return node.jsonfy({ renameTo: resultJson.alias.columns[key] });\n                        }\n                        return {\n                            ...node.jsonfy(),\n                            nodeName: registry.ColumnSchema.NODE_NAME,\n                            name: resultJson.alias.columns[key],\n                        };\n                    }\n                    return defaultTransform();\n                }));\n            }\n\n            transformer.statementContext.artifacts.get('tableSchemas').add({ type: this.joinType?.() || 'dql', lateral: this.lateralKW(), resultSchema });\n\n            const applicableAliasJson = !(this.expr() instanceof registry.SRFExpr1) && (\n                options.deSugar === true ||  Number(options.deSugar?.tableAliases) === 1 || options.deSugar?.tableAliases === -1 && (this.parentNode?.length || 0) > 1\n            ) && derivedAliasJson || resultJson.alias;\n            resultJson = {\n                ...resultJson,\n                alias: applicableAliasJson,\n                result_schema: resultSchema,\n            };\n        }\n\n        return resultJson;\n    }\n}", "import { Transformer } from '../../Transformer.js';\nimport { FromItem } from '../TA/FromItem.js';\n\nexport class JoinClause extends FromItem {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            syntaxes: [\n                [\n                    { type: 'keyword', as: 'join_type', value: 'CROSS' },\n                    { type: 'keyword', value: 'JOIN', assert: true },\n                    ...[].concat(super.syntaxRules),\n                ],\n                [\n                    { type: 'keyword', as: 'natural_kw', value: 'NATURAL', booleanfy: true, optional: true },\n                    {\n                        optional: true,\n                        syntaxes: [\n                            { type: 'keyword', as: 'join_type', value: 'INNER' },\n                            [\n                                { type: 'keyword', as: 'join_type', value: ['LEFT', 'RIGHT', 'FULL'], dialect: 'postgres' },\n                                { type: 'keyword', as: 'join_type', value: ['LEFT', 'RIGHT'], dialect: 'mysql' },\n                                { type: 'keyword', as: 'outer_kw', value: 'OUTER', booleanfy: true, optional: true },\n                            ],\n                        ],\n                    },\n                    { type: 'keyword', value: 'JOIN' },\n                    ...[].concat(super.syntaxRules),\n                    { type: ['OnClause', 'UsingClause'], as: 'condition_clause', if: '!natural_kw', assert: true, autoIndent: true },\n                ],\n            ],\n        };\n    }\n\n    /* AST API */\n\n    naturalKW() { return this._get('natural_kw'); }\n\n    joinType() { return this._get('join_type'); }\n\n    outerKW() { return this._get('outer_kw'); }\n\n    conditionClause() { return this._get('condition_clause'); }\n\n    /* JSON API */\n\n    jsonfy(options = {}, transformer = null, schemaInference = null) {\n        let conditionClauseTransform;\n\n        if (options.deSugar) {\n            transformer = new Transformer((node, defaultTransform, keyHint) => {\n                if (keyHint === 'condition_clause') {\n                    conditionClauseTransform = defaultTransform;\n                } else return defaultTransform();\n            }, transformer, this.statementNode/* IMPORTANT */);\n        }\n\n        let resultJson = super.jsonfy(options, transformer, schemaInference);\n\n        if (conditionClauseTransform) {\n            resultJson = {\n                ...resultJson,\n                condition_clause: conditionClauseTransform(),\n            };\n        }\n\n        return resultJson;\n    }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class LimitClause extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', value: 'LIMIT' },\n            {\n                dialect: 'mysql',\n                syntax: [\n                    {\n                        optional: true,\n                        syntax: [\n                            { type: 'Expr', as: 'my_offset' },\n                            { type: 'punctuation', value: ',', autoSpacing: false },\n                        ]\n                    },\n                    { type: 'Expr', as: 'expr', assert: true, },\n                ]\n            },\n            {\n                dialect: 'postgres',\n                syntaxes: [\n                    { type: 'keyword', as: 'pg_all_kw', value: 'ALL' },\n                    { type: 'Expr', as: 'expr', assert: true },\n                ],\n            },\n        ];\n    }\n\n    /* AST API */\n\n    expr() { return this._get('expr'); }\n\n    // -- Postgres\n\n    pgAllKW() { return this._get('pg_all_kw'); }\n\n    // -- MySQL\n\n    myOffset() { return this._get('my_offset'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class OffsetClause extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', value: 'OFFSET' },\n            { type: 'Expr', as: 'expr', assert: true, },\n            { type: 'keyword', as: 'pg_row_kw', value: ['ROW', 'ROWS'], optional: true, dialect: 'postgres' },\n        ];\n    }\n\n    /* AST API */\n\n    expr() { return this._get('expr'); }\n\n    // -- Postgres\n\n    pgRowKW() { return this._get('pg_row_kw'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class OnClause extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', value: 'ON' },\n            { type: 'Expr', as: 'expr', assert: true }\n        ];\n    }\n\n    /* AST API */\n\n    expr() { return this._get('expr'); }\n}", "import { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\n\nexport class OrderByClause extends AbstractNodeList {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'keyword', value: 'ORDER' },\n            { type: 'keyword', value: 'BY', assert: true },\n            { type: 'OrderElement', as: 'entries', arity: { min: 1 }, itemSeparator, assert: true, autoIndent: 2 },\n            {\n                optional: true,\n                autoIndent: true,\n                syntax: [\n                    { type: 'keyword', as: 'with_rollup', value: 'WITH', booleanfy: true },\n                    { type: 'keyword', value: 'ROLLUP', assert: true },\n                ]\n            },\n        ];\n    }\n\n    /* AST API */\n\n    withRollup() { return this._get('with_rollup'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class OrderElement extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'Expr', as: 'expr' },\n            {\n                optional: true,\n                syntaxes: [\n                    { type: 'keyword', value: ['ASC', 'DESC'], as: 'dir' },\n                    { type: 'PGOrderOperator', as: 'dir' },\n                ]\n            },\n            {\n                optional: true,\n                syntax: [\n                    { type: 'keyword', value: 'NULLS' },\n                    { type: 'keyword', as: 'nulls_spec', value: ['FIRST', 'LAST'], assert: true },\n                ]\n            },\n        ];\n    }\n\n    /* AST API */\n\n    expr() { return this._get('expr'); }\n\n    dir() { return this._get('dir'); }\n\n    nullsSpec() { return this._get('nulls_spec'); }\n}", "import { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\n\nexport class PartitionByClause extends AbstractNodeList {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'keyword', value: 'PARTITION' },\n            { type: 'keyword', value: 'BY', assert: true },\n            { type: 'Expr', as: 'entries', arity: { min: 1 }, itemSeparator, assert: true, autoIndent: 2 }\n        ];\n    }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class PGFetchClause extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            dialect: 'postgres',\n            syntax: [\n                { type: 'keyword', value: 'FETCH' },\n                { type: 'keyword', as: 'rel_kw', value: ['FIRST', 'NEXT'] },\n                { type: 'Expr', as: 'expr', optional: true },\n                { type: 'keyword', as: 'row_kw', value: ['ROW', 'ROWS'], assert: true },\n                {\n                    syntaxes: [\n                        { type: 'keyword', value: 'ONLY' },\n                        [\n                            { type: 'keyword', as: 'with_ties', value: 'WITH' },\n                            { type: 'keyword', value: 'TIES', assert: true },\n                        ]\n                    ]\n                }\n            ]\n        };\n    }\n\n    /* AST API */\n\n    relKW() { return this._get('rel_kw'); }\n\n    expr() { return this._get('expr'); }\n\n    rowKW() { return this._get('row_kw'); }\n\n    withTies() { return this._get('with_ties'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class PGOrderOperator extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            dialect: 'postgres',\n            syntax: [\n                { type: 'keyword', value: 'USING' },\n                { type: 'operator', as: '.', assert: true },\n            ],\n        };\n    }\n\n    /* AST API */\n\n    value() { return this._get('value'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class UsingClause extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'keyword', value: 'USING' },\n            {\n                syntaxes: [\n                    { type: 'Identifier', as: 'column' },\n                    {\n                        type: 'paren_block',\n                        syntax: { type: 'Identifier', as: 'columns', arity: { min: 1 }, itemSeparator, assert: true }\n                    }\n                ], assert: true\n            },\n        ];\n    }\n\n    /* AST API */\n\n    column() { return this._get('column'); }\n\n    columns() { return this._get('columns'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class WhereClause extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', value: 'WHERE' },\n            { type: 'Expr', as: 'expr', assert: true }\n        ];\n    }\n\n    /* AST API */\n\n    expr() { return this._get('expr'); }\n}", "import { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\n\nexport class WindowClause extends AbstractNodeList {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'keyword', value: 'WINDOW' },\n            { type: 'WindowDeclaration', as: 'entries', arity: { min: 1 }, itemSeparator, assert: true, autoIndent: 2 },\n        ];\n    }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class WindowDeclaration extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'Identifier', as: 'name' },\n            { type: 'keyword', value: 'AS' },\n            { type: 'WindowSpec', as: 'spec', assert: true }\n        ];\n    }\n\n    /* AST API */\n\n    name() { return this._get('name'); }\n\n    spec() { return this._get('spec'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class WindowFrameSpec extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'operator', value: 'AND' };\n        return [\n            { type: 'keyword', as: 'specifier', value: ['ROWS', 'RANGE', 'GROUPS'] },\n            {\n                syntaxes: [\n                    [\n                        { type: 'operator', as: 'with_between_clause', value: 'BETWEEN', booleanfy: true },\n                        { type: 'WindowFrameBound', as: 'bounds', arity: 2, itemSeparator, assert: true },\n                    ],\n                    { type: 'WindowFrameBound', as: 'bounds', arity: 1, itemSeparator, assert: true },\n\n                ]\n            },\n            {\n                optional: true,\n                syntax: [\n                    { type: 'keyword', value: 'EXCLUDE' },\n                    { type: 'keyword', as: 'exclusion', value: ['CURRENT ROW', 'GROUP', 'TIES', 'NO OTHERS'], assert: true },\n                ]\n            },\n        ];\n    }\n\n    /* AST API */\n\n    specifier() { return this._get('specifier'); }\n\n    withBetweenClause() { return this._get('with_between_clause'); }\n\n    bounds() { return this._get('bounds'); }\n\n    exclusion() { return this._get('exclusion'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class WindowFrameBound extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            syntaxes: [\n                { type: 'keyword', as: 'specifier', value: 'CURRENT ROW' },\n                [\n                    { type: 'keyword', as: 'specifier', value: 'UNBOUNDED' },\n                    { type: 'keyword', as: 'dir', value: ['PRECEDING', 'FOLLOWING'] },\n                ],\n                [\n                    { type: 'number_literal', as: 'specifier' },\n                    { type: 'keyword', as: 'dir', value: ['PRECEDING', 'FOLLOWING'] },\n                ],\n                [\n                    { type: 'Expr'/* Ideally, Temporal types */, as: 'specifier' },\n                    { type: 'keyword', as: 'dir', value: ['PRECEDING', 'FOLLOWING'] },\n                ],\n            ]\n        };\n    }\n\n    /* AST API */\n\n    specifier() { return this._get('specifier'); }\n\n    dir() { return this._get('dir'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class WindowSpec extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            type: 'paren_block',\n            syntax: [\n                { type: 'WindowRef', as: 'super_window', optional: true },\n                { type: 'PartitionByClause', as: 'partition_by_clause', optional: true, autoIndent: true },\n                { type: 'OrderByClause', as: 'order_by_clause', optional: true, autoIndent: true },\n                { type: 'WindowFrameSpec', as: 'frame_spec', optional: true, autoIndent: true },\n            ],\n            autoIndent: true,\n            autoIndentAdjust: -1\n        };\n    }\n\n    /* AST API */\n\n    superWindow() { return this._get('super_window'); }\n\n    partitionByClause() { return this._get('partition_by_clause'); }\n\n    orderByClause() { return this._get('order_by_clause'); }\n\n    frameSpec() { return this._get('frame_spec'); }\n}", "import { Identifier } from '../../expr/ref/Identifier.js';\n\nexport class FromItemAlias extends Identifier {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            {\n                syntaxes: [\n                    { ...[].concat(super.syntaxRules)[0] },\n                    [\n                        { type: 'keyword', as: 'as_kw', value: 'AS', booleanfy: true },\n                        { ...[].concat(super.syntaxRules)[0], assert: true },\n                    ]\n                ]\n            },\n            {\n                type: 'paren_block',\n                syntax: { type: 'Identifier', as: 'columns', arity: { min: 1 }, itemSeparator, assert: true },\n                if: 'value',\n                optional: true,\n                optionalParens: true,\n            }\n        ];\n    }\n\n    /* AST API */\n\n    asKW() { return this._get('as_kw'); }\n\n    columns() { return this._get('columns'); }\n\n    // --------------\n\n    jsonfy(options = {}, transformer = null, schemaInference = null) {\n        let resultJson = super.jsonfy(options, transformer, schemaInference);\n        if ((options.deSugar === true || options.deSugar?.normalizeCasing) && !resultJson.delim) {\n            resultJson = { ...resultJson, value: resultJson.value.toLowerCase() };\n        }\n        return resultJson;\n    }\n}", "import { ResultSchemaMixin } from '../../abstracts/ResultSchemaMixin.js';\nimport { AbstractNode } from '../../abstracts/AbstractNode.js';\nimport { registry } from '../../registry.js';\n\nexport class SelectItem extends ResultSchemaMixin(AbstractNode) {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: ['Expr', 'ColumnRef0', 'MYVarAssignmentExpr'], as: 'expr' },\n            { type: 'SelectItemAlias', as: 'alias', optional: true }\n        ];\n    }\n\n    /* AST API */\n\n    expr() { return this._get('expr'); }\n\n    alias() { return this._get('alias'); }\n\n    /* SCHEMA API */\n\n    deriveAlias() {\n\n        let derivedAliasJson = this.alias()?.jsonfy();\n\n        let exprNode = this.expr();\n        if (exprNode instanceof registry.ColumnRef0) return;\n\n        // Resolve RowConstructor\n        if (exprNode instanceof registry.RowConstructor) {\n            exprNode = exprNode.exprUnwrapped();\n        }\n\n        // Resolve CastExpr | PGCastExpr2\n        if (exprNode instanceof registry.CastExpr\n            || exprNode instanceof registry.PGCastExpr2) {\n            exprNode = exprNode.expr();\n        }\n\n        if (!derivedAliasJson) {\n            if (exprNode instanceof registry.ColumnRef1) {\n                derivedAliasJson = { as_kw: true, value: exprNode.value(), delim: exprNode._get('delim') };\n            } else if (exprNode instanceof registry.LQDeepRef1 && exprNode.endpoint() instanceof registry.ColumnRef2) {\n                const endpointNode = exprNode.endpoint();\n                derivedAliasJson = { as_kw: true, value: endpointNode.value(), delim: endpointNode._get('delim') };\n            } else {\n                const isToPG = this.options.dialect === 'postgres';\n                if (exprNode instanceof registry.CallExpr && isToPG) {\n                    derivedAliasJson = { as_kw: true, value: exprNode.name().toLowerCase() };\n                }\n            }\n        }\n\n        return registry.SelectItemAlias.fromJSON(derivedAliasJson);\n    }\n\n    jsonfy(options = {}, transformer = null, schemaInference = null) {\n        if (options.deSugar) {\n\n            const derivedAliasNode = this.deriveAlias();\n\n            let asAggr,\n                derivedAliasJson = derivedAliasNode && (transformer\n                    ? transformer.transform(derivedAliasNode, ($options = options) => derivedAliasNode.jsonfy($options), 'alias', options)\n                    : derivedAliasNode.jsonfy(options));\n            if (derivedAliasJson?.is_aggr) ({ is_aggr: asAggr, ...derivedAliasJson } = derivedAliasJson);\n\n            const exprNode = this.expr();\n\n            let defaultExprTransform;\n\n            if (asAggr && !(exprNode instanceof registry.LQDeepRef1)) {\n                // Note the below where we wrap value in an aggr call\n                defaultExprTransform = ($options = options, childTransformer = transformer) => ({\n                    nodeName: registry.AggrCallExpr.NODE_NAME,\n                    name: (options.toDialect || this.options.dialect) === 'mysql' ? 'JSON_ARRAYAGG' : 'JSON_AGG',\n                    arguments: [exprNode.jsonfy($options, childTransformer, schemaInference)],\n                });\n            } else {\n                // Note the below where we derive value, if not specified, from key\n                defaultExprTransform = ($options = options, childTransformer = transformer) => {\n                    return exprNode.jsonfy($options, childTransformer, schemaInference);\n                };\n            }\n\n            const exprJson = transformer\n                ? transformer.transform(exprNode, defaultExprTransform, 'expr', { ...options, asAggr })\n                : defaultExprTransform();\n\n            // ----------------\n\n            const namespaceIdent = derivedAliasJson && {\n                nodeName: registry.Identifier.NODE_NAME,\n                value: derivedAliasJson.value,\n                delim: derivedAliasJson.delim\n            } || {\n                nodeName: registry.Identifier.NODE_NAME,\n                value: this.options.dialect === 'postgres' ? '?column?' : exprNode.stringify(),\n            };\n\n            let resultSchema = exprJson.result_schema;\n\n            if (resultSchema instanceof registry.ColumnSchema) {\n                const tableSchema = resultSchema.parentNode;\n                resultSchema = resultSchema.clone({ renameTo: namespaceIdent });\n                tableSchema?._adoptNodes(resultSchema);\n            } else if (!(exprNode instanceof registry.LQDeepRef1)\n                && !(exprNode instanceof registry.ColumnRef0)) {\n                resultSchema = registry.ColumnSchema.fromJSON({\n                    name: namespaceIdent,\n                    data_type: this.expr().dataType().jsonfy(),\n                });\n                exprNode._adoptNodes(resultSchema);\n            }\n\n            const applicableAliasJson = (asAggr || options.deSugar === true || Number(options.deSugar?.selectAliases) === 1 || (\n                options.deSugar?.selectAliases === -1 && (this.parentNode?.entries().length || 0) > 1\n            )) && derivedAliasJson || this.alias()?.jsonfy();\n\n            return {\n                nodeName: SelectItem.NODE_NAME,\n                expr: exprJson,\n                alias: applicableAliasJson,\n                result_schema: resultSchema,\n            };\n        }\n        return super.jsonfy(options, transformer, schemaInference);\n    }\n}", "import { Identifier } from '../../expr/ref/Identifier.js';\n\nexport class SelectItemAlias extends Identifier {\n    static get syntaxRules() {\n        return [\n            {\n                syntaxes: [\n                    { ...[].concat(super.syntaxRules)[0] },\n                    [\n                        { type: 'keyword', as: 'as_kw', value: 'AS', booleanfy: true },\n                        { ...[].concat(super.syntaxRules)[0], assert: true },\n                    ]\n                ]\n            },\n            { type: 'AggrNotation', as: 'is_aggr', autoSpacing: false, optional: true },\n        ];\n    }\n\n    /* AST API */\n\n    asKW() { return this._get('as_kw'); }\n\n    isAggr() { return this._get('is_aggr'); }\n\n    // --------------\n\n    jsonfy(options = {}, transformer = null, schemaInference = null) {\n        let resultJson = super.jsonfy(options, transformer, schemaInference);\n        if ((options.deSugar === true || options.deSugar?.normalizeCasing) && !resultJson.delim) {\n            resultJson = { ...resultJson, value: resultJson.value.toLowerCase(), };\n        }\n        return resultJson;\n    }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\nimport { ResultSchemaMixin } from '../../abstracts/ResultSchemaMixin.js';\nimport { registry } from '../../registry.js';\n\nexport class SRFExpr1 extends ResultSchemaMixin(AbstractNode) {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'CallExpr', as: 'call_expr' },\n            { type: ['SRFExprDDL1', 'SRFExprDDL2'], as: 'qualif' },\n        ];\n    }\n\n    /* AST API */\n\n    callExpr() { return this._get('call_expr'); }\n\n    qualif() { return this._get('qualif'); }\n\n    /* JSON API */\n\n    jsonfy(options = {}, transformer = null, schemaInference = null) {\n        let resultJson = super.jsonfy(options, transformer, schemaInference);\n        if (options.deSugar) {\n            \n            const columnDefsJson = resultJson.qualif?.column_defs || [];\n            const resultSchema = resultJson.qualif?.alias\n                // a. Compose from \"column_defs\" with explicit table alias\n                ? registry.TableSchema.fromJSON({\n                    name: resultJson.qualif.alias,\n                    entries: columnDefsJson,\n                })\n                // b. Compose from \"column_defs\" without explicit table alias\n                : registry.JSONSchema.fromJSON({\n                    entries: columnDefsJson,\n                });\n\n            resultJson = {\n                ...resultJson,\n                result_schema: resultSchema\n            };\n        }\n\n        return resultJson;\n    }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\nimport { ResultSchemaMixin } from '../../abstracts/ResultSchemaMixin.js';\nimport { registry } from '../../registry.js';\n\nexport class SRFExpr2 extends ResultSchemaMixin(AbstractNode) {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'CallExpr', as: 'call_expr' },\n            {\n                optional: true,\n                syntax: [\n                    { type: 'keyword', as: 'with_ordinality', value: 'WITH', booleanfy: true },\n                    { type: 'keyword', value: 'ORDINALITY', assert: true },\n                ]\n            },\n        ];\n    }\n\n    /* AST API */\n\n    callExpr() { return this._get('call_expr'); }\n\n    withOrdinality() { return this._get('with_ordinality'); }\n\n    /* JSON API */\n\n    jsonfy(options = {}, transformer = null, schemaInference = null) {\n        let resultJson = super.jsonfy(options, transformer, schemaInference);\n        if (options.deSugar) {\n\n            let resultSchema;\n\n            let ordinalityColumn;\n            if (resultJson.with_ordinality) {\n                ordinalityColumn = registry.ColumnSchema.fromJSON({\n                    name: { nodeName: registry.Identifier.NODE_NAME, value: 'ordinality' },\n                    data_type: { nodeName: registry.DataType.NODE_NAME, value: 'INT' },\n                });\n            }\n\n            const schemaIdentFromFuncName = { nodeName: registry.Identifier.NODE_NAME, value: resultJson.call_expr.name };\n\n            if (resultJson.call_expr?.result_schema) {\n                // a. Compose from existing\n                resultSchema = resultJson.call_expr.result_schema;\n\n                if (resultSchema instanceof registry.TableSchema\n                    || resultSchema instanceof registry.JSONSchema) {\n\n                    if (ordinalityColumn) {\n                        const resultSchema_json = resultSchema.jsonfy();\n                        resultSchema = resultSchema.constructor.fromJSON({\n                            name: schemaIdentFromFuncName,\n                            ...resultSchema_json, // overridingly\n                            entries: [\n                                ...resultSchema_json.entries, \n                                ordinalityColumn\n                            ],\n                        });\n                    } else {\n                        resultSchema = resultSchema.clone();\n                    }\n\n                } else {\n                    resultSchema = registry.JSONSchema.fromJSON({\n                        entries: [\n                            resultSchema.jsonfy()\n                        ].concat(ordinalityColumn || []),\n                    });\n                }\n            } else {\n                // b. Compose from Func expr\n                resultSchema = registry.JSONSchema.fromJSON({\n                    entries: [{\n                        nodeName: registry.ColumnSchema.NODE_NAME,\n                        name: schemaIdentFromFuncName,\n                        data_type: this.callExpr().dataType().jsonfy(),\n                    }].concat(ordinalityColumn || []),\n                });\n            }\n\n            resultJson = {\n                ...resultJson,\n                result_schema: resultSchema\n            };\n        }\n\n        return resultJson;\n    }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\nimport { ResultSchemaMixin } from '../../abstracts/ResultSchemaMixin.js';\nimport { registry } from '../../registry.js';\n\nexport class SRFExpr3 extends ResultSchemaMixin(AbstractNode) {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'CallExpr', as: 'call_expr' },\n            { type: 'SRFExprDDL1', as: 'qualif', optional: true },\n        ];\n    }\n\n    /* AST API */\n\n    callExpr() { return this._get('call_expr'); }\n\n    qualif() { return this._get('qualif'); }\n\n    /* JSON API */\n\n    jsonfy(options = {}, transformer = null, schemaInference = null) {\n        let resultJson = super.jsonfy(options, transformer, schemaInference);\n        if (options.deSugar) {\n\n            let resultSchema;\n            if (resultJson.qualif?.column_defs.length) {\n                // a. Compose from \"column_defs\"\n                resultSchema = registry.JSONSchema.fromJSON({\n                    entries: resultJson.qualif.column_defs,\n                });\n            } else if (resultJson.call_expr?.result_schema) {\n                // b. Compose from existing\n                const givenSchema = resultJson.call_expr.result_schema;\n                resultSchema = givenSchema instanceof registry.TableSchema || givenSchema instanceof registry.JSONSchema\n                    ? givenSchema.clone()\n                    : registry.JSONSchema.fromJSON({\n                        entries: [givenSchema.jsonfy()],\n                    });\n            } else {\n                // c. Compose from Func expr\n                const schemaIdentFromFuncName = { nodeName: registry.Identifier.NODE_NAME, value: resultJson.call_expr.name };\n                resultSchema = registry.JSONSchema.fromJSON({\n                    entries: [{\n                        nodeName: registry.ColumnSchema.NODE_NAME,\n                        name: schemaIdentFromFuncName,\n                        data_type: this.callExpr().dataType().jsonfy(),\n                    }],\n                });\n            }\n\n            resultJson = {\n                ...resultJson,\n                result_schema: resultSchema\n            };\n        }\n\n        return resultJson;\n    }\n}", "import { ResultSchemaMixin } from '../../abstracts/ResultSchemaMixin.js';\nimport { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\nimport { registry } from '../../registry.js';\n\nexport class SRFExpr4 extends ResultSchemaMixin(AbstractNodeList) {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'keyword', value: 'ROWS' },\n            { type: 'keyword', value: 'FROM' },\n            {\n                type: 'paren_block',\n                syntax: { type: 'SRFExpr3', as: 'entries', arity: { min: 1 }, itemSeparator, assert: true, autoIndent: 2 },\n                autoIndent: true\n            },\n            {\n                optional: true,\n                syntax: [\n                    { type: 'keyword', as: 'with_ordinality', value: 'WITH', booleanfy: true },\n                    { type: 'keyword', value: 'ORDINALITY', assert: true },\n                ]\n            }\n        ];\n    }\n\n    static get syntaxPriority() { return -1; }\n\n    /* AST API */\n\n    withOrdinality() { return this._get('with_ordinality'); }\n\n    /* JSON API */\n\n    jsonfy(options = {}, transformer = null, schemaInference = null) {\n        let resultJson = super.jsonfy(options, transformer, schemaInference);\n        if (options.deSugar) {\n            let colIdx = 1;\n            const entries = resultJson.entries.reduce((entries, exprJson) => {\n                const exprJsonEntries = exprJson.result_schema.jsonfy().entries.map((x) => ({ ...x, name: { ...x.name, value: colIdx++ } }));\n                return entries.concat(exprJsonEntries);\n            }, []);\n            if (resultJson.with_ordinality) {\n                entries.push({\n                    name: { nodeName: registry.Identifier.NODE_NAME, value: colIdx },\n                    data_type: { nodeName: registry.DataType.NODE_NAME, value: 'INT' },\n                });\n            }\n            const resultSchema = registry.JSONSchema.fromJSON({ entries });\n            resultJson = {\n                ...resultJson,\n                result_schema: resultSchema\n            };\n        }\n\n        return resultJson;\n    }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class SRFExprDDL1 extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'keyword', as: 'as_kw', value: 'AS' },\n            {\n                type: 'paren_block',\n                syntax: { type: 'ColumnSchema', as: 'column_defs', arity: { min: 1 }, itemSeparator },\n            }\n        ];\n    }\n\n    /* AST API */\n\n    asKW() { return this._get('as_kw'); }\n\n    columnDefs() { return this._get('column_defs'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class SRFExprDDL2 extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            {\n                syntaxes: [\n                    { type: 'Identifier', as: 'alias', peek: [1, 'paren_block'] },\n                    [\n                        { type: 'keyword', as: 'as_kw', value: 'AS', peek: [2, 'paren_block'] },\n                        { type: 'Identifier', as: 'alias', assert: true }\n                    ]\n                ]\n            },\n            {\n                type: 'paren_block',\n                syntax: { type: 'ColumnSchema', as: 'column_defs', arity: { min: 1 }, itemSeparator },\n            }\n        ];\n    }\n\n    /* AST API */\n\n    asKW() { return this._get('as_kw'); }\n\n    alias() { return this._get('alias'); }\n\n    columnDefs() { return this._get('column_defs'); }\n}", "import { ValuesConstructor } from '../../dml/constructors/ValuesConstructor.js';\n\nexport class ValuesTableLiteral extends ValuesConstructor {\n    \n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return { type: 'paren_block', syntax: super.syntaxRules, autoIndent: true };\n    }\n}", "import { AbstractNonDDLStmt } from '../abstracts/AbstractNonDDLStmt.js';\nimport { registry } from '../registry.js';\n\nexport class SelectStmt extends AbstractNonDDLStmt {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() { return { type: ['CompleteSelectStmt', 'CompositeSelectStmt'], expression: 2 }; }\n\n    static buildSyntaxRules(part = null) {\n        const part1 = (extRules = []) => [\n            { type: 'keyword', value: 'SELECT' },\n            { type: 'DistinctClause', as: 'distinct_clause', optional: true },\n            { type: 'SelectList', as: 'select_list' },\n            {\n                optional: true,\n                syntax: [\n                    { type: 'FromClause', as: 'from_clause', autoSpacing: '\\n' },\n                    { type: 'JoinClause', as: 'join_clauses', arity: Infinity, optional: true, autoSpacing: '\\n' },\n                    { type: 'MYPartitionClause', as: 'my_partition_clause', optional: true, autoSpacing: '\\n' },\n                    { type: 'WhereClause', as: 'where_clause', optional: true, autoSpacing: '\\n' },\n                    {\n                        optional: true,\n                        syntax: [\n                            { type: 'GroupByClause', as: 'group_by_clause', autoSpacing: '\\n' },\n                            { type: 'HavingClause', as: 'having_clause', optional: true, autoSpacing: '\\n' },\n                        ],\n                    },\n                    { type: 'WindowClause', as: 'window_clause', optional: true, autoSpacing: '\\n' },\n                    ...\n                    extRules\n                ], autoSpacing: '\\n',\n            },\n        ];\n        const part2 = () => [\n            { type: 'OrderByClause', as: 'order_by_clause', optional: true, autoSpacing: '\\n' },\n            { type: 'LimitClause', as: 'limit_clause', optional: true, autoSpacing: '\\n' },\n            { type: 'OffsetClause', as: 'offset_clause', optional: true, autoSpacing: '\\n' },\n            { type: 'PGFetchClause', as: 'pg_fetch_clause', optional: true, dialect: 'postgres', autoSpacing: '\\n' },\n            { type: 'ForClause', as: 'for_clause', optional: true, autoSpacing: '\\n' },\n        ];\n        if (part === 1) return part1();\n        if (part === 2) return part2();\n        return part1(part2());\n    }\n\n    dataType() { return registry.DataType.fromJSON({ value: 'SET' }); }\n}\n", "import { Transformer } from '../Transformer.js';\nimport { SelectorStmtMixin } from '../abstracts/SelectorStmtMixin.js';\nimport { ErrorRefUnknown } from '../expr/ref/abstracts/ErrorRefUnknown.js';\nimport { SelectStmt } from './SelectStmt.js';\nimport { registry } from '../registry.js';\n\nexport class BasicSelectStmt extends SelectorStmtMixin(\n    SelectStmt\n) {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() { return this.buildSyntaxRules(1); }\n\n    static get syntaxPriority() { return -1; }\n\n    /* Schema API */\n\n    distinctClause() { return this._get('distinct_clause'); }\n\n    selectList() { return this._get('select_list'); }\n\n    fromClause() { return this._get('from_clause'); }\n\n    joinClauses() { return this._get('join_clauses'); }\n\n    whereClause() { return this._get('where_clause'); }\n\n    groupByClause() { return this._get('group_by_clause'); }\n\n    havingClause() { return this._get('having_clause'); }\n\n    windowClause() { return this._get('window_clause'); }\n\n    // -- MySQL\n\n    myPartitionClause() { return this._get('my_partition_clause'); }\n\n    // --------\n\n    get length() { return this.selectList()?.length ?? 0; }\n\n    [Symbol.iterator]() { return (this.selectList() || [])[Symbol.iterator](); }\n\n    /* JSON API */\n\n    jsonfy(options = {}, transformer = null, schemaInference = null) {\n        if (!options.deSugar) return super.jsonfy(options, transformer, schemaInference);\n\n        const deferedTransforms = {\n            select_list: null,\n            group_by_clause: new Set,\n            having_clause: new Set,\n            order_by_clause: new Set,\n        };\n\n        transformer = new Transformer((node, defaultTransform, keyHint) => {\n\n            // Defer SelectItem resolution\n            if (node instanceof registry.SelectList) {\n                deferedTransforms.select_list = defaultTransform;\n                return; // Exclude for now\n            }\n\n            // Trigger fields resolution\n            if (node instanceof registry.GroupByClause\n                || node instanceof registry.HavingClause\n                || (node instanceof registry.OrderByClause && node.parentNode === this/* to exclude ORDER BYs within window functions */)) {\n                // Try to capture Linked QL's native GROUP BY clause that's derived\n                // from a back ref, which won't resolve at this time because the relevant generated JOIN\n                // hasn't been add\n                return defaultTransform((childNode, defaultChildTransform, subKeyHint) => {\n                    if ((typeof subKeyHint === 'number' || subKeyHint === 'expr'/* For Having clause */) && childNode.parentNode === node) {\n                        try {\n                            deferedTransforms[keyHint].add(defaultChildTransform());\n                        } catch (e) {\n                            if (e instanceof ErrorRefUnknown) {\n                                deferedTransforms[keyHint].add(defaultChildTransform);\n                            } else throw e;\n                        }\n                        return; // Exclude for now\n                    }\n                    return defaultChildTransform();\n                });\n            }\n\n            // For all other things...\n            return defaultTransform();\n        }, transformer, this/* IMPORTANT */);\n\n        // --------------\n\n        // 0. Run transform\n        let resultJson = super.jsonfy(options, transformer, schemaInference);\n\n        // 1. Transform the defered selectList\n        let selectListJson = deferedTransforms.select_list();\n\n        // 2. Finalize generated JOINS\n        // Generated JOINs are injected into the query\n        const { select_list: _, ..._resultJson } = this.finalizeSelectorJSON(resultJson, transformer, schemaInference, options);\n\n        // 3. Re-resolve output list for cases of just-added deep refs in selectList\n        // wherein schemas wouldn't have been resolvable at the time\n        // 4. Finalize output list for the last time, honouring given deSugaring level with regards to star selects \"*\"\n        // and ofcos finalize output schemas\n        selectListJson = this.selectList().finalizeJSON(selectListJson, transformer, schemaInference, options);\n\n        // Apply now\n        resultJson = {\n            select_list: selectListJson,\n            ..._resultJson,\n            result_schema: selectListJson.result_schema,\n            origin_schemas: this.getOriginSchemas(transformer),\n        };\n\n        // --------------\n\n        // 5. Resolve deferred GROUP BYs and HAVINGs\n        // after having published artifacts.outputSchemas\n        for (const [fieldName, deferreds] of Object.entries(deferedTransforms)) {\n\n            if (fieldName === 'select_list' || !deferreds.size) continue;\n            const resolveds = [];\n\n            for (let deferred of deferreds) {\n                if (typeof deferred === 'function') {\n                    deferred = deferred();\n                }\n                resolveds.push(deferred);\n            }\n\n            if (fieldName === 'having_clause') {\n                resultJson = { ...resultJson, [fieldName]: { expr: resolveds[0] } };\n            } else if (fieldName === 'group_by_clause' || fieldName === 'order_by_clause') {\n                resultJson = { ...resultJson, [fieldName]: { entries: resolveds } };\n            }\n        }\n\n        return resultJson;\n    }\n}", "import { BasicSelectStmt } from './BasicSelectStmt.js';\n\nexport class CompleteSelectStmt extends BasicSelectStmt {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() { return this.buildSyntaxRules(); }\n\n    static get syntaxPriority() { return 99; }\n\n    /* AST API */\n\n    orderByClause() { return this._get('order_by_clause'); }\n\n    offsetClause() { return this._get('offset_clause'); }\n\n    limitClause() { return this._get('limit_clause'); }\n\n    forClause() { return this._get('for_clause'); }\n\n    // -- Postgres\n\n    pgFetchClause() { return this._get('pg_fetch_clause'); }\n}", "import { SelectStmt } from './SelectStmt.js';\nimport { Transformer } from '../Transformer.js';\nimport { registry } from '../registry.js';\n\nexport class CompositeSelectStmt extends SelectStmt {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const operandTypes = ['DerivedQuery', 'ValuesTableLiteral', 'ValuesConstructor', 'TableStmt', 'BasicSelectStmt'];\n        return [\n            { type: [...operandTypes, 'CompositeSelectStmt'], as: 'left' },\n            { type: 'operator', as: 'operator', value: ['INTERSECT', 'UNION', 'EXCEPT'], autoSpacing: '\\n' },\n            { type: 'keyword', as: 'all_or_distinct', value: ['ALL', 'DISTINCT'], optional: true },\n            { type: operandTypes, as: 'right', assert: true, autoSpacing: '\\n' },\n            ...\n            this.buildSyntaxRules(2),\n        ];\n    }\n\n    static get syntaxPriority() { return -1; }\n\n    /* AST API */\n\n    left() { return this._get('left'); }\n\n    operator() { return this._get('operator'); }\n\n    allOrDistinct() { return this._get('all_or_distinct'); }\n\n    right() { return this._get('right'); }\n\n    // --------\n\n    orderByClause() { return this._get('order_by_clause'); }\n\n    offsetClause() { return this._get('offset_clause'); }\n\n    limitClause() { return this._get('limit_clause'); }\n\n    forClause() { return this._get('for_clause'); }\n\n    // -- Postgres\n\n    pgFetchClause() { return this._get('pg_fetch_clause'); }\n\n    // --------\n\n    get length() { return this.left()?.length ?? 0; }\n\n    [Symbol.iterator]() { return (this.left() || [])[Symbol.iterator](); }\n\n    /* JSON API */\n\n    jsonfy(options = {}, transformer = null, schemaInference = null) {\n        if (!options.deSugar) return super.jsonfy(options, transformer, schemaInference);\n\n        const deferedTransforms = { order_by_clause: null };\n        transformer = new Transformer((node, defaultTransform) => {\n            if (node instanceof registry.OrderByClause) {\n                deferedTransforms.order_by_clause = defaultTransform;\n                return; // Exclude for now\n            }\n            return defaultTransform();\n        }, transformer, this/* IMPORTANT */);\n\n        let resultJson = super.jsonfy(options, transformer, schemaInference);\n\n        const resultSchema = resultJson.left.result_schema;\n        transformer.statementContext.artifacts.set('outputSchemas', new Set(resultSchema?.entries() || []));\n        const order_by_clause = deferedTransforms.order_by_clause?.();\n\n        resultJson = { ...resultJson, order_by_clause, result_schema: resultSchema };\n        return resultJson;\n    }\n\n    /* Parser */\n\n    static async _parseFromRules(tokenStream, syntaxRules, { left = undefined, minPrecedence = 0, trail, ...options }, resultAST = {}) {\n        // TODO: a better way to fix this left recursion\n        const trailTail = trail.slice(-3);\n        if (trailTail[0] === this.NODE_NAME && trailTail[2] === this.NODE_NAME) return;\n        // Special support for Pratt parsers that might be bringing \"CompleteSelectStmt\" as left.\n        if ((await tokenStream.match('operator'))?.isSetOp && left instanceof registry.CompleteSelectStmt) {\n            // We first assert\n            if (left.orderByClause() || left.offsetClause() || left.limitClause() || left.forClause()) {\n                const current = tokenStream.current();\n                const message = `[${this.NODE_NAME}] Unexpected ${current.type} token:${typeof current.value === 'string' ? ` \"${current.value}\"` : ''} at <line ${current.line}, column ${current.column}>`;\n                throw new SyntaxError(message);\n            }\n            // We auto convert\n            left = registry.BasicSelectStmt.fromJSON({ ...left.jsonfy(), nodeName: undefined });\n        }\n        return await super._parseFromRules(tokenStream, syntaxRules, { left, minPrecedence, trail, ...options }, resultAST);\n    }\n}", "import { AbstractNonDDLStmt } from '../abstracts/AbstractNonDDLStmt.js';\nimport { registry } from '../registry.js';\n\nexport class TableStmt extends AbstractNonDDLStmt {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', value: 'TABLE' },\n            { type: 'keyword', as: 'pg_only_kw', value: 'ONLY', optional: true, dialect: 'postgres' },\n            { type: 'TableRef2', as: 'table_ref', assert: true },\n            { type: 'operator', as: 'pg_star_ref', value: '*', booleanfy: true, optional: true, dialect: 'postgres' },\n        ];\n    }\n\n    /* AST API */\n\n    tableRef() { return this._get('table_ref'); }\n\n    // -- Postgres\n\n    pgOnlyKW() { return this._get('pg_only_kw'); }\n\n    pgStarRef() { return this._get('pg_star_ref'); }\n\n    /* JSON API */\n\n    jsonfy(options = {}, transformer = null, schemaInference = null) {\n        let resultJson = super.jsonfy({ ...options, forceDeSugar: options.deSugar }, transformer, schemaInference);\n        if (options.deSugar) {\n            const tableSchema = resultJson.table_ref.result_schema;\n            resultJson = {\n                ...resultJson,\n                result_schema: registry.JSONSchema.fromJSON({ entries: tableSchema.jsonfy().entries }),\n                origin_schemas: [tableSchema], // or this.getOriginSchemas(transformer)\n            };\n        }\n        return resultJson;\n    }\n}", "export { AggrNotation } from './AggrNotation.js';\nexport { LQVersionSpec } from './LQVersionSpec.js';\n", "import { AbstractNode } from '../abstracts/AbstractNode.js';\n\nexport class AggrNotation extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            type: 'bracket_block', syntax: { type: 'Expr', as: '_', arity: 0, assert: true }\n        };\n    }\n\n    static get syntaxPriority() { return -1; }\n}", "import { AbstractNode } from '../abstracts/AbstractNode.js';\n\nexport class LQVersionSpec extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() { return { type: 'version_spec', as: '.' }; }\n\n    static get syntaxPriority() { return -1; }\n\n    /* AST API */\n\n    value() { return this._get('value'); }\n}", "export { DataType } from './DataType.js';\n", "import { AbstractNode } from '../abstracts/AbstractNode.js';\n\nexport class DataType extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            {\n                syntaxes: [\n                    [\n                        { type: 'data_type', as: '.', value: ['TIME', 'TIMESTAMP'], dialect: 'postgres' },\n                        { type: 'data_type', as: '.', value: ['TIME', 'TIMESTAMP', 'DATETIME'], dialect: 'mysql' },\n                        {\n                            optional: true,\n                            dialect: 'postgres',\n                            syntax: [\n                                { type: 'keyword', as: 'pg_with_tz', value: ['WITH', 'WITHOUT'] },\n                                { type: 'keyword', value: 'TIME ZONE', assert: true },\n                            ]\n                        }\n                    ],\n                    { type: 'data_type', as: '.' },\n                    { type: 'keyword', as: '.', value: ['SET'] },\n                ]\n            },\n            {\n                type: 'paren_block',\n                syntax: { type: 'Expr', as: 'specificity', arity: Infinity, itemSeparator, assert: true },\n                optional: true,\n                optionalParens: true,\n                autoSpacing: false\n            },\n            { type: 'AggrNotation', as: 'pg_is_aggr', autoSpacing: false, optional: true, dialect: 'postgres' },\n        ];\n    }\n\n    /* AST API */\n\n    value() { return this._get('value'); }\n\n    specificity() { return this._get('specificity'); }\n\n    // -- Postgres\n\n    pgIsAggr() { return this._get('pg_is_aggr'); }\n\n    pgWithTZ() { return this._get('pg_with_tz'); }\n}", "import { AbstractNodeList } from './AbstractNodeList.js';\n\nexport class JSONSchema extends AbstractNodeList {\n    \n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return { type: ['JSONSchema', 'TableSchema', 'ColumnSchema', 'ColumnRef1'/* result of resolving ColumnRef0 */], as: 'entries', arity: Infinity };\n    }\n}", "import { AbstractStmt } from './abstracts/AbstractStmt.js';\nimport { TokenStream } from './TokenStream.js';\n\nexport class StdStmt extends AbstractStmt {\n\n    static fromJSON(inputJson, options = {}, callback = null) {\n        if (inputJson instanceof StdStmt) {\n            return super.fromJSON(inputJson, options, callback);\n        }\n        const { nodeName, ...restJson } = inputJson;\n        if (nodeName && nodeName !== this.NODE_NAME) return;\n        if (Object.keys(restJson).join('') !== 'sql') return;\n        if (typeof callback === 'function') {\n            return callback(restJson, options);\n        }\n        return new this(restJson, options);\n    }\n\n    jsonfy(options = {}, transformer = null, schemaInference = null) {\n        return {\n            nodeName: this.NODE_NAME,\n            sql: this._get('sql'),\n        };\n    }\n\n    sql() { return this._get('sql'); }\n\n    static async parse(sql, options = {}) {\n        const test = (sql) => (typeof sql === 'string'\n            && !/^(\\((\\s+)?)?(WITH|TABLE|SELECT|DELETE|INSERT|UPDATE|UPSERT|CREATE|DROP|SET)\\s+/i.test(sql.trimStart()));\n        \n        if (sql instanceof TokenStream) {\n            const _sql = [];\n\n            if (sql.current()) {\n                if (!test(sql.current().value)) return;\n                _sql.push(sql.current().value);\n            }\n\n            await (async function render(tokenStream) {\n                for await (const tok of tokenStream) {\n                    if (tok.spaceBefore) _sql.push(tok.spaceBefore);\n                    if (tok.value instanceof TokenStream) {\n                        const tag = tok.type === 'bracket_block' ? ['{', '}'] : (\n                            tok.type === 'bracket_block' ? ['[', ']'] : ['(', ')']\n                        );\n                        _sql.push(tag[0]);\n                        await render(tok.value);\n                        _sql.push(tag[1]);\n                    } else _sql.push(tok.value);\n                    if (tok.value === ';') break;\n                }\n            })(sql);\n\n            sql = _sql.join('');\n        }\n\n        if (!sql || !test(sql)) return;\n\n        return new this({ sql }, { ...options });\n    }\n\n    stringify() { return this._get('sql'); }\n}", "import { AbstractNodeList } from './abstracts/AbstractNodeList.js';\nimport { StdStmt } from './StdStmt.js';\n\nexport class Script extends AbstractNodeList {\n\n    /* SYNTAX RULES */\n\n    static get _contentTypes() {\n        return [\n            'SelectStmt',\n            'TableStmt',\n            'InsertStmt',\n            'UpsertStmt',\n            'UpdateStmt',\n            'DeleteStmt',\n            'MYSetStmt',\n            'PGSetStmt',\n            'CTE',\n            'CreateSchemaStmt',\n            'DropSchemaStmt',\n            'CreateTableStmt',\n            'DropTableStmt',\n            'StdStmt',\n        ];\n    }\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ';' };\n        return { type: this._contentTypes, as: 'entries', arity: Infinity, itemSeparator, autoSpacing: '\\n' };\n    }\n\n    /* API */\n\n    static async parse(input, options = {}) {\n        const tokenStream = await this.toStream(input, options);\n        const result = await super.parse(tokenStream, options);\n        if (!tokenStream.done && tokenStream.current()) {\n            const current = tokenStream.current();\n            const message = `[${this.NODE_NAME}] Unexpected ${current.type} token:${typeof current.value === 'string' ? ` \"${current.value}\"` : ''} at <line ${current.line}, column ${current.column}>`;\n            throw new SyntaxError(message);\n        }\n        return result;\n    }\n\n\tstatic async _parseFromRules(tokenStream, syntaxRules, { left, minPrecedence, trail, ...options }, resultAST = {}) {\n        let rulesArray;\n        if (!options.supportStdStmt && (rulesArray = [].concat(syntaxRules)).length === 1 && Array.isArray(rulesArray[0].type) && rulesArray[0].type.includes('StdStmt')) {\n            syntaxRules = { ...rulesArray[0], type: rulesArray[0].type.filter((r) => r !== 'StdStmt') };\n        }\n\t\treturn super._parseFromRules(tokenStream, syntaxRules, { left, minPrecedence, trail, ...options }, resultAST);\n\t}\n\n    stringify(options = {}) { return `${super.stringify(options)};`; }\n}", "import * as cte from './cte/index.js';\nimport * as ddl from './ddl/index.js';\nimport * as dml from './dml/index.js';\nimport * as dql from './dql/index.js';\nimport * as expr from './expr/index.js';\nimport * as qualif from './qualif/index.js';\nimport * as type from './type/index.js';\nimport { JSONSchema } from './abstracts/JSONSchema.js';\nimport { StdStmt } from './StdStmt.js';\nimport { Script } from './Script.js';\nimport { registry } from './registry.js';\n\nObject.assign(registry, { ...cte, ...ddl, ...dml, ...dql, ...expr, ...qualif, ...type, StdStmt, Script, JSONSchema });\n", "export class SimpleEmitter {\n\n    #listeners = new Map;\n    #closeCallbacks = new Set;\n\n    on(event, fn) {\n        if (!this.#listeners.has(event)) {\n            this.#listeners.set(event, new Set);\n        }\n        this.#listeners.get(event).add(fn);\n        return () => {\n            this.#listeners.get(event).delete(fn);\n            if (!this.#listeners.get(event).size) {\n                this.#listeners.delete(event);\n                if (!this.#listeners.size) {\n                    for (const fn of this.#closeCallbacks) fn();\n                    this.#closeCallbacks.clear();\n                }\n            }\n        };\n    }\n\n    onClose(fn) { this.#closeCallbacks.add(fn); }\n\n    emit(event, payload) {\n        const s = this.#listeners.get(event);\n        if (!s) return;\n        for (const fn of s) {\n            fn(payload);\n            try {\n            } catch (err) {\n                // eslint-disable-next-line no-console\n                console.error('emitter handler error', err);\n            }\n        }\n    }\n}\n", "import { NamespaceSchema } from './ddl/namespace/NamespaceSchema.js';\nimport { matchRelationSelector, normalizeRelationSelectorArg } from '../entry/abstracts/util.js';\n\nexport class SchemaInference {\n\n    #searchPath = ['public'];\n    get searchPath() {\n        return this.#searchPath;\n    }\n\n    #driver;\n    #queryHistory = new Map;\n\n    #catalog;\n    get catalog() { return this.#catalog; }\n\n    #options;\n    get options() { return this.#options; }\n\n    constructor({ driver, catalog = [] } = {}, options = {}) {\n        this.#driver = driver;\n        this.#catalog = new Set(catalog);\n        this.#options = options;\n    }\n\n    async provide(selector) {\n        const currentEntries = [...this.#queryHistory.entries()];\n        const diffedSelectors = {};\n        let intersectionFound = false;\n        const pendingFulfilments = [];\n        const newRecords = [];\n        const match = (a, b) => {\n            // Exact match?\n            if (b.includes(a)) return true;\n            // If incoming is a pattern... no matching\n            if (/^!|^%|%$|^\\*$/.test(a)) return false;\n            // If a IN b\n            return matchRelationSelector(a, b);\n        };\n        const order = (x, a, b) => {\n            // Exact match should come first\n            if (a[0] === x) return -1;\n            if (b[0] === x) return 1;\n            // Wildcard should come last\n            if (a[0] === '*') return 1;\n            if (b[0] === '*') return -1;\n            return 0;\n        };\n        const admit = (namespaceName, tables) => {\n            diffedSelectors[namespaceName] = tables;\n            // Create or update a record for the selector\n            const newTableList = [].concat(this.#queryHistory.get(namespaceName)?.tables || []).concat(tables);\n            const newRecord = { namespace: namespaceName, tables: newTableList, fulfilment: null };\n            this.#queryHistory.set(namespaceName, newRecord);\n            newRecords.push(newRecord);\n        };\n        const diff = (namespaceName, tables) => {\n            if (!currentEntries.length) return admit(namespaceName, tables);\n            const currentEntries_sorted = currentEntries.sort((a, b) => order(namespaceName, a, b));\n            for (const [namespaceNameSpec, existingRecord] of currentEntries_sorted) {\n                // See if intersects with namespaceNameSpec & currentEntries_sorted\n                if (match(namespaceName, [namespaceNameSpec])) {\n                    const diffedTables = tables.filter((t) => !match(t, existingRecord.tables));\n                    // If intersects with existingRecord's tables... wait for fulfilment\n                    if (diffedTables.length < tables.length) {\n                        intersectionFound = true;\n                        if (existingRecord.fulfilment) {\n                            pendingFulfilments.push(existingRecord.fulfilment);\n                        }\n                    }\n                    if (diffedTables.length) {\n                        admit(namespaceName, diffedTables);\n                    }\n                } else {\n                    admit(namespaceName, tables);\n                }\n            }\n        };\n        // -----------------------------\n        // Pre-process selector\n        selector = normalizeRelationSelectorArg(selector);\n        for (const [namespaceName, objectNames] of Object.entries(selector)) {\n            diff(namespaceName, objectNames);\n        }\n        // -----------------------------\n        // Build final fulfilment list\n        let currentFulfilment,\n            totalFulfilment = Promise.resolve(0);\n        if (Object.keys(diffedSelectors).length) {\n            currentFulfilment = this.#driver?.showCreate(diffedSelectors, true);\n            pendingFulfilments.push(currentFulfilment);\n            for (const newRecord of newRecords) {\n                newRecord.fulfilment = currentFulfilment;\n            }\n            currentFulfilment.finally(() => {\n                for (const newRecord of newRecords) {\n                    newRecord.fulfilment = null;\n                }\n            });\n            totalFulfilment = Promise.all(pendingFulfilments).then(() => intersectionFound ? 2 : 1);\n        } else if (pendingFulfilments.length) {\n            totalFulfilment = Promise.all(pendingFulfilments).then(() => -1);\n        }\n        // -----------------------------\n        // Process request if any\n        const resultSchemas = await currentFulfilment;\n        if (resultSchemas?.length) {\n            for (const resultSchema of resultSchemas) {\n                // Instantiate...\n                const newNamespaceSchema = NamespaceSchema.fromJSON(resultSchema, { dialect: this.#driver.dialect });\n                for (const existingNamespaceSchema of this.#catalog) {\n                    if (existingNamespaceSchema.name().identifiesAs(newNamespaceSchema.name())) {\n                        // Inherit existing tables from existingNamespaceSchema\n                        for (const existingTableSchema of existingNamespaceSchema.tables()) {\n                            if (!newNamespaceSchema.has(existingTableSchema.name())) {\n                                newNamespaceSchema.add(existingTableSchema.clone());\n                            }\n                        }\n                        // Delete existingNamespaceSchema\n                        this.#catalog.delete(existingNamespaceSchema);\n                    }\n                }\n                // Register newNamespaceSchema\n                this.#catalog.add(newNamespaceSchema);\n            }\n        }\n        return await totalFulfilment;\n    }\n}", "import '../../lang/index.js';\nimport { SimpleEmitter } from './SimpleEmitter.js';\nimport { normalizeRelationSelectorArg } from './util.js';\nimport { SchemaInference } from '../../lang/SchemaInference.js';\n\nexport class AbstractClient extends SimpleEmitter {\n\n    #subscribers = new Map;\n\n    #schemaInference;\n\n    #capabilityOverride;\n    #workingCapability;\n\n    get schemaInference() { return this.#schemaInference; }\n\n    constructor({ capability = {} } = {}) {\n        super();\n        this.#capabilityOverride = capability;\n        this.#workingCapability = capability;\n        this.#schemaInference = new SchemaInference({ driver: this });\n    }\n\n    async connect() {\n        await this._connect();\n    }\n\n    async disconnect() {\n        await this.setCapability({ realtime: false });\n        await this._disconnect();\n    }\n\n    // ---------\n\n    async parse(querySpec, { alias = null, dynamicWhereMode = false, ...options } = {}) {\n        throw new Error(`parse() is unimplemented`);\n    }\n\n    async resolve(query, options = {}) {\n        throw new Error(`resolve() is unimplemented`);\n    }\n\n    async query(...args) {\n        throw new Error(`resolve() is unimplemented`);\n    }\n\n    async cursor(...args) {\n        throw new Error(`resolve() is unimplemented`);\n    }\n\n    async showCreate(selector, structured = false) {\n        throw new Error(`resolve() is unimplemented`);\n    }\n\n    async subscribe(selector, callback) {\n        await this.setCapability({ realtime: true });\n\n        if (typeof selector === 'function') {\n            callback = selector;\n            selector = '*';\n        }\n\n        const flattenedSelectorSet = normalizeRelationSelectorArg(selector, true);\n        this.#subscribers.set(callback, flattenedSelectorSet);\n\n        return async () => {\n            this.#subscribers.delete(callback);\n            if (!this.#subscribers.size) {\n                await this.setCapability({ realtime: false });\n            }\n        };\n    }\n\n    async setCapability(capMap) {\n        const _capMap = Object.fromEntries(Object.entries(capMap).filter(([k, v]) => {\n            return !v || this.#capabilityOverride[k] !== false;\n        }));\n        // realtime?\n        if (_capMap.realtime === false) {\n            await this._teardownRealtime();\n        } else if (_capMap.realtime) {\n            await this._setupRealtime();\n        }\n        // Publish...\n        this.#workingCapability = {\n            ...this.#workingCapability,\n            ..._capMap,\n        };\n    }\n\n    // ---------\n\n    _fanout(events) {\n        const eventsAndPatterns = [];\n        const allPatterns = new Set;\n        for (const event of events) {\n            const patterns = [\n                JSON.stringify([event.relation.namespace, event.relation.name]),\n                JSON.stringify(['*', event.relation.name]),\n                JSON.stringify([event.relation.namespace, '*']),\n            ];\n            eventsAndPatterns.push({ event, patterns });\n            allPatterns.add(patterns[0]);\n            allPatterns.add(patterns[1]);\n            allPatterns.add(patterns[2]);\n        }\n        for (const [cb, flattenedSelectorSet] of this.#subscribers.entries()) {\n            let _events = [];\n            // Match and filter\n            for (const pattern of flattenedSelectorSet) {\n                if (pattern === '[\"*\",\"*\"]') {\n                    _events = [...events];\n                    break;\n                } else if (allPatterns.has(pattern)) {\n                    for (const { event, patterns } of eventsAndPatterns) {\n                        if (patterns.includes(pattern)) {\n                            _events.push(event);\n                        }\n                    }\n                    break;\n                }\n            }\n            if (!_events.length) continue;\n            // Successful match\n            cb(_events);\n        }\n    }\n}", "export class Result {\n\n    #rows\n    #rowCount\n\n    get rows() { return this.#rows; }\n    get rowCount() { return this.#rowCount; }\n    get affectedRows() { return this.#rowCount; }\n\n    constructor({ rows = [], rowCount = 0 } = {}) {\n        this.#rows = rows;\n        this.#rowCount = rowCount;\n    }\n}", "import { _eq } from '../../lang/abstracts/util.js';\nimport { Result } from '../../entry/Result.js';\n\nexport class RealtimeResult extends Result {\n\n    #hashes;\n    #abortLine;\n\n    get hashes() { return this.#hashes; }\n    \n    constructor({ rows = [], hashes = [] } = {}, abortLine = (() => undefined), signal = undefined) {\n        super({ rows });\n\n        this.#hashes = hashes;\n\n        this.#abortLine = abortLine;\n        if (signal) signal.addEventListener('abort', () => this.abort());\n    }\n\n    abort() { this.#abortLine(); }\n\n    async _apply(eventName, eventData) {\n        const Obs = typeof Observer === 'undefined' \n            ? (await import('@webqit/observer')).default\n            : Observer;\n        const $rows = Obs.proxy(this.rows);\n        if (eventName === 'diff') {\n            Obs.batch(this.rows, () => {\n                for (let event of eventData) {\n                    if (event.type === 'update') {\n                        const i = this.#hashes.indexOf(event.oldHash);\n                        if (i > -1) {\n                            Obs.set(this.rows[i], event.new, { diff: true });\n                            this.#hashes[i] = event.newHash;\n                        } else {\n                            event = { ...event, type: 'insert' };\n                        }\n                    }\n                    if (event.type === 'insert') {\n                        $rows.push(event.new);\n                        this.#hashes.push(event.newHash);\n                    }\n                    if (event.type === 'delete') {\n                        const i = this.#hashes.indexOf(event.oldHash);\n                        if (i > -1) {\n                            $rows.splice(i, 1);\n                            this.#hashes.splice(i, 1);\n                        }\n                    }\n                }\n            });\n        }\n\n        if (eventName === 'swap') {\n            Obs.batch(this.rows, () => {\n                const _rows = this.rows.slice(0);\n                const _hashes = this.#hashes.slice(0);\n                for (const [hash, targetHash] of eventData) {\n                    const i_a = _hashes.indexOf(hash);\n                    const i_b = _hashes.indexOf(targetHash);\n                    $rows[i_b] = _rows[i_a];\n                    this.#hashes[i_b] = hash;\n                }\n            });\n        }\n\n        if (eventName === 'result') {\n            this.#hashes = eventData.hashes;\n            Obs.batch(this.rows, () => {\n                const maxLen = Math.max(this.rows.length, eventData.rows.length);\n                for (let i = 0; i < maxLen; i ++) {\n                    if (!eventData.rows[i]) {\n                        $rows.splice(i);\n                        break;\n                    }\n                    if (!_eq(eventData.rows[i], this.rows[i])) {\n                        $rows[i] = eventData.rows[i];\n                    }\n                }\n            });\n        }\n    }\n}", "import { AbstractNode } from '../lang/abstracts/AbstractNode.js';\nimport { _eq } from '../lang/abstracts/util.js';\nimport { registry } from '../lang/registry.js';\n\nconst TBL_PLACEHOLDER = Symbol.for('tbl_placeholder');\nconst GROUPING_META = Symbol.for('grouping_meta');\nconst WINDOW_META = Symbol.for('window_meta');\n\nexport class ExprEngine {\n\n    #derivedQueryCallback;\n    #options;\n\n    constructor(derivedQueryCallback = null, options = {}) {\n        this.#derivedQueryCallback = derivedQueryCallback;\n        this.#options = options;\n    }\n\n    async evaluate(node, compositeRow, queryCtx = {}) {\n        if (!node) throw new Error(`ExprEngine: Cannot evaluate null/undefined node`);\n        // Evaluate derived queries via callback\n        if (['DERIVED_QUERY', 'SCALAR_SUBQUERY'].includes(node.NODE_NAME)) {\n            if (!this.#derivedQueryCallback) {\n                throw new Error(`ExprEngine: Node ${node.NODE_NAME} not supported in this context`);\n            }\n            return await this.#derivedQueryCallback(node, compositeRow, queryCtx);\n        }\n        // Dispatch to handler\n        const handler = this[node.NODE_NAME];\n        if (!handler) throw new Error(`ExprEngine: Unsupported AST node: ${node.NODE_NAME}`);\n        return await handler.call(this, node, compositeRow, queryCtx);\n    }\n\n    async evaluateToScalar(expr, compositeRow, queryCtx) {\n        if (expr instanceof registry.DerivedQuery) {\n            const rows = [];\n            for await (const row of await this.evaluate(expr, compositeRow, queryCtx)) rows.push(row);\n            if (!rows.length) return;\n            if (rows.length > 1) throw new Error(`[${node}] Subquery returned more than one row`);\n            const values = Object.values(rows[0]);\n            if (values.length > 1) throw new Error(`[${node}] Subquery returned more than one column`);\n            return values[0] ?? null;\n        }\n        if (expr instanceof registry.RowConstructor) {\n            if (expr.length !== 1) throw new Error(`Expects a scalar expression but got ${expr}`);\n            return await this.evaluateToScalar(expr.entries()[0], compositeRow, queryCtx);\n        }\n        return await this.evaluate(expr, compositeRow, queryCtx);\n    }\n\n    async evaluateToList(expr, compositeRow, queryCtx) {\n        if (expr instanceof registry.DerivedQuery) {\n            const rows = [];\n            for await (const row of await this.evaluate(expr, compositeRow, queryCtx)) rows.push(row);\n            if (!rows.length) return [];\n            if (Object.values(rows[0]).length > 1) throw new Error(`[${node}] Subquery returned more than one column`);\n            return rows.map((r) => Object.values(r)[0]);\n        }\n        if (expr instanceof registry.RowConstructor) {\n            const entries = await Promise.all(expr.entries().map((e) => this.evaluateToScalar(e, compositeRow, queryCtx)));\n            // ----------- asPartial\n            if (entries.some((x) => x instanceof AbstractNode)) {\n                return registry.RowConstructor.fromJSON(\n                    { nodeName: registry.RowConstructor.NODE_NAME, entries: entries.map(toNode) },\n                    { assert: true, dialect: queryCtx.options?.dialect }\n                );\n            }\n            // -----------\n            return entries;\n        }\n        const result = await this.evaluate(expr, compositeRow, queryCtx);\n        if (!Array.isArray(result) && !(result instanceof AbstractNode)) throw new Error(`[${expr}] Not a list`);\n        return result;\n    }\n\n    // --- CLAUSES & CONSTRUCTS ---\n\n    async SELECT_ITEM(node, compositeRow, queryCtx = {}) {\n        const alias = node.alias()?.value() || (this.#options.dialect === 'mysql' ? '?column?'/* TODO */ : '?column?');\n        const value = await this.evaluateToScalar(node.expr(), compositeRow, queryCtx);\n        return { alias, value };\n    }\n\n    async ON_CLAUSE(node, compositeRow, queryCtx = {}) {\n        const result = await this.evaluate(node.expr(), compositeRow, queryCtx);\n        return result;\n    }\n\n    async USING_CLAUSE(node, compositeRow) {\n        const cols = node.columns() || [node.column()];\n        return cols.every((col) => {\n            const colName = col.value();\n            const caliases = Object.keys(compositeRow).filter((a) => a && colName in compositeRow[a]);\n            if (caliases.length < 2) throw new Error(`USING clause column ${colName} not found in both tables`);\n            return caliases.reduce((v, a) => v && _eq(compositeRow[a][colName], compositeRow[caliases[0]][colName]), true);\n        });\n    }\n\n    // --- EXPRESSIONS ---\n\n    async ROW_CONSTRUCTOR(node, compositeRow, queryCtx = {}) {\n        const entries = await Promise.all(node.entries().map((e) => this.evaluateToScalar(e, compositeRow, queryCtx)));\n        if (entries.length === 1) return entries[0];\n        // ----------- asPartial\n        if (entries.some((x) => x instanceof AbstractNode)) {\n            return registry.RowConstructor.fromJSON(\n                { nodeName: registry.RowConstructor.NODE_NAME, entries: entries.map(toNode) },\n                { assert: true, dialect: queryCtx.options?.dialect }\n            );\n        }\n        // -----------\n        return entries;\n    }\n\n    async TYPED_ROW_CONSTRUCTOR(node, compositeRow, queryCtx = {}) {\n        return await this.ROW_CONSTRUCTOR(node, compositeRow, queryCtx);\n    }\n\n    async PG_TYPED_ARRAY_LITERAL(node, compositeRow, queryCtx = {}) {\n        const entries = await Promise.all(node.entries().map((a) => this.evaluate(a, compositeRow, queryCtx)));\n        // ----------- asPartial\n        if (entries.some((x) => x instanceof AbstractNode)) {\n            return registry.PGTypedArrayLiteral.fromJSON(\n                { nodeName: registry.PGTypedArrayLiteral.NODE_NAME, entries: entries.map(toNode) },\n                { assert: true, dialect: queryCtx.options?.dialect }\n            );\n        }\n        // -----------\n        return entries;\n    }\n\n    async CASE_EXPR(node, compositeRow, queryCtx = {}) {\n        const subject = node.subject()\n            ? await this.evaluate(node.subject(), compositeRow, queryCtx)\n            : undefined;\n\n        const partialModeBranches = [];\n\n        for (const branch of node) {\n            const condition = await this.evaluate(branch.condition(), compositeRow, queryCtx);\n            // ----------- asPartial\n            if (subject instanceof AbstractNode || condition instanceof AbstractNode) {\n                partialModeBranches.push({\n                    nodeName: registry.CaseBranch.NODE_NAME,\n                    condition: toNode(condition),\n                    consequent: toNode(await this.evaluate(branch.consequent(), compositeRow, queryCtx)),\n                });\n                continue;\n            }\n            // -----------\n            const test = subject === undefined ? !!condition : _eq(subject, condition);\n            if (test) {\n                const result = await this.evaluate(branch.consequent(), compositeRow, queryCtx);\n                if (!partialModeBranches.length) return result; // Whether or not resolved\n                // ----------- asPartial\n                partialModeBranches.push({\n                    nodeName: registry.CaseBranch.NODE_NAME,\n                    condition: toNode(condition),\n                    consequent: toNode(result),\n                });\n                continue;\n            }\n        }\n\n        let alternate;\n        if (node.alternate()) {\n            alternate = await this.evaluate(node.alternate(), compositeRow, queryCtx);\n            if (!partialModeBranches.length) return alternate; // Whether or not resolved\n        }\n        // ----------- asPartial\n        if (partialModeBranches.length) {\n            return registry.CaseExpr.fromJSON(\n                { nodeName: registry.CaseExpr.NODE_NAME, subject: toNode(subject), entries: partialModeBranches, alternate: toNode(alternate) },\n                { assert: true, dialect: queryCtx.options?.dialect }\n            );\n        }\n        // -----------\n        return null;\n    }\n\n    async CAST_EXPR(node, compositeRow, queryCtx = {}) {\n        return await this._CAST_EXPR(node.expr(), node.dataType(), compositeRow, queryCtx);\n    }\n\n    async PG_CAST_EXPR2(node, compositeRow, queryCtx = {}) {\n        return await this._CAST_EXPR(node.left(), node.right(), compositeRow, queryCtx);\n    }\n\n    async _CAST_EXPR(expr, dataType, compositeRow, queryCtx = {}) {\n        const L = await this.evaluateToScalar(expr, compositeRow, queryCtx);\n        // ----------- asPartial\n        if (L instanceof AbstractNode) {\n            return registry.CastExpr.fromJSON(\n                { nodeName: registry.CastExpr.NODE_NAME, expr: toNode(L), data_type: dataType.jsonfy() },\n                { assert: true, dialect: queryCtx.options?.dialect }\n            );\n        }\n        // -----------\n        const DT = dataType.value();\n        switch (DT) {\n            case 'INT': return parseInt(L);\n            case 'TEXT': return String(L);\n            case 'BOOLEAN': return Boolean(L);\n            default: return L;\n        }\n    }\n\n    async PREDICATE_EXPR(node, compositeRow, queryCtx = {}) {\n        const predicate = node.predicate();\n        switch (predicate) {\n            case 'EXISTS':\n                const expr = await this.evaluate(node.expr(), compositeRow, queryCtx);\n                // ----------- asPartial\n                if (expr instanceof AbstractNode) {\n                    return registry.PredicateExpr.fromJSON(\n                        { nodeName: registry.PredicateExpr.NODE_NAME, predicate, expr },\n                        { assert: true, dialect: queryCtx.options?.dialect }\n                    );\n                }\n                // -----------\n                const result = (await expr.next()).value;\n                return !!result;\n            default: throw new Error(`ExprEngine: Unimplemented predicate ${node.predicate()}`);\n        }\n    }\n\n    async IN_EXPR(node, compositeRow, queryCtx = {}) {\n        const L = await this.evaluateToScalar(node.left(), compositeRow, queryCtx);\n        const R = await this.evaluateToList(node.right(), compositeRow, queryCtx);\n        const negation = node.negation();\n        // ----------- asPartial\n        if (L instanceof AbstractNode || R instanceof AbstractNode) {\n            return registry.InExpr.fromJSON(\n                { nodeName: registry.InExpr.NODE_NAME, left: toNode(L), negation, operator: 'IN', right: toNode(R) },\n                { assert: true, dialect: queryCtx.options?.dialect }\n            );\n        }\n        // -----------\n        const res = (val) => negation ? !val : val;\n        return res(R.some((v) => _eq(L, v)));\n    }\n\n    async BETWEEN_EXPR(node, compositeRow, queryCtx = {}) {\n        const L = await this.evaluateToScalar(node.left(), compositeRow, queryCtx);\n        const R = await Promise.all(node.right().map((e) => this.evaluateToScalar(e, compositeRow, queryCtx)));\n        const negation = node.negation();\n        // ----------- asPartial\n        if (L instanceof AbstractNode || R.some((x) => x instanceof AbstractNode)) {\n            return registry.BetweenExpr.fromJSON(\n                { nodeName: registry.BetweenExpr.NODE_NAME, left: toNode(L), negation, operator: 'BETWEEN', right: R.map(toNode) },\n                { assert: true, dialect: queryCtx.options?.dialect }\n            );\n        }\n        // -----------\n        const res = (val) => negation ? !val : val;\n        return res(L >= R[0] && L <= R[1]);\n    }\n\n    async DISTINCT_FROM_EXPR(node, compositeRow, queryCtx = {}) {\n        const L = await this.evaluate(node.left(), compositeRow, queryCtx);\n        const R = await this.evaluate(node.right(), compositeRow, queryCtx);\n        const logic = node.logic();\n        // ----------- asPartial\n        if (L instanceof AbstractNode || R instanceof AbstractNode) {\n            return registry.DistinctFromExpr.fromJSON(\n                { nodeName: registry.DistinctFromExpr.NODE_NAME, left: toNode(L), logic, operator: 'DISTINCT FROM', right: toNode(R) },\n                { assert: true, dialect: queryCtx.options?.dialect },\n            );\n        }\n        // -----------\n        const negation = logic === 'IS NOT';\n        const res = (val) => negation ? !val : val;\n        return res(!_eq(L, R));\n    }\n\n    async BINARY_EXPR(node, compositeRow, queryCtx = {}) {\n        const op = node.operator().toUpperCase();\n        const negation = node.negation();\n\n        const asPartial = (L, R) => {\n            return registry.BinaryExpr.fromJSON(\n                { nodeName: registry.BinaryExpr.NODE_NAME, operator: op, left: toNode(L), right: toNode(R) },\n                { assert: true, dialect: queryCtx.options?.dialect }\n            );\n        };\n\n        const res = (val) => negation ? !val : val;\n\n        const compare = (L, R) => {\n            const anyIsNull = L === null || R === null;\n            if (anyIsNull && op !== 'IS' && op !== 'IS NOT') return false;\n            switch (op) {\n                case '=':\n                case 'IS': return _eq(L, R);\n                case '<>':\n                case '!=':\n                case 'IS NOT': return !_eq(L, R);\n                case '<': return L < R;\n                case '<=': return L <= R;\n                case '>': return L > R;\n                case '>=': return L >= R;\n                case 'LIKE': return likeCompare(String(L), String(R));\n                default: throw new Error(`ExprEngine: Unsupported comparison operator ${op}`);\n            }\n        };\n\n        if (node.right() instanceof registry.QuantitativeExpr) {\n            const quantifier = node.right().quantifier();\n            const L = await this.evaluateToScalar(node.left(), compositeRow, queryCtx);\n            const R = await this.evaluateToList(node.right().expr(), compositeRow, queryCtx);\n            // ----------- asPartial\n            if (L instanceof AbstractNode || R instanceof AbstractNode) {\n                return asPartial(L, registry.QuantitativeExpr.fromJSON(\n                    { nodeName: registry.QuantitativeExpr.NODE_NAME, quantifier, expr: toNode(R) },\n                    { assert: true, dialect: queryCtx.options?.dialect }\n                ));\n            }\n            // -----------\n            switch (quantifier) {\n                case 'ALL': return res(R.every((R) => compare(L, R)));\n                case 'ANY':\n                case 'SOME': return res(R.some((R) => compare(L, R)));\n            }\n        }\n\n        const L = await this.evaluateToScalar(node.left(), compositeRow, queryCtx);\n        const R = await this.evaluateToScalar(node.right(), compositeRow, queryCtx);\n\n        // Logical - before asPartial\n        if (op === 'AND') return res(L && R);\n        if (op === 'OR') return res(L || R);\n\n        // ----------- asPartial\n        if (L instanceof AbstractNode || R instanceof AbstractNode) {\n            return asPartial(L, R);\n        }\n        // -----------\n        switch (op) {\n            // Comparison\n            case '=':\n            case 'IS':\n            case '<>':\n            case '!=':\n            case 'IS NOT':\n            case '<':\n            case '<=':\n            case '>':\n            case '>=':\n            case 'LIKE': return res(compare(L, R));\n\n            // Arithmetic\n            case '+': return Number(L) + Number(R);\n            case '-': return Number(L) - Number(R);\n            case '/': return Number(L) / Number(R);\n            case '*': return Number(L) * Number(R);\n            case '%': return Number(L) % Number(R);\n\n            // String\n            case '||': return String(L ?? '') + String(R ?? '');\n\n            // JSON\n            case '->':\n            case '->>': {\n                // JSON path accessors\n                if (L == null) return null;\n                let val;\n                if (typeof R === 'number') {\n                    val = Array.isArray(L) ? L[R] : undefined;\n                } else if (typeof R === 'string') {\n                    if (typeof L === 'object' && !Array.isArray(L)) val = L[R];\n                    else if (Array.isArray(L) && !isNaN(R)) val = L[Number(R)];\n                }\n                return op === '->' ? val : (val == null ? null : String(val));\n            }\n            case '#>':\n            case '#>>': {\n                // JSON path extraction (Postgres)\n                // L #> R, where R is array of keys\n                if (L == null || !Array.isArray(R)) return null;\n                let val = L;\n                for (const key of R) {\n                    if (val == null) return null;\n                    if (Array.isArray(val) && !isNaN(key)) val = val[Number(key)];\n                    else if (typeof val === 'object') val = val[key];\n                    else return null;\n                }\n                return op === '#>' ? val : (val == null ? null : String(val));\n            }\n            case '@>': {\n                // JSON contains (Postgres)\n                if (L == null || R == null) return false;\n                if (typeof L !== 'object' || typeof R !== 'object') return false;\n                // Simple deep contains check\n                const contains = (a, b) => {\n                    if (typeof b !== 'object' || b == null) return a === b;\n                    if (Array.isArray(b)) {\n                        if (!Array.isArray(a)) return false;\n                        return b.every((v, i) => contains(a[i], v));\n                    }\n                    return Object.keys(b).every((k) => contains(a[k], b[k]));\n                };\n                return contains(L, R);\n            }\n            case '<@': {\n                // JSON is contained by (Postgres)\n                if (L == null || R == null) return false;\n                if (typeof L !== 'object' || typeof R !== 'object') return false;\n                // Simple deep contains check\n                const contains = (a, b) => {\n                    if (typeof b !== 'object' || b == null) return a === b;\n                    if (Array.isArray(b)) {\n                        if (!Array.isArray(a)) return false;\n                        return b.every((v, i) => contains(a[i], v));\n                    }\n                    return Object.keys(b).every((k) => contains(a[k], b[k]));\n                };\n                return contains(R, L);\n            }\n            case '?': {\n                // JSON key exists (Postgres)\n                if (L == null || typeof L !== 'object') return false;\n                if (Array.isArray(L)) return L.includes(R);\n                return Object.prototype.hasOwnProperty.call(L, R);\n            }\n            case '?|': {\n                // JSON key exists any (Postgres)\n                if (L == null || typeof L !== 'object' || !Array.isArray(R)) return false;\n                if (Array.isArray(L)) return R.some((key) => L.includes(key));\n                return R.some((key) => Object.prototype.hasOwnProperty.call(L, key));\n            }\n            case '?&': {\n                // JSON key exists all (Postgres)\n                if (L == null || typeof L !== 'object' || !Array.isArray(R)) return false;\n                if (Array.isArray(L)) return R.every((key) => L.includes(key));\n                return R.every((key) => Object.prototype.hasOwnProperty.call(L, key));\n            }\n\n            default: throw new Error(`ExprEngine: Unsupported binary operator ${op}`);\n        }\n    }\n\n    async UNARY_EXPR(node, compositeRow, queryCtx = {}) {\n        const op = node.operator().toUpperCase();\n        const v = await this.evaluateToScalar(node.operand(), compositeRow, queryCtx);\n        // ----------- asPartial\n        if (v instanceof AbstractNode) {\n            return registry.UnaryExpr.fromJSON(\n                { nodeName: registry.UnaryExpr.NODE_NAME, operand: v },\n                { assert: true, dialect: queryCtx.options?.dialect }\n            );\n        }\n        // -----------\n        switch (op) {\n            case 'NOT': return !Boolean(v);\n            case '-': return -v;\n            default: throw new Error(`ExprEngine: Unsupported unary operator ${op}`);\n        }\n    }\n\n    async CALL_EXPR(node, compositeRow, queryCtx = {}) {\n        const fn = node.name().toUpperCase();\n\n        // SRFs\n\n        if (fn === 'UNNEST' || fn === 'GENERATE_SERIES') {\n            const args = await Promise.all(node.arguments().map((a) => this.evaluate(a, compositeRow, queryCtx)));\n\n            return (function* () {\n                if (fn === 'UNNEST') {\n                    for (let i = 0; i < args[0].length; i++) yield args.map((arr) => arr[i] ?? null);\n                }\n\n                if (fn === 'GENERATE_SERIES') {\n                    for (let x = args[0]; x <= args[1]; x += args[2] ?? 1) yield [x];\n                }\n            })();\n        }\n\n        // Meta functions\n\n        if (fn === 'GROUPING' || fn === 'GROUPING_ID') {\n            const meta = compositeRow[GROUPING_META];\n            if (!meta) throw new Error(`${fn}() called outside of grouping pipeline`);\n\n            const args = node.arguments();\n\n            const getBit = (arg) => {\n                const bitIndex = meta.exprIndex.get(arg);\n                if (bitIndex !== undefined) return (meta.groupingId >> bitIndex) & 1;\n\n                if (!(arg instanceof registry.ColumnRef1)) {\n                    throw new Error(`${fn}() argument must be a grouping column reference`);\n                }\n                const alias = arg.qualifier()?.value() || '';\n                const colName = arg.value();\n                return meta.groupingColumnsMap.get(alias)?.has(colName) ? 0 : 1;\n            };\n\n            // Fast path for GROUPING_ID when args match all top-level grouping expressions\n            if (fn === 'GROUPING_ID' &&\n                args.length === meta.exprIndex.size &&\n                args.every((arg, i) => meta.exprIndex.has(arg) && meta.exprIndex.get(arg) === i)\n            ) {\n                return meta.groupingId;\n            }\n\n            // Compute mask manually\n            let mask = 0;\n            for (let i = 0; i < args.length; i++) {\n                const bit = getBit(args[i]);\n                if (fn === 'GROUPING') return bit; // early return for single-bit GROUPING\n                mask = (mask << 1) | bit;\n            }\n\n            return mask;\n        }\n\n        if (fn === 'VALUES'/* MySQL */\n            && compositeRow.EXCLUDED\n            && typeof compositeRow.EXCLUDED === 'object') {\n\n            const args = node.arguments();\n            const fieldName = args[0].value();\n\n            return compositeRow.EXCLUDED[fieldName];\n        }\n\n        // Classic functions\n\n        const args = await Promise.all(node.arguments().map((a) => this.evaluate(a, compositeRow, queryCtx)));\n        // ----------- asPartial\n        if (args.some((x) => x instanceof AbstractNode)) {\n            return registry.CallExpr.fromJSON(\n                { nodeName: registry.CallExpr.NODE_NAME, name: fn, arguments: args.map(toNode) },\n                { assert: true, dialect: queryCtx.options?.dialect }\n            );\n        }\n        // -----------\n        switch (fn) {\n            case 'LOWER': return String(args[0] ?? '').toLowerCase();\n\n            case 'UPPER': return String(args[0] ?? '').toUpperCase();\n\n            case 'LENGTH': return args[0] == null ? null : String(args[0]).length;\n\n            case 'ABS': return Math.abs(Number(args[0]));\n\n            case 'COALESCE': return args.reduce((prev, cur) => prev !== null ? prev : cur, null);\n\n            case 'NULLIF': return _eq(args[0], args[1]) ? null : args[0];\n\n            case 'JSON_BUILD_ARRAY':\n            case 'JSON_ARRAY': return args;\n\n            case 'JSON_BUILD_OBJECT':\n            case 'JSON_OBJECT': {\n                if (args.length % 2 !== 0) throw new Error('JSON_BUILD_OBJECT requires an even number of arguments');\n                const buildObj = Object.create(null);\n                for (let i = 0; i < args.length; i += 2) {\n                    buildObj[args[i]] = args[i + 1];\n                }\n                return buildObj;\n            }\n\n            default: throw new Error(`ExprEngine: Unsupported function ${node.name()}`);\n        }\n    }\n\n    async AGGR_CALL_EXPR(node, compositeRow, queryCtx = {}) {\n\n        let metaData;\n\n        if (node.overClause()) {\n            const meta = compositeRow[WINDOW_META];\n            if (!meta) throw new Error(`${node} called outside of window processing pipeline (1)`);\n            if (!node.winHash) throw new Error(`${node} called outside of window processing pipeline (2)`);\n            if (!meta[node.winHash]) throw new Error(`${node} called outside of window processing pipeline (3)`);\n            metaData = meta[node.winHash];\n        } else {\n            const meta = compositeRow[GROUPING_META];\n            if (!meta) throw new Error('GROUPING() called outside of grouping pipeline');\n            metaData = meta;\n        }\n\n        const { window, frameStart, frameEnd, offset = 0 } = metaData;\n        const fn = node.name().toUpperCase();\n        const args = node.arguments();\n        const expr = args[0] || null;\n\n        switch (fn) {\n            case 'COUNT': {\n                if (!expr || expr instanceof registry.ColumnRef0) {\n                    return frameEnd - frameStart + 1;\n                }\n                let cnt = 0;\n                for (let j = frameStart; j <= frameEnd; j++) {\n                    const entry = window[j];\n                    const v = await this.evaluate(expr, entry, queryCtx);\n                    if (v !== null && v !== undefined) cnt++;\n                }\n                return cnt;\n            }\n\n            case 'SUM':\n            case 'AVG': {\n                if (!expr) return null;\n                let sum = 0, cnt = 0;\n                for (let j = frameStart; j <= frameEnd; j++) {\n                    const entry = window[j];\n                    const v = await this.evaluate(expr, entry, queryCtx);\n                    if (v !== null && !Number.isNaN(Number(v))) {\n                        sum += Number(v);\n                        cnt++;\n                    }\n                }\n                if (fn === 'SUM') return cnt === 0 ? null : sum;\n                return cnt === 0 ? null : sum / cnt;\n            }\n\n            case 'MIN':\n            case 'MAX': {\n                if (!expr) return null;\n                let result = null;\n                for (let j = frameStart; j <= frameEnd; j++) {\n                    const entry = window[j];\n                    const v = await this.evaluate(expr, entry, queryCtx);\n                    if (v == null) continue;\n                    if (result == null) {\n                        result = v;\n                    } else {\n                        if (fn === 'MIN' && v < result) result = v;\n                        if (fn === 'MAX' && v > result) result = v;\n                    }\n                }\n                return result;\n            }\n\n            case 'JSON_AGG':\n            case 'JSON_ARRAYAGG': {\n\n                if (!expr) return [];\n                const arr = [];\n\n                for (let j = frameStart; j <= frameEnd; j++) {\n                    const entry = window[j];\n                    arr.push(await this.evaluate(expr, entry, queryCtx));\n                }\n                return arr;\n            }\n\n            case 'JSON_OBJECT_AGG':\n            case 'JSON_OBJECTAGG': {\n\n                const keyExpr = args[0], valExpr = args[1];\n                if (!keyExpr || !valExpr) return {};\n                const obj = Object.create(null);\n\n                for (let j = frameStart; j <= frameEnd; j++) {\n                    const entry = window[j];\n                    const k = await this.evaluate(keyExpr, entry, queryCtx);\n                    const v = await this.evaluate(valExpr, entry, queryCtx);\n                    obj[k] = v;\n                }\n                return obj;\n            }\n\n            case 'STRING_AGG': {\n\n                const expr = args[0];\n                const delimiter = args[1] ? await this.evaluate(args[1], compositeRow, queryCtx) : ',';\n                const arr = [];\n\n                for (let j = frameStart; j <= frameEnd; j++) {\n                    const v = await this.evaluate(expr, window[j], queryCtx);\n                    if (v != null) arr.push(String(v));\n                }\n                return arr.join(delimiter);\n            }\n\n            case 'ARRAY_AGG': {\n                const expr = args[0];\n                const arr = [];\n                for (let j = frameStart; j <= frameEnd; j++) {\n                    arr.push(await this.evaluate(expr, window[j], queryCtx));\n                }\n                return arr;\n            }\n\n            case 'BIT_AND': {\n                const expr = args[0];\n                let result = ~0; // all bits set\n                for (let j = frameStart; j <= frameEnd; j++) {\n                    const v = await this.evaluate(expr, window[j], queryCtx);\n                    if (v != null) result &= Number(v);\n                }\n                return result;\n            }\n\n            case 'BIT_OR': {\n                const expr = args[0];\n                let result = 0;\n                for (let j = frameStart; j <= frameEnd; j++) {\n                    const v = await this.evaluate(expr, window[j], queryCtx);\n                    if (v != null) result |= Number(v);\n                }\n                return result;\n            }\n\n            case 'BOOL_AND': {\n                const expr = args[0];\n                for (let j = frameStart; j <= frameEnd; j++) {\n                    const v = await this.evaluate(expr, window[j], queryCtx);\n                    if (!v) return false;\n                }\n                return true;\n            }\n\n            case 'BOOL_OR': {\n                const expr = args[0];\n                for (let j = frameStart; j <= frameEnd; j++) {\n                    const v = await this.evaluate(expr, window[j], queryCtx);\n                    if (v) return true;\n                }\n                return false;\n            }\n\n            // -------- Window function proper\n\n            case 'ROW_NUMBER':\n                return offset + 1;\n\n            case 'RANK':\n            case 'PERCENT_RANK': {\n                const myKeysHash = metaData.orderKeysHash;\n                let rank;\n                // find first peer group member\n                for (let i = 0; i <= offset; i++) {\n                    const otherKeysHash = window[i][WINDOW_META][node.winHash].orderKeysHash;\n                    if (myKeysHash === otherKeysHash) {\n                        rank = i + 1; // 1-based\n                        break;\n                    }\n                }\n                if (fn === 'RANK') return rank;\n                // PERCENT_RANK\n                const total = window.length;\n                return total === 1 ? 0 : (rank - 1) / (total - 1);\n            }\n\n            case 'DENSE_RANK': {\n                const seen = new Set();\n                for (let i = 0; i <= offset; i++) {\n                    const otherKeysHash = window[i][WINDOW_META][node.winHash].orderKeysHash;\n                    if (!seen.has(otherKeysHash)) {\n                        seen.add(otherKeysHash);\n                    }\n                }\n                return seen.size;\n            }\n\n            case 'NTILE': {\n                const buckets = Number(await this.evaluateToScalar(args[0], compositeRow, queryCtx));\n                if (!Number.isInteger(buckets) || buckets <= 0) {\n                    throw new Error(`[${node}] NTILE(n) requires a positive integer`);\n                }\n                const total = window.length;\n                const baseSize = Math.floor(total / buckets);\n                const remainder = total % buckets;\n                // bucket boundaries\n                let threshold = 0;\n                for (let b = 1; b <= buckets; b++) {\n                    const bucketSize = baseSize + (b <= remainder ? 1 : 0);\n                    if (offset < threshold + bucketSize) {\n                        return b;\n                    }\n                    threshold += bucketSize;\n                }\n            }\n\n            case 'CUME_DIST': {\n                const total = window.length;\n                const myKeysHash = metaData.orderKeysHash;\n                let lastIndex = offset;\n                for (let i = offset + 1; i < total; i++) {\n                    const otherKeysHash = window[i][WINDOW_META][node.winHash].orderKeysHash;\n                    if (otherKeysHash === myKeysHash) lastIndex = i;\n                    else break;\n                }\n                return (lastIndex + 1) / total;\n            }\n\n            case 'LAG': {\n                const expr = args[0];\n                const lagBy = Number(await this.evaluate(args[1] ?? { value: 1 }, compositeRow, queryCtx));\n                const defaultValue = args[2] ? await this.evaluate(args[2], compositeRow, queryCtx) : null;\n                const targetIndex = offset - lagBy;\n                return targetIndex >= 0 ? await this.evaluate(expr, window[targetIndex], queryCtx) : defaultValue;\n            }\n\n            case 'LEAD': {\n                const expr = args[0];\n                const leadBy = Number(await this.evaluate(args[1] ?? { value: 1 }, compositeRow, queryCtx));\n                const defaultValue = args[2] ? await this.evaluate(args[2], compositeRow, queryCtx) : null;\n                const targetIndex = offset + leadBy;\n                return targetIndex < window.length ? await this.evaluate(expr, window[targetIndex], queryCtx) : defaultValue;\n            }\n\n            case 'FIRST_VALUE': {\n                const expr = args[0];\n                return await this.evaluate(expr, window[frameStart], queryCtx);\n            }\n\n            case 'LAST_VALUE': {\n                const expr = args[0];\n                return await this.evaluate(expr, window[frameEnd], queryCtx);\n            }\n\n            case 'NTH_VALUE': {\n                const expr = args[0];\n                const n = Number(await this.evaluateToScalar(args[1], compositeRow, queryCtx));\n                if (!Number.isInteger(n) || n <= 0) {\n                    throw new Error(`[${node}] NTH_VALUE(n) requires a positive integer`);\n                }\n                const targetIndex = frameStart + (n - 1);\n                if (targetIndex > frameEnd) return null;\n                return await this.evaluate(expr, window[targetIndex], queryCtx);\n            }\n\n            default: throw new Error(`ExprEngine: Unsupported window function ${node.name()}`);\n        }\n    }\n\n    async COLUMN_REF1(node, compositeRow) {\n        if (!node) return undefined;\n        const colName = node.value();\n        const qualName = node.qualifier()?.value() || '';\n\n        if (qualName) {\n            const table = compositeRow[qualName];\n            if (table === TBL_PLACEHOLDER) {\n                return node.clone();\n            }\n            if (!table) throw new Error(`Table alias ${qualName} not found in the current context`);\n            return table[colName];\n        }\n        for (const alias of Object.keys(compositeRow)) {\n            const table = compositeRow[alias];\n            if (colName in table) return table[colName];\n        }\n\n        throw new Error(`Column ${colName} not found in the current context`);\n    }\n\n    async BIND_VAR(node, compositeRow, queryCtx = {}) {\n        if (!Array.isArray(queryCtx.options.values))\n            throw new Error(`there is no parameter ${node}`);\n        const value = Number(node.value());\n        if (queryCtx.options.values.length < value)\n            throw new Error(`there is no parameter ${node}`);\n        return queryCtx.options.values[value - 1];\n    }\n\n    async DEFAULT_LITERAL(node) { return null; }\n    async STRING_LITERAL(node) { return node.value(); }\n    async NUMBER_LITERAL(node) { return Number(node.value()); }\n    async BOOL_LITERAL(node) { return node.value() === 'TRUE'; }\n    async NULL_LITERAL() { return null; }\n\n    // -------------\n\n    resolveScopedRefsInClause(clause, selectList) {\n        return clause.entries().map((entry) => {\n            let refedExpr;\n            if (entry.expr() instanceof registry.NumberLiteral) {\n                if (!(refedExpr = selectList.entries()[parseInt(entry.expr().value()) - 1]?.expr())) {\n                    throw new Error(`[${clause}] The reference by offset ${entry.expr().value()} does not resolve to a select list entry`);\n                }\n            } else if (entry.expr()?.resolution?.() === 'scope') {\n                refedExpr = selectList.entries().find((si, i) => si.alias()?.identifiesAs(entry.expr()))?.expr();\n            }\n            if (refedExpr) {\n                entry = entry.constructor.fromJSON({ ...entry.jsonfy(), expr: refedExpr.jsonfy() }, { assert: true });\n                clause._adoptNodes(entry);\n            }\n            return entry;\n        });\n    }\n\n    applySorting(decorated, orderElements, queryCtx = {}) {\n        // Sort synchronously\n        decorated.sort((a, b) => {\n            for (let i = 0; i < orderElements.length; i++) {\n                const idDesc = orderElements[i].dir() === 'DESC';\n                const dir = idDesc ? -1 : 1;\n                const nullsSpec = orderElements[i].nullsSpec()\n                    || (queryCtx.options?.dialect === 'mysql' ? (idDesc ? 'LAST' : 'FIRST') : (idDesc ? 'FIRST' : 'LAST'));\n\n                const valA = a.keys[i];\n                const valB = b.keys[i];\n                const aIsNull = valA === null; // Explicit NULL check\n                const bIsNull = valB === null;\n\n                // 1. Handle NULL vs. NULL (Always equal)\n                if (aIsNull && bIsNull) continue; // Move to next order element\n\n                // 2. Handle NULL vs. Non-NULL\n                if (aIsNull || bIsNull) {\n                    // Determine the NULLs order required by the SQL dialect/spec\n                    // If NULLS FIRST:\n                    //   - A is NULL, B is NOT: A comes first (return -1)\n                    //   - B is NULL, A is NOT: B comes first (return 1)\n                    if (nullsSpec === 'FIRST') {\n                        if (aIsNull) return -1; // A comes first\n                        if (bIsNull) return 1;  // A comes after B\n                    }\n                    // If NULLS LAST:\n                    //   - A is NULL, B is NOT: A comes last (return 1)\n                    //   - B is NULL, A is NOT: B comes last (return -1)\n                    else { // NULLS LAST\n                        if (aIsNull) return 1;  // A comes after B\n                        if (bIsNull) return -1; // A comes before B\n                    }\n                }\n\n                // 3. Handle Non-NULL vs. Non-NULL (Original logic)\n                // Ensure comparison is safe for potentially non-numeric/string values if needed\n                if (valA < valB) return -dir;\n                if (valA > valB) return dir;\n            }\n            return 0;\n        });\n    }\n}\n\nfunction toNode(x) {\n    if (x === undefined\n        || x instanceof AbstractNode) return x;\n    if (typeof x === 'number') return registry.NumberLiteral.fromJSON({ value: x });\n    if (typeof x === 'string') return registry.StringLiteral.fromJSON({ value: x });\n    if (typeof x === 'boolean') return registry.BoolLiteral.fromJSON({ value: x });\n    if (x === null) return registry.NullLiteral.fromJSON({ value: x });\n    throw new Error(`Cannot convert value to AST node: ${x}`);\n}\n\nfunction likeCompare(str, pattern) {\n    const esc = pattern\n        .replace(/([.+^=!:${}()|\\[\\]\\\\/])/g, '\\\\$1')\n        .replace(/%/g, '.*')\n        .replace(/_/g, '.');\n    try {\n        return new RegExp(`^${esc}$`, 'i').test(str);\n    } catch {\n        return false;\n    }\n}", "import { SimpleEmitter } from '../../entry/abstracts/SimpleEmitter.js';\nimport { matchExpr } from '../../entry/abstracts/util.js';\nimport { ExprEngine } from '../../flashql/ExprEngine.js';\nimport { registry } from \"../../lang/registry.js\";\nimport { _eq } from \"../../lang/abstracts/util.js\";\n\nexport class QueryWindow extends SimpleEmitter {\n\n    static analyseQuery(query) {\n\n        const analysis = {\n            hasSubqueryExprsInSelect: 0,\n            hasSubqueryExprsInWhere: 0,\n            hasSubqueryExprsInOrderBy: 0,\n            hasSubqueryExprs: 0,\n            hasWindowFunctions: false,\n            hasAggrFunctions: false,\n            hasGroupByClause: false,\n            hasOrderByClause: false,\n            hasOffsetClause: false,\n            hasLimitClause: false,\n            fromItemsBySchema: {},\n            fromItemsByAlias: {},\n            isSingleTable: false,\n        };\n\n        query.walkTree((n) => {\n            // Aggregate expressions?\n            if (n instanceof registry.AggrCallExpr) {\n                if (n.overClause()) {\n                    analysis.hasWindowFunctions = true;\n                } else analysis.hasAggrFunctions = true;\n            }\n            // Subquery/derived query expresions?\n            else if (n instanceof registry.DerivedQuery) {\n                const relationHashes = new Set;\n                grepFromItems(n.expr(), analysis.fromItemsBySchema, relationHashes);\n                const resulutionLevel = relationHashes.size || !(n.expr() instanceof registry.SelectStmt)\n                    ? 2 : (n.isCorrelated() ? 1 : 0);\n                if (resulutionLevel === 0) return;\n                // Publish\n                if (analysis.hasSubqueryExprs < resulutionLevel) {\n                    analysis.hasSubqueryExprs = resulutionLevel;\n                }\n                if (analysis.hasSubqueryExprsInSelect < resulutionLevel\n                    && query.selectList().containsNode(n)) {\n                    analysis.hasSubqueryExprsInSelect = resulutionLevel;\n                } else if (analysis.hasSubqueryExprsInWhere < resulutionLevel\n                    && query.whereClause()?.containsNode(n)) {\n                    analysis.hasSubqueryExprsInWhere = resulutionLevel;\n                } else if (analysis.hasSubqueryExprsInOrderBy < resulutionLevel\n                    && query.orderByClause()?.containsNode(n)) {\n                    analysis.hasSubqueryExprsInOrderBy = resulutionLevel;\n                }\n            }\n            // Enter FromItem:\n            else if (n instanceof registry.FromItem) {\n                // Aliases are expected\n                //  - except for a FROM (subquery) scenario, where it's optional\n                const alias = n.alias()?.value() || '';\n                if (n.expr() instanceof registry.DerivedQuery) {\n                    const relationHashes = new Set;\n                    grepFromItems(n.expr().expr(), analysis.fromItemsBySchema, relationHashes);\n                    analysis.fromItemsByAlias[alias] = relationHashes;\n                } else if (n.expr() instanceof registry.TableRef1\n                    && n.expr().resolution() === 'default') {\n                    const relationHashes = new Set;\n                    acquireTableRef(n.expr(), analysis.fromItemsBySchema, relationHashes);\n                    analysis.fromItemsByAlias[alias] = relationHashes;\n                } else {\n                    analysis.fromItemsByAlias[alias] = new Set;\n                }\n            } else return n;\n        });\n\n        function grepFromItems(query, fromItemsBySchema, relationHashes = null) {\n            query.walkTree((n) => {\n                if (n instanceof registry.FromItem\n                    && n.expr() instanceof registry.TableRef1\n                    && n.expr().resolution() === 'default') {\n                    acquireTableRef(n.expr(), fromItemsBySchema, relationHashes);\n                } else return n;\n            }, true);\n        }\n\n        function acquireTableRef(tableRef, fromItemsBySchema, relationHashes = null) {\n            const tableName = tableRef.value();\n            const namespaceName = tableRef.qualifier().value(); // Both name and qualifier are expected\n            fromItemsBySchema[namespaceName] = [].concat(fromItemsBySchema[namespaceName] || []).concat(tableName);\n            if (relationHashes) relationHashes.add(JSON.stringify([namespaceName, tableName]));\n        }\n\n        if (query.groupByClause()) analysis.hasGroupByClause = true;\n        if (query.orderByClause()) analysis.hasOrderByClause = true;\n        if (query.offsetClause()) analysis.hasOffsetClause = true;\n        if (query.limitClause()) analysis.hasLimitClause = true;\n\n        analysis.isSingleTable = !query.joinClauses()?.length\n            && !(analysis.hasAggrFunctions || analysis.hasGroupByClause)\n            && !analysis.hasWindowFunctions\n            && analysis.hasSubqueryExprs !== 2\n            && ((fromItems) => fromItems.length === 1 && !(fromItems[0].expr() instanceof registry.DerivedQuery))(query.fromClause().entries());\n\n        return analysis;\n    }\n\n    static intersectQueries(query1, query2, subwindowingRules) {\n\n        const specialClauses = [\n            // projection\n            'select_list',\n            // filtering\n            'where_clause',\n            // windowing\n            'order_by_clause',\n            'offset_clause',\n            'limit_clause'\n        ];\n\n        const clauses_a = new Set(query1._keys().filter((c) => !specialClauses.includes(c)));\n        const clauses_b = new Set(query2._keys().filter((c) => !specialClauses.includes(c)));\n        if (clauses_a.size !== clauses_b.size) return false;\n        for (const clauseName of new Set([...clauses_a, ...clauses_b])) {\n            if (!clauses_a.has(clauseName) || !clauses_b.has(clauseName)) return false;\n            if (!matchExpr(query1._get(clauseName), query2._get(clauseName))) return false;\n        }\n\n        const selectMapping = [];\n        if (subwindowingRules.projection === '=') {\n            const selectItems_a = query1.selectList().entries();\n            const selectItems_b = query2.selectList().entries();\n            for (const b of selectItems_b) {\n                const i_a = selectItems_a.findIndex((a) => matchExpr(a.expr(), b.expr()));\n                if (i_a === -1) return false;\n                selectMapping.push(i_a);\n            }\n        }\n\n        const effectiveWhere = [];\n        const aWhere = query1.whereClause()?.expr();\n        const bWhere = query2.whereClause()?.expr();\n        if (aWhere || bWhere) {\n            if (subwindowingRules.whereClause === '>=') {\n                if (!aWhere) {\n                    effectiveWhere.push(bWhere);\n                } else {\n                    const _effectiveWhere = matchExpr(aWhere, bWhere, 'AND~');\n                    if (_effectiveWhere === false) return false;\n                    effectiveWhere.push(..._effectiveWhere);\n                }\n            } else if (!matchExpr(aWhere, bWhere)) return false;\n        }\n\n        const aOrd = query1.orderByClause()?.entries() || [];\n        const bOrd = query2.orderByClause()?.entries() || [];\n        if (subwindowingRules.ordinality === '=') {\n            if (aOrd.length !== bOrd.length) return false;\n            if (!aOrd.every((a, i) => matchExpr(a.expr(), bOrd[i].expr()))) return false;\n            if (subwindowingRules.orderDirections === '=') {\n                if (!aOrd.every((a, i) => matchExpr(a.dir(), bOrd[i].dir()))) return false;\n            }\n        } else if (aOrd.length && !bOrd.length) return false;\n\n        let effectiveOffset = 0;\n        const aOffs = query1.offsetClause()?.expr();\n        const bOffs = query2.offsetClause()?.expr();\n        if (subwindowingRules.offsetClause === '=') {\n            if ((aOffs || bOffs) && !matchExpr(aOffs, bOffs)) return;\n        } else if (aOffs || bOffs) {\n            if (!(bOffs instanceof registry.NumberLiteral)) return false;\n            if ((effectiveOffset = bOffs.value() - (aOffs?.value() || 0)) < 0) return false;\n        }\n\n        const aLmt = query1.limitClause()?.expr();\n        const bLmt = query2.limitClause()?.expr();\n        if (subwindowingRules.limitClause === '=') {\n            if ((aLmt || bLmt) && !matchExpr(aLmt, bLmt)) return;\n        } else if (aLmt || bLmt) {\n            if (!(bLmt instanceof registry.NumberLiteral)) return false;\n            if (((aLmt?.value() || Infinity) - bLmt.value()) < 0) return false;\n        }\n\n        return { selectMapping, filters: effectiveWhere, offset: effectiveOffset };\n    }\n\n    // -----------------\n\n    #driver;\n    #options;\n\n    #status = 0;\n    #abortLine;\n\n    #exprEngine;\n    #queryCtx;\n\n    #query;\n    #queryJson;\n\n    #analysis;\n    #strategy = {\n        ssr: false,\n        requeryMode: 'selective',\n        requeryWrappedSelectivity: false,\n        diffing: 'key',\n    };\n    #subwindowingRules = {\n        projection: '~',\n        whereClause: '>=',\n        ordinality: '~',\n        orderDirections: '~',\n        offsetClause: '>=',\n        limitClause: '<=',\n    };\n\n    #logicalQuery;\n    #logicalQueryJson;\n\n    #originAliases = [];\n    #originSchemas = new Map;\n\n    #parentWindow;\n    #subwindowConstraints = {\n        selectMapping: [],\n        filters: [],\n        offset: 0,\n    };\n    #inheritanceDepth = 0;\n\n    #localRecords = new Map;\n    #firstRun = false;\n\n    #resolvedOrderElements = [];\n    #fromJsonOpts;\n\n    get driver() { return this.#driver; }\n\n    get analysis() { return this.#analysis; }\n    get strategy() { return this.#strategy; }\n    get subwindowingRules() { return this.#subwindowingRules; }\n\n    get status() { return this.#status; }\n\n    get parentWindow() { return this.#parentWindow; }\n    get inheritanceDepth() { return this.#inheritanceDepth; }\n\n    constructor(driver, query, options = {}) {\n        super();\n\n        this.#driver = driver;\n        if (!(query instanceof registry.BasicSelectStmt)) {\n            throw new Error('Only SELECT statements are supported in live mode');\n        }\n        if (!query.fromClause()) {\n            throw new Error('Query has no FROM clause');\n        }\n        if (!Array.isArray(query.originSchemas())) {\n            throw new Error('Expected a pre-resolved query object with originSchemas() returning an array');\n        }\n        this.#query = query;\n        this.#queryJson = this.#query.jsonfy({ resultSchemas: false, originSchemas: false });\n        this.#options = options; // { noOffsetRevalidate, forceDiffing }\n\n        this.#fromJsonOpts = { dialect: this.#driver.dialect, assert: true };;\n\n        const self = this;\n        this.#exprEngine = new ExprEngine(\n            async function* (derivedQuery, compositeRow, queryCtx) {\n                const stmt = derivedQuery.expr();\n                if (!(stmt instanceof registry.SelectStmt)) {\n                    throw new Error(`Unexpected expression: ${stmt}`);\n                }\n                const row = Object.create(null);\n                for (const selectItem of stmt.selectList()) {\n                    const { alias, value } = await self.#exprEngine.evaluate(selectItem, {}, queryCtx);\n                    row[alias] = value;\n                }\n                yield row;\n            },\n            this.#options\n        );\n\n        if (this.#query.orderByClause()) {\n            this.#resolvedOrderElements = this.#exprEngine.resolveScopedRefsInClause(\n                this.#query.orderByClause(),\n                this.#query.selectList()\n            );\n        }\n\n        // ------------------ analysis & strategy\n\n        const analysis = this.constructor.analyseQuery(query);\n        this.#analysis = analysis;\n        const strategy = this.#strategy;\n\n        if (analysis.hasAggrFunctions || analysis.hasGroupByClause) {\n            // Can't be computed client-side due to windowing\n            strategy.ssr = true; // SELECT: { ssr[, key[, ord]] }\n            // Result records not mappable via keys to database records\n            strategy.requeryMode = 'wholistic';\n            if (this.#options.forceDiffing) {\n                strategy.diffing = 'deep'; // key + content\n            } else {\n                strategy.diffing = false; // no diffing\n            }\n        }\n\n        if (analysis.hasWindowFunctions) {\n            // Can't be computed client-side due to windowing\n            strategy.ssr = true; // SELECT: { ssr[, key[, ord]] }\n            if (strategy.requeryMode === 'selective') {\n                // Wrapped; to happen only after windowing\n                strategy.requeryWrappedSelectivity = true;\n            }\n            if (strategy.diffing !== false) {\n                // if not already disabled by aggr functions\n                strategy.diffing = 'deep'; // key + content\n            }\n        }\n\n        if (analysis.hasSubqueryExprsInSelect\n            || analysis.hasSubqueryExprsInOrderBy) {\n            // Can't be computed client-side\n            strategy.ssr = true; // SELECT: { ssr[, key[, ord]] }\n            if (strategy.diffing !== false\n                && analysis.hasSubqueryExprsInSelect) {\n                // if not already disabled by aggr functions\n                strategy.diffing = 'deep'; // key + content\n            }\n        }\n\n        if (analysis.hasOffsetClause\n            && !this.#options.noOffsetRevalidate) {\n            strategy.requeryMode = 'wholistic';\n        }\n\n        if (analysis.hasOffsetClause\n            || (analysis.hasLimitClause && analysis.hasOrderByClause)) {\n            // Can't be computed client-side due to windowing\n            if (strategy.requeryMode === 'selective') {\n                // Wrapped; to happen only after windowing\n                strategy.requeryWrappedSelectivity = true;\n            }\n        }\n\n        // ------------------ subwindowingRules\n\n        if (strategy.ssr) {\n            // RESULT shape doesn't support client-side computing of projection & WHERE & ORDER BY\n            // so these must match\n            this.#subwindowingRules.projection = '=';\n            this.#subwindowingRules.whereClause = '=';\n            this.#subwindowingRules.ordinality = '=';\n        } else {\n            // RESULT shape supports client-side computing of projection & ORDER BY\n            // but subqueries in WHERE can't be computed client-side, so, WHERE must match\n            if (analysis.hasSubqueryExprsInWhere) {\n                this.#subwindowingRules.whereClause = '=';\n            }\n        }\n\n        if (analysis.hasOffsetClause\n            || (analysis.hasLimitClause && analysis.hasOrderByClause)) {\n            // Has OFFSET/LIMIT + ORDER BY (windowing):\n            // so everything must match including WHERE & ORDER BY (expressions + directions) due to windowing\n            this.#subwindowingRules.whereClause = '=';\n            this.#subwindowingRules.ordinality = '=';\n            this.#subwindowingRules.orderDirections = '=';\n            // - OFFSET/LIMIT may differ in subwindow but must fall within current window range\n            // - projection may differ in subwindow\n        }\n    }\n\n    async inherit(parentWindow) {\n        // Reset inheritance\n        if (parentWindow === null) {\n            this.#subwindowConstraints = {\n                selectMapping: [],\n                filters: [],\n                offset: 0,\n            };\n            this.#inheritanceDepth = 0;\n            if (this.#parentWindow) {\n                this.#parentWindow = null;\n                await this.stop();\n            }\n            return;\n        }\n        // Process intersection\n        if (!(parentWindow instanceof QueryWindow)) {\n            throw new Error(`Parent window must be instance of QueryWindow or null`);\n        }\n        if (!_eq(this.#subwindowingRules, parentWindow.#subwindowingRules)) return false;\n        const result = this.constructor.intersectQueries(\n            parentWindow.#query,\n            this.#query,\n            this.#subwindowingRules\n        );\n        if (result === false) return false;\n        // Success...\n        this.#subwindowConstraints = result;\n        this.#inheritanceDepth = parentWindow.inheritanceDepth + 1;\n        this.#parentWindow = parentWindow;\n        await this.start();\n        return true;\n    }\n\n    // -------------\n\n    async start() {\n        await this.stop();\n        if (this.#parentWindow) {\n            await this.#initializeAsSub();\n        } else await this.#initializeAsRoot();\n        this.#status = 1;\n    }\n\n    async stop() {\n        await this.#abortLine?.();\n        this.#abortLine = null;\n        this.#status = 0;\n    }\n\n    // -------------\n\n    async #initializeAsRoot() {\n        const analysis = this.#analysis;\n        const strategy = this.#strategy;\n\n        // Construct FromItem schemas\n        // off analysis.fromItemsByAlias & query.originSchemas()\n        const getJson = (node) => {\n            const value = node.value();\n            const delim = node._get('delim');\n            return { value: delim ? value : value.toLowerCase(), delim };\n        };\n        for (const [alias, relationHashes] of Object.entries(analysis.fromItemsByAlias)) {\n            const originSchema = this.#query.originSchemas().find((os) => {\n                if (os instanceof registry.JSONSchema) return alias === '';\n                return os.identifiesAs(alias);\n            });\n            let $columns,\n                $keyColumns,\n                usingAllColumnsForKeyColumns = false;\n            if (originSchema instanceof registry.JSONSchema) {\n                $columns = originSchema.entries().map((e) => getJson(e.name()));\n                if (relationHashes.size > 1 || !($keyColumns = originSchema.entries().filter((e) => e.pkConstraint()).map(getJson)).length) {\n                    $keyColumns = structuredClone($columns);\n                    usingAllColumnsForKeyColumns = true;\n                }\n            } else {\n                $columns = originSchema.columns().map((e) => getJson(e.name()));\n                if (relationHashes.size > 1 || !($keyColumns = originSchema.pkConstraint(true)?.columns().map(getJson))) {\n                    $keyColumns = structuredClone($columns);\n                    usingAllColumnsForKeyColumns = true;\n                }\n            }\n            const relation = relationHashes.size === 1\n                ? (([namespace, name]) => ({ namespace, name }))(JSON.parse([...relationHashes][0]))\n                : null;\n            this.#originSchemas.set(alias, {\n                relation,\n                relationHashes: relationHashes,\n                columns: $columns.map((c) => c.value),\n                keyColumns: $keyColumns.map((c) => c.value),\n                usingAllColumnsForKeyColumns,\n                $columns,\n                $keyColumns,\n            });\n            const delim = alias !== alias.toLowerCase()\n                || /^\\d/.test(alias)\n                || !/^(\\*|[\\w]+)$/.test(alias);\n            this.#originAliases.push({ value: alias, delim: delim && '\"' || '' });\n        }\n\n        // ----------- newQueryHead\n\n        // Generate a new head for the query\n        // This is for internal computation\n        const newOrderElementsJson = this.#resolvedOrderElements.map((oi) => oi.jsonfy());\n        let newQueryHead = this.#originAliases.reduce((acc, aliasJson) => {\n            const originSchema = this.#originSchemas.get(aliasJson.value);\n\n            // Column key/value construction\n            const createColKeyValJson = (colJson) => {\n                const keyJson = { nodeName: 'STRING_LITERAL', ...colJson };\n                let colRefJson = { nodeName: 'COLUMN_REF1', ...colJson, qualifier: { nodeName: 'TABLE_REF1', ...aliasJson } };\n                // Format for strategy.aggrMode === 2?\n                if (analysis.hasAggrFunctions) {\n                    const fnName = this.#driver.dialect === 'mysql' ? 'JSON_STRINGAGG' : 'JSON_AGG';\n                    colRefJson = { nodeName: 'CALL_EXPR', name: fnName, arguments: [colRefJson] };\n                }\n                return [keyJson, colRefJson];\n            };\n            // Compose the cols JSON\n            const fnName = this.#driver.dialect === 'mysql' ? 'JSON_OBJECT' : 'JSON_BUILD_OBJECT';\n            const fnArgs = (strategy.ssr ? originSchema.$keyColumns : originSchema.$columns)\n                .reduce((colKeyValJsons, colJson) => ([...colKeyValJsons, ...createColKeyValJson(colJson)]), []);\n            const aliasColsExpr = { nodeName: 'CALL_EXPR', name: fnName, arguments: fnArgs };\n\n            // Format for strategy.ssr?\n            // SELECT: { ssr: {...}, key: {...}[, ord] }\n            if (strategy.ssr) {\n                const aliasKeyJson = { nodeName: 'STRING_LITERAL', ...aliasJson };\n                return acc.concat(aliasKeyJson, aliasColsExpr);\n            }\n\n            // Format for nornal select list\n            // SELECT: { t1: {...}, t2: {...}, }\n            const aliasKeyJson = { nodeName: 'SELECT_ITEM_ALIAS', ...aliasJson };\n            return acc.concat({\n                nodeName: 'SELECT_ITEM',\n                alias: aliasKeyJson,\n                expr: aliasColsExpr,\n            });\n        }, []);\n\n        // Format for strategy.ssr?\n        // SELECT: { ssr: {...}, key: {...}[, ord] }\n        if (strategy.ssr) {\n            const fnName = this.#driver.dialect === 'mysql' ? 'JSON_OBJECT' : 'JSON_BUILD_OBJECT';\n            // 1. Whole original query head as a select item\n            const originalsArgs = this.#queryJson.select_list.entries.reduce((acc, si) => {\n                return acc.concat({ nodeName: 'STRING_LITERAL', value: si.alias.value }, si.expr);\n            }, []);\n            const originalsJson = { nodeName: 'CALL_EXPR', name: fnName, arguments: originalsArgs };\n            // 2. All keys as a select item\n            const keysJson = { nodeName: 'CALL_EXPR', name: fnName, arguments: newQueryHead };\n            // Final newQueryHead\n            newQueryHead = [{ nodeName: 'SELECT_ITEM', alias: { nodeName: 'SELECT_ITEM_ALIAS', value: 'ssr' }, expr: originalsJson }];\n            if (strategy.diffing) {\n                newQueryHead.push({ nodeName: 'SELECT_ITEM', alias: { nodeName: 'SELECT_ITEM_ALIAS', value: 'key' }, expr: keysJson });\n                // Oh ... with ordinality?\n                if (analysis.hasOrderByClause) {\n                    const fnName = this.#driver.dialect === 'mysql' ? 'JSON_ARRAY' : 'JSON_BUILD_ARRAY';\n                    const ordsJson = { nodeName: 'CALL_EXPR', name: fnName, entries: newOrderElementsJson.map((oi) => oi.expr) };\n                    newQueryHead.push({ nodeName: 'SELECT_ITEM', alias: { nodeName: 'SELECT_ITEM_ALIAS', value: 'ord' }, expr: ordsJson });\n                }\n            }\n        }\n\n        // Declare this.#logicalQueryJson\n        // SELECT: { t1: {...}[, t2: {...}[, ...]] }\n        const select_list = { entries: newQueryHead };\n        const order_by_clause = newOrderElementsJson.length ? { entries: newOrderElementsJson } : undefined;\n        this.#logicalQueryJson = { ...this.#queryJson, select_list, order_by_clause };\n        this.#logicalQuery = this.#query.constructor.fromJSON(this.#logicalQueryJson, this.#fromJsonOpts);\n\n        // ----------- connect\n\n        // Connect to WAL events or equivalent\n        // Drivers must implement the interface\n        this.#abortLine = await this.#driver.subscribe(analysis.fromItemsBySchema, async (events) => {\n            await this.#handleEvents(events);\n        });\n    }\n\n    async #initializeAsSub() {\n        // Handle \"rawresult\"\n        const abortLine1 = this.#parentWindow.on('rawresult', async (resultRecords) => {\n            resultRecords = await this.#applySubwindowConstraints(resultRecords);\n            await this.#commitResult(resultRecords, true);\n        });\n\n        // Handle \"rawdiff\"\n        const abortLine2 = this.#parentWindow.on('rawdiff', async (diffEvents) => {\n            const _diffEvents = new Set;\n\n            for (let diffEvent of diffEvents) {\n                if (diffEvent.type === 'delete') {\n                    // Ignore if not in this window\n                    if (!this.#localRecords.has(diffEvent.oldHash)) continue;\n                } else {\n                    const passesWhere = await this.#applySubwindowWheres(diffEvent.logicalRecord);\n                    if (this.#localRecords.has(diffEvent.oldHash)) {\n                        diffEvent = !passesWhere\n                            ? { ...diffEvent, type: 'delete' } // drop\n                            : { ...diffEvent }; // keep\n                        _diffEvents.add(diffEvent);\n                    } else if (passesWhere) {\n                        // Cast to insert; even if update\n                        diffEvent = { ...diffEvent, type: 'insert' };\n                        _diffEvents.add(diffEvent);\n                    }\n                }\n            }\n            if (_diffEvents.size) await this.#commitDiffs(_diffEvents);\n        });\n\n        // Set abortLine\n        this.#abortLine = () => {\n            abortLine1();\n            abortLine2();\n        };\n    }\n\n    // -------------\n\n    async #applySubwindowConstraints(resultRecords) {\n        const analysis = this.#analysis;\n        const strategy = this.#strategy;\n\n        let resultEntries = [];\n        for (const [logicalHash, logicalRecord] of resultRecords.entries()) {\n            if (await this.#applySubwindowWheres(logicalRecord)) {\n                resultEntries.push([logicalHash, logicalRecord]);\n            }\n        }\n        if (strategy.diffing && analysis.hasOrderByClause && (\n            this.#subwindowingRules.ordinality === '~' || this.#subwindowingRules.orderDirections === '~')) {\n            resultEntries = await this.#applySorting(resultEntries);\n        }\n        if (analysis.hasOffsetClause || analysis.hasLimitClause) {\n            const effectiveLimit = await this.#exprEngine.evaluate(this.#query.limitClause().expr(), {}, this.#queryCtx);\n            resultEntries = resultEntries.slice(this.#subwindowConstraints.offset, effectiveLimit);\n        }\n        return new Map(resultEntries);\n    }\n\n    async #applySubwindowWheres(logicalRecord) {\n        for (const expr of this.#subwindowConstraints.filters) {\n            const _eval = await this.#exprEngine.evaluate(expr, logicalRecord, this.#queryCtx);\n            if (!_eval) return false;\n        }\n        return true;\n    }\n\n    // -------------\n\n    async currentRendering() {\n        const resultRecords = await this.currentRecords();\n        const rows = [], hashes = [];\n        for (const [logicalHash, logicalRecord] of resultRecords.entries()) {\n            const row = await this.#renderLogicalRecord(logicalRecord);\n            rows.push(row);\n            hashes.push(logicalHash);\n        }\n        return { rows, hashes };\n    }\n\n    async currentRecords() {\n        if (!this.#firstRun) {\n            let resultRecords;\n            if (this.#parentWindow) {\n                resultRecords = await this.#parentWindow.currentRecords();\n                resultRecords = await this.#applySubwindowConstraints(resultRecords);\n            } else {\n                resultRecords = await this.#queryHeadless();\n            }\n            await this.#commitResult(resultRecords);\n            this.#firstRun = true;\n        }\n        return this.#localRecords;\n    }\n\n    async #queryHeadless(extraWhere = null) {\n        const strategy = this.#strategy;\n        let logicalQuery = this.#logicalQuery;\n\n        if (extraWhere && strategy.requeryWrappedSelectivity) {\n            const deriveSelectItem = (si) => ({ ...si, expr: { ...si.expr, qualifier: undefined } });\n            const logicalQueryJson = {\n                nodeName: 'BASIC_SELECT_STMT',\n                select_list: { entries: this.#logicalQueryJson.select_list.entries.map(deriveSelectItem) },\n                from_clause: { entries: [{ nodeName: 'FROM_ITEM', expr: { nodeName: 'DERIVED_QUERY', expr: this.#logicalQueryJson } }] },\n                where_clause: { expr: extraWhere },\n            };\n            logicalQuery = this.#query.constructor.fromJSON(logicalQueryJson, this.#fromJsonOpts);\n        } else if (extraWhere) {\n            let logicalQueryJson = this.#logicalQueryJson;\n            const finalWhereJson = logicalQueryJson.where_clause?.expr\n                ? { nodeName: 'BINARY_EXPR', left: extraWhere, operator: 'AND', right: logicalQueryJson.where_clause.expr }\n                : extraWhere;\n            logicalQueryJson = {\n                ...logicalQueryJson,\n                where_clause: { nodeName: 'WHERE_CLAUSE', expr: finalWhereJson },\n            };\n            logicalQuery = this.#query.constructor.fromJSON(logicalQueryJson, this.#fromJsonOpts);\n        }\n\n        const result = await this.#driver.query(logicalQuery);\n\n        const resultMap = new Map;\n        for (const [i, logicalRecord] of result.rows.entries()) {\n            const logicalHash = strategy.diffing\n                ? this.#deriveLogicalHash(logicalRecord)\n                : `$${i}`;\n            resultMap.set(logicalHash, logicalRecord);\n        }\n\n        return resultMap;\n    }\n\n    // -------------\n\n    #getKeyValue(logicalRecord, alias, k) {\n        return this.#strategy.ssr\n            ? logicalRecord.key[alias][k]\n            : logicalRecord[alias][k];\n    }\n\n    #deriveLogicalHash(logicalRecord) {\n        const newKeysList = [...this.#originSchemas.entries()].map(([alias, originSchema]) => {\n            const _newKeys = originSchema.keyColumns.map((k) => this.#getKeyValue(logicalRecord, alias, k));\n            if (_newKeys.every((s) => s === null)) {\n                return null; // IMPORTANT\n            }\n            return _newKeys;\n        });\n        return this.#stringifyLogicalHash(newKeysList);\n    }\n\n    #stringifyLogicalHash(keyValues) {\n        return JSON.stringify(keyValues);\n    }\n\n    #parseLogicalHash(logicalHash) {\n        return JSON.parse(logicalHash);\n    }\n\n    #localSet(logicalHash, logicalRecord) {\n        this.#localRecords.set(logicalHash, logicalRecord);\n    }\n\n    #localDelete(logicalHash) {\n        this.#localRecords.delete(logicalHash);\n    }\n\n    #localReindex(idChanges) {\n        this.#localRecords = new Map([...this.#localRecords.entries()].map(([id, logicalRecord]) => {\n            if (idChanges.has(id)) id = idChanges.get(id);\n            return [id, logicalRecord];\n        }));\n    }\n\n    async #renderLogicalRecord(logicalRecord) {\n        const row = Object.create(null);\n\n        if (this.#strategy.ssr) {\n            if (!this.#subwindowConstraints.filters.length) return logicalRecord.ssr;\n            const renderedValues = Object.values(logicalRecord.ssr);\n            for (const [i, si] of this.#query.selectList().entries().entries()) {\n                const value = renderedValues[i];\n                const alias = si.alias()?.value() || '?column?';\n                row[alias] = value;\n            }\n            return row;\n        }\n\n        for (const selectItem of this.#query.selectList()) {\n            const { alias, value } = await this.#exprEngine.evaluate(selectItem, logicalRecord, this.#queryCtx);\n            row[alias] = value;\n        }\n        return row;\n    }\n\n    // -------------\n\n    #normalizeEvents(events) {\n        const normalizedEventsMap = new Map;\n        const keyHistoryMap = new Map;\n        const allAffectedAliases = new Set;\n\n        for (const e of events) {\n            if (!(e.type === 'insert' || e.type === 'update' || e.type === 'delete')) continue;\n            const relationHash = JSON.stringify([e.relation.namespace, e.relation.name]);\n\n            const affectedAliasesEntries = [...this.#originSchemas.entries()].filter(([, originSchema]) => originSchema.relationHashes.has(relationHash));\n\n            if (!affectedAliasesEntries.length\n                || affectedAliasesEntries.find(([, originSchema]) => originSchema.relationHashes.size > 1)) {\n                return true;\n            }\n\n            const affectedAliases = affectedAliasesEntries.map(([alias]) => alias);\n            for (const alias of affectedAliases) allAffectedAliases.add(alias);\n\n            const keyColumns = e.relation.keyColumns;\n            const oldKeys = e.key\n                ? Object.values(e.key)\n                : keyColumns.map((k) => e.new[k]);\n            const newKeys = e.new\n                ? keyColumns.map((k) => e.new[k])\n                : oldKeys.slice(0);\n\n            const normalizedEvent = { ...e, keyColumns, oldKeys, newKeys, relationHash, affectedAliases };\n\n            let rowKeyHash_old = this.#stringifyLogicalHash([e.relation.namespace, e.relation.name, normalizedEvent.oldKeys]);\n            let rowKeyHash_new, previous;\n\n            if ((previous = normalizedEventsMap.get(rowKeyHash_old))\n                // Or if previous type was an update with key change... we see if rowKeyHash_old === previos' rowKeyHash_new\n                || keyHistoryMap.has(rowKeyHash_old) && (previous = normalizedEventsMap.get(rowKeyHash_old = keyHistoryMap.get(rowKeyHash_old)))) {\n                if (previous.type === 'insert' && normalizedEvent.type === 'delete') {\n                    // Ignore; inconsequential\n                    continue;\n                }\n                if (previous.type === 'delete' && normalizedEvent.type === 'insert') {\n                    // Treat as update should in case props were changed before reinsertion\n                    const _normalizedEvent = { ...normalizedEvent, type: 'update', old: previous.old };\n                    normalizedEventsMap.set(rowKeyHash_old, _normalizedEvent);\n                    continue;\n                }\n                if (previous.type === 'insert' && normalizedEvent.type === 'update') {\n                    // Use the lastest state of said record for the insert\n                    const _normalizedEvent = { ...normalizedEvent, oldKeys: previous.oldKeys, old: null, type: 'insert' };\n                    normalizedEventsMap.delete(rowKeyHash_old); // Don't retain old slot; must come first\n                    normalizedEventsMap.set(rowKeyHash_old, _normalizedEvent);\n                    // Handle key changes\n                    if ((rowKeyHash_new = this.#stringifyLogicalHash([e.relation.namespace, e.relation.name, normalizedEvent.newKeys])) !== rowKeyHash_old) {\n                        keyHistoryMap.set(rowKeyHash_new, rowKeyHash_old);\n                    }\n                    continue;\n                }\n                if (previous.type === 'update' && normalizedEvent.type === 'update') {\n                    // Honour latest update, but mapped to old identity\n                    const _normalizedEvent = { ...normalizedEvent, oldKeys: previous.oldKeys, old: previous.old };\n                    normalizedEventsMap.delete(rowKeyHash_old); // Don't retain old slot; must come first\n                    normalizedEventsMap.set(rowKeyHash_old, _normalizedEvent);\n                    // Handle key changes\n                    if ((rowKeyHash_new = this.#stringifyLogicalHash([e.relation.namespace, e.relation.name, normalizedEvent.newKeys])) !== rowKeyHash_old) {\n                        keyHistoryMap.set(rowKeyHash_new, rowKeyHash_old);\n                    }\n                    continue;\n                }\n                if (previous.type === 'update' && normalizedEvent.type === 'delete') {\n                    // Honour latest event using same ID\n                    normalizedEventsMap.delete(rowKeyHash_old); // Don't retain old slot\n                    normalizedEventsMap.set(rowKeyHash_old, normalizedEvent);\n                    continue;\n                }\n            } else {\n                if (normalizedEvent.type === 'update') {\n                    // Handle key changes\n                    if ((rowKeyHash_new = this.#stringifyLogicalHash([e.relation.namespace, e.relation.name, normalizedEvent.newKeys])) !== rowKeyHash_old) {\n                        keyHistoryMap.set(rowKeyHash_new, rowKeyHash_old);\n                    }\n                }\n                normalizedEventsMap.set(rowKeyHash_old, normalizedEvent);\n            }\n        }\n\n        return [normalizedEventsMap, keyHistoryMap, allAffectedAliases];\n    }\n\n    async #handleEvents(events) {\n        const analysis = this.#analysis;\n        const strategy = this.#strategy;\n        if (strategy.requeryMode === 'wholistic') {\n            // Aggr functions in the house\n            return await this.#diffWithOrigin_Wholistic();\n        }\n        const normalizeEvents = this.#normalizeEvents(events);\n        if (normalizeEvents === true) {\n            return await this.#diffWithOrigin_Wholistic();\n        }\n        if (analysis.isSingleTable) {\n            const [normalizedEventsMap] = normalizeEvents;\n            return await this.#diffWithLocal(normalizedEventsMap);\n        }\n        const [normalizedEventsMap, keyHistoryMap, allAffectedAliases] = normalizeEvents;\n        return await this.#diffWithOrigin_Selective(normalizedEventsMap, keyHistoryMap, allAffectedAliases);\n    }\n\n    async #diffWithLocal(normalizedEventsMap) {\n        const diffEvents = new Set;\n\n        for (const normalizedEvent of normalizedEventsMap.values()) {\n\n            if (normalizedEvent.type === 'insert') {\n                const newHash = this.#stringifyLogicalHash([normalizedEvent.newKeys]);\n                const logicalRecord = { [normalizedEvent.affectedAliases[0]]: normalizedEvent.new };\n                const passesWhere = !this.#query.whereClause()\n                    || await this.#exprEngine.evaluate(this.#query.whereClause().expr(), logicalRecord, this.#queryCtx);\n                if (!passesWhere) continue;\n                const diffEvent = { type: 'insert', newHash, logicalRecord };\n                diffEvents.add(diffEvent);\n            }\n\n            if (normalizedEvent.type === 'update') {\n                const oldHash = this.#stringifyLogicalHash([normalizedEvent.oldKeys]);\n                const newHash = this.#stringifyLogicalHash([normalizedEvent.newKeys]);\n                const logicalRecord = { [normalizedEvent.affectedAliases[0]]: normalizedEvent.new };\n                let diffEvent;\n                const passesWhere = !this.#query.whereClause()\n                    || await this.#exprEngine.evaluate(this.#query.whereClause().expr(), logicalRecord, this.#queryCtx);\n                if (this.#localRecords.has(oldHash)) {\n                    diffEvent = !passesWhere\n                        ? { type: 'delete', oldHash }\n                        : { type: 'update', oldHash, newHash, logicalRecord };\n                } else if (passesWhere) {\n                    diffEvent = { type: 'insert', newHash, logicalRecord };\n                }\n                if (diffEvent) diffEvents.add(diffEvent);\n            }\n\n            if (normalizedEvent.type === 'delete') {\n                const oldHash = this.#stringifyLogicalHash([normalizedEvent.oldKeys]);\n                if (this.#localRecords.has(oldHash)) {\n                    const diffEvent = { type: 'delete', oldHash, logicalRecord: this.#localRecords.get(oldHash) };\n                    diffEvents.add(diffEvent);\n                }\n            }\n        }\n\n        return await this.#commitDiffs(diffEvents);\n    }\n\n    async #diffWithOrigin_Selective(normalizedEventsMap, keyHistoryMap, allAffectedAliases) {\n        const strategy = this.#strategy;\n\n        const composeSelectionLogic = (alias, keyColumns, keyValues, nullTest = 0) => {\n            if (keyColumns.length > 1) {\n                const operands = keyColumns.map((keyColumn, i) => composeSelectionLogic(alias, [keyColumn], [keyValues[i]], nullTest));\n                return operands.reduce((left, right) => registry.BinaryExpr.fromJSON({\n                    nodeName: 'BINARY_EXPR',\n                    left,\n                    operator: 'AND',\n                    right,\n                }, this.#fromJsonOpts), operands.shift());\n            }\n            // Compose...\n            const columnRef = strategy.requeryWrappedSelectivity\n                // key -> alias -> keyColumn\n                ? { nodeName: 'BINARY_EXPR', left: { nodeName: 'COLUMN_REF1', value: 'key' }, operator: '->', right: { nodeName: 'BINARY_EXPR', left: { nodeName: 'COLUMN_REF1', value: alias }, operator: '->>', right: { nodeName: 'COLUMN_REF1', value: keyColumns[0] } } }\n                // alias.keyColumn\n                : { nodeName: 'COLUMN_REF1', value: keyColumns[0], qualifier: { nodeName: 'TABLE_REF1', value: alias } };\n            // Compose: <keyColumn> IS NULL\n            const nullLiteral = { nodeName: 'NULL_LITERAL', value: 'NULL' };\n            const isNullExpr = registry.BinaryExpr.fromJSON({\n                nodeName: 'BINARY_EXPR',\n                left: columnRef,\n                operator: 'IS',\n                right: nullLiteral,\n            }, this.#fromJsonOpts);\n            if (nullTest === 0) {\n                return isNullExpr;\n            }\n            // Compose: <keyColumn> = <keyValue>\n            const valueLiteral = { nodeName: typeof keyValues[0] === 'number' ? 'NUMBER_LITERAL' : 'STRING_LITERAL', value: keyValues[0] };\n            const eqExpr = registry.BinaryExpr.fromJSON({\n                nodeName: 'BINARY_EXPR',\n                left: columnRef,\n                operator: '=',\n                right: valueLiteral\n            }, this.#fromJsonOpts);\n            // Compose?: (<keyColumn> IS NULL OR <keyColumn> = <keyValue>)\n            if (nullTest === 2) {\n                const orExpr = {\n                    nodeName: 'BINARY_EXPR',\n                    left: isNullExpr,\n                    operator: 'OR',\n                    right: eqExpr,\n                };\n                return registry.RowConstructor.fromJSON({ nodeName: 'ROW_CONSTRUCTOR', entries: [orExpr] }, this.#fromJsonOpts);\n            }\n            return eqExpr;\n        };\n\n        // ----------------\n\n        const localRecords = new Map;\n        const remoteDiffingFilters = [];\n\n        for (const normalizedEvent of normalizedEventsMap.values()) {\n            let diffingFilters = [];\n            const affectedAliases = normalizedEvent.affectedAliases;\n            if (normalizedEvent.type === 'insert') {\n                // keyColumn === null // keyColumn IN [null, newKey]\n                diffingFilters = [\n                    affectedAliases.map((alias) => composeSelectionLogic(alias, normalizedEvent.keyColumns, normalizedEvent.oldKeys, 0)),\n                    affectedAliases.map((alias) => composeSelectionLogic(alias, normalizedEvent.keyColumns, normalizedEvent.newKeys, 2/* IMPORTANT */)),\n                ];\n            }\n            if (normalizedEvent.type === 'update') {\n                // keyColumn IN [null, oldKey] // keyColumn IN [null, newKey]\n                diffingFilters = [\n                    affectedAliases.map((alias) => composeSelectionLogic(alias, normalizedEvent.keyColumns, normalizedEvent.oldKeys, 2)),\n                    affectedAliases.map((alias) => composeSelectionLogic(alias, normalizedEvent.keyColumns, normalizedEvent.newKeys, 2)),\n                ];\n            }\n            if (normalizedEvent.type === 'delete') {\n                // keyColumn IN [null, oldKey] // keyColumn === null\n                diffingFilters = [\n                    affectedAliases.map((alias) => composeSelectionLogic(alias, normalizedEvent.keyColumns, normalizedEvent.oldKeys, 2/* IMPORTANT */)),\n                    affectedAliases.map((alias) => composeSelectionLogic(alias, normalizedEvent.keyColumns, normalizedEvent.newKeys, 0)),\n                ];\n            }\n            top: for (const [logicalHash, logicalRecord] of this.#localRecords.entries()) {\n                for (const expr of diffingFilters[0]) {\n                    if (!await this.#exprEngine.evaluate(expr, logicalRecord, this.#queryCtx)) {\n                        continue top;\n                    }\n                }\n                // All of diffingFilters[0] matched - AND\n                localRecords.set(logicalHash, logicalRecord);\n            }\n            // Build this event's diffingFilters\n            const diffingFilters_currentEvent = diffingFilters[1].reduce((left, right) => {\n                return registry.BinaryExpr.fromJSON({ nodeName: 'BINARY_EXPR', left, operator: 'AND', right });\n            }, diffingFilters[1].shift());\n            remoteDiffingFilters.push(diffingFilters_currentEvent);\n        }\n\n        let diffingFilters_allEvents = remoteDiffingFilters[0];\n        if (remoteDiffingFilters.length > 1) {\n            // Compose the logic\n            const _diffingFilters_allEvents = remoteDiffingFilters.reduce((left, right) => {\n                return registry.BinaryExpr.fromJSON({ nodeName: 'BINARY_EXPR', left, operator: 'OR', right });\n            }, remoteDiffingFilters.shift());\n            // Wrap the logic?\n            if (!strategy.requeryWrappedSelectivity) {\n                diffingFilters_allEvents = registry.RowConstructor.fromJSON({\n                    nodeName: 'ROW_CONSTRUCTOR',\n                    entries: [_diffingFilters_allEvents],\n                });\n            } else diffingFilters_allEvents = _diffingFilters_allEvents;\n        }\n\n        // ----------------\n\n        const resolveTransition = (oldHash, matches) => {\n            const oldHash_parsed = this.#parseLogicalHash(oldHash);\n            let i;\n            for (const [alias, originSchema] of this.#originSchemas.entries()) {\n                if (allAffectedAliases.has(alias)) {\n                    const relation = originSchema.relation;\n                    // An event happen of this alias?\n                    let possibleEventId;\n                    let normalizedEvent;\n                    if (oldHash_parsed[i] === null) {\n                        // Find INSERTS or UPDATES that might slot in here from the right hand side\n                        matches = matches.filter(([k]) => {\n                            // Find an INSERT or UPDATE that might talk about this object\n                            if (k[i] !== null && (possibleEventId = JSON.stringify([relation.namespace, relation.name, k[i]])) && (\n                                (normalizedEvent = normalizedEventsMap.get(possibleEventId))\n                                || keyHistoryMap.has(possibleEventId) && (normalizedEvent = normalizedEventsMap.get(possibleEventId = keyHistoryMap.get(possibleEventId)))\n                            )) return true; // At least an INSERT or UPDATE is found on oldHash_parsed[i]\n                        });\n                    } else {\n                        // Find a DELETE or UPDATE that might talk about this object\n                        if ((possibleEventId = JSON.stringify([relation.namespace, relation.name, oldHash_parsed[i]]))\n                            && (normalizedEvent = normalizedEventsMap.get(possibleEventId))) {\n                            matches = matches.filter(([k]) => {\n                                // Remote hash would be null on normalizedEvent.type === 'delete'\n                                return normalizedEvent.type === 'delete' ? k[i] === null : _eq(normalizedEvent.newKeys, k[i]);\n                            });\n                        }\n                    }\n                }\n                // Default matcher: exact key values at given slot\n                matches = matches.filter(([k]) => _eq(oldHash_parsed[i], k[i]));\n                i++;\n            }\n            if (!matches.length) return [];\n            return [this.#stringifyLogicalHash(matches[0][0]), matches[0][1]];\n        };\n\n        // ----------------\n\n        const remoteRecords = await this.#queryHeadless(diffingFilters_allEvents);\n        return await this.#createDiffs(localRecords, remoteRecords, resolveTransition);\n    }\n\n    async #diffWithOrigin_Wholistic() {\n        const remoteRecords = await this.#queryHeadless();\n        return !this.#strategy.diffing\n            ? await this.#commitResult(remoteRecords, true)\n            : await this.#createDiffs(this.#localRecords, remoteRecords);\n    }\n\n    async #createDiffs(localRecords, remoteRecords, resolveTransition = null) {\n        const diffEvents = new Set;\n\n        const parseRemoteRecords = () => [...remoteRecords.entries()].map(([k, v]) => [this.#parseLogicalHash(k), v]);\n        let remoteRecords_parsed = parseRemoteRecords();\n\n        for (const [logicalHash_existing, logicalRecord_existing] of localRecords.entries()) {\n            if (remoteRecords.has(logicalHash_existing)) {\n                const logicalRecord_new = remoteRecords.get(logicalHash_existing);\n                remoteRecords.delete(logicalHash_existing);\n                remoteRecords_parsed = parseRemoteRecords(); // refresh\n                const diffEvent = { type: 'update', oldHash: logicalHash_existing, newHash: logicalHash_existing, logicalRecord: logicalRecord_new };\n                diffEvents.add(diffEvent);\n                continue;\n            }\n            if (resolveTransition) {\n                const [logicalHash_new, logicalRecord_new] = resolveTransition(logicalHash_existing, remoteRecords_parsed);\n                if (logicalHash_new) {\n                    remoteRecords.delete(logicalHash_new);\n                    remoteRecords_parsed = parseRemoteRecords(); // refresh\n                    const diffEvent = { type: 'update', oldHash: logicalHash_existing, newHash: logicalHash_new, logicalRecord: logicalRecord_new };\n                    diffEvents.add(diffEvent);\n                    continue;\n                }\n            }\n            const diffEvent = { type: 'delete', oldHash: logicalHash_existing, logicalRecord: logicalRecord_existing };\n            diffEvents.add(diffEvent);\n        }\n\n        for (const [logicalHash_new, logicalRecord_new] of remoteRecords.entries()) {\n            const diffEvent = { type: 'insert', newHash: logicalHash_new, logicalRecord: logicalRecord_new };\n            diffEvents.add(diffEvent);\n        }\n\n        return await this.#commitDiffs(diffEvents);\n    }\n\n    async #commitDiffs(diffEvents) {\n        if (!diffEvents?.size) return false;\n        const analysis = this.#analysis;\n        const _diffEvents = new Map;\n        const outputEvents = new Map;\n        const idChanges = new Map;\n        const deferredInserts = new Set;\n\n        const effectiveLimit = analysis.hasLimitClause\n            ? await this.#exprEngine.evaluate(this.#query.limitClause().expr(), {}, this.#queryCtx)\n            : 0;\n\n        const render = async (diffEvent) => {\n            const row = await this.#renderLogicalRecord(diffEvent.logicalRecord);\n            const outputEvent = {\n                type: diffEvent.type,\n                ...(diffEvent.type === 'update' ? { oldHash: diffEvent.oldHash, old: diffEvent.old } : {}),\n                newHash: diffEvent.newHash,\n                new: row,\n            };\n            return outputEvent;\n        };\n\n        for (const diffEvent of diffEvents) {\n\n            // Handle deletes\n            if (diffEvent.type === 'delete') {\n                const outputEvent = {\n                    type: diffEvent.type,\n                    oldHash: diffEvent.oldHash,\n                };\n                this.#localDelete(diffEvent.oldHash);\n                _diffEvents.set(diffEvent.oldHash, diffEvent);\n                outputEvents.set(diffEvent.oldHash, outputEvent);\n                continue;\n            }\n            // Handle updates & inserts\n            if (diffEvent.type === 'update'\n                && diffEvent.newHash !== diffEvent.oldHash) {\n                idChanges.set(diffEvent.oldHash, diffEvent.newHash);\n            } else if (diffEvent.type === 'insert'\n                && effectiveLimit\n                && !analysis.hasOrderByClause\n                && this.#localRecords.size === effectiveLimit) {\n                deferredInserts.add(diffEvent);\n                continue;\n            }\n\n            // Add to logicalRecords\n            const effectiveHash = diffEvent.oldHash || diffEvent.newHash;\n            this.#localSet(effectiveHash, diffEvent.logicalRecord);\n\n            // Enque events\n            _diffEvents.set(effectiveHash, diffEvent);\n            outputEvents.set(effectiveHash, await render(diffEvent));\n        }\n\n        if (idChanges.size) this.#localReindex(idChanges);\n\n        let swaps = [];\n        if (analysis.hasOrderByClause) {\n            const [\n                reorderedLocalRecords,\n                sortedEntries,\n                originalEntires\n            ] = await this.#applySorting(this.#localRecords, true);\n            await this.#commitResult(reorderedLocalRecords);\n\n            // Apply limit\n            const splicedHashes = [];\n            if (effectiveLimit && this.#localRecords.size >= effectiveLimit) {\n                const excess = sortedEntries.slice(effectiveLimit);\n                for (const [logicalHash, logicalRecord] of excess) {\n\n                    // Remove from localRecords\n                    this.#localRecords.delete(logicalHash);\n                    splicedHashes.push(logicalHash);\n\n                    // If part of events queue, remove\n                    if (_diffEvents.get(logicalHash)?.type === 'insert') {\n                        // Simply remove\n                        _diffEvents.delete(logicalHash);\n                        outputEvents.delete(logicalHash);\n                    } else {\n                        // Change updates to deletes\n                        _diffEvents.set(logicalHash, {\n                            type: 'delete',\n                            oldHash: logicalHash,\n                            old: logicalRecord,\n                        });\n                        outputEvents.set(logicalHash, {\n                            type: 'delete',\n                            oldHash: logicalHash,\n                        });\n                    }\n                }\n            }\n\n            // Generate swaps\n            const origianlLogicalKeys = originalEntires.map((e) => e[0]);\n            const reorderedLocalKeys = sortedEntries.map((e) => e[0]);\n\n            for (const [oldIdx, logicalHash] of origianlLogicalKeys.entries()) {\n\n                // Handle spliced entry case (1)\n                if (splicedHashes.includes(logicalHash)) continue;\n\n                // Where does logicalHash now map to?\n                let newIdx = reorderedLocalKeys.indexOf(logicalHash);\n                let targetHash = origianlLogicalKeys[newIdx];\n\n                // Handle spliced entry case (2)\n                if (splicedHashes.includes(targetHash)) {\n                    newIdx = reorderedLocalKeys.indexOf(targetHash);\n                    targetHash = origianlLogicalKeys[newIdx];\n                }\n                if (newIdx !== oldIdx) {\n                    swaps.push([logicalHash, targetHash]);\n                }\n            }\n        } else {\n            for (const diffEvent of deferredInserts) {\n                // Limit reached?\n                if (this.#localRecords.size === effectiveLimit) break;\n\n                // Add to logicalRecords\n                this.#localSet(diffEvent.newHash, diffEvent.logicalRecord);\n\n                // Enque events\n                _diffEvents.set(diffEvent.newHash, diffEvent);\n                outputEvents.set(diffEvent.newHash, await render(diffEvent));\n            }\n        }\n\n        // Emit events\n        if (_diffEvents.size) this.emit('rawdiff', [..._diffEvents.values()]);\n        if (outputEvents.size) this.emit('diff', [...outputEvents.values()]);\n        if (swaps.length) this.emit('swap', swaps);\n\n        return true;\n    }\n\n    async #commitResult(resultRecords, emit = false) {\n        this.#localRecords.clear();\n        for (const [logicalHash, logicalRecord] of resultRecords.entries()) {\n            this.#localSet(logicalHash, logicalRecord);\n        }\n        if (emit) {\n            this.emit('rawresult', new Map(this.#localRecords));\n            this.emit('result', await this.currentRendering());\n        }\n    }\n\n    async #applySorting(logicalRecords, withEntries = false) {\n        const entries = !Array.isArray(logicalRecords)\n            ? [...logicalRecords.entries()]\n            : logicalRecords;\n\n        let decorated;\n        if (this.#strategy.ssr) {\n            decorated = entries.map((entry) => ({ entry, keys: entry[1].ord }));\n        } else {\n            decorated = await Promise.all(entries.map(async (entry) => {\n                const keys = await Promise.all(this.#resolvedOrderElements.map(orderElement => {\n                    return this.#exprEngine.evaluate(orderElement.expr(), entry[1], this.#queryCtx)\n                }));\n                return { entry, keys };\n            }));\n        }\n        this.#exprEngine.applySorting(decorated, this.#resolvedOrderElements, this.#queryCtx);\n        const _entries = decorated.map((e) => e.entry);\n\n        const result = !Array.isArray(logicalRecords)\n            ? new Map(_entries)\n            : _entries;\n\n        return withEntries\n            ? [result, _entries, entries]\n            : result;\n    }\n}\n", "import '../../lang/index.js';\nimport { AbstractSQLClient } from '../../entry/abstracts/AbstractSQLClient.js';\nimport { normalizeQueryArgs } from '../../entry/abstracts/util.js';\nimport { RealtimeResult } from './RealtimeResult.js';\nimport { QueryWindow } from './QueryWindow.js';\nimport { registry } from '../../lang/registry.js';\n\nexport class RealtimeClient {\n\n    #windows = new Set;\n    #driver;\n\n    get size() { return this.#windows.size; }\n\n    constructor(driver) {\n        if (!(driver instanceof AbstractSQLClient)) {\n            throw new TypeError('driver must be an instance of AbstractSQLClient');\n        }\n        this.#driver = driver;\n    }\n\n    async query(...args) {\n        const [query, { callback, signal, ...options }] = normalizeQueryArgs(...args);\n        \n        if (!(query instanceof registry.BasicSelectStmt)) {\n            throw new Error('Only SELECT statements are supported in live mode');\n        }\n        if (!query.fromClause()) {\n            throw new Error('Query has no FROM clause');\n        }\n\n        const queryWindow = await this.createWindow(query, options);\n        const resultJson = await queryWindow.currentRendering();\n        const realtimeResult = new RealtimeResult(resultJson, () => abortLines.forEach((c) => c()), signal);\n\n        const changeHandler = callback || ((eventName, eventData) => realtimeResult._apply(eventName, eventData));\n        const abortLines = ['result', 'diff', 'swap'].map((eventName) => {\n            return queryWindow.on(eventName, (eventData) => changeHandler(eventName, eventData));\n        });\n\n        return realtimeResult;\n    }\n\n    async createWindow(query, options) {\n        const newWindow = new QueryWindow(this.#driver, query, options);\n\n        const windows_depthFirst = [...this.#windows]\n            .sort((a, b) => a.inheritanceDepth > b.inheritanceDepth ? 1 : -1);\n        const potentialSubWindows = [];\n\n        // 1. Try inheriting a window. We're searching depth-first\n        for (const potentialParentWindow of windows_depthFirst) {\n            if (await newWindow.inherit(potentialParentWindow)) break;\n            potentialSubWindows.unshift(potentialParentWindow);\n        }\n        \n        // 2. No parent window found. We run as root\n        if (!newWindow.parentWindow) {\n            await newWindow.start();\n            // Try parenting an existing window. This time, we're searching depth-last\n            for (const potentialSubWindow of potentialSubWindows) {\n                if (await potentialSubWindow.inherit(newWindow)) break;\n            }\n        }\n\n        // Register\n        this.#windows.add(newWindow);\n        newWindow.onClose(() => {\n            this.#windows.delete(newWindow);\n            newWindow.stop();\n        });\n\n        return newWindow;\n    }\n}\n", "import { normalizeQueryArgs } from './util.js';\nimport { AbstractClient } from './AbstractClient.js';\nimport { AbstractNode } from '../../lang/abstracts/AbstractNode.js';\nimport { AbstractStmt } from '../../lang/abstracts/AbstractStmt.js';\nimport { RealtimeClient } from '../../proc/realtime/RealtimeClient.js';\nimport { Transformer } from '../../lang/Transformer.js';\nimport { registry } from '../../lang/registry.js';\nimport { Result } from '../../entry/Result.js';\n\nexport class AbstractSQLClient extends AbstractClient {\n\n    get dialect() { throw new Error('Not implemented'); }\n\n    #realtimeClient;\n\n    get realtimeClient() { return this.#realtimeClient; }\n\n    constructor({ capability = {} } = {}) {\n        super({ capability });\n        this.#realtimeClient = new RealtimeClient(this);\n    }\n\n    async parse(querySpec, { alias = null, dynamicWhereMode = false, ...options } = {}) {\n        if (!querySpec) return;\n\n        const wrapORLogic = (exprJson) => {\n            if ((exprJson.nodeName === registry.BinaryExpr.NODE_NAME && exprJson.operator === 'OR')\n                || (exprJson instanceof registry.BinaryExpr && exprJson.operator() === 'OR')) {\n                return { nodeName: registry.RowConstructor.NODE_NAME, entries: [exprJson] };\n            }\n            return exprJson;\n        }\n\n        // 1. ----------- SQL string\n\n        if (typeof querySpec === 'string' || typeof querySpec === 'object' && typeof querySpec.query === 'string') {\n            let query = await registry.Script.parse(querySpec.query || querySpec, { dialect: options.dialect || this.dialect, supportStdStmt: true });\n            if (query.length === 1) query = query.entries()[0];\n\n            if (dynamicWhereMode) {\n                let baseAlias;\n                if (query instanceof registry.CompleteSelectStmt) {\n                    if (alias) {\n                        const baseFromItem = query.fromClause().entries()[0];\n                        baseAlias = (baseFromItem.alias() || baseFromItem.expr())?.value();\n                    }\n                } else if (query instanceof registry.UpdateStmt || query instanceof registry.DeleteStmt) {\n                    if (alias) {\n                        const tableExpr = query.tableExpr();\n                        baseAlias = (tableExpr.alias() || tableExpr.tableRef())?.value();\n                    }\n                } else {\n                    throw new Error('Dynamic where mode is only supported for SELECT, UPDATE, or DELETE statements.');\n                }\n\n                let queryJson = query.jsonfy();\n                const baseExpr = queryJson.where_clause?.expr;\n\n                return (dynamicWhere) => {\n                    // Rewrite column qualifiers to baseAlias?\n                    if (dynamicWhere && alias && baseAlias && alias !== baseAlias) {\n                        const transformer = new Transformer((node, defaultTransform) => {\n                            if (node instanceof registry.ColumnRef1 && node.qualifier()?.identifiesAs(alias)) {\n                                const bodyResultJson = defaultTransform();\n                                return { ...bodyResultJson, qualifier: { ...bodyResultJson.qualifier, value: baseAlias } };\n                            }\n                            return defaultTransform();\n                        }, null);\n                        dynamicWhere = dynamicWhere.jsonfy({}, transformer);\n                    }\n                    // Dummy condition\n                    if (!dynamicWhere || dynamicWhere === true) {\n                        dynamicWhere = { nodeName: registry.BoolLiteral.NODE_NAME, value: 'TRUE' };\n                    }\n                    // Concat logic\n                    if (baseExpr) {\n                        dynamicWhere = { nodeName: registry.BinaryExpr.NODE_NAME, left: wrapORLogic(dynamicWhere), operator: 'AND', right: wrapORLogic(baseExpr) };\n                    }\n                    // Patch query\n                    queryJson = {\n                        ...queryJson,\n                        where_clause: { nodeName: registry.WhereClause.NODE_NAME, expr: dynamicWhere },\n                    };\n                    return registry.Script.fromJSON(\n                        { entries: [queryJson] },\n                        { dialect: options.dialect, assert: true, supportStdStmt: true }\n                    ).entries()[0];\n                };\n            }\n\n            return query;\n        }\n\n        // 2. ----------- Command\n\n        const toExpr = (val) => {\n            if (typeof val === 'number') {\n                return { nodeName: registry.NumberLiteral.NODE_NAME, value: val };\n            }\n            return { nodeName: registry.StringLiteral.NODE_NAME, value: val + '' };\n        };\n\n        const tblName = querySpec.name;\n        const namespaceName = querySpec.namespace;\n        const tableRefJson = { nodeName: registry.TableRef1.NODE_NAME, value: tblName, qualifier: namespaceName && { nodeName: registry.NamespaceRef.NODE_NAME, value: namespaceName } };\n\n        let queryJson;\n        switch (querySpec.command || 'select') {\n\n            case 'insert':\n                const payload = [].concat(querySpec.payload);\n                if (!(typeof payload[0] === 'object' && payload[0])) {\n                    throw new Error('Invalid insert row format. Expected a non-null object.');\n                }\n\n                const columnNames = Object.keys(payload[0]);\n                const columns = columnNames.map((colName) => ({ nodeName: registry.ColumnRef2.NODE_NAME, value: colName }));\n                queryJson = {\n                    nodeName: registry.InsertStmt.NODE_NAME,\n                    table_ref: { ...tableRefJson, nodeName: registry.TableRef2.NODE_NAME },\n                    pg_table_alias: alias ? { nodeName: registry.Identifier.NODE_NAME, value: alias } : undefined,\n                    column_list: { nodeName: registry.ColumnsConstructor.NODE_NAME, entries: columns },\n                    values_clause: { nodeName: registry.ValuesConstructor.NODE_NAME, entries: [] },\n                };\n\n                for (const row of payload) {\n                    if (!(typeof row === 'object' && row)) {\n                        throw new Error('Invalid insert row format. Expected a non-null object.');\n                    }\n\n                    const _columnNames = new Set(Object.keys(row));\n                    if (_columnNames.size !== columnNames.length) {\n                        throw new Error('Inconsistent column count across rows in insert payload');\n                    }\n\n                    const rowJson = { nodeName: registry.RowConstructor.NODE_NAME, entries: [] };\n                    for (const colName of columnNames) {\n                        if (!_columnNames.has(colName)) {\n                            throw new Error(`Missing column \"${colName}\" in insert row`);\n                        }\n                        rowJson.entries.push(toExpr(row[colName]));\n                    }\n                    queryJson.values_clause.entries.push(rowJson);\n                }\n\n                break;\n\n            case 'update':\n                const _payload = querySpec.payload;\n\n                if (Array.isArray(_payload)) {\n                    throw new Error('Batch update is not supported. Please provide a single payload object for update.');\n                }\n                if (!(typeof _payload === 'object' && _payload)) {\n                    throw new Error('Invalid update payload format. Expected a non-null object.');\n                }\n\n                queryJson = {\n                    nodeName: registry.UpdateStmt.NODE_NAME,\n                    table_expr: {\n                        nodeName: registry.TableAbstraction2.NODE_NAME,\n                        table_ref: tableRefJson,\n                        alias: alias ? { nodeName: registry.SelectItemAlias.NODE_NAME, value: alias } : undefined\n                    },\n                    set_clause: { nodeName: registry.SetClause.NODE_NAME, entries: [] },\n                };\n\n                const _columnNames = Object.keys(_payload);\n                for (const colName of _columnNames) {\n                    const assignmentJson = {\n                        nodeName: registry.AssignmentExpr.NODE_NAME,\n                        left: options.dialect === 'mysql' ? { nodeName: registry.ColumnRef1.NODE_NAME, value: colName } : { nodeName: registry.ColumnRef2.NODE_NAME, value: colName },\n                        operator: '=',\n                        right: toExpr(_payload[colName])\n                    };\n                    queryJson.set_clause.entries.push(assignmentJson);\n                }\n\n                break;\n\n            case 'delete':\n                queryJson = {\n                    nodeName: registry.DeleteStmt.NODE_NAME,\n                    table_expr: {\n                        nodeName: registry.TableAbstraction2.NODE_NAME,\n                        table_ref: tableRefJson,\n                        alias: alias ? { nodeName: registry.SelectItemAlias.NODE_NAME, value: alias } : undefined\n                    },\n                };\n\n                break;\n\n            case 'select':\n                const selectItems = (querySpec.columns || ['*']).map((colName) => {\n                    return {\n                        nodeName: registry.SelectItem.NODE_NAME,\n                        expr: colName === '*'\n                            ? { nodeName: registry.ColumnRef0.NODE_NAME, value: colName }\n                            : { nodeName: registry.ColumnRef1.NODE_NAME, value: colName }\n                    };\n                });\n                queryJson = {\n                    nodeName: registry.CompleteSelectStmt.NODE_NAME,\n                    select_list: { nodeName: registry.SelectList.NODE_NAME, entries: selectItems },\n                    from_clause: {\n                        nodeName: registry.FromClause.NODE_NAME,\n                        entries: [{\n                            nodeName: registry.FromItem.NODE_NAME,\n                            expr: tableRefJson,\n                            alias: alias ? { nodeName: registry.FromItemAlias.NODE_NAME, value: alias } : undefined\n                        }]\n                    },\n                };\n\n                break;\n\n            default: throw new Error(`Invalid query input`);\n        }\n\n        if (querySpec.command !== 'insert') {\n            let baseExpr;\n\n            if (typeof querySpec.filters === 'object' && querySpec.filters) {\n                baseExpr = Object.keys(querySpec.filters).reduce((acc, key) => {\n                    const left = { nodeName: registry.ColumnRef1.NODE_NAME, value: key };\n                    const right = toExpr(querySpec.filters[key]);\n                    const exprJson = { nodeName: registry.BinaryExpr.NODE_NAME, left, operator: '=', right };\n                    if (!acc) return exprJson;\n                    return { nodeName: registry.BinaryExpr.NODE_NAME, left: acc, operator: 'AND', right: exprJson };\n                }, null);\n            }\n\n            if (dynamicWhereMode) {\n                return (dynamicWhere) => {\n                    // Dummy condition\n                    if (!dynamicWhere || dynamicWhere === true) {\n                        dynamicWhere = { nodeName: registry.BoolLiteral.NODE_NAME, value: 'TRUE' };\n                    }\n                    // Concat logic\n                    if (baseExpr) {\n                        dynamicWhere = { nodeName: registry.BinaryExpr.NODE_NAME, left: wrapORLogic(dynamicWhere), operator: 'AND', right: baseExpr };\n                    }\n                    // Patch query\n                    queryJson = {\n                        ...queryJson,\n                        where_clause: { nodeName: registry.WhereClause.NODE_NAME, expr: dynamicWhere },\n                    };\n                    return registry.Script.fromJSON(\n                        { entries: [queryJson] },\n                        { dialect: options.dialect, assert: true, supportStdStmt: true }\n                    ).entries()[0];\n                };\n            }\n\n            if (baseExpr) {\n                queryJson = {\n                    ...queryJson,\n                    where_clause: { nodeName: registry.WhereClause.NODE_NAME, expr: baseExpr },\n                };\n            }\n        }\n\n        return registry.Script.fromJSON(\n            { entries: [queryJson] },\n            { dialect: options.dialect, assert: true, supportStdStmt: true }\n        ).entries()[0];\n    }\n\n    async resolve(query, options = {}) {\n        // Parsing...\n        if (!(query instanceof AbstractNode)) {\n            query = await this.parse(query, options);\n        } else if (!(query instanceof registry.Script)\n            && !(query instanceof AbstractStmt)\n            && !(query instanceof registry.MYSetStmt)\n            && !(query instanceof registry.PGSetStmt)) {\n            throw new TypeError('query must be a string or an instance of Script | AbstractStmt');\n        }\n        if (query instanceof registry.Script && query.length === 1) {\n            query = query.entries()[0];\n        }\n\n        // Return if query is a set statement or a standard statement\n        if (query instanceof registry.MYSetStmt\n            || query instanceof registry.PGSetStmt\n            || query instanceof registry.StdStmt\n        ) return query;\n\n        // Determine by heuristics if desugaring needed\n        if ((query instanceof registry.DDLStmt && !query.returningClause?.()) // Desugaring not applicable\n            || query.originSchemas?.()?.length // Desugaring already done\n        ) return query;\n\n        // Schema inference...\n        const relationSelector = {};\n        let anyFound = false;\n        query.walkTree((v, k, scope) => {\n            if (v instanceof registry.MYSetStmt\n                || v instanceof registry.PGSetStmt\n                || v instanceof registry.StdStmt\n            ) return;\n            if (v instanceof registry.DDLStmt\n                && !v.returningClause?.()) return;\n            if (v instanceof registry.CTEItem) {\n                const alias = v.alias()?._get('delim')\n                    ? v.alias().value()\n                    : v.alias()?.value().toLowerCase();\n                scope.set(alias, true);\n                return v;\n            }\n            if ((!(v instanceof registry.TableRef2) || v.parentNode instanceof registry.ColumnIdent)\n                && (!(v instanceof registry.TableRef1) || v.parentNode instanceof registry.ColumnRef1)) {\n                return v;\n            }\n            const namespaceName = v.qualifier()?._get('delim')\n                ? v.qualifier().value()\n                : v.qualifier()?.value().toLowerCase() || '*';\n            const tableName = v._get('delim')\n                ? v.value()\n                : v.value().toLowerCase();\n            if (namespaceName === '*' && scope.has(tableName)) return;\n            if (!(namespaceName in relationSelector)) {\n                relationSelector[namespaceName] = [];\n            }\n            if (!relationSelector[namespaceName].includes(tableName)) {\n                relationSelector[namespaceName].push(tableName);\n                anyFound = true;\n            }\n        }, true);\n\n        if (anyFound) await this.schemaInference.provide(relationSelector);\n\n        // DeSugaring...\n        return query.deSugar(true, {}, null, this.schemaInference);\n    }\n\n    async query(...args) {\n        const [_query, options] = normalizeQueryArgs(...args);\n        const query = await this.resolve(_query, options);\n        // Realtime query?\n        if (options.live && query.fromClause?.()) {\n            return await this.#realtimeClient.query(query, options);\n        }\n        const result = await this._query(query, options);\n        return new Result({ rows: result.rows, rowCount: result.rowCount });\n    }\n\n    async cursor(...args) {\n        const [_query, options] = normalizeQueryArgs(...args);\n        const query = await this.resolve(_query, options);\n        return await this._cursor(query, options);\n    }\n\n    async showCreate(selector, structured = false) {\n        return await this._showCreate(selector, structured);\n    }\n}", "import { normalizeQueryArgs } from '../../entry/abstracts/util.js';\nimport { AbstractClient } from '../../entry/abstracts/AbstractClient.js';\n\nexport class AbstractFetchClient extends AbstractClient {\n\n    async parse(requestSpec, { alias = null, dynamicWhereMode = false, ...options } = {}) {\n    }\n\n    async resolve(request, options = {}) {\n    }\n\n    async request(...args) {\n        const [_request, options] = normalizeQueryArgs(...args);\n        const request = await this.parse(_request, options);\n        return await this._request(request, options);\n    }\n\n    async stream(...args) {\n        const [_request, options] = normalizeQueryArgs(...args);\n        const request = await this.parse(_request, options);\n        return await this._stream(request, options);\n    }\n\n    async showCreate(selector, structured = false) {\n        return await this._showCreate(selector, structured);\n    }\n}", "export class ConflictError extends Error {\n\n    #existing;\n    get existing() { return this.#existing; }\n\n    constructor(message, existing) {\n        super(message);\n        this.#existing = existing;\n    }\n}\n", "import { SimpleEmitter } from '../entry/abstracts/SimpleEmitter.js';\nimport { ConflictError } from './ConflictError.js';\n\nexport class TableStorage extends SimpleEmitter {\n\n    #name;\n    #schema;\n    #parentNode;\n\n    #materialized;\n    #querySpec;\n    #options;\n\n    #columns = [];\n    #keyColumns = [];\n\n    #keys = new Map;\n    #rows = new Map;\n\n    #counters = new Map;\n\n    get name() { return this.#name; }\n    get schema() { return this.#schema; }\n    get parentNode() { return this.#parentNode; }\n\n    get materialized() { return this.#materialized; }\n    get querySpec() { return this.#querySpec; }\n    get options() { return this.#options; }\n\n    constructor(schema, parentNode, { materialized = false, querySpec = null, ...options } = {}) {\n        super();\n\n        this.#name = schema.name().value();\n        this.#schema = schema;\n        this.#parentNode = parentNode;\n\n        this.#materialized = materialized;\n        this.#querySpec = querySpec;\n        this.#options = options;\n\n        this.#columns = schema.columns();\n\n        const pkRefs = this.#schema.pkConstraint(true)?.columns() || [];\n        const pkCols = pkRefs.map((pkRef) => this.#schema.get(pkRef));\n\n        this.#keyColumns = pkCols.map((pkCol) => pkCol.name().value());\n\n        this.on('changefeed', (events) => this.#parentNode?.emit('changefeed', events));\n    }\n\n    get size() { return this.#rows.size; }\n\n    async *[Symbol.asyncIterator]() {\n        for (const [, v] of this.#rows.entries()) {\n            yield v;\n        }\n    }\n\n    async * entries() {\n        for (const [k, v] of this.#rows.entries()) {\n            yield [k, v];\n        }\n    }\n\n    async _destroy() {\n        this.#parentNode = null;\n    }\n\n    async #nextCounter(colName) {\n        if (!this.#counters.has(colName)) {\n            this.#counters.set(colName, 1);\n        }\n        const v = this.#counters.get(colName);\n        this.#counters.set(colName, v + 1);\n        return v;\n    }\n\n    // -------- Keys\n\n    async createKey(keyName, type, columns = []) {\n        if (this.#keys.has(keyName)) throw new Error(`[${this.#name}] Key ${keyName} already exists`);\n        this.#keys.set(keyName, { type, columns, entries: new Map });\n    }\n\n    async showKeys(keyName = null) {\n        if (keyName) {\n            if (!this.#keys.has(keyName)) throw new Error(`[${this.#name}] Key ${keyName} does not exist`);\n            return [...this.#keys.get(keyName).entries.keys()];\n        }\n        return [...this.#rows.keys()];\n    }\n\n    async #computeKeys(row, forInsert = false) {\n        if (!forInsert && typeof row === 'string') {\n            return row;\n        }\n\n        const keyValues = [];\n\n        if (forInsert) {\n            for (const colSchema of this.#columns) {\n                const colName = colSchema.name().value();\n\n                const autoIncr = colSchema.identityConstraint() || colSchema.dataType().value() === 'SERIAL' || colSchema.autoIncrementConstraint();\n                const isPKey = this.#keyColumns.includes(colName);\n\n                let v = row[colName];\n                if (!v) {\n                    if (autoIncr) {\n                        v = await this.#nextCounter(colName);\n                        row = { ...row, [colName]: v };\n                    } else if (isPKey) {\n                        throw new Error(`[${this.#name}] Missing value for primary key field ${colName}`);\n                    }\n                }\n\n                if (isPKey) keyValues.push(v);\n            }\n        } else if (this.#keyColumns.length) {\n            for (const colName of this.#keyColumns) {\n                const v = row[colName];\n                if (!v) throw new Error(`[${this.#name}] Missing value for primary key field ${colName}`);\n                keyValues.push(v);\n            }\n        }\n\n        let pKey;\n        if (keyValues.length) {\n            pKey = JSON.stringify(keyValues);\n        } else pKey = JSON.stringify(Object.values(row))\n        return [pKey, row];\n    }\n\n    async #resolveKey(key, keyName = null) {\n        if (keyName) {\n            if (!this.#keys.has(keyName)) throw new Error(`[${this.#name}] Key ${keyName} does not exist`);\n            return this.#keys.get(keyName).entries.get(key);\n        }\n        return key;\n    }\n\n    // ------ CRUD\n\n    async insert(row, { keyName = null, newKey = null } = {}, { transaction = null } = {}) {\n        if (keyName && newKey) {\n            const pKey = await this.#resolveKey(newKey, keyName);\n            if (pKey) {\n                const existing = this.#rows.get(pKey);\n                throw new ConflictError(`[${this.#name}] Duplicate entry for key ${newKey} on index ${keyName}`, existing);\n            }\n        }\n\n        let pKey;\n        [pKey, row] = await this.#computeKeys(row, true);\n\n        if (this.#rows.has(pKey)) {\n            if (!this.#keyColumns.length) {\n                const _pKey = pKey;\n                let i = 0;\n                while (this.#rows.has(pKey = `${_pKey}${i}`)) i++;\n            } else {\n                const existing = this.#rows.get(pKey);\n                throw new ConflictError(`[${this.#name}] Duplicate entry for key ${pKey}`, existing);\n            }\n        }\n\n        this.#rows.set(pKey, row);\n        if (keyName && newKey) {\n            this.#keys.get(keyName).entries.set(newKey, pKey);\n        }\n\n        const outRow = { ...row };\n        transaction?.emit('changefeed', { type: 'insert', relation: { namespace: this.#parentNode.name, name: this.#name, keyColumns: [...this.#keyColumns] }, new: outRow });\n        if (transaction) return Object.defineProperty(outRow, 'XMAX', { value: 0 }); // Must be 0\n\n        return outRow;\n    }\n\n    async update(rowOrKey, row, { keyName = null, newKey = null } = {}, { transaction = null } = {}) {\n        let oldPKey;\n        if (keyName && typeof rowOrKey === 'string') {\n            oldPKey = await this.#resolveKey(rowOrKey, keyName);\n        } else if (typeof rowOrKey === 'object' && rowOrKey) {\n            [oldPKey] = await this.#computeKeys(rowOrKey, false);\n        } else oldPKey = String(rowOrKey);\n\n        let newPKey;\n        [newPKey, row] = await this.#computeKeys(row, false);\n\n        const old = this.#rows.get(oldPKey);\n        if (!old) throw new Error(`[${this.#name}] Record not found for ${key || newPKey}${keyName ? ` of key ${keyName}` : ''}`);\n\n        this.#rows.set(oldPKey, row);\n        if (newPKey !== oldPKey) {\n            const reIndexed = [...this.#rows.entries()].map(([k, v]) => [k === oldPKey ? newPKey : k, v]);\n            this.#rows = new Map(reIndexed);\n        }\n\n        if (keyName) {\n            if (newKey) this.#keys.get(keyName).entries.delete(rowOrKey);\n            if (newKey || newPKey !== oldPKey) this.#keys.get(keyName).entries.set(newKey || rowOrKey, newPKey);\n        }\n\n        const outRow = { ...row };\n        transaction?.emit('changefeed', { type: 'update', relation: { namespace: this.#parentNode.name, name: this.#name, keyColumns: [...this.#keyColumns] }, old, new: outRow });\n        if (transaction) return Object.defineProperty(outRow, 'XMAX', { value: transaction.txId });\n\n        return outRow;\n    }\n\n    async delete(rowOrKey, { keyName = null } = {}, { transaction = null } = {}) {\n        let pKey;\n        if (keyName && typeof rowOrKey === 'string') {\n            pKey = await this.#resolveKey(rowOrKey, keyName);\n        } else if (typeof rowOrKey === 'object' && rowOrKey) {\n            [pKey] = await this.#computeKeys(rowOrKey, false);\n        } else pKey = String(rowOrKey);\n\n        const old = this.#rows.get(pKey);\n        if (!old) throw new Error(`[${this.#name}] Record not found for ${key}${keyName ? ` of key ${keyName}` : ''}`);\n\n        this.#rows.delete(pKey);\n\n        const outRow = { ...old };\n        transaction?.emit('changefeed', { type: 'delete', relation: { namespace: this.#parentNode.name, name: this.#name, keyColumns: [...this.#keyColumns] }, old });\n        if (transaction) return Object.defineProperty(outRow, 'XMAX', { value: transaction.txId });\n\n        return outRow;\n    }\n\n    async get(rowOrKey, { keyName = null } = {}) {\n        let pKey;\n        if (keyName && typeof rowOrKey === 'string') {\n            pKey = await this.#resolveKey(rowOrKey, keyName);\n        } else if (typeof rowOrKey === 'object' && rowOrKey) {\n            [pKey] = await this.#computeKeys(rowOrKey, false);\n        } else pKey = String(rowOrKey);\n\n        return this.#rows.get(pKey);\n    }\n\n    async truncate() {\n        this.#rows.clear();\n        this.#keys.clear();\n    }\n}", "import { SimpleEmitter } from '../entry/abstracts/SimpleEmitter.js';\nimport { TableStorage } from './TableStorage.js';\nimport { registry } from '../lang/registry.js';\n\nexport class StorageNamespace extends SimpleEmitter {\n\n    #name;\n    #parentNode;\n\n    #type;\n    #mirrored;\n    #origin;\n    #options;\n\n    #tables = new Map;\n\n    get name() { return this.#name; }\n    get parentNode() { return this.#parentNode; }\n\n    get type() { return this.#type; }\n    get mirrored() { return this.#mirrored; }\n    get origin() { return this.#origin; }\n    get options() { return this.#options; }\n\n    constructor(name, parentNode, { type = null, mirrored = false, origin = null, ...options } = {}) {\n        super();\n        this.#name = name;\n        this.#parentNode = parentNode;\n\n        this.#type = type;\n        this.#mirrored = mirrored;\n        this.#origin = origin;\n        this.#options = options;\n\n        this.on('changefeed', (events) => this.#parentNode?.emit('changefeed', events));\n    }\n\n    get size() { return this.#tables.size; }\n\n    async _destroy() {\n        this.#parentNode = null;\n    }\n\n    async tableNames(selector = {}) {\n        let list = [...this.#tables.keys()];\n\n        if ('materialized' in selector) {\n            list = list.filter((tableName) => {\n                const tableStorage = this.#tables.get(tableName);\n                if (/*'materialized' in selector\n                    && */Boolean(selector.materialized) !== Boolean(tableStorage.materialized)) return false;\n                return true;\n            });\n        }\n\n        return list;\n    }\n\n    async createTable(tableSchema, { ifNotExists = false, primaryKey = 'id', autoIncr = true, dialect = 'postgres', ...tableOptions } = {}) {\n        if (typeof tableSchema === 'string') {\n            tableSchema = { name: { value: tableSchema }, entries: [] };\n            if (primaryKey) {\n                const keyCol = {\n                    nodeName: registry.ColumnSchema.NODE_NAME,\n                    name: { value: primaryKey },\n                    data_type: { value: 'INT' },\n                    entries: [{ nodeName: registry.ColumnPKConstraint.NODE_NAME, value: 'KEY' }],\n                };\n                if (autoIncr) {\n                    if (dialect === 'mysql') {\n                        keyCol.entries.push({\n                            nodeName: registry.MyColumnAutoIncrementModifier.NODE_NAME,\n                            value: 'AUTO_INCREMENT',\n                        });\n                    } else {\n                        keyCol.entries.push({\n                            nodeName: registry.ColumnIdentityConstraint.NODE_NAME,\n                            by_default_kw: true,\n                            as_identity_kw: true,\n                        });\n                    }\n                }\n                tableSchema.entries.push(keyCol);\n            }\n            // Instantiate\n            tableSchema = registry.TableSchema.fromJSON(tableSchema, { dialect });\n        } else {\n            if (!(tableSchema instanceof registry.TableSchema)) {\n                throw new Error(`tableSchema must be an instance of TableSchema`);\n            }\n            tableSchema = tableSchema.clone();\n            if (tableSchema.name().qualifier?.()\n                && tableSchema.name().qualifier().value() !== this.#name) {\n                throw new Error(`Cannot create table ${tableSchema.name()} at namespace ${this.#name}`);\n            }\n        }\n\n        const tableName = tableSchema.name().value();\n        if (this.#tables.has(tableName)) {\n            if (ifNotExists) return this.#tables.get(tableName);\n            throw new Error(`Table ${tableName} already exists`);\n        }\n\n        const tableStorage = new TableStorage(tableSchema, this, tableOptions);\n        this.#tables.set(tableName, tableStorage);\n        return tableStorage;\n    }\n\n    async dropTable(tableName, { ifExists = false, cascade = false } = {}) {\n        const tableStorage = this.#tables.get(tableName);\n        if (!tableStorage) {\n            if (ifExists) return null;\n            throw new Error(`Table ${tableName} does not exist`);\n        }\n\n        if (tableStorage.size && !cascade) {\n            throw new Error(`Table ${tableName} is not empty.`);\n        }\n        await tableStorage._destroy();\n\n        this.#tables.delete(tableName);\n        return tableStorage;\n    }\n\n    async getTable(tableName) {\n        const tableStorage = this.#tables.get(tableName);\n        if (!tableStorage) throw new Error(`Table ${tableName} does not exist`);\n        return tableStorage;\n    }\n}", "import { SimpleEmitter } from '../entry/abstracts/SimpleEmitter.js';\nimport { ConflictError } from './ConflictError.js';\nimport { StorageNamespace } from './StorageNamespace.js';\n\nexport class StorageEngine extends SimpleEmitter {\n\n    #searchPath;\n    #options;\n\n    #catalog = new Map;\n    #init;\n\n    get defaultNamespace() { return this.#searchPath[0]; }\n    get options() { return this.#options; }\n\n    constructor({\n        searchPath = ['public'],\n        ...options\n    } = {}) {\n        super();\n        this.#searchPath = [].concat(searchPath || []);\n        this.#options = options;\n\n        if (this.defaultNamespace) {\n            this.#init = this.createNamespace(this.defaultNamespace, { ifNotExists: true });\n        }\n    }\n\n    async setSearchPath(...searchPath) {\n        this.#searchPath = searchPath;\n    }\n\n    async getSearchPath() {\n        return this.#searchPath.slice();\n    }\n\n    async startTransaction(txIdPrefix = '~tx') {\n        const events = new Map;\n        const txId = `${txIdPrefix}:${(0 | Math.random() * 9e6).toString(36)}`;\n\n        return {\n            txId,\n            emit: (eventName, event) => {\n                if (!events.has(eventName)) events.set(eventName, []);\n                events.get(eventName).push({ ...event, txId });\n            },\n            done: async () => {\n                for (const [name, _events] of events.entries()) {\n                    this.emit(name, _events);\n                }\n                events.clear();\n            }\n        };\n    }\n\n    async namespaceNames(selector = {}) {\n        await this.#init;\n        let list = [...this.#catalog.keys()];\n\n        if ('mirrored' in selector) {\n            list = list.filter((ns) => {\n                const nsObj = this.#catalog.get(ns);\n                if (/*'mirrored' in selector\n                    && */Boolean(selector.mirrored) !== Boolean(nsObj.mirrored)) return false;\n                return true;\n            });\n        }\n\n        return list;\n    }\n\n    async createNamespace(namespaceName, { ifNotExists = false, ...namespaceOptions } = {}) {\n        await this.#init;\n\n        if (this.#catalog.has(namespaceName)) {\n            if (ifNotExists) return this.#catalog.get(namespaceName);\n            throw new ConflictError(`Schema/namespace ${namespaceName} already exists`);\n        }\n\n        const namespaceObject = new StorageNamespace(namespaceName, this, namespaceOptions);\n        this.#catalog.set(namespaceName, namespaceObject);\n        return namespaceObject;\n    }\n\n    async dropNamespace(namespaceName, { ifExists = false, cascade = false } = {}) {\n        await this.#init;\n\n        const namespaceObject = this.#catalog.get(namespaceName);\n        if (!namespaceObject) {\n            if (ifExists) return null;\n            throw new Error(`Schema/namespace ${namespaceName} does not exist`);\n        }\n\n        if (namespaceObject.size && !cascade) {\n            throw new Error(`Schema/namespace ${namespaceName} is not empty.`);\n        }\n        await namespaceObject._destroy();\n\n        this.#catalog.delete(namespaceName);\n        return namespaceObject;\n    }\n\n    async getNamespace(namespaceName) {\n        await this.#init;\n\n        const namespaceObject = this.#catalog.get(namespaceName);\n        if (!namespaceObject) throw new Error(`Schema/namespace ${namespaceName} does not exist`);\n        return namespaceObject;\n    }\n\n    async showMirrors(selector = {}) {\n        const mirroredNamespaces = await this.namespaceNames({ mirrored: true });\n        const mirroredNamespacesEntries = mirroredNamespaces.map(async (namespaceName) => {\n\n            const namespaceObject = await this.getNamespace(namespaceName);\n            const tables = await namespaceObject.tableNames(selector);\n\n            const tablesEntries = tables.map(async (tableName) => {\n                const tableStorage = await namespaceObject.getTable(tableName);\n\n                return [tableName, { materialized: tableStorage.materialized, querySpec: tableStorage.querySpec }];\n            });\n\n            return [namespaceName, { type: namespaceObject.type, origin: namespaceObject.origin, tables: new Map(await Promise.all(tablesEntries)) }];\n        });\n\n        return new Map(await Promise.all(mirroredNamespacesEntries));\n    }\n}\n", "import { SimpleEmitter } from '../entry/abstracts/SimpleEmitter.js';\nimport { AbstractNode } from '../lang/abstracts/AbstractNode.js';\nimport { AbstractFetchClient } from './fetch/AbstractFetchClient.js';\nimport { ConflictError } from './ConflictError.js';\nimport { ExprEngine } from './ExprEngine.js';\nimport { registry } from '../lang/registry.js';\n\nconst TBL_PLACEHOLDER = Symbol.for('tbl_placeholder');\nconst GROUPING_META = Symbol.for('grouping_meta');\nconst WINDOW_META = Symbol.for('window_meta');\n\nexport class QueryEngine extends SimpleEmitter {\n\n    #storageEngine;\n    #exprEngine;\n    #options;\n\n    constructor(storageEngine, { dialect = 'postgres', ...options } = {}) {\n        super();\n        this.#storageEngine = storageEngine;\n        this.#options = { dialect, ...options };\n\n        // The ExprEngine\n        const self = this;\n        this.#exprEngine = new ExprEngine(\n            async function* (derivedQuery, compositeRow, queryCtx) {\n                let queryString, result;\n                // Always run afresh if correlated or if first time\n                if (derivedQuery.isCorrelated() || !(\n                    result = queryCtx.cteRegistry?.get(queryString = derivedQuery.stringify()))) {\n                    const _queryCtx = { ...queryCtx, lateralCtx: { ...(queryCtx.lateralCtx || {}), ...compositeRow }, depth: queryCtx.depth + 1 };\n                    result = await self.#evaluateSTMT(\n                        derivedQuery.expr(),\n                        _queryCtx\n                    );\n                    if (queryCtx.cteRegistry && queryString) {\n                        // Cache now being not isCorrelated()\n                        const _result = result, copy = [];\n                        queryCtx.cteRegistry.set(queryString, copy);\n                        result = (async function* () {\n                            for await (const row of _result) {\n                                copy.push(row);\n                                yield row;\n                            }\n                        })();\n                    }\n                }\n                yield* result;\n            },\n            this.#options,\n        );\n    }\n\n    // -------- ENTRY\n\n    async query(scriptNode, options = {}) {\n        const queryCtx = {\n            options: { ...this.#options, ...options },\n            transaction: await this.#storageEngine.startTransaction(),\n            lateralCtx: null,\n            cteRegistry: new Map,\n            depth: 0,\n        };\n\n        const returnValue = await this.#evaluateSTMT(scriptNode, queryCtx);\n        await queryCtx.transaction.done();\n\n        if (returnValue && typeof returnValue?.[Symbol.asyncIterator] === 'function' && options.bufferResultRows !== false) {\n            const rows = [];\n            for await (const r of returnValue) rows.push(r);\n            return { rows };\n        }\n        if (typeof returnValue === 'number' && options.bufferResultRows !== false) {\n            return { rowCount: returnValue };\n        }\n\n        return returnValue;\n    }\n\n    // -------- DISPATCHER\n\n    async #evaluateSTMT(scriptNode, queryCtx) {\n        let returnValue;\n        for (let stmtNode of (scriptNode instanceof registry.Script && scriptNode || [scriptNode])) {\n            switch (stmtNode.NODE_NAME) {\n                // CONFIG\n                case 'PG_SET_STMT': returnValue = await this.#evaluatePG_SET_STMT(stmtNode, queryCtx); break;\n                // DDL\n                case 'CREATE_SCHEMA_STMT': returnValue = await this.#evaluateCREATE_SCHEMA_STMT(stmtNode, queryCtx); break;\n                case 'ALTER_SCHEMA_STMT': returnValue = await this.#evaluateALTER_SCHEMA_STMT(stmtNode, queryCtx); break;\n                case 'DROP_SCHEMA_STMT': returnValue = await this.#evaluateDROP_SCHEMA_STMT(stmtNode, queryCtx); break;\n                case 'CREATE_TABLE_STMT': returnValue = await this.#evaluateCREATE_TABLE_STMT(stmtNode, queryCtx); break;\n                case 'ALTER_TABLE_STMT': returnValue = await this.#evaluateALTER_TABLE_STMT(stmtNode, queryCtx); break;\n                case 'DROP_TABLE_STMT': returnValue = await this.#evaluateDROP_TABLE_STMT(stmtNode, queryCtx); break;\n                // CTE\n                case 'CTE': returnValue = await this.#evaluateCTE(stmtNode, queryCtx); break;\n                // DML\n                case 'INSERT_STMT': returnValue = await this.#evaluateINSERT_STMT(stmtNode, queryCtx); break;\n                case 'UPDATE_STMT': returnValue = await this.#evaluateUPDATE_STMT(stmtNode, queryCtx); break;\n                case 'DELETE_STMT': returnValue = await this.#evaluateDELETE_STMT(stmtNode, queryCtx); break;\n                // DQL\n                case 'TABLE_STMT': returnValue = await this.#evaluateTABLE_STMT(stmtNode, queryCtx); break;\n                case 'BASIC_SELECT_STMT':\n                case 'COMPLETE_SELECT_STMT': returnValue = await this.#evaluateSELECT_STMT(stmtNode, queryCtx); break;\n                case 'COMPOSITE_SELECT_STMT': returnValue = await this.#evaluateCOMPOSITE_SELECT_STMT(stmtNode, queryCtx); break;\n                // STD_STMT\n                case 'STD_STMT': console.error(`Not supported yet in the in-memory StorageEngine: ${stmtNode.stringify()}`); break;\n                // Throw\n                default: throw new Error(`Unknown statement type: ${stmtNode.NODE_NAME}`);\n            }\n        }\n        return returnValue;\n    }\n\n    // -------- CONFIG\n\n    async #evaluatePG_SET_STMT(stmtNode, queryCtx) {\n        const scopeKW = stmtNode.scopeKW();\n        const left = stmtNode.left()?.toLowerCase();\n        const right = stmtNode.right();\n        if (left === 'search_path') {\n            const searchPath = right.map((r) => r.value());\n            this.#storageEngine.setSearchPath(...searchPath);\n            return true;\n        }\n    }\n\n    // -------- DDL\n\n    async #evaluateCREATE_SCHEMA_STMT(stmtNode, queryCtx) {\n        const nsName = stmtNode.name().value();\n        if (!nsName) {\n            throw new Error('Cannot create a namespace with an empty name');\n        }\n\n        const createOpts = { ifNotExists: !!stmtNode.ifNotExists() };\n        const namespaceObject = await this.#storageEngine.createNamespace(nsName, createOpts, queryCtx);\n\n        if (namespaceObject && stmtNode.pgEntries()?.length) {\n            if (ifNotExists) {\n                throw new Error('CREATE SCHEMA ... IF NOT EXISTS ... with entries is not supported');\n            }\n            const __queryCtx = { ..._queryCtx, nsName };\n            for (const entry of stmtNode.pgEntries()) {\n                await this.#evaluateSTMT(entry, __queryCtx);\n            }\n        }\n\n        return true;\n    }\n\n    async #evaluateALTER_SCHEMA_STMT(stmtNode, queryCtx) {\n        // TODO notice\n        throw new Error('ALTER SCHEMA is not supported yet in the in-memory StorageEngine');\n    }\n\n    async #evaluateDROP_SCHEMA_STMT(stmtNode, queryCtx) {\n        const namespaceNames = stmtNode.myName()\n            ? [stmtNode.myName().value()]\n            : stmtNode.pgNames().map((n) => n.value());\n\n        const dropOpts = { ifExists: !!stmtNode.ifExists(), cascade: stmtNode.pgCascadeRule() === 'CASCADE' };\n\n        let returnValue;\n        for (const nsName of namespaceNames) {\n            returnValue = !!await this.#storageEngine.dropNamespace(nsName, dropOpts, queryCtx);\n        }\n\n        return returnValue;\n    }\n\n    async #evaluateCREATE_TABLE_STMT(stmtNode, queryCtx) {\n        if (stmtNode.temporaryKW()) {\n            throw new Error('TEMPORARY tables are not supported yet in the in-memory StorageEngine');\n        }\n\n        const argument = stmtNode.argument();\n        const nsName = argument.name().qualifier()?.value() || queryCtx.nsName || this.#storageEngine.defaultNamespace;\n        if (queryCtx.nsName && nsName !== queryCtx.nsName) {\n            throw new Error(`Cannot create table ${argument.name()} in namespace ${queryCtx.nsName} as it is qualified to namespace ${nsName}`);\n        }\n\n        const namespaceObject = await this.#storageEngine.getNamespace(nsName);\n        const createOpts = { ifNotExists: !!stmtNode.ifNotExists() };\n\n        return !!await namespaceObject.createTable(argument, createOpts, queryCtx);\n    }\n\n    async #evaluateALTER_TABLE_STMT(stmtNode, queryCtx) {\n        // TODO notice\n        throw new Error('ALTER TABLE is not supported yet in the in-memory StorageEngine');\n    }\n\n    async #evaluateDROP_TABLE_STMT(stmtNode, queryCtx) {\n        if (stmtNode.myTemporaryKW()) {\n            throw new Error('MySQL TEMPORARY tables are not supported yet in the in-memory StorageEngine');\n        }\n\n        const tableNames = stmtNode.names().map((n) => {\n            const nsName = n.qualifier()?.value() || queryCtx.nsName || this.#storageEngine.defaultNamespace;\n            return [n.value(), nsName];\n        });\n        const dropOpts = { ifExists: !!stmtNode.ifExists(), cascade: stmtNode.cascadeRule() === 'CASCADE' };\n\n        let returnValue;\n        for (const [tblName, nsName] of tableNames) {\n            const namespaceObject = await this.#storageEngine.getNamespace(nsName);\n            returnValue = !!await namespaceObject.dropTable(tblName, dropOpts, queryCtx);\n        }\n\n        return returnValue;\n    }\n\n    // -------- CTE\n\n    async #evaluateCTE(stmtNode, queryCtx) {\n        // Declare CTEs while inheriting super CTEs\n        const cteRegistry = new Map(queryCtx.cteRegistry || []);\n        queryCtx = { ...queryCtx, cteRegistry };\n\n        // Evaluate...\n        for (const cteItem of stmtNode.declarations()) {\n            const cteName = cteItem.alias().value();\n            if (cteRegistry?.has(cteName)) {\n                throw new Error(`CTE name ${cteName} already exists in the current context`);\n            }\n\n            const itemBody = cteItem.expr();\n            const cteStream = await this.#evaluateSTMT(itemBody, queryCtx);\n            cteRegistry.set(cteName, cteStream);\n        }\n\n        return await this.#evaluateSTMT(stmtNode.body(), queryCtx);\n    }\n\n    // -------- DML\n\n    async #evaluateINSERT_STMT(stmtNode, queryCtx) {\n        const _ = {};\n        if (!Array.isArray(_.originSchemas = stmtNode.originSchemas())) throw new Error('Expected a pre-resolved query object with originSchemas() returning an array');\n\n        // Resolve nsName\n        const nsName = stmtNode.tableRef().qualifier()?.value() || this.#storageEngine.defaultNamespace;\n        const namespaceObject = await this.#storageEngine.getNamespace(nsName);\n\n        // Resolve table\n        const tblName = stmtNode.tableRef().value();\n        const tableAlias = stmtNode.pgTableAlias()?.value() || tblName;\n        const tableStorage = await namespaceObject.getTable(tblName);\n\n        // Resolve table schema\n        const tableSchema = _.originSchemas[0];\n\n        // Resolve column names\n        const definedColumns = Object.fromEntries(tableSchema.columns().map((col) => [col.name().value(), col]));\n        const columnNames = stmtNode.columnList()?.entries().map((col) => col.value())\n            || Object.keys(definedColumns);\n\n        // Resolve defaults and constraints\n        const defaultRecord = Object.create(null);\n        for (const [colName, colSchema] of Object.entries(definedColumns)) {\n            defaultRecord[colName] = null;\n            if (_.cons = colSchema.defaultConstraint()) {\n                defaultRecord[colName] = await this.#exprEngine.evaluate(_.cons.expr());\n            }\n        }\n\n        // Build records\n        const records = [];\n        // ----------- a. values_clause\n        if (_.valuesClause = stmtNode.valuesClause()) {\n            for (const rowConstructor of _.valuesClause) {\n                const record = { ...defaultRecord };\n                const defaultContext = { [tableAlias]: record };\n\n                for (let [i, valExpr] of rowConstructor.entries().entries()) {\n                    const colName = columnNames[i];\n                    const colSchema = definedColumns[colName];\n\n                    if (valExpr instanceof registry.DefaultLiteral) {\n                        const defaultConstraint = colSchema.defaultConstraint();\n                        if (defaultConstraint) valExpr = defaultConstraint.expr();\n                    }\n\n                    const colValue = await this.#exprEngine.evaluate(valExpr, defaultContext, queryCtx);\n                    this.#acquireValue(record, colSchema, colValue);\n                }\n\n                records.push(record);\n            }\n        }\n        // ----------- b. select_clause | my_table_clause\n        else if ((_.selectClause = stmtNode.selectClause())\n            || (_.myTableClause = stmtNode.myTableClause())) {\n            const _queryCtx = { ...queryCtx, depth: queryCtx.depth + 1 };\n\n            const stream = _.myTableClause\n                ? this.#evaluateTABLE_STMT(_.myTableClause, _queryCtx)\n                : await this.#evaluateSTMT(_.selectClause, _queryCtx); // Can be any of the three SELECT_STMT types\n\n            for await (const _record of stream) {\n                const record = { ...defaultRecord };\n\n                for (const [colIdx, colValue] of Object.values(_record).entries()) {\n                    const targetColName = columnNames[colIdx];\n                    const colSchema = definedColumns[targetColName];\n                    this.#acquireValue(record, colSchema, colValue);\n                }\n\n                records.push(record);\n            }\n        }\n        // ----------- c. pg_default_values_clause\n        else if (stmtNode.pgDefaultValuesClause()) {\n            const record = { ...defaultRecord };\n            records.push(record);\n        }\n        // ----------- d. my_set_clause\n        else if (_.mySetClause = stmtNode.mySetClause()) {\n            const renderedLogicalRecord = await this.#renderSetClause({ [tableAlias]: defaultRecord }, _.mySetClause, null, queryCtx);\n            records.push(renderedLogicalRecord[tableAlias]);\n        }\n\n        // Dispatch to DB\n        let rowCount = 0;\n        const returnList = [];\n        const conflictHandlingClause = stmtNode.conflictHandlingClause();\n        const returningClause = stmtNode.returningClause();\n\n        for (const record of records) {\n            // Exec insert / update\n            let finalizedRecord;\n            try {\n                finalizedRecord = await tableStorage.insert(record, {}, queryCtx);\n            } catch (e) {\n                // TODO: Assertain conflict target\n                if (e instanceof ConflictError && conflictHandlingClause?.length) {\n                    if (conflictHandlingClause.whereClause?.()\n                        && !await this.evaluateWhereClause(conflictHandlingClause.whereClause(), [{ [tableAlias]: e.existing }], queryCtx)) {\n                        finalizedRecord = null;\n                    } else {\n                        const newLogicalRecord = await this.#renderSetClause({ [tableAlias]: e.existing, EXCLUDED: record }, conflictHandlingClause, _.originSchemas, queryCtx);\n                        finalizedRecord = await tableStorage.update(e.existing, newLogicalRecord[tableAlias], {}, queryCtx);\n                    }\n                } else if (e instanceof ConflictError && conflictHandlingClause?.doNothingKW?.()) {\n                    finalizedRecord = null;\n                } else throw e;\n            }\n            // Process RETURNING clause\n            if (returningClause) {\n                if (finalizedRecord) {\n                    const _record = Object.create(null);\n                    const outputRecordContext = { [tableAlias]: finalizedRecord };\n\n                    for (const selectItem of returningClause) {\n                        const { alias, value } = await this.#exprEngine.evaluate(selectItem, outputRecordContext, queryCtx);\n                        _record[alias] = value;\n                    }\n\n                    returnList.push(_record);\n                }\n            } else rowCount++;\n        }\n\n        // Number | array\n        if (!returningClause) return rowCount;\n        return (async function* () { yield* returnList; })();\n    }\n\n    async #evaluateUPDATE_STMT(stmtNode, queryCtx) {\n        const _ = {};\n        if (!Array.isArray(_.originSchemas = stmtNode.originSchemas())) throw new Error('Expected a pre-resolved query object with originSchemas() returning an array');\n\n        // Derive FromItems and JoinClauses\n        let fromItems, joinClauses, updateTargets;\n        if (_.myUpdateList = stmtNode.myUpdateList()) {\n\n            // Derive FromItems and JoinClauses\n            fromItems = _.myUpdateList;\n            joinClauses = stmtNode.joinClauses() || [];\n\n            // Derive update targets\n            updateTargets = fromItems.concat(joinClauses).map((item) => {\n                const tableRef = item.expr?.() || item.tableRef();\n\n                const tblName = tableRef.value();\n                const tableAlias = item.alias()?.value() || tblName;\n                const nsName = tableRef.qualifier()?.value() || this.#storageEngine.defaultNamespace;\n\n                return [tableAlias, tblName, nsName];\n            });\n        } else {\n            const tableExpr = stmtNode.tableExpr();\n\n            // Derive FromItems and JoinClauses\n            fromItems = [tableExpr];\n            joinClauses = (stmtNode.pgFromClause()?.entries() || []).concat(stmtNode.joinClauses() || []);\n\n            // Derive update targets\n            const nsName = tableExpr.tableRef().qualifier()?.value() || this.#storageEngine.defaultNamespace;\n            const tblName = tableExpr.tableRef().value();\n            const tableAlias = tableExpr.alias()?.value() || tblName;\n\n            updateTargets = [\n                [tableAlias, tblName, nsName],\n            ];\n        }\n\n        // FROM -> composites\n        let stream = await this.evaluateFromItems(fromItems, joinClauses, _.originSchemas, queryCtx);\n        if (_.whereClause = stmtNode.whereClause()) {\n            stream = this.evaluateWhereClause(_.whereClause, stream, queryCtx);\n        }\n\n        // 3. Exec updates\n        let rowCount = 0;\n        const returnList = [];\n        const returningClause = stmtNode.returningClause();\n        const setClause = stmtNode.setClause();\n\n        for await (const logicalRecord of stream) {\n            // Exec update\n            const newLogicalRecord = await this.#renderSetClause(logicalRecord, setClause, _.originSchemas, queryCtx);\n\n            for (const [tableAlias, tblName, nsName] of updateTargets) {\n                if (newLogicalRecord[tableAlias] === logicalRecord[tableAlias]) continue;\n\n                const namespaceObject = await this.#storageEngine.getNamespace(nsName);\n                const tableStorage = await namespaceObject.getTable(tblName);\n\n                newLogicalRecord[tableAlias] = await tableStorage.update(logicalRecord[tableAlias], newLogicalRecord[tableAlias], {}, queryCtx);\n            }\n\n            // Process RETURNING clause\n            if (returningClause) {\n                const _record = Object.create(null);\n\n                for (const selectItem of returningClause) {\n                    const { alias, value } = await this.#exprEngine.evaluate(selectItem, newLogicalRecord, queryCtx);\n                    _record[alias] = value;\n                }\n\n                returnList.push(_record);\n            } else rowCount++;\n        }\n\n        // Number | array\n        if (!returningClause) return rowCount;\n        return (async function* () { yield* returnList; })();\n    }\n\n    async #evaluateDELETE_STMT(stmtNode, queryCtx) {\n        const _ = {};\n        if (!Array.isArray(_.originSchemas = stmtNode.originSchemas())) throw new Error('Expected a pre-resolved query object with originSchemas() returning an array');\n\n        // Derive FromItems and JoinClauses\n        let fromItems, joinClauses, deleteTargets;\n        if (_.myDeleteList = stmtNode.myDeleteList()) {\n\n            // Derive FromItems and JoinClauses\n            fromItems = (stmtNode.myFromClause() || stmtNode.usingClause())?.entries() || [];\n            joinClauses = stmtNode.joinClauses() || [];\n\n            // Derive update targets\n            const _combinedFromItems = [...fromItems, ...joinClauses];\n\n            deleteTargets = _.myDeleteList.map((item) => {\n                const fromItem = _combinedFromItems.find((fi) => (fi.alias() || fi.expr()).identifiesAs(item));\n                const tableRef = fromItem.expr();\n                const tblName = tableRef.value?.();\n\n                if (!tblName) throw new Error(`Cannot delete from ${item}; ${fromItem} isn't a table reference.`);\n\n                const nsName = tableRef.qualifier()?.value() || this.#storageEngine.defaultNamespace;\n                return [item.value(), tblName, nsName];\n            });\n        } else {\n            const tableExpr = stmtNode.tableExpr();\n\n            // Derive FromItems and JoinClauses\n            fromItems = [tableExpr];\n            joinClauses = (stmtNode.pgUsingClause()?.entries() || []).concat(stmtNode.joinClauses() || []);\n\n            // Derive update targets\n            const tableRef = tableExpr.tableRef();\n            const tblName = tableRef.value();\n            const tableAlias = tableExpr.alias()?.value() || tblName;\n            const nsName = tableRef.qualifier()?.value() || this.#storageEngine.defaultNamespace;\n\n            deleteTargets = [\n                [tableAlias, tblName, nsName],\n            ];\n        }\n\n        // FROM -> composites\n        let stream = await this.evaluateFromItems(fromItems, joinClauses, _.originSchemas, queryCtx);\n        if (_.whereClause = stmtNode.whereClause()) {\n            stream = this.evaluateWhereClause(_.whereClause, stream, queryCtx);\n        }\n\n        // 3. Exec updates\n        let rowCount = 0;\n        const returnList = [];\n        const returningClause = stmtNode.returningClause();\n\n        for await (let logicalRecord of stream) {\n            for (const [tableAlias, tblName, nsName] of deleteTargets) {\n\n                const namespaceObject = await this.#storageEngine.getNamespace(nsName);\n                const tableStorage = await namespaceObject.getTable(tblName);\n\n                logicalRecord[tableAlias] = await tableStorage.delete(logicalRecord[tableAlias], {}, queryCtx);\n            }\n\n            // Process RETURNING clause\n            if (returningClause) {\n                const _record = Object.create(null);\n\n                for (const selectItem of returningClause) {\n                    const { alias, value } = await this.#exprEngine.evaluate(selectItem, logicalRecord, queryCtx);\n                    _record[alias] = value;\n                }\n\n                returnList.push(_record);\n            } else rowCount++;\n        }\n\n        // Number | array\n        if (!returningClause) return rowCount;\n        return (async function* () { yield* returnList; })();\n    }\n\n    async #renderSetClause(logicalRecord, setClause, originSchemas, queryCtx) {\n        const newLogicalRecord = { ...logicalRecord };\n        const baseAlias = Object.keys(logicalRecord)[0];\n\n        const acquireValue = async (tableAlias, colName, valExpr) => {\n            if (valExpr instanceof registry.DefaultLiteral) {\n\n                const colSchema = originSchemas.find((os) => os.identifiesAs(tableAlias)).columns().find((col) => col.identifiesAs(colName));\n                const defaultConstraint = colSchema.defaultConstraint();\n\n                if (defaultConstraint) valExpr = defaultConstraint.expr();\n            }\n\n            const colValue = await this.#exprEngine.evaluate(valExpr, logicalRecord, queryCtx);\n            newLogicalRecord[tableAlias] = { ...newLogicalRecord[tableAlias], [colName]: colValue };\n        };\n\n        for (const assignmentExpr of setClause) {\n\n            const left = assignmentExpr.left();\n            const right = assignmentExpr.right();\n\n            if (left instanceof registry.ColumnsConstructor) {\n                if (!(right instanceof registry.RowConstructor)) {\n                    throw new Error(`Expected a RHS of type ROW_CONSTRUCTOR for a LHS of type COLUMNS_CONSTRUCTOR, but got ${right.NODE_NAME}`);\n                }\n\n                for (const [i, colNode] of left.entries().entries()) {\n                    const colName = colNode.value();\n                    const correspondingRight = right.entries()[i];\n\n                    if (!correspondingRight) {\n                        throw new Error(`Mismatched number of entries in SET clause: LHS has ${left.entries().length} but RHS has ${right.entries().length}`);\n                    }\n\n                    await acquireValue(baseAlias, colName, correspondingRight);\n                }\n            } else {\n                const colName = left.value();\n                const qualif = left.qualifier?.()?.value() || baseAlias;\n\n                await acquireValue(qualif, colName, right);\n            }\n        }\n\n        return newLogicalRecord;\n    }\n\n    #acquireValue(record, colSchema, colValue, isSkipConstraints = false) {\n        const colName = colSchema.name().value();\n        record[colName] = colValue;\n        return record;\n        // TODO\n        if ((!colSchema.identityConstraint() && !colSchema.autoIncrementConstraint())\n            && ((_cons = colSchema.nullConstraint()) && _cons.value() === 'NOT')) {\n            requireds.add(colName);\n        }\n        return inputValue;\n    }\n\n    // -------- DQL\n\n    async * #evaluateTABLE_STMT(stmtNode, queryCtx) {\n        // Resolve namespace/table spec\n        const tableRef = stmtNode.tableRef();\n        const tblName = tableRef.value();\n        const nsName = tableRef.qualifier()?.value() || this.#storageEngine.defaultNamespace;\n\n        const namespaceObject = await this.#storageEngine.getNamespace(nsName);\n        const tableStorage = await namespaceObject.getTable(tblName);\n\n        // Exedute table scan\n        yield* tableStorage;\n    }\n\n    async * #evaluateSELECT_STMT(stmtNode, queryCtx) {\n        const _ = {};\n        if (!Array.isArray(_.originSchemas = stmtNode.originSchemas())) throw new Error('Expected a pre-resolved query object with originSchemas() returning an array');\n\n        // 1. FROM -> composites, WHERE\n        let stream = await this.evaluateFromClause(\n            stmtNode.fromClause(),\n            stmtNode.joinClauses(),\n            _.originSchemas,\n            queryCtx\n        );\n\n        if (_.whereClause = stmtNode.whereClause()) {\n            stream = this.evaluateWhereClause(_.whereClause, stream, queryCtx);\n        }\n\n        // 3. Grep aggr and window functions\n        const aggrFunctions = [];\n        const winFunctions = [];\n        stmtNode.walkTree((v) => {\n            if (v instanceof registry.DerivedQuery\n                || v instanceof registry.ScalarSubquery) return;\n            if (v instanceof registry.AggrCallExpr) {\n                if (v.overClause()) winFunctions.push(v);\n                else aggrFunctions.push(v);\n            } else return v;\n        });\n\n        // 4. GROUPING / aggregates\n        const groupByClause = stmtNode.groupByClause();\n        const havingClause = stmtNode.havingClause();\n        const selectList = stmtNode.selectList();\n\n        if (groupByClause?.length) {\n            const groupingElements = this.#exprEngine.resolveScopedRefsInClause(groupByClause, selectList);\n            stream = this.evaluateGroupByClause(groupingElements, havingClause, stream, queryCtx);\n        } else if (aggrFunctions.length) {\n            stream = this.evaluateGlobalGroup(stream);\n        }\n\n        // 5. WINDOWING\n        if (winFunctions.length) {\n            const windowDefs = new Map(stmtNode.windowClause()?.entries().map((w) => [w.name().value(), w.spec()]) || []);\n            stream = this.evaluateWindowing(winFunctions, windowDefs, stream, queryCtx);\n        }\n\n        // 5. ORDER BY (materialize) then LIMIT\n        const orderByClause = stmtNode.orderByClause?.(); // Not implemented by BasicSelectStmt\n        if (orderByClause) {\n            const orderElements = this.#exprEngine.resolveScopedRefsInClause(orderByClause, selectList);\n            stream = this.evaluateOrderByClause(orderElements, stream, queryCtx);\n        }\n\n        // 4. SELECT (projection) -- always works on compositeRecords\n        stream = this.evaluateSelectList(selectList, stream, queryCtx);\n\n        // 6. LIMIT + OFFSET\n        const limitClause = stmtNode.limitClause?.(); // Not implemented by BasicSelectStmt\n        const offsetClause = stmtNode.offsetClause?.(); // Not implemented by BasicSelectStmt\n        if (limitClause || offsetClause) stream = this.evaluateLimitClause(limitClause, offsetClause, stream, queryCtx);\n\n        yield* stream;\n    }\n\n    async evaluateFromClause(fromClause, joinClauses, originSchemas, queryCtx) {\n        if (!fromClause?.length) return (async function* () { yield { ...(queryCtx.lateralCtx || {}) }; })();\n        return await this.evaluateFromItems(fromClause.entries(), joinClauses, originSchemas, queryCtx);\n    }\n\n    async evaluateFromItems(fromEntries, joinClauses, originSchemas, queryCtx) {\n        // combine base from entries then join clauses in order\n        const allItems = [...fromEntries, ...(joinClauses || [])];\n        const _originSchema = (aliasName) => originSchemas.find((os) => !aliasName ? !os.name?.() : os.identifiesAs(aliasName));\n\n        // start with first item\n        const firstItem = allItems[0];\n        const firstItemAlias = firstItem.alias?.()?.value();\n\n        // Pre-resolve remote calls\n        const [nsDef, tblDef] = this.#isRemoteRef(firstItem.expr?.(), queryCtx.options);\n        let remoteStream;\n        if (tblDef) {\n            const remoteQuery = await nsDef.client.parse(tblDef.querySpec);\n            remoteStream = nsDef.client instanceof AbstractFetchClient\n                ? await nsDef.client.stream(remoteQuery)\n                : await nsDef.client.cursor(remoteQuery);\n        }\n\n        let leftStream = this.evaluateFromItem(firstItem, _originSchema(firstItemAlias), { ...queryCtx, remoteStream });\n\n        // progressively join subsequent items\n        for (let idx = 1; idx < allItems.length; idx++) {\n            const leftAlias = allItems[idx - 1].alias?.()?.value();\n\n            const rightItem = allItems[idx];\n            const rightAlias = rightItem.alias?.()?.value();\n            const rightSchema = _originSchema(rightAlias);\n\n            // Determin JOIN type and lateralness\n            const joinType = rightItem.joinType?.() || (fromEntries.includes(rightItem) ? 'CROSS' : 'INNER');\n            const isLateral = !!rightItem.lateralKW?.();\n\n            let joinCondition = rightItem.conditionClause?.();\n\n            // Derive the condition for NATURAL JOINs\n            if (!joinCondition && rightItem.naturalKW?.()) {\n                const leftSchema = _originSchema(leftAlias);\n                const lCols = leftSchema.columns?.() || leftSchema.entries();\n                const rCols = rightSchema.columns?.() || rightSchema.entries();\n                const columns = rCols.reduce((all, rc) => {\n                    if (!lCols.find((lc) => lc.identifiesAs(rc))) return all;\n                    return all.concat({ value: rc.name().value(), delim: rc._get('delim') });\n                }, []);\n                if (columns.length) {\n                    joinCondition = registry.OnClause.fromJSON(\n                        { expr: this.#usingToExpr_Transform(columns, leftAlias, rightAlias) },\n                        { assert: true }\n                    );\n                }\n            }\n\n            // Determine how right stream is resolved\n            let createRightStream;\n\n            // Pre-resolve remote calls\n            const [nsDef, tblDef] = this.#isRemoteRef(rightItem.expr?.(), queryCtx.options);\n            if (tblDef) {\n                let createRemoteStream;\n                // Resolve remote stream\n                [leftStream, createRemoteStream, joinCondition] = await this.#deriveCreateRemoteStream(\n                    leftStream,\n                    nsDef,\n                    tblDef,\n                    joinCondition,\n                    leftAlias,\n                    rightAlias,\n                    queryCtx\n                );\n                // Declare the streaming handler\n                createRightStream = async (lateralCtx, i) => {\n                    const remoteStream = await createRemoteStream(lateralCtx, i);\n                    return this.evaluateFromItem(rightItem, rightSchema, { ...queryCtx, lateralCtx: null, remoteStream });\n                };\n            } else if (isLateral) {\n                createRightStream = (lateralCtx) => this.evaluateFromItem(rightItem, rightSchema, { ...queryCtx, lateralCtx });\n            } else {\n                const rightStream = this.evaluateFromItem(rightItem, rightSchema, { ...queryCtx, lateralCtx: null });\n                createRightStream = this.#memoizeStream(rightStream);\n            }\n\n            // join\n            leftStream = this.evaluateJoin(leftStream, { alias: rightAlias, isLateral }, createRightStream, joinType, joinCondition, originSchemas, queryCtx);\n        }\n\n        return leftStream;\n    }\n\n    // ---------- begin util\n\n    async #deriveCreateRemoteStream(leftStream, nsDef, tblDef, joinCondition, leftAlias, rightAlias, queryCtx) {\n        let createRemoteStream;\n\n        const joinStrategy = tblDef.querySpec.joinStrategy || { memoization: false, pushdownSize: 0 };\n\n        if (joinCondition && joinStrategy.pushdownSize) {\n            // Normalize to Expr\n            let conditionExpr;\n            if (joinCondition instanceof registry.UsingClause) {\n                const columns = [].concat(joinCondition.column() || joinCondition.columns());\n                conditionExpr = this.#usingToExpr_Transform(columns, leftAlias, rightAlias);\n            } else {\n                conditionExpr = joinCondition.expr();\n            }\n\n            // Compile\n            const remoteQuery_Where = await nsDef.client.parse(tblDef.querySpec, {\n                alias: rightAlias,\n                dynamicWhereMode: true,\n            });\n\n            if (Number(joinStrategy.pushdownSize) > 1) {\n                const pushdownSize = joinStrategy.pushdownSize;\n\n                // Tee the stream\n                let memo = this.#memoizeStream(leftStream);;\n                const masterLeftStream = memo(); // Must be #1\n                leftStream = memo(); // Must be #2\n\n                let $i = 0;\n                const concatWhere = async () => {\n                    let $pushDownLogic;\n                    let someTruthy = false;\n                    for await (const leftComp of masterLeftStream) {\n                        $i++;\n                        const pushDownLogic = await this.#exprEngine.evaluate(conditionExpr, { ...leftComp, [rightAlias]: TBL_PLACEHOLDER }, queryCtx);\n                        // Concat logic\n                        if (pushDownLogic instanceof AbstractNode) {\n                            $pushDownLogic = $pushDownLogic\n                                ? registry.BinaryExpr.fromJSON(\n                                    { nodeName: registry.BinaryExpr.NODE_NAME, left: $pushDownLogic, operator: 'OR', right: pushDownLogic },\n                                    { assert: true }\n                                )\n                                : pushDownLogic;\n                        } else if (pushDownLogic) {\n                            someTruthy = true;\n                        }\n                        if ($i > 1 && $i % pushdownSize === 0) {\n                            break;\n                        }\n                    }\n                    if (!$pushDownLogic && !someTruthy) return;\n                    return remoteQuery_Where($pushDownLogic);\n                };\n\n                // Initialize process\n                let remoteQuery = await concatWhere();\n                let remoteStream;\n\n                // Stream with at pushdownSize chunks\n                createRemoteStream = async (_, i) => {\n                    if (i === 0 || i > $i) {\n                        if (i > $i) remoteQuery = await concatWhere(); // lazily\n                        if (remoteQuery) {\n                            remoteStream = nsDef.client instanceof AbstractFetchClient\n                                ? await nsDef.client.stream(remoteQuery)\n                                : await nsDef.client.cursor(remoteQuery);\n                        } else remoteStream = (async function* () { })();\n                    }\n                    return remoteStream;\n                };\n            } else {\n                // Fixed WHERE structure\n                createRemoteStream = async (lateralCtx) => {\n                    let pushDownLogic = await this.#exprEngine.evaluate(conditionExpr, { ...lateralCtx, [rightAlias]: TBL_PLACEHOLDER }, queryCtx);\n                    if (pushDownLogic instanceof AbstractNode || (pushDownLogic = Boolean(pushDownLogic))) {\n                        const remoteQuery = remoteQuery_Where(pushDownLogic);\n                        return nsDef.client instanceof AbstractFetchClient\n                            ? await nsDef.client.stream(remoteQuery)\n                            : await nsDef.client.cursor(remoteQuery);\n                    }\n                    return (async function* () { })();\n                };\n                // Can be safely ommited as having been pushed down\n                joinCondition = null;\n            }\n        } else {\n            // No WHERE at all\n            const remoteQuery = await nsDef.client.parse(tblDef.querySpec);\n            if (joinStrategy.memoization) {\n                const remoteStream = nsDef.client instanceof AbstractFetchClient\n                    ? await nsDef.client.stream(remoteQuery)\n                    : await nsDef.client.cursor(remoteQuery);\n                createRemoteStream = this.#memoizeStream(remoteStream);\n            } else {\n                createRemoteStream = async () => nsDef.client instanceof AbstractFetchClient\n                    ? await nsDef.client.stream(remoteQuery)\n                    : await nsDef.client.cursor(remoteQuery);\n            }\n        }\n\n        return [leftStream, createRemoteStream, joinCondition];\n    }\n\n    #isRemoteRef(fromItemExpr, options) {\n        if (!(fromItemExpr instanceof registry.TableRef1)\n            || fromItemExpr.resolution() !== 'default') return [];\n        if (!options.effectiveMirrorsSpec) return [];\n\n        const nsName = fromItemExpr.qualifier()?.value() || this.#storageEngine.defaultNamespace;\n        const tblName = fromItemExpr.value();\n\n        const nsDef = options.effectiveMirrorsSpec.get(nsName);\n        const tblDef = nsDef?.tables.get(tblName);\n\n        return [nsDef, tblDef];\n    }\n\n    #memoizeStream(stream, callback = null) {\n        const buffer = [];\n        return async function* () {\n            if (buffer.length) {\n                yield* buffer;\n            } else for await (let q of stream) {\n                if (callback) {\n                    q = callback(q);\n                }\n                buffer.push(q);\n                yield q;\n            }\n        };\n    }\n\n    #usingToExpr_Transform(columns, leftAlias, rightAlias) {\n        return columns.reduce((acc, ident) => {\n            const identJson = ident.jsonfy?.() || ident;\n            const left = { ...identJson, nodeName: registry.ColumnRef1.NODE_NAME, qualifier: { nodeName: registry.TableRef1.NODE_NAME, value: leftAlias } };\n            const right = { ...identJson, nodeName: registry.ColumnRef1.NODE_NAME, qualifier: { nodeName: registry.TableRef1.NODE_NAME, value: rightAlias } };\n            let logicalExpr = registry.BinaryExpr.fromJSON({ left, operator: '=', right });\n\n            if (acc) logicalExpr = registry.BinaryExpr.fromJSON({ left: acc, operator: 'AND', right: logicalExpr });\n            return logicalExpr;\n        }, null);\n    }\n\n    // ---------- end util\n\n    async * evaluateFromItem(fromItem, originSchema, queryCtx) {\n\n        // ---------- a. TableAbstraction2 | TableAbstraction1\n\n        if (fromItem instanceof registry.TableAbstraction2\n            || fromItem instanceof registry.TableAbstraction1) {\n            const tableRef = fromItem.tableRef();\n            const tableAlias = fromItem.alias();\n\n            // Part2 resolution: table scan\n            const tblName = tableRef.value();\n            const aliasName = tableAlias?.value() || tblName;\n\n            const nsName = tableRef.qualifier()?.value() || this.#storageEngine.defaultNamespace;\n\n            const namespaceObject = await this.#storageEngine.getNamespace(nsName);\n            const tableStorage = await namespaceObject.getTable(tblName);\n\n            for await (let row of tableStorage) {\n                yield { [aliasName]: row };\n            }\n\n            return;\n        }\n\n        // ---------- b. FromItem\n\n        const fromItemExpr = fromItem.expr();\n        const aliasName = fromItem.alias()?.value() || '';\n        const expectedColWidth = originSchema.length;\n\n        // ---------- DerivedQuery?\n        if (fromItemExpr instanceof registry.DerivedQuery) {\n            for await (const row of await this.#evaluateSTMT(fromItemExpr.expr(), queryCtx)) {\n                const entries = Object.entries(row);\n                const actualColWidth = entries.length;\n                if (actualColWidth !== expectedColWidth) {\n                    throw new Error(`Expected number of columns from DerivedQuery function to be ${expectedColWidth} but got ${actualColWidth}`);\n                }\n                const _row = Object.create(null);\n                for (const [key, value] of entries) {\n                    this.#acquireValue(_row, originSchema._get('entries', key), value);\n                }\n                yield { [aliasName]: _row };\n            }\n            return;\n        }\n\n        // ---------- ValuesTableLiteral?\n        if (fromItemExpr instanceof registry.ValuesTableLiteral) {\n            for (const rowConstructor of fromItemExpr.entries()) {\n                const actualColWidth = rowConstructor.length;\n                if (actualColWidth !== expectedColWidth) {\n                    throw new Error(`Expected number of columns in ROW_CONSTRUCTOR to be ${expectedColWidth} but got ${actualColWidth}`);\n                }\n                const row = Object.create(null);\n                for (const [i, valExpr] of rowConstructor.entries().entries()) {\n                    this.#acquireValue(row, originSchema.entries()[i], await this.#exprEngine.evaluate(valExpr, queryCtx.lateralCtx, queryCtx));\n                }\n                yield { [aliasName]: row };\n            }\n            return;\n        }\n\n        const createSRFGenerator = async (callExpr) => {\n            const funcResult = await this.#exprEngine.evaluate(callExpr, queryCtx.lateralCtx, queryCtx);\n            let asyncIter;\n            if (Symbol.asyncIterator in funcResult) {\n                asyncIter = funcResult[Symbol.asyncIterator]();\n            } else if (Symbol.iterator in funcResult) {\n                asyncIter = (async function* () { yield* funcResult; })();\n            } else throw new Error(`Function ${callExpr.name()} did not return an iterable value or a promise of such thereof.`);\n            return asyncIter;\n        };\n\n        const createSRFGenerator2 = async (callExpr, columnDefs) => {\n            const asyncIter = await createSRFGenerator(callExpr);\n            return asyncIter;\n        };\n\n        // ---------- SRFExpr1?\n        if (fromItemExpr instanceof registry.SRFExpr1) {\n            const callExpr = fromItemExpr.callExpr();\n            const qualif = fromItemExpr.qualif(); // SRFExprDDL1 | SRFExprDDL2\n            const aliasName = qualif.alias/* if SRFExprDDL2 */?.()?.value() || '';\n            // Consume callExpr as async iterator\n            for await (const row of await createSRFGenerator2(callExpr, qualif.columnDefs())) {\n                if (!Array.isArray(row) && !(row && typeof row === 'object')) {\n                    throw new Error(`Function ${callExpr.name()} did not return an object or array value or a promise of such thereof.`);\n                }\n                const values = Object.values(row);\n                const actualColWidth = values.length;\n                if (actualColWidth !== expectedColWidth) {\n                    throw new Error(`Expected number of columns from SRF function to be ${expectedColWidth} but got ${actualColWidth}`);\n                }\n                const _row = Object.create(null);\n                for (let i = 0; i < actualColWidth; i++) {\n                    this.#acquireValue(_row, originSchema.entries()[i], values[i]);\n                }\n                yield { [aliasName]: _row };\n            }\n            return;\n        }\n\n        // ---------- SRFExpr2?\n        if (fromItemExpr instanceof registry.SRFExpr2) {\n            const callExpr = fromItemExpr.callExpr();\n            const withOrdinality = fromItemExpr.withOrdinality(); // Boolean\n            // Consume callExpr as async iterator\n            let rowIdx = 0;\n            for await (const row of await createSRFGenerator(callExpr)) {\n                if (!Array.isArray(row) && !(row && typeof row === 'object')) {\n                    throw new Error(`Function ${callExpr.name()} did not return an object or array value or a promise of such thereof.`);\n                }\n                const values = Object.values(row);\n                if (withOrdinality) values.push(++rowIdx);\n                const actualColWidth = values.length;\n                if (actualColWidth !== expectedColWidth) {\n                    throw new Error(`Expected number of columns from SRF function to be ${expectedColWidth} but got ${actualColWidth}`);\n                }\n                const _row = Object.create(null);\n                for (let i = 0; i < actualColWidth; i++) {\n                    this.#acquireValue(_row, originSchema.entries()[i], values[i]);\n                }\n                yield { [aliasName]: _row };\n            }\n            return;\n        }\n\n        // ---------- SRFExpr4?\n        if (fromItemExpr instanceof registry.SRFExpr4) {\n            const withOrdinality = fromItemExpr.withOrdinality(); // Boolean\n            const asyncIters = [];\n            // Initialize all SRF generators\n            for (const entry of fromItemExpr.entries()) {\n                if (!(entry instanceof registry.SRFExpr3)) {\n                    throw new Error(`Expected SRFExpr3 but got ${entry?.NODE_NAME}`);\n                }\n                const callExpr = entry.callExpr();\n                const qualif = entry.qualif(); // SRFExprDDL1\n                const stream = await createSRFGenerator2(callExpr, qualif?.columnDefs());\n                asyncIters.push({ stream, callExpr });\n            }\n            // Zipped iteration\n            let rowIdx = 0,\n                colWidths = {};\n            while (true) {\n                let colIdx = 0,\n                    allDone = true;\n                const row = Object.create(null);\n                for (let i = 0; i < asyncIters.length; i++) {\n                    const { stream, callExpr } = asyncIters[i];\n                    const r = await stream.next();\n                    if (!r.done) {\n                        allDone = false;\n                        const _row = r.value;\n                        if (!Array.isArray(_row) && !(_row && typeof _row === 'object')) {\n                            throw new Error(`Function ${callExpr.name()} did not return an object or array value or a promise of such thereof.`);\n                        }\n                        const values = Object.values(_row);\n                        // Determine/validate column width\n                        if (!colWidths[i]) {\n                            colWidths[i] = values.length;\n                            if (colWidths[i] + colIdx + (withOrdinality ? 1 : 0) > expectedColWidth) {\n                                throw new Error(`Number of columns from SRF function(s) (${colWidths[i] + colIdx + (withOrdinality ? 1 : 0)}) exceeds expected: expected ${expectedColWidth}`);\n                            }\n                        } else if (colWidths[i] !== values.length) {\n                            throw new Error(`Inconsistent number of columns from SRF function: expected ${colWidths[i]} but got ${values.length}`);\n                        }\n                        // Render values into row\n                        for (const value of values) {\n                            this.#acquireValue(row, originSchema.entries()[colIdx], value);\n                            colIdx++;\n                        }\n                    } else {\n                        // Fill with nulls for this SRF\n                        for (let j = 0; j < (colWidths[i] || 1); j++) {\n                            this.#acquireValue(row, originSchema.entries()[colIdx], null, true);\n                            colIdx++;\n                        }\n                    }\n                }\n                if (allDone) break;\n                // Handle ordinality\n                if (withOrdinality) {\n                    this.#acquireValue(row, originSchema.entries()[colIdx], rowIdx + 1);\n                    colIdx++;\n                }\n                // Yield\n                yield { [aliasName]: row };\n                rowIdx++;\n            }\n            return;\n        }\n\n        // ---------- TableRef1 | TableRef2\n        const tblName = fromItemExpr.value();\n\n        // CTERef?\n        let stream;\n        if (queryCtx.remoteStream) {\n            stream = queryCtx.remoteStream;\n        } else if (fromItemExpr.resolution() === 'cte') {\n            stream = queryCtx.cteRegistry?.get(tblName);\n            if (!stream) throw new Error(`Implied CTE ${tblName} does not exist in the current context`);\n            if (typeof stream[Symbol.asyncIterator] !== 'function') throw new Error(`Implied CTE ${tblName} does not return a record set`);\n        } else {\n            const nsName = fromItemExpr.qualifier()?.value() || this.#storageEngine.defaultNamespace;\n            const namespaceObject = await this.#storageEngine.getNamespace(nsName);\n            const tableStorage = await namespaceObject.getTable(tblName);\n            // Whole tableStorage is stream\n            stream = tableStorage;\n        }\n\n        // Consume stream\n        for await (const row of stream) {\n            const entries = Object.entries(row);\n            const actualColWidth = entries.length;\n\n            if (actualColWidth !== expectedColWidth) {\n                throw new Error(`Expected number of columns from ${aliasName} to be ${expectedColWidth} but got ${actualColWidth}`);\n            }\n\n            const _row = Object.create(null);\n            for (const [key, value] of entries) {\n                this.#acquireValue(_row, originSchema._get('entries', key), value);\n            }\n\n            yield { ...(queryCtx.lateralCtx || {}), [aliasName]: _row };\n        }\n    }\n\n    async * evaluateJoin(leftStream, { alias: rightAlias, isLateral }, createRightStream, joinType, joinCondition, originSchemas, queryCtx) {\n        const _originSchema = (aliasName) => originSchemas.find((os) => os.identifiesAs(aliasName));\n        // Composition helpers\n        const nullFill = (baseComp, aliases) => {\n            for (const alias of aliases) {\n                if (baseComp[alias]) continue;\n                const originSchema = _originSchema(alias);\n                const columns = originSchema.columns?.() || originSchema.entries();\n                baseComp[alias] = Object.fromEntries(columns.map((col) => [col.name().value(), null]));\n            }\n            return baseComp;\n        };\n\n        const leftAliasSet = new Set;\n        const rightMatches = new Map;\n\n        // The JOIN\n        let i = 0;\n        for await (const leftComp of leftStream) {\n            for (const k of Object.keys(leftComp)) leftAliasSet.add(k);\n\n            let leftMatched = false;\n            for await (const rightComp of await createRightStream(leftComp, i)) {\n                const fullMergedComp = { ...leftComp, ...rightComp };\n\n                const rightRef = () => _rightRef || (_rightRef = isLateral ? JSON.stringify(rightComp) : rightComp);\n                let _rightRef;\n\n                if (!joinCondition/* Also: CROSS JOIN */\n                    || await this.#exprEngine.evaluate(joinCondition, fullMergedComp, queryCtx)) {\n                    leftMatched = true;\n                    rightMatches.set(rightRef(), true);\n                    yield fullMergedComp;\n                } else if ((joinType === 'RIGHT' || joinType === 'FULL') && !rightMatches.has(rightRef())) {\n                    rightMatches.set(rightRef(), false);\n                }\n            }\n\n            if (!leftMatched && (joinType === 'LEFT' || joinType === 'FULL')) {\n                yield nullFill({ ...leftComp }, [rightAlias]);\n            }\n            i++;\n        }\n\n        if (joinType === 'RIGHT' || joinType === 'FULL') {\n            for (let [rightComp, matched] of rightMatches.entries()) {\n                if (matched) continue;\n                if (typeof rightComp === 'string') rightComp = JSON.parse(rightComp);\n                yield nullFill({ ...rightComp }, [...leftAliasSet]);\n            }\n        }\n    }\n\n    async * evaluateWhereClause(whereClause, upstream, queryCtx) {\n        for await (const comp of upstream) {\n            if (await this.#exprEngine.evaluate(whereClause.expr(), comp, queryCtx)) yield comp;\n        }\n    }\n\n    async * evaluateGroupByClause(groupingElements, havingClause, upstream, queryCtx) {\n\n        // -----------Utils:\n\n        function flattenRowConstructor(expr) {\n            if (expr instanceof registry.RowConstructor) {\n                // Flatten each entry recursively\n                return expr.entries().flatMap(flattenRowConstructor);\n            }\n            return [expr];\n        }\n\n        function expandElement(elem) {\n            if (elem.groupingSets()) return elem.groupingSets().flatMap(expandElement);\n            if (elem.rollupSet()) {\n                const entries = elem.rollupSet().entries();\n                const sets = [];\n                for (let i = entries.length; i >= 0; i--) sets.push(entries.slice(0, i).flatMap(flattenRowConstructor));\n                return sets;\n            }\n\n            if (elem.cubeSet()) {\n                const entries = elem.cubeSet().entries();\n                const n = entries.length;\n                const sets = [];\n                for (let mask = 0; mask < (1 << n); mask++) {\n                    const subset = [];\n                    for (let j = 0; j < n; j++) if (mask & (1 << j)) subset.push(entries[j]);\n                    sets.push(subset.flatMap(flattenRowConstructor));\n                }\n                return sets;\n            }\n\n            if (elem.expr()) return [flattenRowConstructor(elem.expr())];\n            return [[]]; // fallback\n        }\n        function getAtomicExprs(elem) {\n            if (elem.groupingSets()) return elem.groupingSets().flatMap(getAtomicExprs);\n            if (elem.rollupSet()) return [...elem.rollupSet().entries()];\n            if (elem.cubeSet()) return [...elem.cubeSet().entries()];\n            if (elem.expr()) {\n                const e = elem.expr();\n                return e instanceof registry.RowConstructor ? e.entries() : [e];\n            }\n            return [];\n        }\n\n        // ------------ Processing:\n\n        let groupingSets;\n        if (groupingElements.every(e => e.expr() && !e.rollupSet() && !e.cubeSet() && !e.groupingSets())) {\n            // plain multi-column GROUP BY\n            groupingSets = [groupingElements.flatMap(e => expandElement(e)[0])];\n        } else {\n            // includes GROUPING SETS / ROLLUP / CUBE\n            groupingSets = groupingElements.flatMap(expandElement);\n        }\n\n        // Build mapping ExprNode \u2192 top-level index\n        const topEntryAtomicMap = new Map();\n        for (let j = 0; j < groupingElements.length; j++) {\n            const atomic = getAtomicExprs(groupingElements[j]);\n            topEntryAtomicMap.set(j, atomic);\n        }\n\n        const groups = new Map();\n        for await (const comp of upstream) {\n            for (let setIndex = 0; setIndex < groupingSets.length; setIndex++) {\n                const set = groupingSets[setIndex];\n\n                const keyVals = set.length\n                    ? await Promise.all(set.map((expr) => this.#exprEngine.evaluate(expr, comp, queryCtx)))\n                    : [];\n\n                // Compute mask for GROUPING_ID\n                let mask = 0;\n                for (let j = 0; j < groupingElements.length; j++) {\n                    const atomic = topEntryAtomicMap.get(j) || [];\n                    if (atomic.length === 0) {\n                        mask |= (1 << j);\n                        continue;\n                    }\n                    let allPresent = atomic.every((aExpr) => set.includes(aExpr));\n                    if (!allPresent) mask |= (1 << j);\n                }\n\n                const key = JSON.stringify([setIndex, keyVals]);\n                if (!groups.has(key)) {\n                    groups.set(key, { window: [], mask, setIndex, keyVals, set });\n                }\n                groups.get(key).window.push(comp);\n            }\n        }\n\n        // Yield representative rows\n        for (const { window, mask, setIndex, keyVals, set } of groups.values()) {\n            const rep = {};\n\n            // Build lightweight groupingColumnsMap: Map<alias, Set<colName>>\n            const groupingColumnsMap = new Map();\n            const _add = (colRef) => {\n                const alias = colRef.qualifier()?.value() || '';\n                const set = groupingColumnsMap.get(alias) ?? new Set();\n                set.add(colRef.value());\n                groupingColumnsMap.set(alias, set);\n            };\n            // Scan set and build groupingColumnsMap\n            for (const expr of set) {\n                if (expr instanceof registry.ColumnRef1) _add(expr); else {\n                    expr.walkTree((child) => {\n                        if (child instanceof registry.ColumnRef1) _add(child);\n                        return child;\n                    });\n                }\n            }\n\n            // Build exprToTopIndex per grouping set for GROUPING_ID evaluation\n            const exprToTopIndex = new Map();\n            for (let j = 0; j < groupingElements.length; j++) {\n                const atomic = topEntryAtomicMap.get(j) || [];\n                for (const exprNode of atomic) exprToTopIndex.set(exprNode, j);\n            }\n\n            // Column-level nulling\n            for (const alias of Object.keys(window[0])) {\n                const tableRow = { ...window[0][alias] };\n                for (const colName of Object.keys(tableRow)) {\n                    const isGrouped = groupingColumnsMap.get(alias)?.has(colName);\n                    if (!isGrouped) tableRow[colName] = null;\n                }\n                rep[alias] = tableRow;\n            }\n\n            // Metadata\n            rep[GROUPING_META] = {\n                window: window,\n                frameStart: 0,\n                frameEnd: window.length - 1,\n                groupValues: keyVals,\n                groupingId: mask,\n                setIndex,\n                exprIndex: exprToTopIndex,\n                isGrandTotal: set.length === 0,\n                groupingColumnsMap\n            };\n\n            // Apply HAVING\n            if (havingClause) {\n                const keep = await this.#exprEngine.evaluate(havingClause.expr(), rep, queryCtx);\n                if (!keep) continue;\n            }\n\n            yield rep;\n        }\n    }\n\n    async * evaluateGlobalGroup(upstream) {\n        const window = [];\n        for await (const comp of upstream) window.push(comp);\n        // representative: first member or empty composite\n        const rep = window[0] ? { ...window[0] } : {};\n\n        // attach grouping metadata\n        rep[GROUPING_META] = {\n            window: window,\n            frameStart: 0,\n            frameEnd: window.length - 1,\n            groupValues: [],\n            groupingId: 0,\n            setIndex: 0,\n            exprIndex: new Map()\n        };\n\n        yield rep;\n    }\n\n    async * evaluateWindowing(winFunctions, windowDefs, upstream, queryCtx) {\n        const rows = Array.isArray(upstream) ? upstream : [];\n        if (!Array.isArray(upstream)) for await (const r of upstream) rows.push(r);\n        // Group window functions by their resolved 'effective spec'\n        const winFnMap = new Map(); // winHash -> { winFn, effectiveSpec }\n\n        for (const winFn of winFunctions) {\n            const over = winFn.overClause();\n\n            let effectiveSpec;\n            if (over instanceof registry.WindowRef) {\n                const namedSpec = windowDefs.get(over.value());\n                if (!namedSpec) throw new Error(`[${winFn}] Window '${over.value()}' not found`);\n                effectiveSpec = {\n                    partitionBy: namedSpec.partitionByClause(),\n                    orderBy: namedSpec.orderByClause(),\n                    frameSpec: namedSpec.frameSpec(),\n                };\n            } else if (over instanceof registry.WindowSpec) {\n                const baseSpec = over.superWindow() ? windowDefs.get(over.superWindow().value()) : null;\n                effectiveSpec = {\n                    partitionBy: over.partitionByClause() ?? baseSpec?.partitionByClause(),\n                    orderBy: over.orderByClause() ?? baseSpec?.orderByClause(),\n                    frameSpec: over.frameSpec() ?? baseSpec?.frameSpec(),\n                };\n            }\n\n            const winHash = JSON.stringify(effectiveSpec); // simple stable hash\n            if (!winFnMap.has(winHash)) winFnMap.set(winHash, effectiveSpec);\n            winFn.winHash = winHash;\n        }\n\n        // Partition rows per window function\n        for (const [winHash, effectiveSpec] of winFnMap.entries()) {\n            // Partition rows by PARTITION BY expression(s)\n            const partitions = new Map(); // key -> rows[]\n\n            const rowsAreReps = !!rows[0]?.[GROUPING_META];\n            const rowToRepMap = new WeakMap;\n            for (let row of rows) {\n                const originalRep = row;\n                let originalRow = row;\n                if (rowsAreReps) {\n                    // Rep rows may have nulled columns \n                    // we fall back origianl rep row\n                    originalRow = { ...row[GROUPING_META].window[0] };\n                    rowToRepMap.set(originalRow, originalRep);\n                }\n                const keyVals = await Promise.all(effectiveSpec.partitionBy?.map((expr) => this.#exprEngine(expr, originalRow, queryCtx)) ?? []);\n                const key = JSON.stringify(keyVals);\n                if (!partitions.has(key)) {\n                    const window = [];\n                    partitions.set(key, window);\n                }\n                partitions.get(key).push(originalRow);\n            }\n\n            // Populate WINDOW_META for each row\n            for (let window of partitions.values()) {\n\n                // Apply ORDER BY if present\n                if (effectiveSpec.orderBy) {\n                    const ordered = this.evaluateOrderByClause(effectiveSpec.orderBy.entries(), window, queryCtx, true);\n                    const orderedArray = [];\n                    for await (const decorated of ordered) orderedArray.push(decorated);\n                    window = orderedArray;\n                }\n\n                // Attach meta\n                let i = 0;\n                const isDecorated = !!effectiveSpec.orderBy;\n                for (const entry of window) {\n                    const { row, keys } = isDecorated ? entry : { row: entry, keys: [i] };\n                    const originalRep = rowsAreReps ? rowToRepMap.get(row) : row;\n\n                    // Compute frame start/end for this row\n                    const {\n                        frameStart,\n                        frameEnd\n                    } = this.#computeFrameBounds(effectiveSpec, window, i, isDecorated);\n\n                    if (!originalRep[WINDOW_META]) originalRep[WINDOW_META] = {};\n                    originalRep[WINDOW_META][winHash] = {\n                        window: isDecorated ? window.map((d) => d.row) : window,\n                        orderKeysHash: JSON.stringify(keys),\n                        orderKeys: keys,\n                        offset: i++,\n                        frameStart,\n                        frameEnd,\n                    };\n                }\n            }\n        }\n\n        yield* rows;\n    }\n\n    #computeFrameBounds(effectiveSpec, window, rowIndex, isDecorated = false) {\n        const frameSpec = effectiveSpec.frameSpec;\n        const total = window.length;\n\n        // Default frame = full partition\n        if (!frameSpec) {\n            return { frameStart: 0, frameEnd: total - 1 };\n        }\n\n        const specifier = frameSpec.specifier();\n        const [start, end] = frameSpec.bounds() ?? [];\n\n        let frameStart = 0;\n        let frameEnd = total - 1;\n\n        // helper to clamp safely\n        const clamp = (n) => Math.min(Math.max(n, 0), total - 1);\n\n        // ----- ROWS -----\n        if (specifier === 'ROWS') {\n            // --- Start ---\n            if (!start || start.specifier() === 'CURRENT ROW') {\n                frameStart = rowIndex;\n            } else if (start.specifier() === 'UNBOUNDED' && start.dir() === 'PRECEDING') {\n                frameStart = 0;\n            } else if (start.specifier() instanceof registry.NumberLiteral) {\n                const n = start.specifier().value();\n                frameStart = clamp(\n                    start.dir() === 'PRECEDING' ? rowIndex - n : rowIndex + n\n                );\n            }\n\n            // --- End ---\n            if (!end || end.specifier() === 'CURRENT ROW') {\n                frameEnd = rowIndex;\n            } else if (end.specifier() === 'UNBOUNDED' && end.dir() === 'FOLLOWING') {\n                frameEnd = total - 1;\n            } else if (end.specifier() instanceof registry.NumberLiteral) {\n                const n = end.specifier().value();\n                frameEnd = clamp(\n                    end.dir() === 'FOLLOWING' ? rowIndex + n : rowIndex - n\n                );\n            }\n        }\n\n        // ----- RANGE -----\n        else if (specifier === 'RANGE') {\n            if (!effectiveSpec.orderBy) {\n                return { frameStart: 0, frameEnd: total - 1 };\n            }\n\n            const getKeys = (entry) => isDecorated ? entry.keys : [rowIndex];\n            const myKeys = getKeys(window[rowIndex]);\n            const myValue = myKeys[0]; // leading ORDER BY key\n\n            const getValue = (entry) => isDecorated ? entry.keys[0] : rowIndex;\n\n            // Peer range by default\n            let peerStart = rowIndex;\n            while (peerStart > 0 && getValue(window[peerStart - 1]) === myValue) peerStart--;\n            let peerEnd = rowIndex;\n            while (peerEnd < total - 1 && getValue(window[peerEnd + 1]) === myValue) peerEnd++;\n\n            frameStart = peerStart;\n            frameEnd = peerEnd;\n\n            const adjustBound = (bound, isStart) => {\n                if (!bound) return;\n\n                if (bound.specifier() === 'UNBOUNDED' && bound.dir() === 'PRECEDING') {\n                    frameStart = 0;\n                } else if (bound.specifier() === 'UNBOUNDED' && bound.dir() === 'FOLLOWING') {\n                    frameEnd = total - 1;\n                } else if (bound.specifier() === 'CURRENT ROW') {\n                    if (isStart) frameStart = peerStart;\n                    else frameEnd = peerEnd;\n                } else if (bound.specifier() instanceof registry.NumberLiteral) {\n                    // numeric RANGE offset\n                    const n = bound.specifier().value();\n                    const ref = myValue + (bound.dir() === 'FOLLOWING' ? n : -n);\n                    if (isStart) {\n                        let idx = 0;\n                        while (idx < total && getValue(window[idx]) < ref) idx++;\n                        frameStart = idx;\n                    } else {\n                        let idx = total - 1;\n                        while (idx >= 0 && getValue(window[idx]) > ref) idx--;\n                        frameEnd = idx;\n                    }\n                } else if (bound.specifier() instanceof registry.TypedIntervalLiteral) {\n                    const refTime = new Date(myValue).getTime();\n                    const shifted = bound.specifier().applyToDate(new Date(refTime), bound.dir());\n\n                    if (isStart) {\n                        let idx = 0;\n                        while (idx < total && new Date(getValue(window[idx])).getTime() < shifted) idx++;\n                        frameStart = idx;\n                    } else {\n                        let idx = total - 1;\n                        while (idx >= 0 && new Date(getValue(window[idx])).getTime() > shifted) idx--;\n                        frameEnd = idx;\n                    }\n                }\n            };\n\n            adjustBound(start, true);\n            adjustBound(end, false);\n        }\n\n        // ----- GROUPS -----\n        else if (specifier === 'GROUPS') {\n            if (!effectiveSpec.orderBy) {\n                // no ORDER BY \u2192 one peer group (all rows)\n                return { frameStart: 0, frameEnd: total - 1 };\n            }\n\n            const getHash = (entry) => {\n                return isDecorated\n                    ? JSON.stringify(entry.keys)\n                    : JSON.stringify([rowIndex]);\n            };\n\n            // Build groups of peer rows by orderKeys\n            const groups = [];\n            let currentGroup = [0];\n            let lastHash = getHash(window[0]);\n\n            for (let i = 1; i < total; i++) {\n                const h = getHash(window[i]);\n                if (h === lastHash) {\n                    currentGroup.push(i);\n                } else {\n                    groups.push(currentGroup);\n                    currentGroup = [i];\n                    lastHash = h;\n                }\n            }\n            groups.push(currentGroup);\n\n            // Find current row's group index\n            const groupIndex = groups.findIndex((g) => g.includes(rowIndex));\n\n            let startGroup = groupIndex;\n            let endGroup = groupIndex;\n\n            if (start) {\n                if (start.specifier() === 'UNBOUNDED' && start.dir() === 'PRECEDING') {\n                    startGroup = 0;\n                } else if (start.specifier() === 'CURRENT ROW') {\n                    startGroup = groupIndex;\n                } else if (start.specifier() instanceof registry.NumberLiteral) {\n                    const n = start.specifier().value();\n                    startGroup = clamp(groupIndex - n);\n                }\n            }\n\n            if (end) {\n                if (end.specifier() === 'UNBOUNDED' && end.dir() === 'FOLLOWING') {\n                    endGroup = groups.length - 1;\n                } else if (end.specifier() === 'CURRENT ROW') {\n                    endGroup = groupIndex;\n                } else if (end.specifier() instanceof registry.NumberLiteral) {\n                    const n = end.specifier().value();\n                    endGroup = clamp(groupIndex + n);\n                }\n            }\n\n            frameStart = groups[startGroup][0];\n            frameEnd = groups[endGroup][groups[endGroup].length - 1];\n        }\n\n        return { frameStart, frameEnd };\n    }\n\n    async * evaluateSelectList(selectList, upstream, queryCtx) {\n        for await (const comp of upstream) {\n            const projected = Object.create(null);\n            let fieldIdx = 1;\n            for (const selectItem of selectList) {\n                let { alias, value } = await this.#exprEngine.evaluate(selectItem, comp, queryCtx);\n                if (projected[alias] && queryCtx.depth) alias += fieldIdx;\n                projected[alias] = value;\n                fieldIdx++;\n            }\n            yield projected;\n        }\n    }\n\n    async * evaluateOrderByClause(orderElements, upstream, queryCtx, withKeys = false) {\n        const rows = Array.isArray(upstream) ? upstream : [];\n        if (!Array.isArray(upstream)) for await (const r of upstream) rows.push(r);\n        // Precompute keys\n        const decorated = await Promise.all(rows.map(async (row) => {\n            const keys = await Promise.all(orderElements.map(orderElement =>\n                this.#exprEngine.evaluate(orderElement.expr(), row, queryCtx)\n            ));\n            return { row, keys };\n        }));\n        // Sort synchronously\n        this.#exprEngine.applySorting(decorated, orderElements, queryCtx);\n        // Extract rows back\n        for (const d of decorated) {\n            if (withKeys) yield d;\n            else yield d.row;\n        }\n    }\n\n    async * evaluateLimitClause(limitClause, offsetClause, upstream, queryCtx) {\n        const limit = limitClause ? await this.#exprEngine.evaluate(limitClause.expr(), {}, queryCtx) : 0;\n        const offset = offsetClause ? await this.#exprEngine.evaluate(offsetClause.expr(), {}, queryCtx) : (\n            limitClause.myOffset() ? await this.#exprEngine.evaluate(limitClause.myOffset(), {}, queryCtx) : 0\n        );\n        let idx = 0, yielded = 0;\n        for await (const r of upstream) {\n            if (idx++ < offset) continue;\n            if (limit && yielded++ >= limit) break;\n            yield r;\n        }\n    }\n\n    // -------- Composite select (UNION / INTERSECT / EXCEPT) support\n\n    async * #evaluateCOMPOSITE_SELECT_STMT(stmtNode, queryCtx) {\n\n        const self = this;\n        async function* evaluateOperand(operand) {\n            if (operand instanceof registry.SelectStmt) {\n                yield* await self.#evaluateSTMT(operand, { ...queryCtx, depth: queryCtx.depth + 1 });\n                return;\n            }\n            if (operand instanceof registry.TableStmt) {\n                yield* self.#evaluateTABLE_STMT(operand, { ...queryCtx, depth: queryCtx.depth + 1 });\n                return;\n            }\n            const resultSchema = operand.resultSchema();\n            let operandJson = operand.jsonfy();\n            if (operand instanceof registry.ValuesConstructor) {\n                operandJson = { ...operandJson, nodeName: 'VALUES_TABLE_LITERAL' };\n            }\n            const fromItem = registry.FromItem.fromJSON({ nodeName: 'FROM_ITEM', expr: operandJson }, { dialect: self.#options.dialect, assert: true });\n            stmtNode._adoptNodes(fromItem);\n            const result = self.evaluateFromItem(fromItem, resultSchema, queryCtx);\n            for await (const r of result) yield r[''];\n        };\n\n        const leftStream = await evaluateOperand(stmtNode.left());\n        const rightStream = await evaluateOperand(stmtNode.right());\n\n        // Normalize\n\n        const leftRows = [];\n        const rightRows = [];\n        for await (const r of leftStream) leftRows.push(r);\n        for await (const r of rightStream) rightRows.push(r);\n\n        const leftOutputCols = stmtNode.left().resultSchema?.().entries() || [];\n        const rightOutputCols = stmtNode.right().resultSchema?.().entries() || [];\n        if (leftOutputCols.length !== rightOutputCols.length) {\n            throw new Error(`Set operation column mismatch: left has ${leftOutputCols.length} columns, right has ${rightOutputCols.length}`);\n        }\n\n        const mappers = leftOutputCols.map((leftCol, i) => {\n            const rightCol = rightOutputCols[i];\n            const leftType = leftCol.dataType().value();\n            const rightType = rightCol.dataType().value();\n            const coercedType = this.#resolveCommonType(leftType, rightType);\n            const name = leftCol.name().value() ?? `col${i + 1}`;\n            return { name, coercedType };\n        });\n\n        const coercedLeft = [];\n        const coercedRight = [];\n        for (const r of leftRows) coercedLeft.push(this.#coerceRowToAliases(r, mappers));\n        for (const r of rightRows) coercedRight.push(this.#coerceRowToAliases(r, mappers));\n\n        // Perform set operation\n\n        const operator = stmtNode.operator();\n        const modifier = stmtNode.allOrDistinct() || 'DISTINCT';\n\n        let resultRows = [];\n        const rowHash = (row) => {\n            // Create a stable row key where:\n            // - null and undefined are treated the same\n            // - NaN becomes the string '__NaN__'\n            // - objects/arrays are stringified consistently\n            return JSON.stringify(Object.values(row), (k, v) => {\n                if (v === undefined || v === null) return { __sql_null__: true };\n                if (typeof v === 'number' && Number.isNaN(v)) return { __sql_NaN__: true };\n                return v;\n            });\n        };\n\n        const hashSymbol = Symbol('hash');\n        const count = (arr) => {\n            const counts = new Map();\n            for (const r of arr) {\n                const k = r[hashSymbol] ?? (r[hashSymbol] = rowHash(r));\n                counts.set(k, (counts.get(k) || 0) + 1);\n            }\n            return counts;\n        };\n\n        if (operator === 'UNION') {\n            if (modifier === 'ALL') {\n                resultRows = [...coercedLeft, ...coercedRight];\n            } else {\n                // DISTINCT: merge left then right deduping by key (left wins)\n                const map = new Map();\n                for (const r of coercedLeft) map.set(rowHash(r), r);\n                for (const r of coercedRight) {\n                    const k = rowHash(r);\n                    if (!map.has(k)) map.set(k, r);\n                }\n                resultRows = Array.from(map.values());\n            }\n        } else if (operator === 'INTERSECT') {\n            // INTERSECT keeps only rows present on both sides.\n            // For ALL, we must preserve multiplicities: produce as many occurrences as min(countLeft, countRight)\n            const leftCount = count(coercedLeft);\n            const rightCount = count(coercedRight);\n\n            if (modifier === 'ALL') {\n                for (const [k, nLeft] of leftCount.entries()) {\n                    const nRight = rightCount.get(k) || 0;\n                    const times = Math.min(nLeft, nRight);\n                    const exemplar = coercedLeft.find(r => rowHash(r) === k);\n                    for (let i = 0; i < times; i++) resultRows.push({ ...exemplar });\n                }\n            } else {\n                // DISTINCT INTERSECT\n                for (const k of leftCount.keys()) {\n                    if (rightCount.has(k)) {\n                        const exemplar = coercedLeft.find(r => rowHash(r) === k);\n                        resultRows.push({ ...exemplar });\n                    }\n                }\n            }\n        } else if (operator === 'EXCEPT') {\n            // EXCEPT: rows in left not in right.\n            // For ALL: multiplicity = max(0, countLeft - countRight)\n            const leftCount = count(coercedLeft);\n            const rightCount = count(coercedRight);\n\n            if (modifier === 'ALL') {\n                for (const [k, nLeft] of leftCount.entries()) {\n                    const nRight = rightCount.get(k) || 0;\n                    const times = Math.max(0, nLeft - nRight);\n                    const exemplar = coercedLeft.find(r => rowHash(r) === k);\n                    for (let i = 0; i < times; i++) resultRows.push({ ...exemplar });\n                }\n            } else {\n                // DISTINCT EXCEPT\n                for (const k of leftCount.keys()) {\n                    if (!rightCount.has(k)) {\n                        const exemplar = coercedLeft.find(r => rowHash(r) === k);\n                        resultRows.push({ ...exemplar });\n                    }\n                }\n            }\n        }\n\n        // ORDER BY / LIMIT / OFFSET\n\n        const orderByClause = stmtNode.orderByClause();\n        if (orderByClause) resultRows = await this.evaluateSetOpOrderByClause(orderByClause.entries(), resultRows, queryCtx);\n\n        const limitClause = stmtNode.limitClause();\n        const offsetClause = stmtNode.offsetClause();\n        if (limitClause || offsetClause) resultRows = await this.evaluateSetOpLimitClause(limitClause, offsetClause, resultRows, queryCtx);\n\n        yield* resultRows;\n    }\n\n    #coerceRowToAliases(row, mappers) {\n        // Coerce a projected row (object with aliases) into canonical object with mappers order.\n        // Uses Object.values(row) to respect projection order emitted by evaluateSelectList.\n        const values = Object.values(row);\n        const coerced = Object.create(null);\n        for (let i = 0; i < mappers.length; i++) {\n\n            const { name, coercedType } = mappers[i];\n            let val = values[i];\n            // Minimal coercion rules (extend this as you add type metadata)\n            if (coercedType === 'numeric') {\n                if (typeof val === 'string' && val !== '' && !isNaN(+val)) val = +val;\n            } else if (coercedType === 'text') {\n                if (val != null && typeof val !== 'string') val = String(val);\n            }\n\n            // Normalize undefined -> null for consistent equality semantics\n            if (val === undefined) val = null;\n\n            coerced[name] = val;\n        }\n        return coerced;\n    }\n\n    #resolveCommonType(leftType, rightType) {\n        // Minimal common type resolver\n        if (!leftType && !rightType) return null;\n        if (!leftType) return rightType;\n        if (!rightType) return leftType;\n        if (leftType === rightType) return leftType;\n\n        const numeric = new Set(['smallint', 'integer', 'bigint', 'numeric', 'decimal', 'float', 'double']);\n        if (numeric.has(leftType) && numeric.has(rightType)) return 'numeric';\n        if (leftType === 'text' || rightType === 'text') return 'text';\n        if (leftType === 'boolean' && rightType === 'boolean') return 'boolean';\n        // fallback to leftType (conservative)\n        return leftType;\n    }\n\n    async evaluateSetOpOrderByClause(orderElements, resultRows, queryCtx) {\n        // Precompute keys\n        const decorated = await Promise.all(resultRows.map(async (row) => {\n            const keys = await Promise.all(orderElements.map(orderElement => {\n                let refedValue;\n                const throwRefError = () => { throw new Error(`[ORDER BY] The reference by offset ${orderElement.expr()} does not resolve to a select list entry`); };\n                if (orderElement.expr() instanceof registry.NumberLiteral) {\n                    const values = Object.values(row);\n                    const index = orderElement.expr().value() - 1;\n                    if (index < 0 || index >= values.length) throwRefError();\n                    return values[index];\n                }\n                if (orderElement.expr()?.resolution?.() === 'scope') {\n                    if ((refedValue = row[orderElement.expr().value()]) === undefined) throwRefError();\n                    return refedValue;\n                }\n                return this.#exprEngine.evaluate(orderElement.expr(), { ...(queryCtx.lateralCtx || {}), [' ']: row }, queryCtx)\n            }));\n            return { row, keys };\n        }));\n        // Sort synchronously\n        this.#exprEngine.applySorting(decorated, orderElements, queryCtx);\n        return decorated.map((e) => e.row);\n    }\n\n    async evaluateSetOpLimitClause(limitClause, offsetClause, resultRows, queryCtx) {\n        const limit = limitClause ? await this.#exprEngine.evaluate(limitClause.expr(), {}, queryCtx) : 0;\n        const offset = offsetClause ? await this.#exprEngine.evaluate(offsetClause.expr(), {}, queryCtx) : (\n            limitClause.myOffset() ? await this.#exprEngine.evaluate(limitClause.myOffset(), {}, queryCtx) : 0\n        );\n        return resultRows.slice(offset, limit ? offset + limit : undefined);\n    }\n}\n", "import { AbstractSQLClient } from '../entry/abstracts/AbstractSQLClient.js';\nimport { matchRelationSelector, normalizeRelationSelectorArg } from '../entry/abstracts/util.js';\nimport { AbstractFetchClient } from './fetch/AbstractFetchClient.js';\nimport { ConflictError } from './ConflictError.js';\nimport { StorageEngine } from './StorageEngine.js';\nimport { QueryEngine } from './QueryEngine.js';\nimport { registry } from '../lang/registry.js';\n\nexport class FlashQL extends AbstractSQLClient {\n\n    #dialect;\n\n    #storageEngine;\n    #queryEngine;\n\n    #onCreateRemoteClient;\n    #remoteClients = new Map;\n\n    #realtimeAbortLine;\n\n    get dialect() { return this.#dialect; }\n    get storageEngine() { return this.#storageEngine; }\n\n    constructor({ dialect = 'postgres', capability = {}, onCreateRemoteClient = null, ...options } = {}, storageEngine = null) {\n        super({ capability });\n        this.#dialect = dialect;\n        this.#storageEngine = storageEngine || new StorageEngine({ dialect, ...options });\n        this.#queryEngine = new QueryEngine(this.#storageEngine, { dialect, ...options });\n        this.#onCreateRemoteClient = onCreateRemoteClient;\n    }\n\n    async _connect() { }\n\n    async _disconnect() { }\n\n    async _query(query, options) {\n        const unmaterializedMirrors = await this.#storageEngine.showMirrors({ materialized: false });\n        const effectiveMirrorsSpec = new Map;\n\n        if (unmaterializedMirrors.size) {\n            let resolutionHint = 0;\n            query.walkTree((v) => {\n                let nsName,\n                    tblName;\n                if (v instanceof registry.TableRef1\n                    && (nsName = v.qualifier()?.value())\n                    && (tblName = v.value())) {\n                    const nsDef = unmaterializedMirrors.get(nsName);\n                    const tblDef = nsDef?.tables.get(tblName);\n                    if (!tblDef) return;\n\n                    if (!effectiveMirrorsSpec.has(nsName)) {\n                        effectiveMirrorsSpec.set(nsName, { type: nsDef.type, origin: nsDef.origin, tables: new Map });\n                    }\n                    effectiveMirrorsSpec.get(nsName).tables.set(tblName, tblDef);\n\n                    if (nsDef.type === 'API'\n                        || tblDef?.querySpec.query\n                        || tblDef.querySpec.namespace !== nsName) {\n                        resolutionHint = -1;\n                    } else if (resolutionHint !== -1) {\n                        resolutionHint = 1;\n                    }\n                } else return v;\n            }, true);\n\n            let lastClient;\n            for (const nsDef of effectiveMirrorsSpec.values()) {\n                lastClient = await this.getRemoteClient(nsDef.origin);\n                nsDef.client = lastClient;\n            }\n\n            if (resolutionHint === 1\n                && effectiveMirrorsSpec.size === 1) {\n                return await lastClient.query(query, options);\n            }\n        }\n\n        return await this.#queryEngine.query(query, { ...options, effectiveMirrorsSpec });\n    }\n\n    async _cursor(query, options) {\n        let closed = false;\n        return {\n            async *[Symbol.asyncIterator]() {\n                const { rows } = await this._query(query, options);\n                for await (const row of rows) {\n                    if (closed) return;\n                    yield row;\n                }\n            },\n            async close() { closed = true; },\n        };\n    }\n\n    async _showCreate(selector, structured = false) {\n        selector = normalizeRelationSelectorArg(selector);\n        const namespaceSchemas = [];\n        for (const nsName of await this.#storageEngine.namespaceNames()) {\n\n            const objectNames = Object.entries(selector).reduce((arr, [_namespaceName, objectNames]) => {\n                return matchRelationSelector(nsName, [_namespaceName])\n                    ? arr.concat(objectNames)\n                    : arr;\n            }, []);\n            if (!objectNames.length) continue;\n\n            // Schema def:\n            const namespaceJson = {\n                nodeName: registry.NamespaceSchema.NODE_NAME,\n                name: { nodeName: registry.NamespaceIdent.NODE_NAME, value: nsName },\n                entries: [],\n            };\n\n            // Schema tables:\n            const namespaceObject = await this.#storageEngine.getNamespace(nsName);\n            for (const tblName of await namespaceObject.tableNames()) {\n                if (!matchRelationSelector(tblName, objectNames)) continue;\n                const tableStorage = await namespaceObject.getTable(tblName);\n                const tableSchemaJson = tableStorage.schema.jsonfy();\n                tableSchemaJson.name.nodeName = registry.TableIdent.NODE_NAME;\n                tableSchemaJson.name.qualifier = { nodeName: registry.NamespaceRef.NODE_NAME, value: nsName };\n                (structured\n                    ? namespaceJson.entries\n                    : namespaceSchemas).push(registry.TableSchema.fromJSON(tableSchemaJson, { assert: true, dialect: this.dialect }));\n            }\n\n            if (structured) {\n                namespaceSchemas.push(registry.NamespaceSchema.fromJSON(namespaceJson, { dialect: this.dialect }));\n            }\n        }\n\n        return namespaceSchemas;\n    }\n\n    async _setupRealtime() {\n        if (this.#realtimeAbortLine) return; // Indempotency\n        this.#realtimeAbortLine = this.#storageEngine.on('changefeed', (events) => this._fanout(events));\n    }\n\n    async _teardownRealtime() {\n        this.#realtimeAbortLine?.();\n        this.#realtimeAbortLine = null;\n    }\n\n    // --------- FlashQL extras\n\n    async subscribe(selector, callback) {\n        if (typeof selector === 'function') return super.subscribe(selector);\n\n        const unmaterializedMirrors = await this.#storageEngine.showMirrors({ materialized: false });\n        if (unmaterializedMirrors.size) {\n\n            const abortLines = [];\n            const relationSelector = normalizeRelationSelectorArg(selector);\n\n            const localMap = {}, remoteMapMap = {};\n            for (const [nsName, tblNames] of Object.entries(relationSelector)) {\n                const remoteTablesMap = unmaterializedMirrors.get(nsName)?.tables;\n                if (remoteTablesMap) {\n                    for (const tblName of tblNames) {\n                        const remoteNsName = remoteTablesMap.get(tblName)?.querySpec.namespace || '*';\n                        // querySpec.query explocitly excluded from here\n                        if (remoteNsName) {\n                            if (!remoteMapMap[nsName]) remoteMapMap[nsName] = {};\n                            if (!remoteMapMap[nsName][remoteNsName]) remoteMapMap[nsName][remoteNsName] = [];\n                            remoteMapMap[nsName][remoteNsName].push(tblName);\n                        } else {\n                            if (!localMap[nsName]) localMap[nsName] = [];\n                            localMap[nsName].push(tblName);\n                        }\n                    }\n                } else {\n                    localMap[nsName] = tblNames;\n                }\n            }\n\n            if (Object.keys(localMap).length) {\n                abortLines.push(await super.subscribe(localMap, callback));\n            }\n            for (const nsName in remoteMapMap) {\n                const remoteClient = await this.getRemoteClient(unmaterializedMirrors.get(nsName).origin);\n                abortLines.push(await remoteClient.subscribe(remoteMapMap[nsName], (events) => {\n                    events = events.map((e) => ({ ...e, relation: { ...e.relation, namespace: nsName } }));\n                    callback(events);\n                }));\n            }\n\n            return () => abortLines.forEach((c) => c());\n        }\n\n        return super.subscribe(selector, callback);\n    }\n\n    async federate(...args) {\n        const [specifiers, options, origin] = this.#normalizeMirroringSpec(true, ...args);\n        return await this.#federate(specifiers, options, origin);\n    }\n\n    async materialize(...args) {\n        const [specifiers, options, origin] = this.#normalizeMirroringSpec(true, ...args);\n        return await this.#materialize(specifiers, options, origin);\n    }\n\n    async sync(...args) {\n        const [specifiers, options, origin] = this.#normalizeMirroringSpec(false, ...args);\n        return await this.#sync(specifiers, options, origin);\n    }\n\n    async getRemoteClient(origin) {\n        if (!this.#onCreateRemoteClient)\n            throw new Error(`Cannot process remote operation; missing options.onCreateRemoteClient`);\n        if (!this.#remoteClients.has(origin)) { // TODO: derive stable hashing\n            this.#remoteClients.set(origin, await this.#onCreateRemoteClient(origin));\n        }\n        return this.#remoteClients.get(origin);\n    }\n\n    // --------- standard client hooks\n\n    async #federate(specifiers, options, origin, materializeCallback = null) {\n        const storageEngine = this.#storageEngine;\n        const queryCtx = { transaction: await storageEngine.startTransaction('~sync~init') };\n        const remoteClient = await this.getRemoteClient(origin);\n\n        for (const [nsName, queryObjects] of specifiers.entries()) {\n            const namespaceObject = await storageEngine.createNamespace(nsName, { ifNotExists: options.ifNotExists, type: options.type, mirrored: true, origin }, queryCtx);\n\n            for (const querySpec of queryObjects) {\n                const query = await remoteClient.resolve(querySpec);\n                const tableSchema = registry.TableSchema.fromJSON({\n                    name: { nodeName: registry.Identifier.NODE_NAME, value: querySpec.name },\n                    entries: query.resultSchema().entries().map((e) => e.jsonfy()),\n                }, { assert: true });\n\n                const tableStorage = await namespaceObject.createTable(\n                    tableSchema,\n                    { ifNotExists: options.ifNotExists, materialized: !!materializeCallback, querySpec },\n                    queryCtx\n                );\n\n                if (materializeCallback) {\n                    await materializeCallback(tableStorage, query, queryCtx, remoteClient);\n                }\n            }\n        }\n\n        await queryCtx.transaction.done();\n    }\n\n    async #materialize(specifiers, options, origin) {\n        const keyOpts = { keyName: '~sync' };\n        const abortLines = [];\n\n        await this.#federate(specifiers, options, origin, async (tableStorage, query, queryCtx, remoteClient) => {\n            await tableStorage.createKey(keyOpts.keyName);\n            // Inser records\n            let stream, hashes = [];\n            if (options.live) {\n                const result = await remoteClient[remoteClient instanceof AbstractFetchClient ? 'query' : 'request'](\n                    query,\n                    (eventName, eventData) => this.#handleInSync(tableStorage, eventName, eventData),\n                    { live: true }\n                );\n                ({ rows: stream, hashes } = result);\n                abortLines.push(result.abort.bind(result));\n            } else stream = await remoteClient[remoteClient instanceof AbstractFetchClient ? 'cursor' : 'stream'](query);\n\n            let i = 0;\n            for await (const row of stream) {\n                try {\n                    await tableStorage.insert(row, hashes[i] && { ...keyOpts, newKey: hashes[i] }, queryCtx);\n                } catch (e) {\n                    if (e instanceof ConflictError) {\n                        if (!options.ifNotExists) {\n                            await tableStorage.update(e.existing, row, hashes[i] && { ...keyOpts, newKey: hashes[i] }, queryCtx);\n                        }\n                    } else throw e;\n                }\n                i++;\n            }\n        });\n\n        return () => abortLines.forEach((c) => c());\n    }\n\n    async #sync(specifiers, options, origin) {\n        const inSyncAbortLine = await this.#materialize(specifiers, { ...options, live: true }, origin);\n        const abortLines = [inSyncAbortLine];\n\n        for (const [nsName, queryObjects] of specifiers.entries()) {\n            for (const querySpec of queryObjects) {\n                abortLines.push(await this.subscribe(\n                    { [nsName]: [querySpec.name] },\n                    (events) => this.#handleOutSync(events, querySpec, origin)\n                ));\n            }\n        }\n\n        return () => abortLines.forEach((c) => c());\n    }\n\n    async #handleInSync(tableStorage, eventName, eventData) {\n        const storageEngine = this.#storageEngine;\n        const queryCtx = { transaction: await storageEngine.startTransaction('~sync~in') };\n        const keyOpts = { keyName: '~sync' };\n\n        if (eventName === 'diff') {\n            for (let event of eventData) {\n                if (event.type === 'update') {\n                    const existing = await tableStorage.get(event.newHash, keyOpts);\n\n                    if (existing) {\n                        await tableStorage.update(event.oldHash, event.new, { ...keyOpts, newKey: event.newHash }, queryCtx);\n                    } else {\n                        event = { ...event, type: 'insert' };\n                    }\n                }\n\n                if (event.type === 'insert') {\n                    await tableStorage.insert(event.new, { ...keyOpts, newKey: event.newHash }, queryCtx);\n                }\n\n                if (event.type === 'delete') {\n                    await tableStorage.delete(event.newHash, keyOpts, queryCtx);\n                }\n            }\n        }\n\n        if (eventName === 'swap') {\n            const displaced = new Map;\n\n            for (const [hash, targetHash] of eventData) {\n                const sourceRecord = displaced.get(hash)\n                    || await tableStorage.get(hash, keyOpts);\n\n                const targetRedord = await tableStorage.get(targetHash, keyOpts);\n                displaced.set(targetHash, targetRedord);\n\n                await tableStorage.update(targetHash, sourceRecord, keyOpts);\n            }\n        }\n\n        if (eventName === 'result') {\n            const keys = await tableStorage.showKeys(keyOpts.keyName);\n            const allKeys = [...eventData.hashes, ...keys];\n\n            let existing;\n            for (let i = 0; i < allKeys.length; i++) {\n                if (!eventData.rows[i]) {\n                    await tableStorage.delete(allKeys[i], keyOpts, queryCtx);\n                } else if (existing = await tableStorage.get(allKeys[i], keyOpts)) {\n                    if (_eq(eventData.rows[i], existing)) continue;\n                    await tableStorage.update(allKeys[i], eventData.rows[i], keyOpts, queryCtx);\n                } else {\n                    await tableStorage.insert(eventData.rows[i], { ...keyOpts, newKey: allKeys[i] }, queryCtx);\n                }\n            }\n        }\n\n        await queryCtx.transaction.done();\n    }\n\n    async #handleOutSync(events, querySpec, origin) {\n        const outQueryObjects = [];\n\n        for (const event of events) {\n            if (event.txId.startsWith('~sync')) continue;\n\n            const outQueryObject = { ...querySpec, command: event.type };\n\n            if (event.type === 'insert') {\n                outQueryObject.payload = [{ ...(querySpec.filters || {}), ...event.new }];\n            } else if (event.type === 'update' || event.type === 'delete') {\n                const key = event.key || Object.fromEntries(event.relation.keyColumns.map((k) => [k, event.old[k]]));\n                outQueryObject.filters = { ...(querySpec.filters || {}), ...key };\n\n                if (event.type === 'update') {\n                    outQueryObject.payload = event.new;\n                }\n            }\n\n            outQueryObjects.push(outQueryObject);\n        }\n\n        if (outQueryObjects.length) {\n            // TODO: implement an outbound queue for these quesries and handle failures\n            //const remoteClient = await this.getRemoteClient(origin);\n            //const result = await remoteClient.query(outQueryObjects.join(';'));\n        }\n    }\n\n    #normalizeMirroringSpec(allowQueries, ...args) {\n        const spec = args.shift();\n        const origin = args.pop(); // Last arg\n        const options = args.pop() || {}; // Middle, optional arg\n\n        if (!(typeof spec === 'object' && spec) || Array.isArray(spec)) {\n            throw new TypeError('Mirroring spec must be a non-array object spec');\n        }\n        if (!origin || !['object', 'string'].includes(typeof origin)) {\n            throw new TypeError('Origin spec must be a string or an object');\n        }\n\n        const specifiers = new Map;\n\n        for (const nsName in spec) {\n            specifiers.set(nsName, new Set);\n\n            for (const subSpec of [].concat(spec[nsName])) {\n                const tableSpec = {};\n\n                if (typeof subSpec === 'string') {\n                    if (options.type === 'API') {\n                        specifiers.get(nsName).add({\n                            name: subSpec,\n                        });\n                    } else {\n                        specifiers.get(nsName).add({\n                            namespace: nsName,\n                            name: subSpec,\n                        });\n                    }\n                } else {\n                    let keys;\n                    if (!(typeof subSpec === 'object' && subSpec)\n                        || !(keys = Object.keys(subSpec)).length\n                        || keys.filter((k) => k !== 'namespace' && k !== 'name' && k !== 'query' && k !== 'url' && k !== 'filters' && k !== 'joinStrategy').length) {\n                        throw new SyntaxError(`Given table spec ${JSON.stringify(subSpec)} invalid`);\n                    }\n\n                    if (!subSpec.name)\n                        throw new SyntaxError(`Missing attribute \"name\" in ${JSON.stringify(subSpec)}`);\n\n                    if (options.type === 'API') {\n                        if (subSpec.query)\n                            throw new SyntaxError(`Unsupported attribute \"query\" in API-type mirror spec: ${JSON.stringify(subSpec)}`);\n                        if (subSpec.namespace || subSpec.filters)\n                            throw new SyntaxError(`Mutually-exclusive attributes \"namespace|filters\" in ${JSON.stringify(subSpec)}`);\n                        specifiers.get(nsName).add({\n                            name: subSpec.name,\n                            url: subSpec.url,\n                            joinStrategy: subSpec.joinStrategy\n                        });\n                    } else {\n                        if (subSpec.url)\n                            throw new SyntaxError(`Unsupported attribute \"url\" in SQL-type mirror spec: ${JSON.stringify(subSpec)}`);\n                        if (subSpec.query) {\n                            if (!allowQueries)\n                                throw new SyntaxError(`Arbitrary queries ${JSON.stringify(tableSpec)} not supported on this operation`);\n                            if (subSpec.namespace || subSpec.filters)\n                                throw new SyntaxError(`Mutually-exclusive attributes \"namespace|filters\" in ${JSON.stringify(subSpec)}`);\n                            specifiers.get(nsName).add({\n                                name: subSpec.name,\n                                query: subSpec.query,\n                                joinStrategy: subSpec.joinStrategy\n                            });\n                        } else {\n                            if (subSpec.filters && typeof subSpec.filters !== 'object')\n                                throw new SyntaxError(`Invalid attribute \"filter\" in ${JSON.stringify(subSpec)}`);\n                            specifiers.get(nsName).add({\n                                namespace: subSpec.namespace || nsName,\n                                name: subSpec.name,\n                                filters: subSpec.filters,\n                                joinStrategy: subSpec.joinStrategy\n                            });\n                        }\n                    }\n                }\n            }\n        }\n\n        return [specifiers, options, origin];\n    }\n}"],
  "mappings": "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",
  "names": ["isObject_default", "val", "init_isObject", "__esmMin", "init_isProxy", "__esmMin", "init_isObject", "init_getProxyTarget", "__esmMin", "init_isProxy", "init_getProxyTrap", "__esmMin", "init_isProxy", "getType_default", "val", "init_getType", "__esmMin", "init_instanceof", "__esmMin", "isArray_default", "val", "init_isArray", "__esmMin", "init_intersect", "__esmMin", "init_isArray", "init_internals", "__esmMin", "init_intersect", "init_isBoolean", "__esmMin", "isTypeFunction_default", "val", "init_isTypeFunction", "__esmMin", "init_isClass", "__esmMin", "init_isTypeFunction", "isNull_default", "val", "init_isNull", "__esmMin", "isUndefined_default", "val", "init_isUndefined", "__esmMin", "isTypeObject_default", "val", "isTypeFunction_default", "init_isTypeObject", "__esmMin", "init_isTypeFunction", "isEmpty_default", "val", "isNull_default", "isUndefined_default", "isTypeObject_default", "init_isEmpty", "__esmMin", "init_isNull", "init_isUndefined", "init_isTypeObject", "isFunction_default", "val", "isTypeFunction_default", "init_isFunction", "__esmMin", "init_isTypeFunction", "init_isNumber", "__esmMin", "init_isNumeric", "__esmMin", "init_isNumber", "init_isPlainArray", "__esmMin", "init_isArray", "init_isPlainObject", "__esmMin", "init_isObject", "isString_default", "val", "init_isString", "__esmMin", "isTypeArray_default", "val", "isString_default", "isUndefined_default", "init_isTypeArray", "__esmMin", "init_isString", "init_isUndefined", "init_first", "__esmMin", "init_last", "__esmMin", "init_first", "init_pushUnique", "__esmMin", "init_getPrototypeChain", "__esmMin", "init_isArray", "init_getAllPropertyNames", "__esmMin", "init_pushUnique", "init_getPrototypeChain", "init_mergeCallback", "__esmMin", "init_isArray", "init_isFunction", "init_isObject", "init_isTypeObject", "init_isNumeric", "init_getAllPropertyNames", "init_each", "__esmMin", "init_isTypeObject", "init_isNumeric", "init_mixin", "__esmMin", "init_isArray", "init_isFunction", "init_last", "init_mergeCallback", "init_each", "init_merge", "__esmMin", "init_mergeCallback", "init_proxy", "__esmMin", "init_merge", "wq", "obj", "namespaces", "WQInternals", "_ns", "_wq", "init_wq", "__esmMin", "init_js", "__esmMin", "init_getProxyTarget", "init_getProxyTrap", "init_getType", "init_instanceof", "init_internals", "init_isArray", "init_isBoolean", "init_isClass", "init_isEmpty", "init_isFunction", "init_isNull", "init_isNumber", "init_isNumeric", "init_isObject", "init_isPlainArray", "init_isPlainObject", "init_isProxy", "init_isString", "init_isTypeArray", "init_isTypeFunction", "init_isTypeObject", "init_isUndefined", "init_mixin", "init_proxy", "init_wq", "init_after", "__esmMin", "init_indexOfSet", "__esmMin", "init_after", "__esmMin", "init_indexOfSet", "init_afterLast", "__esmMin", "init_after", "init_all", "__esmMin", "init_any", "__esmMin", "init_sum", "__esmMin", "init_avg", "__esmMin", "init_sum", "init_before", "__esmMin", "init_before", "__esmMin", "init_indexOfSet", "init_beforeLast", "__esmMin", "init_before", "init_following", "__esmMin", "init_isUndefined", "init_isFunction", "init_preceding", "__esmMin", "init_isUndefined", "init_isFunction", "init_between", "__esmMin", "init_following", "init_preceding", "init_isFunction", "init_concatAfter", "__esmMin", "init_concatAfterLast", "__esmMin", "init_concatAfter", "init_concatBefore", "__esmMin", "init_concatBeforeLast", "__esmMin", "init_concatBefore", "from_default", "val", "castObject", "isArray_default", "isObject_default", "isEmpty_default", "isTypeArray_default", "init_from", "__esmMin", "init_isArray", "init_isTypeArray", "init_isEmpty", "init_isObject", "init_concatUnique", "__esmMin", "init_pushUnique", "init_from", "init_crossJoin", "__esmMin", "init_from", "init_difference", "__esmMin", "init_isArray", "init_divide", "__esmMin", "init_endsWith", "__esmMin", "init_equals", "__esmMin", "init_equals2D", "__esmMin", "init_all", "init_equals", "init_remove", "__esmMin", "init_exclude", "__esmMin", "init_remove", "init_filter", "__esmMin", "init_divide", "init_flatten", "__esmMin", "init_isArray", "init_isObject", "init_isNumeric", "init_followingLast", "__esmMin", "init_following", "init_inSequence", "__esmMin", "init_isArray", "init_isObject", "init_isBoolean", "init_isNumber", "init_lastIndexOfSet", "__esmMin", "init_indexOfSet", "init_max", "__esmMin", "init_mid", "__esmMin", "init_min", "__esmMin", "init_precedingLast", "__esmMin", "init_preceding", "init_rand", "__esmMin", "init_replace", "__esmMin", "init_each", "init_slice", "__esmMin", "init_sort", "__esmMin", "init_isString", "init_startsWith", "__esmMin", "init_unique", "__esmMin", "init_arr", "__esmMin", "init_after", "init_afterLast", "init_all", "init_any", "init_avg", "init_before", "init_beforeLast", "init_between", "init_concatAfter", "init_concatAfterLast", "init_concatBefore", "init_concatBeforeLast", "init_concatUnique", "init_crossJoin", "init_difference", "init_divide", "init_endsWith", "init_equals", "init_equals2D", "init_exclude", "init_filter", "init_first", "init_flatten", "init_following", "init_followingLast", "init_from", "init_indexOfSet", "init_inSequence", "init_intersect", "init_last", "init_lastIndexOfSet", "init_max", "init_mid", "init_min", "init_preceding", "init_precedingLast", "init_pushUnique", "init_rand", "init_remove", "init_replace", "init_slice", "init_sort", "init_startsWith", "init_sum", "init_unique", "_wq", "_await", "env", "init_util", "__esmMin", "init_js", "target", "args", "wq", "value", "callback", "Registration", "init_Registration", "__esmMin", "registry", "dfn", "ListenerRegistration", "init_ListenerRegistration", "__esmMin", "init_arr", "init_Registration", "init_util", "Registration", "env", "events", "matches", "filter", "from_default", "event", "$ret", "_await", "ret", "recursions", "Registry", "init_Registry", "__esmMin", "init_js", "init_arr", "init_util", "target", "registration", "_entry", "type", "createIfNotExists", "namespace", "isTypeObject_default", "getType_default", "ImplementationClass", "_wq", "Descriptor", "init_Descriptor", "__esmMin", "target", "dfn", "ListenerRegistry", "init_ListenerRegistry", "__esmMin", "init_ListenerRegistration", "init_Registry", "init_util", "init_Descriptor", "Registry", "target", "createIfNotExists", "namespace", "ImplementationClass", "filter", "emit", "params", "ListenerRegistration", "events", "eventsArePropertyDescriptors", "eventIsArrayMethodDescriptor", "arrayMethodName", "listeners", "snapshots", "listenersLength", "listenersAskingEventsWithPropertyDescriptors", "listenersAskingArrayMethodDescriptors", "listener", "events_with_PropertyDescriptors_with_ArrayMethodDescriptors", "events_with_PropertyDescriptors_without_ArrayMethodDescriptors", "events_without_PropertyDescriptors_with_ArrayMethodDescriptors", "events_without_PropertyDescriptors_without_ArrayMethodDescriptors", "snapshot", "event", "$event", "type", "details", "Descriptor", "callback", "returnValue", "_await", "batch", "TrapsRegistration", "init_TrapsRegistration", "__esmMin", "init_Registration", "Registration", "descriptor", "next", "recieved", "args", "TrapsRegistry", "init_TrapsRegistry", "__esmMin", "init_TrapsRegistration", "init_Registry", "Registry", "target", "createIfNotExists", "namespace", "ImplementationClass", "dfn", "TrapsRegistration", "descriptor", "defaultHandler", "$this", "next", "index", "_args", "registration", "args", "actors_exports", "__export", "accessorize", "proxy", "unaccessorize", "unproxy", "target", "props", "params", "resolveTarget", "accessorizedProps", "_wq", "getDescriptorDeep", "prop", "descriptor", "proto", "accessorizeProp", "currentDescriptorRecord", "withPropertyDescriptors", "value", "currentDescriptor", "accessorization", "enumerable", "set", "get", "statuses", "unaccessorizeProp", "extendCallback", "originalTarget", "traps", "thisArgument", "argumentsList", "apply", "newTarget", "construct", "propertyKey", "attributes", "defineProperty", "deleteProperty", "receiver", "symWQOriginal", "$params", "returnValue", "isTypeObject_default", "getOwnPropertyDescriptor", "getPrototypeOf", "has", "isExtensible", "ownKeys", "preventExtensions", "prototype", "setPrototypeOf", "$traps", "$proxy", "init_actors", "__esmMin", "init_arr", "init_js", "init_main", "init_util", "main_exports", "__export", "any", "apply", "batch", "construct", "defineProperties", "defineProperty", "deleteProperties", "deleteProperty", "get", "getOwnPropertyDescriptor", "getOwnPropertyDescriptors", "getPrototypeOf", "has", "intercept", "isExtensible", "map", "observe", "ownKeys", "path", "preventExtensions", "reduce", "set", "setPrototypeOf", "subtree", "segments", "Path", "Subtree", "target", "receiver", "final", "x", "params", "_isSubtree", "eat", "$params", "$isSubtree", "isSubtree", "segment", "isLastSegment", "Descriptor", "result", "args", "addTrail", "desc", "flags", "advance", "$value", "resolveObj", "_await", "isPropsList", "entry", "prop", "originalTarget", "isFunction_default", "getType_default", "isTypeObject_default", "emit", "bind", "traps", "isObject_default", "TrapsRegistry", "exec", "isLive", "resolveProps", "props", "related", "next", "results", "_props", "_done", "defaultGet", "descriptor", "value", "_next", "accessorizedProps", "_wq", "accessorization", "trapsRegistry", "result_s", "callback", "ListenerRegistry", "source", "only", "except", "sourceKeys", "k", "filteredKeys", "resolveKey", "i", "doSet", "key", "mutations", "def", "entries", "descriptors", "defaultSet", "status", "isUpdate", "oldValue", "exists", "listenerRegistry", "opr", "from_default", "defaultDel", "argumentsList", "newTarget", "thisArgument", "originalThis", "unproxy", "returnValue", "proto", "controller", "env", "childRegistrations", "descriptor_s", "prevRegistration", "registrationNext", "isExisting", "handlerReturnValue", "operation", "payload", "defaultExec", "obj", "assert", "probePropertyDescriptors", "p", "name", "init_main", "__esmMin", "init_js", "init_arr", "init_util", "init_ListenerRegistry", "init_TrapsRegistry", "init_Descriptor", "init_actors", "src_exports", "__export", "src_default", "Observer", "init_src", "__esmMin", "init_main", "init_actors", "main_exports", "actors_exports", "init_js", "init_js", "_eq", "a", "b", "cs", "ignoreList", "x", "i", "isObject_default", "temp", "$ignoreList", "k", "prev", "_toCapsSnake", "str", "result", "toktypes_exports", "__export", "TOK_TYPES", "aggrFunctionNames", "dataTypes", "functionNames", "keywords", "operators", "statements", "dialect", "mysqlAnsiQuotes", "value", "TokenStreamState", "by", "isLf", "TokenStream", "#iterator", "#options", "#locked", "#started", "#done", "#rootSavepoint", "#history", "#current", "#peeks", "iterator", "_", "options", "#assertNotLocked", "value", "done", "#historyPush", "#peeksShift", "$type", "$value", "peek", "type", "match", "tok", "i", "length", "$length", "next", "#peeksPush", "#historyPop", "#peeksUnshift", "method", "point", "toIndex", "input", "dialect", "state", "s", "normalizeOptions", "stream", "localState", "$finalizeToken", "token", "forceYield", "finalizeToken", "chunk", "char", "possiblyChunked", "charIsWhitespace", "whitespace", "$throw", "isEndQuote", "isEndTag", "isString", "isDelimitedIdent", "isBlockComment", "isLineComment", "prevChar", "nextChar", "strings_inBackslashEscapeMode", "strings_atEscapePosition", "tokenEndSteps", "cursor", "tokenStart", "tokenStartBacksteps", "tokenStartForwardsteps", "__", "restTok", "modifierPattern", "modifierMatch", "modifier", "groupToken", "previousChar", "addMultiWord", "targetMap", "prefix", "_tok", "tokenCategory", "$tokenCategory", "tokenRegistry", "tokenDialectBranch", "entries", "toktypes_exports", "entry", "finalizeComment", "finalToken", "identResolution", "line", "column", "finalizeIdentifier", "multiwordBufferLength", "wordSoFar", "findInBranch", "branch", "matchResult", "resolveTok", "spaceBefore", "processExactMatch", "processPartialMatch", "multiwordMatched", "tokenCategory2", "matchResult2", "existing", "current", "registry", "AbstractNode", "_AbstractNode", "_toCapsSnake", "#ast", "#options", "#parentNode", "ast", "options", "node_s", "k", "fieldName", "index", "cs", "n", "value", "indexOrValue", "valueOnIndex", "existing", "all", "i", "args", "nodes", "node", "activeTrailStr", "visitor", "crossStmt", "scope", "visit", "key", "_scope", "v", "possibleChild", "_eq", "transformer", "schemaInference", "resultJson", "prev", "C", "transformSpec", "dialect", "cacheKey", "result", "syntaxRules", "rulesArray", "trail", "schemaSet", "assertionTrail", "newDependencyTrail", "cloneSchemaSet", "sch", "rule", "type", "exposure", "inference", "arity", "singletons", "modifier", "booleanfy", "optional", "assert", "syntax", "syntaxes", "rest", "activeTrail", "unsupportedAttrs", "_getUnsupportedRuleAttrs", "isTokenRule", "TOK_TYPES", "t", "registry", "isObject_default", "keys", "a", "fieldSchema", "schema", "newAssertionTrail", "newSchemaSet", "j", "schemaSetClone", "schemaSetCloneResult", "resultSchema", "schemasArray", "schemaA", "schemaAObj", "schemaB", "schemaBObj", "inputJson", "callback", "astSchema", "hardCodedNodeName", "lastAssertion", "$decideThrow", "message", "rulePath", "assertsGrep", "matchTokenRule", "fieldJson", "expectedValue", "resolveField", "fieldValue", "acquireField", "resultAST", "depField", "_inferenceMatch", "count", "resultArray", "entry", "resultLenth", "havingDuplicate", "e", "_e", "paths_loop", "$astSchema", "$inputJson", "rootRule", "tokSchema", "attr", "jsonfy", "relevantTransformer", "defaultTransform", "options1", "childTransformer", "entries", "resultEntries", "input", "tokenStream", "TokenStream", "left", "minPrecedence", "savepoint", "types", "exprClass", "operator", "newLeft", "numSkippedRules_dialectWise", "newMinPrecedence", "requiredSpacing", "peek", "optionalParens", "itemSeparator", "supportsLeft", "acquireLeft", "peekToken", "name", "matchSpacing", "current", "adjustBy", "eatToken", "op", "tok", "parseNode", "activeTokenStream", "NodeClass", "tokenStreamPosition", "forceThrow", "proximityTerm", "_type", "line", "column", "spaceBefore", "prec", "assoc", "resultType", "itemMinPrecedence", "relevantOperatorDef", "currentAsUnexpected", "startingIndentLevel", "autoLineBreakThreshold", "renderingStats", "$space", "$lineBreak", "indentLevel", "resultTokens", "numSkippedRules_optionalWise", "autoSpacing", "autoIndent", "autoIndentAdjust", "$autoIndent", "activeOptions", "rendering", "highestRenderingScore", "newRenderingStats", "$rendering", "hasExpectedValue", "$rule", "shouldRender", "itemsRendering", "renderingsStr", "$autoItemSpacing", "$itemSeparator", "autoSpaceIgnore", "hitsAutoLineBreakThreshold", "blockAutoLineBreakMode", "delims", "precedingTok", "delimChars", "delimChar", "escChar", "defs", "match", "indent", "lines", "supportedRuleAttrs", "criteria", "exp", "normalizeRelationSelectorArg", "selector", "flatten", "ss", "i", "keys", "k", "namespace", "tables", "v", "all", "table", "parseRelationSelectors", "enums", "names", "_names", "patterns", "_patterns", "e", "matchRelationSelector", "ident", "$names", "$_names", "$patterns", "s", "$_patterns", "normalizeQueryArgs", "args", "query", "options", "matchExpr", "a", "b", "_op", "_a", "AbstractNode", "_eq", "registry", "matchOperators", "ops", "x", "logicalOp", "aSplit", "splitLogicalExpr", "bSplit", "matchLogicalSplits", "aKeys", "bKeys", "op", "top", "_b", "expr", "cte_exports", "__export", "CTE", "CTEItem", "CTEItemAlias", "PGCycleClause", "PGSearchClause", "PGCycleClause", "AbstractNode", "PGSearchClause", "AbstractNode", "ResultSchemaMixin", "Class", "#result_schema", "inputJson", "options", "callback", "AbstractNode", "result_schema", "restJson", "instance", "transformer", "schemaInference", "resultJson", "OriginSchemasMixin", "Class", "#origin_schemas", "inputJson", "options", "callback", "AbstractNode", "origin_schemas", "restJson", "instance", "transformer", "schemaInference", "resultJson", "originSchemas", "foundJSONSchema", "resultSchema", "registry", "AbstractStmt", "AbstractNode", "#uuid", "inputJson", "options", "callback", "uuid", "restJson", "instance", "transformer", "schemaInference", "resultJson", "AbstractNonDDLStmt", "ResultSchemaMixin", "OriginSchemasMixin", "AbstractStmt", "values", "queryBindings", "i", "bindings", "b", "dedupe", "redundants", "$offset", "newOffset", "Transformer", "_Transformer", "#callback", "#rands", "#hashes", "#parentTransformer", "#statementNode", "#isStatementContext", "#artifacts", "callback", "parentTransformer", "statementNode", "type", "asSalt", "rands", "value", "hashes", "node", "defaultTransform", "key", "options0", "originatingContext", "$defaultTransform", "options1", "childTransformer", "options2", "CTE", "AbstractNonDDLStmt", "options", "transformer", "schemaInference", "outerResultSchema", "Transformer", "node", "defaultTransform", "keyHint", "bodyResultJson", "CTEItem", "AbstractNonDDLStmt", "options", "transformer", "schemaInference", "resultJson", "namespaceIdent", "registry", "resultSchema", "s", "Transformer", "node", "defaultTransform", "key", "Identifier", "_Identifier", "AbstractNode", "ident", "cs", "_eq", "CTEItemAlias", "Identifier", "itemSeparator", "ddl_exports", "__export", "CheckConstraint", "ColumnDefaultConstraint", "ColumnDiff", "ColumnExpressionConstraint", "ColumnFKConstraint", "ColumnIdent", "ColumnIdentityConstraint", "ColumnNullConstraint", "ColumnPKConstraint", "ColumnSchema", "ColumnUKConstraint", "ConstraintSchema", "CreateSchemaStmt", "CreateTableStmt", "DDLStmt", "DropSchemaStmt", "DropTableStmt", "FKDeleteRule", "FKMatchRule", "FKUpdateRule", "IndexDiff", "IndexSchema", "MYColumnAutoIncrementModifier", "MYColumnCommentModifier", "MYColumnOnUpdateModifier", "MYColumnVisibilityModifier", "NamespaceIdent", "NamespaceSchema", "PGIndexParamInclude", "PGIndexParamUsing", "PGIndexParamWith", "PGIndexParameters", "PGTableEXConstraint", "PGTableEXConstraintItem", "ReferentialAction", "SchemaDiff", "TableDiff", "TableFKConstraint", "TableIdent", "TablePKConstraint", "TableSchema", "TableUKConstraint", "AbstractNodeList", "AbstractNode", "index", "value", "args", "AbstractDiff", "AbstractNodeList", "ColumnDiff", "AbstractDiff", "AbstractSchema", "_AbstractSchema", "AbstractNodeList", "value", "args", "inputJson", "options", "callback", "AbstractNode", "ddl_name", "restJson", "node", "iddlNameIdent", "registry", "prev", "Class", "renameTo", "transformer", "schemaInference", "resultJson", "ColumnSchema", "AbstractSchema", "cons", "registry", "normalized", "pkConstraint", "pkColumns", "nodeName", "columns", "cJson", "instance", "c", "options", "transformer", "schemaInference", "resultJson", "tableLevelConstraints", "x", "method", "s", "FKMatchRule", "AbstractNode", "FKDeleteRule", "AbstractNode", "FKUpdateRule", "AbstractNode", "PGIndexParameters", "AbstractNodeList", "PGIndexParamInclude", "AbstractNodeList", "PGIndexParamUsing", "AbstractNode", "PGIndexParamWith", "AbstractNodeList", "ConstraintSchema", "AbstractSchema", "rules", "registry", "PGTableEXConstraintItem", "ConstraintSchema", "ReferentialAction", "AbstractNode", "CheckConstraint", "ConstraintSchema", "columns", "node", "registry", "ColumnDefaultConstraint", "ConstraintSchema", "ColumnExpressionConstraint", "ConstraintSchema", "ColumnSchema", "ColumnRef2", "registry", "ColumnFKConstraint", "ConstraintSchema", "itemSeparator", "MYColumnAutoIncrementModifier", "AbstractNode", "options", "transformer", "schemaInference", "ColumnIdentityConstraint", "ColumnIdentityConstraint", "ConstraintSchema", "options", "transformer", "schemaInference", "MYColumnAutoIncrementModifier", "ColumnNullConstraint", "ConstraintSchema", "ColumnPKConstraint", "ConstraintSchema", "registry", "ColumnUKConstraint", "ConstraintSchema", "ColumnSchema", "ColumnRef2", "registry", "MYColumnCommentModifier", "AbstractNode", "MYColumnOnUpdateModifier", "AbstractNode", "MYColumnVisibilityModifier", "AbstractNode", "PGTableEXConstraint", "ConstraintSchema", "itemSeparator", "TableFKConstraint", "ConstraintSchema", "itemSeparator", "TablePKConstraint", "ConstraintSchema", "itemSeparator", "TableUKConstraint", "ConstraintSchema", "itemSeparator", "PathMixin", "Class", "baseRule", "ident", "cs", "result", "tokenStream", "syntaxRules", "left", "minPrecedence", "trail", "options", "resultAST", "qualifierTokens", "qualifierExposure", "qualifierTypes", "qualifierStream", "qualifierOptions", "expr_exports", "__export", "AggrCallExpr", "AtTimeZoneExpr", "BetweenExpr", "BinaryExpr", "BindVar", "BitLiteral", "BoolLiteral", "CallExpr", "CaseBranch", "CaseExpr", "CastExpr", "ColumnRef0", "ColumnRef1", "ColumnRef2", "DefaultLiteral", "DistinctFromExpr", "Expr", "ExtractExpr", "HexLiteral", "Identifier", "InExpr", "LQArrayLiteral", "LQBackBackRef", "LQBackRef", "LQBackRefAbstraction", "LQBackRefEndpoint", "LQDeepDeepRef1", "LQDeepDeepRef2", "LQDeepRef1", "LQDeepRef2", "LQObjectLiteral", "LQObjectProperty", "NamespaceRef", "NullLiteral", "NumberLiteral", "PGCastExpr2", "PGFilterClause", "PGTypedArrayLiteral", "PGWithinGroupClause", "ParenExpr", "PredicateExpr", "QuantitativeExpr", "RowConstructor", "ScalarSubquery", "StringLiteral", "SystemVar", "TableRef0", "TableRef1", "TableRef2", "TypedDateLiteral", "TypedIntervalLiteral", "TypedLiteral", "TypedRowConstructor", "TypedTimeLiteral", "TypedTimeZoneLiteral", "TypedTimestampLiteral", "UnaryExpr", "UnknownLiteral", "UserVar", "WindowRef", "TypeSysMixin", "Class", "registry", "AbstractClassicExpr", "TypeSysMixin", "AbstractNode", "ParenExpr", "_ParenExpr", "AbstractClassicExpr", "expr", "RowConstructor", "_RowConstructor", "ResultSchemaMixin", "TypeSysMixin", "AbstractNodeList", "registry", "options", "transformer", "schemaInference", "resultJson", "entriesNode", "resultSchemas", "entry", "i", "ident", "DerivedQuery", "ResultSchemaMixin", "ParenExpr", "#is_correlated", "inputJson", "options", "callback", "AbstractNode", "is_correlated", "restJson", "instance", "transformer", "schemaInference", "statementContextArtifacts", "resultJson", "correlationFlag", "resultSchema", "ScalarSubquery", "DerivedQuery", "registry", "options", "transformer", "schemaInference", "resultJson", "resultSchema", "TypedRowConstructor", "RowConstructor", "PGFilterClause", "AbstractNode", "PGWithinGroupClause", "AbstractNode", "CallExpr", "ResultSchemaMixin", "AbstractClassicExpr", "itemSeparator", "AggrCallExpr", "CallExpr", "itemSeparator", "optional_distinct_modifier", "optional_separator_arg", "optional_order_by_clause", "optional_filter_clause_postgres", "optional_within_group_clause_postgres", "optional_null_handling_directive", "optional_over_clause", "CaseExpr", "TypeSysMixin", "AbstractNodeList", "CaseBranch", "AbstractNode", "CastExpr", "AbstractClassicExpr", "BinaryExpr", "AbstractClassicExpr", "operator", "toDialect", "resultType", "operators", "registry", "ExtractExpr", "BinaryExpr", "PredicateExpr", "AbstractClassicExpr", "registry", "QuantitativeExpr", "AbstractNode", "AbstractLiteral", "AbstractClassicExpr", "BitLiteral", "AbstractLiteral", "registry", "BoolLiteral", "AbstractLiteral", "registry", "DefaultLiteral", "AbstractLiteral", "HexLiteral", "AbstractLiteral", "registry", "NullLiteral", "AbstractLiteral", "NumberLiteral", "AbstractLiteral", "registry", "StringLiteral", "AbstractLiteral", "registry", "TypedLiteral", "AbstractClassicExpr", "registry", "TypedDateLiteral", "TypedLiteral", "TypedIntervalLiteral", "TypedLiteral", "val", "str", "num", "unit", "#unitToParts", "sign", "parts", "toUnit", "y", "#applySign", "d", "h", "hm", "m", "hms", "s", "tokens", "i", "token", "u", "mapped", "k", "v", "baseDate", "dir", "TypedTimeLiteral", "TypedLiteral", "TypedTimestampLiteral", "TypedLiteral", "TypedTimeZoneLiteral", "TypedLiteral", "UnknownLiteral", "AbstractLiteral", "SugarMixin", "Class", "AbstractLQJsonLiteral", "SugarMixin", "TypeSysMixin", "AbstractNodeList", "registry", "LQArrayLiteral", "AbstractLQJsonLiteral", "registry", "options", "transformer", "schemaInference", "resultJson", "resultSchemas", "e", "i", "resultSchema", "namespaceIdent", "LQObjectLiteral", "AbstractLQJsonLiteral", "registry", "options", "transformer", "schemaInference", "resultJson", "entries", "result", "propertyJson", "ref", "newPropertyJson", "existing", "_eq", "resultSchemas", "args", "i", "resultSchema", "namespaceIdent", "LQObjectProperty", "_LQObjectProperty", "AbstractNode", "options", "transformer", "schemaInference", "keyNode", "asAggr", "keyJson", "$options", "valueNode", "registry", "defaultTransform", "childTransformer", "valueJson", "PGTypedArrayLiteral", "AbstractNodeList", "registry", "options", "transformer", "schemaInference", "resultJson", "AtTimeZoneExpr", "BinaryExpr", "registry", "BetweenExpr", "BinaryExpr", "DistinctFromExpr", "BinaryExpr", "InExpr", "BinaryExpr", "PGCastExpr2", "BinaryExpr", "UnaryExpr", "AbstractClassicExpr", "operator", "registry", "ErrorRefUnknown", "ErrorRefAmbiguous", "AbstractClassicRef", "ResultSchemaMixin", "TypeSysMixin", "Identifier", "#resolution", "transformer", "schemaInference", "resultSet", "objectType", "ErrorRefAmbiguous", "ErrorRefUnknown", "inputJson", "options", "callback", "AbstractNode", "resolution", "restJson", "instance", "resultJson", "ColumnRef1", "_ColumnRef1", "PathMixin", "AbstractClassicRef", "registry", "parentNode", "up", "deepMatchCallback", "transformer", "schemaInference", "name", "inGrepMode", "resultSet", "resolve", "columnSchema", "qualifierJson", "resolution", "result", "AbstractNode", "resultSchema", "resolvedColumnRef1", "statementContext", "tempTableRef", "tableSchema", "prev", "newQualifierJson", "compositeResult", "s", "toKind", "options", "resultJson", "resolved", "ColumnRef0", "ColumnRef1", "registry", "ErrorFKInvalid", "message", "AbstractMagicRef", "SugarMixin", "BinaryExpr", "transformer", "schemaInference", "fk", "ErrorFKInvalid", "ColumnRef2", "_ColumnRef2", "AbstractClassicRef", "registry", "deepMatchCallback", "transformer", "schemaInference", "name", "inGrepMode", "resultSet", "resolve", "columnSchema", "result", "AbstractNode", "resultSchema", "resolvedColumnRef2", "tableSchemasInScope", "AbstractMagicRef", "superParentNode", "up", "tableSchemas", "t", "outer", "tableSchema", "toKind", "options", "resultJson", "LQBackBackRef", "_LQBackBackRef", "AbstractMagicRef", "registry", "reverseRef", "toKind", "options", "transformer", "schemaInference", "LQBackRef", "LQBackBackRef", "transformer", "schemaInference", "tableRefs", "ErrorRefUnknown", "toKind", "left", "qualifiedLeftEndpoint", "leftEndpointQualifier", "unqualifiedLeftEndpoint", "registry", "leftFk", "ErrorFKInvalid", "leftEndpointTable", "qualifiedLeftOperand", "resolve", "ddlName", "tableSchema", "pkColumnRef2", "$qualifiedLeftOperand", "ErrorRefAmbiguous", "statementContext", "outer", "type", "qualifiedRightTable", "unqualifiedRightOperand", "LQBackRefAbstraction", "ParenExpr", "LQBackRefEndpoint", "ColumnRef2", "LQDeepDeepRef1", "_LQDeepDeepRef1", "AbstractMagicRef", "registry", "toDeepRef", "toKind", "options", "transformer", "schemaInference", "altsMap", "currentIndex", "LQDeepDeepRef2", "LQDeepDeepRef1", "toDeepRef", "toKind", "options", "transformer", "schemaInference", "LQDeepRef1", "_LQDeepRef1", "LQDeepDeepRef1", "transformer", "schemaInference", "registry", "left", "right", "lhsOperandJson", "rhsOperandJson", "deepRef", "toKind", "detail", "qualifiedLeftOperand", "qualifiedRightTable", "unqualifiedRightOperand", "LQDeepRef2", "LQDeepRef1", "transformer", "schemaInference", "toKind", "toDeepRef", "options", "NamespaceRef", "AbstractClassicRef", "deepMatchCallback", "transformer", "schemaInference", "name", "inGrepMode", "resultSet", "resolve", "namespaceSchema", "registry", "result", "AbstractNode", "resolvedNamespaceRef1", "options", "resultJson", "TableRef1", "PathMixin", "AbstractClassicRef", "registry", "deepMatchCallback", "transformer", "schemaInference", "name", "inGrepMode", "isFromItemRef", "enclosingDerivedQuery", "canTraverseUp", "resultSet", "resolve", "tableSchema", "qualifierJson", "resolution", "result", "AbstractNode", "resolvedTableRef", "statementContext", "originalType", "inSuperScopeNow", "queryScopes", "type", "queryScope", "tempNamespaceRef", "namespaceSchema", "prev", "newQualifierJson", "compositeResult", "s", "options", "resultJson", "TableRef0", "TableRef1", "registry", "TableRef2", "TableRef1", "WindowRef", "Identifier", "BindVar", "AbstractClassicExpr", "SystemVar", "AbstractClassicExpr", "UserVar", "AbstractClassicExpr", "Expr", "AbstractClassicExpr", "ExprNamesInOrder", "instance", "expr_exports", "ExprNames", "k", "a", "b", "comp", "ColumnIdent", "PathMixin", "Identifier", "NamespaceIdent", "Identifier", "TableIdent", "PathMixin", "Identifier", "IndexDiff", "AbstractDiff", "IndexSchema", "AbstractSchema", "SchemaDiff", "AbstractDiff", "NamespaceSchema", "AbstractSchema", "result", "entry", "registry", "TableDiff", "AbstractDiff", "TableSchema", "AbstractSchema", "itemSeparator", "type", "result", "entry", "registry", "normalized", "pk", "instance", "fk", "uk", "ck", "options", "transformer", "schemaInference", "columnLockedConstraints", "consMap", "Transformer", "node", "defaultTransform", "resultJson", "DDLStmt", "AbstractStmt", "deSugar", "options", "transformer", "schemaInference", "CreateSchemaStmt", "DDLStmt", "mameRule", "pgAuthorizationRule", "pgOptionalEntiresRule", "DropSchemaStmt", "DDLStmt", "CreateTableStmt", "DDLStmt", "DropTableStmt", "DDLStmt", "dml_exports", "__export", "AssignmentExpr", "ColumnsConstructor", "ConfigAssignmentExpr", "ConfigAssignmentExprAlt1", "ConfigAssignmentExprAlt2", "DeleteStmt", "InsertStmt", "KW", "MYOnDuplicateKeyUpdateClause", "MYPartitionClause", "MYSetStmt", "MYVarAssignmentExpr", "PGConflictTarget", "PGConflictTargetIndexSpec", "PGDefaultValuesClause", "PGOnConflictClause", "PGSetStmt", "PGWhereCurrentClause", "ReturningClause", "SetClause", "TableAbstraction1", "TableAbstraction2", "UpdateStmt", "UpsertStmt", "UsingFromClause", "ValuesConstructor", "MYOnDuplicateKeyUpdateClause", "AbstractNodeList", "MYPartitionClause", "AbstractNodeList", "PGConflictTarget", "AbstractNode", "PGConflictTargetIndexSpec", "AbstractNode", "PGDefaultValuesClause", "AbstractNode", "PGOnConflictClause", "AbstractNodeList", "SelectList", "ResultSchemaMixin", "AbstractNodeList", "options", "transformer", "schemaInference", "resultJson", "resolvedOutputList", "shouldFlattenUnaliasedRootObjects", "shouldDedupe", "addOutputItem", "itemJson", "result", "existing", "_eq", "i", "selectItemJson", "columnRef", "exprJson", "aliasJson", "registry", "argPairs", "key", "value", "resultSchemas", "shouldDeSugarStars", "starsFound", "selectItems", "outputSchemas", "a", "b", "_originalStarJson", "fieldJson", "fieldNode", "ReturningClause", "SelectList", "PGWhereCurrentClause", "AbstractNode", "SetClause", "AbstractNodeList", "UsingFromClause", "AbstractNodeList", "ColumnsConstructor", "AbstractNodeList", "ValuesConstructor", "ResultSchemaMixin", "AbstractNodeList", "itemSeparator", "options", "transformer", "schemaInference", "resultJson", "row1_resultSchema", "AssignmentExpr", "BinaryExpr", "ConfigAssignmentExpr", "BinaryExpr", "ConfigAssignmentExprAlt1", "BinaryExpr", "ConfigAssignmentExprAlt2", "BinaryExpr", "MYVarAssignmentExpr", "BinaryExpr", "KW", "AbstractNode", "TableAbstraction2", "ResultSchemaMixin", "AbstractNode", "derivedAlias", "registry", "options", "transformer", "schemaInference", "resultJson", "derivedAliasJson", "namespaceIdent", "resultSchema", "applicableAliasJson", "TableAbstraction1", "ResultSchemaMixin", "AbstractNode", "derivedAlias", "registry", "options", "transformer", "schemaInference", "resultJson", "derivedAliasJson", "namespaceIdent", "resultSchema", "applicableAliasJson", "SelectorStmtMixin", "Class", "options", "transformer", "schemaInference", "ColumnRef1", "ColumnRef2", "AggrCallExpr", "LQBackRefAbstraction", "LQDeepRef1", "LQBackRef", "registry", "Transformer", "node", "defaultTransform", "keyHint", "deSugar", "asAggr", "$options", "isSpecialColumnRef1", "specialColumnRef1ToDeepRef", "columnRef", "lhsOperandJson", "rhsOperandJson", "deepRef", "toAggr", "nodeJson", "select", "detail", "detailJson", "alias", "LQRef", "lhsOperand", "rhsOperand", "rhsTable", "selectorDimensions", "CompleteSelectStmt", "DerivedQuery", "FromClause", "JoinClause", "OnClause", "GroupByClause", "GroupingElement", "FromItem", "SelectList", "SelectItem", "FromItemAlias", "SelectItemAlias", "TableRef1", "BinaryExpr", "$dimensionID", "dimensionID", "rands", "rhsOperandMask", "fieldSpec", "joinJson", "selectorDimension", "selectAlias", "resultJson", "rewrittenJoinEntries", "joinNode", "joinJson2", "childTransformer", "WhereClause", "rand", "tableExpr", "tblAliasOriginal", "tblAliasOriginal_delim", "tblAliasRewrite", "pkColumnRef", "pgGeneratedFromItem", "pgGeneratedWhereClause", "createCorrelationExpr", "selectItems", "createOrPatchAFromEntry", "_eq", "fromItem", "fieldJson", "whereExpr", "fromClause", "fromClauseClass", "fromItemNode", "DMLStmt", "AbstractNonDDLStmt", "resultJson", "transformer", "schemaInference", "options", "returningClauseJson", "registry", "DeleteStmt", "SelectorStmtMixin", "DMLStmt", "itemSeparator", "options", "transformer", "schemaInference", "Transformer", "node", "defaultTransform", "resultJson", "PayloadStmtMixin", "Class", "registry", "options", "transformer", "schemaInference", "LQDeepRef2", "AssignmentExpr", "DerivedQuery", "ColumnsConstructor", "ValuesConstructor", "TypedRowConstructor", "RowConstructor", "specials", "s", "columnList", "pgDefaultValuesClause", "valuesClause", "selectClause", "hasTopLevelDeepRefs", "c", "ignoreList", "Transformer", "node", "defaultTransform", "keyHint", "deSugar", "$options", "conflictHandlingClauseContext", "$$options", "deSugaredLhs", "deSugaredRhs", "resultJson", "rowSet", "rowsJson", "rowSetJson", "columns", "values", "payloadDimensions", "TableRef1", "ColumnRef1", "SelectItemAlias", "ColumnRef2", "DefaultLiteral", "SelectStmt", "CompleteSelectStmt", "PGDefaultValuesClause", "SelectList", "SelectItem", "FromClause", "FromItem", "jsonfy", "_deSugar", "deSugarColumnsList", "dimensionsMap", "columnRef", "columnOffset", "dimension", "deSugarValuesFromDefaultValues", "valuesRow", "valueJson", "deSugarValuesFromValues", "valuesEntries", "rowOffset", "valueNode", "deSugarValuesFromSelect", "selectStmt", "baseSelect", "baseSelectItems", "memoSelect", "memoSelectAlias", "rowNumberExpr", "newBaseSelectFromItem", "rewriteAgainstMemoSelect", "fieldJson", "obfuscateAlias", "newBaseSelectList", "selectList", "subSelectItems", "entryJson", "lhsOperandJson", "correspondingColumn", "LQRefColumn", "lhsOperand", "rhsOperand", "rhsTable", "detail", "LQBackRefAbstraction", "ReturningClause", "ValuesTableLiteral", "WhereClause", "ScalarSubquery", "SetClause", "BinaryExpr", "BoolLiteral", "NumberLiteral", "UpdateStmt", "TableAbstraction2", "baseUUID", "rhsOperandJson", "rhsTableJson", "lhsOperand1Json", "rhsOperand1Json", "rhsTable1Json", "refMode", "isDeepRef", "columnsConstructorJson", "columnsLength", "dimensionValidateRowLength", "rowNode", "result_schema", "rowLength", "createForeignBinding", "sourceUuid", "sourceCol", "sourceRowIndex", "innerFilter", "whereExpr", "whereExprRhs", "tableSpec", "onConflictUpdatedStatusAlias", "whereClause", "query", "payloadDimension", "payload", "payloadJson", "queries", "dimensionPushRow", "fKBindingJson", "lastIndex", "i", "rowJson", "queryTemplate", "selectForeignBinding", "selectJson", "fkField", "correlationRhs", "currentQuery", "isDerivedQuery", "deriveSelectAliasesFromColumns", "rhsOperandPKJson", "ColumnRef0", "AggrCallExpr", "CTE", "CTEItem", "CTEItemAlias", "cte", "$transformer", "toCTEItem", "dimensionID", "queryJson", "indices", "cteItemJson", "flipSelectFromWithRowNumbers", "dependents", "deferedDependencies", "lefts", "onConflictUpdatedStatusRequired", "originalReturningList", "$query", "uuid", "existing", "_eq", "fieldExpr", "wherePredicate", "cteReturningList", "newOuterReturningList", "cteReturningClause", "selectItems", "instance", "prev", "C", "newSelectList", "fromName", "rowNumberJson", "fromItemJson", "alias", "InsertStmt", "PayloadStmtMixin", "DMLStmt", "optional_alias_postgres", "optional_alias_mysql", "options", "transformer", "schemaInference", "Transformer", "node", "defaultTransform", "registry", "subResultJson", "resultSchema", "resultJson", "toDialect", "pkColumn", "MYSetStmt", "AbstractNodeList", "deSugar", "options", "transformer", "schemaInference", "PGSetStmt", "BinaryExpr", "deSugar", "options", "transformer", "schemaInference", "UpdateStmt", "PayloadStmtMixin", "SelectorStmtMixin", "DMLStmt", "options", "transformer", "schemaInference", "deferedTransforms", "Transformer", "node", "defaultTransform", "registry", "resultJson", "pkColumn", "UpsertStmt", "SugarMixin", "InsertStmt", "resultJson", "transformer", "schemaInference", "options", "tableSchema", "t", "toDialect", "columnNamesJson", "e", "c", "conflictHandlingClause", "registry", "uniqueKeysColumnSets", "k", "firstUniqueKeysColumnSet", "colSet", "_eq", "dql_exports", "__export", "BasicSelectStmt", "CompleteSelectStmt", "CompositeSelectStmt", "DerivedQuery", "DistinctClause", "ForClause", "FromClause", "FromItem", "FromItemAlias", "GroupByClause", "GroupingElement", "HavingClause", "JoinClause", "LimitClause", "OffsetClause", "OnClause", "OrderByClause", "OrderElement", "PGFetchClause", "PGOrderOperator", "PartitionByClause", "SRFExpr1", "SRFExpr2", "SRFExpr3", "SRFExpr4", "SRFExprDDL1", "SRFExprDDL2", "SelectItem", "SelectItemAlias", "SelectList", "SelectStmt", "TableStmt", "UsingClause", "ValuesTableLiteral", "WhereClause", "WindowClause", "WindowDeclaration", "WindowFrameBound", "WindowFrameSpec", "WindowSpec", "DistinctClause", "AbstractNode", "ForClause", "AbstractNode", "FromClause", "AbstractNodeList", "GroupByClause", "AbstractNodeList", "GroupingElement", "AbstractNode", "HavingClause", "AbstractNode", "FromItem", "ResultSchemaMixin", "AbstractNode", "itemSeparator", "derivedAliasJson", "registry", "options", "transformer", "schemaInference", "resultJson", "namespaceIdent", "resultSchema", "s", "Transformer", "node", "defaultTransform", "key", "applicableAliasJson", "JoinClause", "FromItem", "options", "transformer", "schemaInference", "conditionClauseTransform", "Transformer", "node", "defaultTransform", "keyHint", "resultJson", "LimitClause", "AbstractNode", "OffsetClause", "AbstractNode", "OnClause", "AbstractNode", "OrderByClause", "AbstractNodeList", "OrderElement", "AbstractNode", "PartitionByClause", "AbstractNodeList", "PGFetchClause", "AbstractNode", "PGOrderOperator", "AbstractNode", "UsingClause", "AbstractNode", "WhereClause", "AbstractNode", "WindowClause", "AbstractNodeList", "WindowDeclaration", "AbstractNode", "WindowFrameSpec", "AbstractNode", "itemSeparator", "WindowFrameBound", "AbstractNode", "WindowSpec", "AbstractNode", "FromItemAlias", "Identifier", "itemSeparator", "options", "transformer", "schemaInference", "resultJson", "SelectItem", "_SelectItem", "ResultSchemaMixin", "AbstractNode", "derivedAliasJson", "exprNode", "registry", "endpointNode", "isToPG", "options", "transformer", "schemaInference", "derivedAliasNode", "asAggr", "$options", "defaultExprTransform", "childTransformer", "exprJson", "namespaceIdent", "resultSchema", "tableSchema", "applicableAliasJson", "SelectItemAlias", "Identifier", "options", "transformer", "schemaInference", "resultJson", "SRFExpr1", "ResultSchemaMixin", "AbstractNode", "options", "transformer", "schemaInference", "resultJson", "columnDefsJson", "resultSchema", "registry", "SRFExpr2", "ResultSchemaMixin", "AbstractNode", "options", "transformer", "schemaInference", "resultJson", "resultSchema", "ordinalityColumn", "registry", "schemaIdentFromFuncName", "resultSchema_json", "SRFExpr3", "ResultSchemaMixin", "AbstractNode", "options", "transformer", "schemaInference", "resultJson", "resultSchema", "registry", "givenSchema", "schemaIdentFromFuncName", "SRFExpr4", "ResultSchemaMixin", "AbstractNodeList", "options", "transformer", "schemaInference", "resultJson", "colIdx", "entries", "exprJson", "exprJsonEntries", "x", "registry", "resultSchema", "SRFExprDDL1", "AbstractNode", "SRFExprDDL2", "AbstractNode", "ValuesTableLiteral", "ValuesConstructor", "SelectStmt", "AbstractNonDDLStmt", "part", "part1", "extRules", "part2", "registry", "BasicSelectStmt", "SelectorStmtMixin", "SelectStmt", "options", "transformer", "schemaInference", "deferedTransforms", "Transformer", "node", "defaultTransform", "keyHint", "registry", "childNode", "defaultChildTransform", "subKeyHint", "e", "ErrorRefUnknown", "resultJson", "selectListJson", "_", "_resultJson", "fieldName", "deferreds", "resolveds", "deferred", "CompleteSelectStmt", "BasicSelectStmt", "CompositeSelectStmt", "SelectStmt", "operandTypes", "options", "transformer", "schemaInference", "deferedTransforms", "Transformer", "node", "defaultTransform", "registry", "resultJson", "resultSchema", "order_by_clause", "tokenStream", "syntaxRules", "left", "minPrecedence", "trail", "resultAST", "trailTail", "current", "message", "TableStmt", "AbstractNonDDLStmt", "options", "transformer", "schemaInference", "resultJson", "tableSchema", "registry", "qualif_exports", "__export", "AggrNotation", "LQVersionSpec", "AggrNotation", "AbstractNode", "LQVersionSpec", "AbstractNode", "type_exports", "__export", "DataType", "DataType", "AbstractNode", "JSONSchema", "AbstractNodeList", "StdStmt", "_StdStmt", "AbstractStmt", "inputJson", "options", "callback", "nodeName", "restJson", "transformer", "schemaInference", "sql", "test", "TokenStream", "_sql", "render", "tokenStream", "tok", "tag", "Script", "AbstractNodeList", "itemSeparator", "input", "options", "tokenStream", "result", "current", "message", "syntaxRules", "left", "minPrecedence", "trail", "resultAST", "rulesArray", "r", "registry", "cte_exports", "ddl_exports", "dml_exports", "dql_exports", "expr_exports", "qualif_exports", "type_exports", "StdStmt", "Script", "JSONSchema", "SimpleEmitter", "#listeners", "#closeCallbacks", "event", "fn", "payload", "err", "SchemaInference", "#searchPath", "#driver", "#queryHistory", "#catalog", "#options", "driver", "catalog", "options", "selector", "currentEntries", "diffedSelectors", "intersectionFound", "pendingFulfilments", "newRecords", "match", "a", "b", "matchRelationSelector", "order", "x", "admit", "namespaceName", "tables", "newTableList", "newRecord", "diff", "currentEntries_sorted", "namespaceNameSpec", "existingRecord", "diffedTables", "t", "normalizeRelationSelectorArg", "objectNames", "currentFulfilment", "totalFulfilment", "resultSchemas", "resultSchema", "newNamespaceSchema", "NamespaceSchema", "existingNamespaceSchema", "existingTableSchema", "AbstractClient", "SimpleEmitter", "#subscribers", "#schemaInference", "#capabilityOverride", "#workingCapability", "capability", "SchemaInference", "querySpec", "alias", "dynamicWhereMode", "options", "query", "args", "selector", "structured", "callback", "flattenedSelectorSet", "normalizeRelationSelectorArg", "capMap", "_capMap", "k", "v", "events", "eventsAndPatterns", "allPatterns", "event", "patterns", "cb", "_events", "pattern", "Result", "#rows", "#rowCount", "rows", "rowCount", "RealtimeResult", "Result", "#hashes", "#abortLine", "rows", "hashes", "abortLine", "signal", "eventName", "eventData", "Obs", "$rows", "event", "i", "_rows", "_hashes", "hash", "targetHash", "i_a", "i_b", "maxLen", "_eq", "TBL_PLACEHOLDER", "GROUPING_META", "WINDOW_META", "ExprEngine", "#derivedQueryCallback", "#options", "derivedQueryCallback", "options", "node", "compositeRow", "queryCtx", "handler", "expr", "registry", "rows", "row", "values", "r", "entries", "e", "x", "AbstractNode", "toNode", "result", "alias", "value", "col", "colName", "caliases", "a", "v", "_eq", "subject", "partialModeBranches", "branch", "condition", "alternate", "dataType", "L", "predicate", "R", "negation", "val", "logic", "op", "asPartial", "res", "compare", "likeCompare", "quantifier", "key", "contains", "b", "i", "k", "fn", "args", "arr", "meta", "getBit", "arg", "bitIndex", "mask", "bit", "fieldName", "prev", "cur", "buildObj", "metaData", "window", "frameStart", "frameEnd", "offset", "cnt", "j", "entry", "sum", "keyExpr", "valExpr", "obj", "delimiter", "myKeysHash", "rank", "otherKeysHash", "total", "seen", "buckets", "baseSize", "remainder", "threshold", "bucketSize", "lastIndex", "lagBy", "defaultValue", "targetIndex", "leadBy", "n", "qualName", "table", "clause", "selectList", "refedExpr", "si", "decorated", "orderElements", "idDesc", "dir", "nullsSpec", "valA", "valB", "aIsNull", "bIsNull", "str", "pattern", "esc", "QueryWindow", "_QueryWindow", "SimpleEmitter", "query", "analysis", "registry", "relationHashes", "grepFromItems", "resulutionLevel", "alias", "acquireTableRef", "fromItemsBySchema", "n", "tableRef", "tableName", "namespaceName", "fromItems", "query1", "query2", "subwindowingRules", "specialClauses", "clauses_a", "c", "clauses_b", "clauseName", "matchExpr", "selectMapping", "selectItems_a", "selectItems_b", "b", "i_a", "a", "effectiveWhere", "aWhere", "bWhere", "_effectiveWhere", "aOrd", "bOrd", "i", "effectiveOffset", "aOffs", "bOffs", "aLmt", "bLmt", "#driver", "#options", "#status", "#abortLine", "#exprEngine", "#queryCtx", "#query", "#queryJson", "#analysis", "#strategy", "#subwindowingRules", "#logicalQuery", "#logicalQueryJson", "#originAliases", "#originSchemas", "#parentWindow", "#subwindowConstraints", "#inheritanceDepth", "#localRecords", "#firstRun", "#resolvedOrderElements", "#fromJsonOpts", "driver", "options", "self", "ExprEngine", "derivedQuery", "compositeRow", "queryCtx", "stmt", "row", "selectItem", "value", "strategy", "parentWindow", "_eq", "result", "#initializeAsSub", "#initializeAsRoot", "getJson", "node", "delim", "originSchema", "os", "$columns", "$keyColumns", "usingAllColumnsForKeyColumns", "e", "relation", "namespace", "name", "newOrderElementsJson", "oi", "newQueryHead", "acc", "aliasJson", "createColKeyValJson", "colJson", "keyJson", "colRefJson", "fnName", "fnArgs", "colKeyValJsons", "aliasColsExpr", "aliasKeyJson", "originalsArgs", "si", "originalsJson", "keysJson", "ordsJson", "select_list", "order_by_clause", "events", "#handleEvents", "abortLine1", "resultRecords", "#applySubwindowConstraints", "#commitResult", "abortLine2", "diffEvents", "_diffEvents", "diffEvent", "passesWhere", "#applySubwindowWheres", "#commitDiffs", "resultEntries", "logicalHash", "logicalRecord", "#applySorting", "effectiveLimit", "expr", "rows", "hashes", "#renderLogicalRecord", "#queryHeadless", "extraWhere", "logicalQuery", "deriveSelectItem", "logicalQueryJson", "finalWhereJson", "resultMap", "#deriveLogicalHash", "#getKeyValue", "k", "newKeysList", "_newKeys", "s", "#stringifyLogicalHash", "keyValues", "#parseLogicalHash", "#localSet", "#localDelete", "#localReindex", "idChanges", "id", "renderedValues", "#normalizeEvents", "normalizedEventsMap", "keyHistoryMap", "allAffectedAliases", "relationHash", "affectedAliasesEntries", "affectedAliases", "keyColumns", "oldKeys", "newKeys", "normalizedEvent", "rowKeyHash_old", "rowKeyHash_new", "previous", "_normalizedEvent", "#diffWithOrigin_Wholistic", "normalizeEvents", "#diffWithLocal", "#diffWithOrigin_Selective", "newHash", "oldHash", "composeSelectionLogic", "nullTest", "operands", "keyColumn", "left", "right", "columnRef", "nullLiteral", "isNullExpr", "valueLiteral", "eqExpr", "orExpr", "localRecords", "remoteDiffingFilters", "diffingFilters", "top", "diffingFilters_currentEvent", "diffingFilters_allEvents", "_diffingFilters_allEvents", "resolveTransition", "matches", "oldHash_parsed", "possibleEventId", "remoteRecords", "#createDiffs", "parseRemoteRecords", "v", "remoteRecords_parsed", "logicalHash_existing", "logicalRecord_existing", "logicalRecord_new", "logicalHash_new", "outputEvents", "deferredInserts", "render", "outputEvent", "effectiveHash", "swaps", "reorderedLocalRecords", "sortedEntries", "originalEntires", "splicedHashes", "excess", "origianlLogicalKeys", "reorderedLocalKeys", "oldIdx", "newIdx", "targetHash", "emit", "logicalRecords", "withEntries", "entries", "decorated", "entry", "keys", "orderElement", "_entries", "RealtimeClient", "#windows", "#driver", "driver", "AbstractSQLClient", "args", "query", "callback", "signal", "options", "normalizeQueryArgs", "registry", "queryWindow", "resultJson", "realtimeResult", "RealtimeResult", "abortLines", "c", "changeHandler", "eventName", "eventData", "newWindow", "QueryWindow", "windows_depthFirst", "b", "potentialSubWindows", "potentialParentWindow", "potentialSubWindow", "AbstractSQLClient", "AbstractClient", "#realtimeClient", "capability", "RealtimeClient", "querySpec", "alias", "dynamicWhereMode", "options", "wrapORLogic", "exprJson", "registry", "query", "baseAlias", "baseFromItem", "tableExpr", "queryJson", "baseExpr", "dynamicWhere", "transformer", "Transformer", "node", "defaultTransform", "bodyResultJson", "toExpr", "val", "tblName", "namespaceName", "tableRefJson", "payload", "columnNames", "columns", "colName", "row", "_columnNames", "rowJson", "_payload", "assignmentJson", "selectItems", "acc", "key", "left", "right", "AbstractNode", "AbstractStmt", "relationSelector", "anyFound", "v", "k", "scope", "tableName", "args", "_query", "normalizeQueryArgs", "result", "Result", "selector", "structured", "AbstractFetchClient", "AbstractClient", "requestSpec", "alias", "dynamicWhereMode", "options", "request", "args", "_request", "normalizeQueryArgs", "selector", "structured", "ConflictError", "#existing", "message", "existing", "TableStorage", "SimpleEmitter", "#name", "#schema", "#parentNode", "#materialized", "#querySpec", "#options", "#columns", "#keyColumns", "#keys", "#rows", "#counters", "schema", "parentNode", "materialized", "querySpec", "options", "pkCols", "pkRef", "pkCol", "events", "v", "k", "#nextCounter", "colName", "keyName", "type", "columns", "#computeKeys", "row", "forInsert", "keyValues", "colSchema", "autoIncr", "isPKey", "pKey", "#resolveKey", "key", "newKey", "transaction", "existing", "ConflictError", "_pKey", "i", "outRow", "rowOrKey", "oldPKey", "newPKey", "old", "reIndexed", "StorageNamespace", "SimpleEmitter", "#name", "#parentNode", "#type", "#mirrored", "#origin", "#options", "#tables", "name", "parentNode", "type", "mirrored", "origin", "options", "events", "selector", "list", "tableName", "tableStorage", "tableSchema", "ifNotExists", "primaryKey", "autoIncr", "dialect", "tableOptions", "keyCol", "registry", "TableStorage", "ifExists", "cascade", "StorageEngine", "SimpleEmitter", "#searchPath", "#options", "#catalog", "#init", "searchPath", "options", "txIdPrefix", "events", "txId", "eventName", "event", "name", "_events", "selector", "list", "ns", "nsObj", "namespaceName", "ifNotExists", "namespaceOptions", "ConflictError", "namespaceObject", "StorageNamespace", "ifExists", "cascade", "mirroredNamespacesEntries", "tablesEntries", "tableName", "tableStorage", "TBL_PLACEHOLDER", "GROUPING_META", "WINDOW_META", "QueryEngine", "SimpleEmitter", "#storageEngine", "#exprEngine", "#options", "storageEngine", "dialect", "options", "self", "ExprEngine", "derivedQuery", "compositeRow", "queryCtx", "queryString", "result", "_queryCtx", "#evaluateSTMT", "_result", "copy", "row", "scriptNode", "returnValue", "rows", "r", "stmtNode", "registry", "#evaluatePG_SET_STMT", "#evaluateCREATE_SCHEMA_STMT", "#evaluateALTER_SCHEMA_STMT", "#evaluateDROP_SCHEMA_STMT", "#evaluateCREATE_TABLE_STMT", "#evaluateALTER_TABLE_STMT", "#evaluateDROP_TABLE_STMT", "#evaluateCTE", "#evaluateINSERT_STMT", "#evaluateUPDATE_STMT", "#evaluateDELETE_STMT", "#evaluateTABLE_STMT", "#evaluateSELECT_STMT", "#evaluateCOMPOSITE_SELECT_STMT", "scopeKW", "left", "right", "searchPath", "nsName", "createOpts", "__queryCtx", "entry", "namespaceNames", "n", "dropOpts", "argument", "namespaceObject", "tableNames", "tblName", "cteRegistry", "cteItem", "cteName", "itemBody", "cteStream", "_", "tableAlias", "tableStorage", "tableSchema", "definedColumns", "col", "columnNames", "defaultRecord", "colName", "colSchema", "records", "rowConstructor", "record", "defaultContext", "i", "valExpr", "defaultConstraint", "colValue", "#acquireValue", "stream", "_record", "colIdx", "targetColName", "renderedLogicalRecord", "#renderSetClause", "rowCount", "returnList", "conflictHandlingClause", "returningClause", "finalizedRecord", "e", "ConflictError", "newLogicalRecord", "outputRecordContext", "selectItem", "alias", "value", "fromItems", "joinClauses", "updateTargets", "item", "tableRef", "tableExpr", "setClause", "logicalRecord", "deleteTargets", "_combinedFromItems", "fromItem", "fi", "originSchemas", "baseAlias", "acquireValue", "os", "assignmentExpr", "colNode", "correspondingRight", "qualif", "isSkipConstraints", "aggrFunctions", "winFunctions", "v", "groupByClause", "havingClause", "selectList", "groupingElements", "windowDefs", "w", "orderByClause", "orderElements", "limitClause", "offsetClause", "fromClause", "fromEntries", "allItems", "_originSchema", "aliasName", "firstItem", "firstItemAlias", "nsDef", "tblDef", "#isRemoteRef", "remoteStream", "remoteQuery", "AbstractFetchClient", "leftStream", "idx", "leftAlias", "rightItem", "rightAlias", "rightSchema", "joinType", "isLateral", "joinCondition", "leftSchema", "lCols", "columns", "all", "rc", "lc", "#usingToExpr_Transform", "createRightStream", "createRemoteStream", "#deriveCreateRemoteStream", "lateralCtx", "rightStream", "#memoizeStream", "joinStrategy", "conditionExpr", "remoteQuery_Where", "pushdownSize", "memo", "masterLeftStream", "$i", "concatWhere", "$pushDownLogic", "someTruthy", "leftComp", "pushDownLogic", "AbstractNode", "fromItemExpr", "callback", "buffer", "q", "acc", "ident", "identJson", "logicalExpr", "originSchema", "expectedColWidth", "entries", "actualColWidth", "_row", "key", "createSRFGenerator", "callExpr", "funcResult", "asyncIter", "createSRFGenerator2", "columnDefs", "values", "withOrdinality", "rowIdx", "asyncIters", "colWidths", "allDone", "j", "nullFill", "baseComp", "aliases", "leftAliasSet", "rightMatches", "k", "leftMatched", "rightComp", "fullMergedComp", "rightRef", "_rightRef", "matched", "whereClause", "upstream", "comp", "flattenRowConstructor", "expr", "expandElement", "elem", "sets", "mask", "subset", "getAtomicExprs", "groupingSets", "topEntryAtomicMap", "atomic", "groups", "setIndex", "set", "keyVals", "aExpr", "window", "rep", "groupingColumnsMap", "_add", "colRef", "child", "exprToTopIndex", "exprNode", "tableRow", "winFnMap", "winFn", "over", "effectiveSpec", "namedSpec", "baseSpec", "winHash", "partitions", "rowsAreReps", "rowToRepMap", "originalRep", "originalRow", "ordered", "orderedArray", "decorated", "isDecorated", "keys", "frameStart", "frameEnd", "#computeFrameBounds", "d", "rowIndex", "frameSpec", "total", "specifier", "start", "end", "clamp", "myValue", "getValue", "peerStart", "peerEnd", "adjustBound", "bound", "isStart", "ref", "refTime", "shifted", "getHash", "currentGroup", "lastHash", "h", "groupIndex", "g", "startGroup", "endGroup", "projected", "fieldIdx", "withKeys", "orderElement", "limit", "offset", "yielded", "evaluateOperand", "operand", "resultSchema", "operandJson", "leftRows", "rightRows", "leftOutputCols", "rightOutputCols", "mappers", "leftCol", "rightCol", "leftType", "rightType", "coercedType", "#resolveCommonType", "coercedLeft", "coercedRight", "#coerceRowToAliases", "operator", "modifier", "resultRows", "rowHash", "hashSymbol", "count", "arr", "counts", "map", "leftCount", "rightCount", "nLeft", "nRight", "times", "exemplar", "coerced", "name", "val", "numeric", "refedValue", "throwRefError", "index", "FlashQL", "AbstractSQLClient", "#dialect", "#storageEngine", "#queryEngine", "#onCreateRemoteClient", "#remoteClients", "#realtimeAbortLine", "dialect", "capability", "onCreateRemoteClient", "options", "storageEngine", "StorageEngine", "QueryEngine", "query", "unmaterializedMirrors", "effectiveMirrorsSpec", "resolutionHint", "v", "nsName", "tblName", "registry", "nsDef", "tblDef", "lastClient", "closed", "rows", "row", "selector", "structured", "normalizeRelationSelectorArg", "namespaceSchemas", "objectNames", "arr", "_namespaceName", "matchRelationSelector", "namespaceJson", "namespaceObject", "tableSchemaJson", "events", "callback", "abortLines", "relationSelector", "localMap", "remoteMapMap", "tblNames", "remoteTablesMap", "remoteNsName", "remoteClient", "e", "c", "args", "specifiers", "origin", "#normalizeMirroringSpec", "#federate", "#materialize", "#sync", "materializeCallback", "queryCtx", "queryObjects", "querySpec", "tableSchema", "tableStorage", "keyOpts", "stream", "hashes", "result", "AbstractFetchClient", "eventName", "eventData", "#handleInSync", "i", "ConflictError", "#handleOutSync", "event", "displaced", "hash", "targetHash", "sourceRecord", "targetRedord", "keys", "allKeys", "existing", "outQueryObjects", "outQueryObject", "key", "k", "allowQueries", "spec", "subSpec", "tableSpec"]
}
