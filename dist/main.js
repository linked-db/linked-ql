(()=>{var Rs=Object.defineProperty;var ne=(a,e)=>{for(var r in e)Rs(a,r,{get:e[r],enumerable:!0})};var Br={};ne(Br,{CTE:()=>Be,CTEBinding:()=>$e,PGCycleClause:()=>Me,PGSearchClause:()=>Pe});function $(a){return!Array.isArray(a)&&typeof a=="object"&&a}function oe(a,e,r=null,t=null){if(Array.isArray(a)&&Array.isArray(e))return a.length===e.length&&(e=e.slice(0).sort())&&a.slice(0).sort().every((n,o)=>oe(n,e[o],r,t));if(typeof a?.jsonfy=="function"&&(a=a.jsonfy()),typeof e?.jsonfy=="function"&&(e=e.jsonfy()),$(a)&&$(e)){let n={indexs_a:Object.keys(a),indexs_b:Object.keys(e)};if(t?.length){let o=[].concat(t);n.indexs_a=n.indexs_a.filter(s=>!o.includes(s)),n.indexs_b=n.indexs_b.filter(s=>!o.includes(s))}return n.indexs_a.length===n.indexs_b.length&&n.indexs_a.reduce((o,s)=>o&&oe(a[s],e[s],r,t),!0)}return typeof a=="string"&&typeof e=="string"&&r==="ci"?a.toLowerCase()===e.toLowerCase():a===e}function ns(a){let e=a.replace(/([a-z0-9])([A-Z])/g,"$1_$2");return e=e.replace(/([A-Z])([A-Z][a-z])/g,"$1_$2"),e.toUpperCase()}var Mr={};ne(Mr,{TOK_TYPES:()=>ve,aggrFunctionNames:()=>Ls,dataTypes:()=>Ms,functionNames:()=>Ds,keywords:()=>Is,operators:()=>Ps,statements:()=>ks});var ve={data_type:{type:"data_type",value:void 0,resolve(){return this}},identifier:{type:"identifier",value:void 0,delim:[void 0],resolve({dialect:a,mysqlAnsiQuotes:e}={}){return{...this,delim:this.delim.concat(a==="mysql"?e?['"',"`"]:["`"]:['"'])}}},keyword:{type:"keyword",value:void 0,resolve(){return this}},operator:{type:"operator",value:void 0,prec:void 0,assoc:void 0,resolve(){return this}},punctuation:{type:"punctuation",value:void 0,resolve(){return this}},string_literal:{type:"string_literal",value:void 0,delim:["'"],modifier:[void 0],resolve({dialect:a,mysqlAnsiQuotes:e}={}){return{...this,delim:this.delim.concat(a==="mysql"?e?[]:['"']:[/^(\$\$|\$[a-zA-Z_][a-zA-Z0-9_]*\$)$/]),modifier:this.modifier.concat(a==="mysql"?["N"]:["E"])}}},number_literal:{type:"number_literal",value:void 0,match({value:a}){return!!/^[+-]?(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?$/.test(a)}},null_literal:{type:"null_literal",value:void 0,resolve(){return this}},unknown_literal:{type:"unknown_literal",value:void 0,resolve(){return this}},bool_literal:{type:"bool_literal",value:void 0,resolve(){return this}},hex_literal:{type:"hex_literal",value:void 0,resolve(){return this}},bit_literal:{type:"bit_literal",value:void 0,resolve(){return this}},bind_var:{type:"bind_var",value:void 0,delim:[],resolve({dialect:a}={}){return{...this,delim:this.delim.concat(a==="mysql"?["?"]:["$"])}}},version_spec:{type:"version_spec",value:void 0,delim:[void 0,"'"],resolve(){return this}},user_var:{type:"user_var",value:void 0,delim:[void 0],resolve({dialect:a}={}){return{...this,delim:this.delim.concat(a==="mysql"?["'"]:[])}}},system_var:{type:"system_var",value:void 0,resolve(){return this}},brace_block:{type:"brace_block",value:void 0,resolve(){return this}},bracket_block:{type:"bracket_block",value:void 0,resolve(){return this}},parent_block:{type:"paren_block",value:void 0,resolve(){return this}},block_comment:{type:"block_comment",value:void 0,resolve(){return this}},line_comment:{type:"line_comment",value:void 0,delim:["--"],resolve({dialect:a}={}){return{...this,delim:this.delim.concat(a==="mysql"?["#"]:[])}}}},ks={common:["ALTER","CREATE","DROP","SELECT","INSERT","UPSERT","UPDATE","MERGE","DELETE","BEGIN","COMMIT","ROLLBACK","RELEASE","DESCRIBE","EXPLAIN","USE"],postgres:["ANALYZE","CLUSTER","COMMENT ON","REFRESH","REINDEX","VACUUM"],mysql:["ANALYZE","FLUSH","LOCK","OPTIMIZE","RENAME","REPAIR","RESET","SET","SHOW","TRUNCATE","UNLOCK"]},Is={common:["ALL","ON","NO","KEY","ANY","AS","BY","ASC","CASE","CAST","DEFAULT","DESC","DO","DISTINCT","ELSE","END","ESCAPE","FIRST","LAST","FOLLOWING","FOR","HAVING","FILTER","SHARE","JOIN","SEPARATOR","SKIP","LOCKED","NOWAIT","OF","RECURSIVE","LIMIT","LOAD","NEXT","NOTHING","NULLS","OFFSET","ONLY","TIES","OVER","PARTITION","PRECEDING","RANGE","RETURNING","ROW","ROWS","EXCLUDE","SET","SOME","THEN","USING","MATERIALIZED","MODE","DATABASE","TABLE","COLUMN","INDEX","SEQUENCE","TRIGGER","VIEW","SAVEPOINT","VALUES","WHEN","WHERE","WINDOW","WITH","WITHOUT","TO","INTO","FROM","GROUP","ORDER","PARTITION","BREADTH","DEPTH","INNER","LEFT","RIGHT","OUTER","FULL","CROSS","NATURAL","NO OTHERS","ROLLUP","UNBOUNDED","CURRENT ROW","GROUPS","IGNORE","RESPECT"],postgres:["ARRAY","GROUPING SETS","CUBE","TABLESAMPLE","REPEATABLE","SEARCH","LATERAL","ORDINALITY","OVERLAPS","SIMILAR","BERNOULLI","SYSTEM","TABLESPACE","UNLOGGED","PERFORM","CURRENT OF","TYPE","EXTENSION","IMMUTABLE","STABLE","VOLATILE","CYCLE","CONFLICT","TIME ZONE","FETCH","LOCAL"],mysql:["LOCK","RENAME","REPLACE","SHOW","UNLOCK","HIGH_PRIORITY","CACHE","SQL_CACHE","SQL_NO_CACHE","STRAIGHT_JOIN","DATABASES","TABLES","COLUMNS","STATUS","PROCEDURE","FUNCTION","AUTO_INCREMENT","CHARACTER SET","ENGINE","VALUE","DUPLICATE"]},Ds={common:["NOW","CURRENT_DATE","CURRENT_TIME","CURRENT_TIMESTAMP","IF","NULLIF","IFNULL","COALESCE","GREATEST","LEAST","CONCAT","GROUPING","CONCAT_WS","FORMAT","MD5","SHA1","ST_ASTEXT","ST_ASGEOJSON","ST_GEOMFROMTEXT","ST_WITHIN","ST_CONTAINS","ST_INTERSECTS","ST_DISTANCE","ST_BUFFER"],postgres:["MAKE_DATE","MAKE_TIME","MAKE_TIMESTAMP","TO_JSON","TO_JSONB","JSON_TYPEOF","JSONB_TYPEOF","JSON_BUILD_ARRAY","JSONB_BUILD_ARRAY","JSON_BUILD_OBJECT","JSONB_BUILD_OBJECT","JSON_POPULATE_RECORD","JSONB_POPULATE_RECORD","JSON_PATH_QUERY","JSON_PATH_EXISTS"],mysql:["CURDATE","CURTIME","SYSDATE","STR_TO_DATE","MAKEDATE","MAKETIME","JSON_ARRAY","JSON_OBJECT","JSON_EXTRACT","JSON_UNQUOTE","JSON_SET","JSON_INSERT","JSON_REPLACE","JSON_REMOVE","JSON_SEARCH","JSON_CONTAINS","JSON_CONTAINS_PATH","JSON_KEYS","JSON_ARRAY_APPEND","JSON_ARRAY_INSERT","JSON_DEPTH","JSON_LENGTH","JSON_MERGE_PRESERVE","JSON_MERGE_PATCH","JSON_PRETTY","JSON_STORAGE_FREE"]},Ls={common:["COUNT","SUM","AVG","MIN","MAX","COVAR_POP","COVAR_SAMP","CORR","ROW_NUMBER","BIT_AND","BIT_OR","STDDEV_POP","STDDEV_SAMP","VAR_POP","VAR_SAMP","VARIANCE","STD","LEAD","LAG","NTILE","FIRST_VALUE","LAST_VALUE"],postgres:["ARRAY_AGG","STRING_AGG","REGR_SLOPE","PERCENTILE_CONT","PERCENTILE_DISC","MODE","RANK","DENSE_RANK","EVERY","BOOL_AND","BOOL_OR","JSON_AGG","JSON_OBJECT_AGG","JSONB_OBJECT_AGG","XMLAGG"],mysql:["GROUP_CONCAT","BIT_XOR","JSON_ARRAYAGG","JSON_OBJECTAGG"]},Ms={common:["SMALLINT","INTEGER","INT","BIGINT","DECIMAL","DEC","NUMERIC","REAL","FLOAT","DATE","TIME","TIMESTAMP","INTERVAL","CHAR","CHARACTER","VARCHAR","TEXT","BINARY","VARBINARY","BOOLEAN","JSON","GEOMETRY","POINT","LINESTRING","POLYGON","DOUBLE PRECISION","CHARACTER VARYING"],postgres:["SERIAL","BIGSERIAL","MONEY","BIT","CIDR","INET","MACADDR","MACADDR8","TIMESTAMPTZ","TIMETZ","TSVECTOR","TSQUERY","UUID","XML","INT4RANGE","INT8RANGE","NUMRANGE","TSRANGE","TSTZRANGE","DATERANGE","BOX","PATH","CIRCLE","LINE","LSEG","POLYGON","OID","BIT VARYING","JSONB","REGCLASS"],mysql:["TINYINT","MEDIUMINT","BIT","YEAR","DATETIME","TINYTEXT","QUERY","MEDIUMTEXT","LONGTEXT","TINYBLOB","BLOB","MEDIUMBLOB","LONGBLOB","ENUM","GEOMETRYCOLLECTION","MULTIPOINT","MULTILINESTRING","MULTIPOLYGON","BOOL"]},Ps={common:[["<~",{prec:90,assoc:"left"}],["~>",{prec:90,assoc:"right"}],["BETWEEN",{prec:85,assoc:"left"}],["EXISTS",{prec:83,assoc:"left"}],["UNIQUE",{prec:83,assoc:"left"}],["NOT",{prec:80,assoc:"right"}],["*",{prec:70,assoc:"left"}],["/",{prec:70,assoc:"left"}],["%",{prec:70,assoc:"left"}],["+",{prec:60,assoc:"left"}],["-",{prec:60,assoc:"left"}],["&",{prec:60,assoc:"left"}],["|",{prec:60,assoc:"left"}],["<<",{prec:60,assoc:"left"}],[">>",{prec:60,assoc:"left"}],["=",{prec:50,assoc:"left"}],["!=",{prec:50,assoc:"left"}],["<>",{prec:50,assoc:"left"}],["<",{prec:50,assoc:"left"}],["<=",{prec:50,assoc:"left"}],[">",{prec:50,assoc:"left"}],[">=",{prec:50,assoc:"left"}],["IS",{prec:50,assoc:"left"}],["IS NOT",{prec:50,assoc:"left"}],["DISTINCT FROM",{prec:50,assoc:"left"}],["IN",{prec:50,assoc:"left",negatable:!0}],["LIKE",{prec:50,assoc:"left",negatable:!0}],["AND",{prec:40,assoc:"left"}],["OR",{prec:30,assoc:"left"}],["INTERSECT",{prec:20,assoc:"left"}],["UNION",{prec:10,assoc:"left"}],["EXCEPT",{prec:10,assoc:"left"}]],postgres:[["COLLATE",{prec:83,assoc:"left"}],["||",{prec:60,assoc:"left"}],["::",{prec:100,assoc:"left"}],["AT",{prec:95,assoc:"left"}],["^",{prec:90,assoc:"left"}],["#",{prec:60,assoc:"left"}],["->",{prec:80,assoc:"left"}],["->>",{prec:80,assoc:"left"}],["#>",{prec:80,assoc:"left"}],["#>>",{prec:80,assoc:"left"}],["@>",{prec:80,assoc:"left"}],["<@",{prec:80,assoc:"left"}],["?",{prec:80,assoc:"left"}],["?|",{prec:80,assoc:"left"}],["?&",{prec:80,assoc:"left"}],["-@",{prec:80,assoc:"left"}],["#-",{prec:80,assoc:"left"}],["@?",{prec:80,assoc:"left"}],["@@",{prec:80,assoc:"left"}],["ILIKE",{prec:50,assoc:"left",negatable:!0}],["~",{prec:50,assoc:"left"}],["!~",{prec:50,assoc:"left"}],["~*",{prec:50,assoc:"left"}],["!~*",{prec:50,assoc:"left"}],["SIMILAR TO",{prec:50,assoc:"left"}],["&&",{prec:60,assoc:"left"}],["<->",{prec:60,assoc:"left"}],["@",{prec:60,assoc:"left"}],["&<",{prec:60,assoc:"left"}],["&>",{prec:60,assoc:"left"}],["|-",{prec:60,assoc:"left"}],["-|",{prec:60,assoc:"left"}],["<<",{prec:60,assoc:"left"}],[">>",{prec:60,assoc:"left"}],["<<|",{prec:60,assoc:"left"}],["|>>",{prec:60,assoc:"left"}],["&<|",{prec:60,assoc:"left"}],["|&>",{prec:60,assoc:"left"}],["~=",{prec:50,assoc:"left"}],["?#",{prec:60,assoc:"left"}],["?-",{prec:60,assoc:"left"}],["?-|",{prec:60,assoc:"left"}],["?|",{prec:60,assoc:"left"}],["?||",{prec:60,assoc:"left"}],["#",{prec:60,assoc:"left"}],["##",{prec:60,assoc:"left"}],["@-@",{prec:60,assoc:"left"}]],mysql:[["DIV",{prec:70,assoc:"left"}],["MOD",{prec:70,assoc:"left"}],["BINARY",{prec:90,assoc:"right"}],["^",{prec:80,assoc:"left"}],["~",{prec:85,assoc:"right"}],["<=>",{prec:50,assoc:"left"}],["REGEXP",{prec:50,assoc:"left"}],["RLIKE",{prec:50,assoc:"left"}],["!",{prec:80,assoc:"right"}],["XOR",{prec:40,assoc:"left"}],["&&",{prec:40,assoc:"left"}],["||",{prec:30,assoc:"left"}],[":=",{prec:10,assoc:"right"}],["SOUNDS LIKE",{prec:50,assoc:"left"}]]};var be=class{buffer="";cursor=0;line=1;column=1;mysqlBindingIndex=0;nestingContext=[];nextTokenEscape=0;next(e=1,r=!1){r&&(this.line++,this.column=0),this.column+=e,this.cursor+=e,this.nextTokenEscape===1?this.nextTokenEscape=2:this.nextTokenEscape===2&&(this.nextTokenEscape=0)}},Ce=class{#e;#s;#o=!1;#t=!1;#l=!1;#r=null;#a=[];#n;#i=[];constructor(e,{state:r,...t}={}){this.#e=e,this.#s=t}[Symbol.asyncIterator](){return this}get options(){return this.#s}get locked(){return this.#o}get started(){return this.#t}get done(){return this.#l&&!this.#i.length}previous(){return this.#a[this.#a.length-1]}current(){return this.#n}async next(){this.#u("next()"),this.#t=!0;let e,r=!1;return this.#i.length?(this.#p(this.#n),this.#n=this.#y(),e=this.#n):({value:e,done:r}=await this.#e.next(),this.#p(this.#n),this.#n=e,this.#l=r),this.#r!==null&&e?.type.endsWith("_block")&&e.value.savepoint(),{value:e,done:r}}async match(e,r=void 0){let[t,n,o]=typeof arguments[0]=="number"?arguments:[0,e,r],s=l=>l&&(Array.isArray(n)?n.includes(l.type):n===l.type)&&(o===void 0||(Array.isArray(o)?o.includes(l.value)||o.includes(void 0):o===l.value))&&l||void 0;if(t===1/0){let l=0,c;for(;c=await this.peek(l++);)if(s(c))return c;return}return s(t?await this.peek(t):this.current())}async peek(e=1){if(e===0)return this.#n;let r=e-this.#i.length;for(;r;){let n=await this.#e.next();if(n.done)break;this.#m(n.value),r--}return this.#i[e-1]}async eat(e=void 0,r=void 0){let t=e?await this.match(e,r):this.current();return t&&(await this.next())?.value,t}async expect(e,r=void 0){let t=await this.eat(e,r);if(!t)throw new Error(`Expected token: ${e}${r?` (${r})`:""}`);return t}#p(e){e?.type.endsWith("_block"),this.#r!==null?this.#a.push(e):this.#a=[e]}#y(){let e=this.#i.shift();return e?.type.endsWith("_block")&&(e.value.#o=!1),e}#c(){let e=this.#a.pop();return e?.type.endsWith("_block")&&e.value.restore(e.value.#r),e}#f(e){e?.type.endsWith("_block")&&(e.value.restore(e.value.#r),e.value.#o=!0),this.#i.unshift(e)}#m(e){e?.type.endsWith("_block")&&(e.value.#o=!0),this.#i.push(e)}#u(e){if(this.#o)throw new Error(`Can't execute ${e}; TokenStream is locked`)}savepoint(){this.#u("savepoint()");let e=this.#a.length;return this.#r===null&&(this.#r=e),e}savepointStatus(){return this.#r!==null?this.#a.length:null}restore(e){if(this.#u("restore()"),this.#r===null||typeof e!="number"||e>this.#a.length)throw new Error(`Invalid restore point ${e}${this.#r===null?". Not in savepoint mode":""}`);for(;e<this.#a.length;)this.#n&&this.#f(this.#n),this.#n=this.#c()}commit(e){if(this.#u("commit()"),e!==this.#r)return;let r;for(;e<this.#a.length&&(r=this.#c());)r.type.endsWith("_block")&&r.value.commit(r.value.#r);this.#r=null}static toStream(e){return typeof e[Symbol.asyncIterator]=="function"?typeof e.next=="function"?e:e[Symbol.asyncIterator]():typeof e[Symbol.iterator]=="function"&&typeof e!="string"&&!(e instanceof String)?typeof e.next=="function"?e:e[Symbol.iterator]():function*(){yield e+""}()}static async create(e,{dialect:r="postgres",state:t=new be,...n}={}){return n.normalized||(n=is({dialect:r,...n,normalized:!0})),new this(await this.createIterator(e,{dialect:r,state:t,...n,extendedAPI:!0}),{dialect:r,...n})}static async*createIterator(e,{dialect:r="postgres",state:t=new be,...n}={}){let o=this.toStream(e);if(!["postgres","mysql"].includes(r))throw new Error(`Unknown dialect: ${r}`);if(!(t instanceof be))throw new Error("options.state must be an instance of TokenStreamState");n.normalized?n={dialect:r,...n}:n=is({dialect:r,...n,normalized:!0});let s={token:null,prevEmittedToken:null,nextTokenSpaceBefore:"",multiwordBuffer:[]},l=(i,_=!1)=>i?us(i,{options:n,state:t,localState:s},_):[],c={value:""};do{t.buffer+=c.value||"";let i;for(;i=t.buffer[t.cursor];){let _=t.buffer[t.cursor+1]===void 0&&!c.done,d=os.has(i),f=()=>{throw new SyntaxError(`Unexpected token: ${i} at line ${t.line}, column ${t.column}`)};if(s.token?.type==="hex_literal"||s.token?.type==="bit_literal"){(s.token.delim?i===s.token.delim:d)?(yield*l(s.token),s.token=null,d&&n.spaces&&(s.nextTokenSpaceBefore+=i)):(s.token?.type==="hex_literal"?/[0-9A-Fa-f]/.test(i)||f():/[01]/.test(i)||f(),s.token.value+=i),t.next();continue}if(s.token?.type==="version_spec"&&((s.token.delim?i===s.token.delim:i==="."||d)?(yield*l(s.token),s.token=null,d&&n.spaces&&(s.nextTokenSpaceBefore+=i)):(s.token.value&&(i==="="?["<",">"].includes(s.token.value)||f():i==="_"?/\d$/.test(s.token.value)||f():/\d/.test(i)||f()),s.token.value+=i),i!==".")){t.next();continue}if(d){let p=s.token?.type==="string_literal",E=s.token?.type==="identifier"&&s.token.delim,x=s.token?.type==="block_comment",N=s.token?.type==="line_comment";if(p||E||x||N&&!(i==="\r"||i===`
`))s.token.value+=i;else{let h=t.buffer[t.cursor-1];!os.has(h)&&s.token&&(yield*l(s.token),s.token=null),n.spaces&&(s.nextTokenSpaceBefore+=i)}i===`
`||i==="\r"?t.next(1,!0):t.next();continue}if(i==="\\"){if(_)break;let p=t.buffer[t.cursor+1],E=s.token?.type==="string_literal"&&(n.dialect==="mysql"?!n.mysqlNoBackslashEscapes:s.token.modifier==="E"),x=p===s.token?.delim||p==="\\"||p==="0"||p==="b"||p==="f"||p==="n"||p==="r"||p==="t"||p==="v"||p==="Z";if(E&&x){p={"\\":"\\",0:"\0",b:"\b",f:"\f",n:`
`,r:"\r",t:"	",v:"\v",Z:""}[p]||p,s.token.value+=p,t.next(2);continue}t.nextTokenEscape=1,t.next();continue}if(s.token?.type==="block_comment"||s.token?.type==="line_comment"||s.token?.type==="string_literal"||s.token?.type==="identifier"&&s.token.delim||s.token?.type==="user_var"&&s.token.delim){let p;if(s.token.type==="block_comment"){if(i==="*"){if(_)break;p=t.buffer[t.cursor+1]==="/"?2:0}}else if(i===s.token.delim){if(s.token.type==="identifier"||s.token.type==="string_literal"&&(n.dialect==="mysql"?n.mysqlNoBackslashEscapes:s.token.modifier!=="E")){if(_)break;if(t.buffer[t.cursor+1]===i){s.token.value+=i,t.next(2);continue}}p=1}else if(s.token.type==="string_literal"&&s.token.delim.startsWith("$")&&i==="$"){let E=t.cursor+1;t.buffer.slice(E-s.token.delim.length,E)===s.token.delim&&(s.token.value=s.token.value.slice(0,-s.token.delim.length+1),p=1)}if(p){yield*l(s.token),s.token=null,t.next(p);continue}s.token.value+=i,t.next();continue}if(t.nestingContext.length&&i==={"{":"}","[":"]","(":")"}[t.nestingContext[0]]){if(yield*l(s.token,!0),t.nestingContext.shift(),n.structured){t.next(),s.nestingEndTagSeen=!0;return}s.token=null}let u,g=0,m=0;if(n.dialect==="postgres"){if(s.token?.type==="pg_possible_dollar_delim"||i==="$"){if(s.token?.type==="pg_possible_dollar_delim"){if(i==="$"){let{type:E,value:x,delim:N,...h}=s.token;s.token={type:"string_literal",value:"",delim:`$${x}$`,...h}}else s.token.value+=i;t.next();continue}if(_)break;let p=t.buffer[t.cursor+1];/[0-9]/.test(p)?u={type:"bind_var"}:u={type:"pg_possible_dollar_delim",delim:i}}}else n.dialect==="mysql"&&(i==="?"&&(u={type:"bind_var"}),i==="#"&&(u={type:"line_comment",delim:i}),i==="`"&&(u={type:"identifier",delim:i}));if(i==="'"){let p=new RegExp(`(@)$|^\\W?(${n.dialect==="postgres"?"E|X|B":"N|X"})$`,"i"),E=t.buffer.slice(Math.max(t.cursor-2,0),t.cursor).match(p),x=E?.[1]||E?.[2];if(x==="@"&&s.prevEmittedToken?.type==="identifier"){if(_)break;let N=t.buffer[t.cursor+1];/[\^~=\d<>!]/.test(N)&&(u={type:"version_spec",delim:i},g=1)}if(!u)if(x&&(x!=="@"||n.dialect==="mysql")){let N=/^(E|N)/i.test(x)?"string_literal":x==="@"?"user_var":(x==="X"?"hex_":"bit_")+"literal";u={type:N,...N==="string_literal"?{modifier:x.toUpperCase()}:{},delim:i},g=x==="@"?1:x.length}else u={type:"string_literal",delim:i}}else i==='"'&&(u={type:n.dialect!=="mysql"||n.mysqlAnsiQuotes?"identifier":"string_literal",delim:i});if(i==="@"){if(_)break;let p=t.buffer[t.cursor+1];(s.token||s.prevEmittedToken)?.type==="identifier"&&/[\^~=\d<>!]/.test(p)?u={type:"version_spec"}:n.dialect==="mysql"&&(p==="@"?(u={type:"system_var"},m=1):/[a-zA-Z_$]/.test(p)&&(u={type:"user_var"}))}if(i==="/"||i==="-"){if(_)break;let p=t.buffer[t.cursor+1];i==="/"&&p==="*"?(u={type:"block_comment"},m=1):i==="-"&&p==="-"&&(u={type:"line_comment",delim:i+p},m=1)}if(u){s.token&&!g&&(yield*l(s.token)),s.token={type:u.type,value:"",...u,line:t.line,column:g?t.column-g:t.column},t.next(1+m);continue}if((i==="{"||i==="["||i==="(")&&(yield*l(s.token),s.token=null,t.nestingContext.unshift(i),n.structured)){t.next();let p={type:{"{":"brace_block","[":"bracket_block","(":"paren_block"}[i],value:await this[n.extendedAPI?"create":"createIterator"](o,{state:t,...n})};if(yield*l(p),n.extendedAPI)await p.value.peek(1/0);else for(;!(await p.value.next()).done;);continue}if(/[0-9]/.test(i)){if(s.token?.type!=="identifier"&&s.token?.type!=="bind_var"&&s.token?.type!=="version_spec"&&!s.token?.type.endsWith("_literal")&&!s.token?.type.endsWith("_var")){if(yield*l(s.token),i==="0"){if(_)break;let p=t.buffer[t.cursor+1]?.toUpperCase();if((p==="X"||p==="B")&&n.dialect==="mysql"){s.token={type:(p==="X"?"hex_":"bit_")+"literal",value:"",line:t.line,column:t.column},t.next(2);continue}}s.token={type:"number_literal",value:i,line:t.line,column:t.column},t.next();continue}}else if(/[a-zA-Z_]/.test(i)){if(s.token?.type!=="identifier"&&!s.token?.type.endsWith("_var")&&!(s.token?.type==="number_literal"&&/\d$/.test(s.token.value)&&/E/i.test(i))){s.token?.type==="number_literal"&&f(),yield*l(s.token),s.token={type:"identifier",value:i,line:t.line,column:t.column},t.next();continue}}else{let p="operator";if(i===";"||i===","||i===":"||i==="{"||i==="}"||i==="["||i==="]"||i==="("||i===")"){if(i===":"&&(t.nestingContext[0]!=="{"||t.nextTokenEscape)?p="operator":p="punctuation",n.dialect==="postgres"&&i===":"&&p==="operator"&&s.token?.type!=="operator"){let E=t.buffer[t.cursor-1];if(_)break;let x=t.buffer[t.cursor+1];E!==":"&&/[a-zA-Z_]/.test(x)&&n.PL_SQL!==!1&&(p="user_var",i="")}}else if(i===".")if(s.token?.type==="number_literal")s.token.value.includes(".")&&f(),p="number_literal";else{if(_)break;let E=t.buffer[t.cursor+1];/\d/.test(E)?p="number_literal":(p="punctuation",s.token?.type==="system_var"&&(p="system_var"))}else(i==="+"||i==="-")&&s.token?.type==="number_literal"&&/E$/i.test(s.token.value)&&(/\+|\-/.test(s.token.value)&&f(),p="number_literal");if(s.token?.type!==p||p==="punctuation"||p==="operator"&&!n.operators.classic.has(`${s.token.value}${i}`)){yield*l(s.token),s.token={type:p,value:i,line:t.line,column:t.column},t.next();continue}}s.token.value+=i,t.next()}if(c.done)break;t.buffer=t.buffer.slice(t.cursor),t.cursor=0}while(c=await o.next());if(s.token){if(s.token.type==="operator"&&s.token.value!=="*"||s.token.type==="number_literal"&&/E$/i.test(s.token.value)||s.token.type==="block_comment"||s.token.type==="pg_possible_dollar_delim"||["string_literal","hex_literal","bit_literal","identifier","version_spec","user_var"].includes(s.token.type)&&s.token.delim)throw new SyntaxError(`Unterminated ${s.token.type} at line ${t.line}, column ${t.column}`);yield*l(s.token,!0)}if(t.nestingContext.length&&!s.nestingEndTagSeen)throw new SyntaxError(`Unterminated nesting "${t.nestingContext[0]}" at line ${t.line}, column ${t.column}`)}},os=new Set([" ","\f",`
`,"\r","	","\v"]);function is(a){let e=(r,t,n,o)=>{n.split(" ").reduce((s,l)=>(s=s?`${s} ${l}`:l,r.set(s,o),s),t)};for(let r of["statements","functionNames","aggrFunctionNames","keywords","operators","dataTypes"]){let t=["statements","functionNames","aggrFunctionNames"].includes(r)?"keywords":r,n=a[t]||{classic:new Map,compound:new Map};for(let o of["common",a.dialect==="mysql"?"mysql":"postgres"]){let s=Mr[r][o];for(let l of s){let[c,i]=Array.isArray(l)?[l[0],{...l[1],value:l[0]}]:[l,{value:l}];c.includes(" ")?e(n.compound,"",c,i):n.classic.set(c,i)}}a={...a,[t]:n}}return a}function us(a,{options:e,state:r,localState:t},n=!1){if(t.nextTokenSpaceBefore){let{type:l,...c}=a;a={type:l,spaceBefore:t.nextTokenSpaceBefore,...c},t.nextTokenSpaceBefore=""}if(a.type==="block_comment"||a.type==="line_comment")return Bs(a,{options:e});let o,s=!1;if(e.dialect==="mysql"&&a.type==="bind_var")o=[{...a,value:`${++r.mysqlBindingIndex}`}];else if(a.type==="operator"){let{line:l,column:c,...i}=a;o=[{...i,...e.operators.classic.get(a.value)||{},line:l,column:c}]}else a.type==="identifier"&&!a.delim&&(o=$s(a,{options:e,state:r,localState:t},n),s=!0);return o||(o=[a]),o?.length?t.prevEmittedToken=o[0]:t.prevEmittedToken=a,!s&&o.length&&t.multiwordBuffer.length?t.multiwordBuffer.splice(0).concat(o):o}function Bs(a,{options:e}){return e.comments?(a.type==="block_comment"?a={...a,value:a.value.split(`
`).map(r=>r.replace(/^[ ]+\*[ ]+?/,"").trim()).join(`
`)}:a={...a,value:a.value.trim()},[a]):[]}function $s(a,{options:e,state:r,localState:t},n=!1){let o,s=t.multiwordBuffer.length,l=(s?t.multiwordBuffer.map(g=>g.value).concat(a.value).join(" "):a.value).toUpperCase(),c=g=>{for(let m of["keywords","operators","dataTypes"]){let p=e[m][g].get(l);if(p)return[m,p]}return[]},i=()=>{let{type:g,spaceBefore:m,line:p,column:E,...x}=a;s&&(m=t.multiwordBuffer[0].spaceBefore,p=t.multiwordBuffer[0].line,E=t.multiwordBuffer[0].column);let N={type:f==="dataTypes"?"data_type":f.replace(/s$/,""),...m?{spaceBefore:m}:{},...x,...u,value:l,line:p,column:E};s?(o=[N],t.multiwordBuffer.splice(0),s=0):o=[N]},_=()=>{let g={...a,type:f==="dataTypes"?"data_type":f.replace(/s$/,"")};t.multiwordBuffer.push(g),o=[]},d=!1,[f,u]=c("compound");if(u?.value===l||n&&u)i(),d=!0;else if(u){let[g,m]=c("classic");m&&g!==f&&([f,u]=[g,m]),_(),d=!0}else[f,u]=c("classic"),u&&(i(),d=!0);if(!d&&s){let g=t.multiwordBuffer.splice(0),m=us(a,{options:e,state:r,localState:t});return[...g,...m]}if(!o&&/^(TRUE|FALSE|NULL|UNKNOWN)$/i.test(a.value)){let{type:g,...m}=a;o=[{type:/UNKNOWN/.test(a.value)?"unknown_literal":/NULL/i.test(a.value)?"null_literal":"bool_literal",...m}]}return o}var R=Object.create(null);var y=class a{static get NODE_NAME(){return ns(this.name)}get NODE_NAME(){return this.constructor.NODE_NAME}#e;#s;#o;constructor(e={},r={}){this.#e=e,this.#s=r,this.#o=this.constructor.compileASTSchemaFromSyntaxRules(this.options);for(let t of Object.values(this.#e))this._adoptNodes(...[].concat(t))}#t;get contextNode(){return this.#t}get statementNode(){return this.#t?.statementNode}get rootNode(){return this.#t?.rootNode||this}get options(){return this.#s}get _astSchema(){return this.#e}_fieldSchema(e,r=void 0){let t=this.#o[e]||{};if(typeof r<"u"){let n=`${this.NODE_NAME}.<${e}>.<${r}>`;if([void 0,null].includes(t.arity))throw new Error(`[${n}] Can't use index on "${e}". Not index-based.`);if(!t.keyed&&typeof r!="number")throw new Error(`[${n}] Can't use non-numeric index on "${e}". Not keyed.`)}return t}_set(e,r,t=void 0){let n=arguments.length>2?r:void 0,o=arguments.length>2?t:r,s=this._fieldSchema(e,n),l=this._get(e,n),c=`${this.NODE_NAME}.<${e}>`;if(l&&this._unadoptNodes(...[].concat(l)),typeof n<"u")this.#e[e]=l?this.#e[e].reduce((i,_)=>_===l?i:i.concat(_),[]):this.#e[e].concat(o);else{if(![void 0,null].includes(s.arity)){if(!Array.isArray(o))throw new Error(`[${c}] Invalid "${e}" type provided. Array expected.`);if(s.arity!==1/0){let i=o.length;if($(s.arity)){if("min"in s.arity&&i<s.arity.min)throw new Error(`[${c}] A minimum of ${s.arity.min} argument(s) expected but got ${i}.`);if("max"in s.arity&&i>s.arity.max)throw new Error(`[${c}] A maximum of ${s.arity.max} argument(s) expected but got ${i}.`)}else if(![].concat(s.arity).includes(i))throw new Error(`[${c}] Exactly ${[].concat(s.arity).join(" or ")} argument(s) expected but got ${i}.`)}}this.#e[e]=o}return this._adoptNodes(...[].concat(o)),!0}_get(e,r=void 0){if(e in this.#e){let t=this.#e[e];return typeof r=="number"?t=t[r]:r&&(t=t.find(n=>n.identifiesAs?.(r))),t}}_delete(e,r=void 0){return this._fieldSchema(e,r),e in this.#e?(typeof r<"u"?this.#e[e]=this.#e[e].reduce((t,n,o)=>(typeof r=="number"?o===r:n.identifiesAs?.(r))?(this._unadoptNodes(n),t):t.concat(n),[]):(this._unadoptNodes(...[].concat(this.#e[e])),this.#e[e]=this._default(e)),!0):!1}_has(e,r=void 0){return this._fieldSchema(e,r),e in this.#e?typeof r=="number"?typeof this.#e[e][r]<"u":r?this.#e[e].some(t=>t.identifiesAs?.(r)):!0:!1}_add(e,...r){let t=this._fieldSchema(e);if([void 0,null].includes(t.arity)){let n=`${this.NODE_NAME}.<${e}>`;throw new Error(`[${n}] Can't perform add() on "${e}". Not item-based.`)}return this._adoptNodes(...r),this.#e[e]=this.#e[e].concat(r),!0}_adoptNodes(...e){for(let r of e)if(r instanceof a){if(r.#t&&r.#t!==this){let t=`${this.NODE_NAME}`;throw new Error(`[${t}] Illegal node operation`)}r.#t=this}}_unadoptNodes(...e){for(let r of e)if(r instanceof a){if(r.#t!==this){let t=`${this.NODE_NAME}`;throw new Error(`[${t}] Illegal node operation`)}r.#t=null}}_walk(e){for(let r of Object.values(this.#e))for(let t of[].concat(r))t?._walk&&t._walk(e);if(e?.visit)return e.visit(this);if(typeof e=="function")return e(this)}_capture(e,r){if(arguments.length!==2)throw new Error("_capture() expects exactly 2 parameters.");return this.#t?._capture?.(e,r)}capture(e){if(arguments.length!==1)throw new Error("capture() expects exactly 1 parameter.");return this.#t?._capture(e,this)}_bubble(e,r){if(arguments.length!==2)throw new Error("_bubble() expects exactly 2 parameters.");this.#t?._bubble?.(e,r),r===this&&e==="DISCONNECTED"&&(this.#t=null)}bubble(e){if(arguments.length!==1)throw new Error("bubble() expects exactly 1 parameter.");return this.#t?._bubble?.(e,this)}containsNode(e){return e?this===e.contextNode||this.containsNode(e.contextNode):!1}identifiesAs(e){if(typeof e>"u")return!1;if(typeof e?.toJSON=="function")return oe(this.jsonfy(),e.jsonfy(),"ci")}static morphsTo(){return this}deSugar(e={}){return e={...e,deSugar:!0},this.clone(e)}toDialect(e,r={}){return r={...r,toDialect:e},this.clone(r)}clone(e={}){let r=this.jsonfy(e);return[].concat(this.constructor.morphsTo()).reduce((n,o)=>n||o.fromJSON(r,{dialect:e.toDialect||this.options.dialect}),void 0)}static get syntaxRules(){return[]}static compileASTSchemaFromSyntaxRules({dialect:e="postgres"}={}){this._astSchemaCompileCache||(this._astSchemaCompileCache=new Map);let r=`${this.NODE_NAME}:${e}`;if(!this._astSchemaCompileCache.has(r)){let t,n=this.syntaxRules,o=[].concat(n);o.length===1&&Array.isArray(o[0].type)&&!o[0].as?t=o[0]:t=this._compileASTSchemaFromSyntaxRules(n,e,{trail:[this.NODE_NAME]}),this._astSchemaCompileCache.set(r,t)}return this._astSchemaCompileCache.get(r)}static _compileASTSchemaFromSyntaxRules(e,r="postgres",{trail:t=[],schemaSet:n=new Set([new Map]),assertionTrail:o={dependencies:new Set,optional:!1,assert:!1}}={}){let s=Array.isArray(e)?e:[e],l=new Set(o.dependencies),c=_=>new Set([..._].map(d=>new Map(d)));for(let[_,d]of s.entries()){if(d.dialect&&d.dialect!==r)continue;let{type:f,as:u,if:g=o.inference,value:m,arity:p,modifier:E,booleanfy:x,optional:N=o.optional,assert:h=o.assert,syntax:S,syntaxes:A,...j}=d,F=t.concat(`${Array.isArray(e)?_:""}${u?`<${u}>`:""}`||[]),w=F.join("."),B=ls(j);if(B.length)throw new Error(`[${w}] Unsupported attributes in rule: "${B.join('", "')}".`);let G=typeof f=="string"&&f[0]===f[0].toLowerCase();if(u){if(!f)throw new Error(`[${w}] Field rules must have a "type" attribute of type string.`);if(S||A)throw new Error(`[${w}] Field rules ("${u}") can not have a "syntax" or "syntaxes" attribute.`);if(u==="."){if(!G)throw new Error(`[${w}] Terminal Node rules must be token-typed rules.`);if(N)throw new Error(`[${w}] Terminal Node rules can not be optional.`)}else if(E)throw new Error(`[${w}] Only Terminal Node rules can have a "modifier" attribute.`);if(G){if(![void 0,null].includes(p))throw new Error(`[${w}] Token rules can not be item-based.`);if(!ve[f])throw new Error(`[${w}] Unknown token type "${f}".`)}else{if(m)throw new Error(`[${w}] Only token rules can have a "value" attribute.`);for(let M of[].concat(f))if(!R[M])throw new Error(`[${w}] Unknown node type "${M}".`);if(![void 0,null].includes(p)){if($(p)){let M=Object.keys(p);if(M.some(K=>!["min","max","eager"].includes(K)||typeof p[K]!=(K==="eager"?"boolean":"number")))throw new Error(`Invalid arity object "{ ${M.join(", ")} }" for field "${u}". Only "min: <number>", "max: <number>" and "eager: <bool>" expected.`)}else if([].concat(p).some(M=>typeof M!="number"))throw new Error(`[${w}] Invalid arity value "${[].concat(p).join(", ")}" for field "${u}". Number(s) expected.`)}}let k={rulePath:w,type:f};m&&(k.value=m),E&&(k.modifier=E),x&&(k.booleanfy=x),[void 0,null].includes(p)||(k.arity=p),N&&(k.optional=!0),h&&(k.assert=h),g&&(k.if=g),N&&o.dependencies.size&&(k.dependencies=Array.from(o.dependencies));for(let M of n)M.set(u,k);u!=="."&&N&&!d.optional&&l.add(u)}if(S||A){let k={dependencies:l,optional:N,assert:h,inference:g};if(S){n=this._compileASTSchemaFromSyntaxRules(S,r,{trail:F.concat("syntax"),schemaSet:n,assertionTrail:k});continue}let M=new Set;for(let[K,ae]of A.entries()){let q=c(n),I=this._compileASTSchemaFromSyntaxRules(ae,r,{trail:F.concat("syntaxes",K),schemaSet:q,assertionTrail:k});for(let z of I)M.add(z)}n=M}}let i=Array.from(n);for(let _=0;_<i.length;_++){let d=i[_],f=Object.fromEntries(d);if(!d.size){n.delete(d);continue}for(let u=_+1;u<i.length;u++){let g=i[u],m=Object.fromEntries(g);oe(f,m,"cs","rulePath")&&n.delete(g)}}return n}static fromJSON(e,r={},t=null){let n=this.compileASTSchemaFromSyntaxRules(r);if(Array.isArray(n.type)){for(let d of n.type){let u=R[d].fromJSON(e,r,t);if(u)return u}return}if(e instanceof a)return e instanceof this?e:void 0;if(!$(e))return;let o=null;if("nodeName"in e){if(e.nodeName!==this.NODE_NAME)return;({nodeName:o,...e}=e)}let s,l=(d,f=null,u=!1)=>{if(!(!o&&r.assert!==!0&&!(r.assert instanceof RegExp&&r.assert.test(activeTrailStr)))){if(f&&(d=`[${f}] ${d}`),u){s=d;return}throw new Error(d)}},c=(d,f)=>{if(d.value!==void 0){let u=d.booleanfy?[!0,!1]:d.value;return[].concat(u).includes(f.value)}return ve[d.type].match?.(f,r)!==!1},i=(d,f)=>{for(let u of[].concat(d.type))if(typeof u=="string"&&u[0]===u[0].toLowerCase()){if(c(d,{value:f})===!0)return f}else{let m=R[u].fromJSON(f,r);if(m)return m}},_=(d,f,u,g=!1)=>{if(u.dependencies?.length){for(let p of u.dependencies)if(!(p in d))return l(`Missing dependency field "${p}" required by "${f}"`,u.rulePath,g),!1}if(u.if&&!Pr(u.if,d,u.rulePath))return!0;if(![void 0,null].includes(u.arity)){if(e[f]===void 0)return u.optional?(d[f]=[],!0):(l(`Missing required field "${f}"`,u.rulePath,g),!1);if(!Array.isArray(e[f]))return l(`Field "${f}" must be an array`,u.rulePath,g),!1;if(u.arity!==1/0){let x=e[f].length;if($(u.arity)){if("min"in u.arity&&x<u.arity.min)return l(`A minimum of ${u.arity.min} argument(s) expected but got ${x}`,u.rulePath,g),!1;if("max"in u.arity&&x>u.arity.max)return l(`A maximum of ${u.arity.max} argument(s) expected but got ${x}`,u.rulePath,g),!1}else if(![].concat(u.arity).includes(x))return l(`Exactly ${[].concat(u.arity).join(" or ")} argument(s) expected but got ${x}`,u.rulePath,g),!1}let p=e[f].map(x=>i(u,x)).filter(x=>x!==void 0),E=p.length;return e[f].length>E?E?(l(`Inconsistent "${f}" argument(s)`,u.rulePath,g),!1):(l(`Failed to resolve any argument for "${f}"`,u.rulePath,g),!1):(d[f]=p,!0)}if(e[f]===void 0)return u.optional?(d[f]=u.booleanfy?!1:void 0,!0):(l(`Missing required field "${f}"`,u.rulePath,g),!1);let m=i(u,e[f]);return m===void 0?(l(`Failed to resolve field "${f}"`,u.rulePath,g),!1):(d[f]=m,!0)};e:for(let d of n instanceof Map?[n]:n){let f=Object.create(null),u=new Map(d),g=e;if(u.has(".")){let m=u.get("."),p=ve[m.type];if([void 0,null].includes(g.value))continue e;({value:f.value,...g}=g);for(let E of Object.keys(p))typeof p[E]!="function"&&E in g&&({[E]:f[E],...g}=g);if(c(m,f)===!1)continue e;u.delete(".")}for(let m of new Set(Object.keys(g).concat(...u.keys()))){if(!u.has(m))continue e;let p=u.get(m);if(_(f,m,p,!0)===!1)continue e}return typeof t=="function"?t(f,r):new this(f,r)}l(`Failed to match any schema${s?`. ${s}`:""}`,this.NODE_NAME)}toJSON(e=null,r={}){return this.jsonfy(r)}jsonfy(e={},r=null){let t=(n,o)=>{let s=n;return r&&(n=r(n,o,e)),n instanceof a?n=n.jsonfy(e,r):Array.isArray(s)&&Array.isArray(n)&&n.every(l=>l instanceof a)&&(n=n.reduce((l,c,i)=>{let _=t(c,i);return _===void 0?l:l.concat(_)},[])),n};return{...e.nodeNames!==!1?{nodeName:this.NODE_NAME}:{},...Object.fromEntries(Object.entries(this.#e).map(([n,o])=>[n,t(o,n)]))}}static async parse(e,{left:r,minPrecedence:t=0,trail:n=[],...o}={}){let s=e instanceof Ce?e:await Ce.create(e,{structured:!0,spaces:!0,...o}),l=s.savepoint();!s.current()&&!s.done&&await s.next();let c=this.syntaxRules,i,_;if((_=[].concat(c)).length===1&&Array.isArray(_[0].type)&&!_[0].as)_[0].expression?i=await this._parseAsExpression(s,_[0].type,{left:r,minPrecedence:t,trail:n.concat(this.NODE_NAME),...o}):i=await this._parseFromTypes(s,_[0].type,{left:r,minPrecedence:t,trail:n.concat(this.NODE_NAME),...o});else{let d=await this._parseFromRules(s,c,{left:r,minPrecedence:t,trail:n.concat(this.NODE_NAME),...o});d&&(i=d instanceof a?d:new this(d,{...o,dialect:s.options.dialect}))}return i||s.restore(l),i}static async _parseAsExpression(e,r,{left:t=null,minPrecedence:n,trail:o,...s}){if(t)throw new Error("TODO");for(t=await this._parseFromTypes(e,r,{minPrecedence:n,trail:o,...s});t;){let l=await e.match("operator");if(!l||l.prec<n)break;let c=t,i=await this._parseFromTypes(e,r,{left:t,minPrecedence:n,trail:o,...s});if(!i)return t;t=i}return t}static async _parseFromRules(e,r,{left:t,minPrecedence:n,trail:o,...s},l={}){let c=Array.isArray(r)?r:[r],i=0,_=n;for(let[d,f]of c.entries()){if(f.dialect&&f.dialect!==e.options.dialect){i++;continue}let{requiredSpacing:u,peek:g,type:m,value:p,syntax:E,syntaxes:x,as:N,if:h,arity:S,itemSeparator:A,optional:j=!1,assert:F=!1,booleanfy:w,...B}=f,G=o.concat(`${Array.isArray(r)?d:""}${N?`<${N}>`:""}`||[]),k=G.join("."),M=ls(B);if(M.length)throw new Error(`[${k}] Unsupported attributes in rule: "${M.join('", "')}".`);let K=typeof m=="string"&&m[0]===m[0].toLowerCase(),ae=async()=>{if(!(!N||K)&&c[d+1]?.type==="operator"&&!(Array.isArray(g)&&!await I(-1))){for(let O of[].concat(m))if(t instanceof R[O])return l[N]=t,!0;return!1}},q=()=>{let O=e.current();return u===!1&&!O?.spaceBefore||u===!0&&O?.spaceBefore||u===`
`&&/\n/.test(O?.spaceBefore)},I=async(O=0)=>O?await e.match(g[0]+O,...g.slice(1)):await e.match(...g),z=async()=>{let O;if((O=await e.match("operator"))&&O.prec<n)return;let b=await e.eat(m,m.endsWith("_block")?void 0:p);return b?.type==="operator"&&(_=b.prec+(b.assoc==="right"?0:1)),b},Oe=async(O,b)=>{if(Array.isArray(m))return await this._parseFromTypes(O,m,{minPrecedence:b,trail:G,...s});let Y=R[m];if(!Y)throw new Error(`[${k}] Unknown node type <${m}>.`);return await Y.parse(O,{minPrecedence:b,trail:G,...s})},C=(O,b,Y=!1)=>{if(!(!F&&s.assert!==!0&&!(s.assert instanceof RegExp&&s.assert.test(k)))){if(Y){let P=O.current()||O.previous(),Q=O.current()?"near":"by";b+=P?` - ${Q}${typeof P.value=="string"?` "${P.value}" (${P.type})`:""} <line ${P.line}, column ${P.column}>`:` - ${Q} end of stream`}throw new Error(`[${k}] ${b}.`)}};if(t&&m){if(!await ae())return;t=null;continue}if(h&&!Pr(h,l,k))continue;if(u!==void 0&&!q()){C(e,"Required spacing mismatch",!0);return}if(Array.isArray(g)&&!await I()){C(e,"Peek failure",!0);return}if(N==="."){if(!m||!K)throw new Error(`[${k}] Terminal node rules must be token-typed rules.`);let O=await z();if(!O){C(e,`Token of type "${m}"${p?` and value "${p}"`:""} expected but got "${e.current()?.type}"`,!0);return}let b,Y,P,Q,Re,Os,es;({type:b,line:Y,column:P,spaceBefore:Q,prec:Re,assoc:Os,...es}=O),Object.assign(l,es);continue}let v=e;if(typeof m=="string"&&m.endsWith("_block")){if(!(v=(await z())?.value)){if(j)continue;C(e,`Token of type "${m}" expected but got "${e.current()?.type}"`,!0);return}_=0,!v.current()&&!v.done&&await v.next()}if(![void 0,null].includes(S)){if(!N)throw new Error(`[${k}] Multi-argument field rules must have a "as" attribute.`);if(!m)throw new Error(`[${k}] Multi-argument field rules must have a "type" attribute.`);if(K)throw new Error(`[${k}] Multi-argument field rules must be node-typed rules.`);let O,b=[],Y=_;if(A?.type==="operator"){let P=A.value&&(v.options.operators?.classic.get(A.value)||v.options.operators?.compound.get(A.value));P?.prec&&(Y=P?.prec+1)}for(;(O=await Oe(v,Y))&&(b.push(O),!($(S)&&S.eager===!1&&b.length===S.max||A&&!await v.eat(A.type,A.value))););if(S!==1/0){let P=b.length;if(!P&&j)continue;let Q=v.current(),Re=Q?`. Unexpected ${Q.type}${typeof Q.value=="string"?` "${Q.value}"`:""}`:"";if($(S)){if("min"in S&&P<S.min){C(v,`A minimum of ${S.min} argument(s) expected but got ${P}${Re}`,!0);return}if("max"in S&&P>S.max){C(v,`A maximum of ${S.max} argument(s) expected but got ${P}${Re}`,!0);return}}else if(![].concat(S).includes(P)){C(v,`Exactly ${[].concat(S).join(" or ")} argument(s) expected but got ${P}${Re}`,!0);return}}l[N]=b;continue}let D;if(E){let O=v.savepoint();D=await this._parseFromRules(v,E,{left:t,minPrecedence:_,trail:G.concat("syntax"),...s}),D===void 0?v.restore(O):t&&(t=null)}else if(x){for(let[O,b]of x.entries()){let Y=v.savepoint();if(D=await this._parseFromRules(v,b,{left:t,minPrecedence:_,trail:G.concat("syntaxes",O),...s}),D===void 0)v.restore(Y);else break}D!==void 0&&t&&(t=null)}else if(!(typeof m=="string"&&m.endsWith("_block")))D=K?(await z())?.value:await Oe(v,_);else if(!m)throw new Error(`[${k}] Rules must have a "type", "syntax" or "syntaxes" attribute.`);if(D===void 0&&!j){C(v,m?"Type mismatch":null,!0);return}N?(w&&(D=D!==void 0),l[N]=D):(E||x)&&Object.assign(l,D)}if(i!==c.length)return l}static async _parseFromTypes(e,r,{left:t,minPrecedence:n,trail:o,...s}){for(let l of r)if(typeof l=="string"&&l[0]===l[0].toLowerCase()){if(await e.match(l))return await e.eat()}else{let i=R[l];if(!i)throw new Error(`[${this.NODE_NAME}] Unknown node type "${l}".`);let _=await i.parse(e,{left:t,minPrecedence:n,trail:o,...s});if(_!==void 0)return _}}toString(){return this.stringify()}stringify(e={}){return this._stringifyFromRules(this.constructor.syntaxRules,{trail:[this.NODE_NAME],...e})}_stringifyFromRules(e,{trail:r=[],startingIndentLevel:t=0,autoLineBreakThreshold:n=100,...o},s=null){let l=()=>" ",c=f=>`
${(o.tabSpaces===4?"	":" ".repeat(o.tabSpaces||2)).repeat(f)}`,i=[],_=[].concat(e),d=0;for(let[f,u]of _.entries()){if(u.dialect&&u.dialect!==this.options.dialect)continue;let{requiredSpacing:g,type:m,value:p,booleanfy:E,syntax:x,syntaxes:N,as:h,if:S,arity:A,itemSeparator:j,optional:F=!1,autoSpacing:w=g,optionalParens:B,autoIndent:G=!1,autoIndentAdjust:k=0}=u,M=r.concat(`${Array.isArray(e)?f:""}${h?`<${h}>`:""}`||[]),K=M.join("."),ae=G;if(S&&!Pr(S,this.#e,this.NODE_NAME))continue;let q={startingIndentLevel:t+(G?1:0)+k,autoLineBreakThreshold:n,...o},I;if([void 0,null].includes(A))if(x)I=this._stringifyFromRules(x,{trail:M.concat("syntax"),...q},s);else if(N){let C=-1;for(let[v,D]of N.entries()){let O={score:0},b=this._stringifyFromRules(D,{trail:M.concat("syntaxes",v),...q},O);typeof b=="string"&&O.score>C&&(I=b,C=O.score)}s&&(s.score+=C)}else if(h){let C=this._get(h==="."?"value":h),v=p!=null;if(v&&E&&C===!0&&(C=p),v&&([].concat(p).includes(C)?s&&s.score++:C=void 0),C!==void 0){C instanceof a&&(C=C.stringify(q));let D=h==="."?{...u,...this.#e}:{...u,value:C};I=this._stringifyTerminal(D,q)}}else I=this._stringifyTerminal(u,q);else{let C=!1,v=this._get(h);if(v&&!(C=A===1/0)){let D=v.length;$(A)?C=(!("min"in A)||D>=A.min)&&(!("max"in A)||D<=A.max):C=[].concat(A).includes(D)}if(C){let D=v.map(Y=>Y.stringify(q));ae=G===!0||typeof G=="number"&&v.length>=G||w===`
`;let O=q.prettyPrint&&ae&&D.join(" ").length>n?c(q.startingIndentLevel):l(),b=j?this._stringifyTerminal(j,q):"";/^\w+$/.test(b)?b=`${O}${b}${O}`:b===";"&&q.prettyPrint?b=`${b}
${O}`:b=`${b}${O}`,I=D.join(b)}}if(m==="paren_block"&&B&&!I?.trim()){if(B===!0||o.pruneOptionalParens){s&&s.score++,d++;continue}I=""}if(I===void 0){if(F){d++;continue}return}h&&s&&s.score++;let z=!1;if(typeof m=="string"&&m.endsWith("_block")){let C=q.prettyPrint&&G&&I.length>n,v={brace_block:"{}",bracket_block:"[]",paren_block:"()"}[m];I=[v[0],C&&!/^\s/.test(I)?c(t+1):v[0]==="{"?l():"",I,C?c(t):v[1]==="}"?l():"",v[1]].join("")}else q.prettyPrint&&ae&&I!==""&&(I=[c(t+(w===`
`?0:1)),I].join(""),z=!0);let Oe=i[i.length-1];I!==""&&!z&&i.length&&!/\s$/.test(Oe)&&(Array.isArray(w)?w.includes(Oe):w!==!1)&&(w===`
`&&q.prettyPrint?i.push(c(t)):i.push(l())),i.push(I)}if(i.length||d===_.length)return i.join("")}_stringifyTerminal(e,r={}){switch(e.type){case"data_type":return this._stringifyDataType(e,r);case"identifier":return this._stringifyIdentifier(e,r);case"keyword":return this._stringifyKeyword(e,r);case"operator":return this._stringifyOperator(e,r);case"punctuation":return this._stringifyPunctuation(e,r);case"bind_var":return this._stringifyBindVar(e,r);case"version_spec":return`@${e.value}`}if(!Array.isArray(e.type)){if(e.type.endsWith("_literal"))return this._stringifyLiteral(e,r);if(e.type.endsWith("_var"))return this._stringifyVariable(e,r);if(e.type.endsWith("_comment"))return this._stringifyComment(e,r)}return String(e.value)}_stringifyIdentifier(e){let{value:r}=e,t=['"'];this.options.dialect==="mysql"&&(this.options.mysqlAnsiQuotes?t.push("`"):t.fill("`"));let n=t.includes(e.delim)?e.delim:t[0];return/^\d/.test(r)||!/^(\*|[\w]+)$/.test(r)?`${n}${(r||"").replace(new RegExp(n,"g"),n.repeat(2))}${n}`:r}_stringifyKeyword(e){return String(e.value)}_stringifyOperator(e){return e.value===":"&&this.#t?.isProperty?"\\:":String(e.value)}_stringifyPunctuation(e){return String(e.value)}_stringifyDataType(e){return String(e.value)}_stringifyLiteral(e,r){let{value:t}=e;switch(e.type){case"bit_literal":return this._stringifyBitLiteral(e,r);case"hex_literal":return this._stringifyHexLiteral(e,r);case"number_literal":return this._stringifyNumberLiteral(e,r);case"string_literal":return this._stringifyStringLiteral(e,r);case"bool_literal":return/^true$/i.test(t+"")?"TRUE":"FALSE";case"null_literal":return"NULL"}return String(t)}_stringifyBindVar(e){let{value:r}=e;return this.options.dialect==="mysql"?"?":`$${r}`}_stringifyBitLiteral(e){let{value:r}=e;return this.options.dialect==="mysql"?`0b${r}`:`B'${r}'`}_stringifyHexLiteral(e){let{value:r}=e;return this.options.dialect==="mysql"?`0x${r}`:`X'${r}'`}_stringifyNumberLiteral(e){let{value:r}=e;return String(r)}_stringifyStringLiteral(e){let{value:r}=e,t=["'"],n=null;this.options.dialect==="postgres"&&e.delim?.startsWith("$")?t.fill(e.delim):this.options.dialect==="mysql"&&!this.options.mysqlAnsiQuotes&&t.push('"');let o=t.includes(e.delim)?e.delim:t[0];if((this.options.dialect==="mysql"&&!this.options.mysqlNoBackslashEscapes||this.options.dialect==="postgres"&&e.modifier==="E")&&(n="\\"),o.length>1)return`${o}${r}${o}`;if(!n)n=o;else if(n==="\\"){let s={"\\":"\\\\","\0":"\\0","\b":"\\b","\f":"\\f","\n":"\\n","\r":"\\r","	":"\\t","\v":"\\v","":"\\Z"};r=r.replace(/[\\\0\b\r\n\t\x1A]/g,l=>s[l])}return r=`${o}${(r||"").replace(new RegExp(o,"g"),`${n}${o}`)}${o}`,e.modifier?`${e.modifier}${r}`:r}_stringifyVariable(e){let{type:r,value:t}=e;return this.options.dialect==="mysql"?`${r==="system_var"?"@@":"@"}${t}`:`${this.#t?.isProperty?"\\:":":"}${t}`}_stringifyComment(e,r={}){let{value:t}=e;if(e.type==="block_comment"){let s="  ".repeat(r.startingIndentLevel||0),l=t.trim().split(`
`).map(i=>i.trim());return[`${s}/**`,...l.map(i=>`${s} * ${i}`),`${s} */`].join(`
`)}let n=["--"];return this.options.dialect==="mysql"&&n.push("#"),`${n.includes(e.delim)?e.delim:n[0]} ${t}`}},ls=a=>Object.keys(a).filter(e=>!Us.has(e)),Us=new Set(["dialect","autoSpacing","optionalParens","autoIndent","autoIndentAdjust","type","value","delim","modifier","syntax","syntaxes","as","booleanfy","if","arity","itemSeparator","keyed","requiredSpacing","peek","optional","assert"]),Pr=(a,e,r)=>[].concat(a).some(t=>{if($(t))return Object.entries(t).every(([o,s])=>{let l=!0;return o.startsWith("!")&&(o=o.slice(1),l=!1),(Array.isArray(s)?s.includes(e[o]):e[o]===s)===l});if(typeof t!="string")throw new Error(`[${r}] A specifier of type string or object expected in inferenceMatch but got ${t===null?"null":`type ${typeof t}`}`);let n=!0;return t.startsWith("!")&&(t=t.slice(1),n=!1),![void 0,null,!1].includes(e[t])===n});var Me=class extends y{static get syntaxRules(){return{dialect:"postgres",syntax:[{type:"keyword",value:"CYCLE"},{assert:!0,syntax:[{type:"ComputedColumnRef",as:"column_names",arity:{min:1},itemSeparator:{type:"punctuation",value:","},assert:!0,autoIndent:2},{type:"keyword",value:"SET"},{type:"ComputedColumnRef",as:"mark_col_name"},{optional:!0,syntax:[{type:"keyword",value:"TO"},{type:"Expr",as:"mark_value"},{type:"keyword",value:"DEFAULT"},{type:"Expr",as:"mark_default"}]},{type:"keyword",value:"USING"},{type:"ComputedColumnRef",as:"path_col_name"}]}]}}breadthOrDepthFirst(){return this._get("breadth_or_depth_first")}columnNames(){return this._get("column_names")}markColName(){return this._get("mark_col_name")}markValue(){return this._get("mark_value")}markDefault(){return this._get("mark_default")}pathColName(){return this._get("path_col_name")}};var Pe=class extends y{static get syntaxRules(){return{dialect:"postgres",syntax:[{type:"keyword",value:"SEARCH"},{assert:!0,syntax:[{type:"keyword",as:"breadth_or_depth_first",value:["BREADTH","DEPTH"]},{type:"keyword",value:"FIRST"},{type:"keyword",value:"BY"},{type:"ComputedColumnRef",as:"column_names",arity:{min:1},itemSeparator:{type:"punctuation",value:","},assert:!0,autoIndent:2},{type:"keyword",value:"SET"},{type:"ComputedColumnRef",as:"seq_col_name"}]}]}}breadthOrDepthFirst(){return this._get("breadth_or_depth_first")}columnNames(){return this._get("column_names")}seqColName(){return this._get("seq_col_name")}};var ie=class extends y{#e=0;_rand(e){return`${e}::${this.#e++}`}#s;get uuid(){return this.#s||(this.#s=this._rand("query")),this.#s}static fromJSON(e,r={}){let{uuid:t,...n}=e,o=super.fromJSON(n,r);return t&&o&&(o.#s=t),o}jsonfy(e={}){return{...super.jsonfy(e),uuid:this.#s}}};var H=class extends ie{_capture(e,r){let t=super._capture(e,r);return e==="CONTEXT.ROOT_SCHEMA"&&!t?RootSchema.fromJSON(this,[]):t}renderBindings(e){if(!Array.isArray(e))throw new Error("Values must be an array");let r=[...this.queryBindings()];for(let t=0;t<e.length;t++){let n=r.filter(o=>o.offset()===t+1);if(!n.length)throw new Error(`No bindings exists at offset #${t}`);n.forEach(o=>o.value(e[t]))}}normalizeBindings(e=!1){let r=[...this.queryBindings()];if(!e)return r.forEach((o,s)=>o.offset(s+1)),r;let t=new Map,n=1;for(let o of r)if(o.offset()===0||!t.has(o.offset())){let s=n++;t.set(o.offset(),s),o.offset(s)}else o.offset(t.get(o.offset())).withDetail("redundant",!0);return r.filter(o=>!o.getDetail("redundant"))}};var Be=class extends H{static get _bodyTypes(){return["SelectStmt","TableStmt","InsertStmt","UpsertStmt","UpdateStmt","DeleteStmt","ValuesConstructor"]}static get syntaxRules(){return[{type:"keyword",value:"WITH"},{type:"keyword",as:"recursive",value:"RECURSIVE",booleanfy:!0,optional:!0},{type:"CTEBinding",as:"bindings",arity:{min:1},itemSeparator:{type:"punctuation",value:","},assert:!0,autoIndent:2},{type:this._bodyTypes,as:"body",assert:!0,autoSpacing:`
`}]}recursive(){return this._get("recursive")}bindings(){return this._get("bindings")}body(){return this._get("body")}};var $e=class extends y{static get syntaxRules(){return[{type:"CompositeAlias",as:"alias",assert:!0},{type:"keyword",value:"AS"},{optional:!0,syntaxes:[[{type:"operator",as:"not_materialized_kw",value:"NOT",booleanfy:!0},{type:"keyword",value:"MATERIALIZED",assert:!0}],{type:"keyword",as:"materialized",value:"MATERIALIZED",booleanfy:!0}]},{type:["SubqueryConstructor","ValuesSetConstructor"],as:"expr"},{type:"PGSearchClause",as:"search_clause",optional:!0},{type:"PGCycleClause",as:"cycle_clause",optional:!0}]}alias(){return this._get("alias")}notMaterializedKW(){return this._get("not_materialized_kw")}materialized(){return this._get("materialized")}expr(){return this._get("expr")}searchClause(){return this._get("search_clause")}cycleClause(){return this._get("cycle_clause")}};var ps={};var Kr={};ne(Kr,{AssignmentExpr:()=>je,BasicTableExpr:()=>Ge,ColumnsConstructor:()=>Ue,DeleteStmt:()=>et,InsertStmt:()=>pe,MYOnDuplicateKeyUpdateClause:()=>qe,MYPartitionClause:()=>Fe,MYSetStmt:()=>it,MYStarredTableRef:()=>Je,MYVarAssignmentExpr:()=>We,PGConflictTarget:()=>Ye,PGConflictTargetIndexSpec:()=>He,PGDefaultValuesClause:()=>Ve,PGOnConflictClause:()=>Ke,PGReturningClause:()=>Xe,PGWhereCurrentClause:()=>Qe,SetClause:()=>ze,UpdateStmt:()=>lt,UpsertStmt:()=>pt,UsingFromClause:()=>Ze});var T=class extends y{static get syntaxRules(){return[]}get length(){return(this._get("entries")||[]).length}[Symbol.iterator](){return(this._get("entries")||[])[Symbol.iterator]()}entries(){return(this._get("entries")||[]).slice(0)}get(e){return this._get("entries",e)}set(e,r){return this._set("entries",e,r)}has(e){return this._has("entries",e)}add(...e){return this._add("entries",...e)}};var Ue=class extends T{static get syntaxRules(){return{syntax:[{type:"paren_block",syntax:{type:"ClassicColumnRef",as:"entries",arity:1/0,itemSeparator:{type:"punctuation",value:","},autoIndent:2}}]}}static get syntaxPriority(){return-1}};var L=class extends y{static get syntaxRules(){return[{type:"Expr",as:"left",peek:[1,"operator",["NOT",void 0]]},{type:"operator",as:"negation",value:"NOT",booleanfy:!0,optional:!0},{type:"operator",as:"operator"},{type:"Expr",as:"right"}]}static get syntaxPriority(){return 0}left(){return this._get("left")}negation(){return this._get("negation")}operator(){return this._get("operator")}right(){return this._get("right")}};var je=class extends L{static get syntaxRules(){return[{type:["LQDeepRef","ColumnsConstructor","ComputedColumnRef"],as:"left"},{type:"operator",as:"operator",value:"="},{type:["ValuesSetConstructor","Expr"],as:"right"}]}};var Ge=class extends y{static get syntaxRules(){return[{type:"keyword",as:"pg_only_kw",value:"ONLY",optional:!0,dialect:"postgres"},{type:"ClassicTableRef",as:"name",assert:!0},{type:"StarRef",as:"pg_star_ref",optional:!0,dialect:"postgres"},{...{optional:!0,syntaxes:[{type:"BasicAlias",as:"alias"},[{type:"keyword",as:"as_kw",value:"AS",booleanfy:!0},{type:"BasicAlias",as:"alias",assert:!0}]]}}]}name(){return this._get("name")}alias(){return this._get("alias")}pgOnlyKW(){return this._get("pg_only_kw")}pgStarRef(){return this._get("pg_star_ref")}};var qe=class extends T{static get syntaxRules(){return{dialect:"mysql",syntax:[{type:"keyword",value:"ON"},{type:"keyword",value:"DUPLICATE"},{type:"keyword",value:"KEY"},{type:"keyword",value:"UPDATE"},{type:"AssignmentExpr",as:"entries",arity:{min:1},itemSeparator:{type:"punctuation",value:","},assert:!0,autoIndent:2}]}}};var Fe=class extends T{static get syntaxRules(){return{dialect:"mysql",syntax:[{type:"keyword",value:"PARTITION"},{type:"Identifier",as:"entries",arity:{min:1},itemSeparator:{type:"punctuation",value:","},assert:!0}]}}};var Je=class extends y{static get syntaxRules(){return{dialect:"mysql",syntax:[{type:"ClassicTableRef",as:"name"},{optional:!0,syntax:[{type:"punctuation",value:".",autoSpacing:!1},{type:"StarRef",as:"star_ref",autoSpacing:!1}]}]}}name(){return this._get("name")}starRef(){return this._get("star_ref")}};var We=class extends L{static get syntaxRules(){return{dialect:"mysql",syntax:[{type:["UserVar","SystemVar"],as:"left"},{type:"operator",as:"operator",value:["=",":="]},{type:"Expr",as:"right"}]}}};var Ye=class extends y{static get syntaxRules(){return{syntaxes:[[{type:"keyword",value:"ON"},{type:"keyword",value:"CONSTRAINT"},{type:"Identifier",as:"constraint_name",assert:!0}],[{type:"paren_block",syntax:{type:"PGConflictTargetIndexSpec",as:"index_list",arity:{min:1},itemSeparator:{type:"punctuation",value:","},assert:!0},autoIndent:!0},{type:"WhereClause",as:"where_clause",optional:!0,autoIndent:!0}]]}}constraintName(){return this._get("constraint_name")}indexList(){return this._get("index_list")}whereClause(){return this._get("where_clause")}};var He=class extends y{static get syntaxRules(){return[{syntaxes:[{type:"ClassicColumnRef",as:"column_name"},{type:"paren_block",syntax:{type:"Expr",as:"expr",assert:!0},autoIndent:!0},{type:"CallExpr",as:"expr"}]},{optional:!0,syntax:[{type:"operator",value:"COLLATE"},{type:"string_literal",as:"collation",assert:!0}]},{type:"Identifier",as:"opclass",optional:!0}]}columnName(){return this._get("column_name")}expr(){return this._get("expr")}collation(){return this._get("collation")}opclass(){return this._get("opclass")}};var Ve=class extends y{static get syntaxRules(){return{dialect:"postgres",syntax:[{type:"keyword",value:"DEFAULT"},{type:"keyword",as:"_",value:"VALUES"}]}}};var Ke=class extends T{static get syntaxRules(){return{dialect:"postgres",syntax:[{type:"keyword",value:"ON"},{type:"keyword",value:"CONFLICT"},{syntaxes:[[{type:"PGConflictTarget",as:"conflict_target",optional:!0},{type:"keyword",as:"do_nothing",value:"DO"},{type:"keyword",value:"NOTHING"}],[{type:"PGConflictTarget",as:"conflict_target"},{type:"keyword",value:"DO"},{type:"keyword",value:"UPDATE"},{type:"keyword",value:"SET"},{type:"AssignmentExpr",as:"entries",arity:{min:1},itemSeparator:{type:"punctuation",value:","},assert:!0,autoIndent:2},{type:"WhereClause",as:"where_clause",optional:!0,autoIndent:!0}]]}]}}conflictTarget(){return this._get("conflict_target")}doNothing(){return this._get("do_nothing")}whereClause(){return this._get("where_clause")}};var Xe=class extends T{static get syntaxRules(){return{dialect:"postgres",syntax:[{type:"keyword",value:"RETURNING"},{type:"SelectElement",as:"entries",arity:{min:1},itemSeparator:{type:"punctuation",value:","},assert:!0,autoIndent:2}]}}};var Qe=class extends y{static get syntaxRules(){return{dialect:"postgres",syntax:[{type:"keyword",value:"WHERE"},{type:"keyword",value:"CURRENT OF"},{type:"identifier",as:"cursor_name",assert:!0}]}}cursorName(){return this._get("cursor_name")}};var ze=class extends T{static get syntaxRules(){return[{type:"keyword",value:"SET"},{type:"AssignmentExpr",as:"entries",arity:{min:1},itemSeparator:{type:"punctuation",value:","},assert:!0,autoIndent:2}]}};var Ze=class extends T{static get syntaxRules(){return[{type:"keyword",value:"USING"},{type:"FromElement",as:"entries",arity:{min:1},itemSeparator:{type:"punctuation",value:","},assert:!0}]}};var{CompleteSelectStmt:js,SubqueryConstructor:Gs,FromClause:qs,JoinClause:cs,OnClause:Fs,GroupByClause:Js,FromElement:Ws,SelectElement:ys,CompositeAlias:Ys,BasicAlias:fs,ComputedTableRef:$r,ComputedColumnRef:Ur,BinaryExpr:Hs,LQDeepRef:Vs,LQBackRef:Ks,LQBackRefConstructor:ms}=R,ue=a=>class extends a{get isSelectorStmt(){return!0}jsonfy(e={},r=null){if(!e.deSugar)return super.jsonfy(e);let t=new Map,n=(s,l,{deSugar:c,...i})=>{if(r&&(s=r(s,l,{deSugar:c,...i})),c&&s instanceof Vs){let{select:_}=this.createSelectorDimension(s,t,i);return _(s.right())}if(c&&(s instanceof Ks||s instanceof ms)){s instanceof ms&&(s=s.expr());let{alias:_}=this.createSelectorDimension(s,t,i);return _()}return s},o=super.jsonfy(e,n);return t.size&&(o=this.applySelectorDimensions(o,t,e)),o}createSelectorDimension(e,r=null,{asAggr:t=!1,...n}={}){let{left:o,right:s,table:l}=e.getOperands(),c=`dimension${t?"/g":""}::${[o,s,l].join("/")}`;if(r?.has(c))return r.get(c);let i=this._rand("rand"),_={nodeName:ys.NODE_NAME,expr:s.jsonfy(n),alias:{nodeName:fs.NODE_NAME,value:i},as_kw:!0},d={nodeName:cs.NODE_NAME,join_type:"LEFT",expr:{nodeName:Gs.NODE_NAME,expr:{nodeName:js.NODE_NAME,select_list:[_],from_clause:{nodeName:qs.NODE_NAME,entries:[{nodeName:Ws.NODE_NAME,expr:l.jsonfy(n)}]},group_by_clause:t?{nodeName:Js.NODE_NAME,entries:[{nodeName:Ur.NODE_NAME,value:i}]}:void 0}},as_kw:!0,alias:{nodeName:Ys.NODE_NAME,value:c},condition_clause:{nodeName:Fs.NODE_NAME,expr:{nodeName:Hs.NODE_NAME,operator:"=",left:o.jsonfy(n),right:{nodeName:Ur.NODE_NAME,qualifier:{nodeName:$r.NODE_NAME,value:c},value:i}}}},g={id:c,type:"join",query:d,alias:()=>({nodeName:$r.NODE_NAME,value:c}),select:m=>{let p=this._rand("ref");return d.expr.expr.select_list.push({nodeName:ys.NODE_NAME,expr:m.jsonfy(n),alias:{nodeName:fs.NODE_NAME,value:p},as_kw:!0}),{nodeName:Ur.NODE_NAME,qualifier:{nodeName:$r.NODE_NAME,value:c},value:p}}};return r?.set(c,g),g}applySelectorDimensions(e,r,t){e={...e,join_clauses:e.join_clauses?.slice(0)||[]};for(let[,{query:n}]of r)e.join_clauses.push(cs.fromJSON(n,this.options).jsonfy(t));return e}};var{FromElement:Xs,BasicTableExpr:Qs,ClassicTableRef:ds,BasicAlias:zs,CompositeAlias:Zs,ComputedTableRef:ea,ComputedColumnRef:_s,SelectElement:ta,FromClause:ra,CompleteSelectStmt:sa,SubqueryConstructor:aa,BinaryExpr:na}=R,et=class extends ue(H){static get syntaxRules(){let e={type:"punctuation",value:","};return[{type:"keyword",value:"DELETE"},{syntaxes:[{dialect:"postgres",syntax:[{type:"keyword",value:"FROM"},{type:"BasicTableExpr",as:"table_expr"},{type:"UsingFromClause",as:"using_clause",optional:!0,autoIndent:!0},{type:"JoinClause",as:"join_clause",optional:!0,autoIndent:!0},{type:["PGWhereCurrentClause","WhereClause"],as:"where_clause",optional:!0,autoIndent:!0},{type:"PGReturningClause",as:"pg_returning_clause",optional:!0,autoIndent:!0}]},{dialect:"mysql",syntax:[{type:"MYStarredTableRef",as:"my_delete_list",arity:{min:1},itemSeparator:e},{type:"FromClause",as:"my_from_clause",autoIndent:!0},{type:"JoinClause",as:"join_clause",optional:!0,autoIndent:!0},{type:"WhereClause",as:"where_clause",optional:!0,autoIndent:!0}]},{dialect:"mysql",syntax:[{type:"keyword",value:"FROM"},{type:"MYStarredTableRef",as:"my_delete_list",arity:{min:1},itemSeparator:e},{type:"UsingFromClause",as:"using_clause",autoIndent:!0},{type:"JoinClause",as:"join_clause",optional:!0,autoIndent:!0},{type:"WhereClause",as:"where_clause",optional:!0,autoIndent:!0}]},{dialect:"mysql",syntax:[{type:"keyword",value:"FROM"},{type:"BasicTableExpr",as:"table_expr"},{type:"MYPartitionClause",as:"my_partition_clause",optional:!0,autoIndent:!0},{type:"WhereClause",as:"where_clause",optional:!0,autoIndent:!0},{type:"OrderByClause",as:"my_order_by_clause",optional:!0,dialect:"mysql",autoIndent:!0},{type:"LimitClause",as:"my_limit_clause",optional:!0,dialect:"mysql",autoIndent:!0}]}]}]}tableExpr(){return this._get("table_expr")}usingClause(){return this._get("using_clause")}joinClause(){return this._get("join_clause")}whereClause(){return this._get("where_clause")}pgPGReturningClause(){return this._get("pg_returning_clause")}myPartitionClause(){return this._get("my_partition_clause")}myDeleteList(){return this._get("my_delete_list")}myFromClause(){return this._get("my_from_clause")}myOrderByClause(){return this._get("my_order_by_clause")}myLimitClause(){return this._get("my_limit_clause")}applySelectorDimensions(e,r,t){if(this.options.dialect!=="postgres")return super.applySelectorDimensions(e,r,t);if(e.where_clause?.cursor_name)throw new Error('Deep/Back Refs are currently not supported with a "WHERE CURRENT OF..." statement');let n=this._rand("rand"),o=e.table_expr.name.value,s=e.table_expr.alias?e.table_expr.alias.value:e.table_expr.name.value,l=`${n}::${s}`,c=e.where_clause,i=this.table().tableSchema().primaryKey().columns()[0];return e={...e,table_expr:{nodeName:Qs.NODE_NAME,name:{nodeName:ds.NODE_NAME,value:o},alias:{nodeName:zs.NODE_NAME,value:l}},where_clause:{nodeName:na.NODE_NAME,left:{nodeName:_s.NODE_NAME,qualifier:{nodeName:ea.NODE_NAME,value:l},value:i},operator:"IN",right:{nodeName:aa.NODE_NAME,expr:{nodeName:sa.NODE_NAME,select_list:[{nodeName:ta.NODE_NAME,expr:{nodeName:_s.NODE_NAME,value:i}}],from_clause:{nodeName:ra.NODE_NAME,entries:[{nodeName:Xs.NODE_NAME,expr:{nodeName:ds.NODE_NAME,value:o},alias:{nodeName:Zs.NODE_NAME,value:s}}]},where_clause:c,join_clauses:[...r].map(_=>_.query)}}}},e}};var{LQDeepRef:ke,LQBackRefConstructor:oa,ClassicColumnRef:ia,ComputedColumnRef:jr,ClassicTableRef:Gr,BasicAlias:ua,AssignmentExpr:tt,ColumnsConstructor:rt,RowConstructor:le,SetConstructor:qr,ValuesConstructor:gs,ValuesSetConstructor:Fr,SelectStmt:st,CompleteSelectStmt:Ie,SubqueryConstructor:De,SelectElement:at,FromElement:nt,CompositeAlias:la,FromClause:Jr,SetClause:pa,PGReturningClause:ca,BinaryExpr:Wr,BoolLiteral:ya,NumberLiteral:fa,StarRef:hs,CTE:Yr,CTEBinding:ma,UpdateStmt:Hr,InsertStmt:da,UpsertStmt:_a}=R,ot=a=>class extends a{get isPayloadStmt(){return!0}static morphsTo(){return Yr}jsonfy(e={},r=null){if(!e.deSugar)return super.jsonfy(e);let t=new Set,n=["columns_list","default_values_clause","values_clause","select_clause"].map(u=>this._get(u)),[o,s,l,c]=n,i=o?.some(u=>u instanceof ke),_=i?new Set(n):new Set,d=(u,g,{deSugar:m,...p})=>{if(r&&(u=r(u,g,{deSugar:m,...p})),_.has(u))return;if(!(m&&u instanceof tt))return u;let E=!!this._get("on_conflict_clause")?.containsNode(u),x={...p,onConflictClauseContext:E};if(u.left()instanceof ke){let[[N],[[h]]]=this.deSugarPayload([u.left()],[[u.right()]],t,x);return N?{nodeName:tt.NODE_NAME,operator:"=",left:N,right:h}:void 0}if(u.left()instanceof rt&&u.left().entries().some(N=>N instanceof ke)){let N=u.left().entries(),h,S;return u.right()instanceof qr?([h,S]=this.deSugarPayload(N,[u.right().entries()],t,x),S={nodeName:le.NODE_NAME,entries:S}):u.right()instanceof De?([h,S]=this.deSugarPayload(N,u.right().expr(),t,x),S={nodeName:De.NODE_NAME,expr:S}):[h,S]=this.deSugarPayload(N,[[u.right()]],t,x),h.length?{nodeName:tt.NODE_NAME,operator:"=",left:{nodeName:rt.NODE_NAME,entries:h},right:S}:void 0}},f=super.jsonfy(e,d);if(i){let[u,g]=this.deSugarPayload(o,c||l.entries().map(m=>m.entries()),t,e);if(f={...f,columns_list:u},c)f={...f,select_clause:g};else{let m=g.map(p=>({nodeName:le.NODE_NAME,entries:p}));f={...f,values_clause:{nodeName:gs.NODE_NAME,entries:m}}}}return t.size&&(f=this.applyPayloadDimensions(f,t,e)),f}deSugarPayload(e,r,t,{onConflictClauseContext:n=!1,deSugar:o,...s}={}){let l=(u,g)=>u.reduce(u,(m,p)=>{if(m instanceof ke){let E=this.createPayloadDimension(m,t,{onConflictClauseContext:n,...s});return g.set(p,E),E.type==="dependency"&&E.leftJson?u.concat(E.leftJson):u}return u.concat(m.jsonfy({deSugar:o,...s}))},[]),c=(u,g)=>{let m=u.jsonfy(s),p=m.select_list;if(p[0].expr.nodeName===hs.NODE_NAME)throw new Error("TODO");if(!n){let x=this._rand("cte"),N={...m,uuid:x,select_list:[{nodeName:at.NODE_NAME,expr:{nodeName:hs.NODE_NAME}}]};t?.add({type:"memo",query:N});let h={nodeName:nt.NODE_NAME,expr:{nodeName:Gr.NODE_NAME,value:x}};m={nodeName:Ie.NODE_NAME,from_clause:{nodeName:Jr.NODE_NAME,entries:[h]}}}let E=p.reduce((x,N,h)=>{if(g.has(h)){let S;N.expr.nodeName===le.NODE_NAME?S=N.expr.entries:S=[N.expr];let A=st.fromJson({...m,select_list:S.map(j=>({nodeName:at.NODE_NAME,expr:j}))});if(N=g.get(h).offload(A,rowOffset),N)return x.concat(N)}return x.concat(N)},[]);return{...m,select_list:E}},i=(u,g)=>u.map((m,p)=>m.reduce((E,x,N)=>{let h=g.has(N)?g.get(N).offload(x,p):x.jsonfy({deSugar:o,...s});return h?E.concat(h):E},[])),_=new Map,d=l(e,_),f=r instanceof st?c(r,_):i(r,_);return _.clear(),[d,f]}createPayloadDimension(e,r=null,{onConflictClauseContext:t=!1,...n}={}){let{left:o,right:s,table:l}=e.getOperands(),c=`dimension${t?"/c":""}::${[o,s,l].join("/")}`,i=o.jsonfy(n),_=s.jsonfy(n),d,f=e.right();if(f instanceof rt)d=f.jsonfy(n);else if(f instanceof ia||f instanceof ke)d={nodeName:rt.NODE_NAME,entries:[f.jsonfy(n)]};else throw new Error(`Invalid columns spec: ${e}`);let u=d.entries.length,g=h=>{let S=1;if(h instanceof De?S=h.expr().length:(h instanceof st||h instanceof le)&&(S=h.length),S>u)throw new Error("INSERT has more expressions than target columns");if(S<u)throw new Error("INSERT has more target columns than expressions");return h},m=(h,S,A=null,j=null)=>{let F=typeof A=="number"?{nodeName:Wr.NODE_NAME,operator:"->>",left:S,right:{nodeName:fa.NODE_NAME,value:A}}:S,w=typeof j=="string"?{nodeName:Wr.NODE_NAME,operator:"IS",left:{nodeName:jr.NODE_NAME,value:j},right:{nodeName:ya.NODE_NAME,value:"TRUE"}}:null,B={nodeName:nt.NODE_NAME,expr:{nodeName:Gr.NODE_NAME,value:h}},G={nodeName:Ie.NODE_NAME,select_list:[{nodeName:at.NODE_NAME,expr:F}],from_clause:{nodeName:Jr.NODE_NAME,entries:[B]},...w?{where_clause:w}:{}};return{nodeName:De.NODE_NAME,expr:G}};if(this instanceof Hr||t){let h=t?`${this.uuid}_on_conflict_updated_status`:null,S={nodeName:Wr.NODE_NAME,operator:"IN",left:_,right:m(this.uuid,i,null,h)},A={uuid:this._rand("query"),nodeName:Hr.NODE_NAME,tables:[{nodeName:nt.NODE_NAME,expr:l.jsonfy(n)}],set_clause:{nodeName:pa.NODE_NAME,entries:[]},where_clause:S},F={id:c,type:"dependent",query:A,offload:w=>{if(w instanceof Fr)throw new Error(`Single-row payload structure expected for column structure: ${e.right()}. Recieved ${w.NODE_NAME}.`);if(A.set_clause.entries.length)throw new Error(`Unexpected offload() call on ${e}`);g(w);let B=w.jsonfy(n);w instanceof st?B={nodeName:De.NODE_NAME,expr:B}:w instanceof qr||(B={nodeName:le.NODE_NAME,entries:[B]}),A.set_clause.entries.push({nodeName:tt.NODE_NAME,operator:"=",left:d,right:B})},leftJson:i,onConflictClauseContext:t};return r?.add(F),F}let p={uuid:this._rand("query"),nodeName:this.NODE_NAME,table:l.jsonfy(n),columns_list:d,values_clause:{nodeName:gs.NODE_NAME,entries:[]}},E=(h,S=null)=>{g(h);let A=h instanceof qr?h.jsonfy(n):{nodeName:le.NODE_NAME,entries:[h.jsonfy(n)]};S?p.values_clause.entries.push({...A,entries:A.entries.concat(S)}):p.values_clause.entries.push(A)};if(e.left()instanceof oa){p.columns_list.push(_);let S={id:c,type:"dependent",query:p,offload:(A,j)=>{let F=m(this.uuid,i,j);if(A instanceof Ie){g(A),delete p.values_clause;let w={nodeName:at.NODE_NAME,expr:F,alias:s instanceof jr?{nodeName:ua.NODE_NAME,value:s.value()}:void 0},B=A.jsonfy(n);p.select_clause={...B,select_list:B.select_list.concat(w)};return}if(A instanceof Fr)for(let w of A.expr())E(w,F);else E(A,F)},leftJson:i};return r?.add(S),S}let N={id:c,type:"dependency",query:p,offload:(h,S)=>{if(h instanceof Fr)throw new Error(`Single-row payload structure expected for column structure: ${e.right()}. Recieved ${h.NODE_NAME}.`);if(p.values_clause.entries.length||p.select_clause)throw new Error(`Unexpected offload() call on ${e}`);h instanceof Ie?(g(h),delete p.values_clause,p.select_clause=h.jsonfy(n)):E(h);let A={nodeName:jr.NODE_NAME,value:s.value()};return m(p.uuid,A,S)},leftJson:i};return r?.add(N),N}applyPayloadDimensions(e,r,t){let n={nodeName:Yr.NODE_NAME,bindings:[],body:null},o=(_,d)=>{d.nodeName===Yr.NODE_NAME&&(n.bindings.push(...d.bindings),d=d.body),n.bindings.push({nodeName:ma.NODE_NAME,alias:{nodeName:la.NODE_NAME,value:_},expr:d})},s=(_,d)=>{for(let f of[Hr,da,_a]){let u=f.fromJSON(_,d);if(u)return u}},l=[],c=[],i;for(let{id:_,type:d,query:f,leftJson:u,onConflictClauseContext:g}of r){if(d==="dependent"){c.find(m=>oe(m,u))||c.push(u),g&&(i=!0),l.push({id:_,query:f});continue}o(_,s(f,this.options).jsonfy(t))}if(l.length){let _=e.returning_clause,d={nodeName:ca.NODE_NAME,entries:[...c]};if(i){let u=`${this.uuid}_on_conflict_updated_status`}o(this.uuid,{...e,returning_clause:d});for(let{id:u,query:g}of l)o(u,s(g,this.options).jsonfy(t));let f={nodeName:nt.NODE_NAME,expr:{nodeName:Gr.NODE_NAME,value:this.uuid}};n.body={nodeName:Ie.NODE_NAME,select_list:_.entries,from_clause:{nodeName:Jr.NODE_NAME,entries:[f]}}}else n.body=e;return n}};var pe=class extends ot(H){static get _clause(){return"INSERT"}static get syntaxRules(){let e={type:"punctuation",value:","},r={optional:!0,dialect:"mysql",if:["!select_clause","!my_table_clause"],syntax:[{type:"keyword",value:"AS"},{type:"CompositeAlias",as:"my_alias",assert:!0}]};return[{type:"keyword",value:this._clause},{type:"keyword",value:"INTO"},{dialect:"postgres",syntax:[{type:"BasicTableExpr",as:"table_expr"},{type:"ColumnsConstructor",as:"column_list",arity:{min:1},itemSeparator:e,optional:!0,autoIndent:2},{syntaxes:[{type:"PGDefaultValuesClause",as:"pg_default_values_clause",autoIndent:!0},{type:"ValuesConstructor",as:"values_clause",autoIndent:!0},{type:"SelectStmt",as:"select_clause",autoIndent:!0}]},...this._clause==="INSERT"?[{type:"PGOnConflictClause",as:"conflict_handling_clause",optional:!0,autoIndent:!0}]:[],{type:"PGReturningClause",as:"pg_returning_clause",optional:!0,autoIndent:!0}]},{dialect:"mysql",syntax:[{type:"ClassicTableRef",as:"table_expr"},{type:"MYPartitionClause",as:"my_partition_clause",optional:!0,autoIndent:!0},{syntaxes:[[{type:"ColumnsConstructor",as:"column_list",arity:{min:1},itemSeparator:e,optional:!0,autoIndent:2},{syntaxes:[{type:"ValuesConstructor",as:"values_clause",autoIndent:!0},{type:"SelectStmt",as:"select_clause",autoIndent:!0},{type:"TableStmt",as:"my_table_clause",autoIndent:!0}]}],{type:"SetClause",as:"my_set_clause",autoIndent:!0}]},{...r},...this._clause==="INSERT"?[{type:"MYOnDuplicateKeyUpdateClause",as:"conflict_handling_clause",optional:!0,autoIndent:!0}]:[]]}]}tableExpr(){return this._get("table_expr")}columnList(){return this._get("column_list")}valuesClause(){return this._get("values_clause")}selectClause(){return this._get("select_clause")}conflictHandlingClause(){return this._get("conflict_handling_clause")}pgDefaultValuesClause(){return this._get("pg_default_values_clause")}pgPGReturningClause(){return this._get("pg_returning_clause")}myAlias(){return this._get("my_alias")}myPartitionClause(){return this._get("my_partition_clause")}mySetClause(){return this._get("my_set_clause")}myTableClause(){return this._get("my_table_clause")}};var it=class extends T{static get syntaxRules(){return[{type:"keyword",value:"SET"},{type:"MYVarAssignmentExpr",as:"entries",arity:{min:1},itemSeparator:{type:"punctuation",value:","},assert:!0,autoIndent:2}]}};var{SubqueryConstructor:ga,CompleteSelectStmt:ha,SelectElement:xa,BasicAlias:Ea,CompositeAlias:Na,FromClause:xs,WhereClause:Es,ComputedColumnRef:ut,ComputedTableRef:Vr,BinaryExpr:Ns,ClassicTableRef:Sa,FromElement:Ss}=R,lt=class extends ot(ue(H)){static get syntaxRules(){return{syntaxes:[{dialect:"postgres",syntax:[{type:"keyword",value:"UPDATE"},{type:"BasicTableExpr",as:"table_expr"},{type:"SetClause",as:"set_clause"},{type:"FromClause",as:"pg_from_clause",optional:!0,dialect:"postgres",autoIndent:!0},{type:"JoinClause",as:"join_clause",optional:!0,autoIndent:!0},{type:["PGWhereCurrentClause","WhereClause"],as:"where_clause",optional:!0,autoIndent:!0},{type:"PGReturningClause",as:"pg_returning_clause",optional:!0,autoIndent:!0}]},{dialect:"mysql",syntax:[{type:"keyword",value:"UPDATE"},{type:"BasicTableExpr",as:"table_expr"},{type:"SetClause",as:"set_clause"},{type:"WhereClause",as:"where_clause",optional:!0,autoIndent:!0},{type:"OrderByClause",as:"my_order_by_clause",optional:!0,autoIndent:!0},{type:"LimitClause",as:"my_limit_clause",optional:!0,autoIndent:!0}]},{dialect:"mysql",syntax:[{type:"keyword",value:"UPDATE"},{type:"MYStarredTableRef",as:"my_update_list",arity:{min:1},itemSeparator:{type:"punctuation",value:","}},{type:"JoinClause",as:"join_clause",optional:!0,autoIndent:!0},{type:"SetClause",as:"set_clause"},{type:"WhereClause",as:"where_clause",optional:!0,autoIndent:!0}]}]}}tableExpr(){return this._get("table_expr")}joinClause(){return this._get("join_clause")}setClause(){return this._get("set_clause")}whereClause(){return this._get("where_clause")}pgFromClause(){return this._get("pg_from_clause")}pgPGReturningClause(){return this._get("pg_returning_clause")}myUpdateList(){return this._get("my_update_list")}myOrderByClause(){return this._get("my_order_by_clause")}myLimitClause(){return this._get("my_limit_clause")}jsonfy(e={}){if(!e.deSugar)return super.jsonfy(e);let r=new Map,t=(o,s,{deSugar:l,...c})=>{if(l&&o instanceof LQDeepRef){let{select:i}=this.deSugarLQRef(r,o,c);return i(o.right())}if(l&&(o instanceof LQBackRef||o instanceof LQBackRefConstructor)){o instanceof LQBackRefConstructor&&(o=o.expr());let{alias:i}=this.deSugarLQRef(r,o,c);return i()}return o},n=super.jsonfy(e,t);return r.size&&(n=this.applySelectorDimensions(n,r,e)),n}applySelectorDimensions(e,r,t){if(this.options.dialect!=="postgres")return super.applySelectorDimensions(e,r,t);if(e.where_clause?.cursor_name)throw new Error('Deep/Back Refs are currently not supported with a "WHERE CURRENT OF..." statement');let n=this._rand("rand"),o,s=l=>{let c=e.table_expr,i=c.name.value,_=c.alias?c.alias.value:c.name.value,d=l.value;if(l.qualifier.value!==_)return l;let f=`${n}::${_}`,u=`${n}::${d}`;if(!o){let g={nodeName:Ss.NODE_NAME,expr:{nodeName:ga.NODE_NAME,expr:{nodeName:ha.NODE_NAME,select_list:[],pg_from_clause:{nodeName:xs.NODE_NAME,entries:[{nodeName:Ss.NODE_NAME,expr:{nodeName:Sa.NODE_NAME,value:i}}]}}},as_kw:!0,alias:{nodeName:Na.NODE_NAME,value:f}},m={nodeName:Ns.NODE_NAME,left:{nodeName:ut.NODE_NAME,qualifier:{nodeName:Vr.NODE_NAME,value:_},value:d},operator:"=",right:{nodeName:ut.NODE_NAME,qualifier:{nodeName:Vr.NODE_NAME,value:f},value:u}};o={from:g,where:m}}return o.from.expr.expr.select_list.push({nodeName:xa.NODE_NAME,expr:{nodeName:ut.NODE_NAME,value:d},alias:{nodeName:Ea.NODE_NAME,value:u}}),{nodeName:ut.NODE_NAME,qualifier:{nodeName:Vr.NODE_NAME,value:f},value:u}};e={...e,join_clauses:e.join_clauses?.slice(0)||[]};for(let[,{query:l}]of r){let c={...l.condition_clause.expr};c.left=s(c.left),e.join_clauses.push(l)}return o&&(e={...e,pg_from_clause:{nodeName:xs.NODE_NAME,entries:e.pg_from_clause?.entries?.slice(0)||[]}},e.pg_from_clause.entries.push(o.from),e.where_clause?e.where_clause={nodeName:Es.NODE_NAME,expr:{nodeName:Ns.NODE_NAME,operator:"AND",left:e.where_clause.expr,right:o.where}}:e.where_clause={nodeName:Es.NODE_NAME,expr:o.where}),e}};var ce=a=>class extends a{get isSugar(){return!0}};var pt=class extends ce(pe){static get _clause(){return"UPSERT"}jsonfy(e={}){if(!e.deSugar)return super.jsonfy(e);if(this.conflictHandlingClause())throw new Error('A redundanct "ON CONFLICT" clause in query.');let r=super.jsonfy(e),t=(this.set()?this.set().columns():this.columns().entries()).map(s=>s.name()),n=this.params.dialect==="mysql"?s=>l=>l.fn("VALUES",s):s=>["EXCLUDED",s],o=OnConflictClause.fromJSON(this,{entries:[]});for(let s of t)o.add([s,n(s)]);if(this.params.dialect!=="mysql"){let s=this.into().schema(),l=[].concat(s.primaryKey()||[]).concat(s.uniqueKeys()).map(i=>i.columns());if(!l.length)throw new Error(`Table ${this.into().clone({fullyQualified:!0})} has no unique keys defined to process an UPSERT operation. You may want to perform a direct INSERT operation.`);let c=l.find(i=>_intersect(i,t).length)||l[0];o.columnsSpec(...c)}return{nodeName:InsertStatement.NODE_NAME,...superJson,onConflictClause:o.jsonfy(e),...flags?{flags}:{}}}};var Xr={};ne(Xr,{BasicAlias:()=>_e,BasicSelectStmt:()=>Ee,CompleteSelectStmt:()=>$t,CompositeAlias:()=>ft,CompositeSelectStmt:()=>Ut,DistinctClause:()=>mt,ForClause:()=>dt,FromClause:()=>_t,FromElement:()=>ge,FunctionsSetConstructor:()=>ct,GroupByClause:()=>gt,GroupingElement:()=>ht,HavingClause:()=>xt,JoinClause:()=>Et,LQBackRefConstructor:()=>ye,LimitClause:()=>Nt,OffsetClause:()=>St,OnClause:()=>At,OrderByClause:()=>Tt,OrderElement:()=>Ot,PGFetchClause:()=>wt,PGOrderOperator:()=>vt,PartitionByClause:()=>Rt,RowConstructor:()=>fe,SRFSpec:()=>Ct,SelectElement:()=>bt,SelectStmt:()=>te,SetConstructor:()=>ee,SubqueryConstructor:()=>me,TableStmt:()=>jt,UsingClause:()=>kt,ValuesConstructor:()=>de,ValuesSetConstructor:()=>yt,WhereClause:()=>It,WindowClause:()=>Dt,WindowDeclaration:()=>Lt,WindowFrameBound:()=>Pt,WindowFrameSpec:()=>Mt,WindowSpec:()=>Bt});var ct=class extends T{static get syntaxRules(){return[{type:"keyword",value:"ROWS"},{type:"keyword",value:"FROM"},{type:"paren_block",syntax:{type:"SRFSpec",as:"entries",arity:{min:1},itemSeparator:{type:"punctuation",value:","},assert:!0,autoIndent:2},autoIndent:!0,autoSpacing:!1}]}static get syntaxPriority(){return-1}};var Z=class a extends y{static get syntaxRules(){return{type:"paren_block",syntax:{type:"Expr",as:"expr"},autoIndent:!0}}static get syntaxPriority(){return-1}expr(){return this._get("expr")}exprUnwrapped(){let e=this._get("expr");return e instanceof a?e.exprUnwrapped():e}};var{LQBackRef:As}=R,ye=class extends Z{static get syntaxRules(){return{type:"paren_block",syntax:{type:"Expr",as:"expr",peek:[1,"operator","<~"]}}}static get syntaxPriority(){return 51}static morphsTo(){return this.expr()?.constructor().morphsTo()}_capture(e,r){return e==="CONTEXT.TABLE_SCHEMA"?this.tableSchema():super._capture(e,r)}expr(){return this._get("expr")}tableSchema(){let e=this.expr();if(!(e instanceof As))throw new Error(`[${this.constructor.name}.<expr>] Expects an instance of LQBackRef but got ${e?.constructor.name}`);return e.tableSchema()}jsonfy(e={},r=null){if(e.deSugar){let t=this.expr();if(!(t instanceof As))throw new Error(`[${this.constructor.name}.<expr>] Expects an instance of LQBackRef but got ${t?.constructor.name}`);return t.jsonfy(e,r)}return super.jsonfy(e,r)}};var ee=class extends T{static get syntaxRules(){return{syntax:[{type:"paren_block",syntax:{type:"Expr",as:"entries",arity:1/0,itemSeparator:{type:"punctuation",value:","},autoIndent:2},autoIndent:!0,autoIndentAdjust:-1}]}}static get syntaxPriority(){return 49}};var fe=class extends ee{static get syntaxRules(){return[{type:"keyword",value:"ROW"},...[].concat(super.syntaxRules)]}};var me=class extends Z{static get syntaxRules(){return{type:"paren_block",syntax:{type:["SelectStmt","InsertStmt","UpsertStmt","UpdateStmt","DeleteStmt","CTE"],as:"expr"},autoIndent:!0}}static get syntaxPriority(){return 51}};var de=class extends T{static get syntaxRules(){let e={type:"punctuation",value:","};return{syntaxes:[[{type:"keyword",value:"VALUES"},{type:"SetConstructor",as:"entries",arity:{min:1},itemSeparator:e,assert:!0}],{dialect:"mysql",syntax:[{type:"keyword",value:["VALUES","VALUE"]},{type:"SetConstructor",as:"entries",arity:{min:1},itemSeparator:e,assert:!0}]}]}}static get syntaxPriority(){return-1}};var yt=class extends de{static get syntaxRules(){return{type:"paren_block",syntax:super.syntaxRules,autoIndent:!0}}static get syntaxPriority(){return-1}};var X=class extends y{static get syntaxRules(){return{type:"identifier",as:"."}}static get syntaxPriority(){return-1}value(){return this._get("value")}identifiesAs(e){return typeof e=="string"?this._eq(this._get("value"),e,"ci"):super.identifiesAs(e)}};var _e=class extends X{static get syntaxRules(){return[...[].concat(super.syntaxRules),{type:"AggrNotation",as:"is_aggr",autoSpacing:!1,optional:!0}]}isAggr(){return this._get("is_aggr")}};var ft=class extends X{static get syntaxRules(){let e={type:"punctuation",value:","};return{syntaxes:[[{...[].concat(super.syntaxRules)[0]},{type:"paren_block",syntax:{type:"Identifier",as:"columns",arity:{min:1},itemSeparator:e,assert:!0},if:"value",optional:!0,optionalParens:!0}],{type:"paren_block",syntax:{type:"Identifier",as:"columns",arity:{min:1},itemSeparator:e,assert:!0}}]}}columns(){return this._get("columns")}};var mt=class extends y{static get syntaxRules(){return{syntaxes:[{dialect:"postgres",syntax:[{type:"keyword",value:"DISTINCT"},{type:"keyword",value:"ON"},{type:"paren_block",syntax:{type:"Expr",as:"pg_distinct_on_list",arity:{min:1},itemSeparator:{type:"punctuation",value:","},assert:!0}}]},{type:"keyword",as:"all_or_distinct",value:["ALL","DISTINCT"]}]}}allOrDistinct(){return this._get("all_or_distinct")}pgDistinctOnList(){return this._get("pg_distinct_on_list")}};var dt=class extends y{static get syntaxRules(){return[{type:"keyword",value:"FOR"},{optional:!0,dialect:"postgres",syntaxes:[[{type:"keyword",as:"pg_no_key_kw",value:"NO",booleanfy:!0},{type:"keyword",value:"KEY",if:"pg_no_key_kw",assert:!0}],{type:"keyword",as:"pg_key_kw",value:"KEY",booleanfy:!0}]},{type:"keyword",as:"intent_kw",value:["UPDATE","SHARE"],assert:!0},{optional:!0,syntax:[{type:"keyword",value:"OF"},{type:"ComputedTableRef",as:"table_names",arity:{min:1},itemSeparator:{type:"punctuation",value:","},assert:!0}]},{optional:!0,syntaxes:[[{type:"keyword",as:"skip_locked_kw",value:"SKIP",booleanfy:!0},{type:"keyword",value:"LOCKED",assert:!0}],{type:"keyword",as:"nowait_kw",value:"NOWAIT",booleanfy:!0},{dialect:"mysql",syntax:[{type:"keyword",as:"my_lock_in_share_mode",value:"LOCK",booleanfy:!0},{type:"operator",value:"IN",assert:!0},{type:"keyword",value:"SHARE",assert:!0},{type:"keyword",value:"MODE",assert:!0}]}]}]}intentKW(){return this._get("intent_kw")}tableNames(){return this._get("table_names")}skipLockedKW(){return this._get("skip_locked_kw")}nowaitKW(){return this._get("nowait_kw")}pgKeyKW(){return this._get("pg_key_kw")}pgNoKeyKW(){return this._get("pg_no_key_kw")}myLockInShareMode(){return this._get("my_lock_in_share_mode")}};var _t=class extends T{static get syntaxRules(){return[{type:"keyword",value:"FROM"},{type:"FromElement",as:"entries",arity:{min:1},itemSeparator:{type:"punctuation",value:","},assert:!0}]}};var ge=class extends y{static get syntaxRules(){let e={type:"punctuation",value:","},r={optional:!0,syntaxes:[{type:"CompositeAlias",as:"alias"},[{type:"keyword",as:"as_kw",value:"AS",booleanfy:!0},{type:"CompositeAlias",as:"alias",assert:!0}]]},t={optional:!0,dialect:"postgres",syntax:[{type:"keyword",value:"TABLESAMPLE"},{syntaxes:[[{type:"keyword",as:"pg_sampling_method",value:["BERNOULLI","SYSTEM"]},{type:"paren_block",syntax:{type:"Expr",as:"pg_sampling_arguments",arity:1,itemSeparator:e,assert:!0}}],[{type:"identifier",as:"pg_sampling_method"},{type:"paren_block",syntax:{type:"Expr",as:"pg_sampling_arguments",arity:1/0,itemSeparator:e,assert:!0}}]],assert:!0},{optional:!0,syntax:[{type:"keyword",value:"REPEATABLE"},{type:"paren_block",syntax:{type:"Expr",as:"pg_repeatable_seed"},assert:!0}]}]},n={optional:!0,dialect:"postgres",syntax:[{type:"keyword",as:"pg_with_ordinality",value:"WITH",booleanfy:!0},{type:"keyword",value:"ORDINALITY",assert:!0}]};return{syntaxes:[[{type:"keyword",as:"lateral_kw",value:"LATERAL",optional:!0},{type:"CallExpr",as:"expr"},{...r,optional:!1}],{dialect:"postgres",syntax:[{type:"keyword",as:"lateral_kw",value:"LATERAL",optional:!0},{type:["FunctionsSetConstructor","CallExpr"],as:"expr"},{...n},{...r}]},[{type:"keyword",as:"lateral_kw",value:"LATERAL",optional:!0},{type:["SubqueryConstructor","ValuesSetConstructor"],as:"expr",dialect:"postgres"},{type:"SubqueryConstructor",as:"expr",dialect:"mysql"},{...r}],[{type:"keyword",as:"pg_only_kw",value:"ONLY",optional:!0,dialect:"postgres"},{type:"ClassicTableRef",as:"expr"},{type:"StarRef",as:"pg_star_ref",optional:!0,dialect:"postgres"},{...r},{...t}]]}}expr(){return this._get("expr")}lateralKW(){return this._get("lateral_kw")}asKW(){return this._get("as_kw")}alias(){return this._get("alias")}pgOnlyKW(){return this._get("pg_only_kw")}pgStarRef(){return this._get("pg_star_ref")}pgSamplingMethod(){return this._get("pg_sampling_method")}pgSamplingArguments(){return this._get("pg_sampling_arguments")}pgRepeatableSeed(){return this._get("pg_repeatable_seed")}pgWithOrdinality(){return this._get("pg_with_ordinality")}};var gt=class extends T{static get syntaxRules(){return[{type:"keyword",value:"GROUP"},{type:"keyword",value:"BY",assert:!0},{type:"keyword",as:"all_or_distinct",value:["ALL","DISTINCT"],optional:!0},{type:"GroupingElement",as:"entries",arity:{min:1},itemSeparator:{type:"punctuation",value:","},assert:!0,autoIndent:2},{optional:!0,autoIndent:!0,syntax:[{type:"keyword",as:"with_rollup",value:"WITH",booleanfy:!0},{type:"keyword",value:"ROLLUP",assert:!0}]}]}allOrDistinct(){return this._get("all_or_distinct")}withRollup(){return this._get("with_rollup")}};var ht=class extends y{static get syntaxRules(){return{syntaxes:[[{type:"keyword",value:"GROUPING SETS"},{type:"paren_block",syntax:{type:"GroupingElement",as:"grouping_sets",arity:{min:1},itemSeparator:{type:"punctuation",value:","},assert:!0,autoIndent:2},autoIndent:!0}],[{type:"keyword",value:"ROLLUP"},{type:"SetConstructor",as:"rollup_set",assert:!0}],[{type:"keyword",value:"CUBE"},{type:"SetConstructor",as:"cube_set",assert:!0}],{type:["Expr","ParenShape"],as:"expr"}]}}groupingSets(){return this._get("grouping_sets")}rollupSet(){return this._get("rollup_set")}cubeSet(){return this._get("cube_set")}expr(){return this._get("expr")}};var xt=class extends y{static get syntaxRules(){return[{type:"keyword",value:"HAVING"},{type:"Expr",as:"expr",assert:!0}]}static get syntaxPriority(){return-1}expr(){return this._get("expr")}};var Et=class extends ge{static get syntaxRules(){return{syntaxes:[[{type:"keyword",as:"join_type",value:"CROSS"},{type:"keyword",value:"JOIN",assert:!0},...[].concat(super.syntaxRules)],[{type:"keyword",as:"natural_kw",value:"NATURAL",booleanfy:!0,optional:!0},{optional:!0,syntaxes:[{type:"keyword",as:"join_type",value:"INNER"},[{type:"keyword",as:"join_type",value:["LEFT","RIGHT","FULL"],dialect:"postgres"},{type:"keyword",as:"join_type",value:["LEFT","RIGHT"],dialect:"mysql"},{type:"keyword",as:"outer_kw",value:"OUTER",booleanfy:!0,optional:!0}]]},{type:"keyword",value:"JOIN"},...[].concat(super.syntaxRules),{type:["OnClause","UsingClause"],as:"condition_clause",if:"!natural_kw",autoIndent:!0}]]}}naturalKW(){return this._get("natural_kw")}joinType(){return this._get("join_type")}outerKW(){return this._get("outer_kw")}conditionClause(){return this._get("condition_clause")}};var Nt=class extends y{static get syntaxRules(){return[{type:"keyword",value:"LIMIT"},{dialect:"mysql",syntax:[{optional:!0,syntax:[{type:"Expr",as:"my_offset"},{type:"punctuation",value:",",autoSpacing:!1}]},{type:"Expr",as:"expr",assert:!0}]},{dialect:"postgres",syntaxes:[{type:"keyword",as:"pg_all_kw",value:"ALL"},{type:"Expr",as:"expr",assert:!0}]}]}expr(){return this._get("expr")}pgAllKW(){return this._get("pg_all_kw")}myOffset(){return this._get("my_offset")}};var St=class extends y{static get syntaxRules(){return[{type:"keyword",value:"OFFSET"},{type:"Expr",as:"expr",assert:!0},{type:"keyword",as:"pg_row_kw",value:["ROW","ROWS"],optional:!0,dialect:"postgres"}]}expr(){return this._get("expr")}pgRowKW(){return this._get("pg_row_kw")}};var At=class extends y{static get syntaxRules(){return[{type:"keyword",value:"ON"},{type:"Expr",as:"expr",assert:!0}]}expr(){return this._get("expr")}};var Tt=class extends T{static get syntaxRules(){return[{type:"keyword",value:"ORDER"},{type:"keyword",value:"BY",assert:!0},{type:"OrderElement",as:"entries",arity:{min:1},itemSeparator:{type:"punctuation",value:","},assert:!0,autoIndent:2},{optional:!0,autoIndent:!0,syntax:[{type:"keyword",as:"with_rollup",value:"WITH",booleanfy:!0},{type:"keyword",value:"ROLLUP",assert:!0}]}]}withRollup(){return this._get("with_rollup")}};var Ot=class extends y{static get syntaxRules(){return[{type:"Expr",as:"expr"},{optional:!0,syntaxes:[{type:"keyword",value:["ASC","DESC"],as:"dir"},{type:"PGOrderOperator",as:"dir"}]},{optional:!0,syntax:[{type:"keyword",value:"NULLS"},{type:"keyword",as:"nulls_spec",value:["FIRST","LAST"],assert:!0}]}]}expr(){return this._get("expr")}dir(){return this._get("dir")}nullsSpec(){return this._get("nulls_spec")}};var Rt=class extends T{static get syntaxRules(){return[{type:"keyword",value:"PARTITION"},{type:"keyword",value:"BY",assert:!0},{type:"Expr",as:"entries",arity:{min:1},itemSeparator:{type:"punctuation",value:","},assert:!0,autoIndent:2}]}};var wt=class extends y{static get syntaxRules(){return{dialect:"postgres",syntax:[{type:"keyword",value:"FETCH"},{type:"keyword",as:"rel_kw",value:["FIRST","NEXT"]},{type:["SubqueryConstructor","Expr"],as:"expr",optional:!0},{type:"keyword",as:"row_kw",value:["ROW","ROWS"],assert:!0},{syntaxes:[{type:"keyword",value:"ONLY"},[{type:"keyword",as:"with_ties",value:"WITH"},{type:"keyword",value:"TIES",assert:!0}]]}]}}relKW(){return this._get("rel_kw")}expr(){return this._get("expr")}rowKW(){return this._get("row_kw")}withTies(){return this._get("with_ties")}};var vt=class extends y{static get syntaxRules(){return{dialect:"postgres",syntax:[{type:"keyword",value:"USING"},{type:"operator",as:".",assert:!0}]}}value(){return this._get("value")}};var he=class extends y{static get syntaxRules(){let e={type:"punctuation",value:","};return{syntaxes:[{peek:[0,"keyword",["NOW","CURRENT_DATE","CURRENT_TIME","CURRENT_TIMESTAMP","IF","NULLIF","IFNULL","COALESCE","GREATEST","LEAST","CONCAT","CONCAT_WS","FORMAT","MD5","SHA1","TO_JSON","TO_JSONB","JSON_TYPEOF","JSONB_TYPEOF","JSON_BUILD_ARRAY","JSONB_BUILD_ARRAY","JSON_BUILD_OBJECT","JSONB_BUILD_OBJECT","JSON_POPULATE_RECORD","JSONB_POPULATE_RECORD","JSON_PATH_QUERY","JSON_PATH_EXISTS","JSON_ARRAY","JSON_OBJECT","JSON_EXTRACT","JSON_UNQUOTE","JSON_SET","JSON_INSERT","JSON_REPLACE","JSON_REMOVE","JSON_SEARCH","JSON_CONTAINS","JSON_CONTAINS_PATH","JSON_KEYS","JSON_ARRAY_APPEND","JSON_ARRAY_INSERT","JSON_DEPTH","JSON_LENGTH","JSON_MERGE_PRESERVE","JSON_MERGE_PATCH","JSON_PRETTY","JSON_STORAGE_FREE","ST_ASTEXT","ST_ASGEOJSON","ST_GEOMFROMTEXT","ST_WITHIN","ST_CONTAINS","ST_INTERSECTS","ST_DISTANCE","ST_BUFFER","MAKE_DATE","MAKE_TIME","MAKE_TIMESTAMP","ARRAY","CURDATE","CURTIME","SYSDATE","STR_TO_DATE","MAKEDATE","MAKETIME"]],syntaxes:[[{type:"keyword",as:"name",value:["CURRENT_DATE","CURRENT_TIME","CURRENT_TIMESTAMP"]},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:0,itemSeparator:e,assert:!0},optional:!0,optionalParens:!0,autoSpacing:!1}],[{type:"keyword",as:"name",value:["NOW"]},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:0,itemSeparator:e,assert:!0},optional:!0,autoSpacing:!1}],[{type:"keyword",as:"name",value:["IF","NULLIF","IFNULL"]},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:{min:2,max:3},itemSeparator:e,assert:!0},autoSpacing:!1}],[{type:"keyword",as:"name",value:["COALESCE","GREATEST","LEAST","CONCAT"]},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:{min:1},itemSeparator:e,assert:!0},autoSpacing:!1}],[{type:"keyword",as:"name",value:["CONCAT_WS","FORMAT"]},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:{min:2},itemSeparator:e,assert:!0},autoSpacing:!1}],[{type:"keyword",as:"name",value:["MD5","SHA1"]},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:1,itemSeparator:e,assert:!0},autoSpacing:!1}],[{type:"keyword",as:"name",value:["ST_ASTEXT","ST_ASGEOJSON","ST_GEOMFROMTEXT"]},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:1,itemSeparator:e,assert:!0},autoSpacing:!1}],[{type:"keyword",as:"name",value:["ST_WITHIN","ST_CONTAINS","ST_INTERSECTS","ST_DISTANCE","ST_BUFFER"]},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:2,itemSeparator:e,assert:!0},autoSpacing:!1}],{dialect:"postgres",syntax:[{type:"keyword",as:"name",value:["TO_JSON","TO_JSONB","JSON_TYPEOF","JSONB_TYPEOF"]},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:1,itemSeparator:e,assert:!0},autoSpacing:!1}]},{dialect:"postgres",syntax:[{type:"keyword",as:"name",value:["JSON_BUILD_ARRAY","JSONB_BUILD_ARRAY","JSON_BUILD_OBJECT","JSONB_BUILD_OBJECT"]},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:{min:0},itemSeparator:e,assert:!0},autoSpacing:!1}]},{dialect:"postgres",syntax:[{type:"keyword",as:"name",value:["JSON_POPULATE_RECORD","JSONB_POPULATE_RECORD","JSON_PATH_QUERY","JSON_PATH_EXISTS"]},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:2,itemSeparator:e,assert:!0},autoSpacing:!1}]},{dialect:"postgres",syntax:[{type:"keyword",as:"name",value:["ARRAY"]},{type:"paren_block",syntax:{type:"SelectStmt",as:"arguments",arity:1,itemSeparator:e,assert:!0},autoIndent:!0,autoSpacing:!0}]},{dialect:"postgres",syntax:[{type:"keyword",as:"name",value:["MAKE_DATE","MAKE_TIME","MAKE_TIMESTAMP"]},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:1/0,itemSeparator:e,assert:!0},autoSpacing:!1}]},{dialect:"mysql",syntax:[{type:"keyword",as:"name",value:["JSON_ARRAY","JSON_OBJECT","JSON_EXTRACT","JSON_UNQUOTE","JSON_SET","JSON_INSERT","JSON_REPLACE","JSON_REMOVE","JSON_SEARCH","JSON_CONTAINS","JSON_CONTAINS_PATH","JSON_KEYS","JSON_ARRAY_APPEND","JSON_ARRAY_INSERT","JSON_DEPTH","JSON_LENGTH","JSON_MERGE_PRESERVE","JSON_MERGE_PATCH","JSON_PRETTY","JSON_STORAGE_FREE"]},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:{min:1},itemSeparator:e,assert:!0},autoSpacing:!1}]},{dialect:"mysql",syntax:[{type:"keyword",as:"name",value:["CURDATE","CURTIME","SYSDATE"]},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:0,itemSeparator:e,optional:!0,assert:!0},autoSpacing:!1}]},{dialect:"mysql",syntax:[{type:"keyword",as:"name",value:"STR_TO_DATE"},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:2,itemSeparator:e,assert:!0},autoSpacing:!1}]},{dialect:"mysql",syntax:[{type:"keyword",as:"name",value:["MAKEDATE","MAKETIME"]},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:2,itemSeparator:e,assert:!0},autoSpacing:!1}]}]},[{type:"keyword",as:"name"},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:1/0,itemSeparator:e},autoSpacing:!1}],[{type:"identifier",as:"name"},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:1/0,itemSeparator:e},autoSpacing:!1}]]}}static get syntaxPriority(){return 51}name(){return this._get("name")}arguments(){return this._get("arguments")}};var xe=class extends he{static get syntaxRules(){let e={type:"punctuation",value:","},r={type:"keyword",as:"distinct",value:"DISTINCT",booleanfy:!0,optional:!0},t={optional:!0,syntax:[{type:"keyword",value:"SEPARATOR"},{type:"Expr",as:"separator",assert:!0}]},n={type:"OrderByClause",as:"order_by_clause",optional:!0},o={type:"PGFilterClause",as:"pg_filter_clause",optional:!0,dialect:"postgres"},s={type:"PGWithinGroupClause",as:"pg_within_group_clause",optional:!0,dialect:"postgres"},l={optional:!0,syntax:[{type:"keyword",as:"null_handling",value:["IGNORE","RESPECT"]},{type:"keyword",value:"NULLS",assert:!0}]},c={optional:!0,syntax:[{type:"keyword",value:"OVER"},{type:["WindowRef","WindowSpec"],as:"over_clause",assert:!0}]};return{peek:[0,"keyword",["COUNT","SUM","AVG","MIN","MAX","ARRAY_AGG","STRING_AGG","GROUP_CONCAT","REGR_SLOPE","COVAR_POP","COVAR_SAMP","CORR","PERCENTILE_CONT","PERCENTILE_DISC","MODE","RANK","DENSE_RANK","ROW_NUMBER","EVERY","BOOL_AND","BOOL_OR","BIT_AND","BIT_OR","BIT_XOR","JSON_AGG","JSON_ARRAYAGG","JSON_OBJECT_AGG","JSONB_OBJECT_AGG","JSON_OBJECTAGG","STDDEV_POP","STDDEV_SAMP","VAR_POP","VAR_SAMP","VARIANCE","STD","XMLAGG","LEAD","LAG","NTILE","FIRST_VALUE","LAST_VALUE"]],syntaxes:[[{type:"keyword",as:"name",value:"COUNT"},{type:"paren_block",syntax:[{dialect:"postgres",type:"StarRef",as:"arguments",arity:1,assert:!1,itemSeparator:e},{dialect:"mysql",type:"StarRef",as:"arguments",arity:{max:1},assert:!1,itemSeparator:e,optional:!0}],autoSpacing:!1},{...o},{...c}],[{type:"keyword",as:"name",value:["COUNT","SUM","AVG","MIN","MAX"]},{type:"paren_block",syntax:[{...r},{type:"Expr",as:"arguments",arity:1,itemSeparator:e,assert:!0}],autoSpacing:!1},{...o},{...c}],{dialect:"postgres",syntax:[{type:"keyword",as:"name",value:"ARRAY_AGG"},{type:"paren_block",syntax:[{...r},{type:"Expr",as:"arguments",arity:{min:1},itemSeparator:e,assert:!0},{...n}],autoSpacing:!1},{...o},{...c}]},{dialect:"postgres",syntax:[{type:"keyword",as:"name",value:"STRING_AGG"},{type:"paren_block",syntax:[{...r},{type:"Expr",as:"arguments",arity:2,itemSeparator:e,assert:!0},{...n},{...t}],autoSpacing:!1},{...o},{...c}]},{dialect:"mysql",syntax:[{type:"keyword",as:"name",value:"GROUP_CONCAT"},{type:"paren_block",syntax:[{...r},{type:"Expr",as:"arguments",arity:{min:1},itemSeparator:e,assert:!0},{...n},{...t}],autoSpacing:!1},{...c}]},{dialect:"postgres",syntax:[{type:"keyword",as:"name",value:"REGR_SLOPE"},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:2,itemSeparator:e,assert:!0},autoSpacing:!1},{...o},{...c}]},[{type:"keyword",as:"name",value:["COVAR_POP","COVAR_SAMP","CORR"]},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:2,itemSeparator:e,assert:!0},autoSpacing:!1},{...o},{...c}],{dialect:"postgres",syntax:[{type:"keyword",as:"name",value:["PERCENTILE_CONT","PERCENTILE_DISC"]},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:1,itemSeparator:e,assert:!0},autoSpacing:!1},{...o},{...s,optional:!1}]},{dialect:"postgres",syntax:[{type:"keyword",as:"name",value:"MODE"},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:0,itemSeparator:e,assert:!0},autoSpacing:!1},{...o},{...s,optional:!1}]},{dialect:"postgres",syntax:[{type:"keyword",as:"name",value:["RANK","DENSE_RANK"]},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:0,itemSeparator:e,assert:!0},autoSpacing:!1},{...o},{...c,optional:!1}]},[{type:"keyword",as:"name",value:"ROW_NUMBER"},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:0,itemSeparator:e,assert:!0},autoSpacing:!1},{...c,optional:!1}],{dialect:"postgres",syntax:[{type:"keyword",as:"name",value:["EVERY","BOOL_AND","BOOL_OR"]},{type:"paren_block",syntax:[{...r},{type:"Expr",as:"arguments",arity:1,itemSeparator:e,assert:!0}],autoSpacing:!1},{...o},{...c}]},{dialect:"postgres",syntax:[{type:"keyword",as:"name",value:"JSON_AGG"},{type:"paren_block",syntax:[{...r},{type:"Expr",as:"arguments",arity:{min:1},itemSeparator:e,assert:!0}],autoSpacing:!1},{...o},{...c}]},{dialect:"mysql",syntax:[{type:"keyword",as:"name",value:"JSON_ARRAYAGG"},{type:"paren_block",syntax:[{...r},{type:"Expr",as:"arguments",arity:{min:1},itemSeparator:e,assert:!0}],autoSpacing:!1},{...c}]},{dialect:"mysql",syntax:[{type:"keyword",as:"name",value:"BIT_XOR"},{type:"paren_block",syntax:[{...r},{type:"Expr",as:"arguments",arity:1,itemSeparator:e,assert:!0}],autoSpacing:!1},{...c}]},[{type:"keyword",as:"name",value:["BIT_AND","BIT_OR"]},{type:"paren_block",syntax:[{...r},{type:"Expr",as:"arguments",arity:1,itemSeparator:e,assert:!0}],autoSpacing:!1},{...o},{...c}],{dialect:"postgres",syntax:[{type:"keyword",as:"name",value:["JSON_OBJECT_AGG","JSONB_OBJECT_AGG"]},{type:"paren_block",syntax:[{...r},{type:"Expr",as:"arguments",arity:2,itemSeparator:e,assert:!0}],autoSpacing:!1},{...o},{...c}]},{dialect:"mysql",syntax:[{type:"keyword",as:"name",value:"JSON_OBJECTAGG"},{type:"paren_block",syntax:[{...r},{type:"Expr",as:"arguments",arity:2,itemSeparator:e,assert:!0}],autoSpacing:!1},{...c}]},[{type:"keyword",as:"name",value:["STDDEV_POP","STDDEV_SAMP","VAR_POP","VAR_SAMP","VARIANCE","STD"]},{type:"paren_block",syntax:[{...r},{type:"Expr",as:"arguments",arity:1,itemSeparator:e,assert:!0}],autoSpacing:!1},{...o},{...c}],{dialect:"postgres",syntax:[{type:"keyword",as:"name",value:"XMLAGG"},{type:"paren_block",syntax:[{type:"Expr",as:"arguments",arity:1,itemSeparator:e,assert:!0},{...n}],autoSpacing:!1},{...o},{...c}]},[{type:"keyword",as:"name",value:["LEAD","LAG"]},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:{max:3},itemSeparator:e,optional:!0,assert:!0},autoSpacing:!1},{...l},{...c}],[{type:"keyword",as:"name",value:["NTILE","FIRST_VALUE","LAST_VALUE"]},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:1,itemSeparator:e,assert:!0},autoSpacing:!1},{...c,optional:!1}]]}}distinct(){return this._get("distinct")}orderByClause(){return this._get("order_by_clause")}separator(){return this._get("separator")}overClause(){return this._get("over_clause")}pgFilterClause(){return this._get("pg_filter_clause")}pgWithinGroupClause(){return this._get("pg_within_group_clause")}};var bt=class a extends y{static get syntaxRules(){return[{type:["Expr","MYVarAssignmentExpr"],as:"expr"},{optional:!0,syntaxes:[{type:"BasicAlias",as:"alias"},[{type:"keyword",as:"as_kw",value:"AS",booleanfy:!0},{type:"BasicAlias",as:"alias",assert:!0}]]}]}expr(){return this._get("expr")}asKW(){return this._get("as_kw")}alias(){return this._get("alias")}jsonfy(e={},r=null){if(e.deSugar&&this.alias()?.isAggr()){let t={nodeName:xe.NODE_NAME,name:(e.toDialect||this.options.dialect)==="mysql"?"JSON_ARRAYAGG":"JSON_AGG",arguments:[this.expr().jsonfy({...e,asAggr:!0},r)]},n={nodeName:_e.NODE_NAME,value:this.alias().value()};return{nodeName:a.NODE_NAME,expr:t,as_kw:this.asKW(),alias:n}}return super.jsonfy(e,r)}};var Ct=class extends y{static get syntaxRules(){return[{type:"CallExpr",as:"expr"},{optional:!0,syntax:[{syntaxes:[{type:"CompositeAlias",as:"alias"},[{type:"keyword",as:"as_kw",value:"AS",booleanfy:!0},{type:"CompositeAlias",as:"alias",assert:!0}]]}]}]}expr(){return this._get("expr")}asKW(){return this._get("as_kw")}alias(){return this._get("alias")}};var kt=class extends y{static get syntaxRules(){return[{type:"keyword",value:"USING"},{type:["ClassicColumnRef","SetConstructor"],as:"column",assert:!0}]}column(){return this._get("column")}};var It=class extends y{static get syntaxRules(){return[{type:"keyword",value:"WHERE"},{type:"Expr",as:"expr",assert:!0}]}expr(){return this._get("expr")}};var Dt=class extends T{static get syntaxRules(){return[{type:"keyword",value:"WINDOW"},{type:"WindowDeclaration",as:"entries",arity:{min:1},itemSeparator:{type:"punctuation",value:","},assert:!0,autoIndent:2}]}};var Lt=class extends y{static get syntaxRules(){return[{type:"Identifier",as:"name"},{type:"keyword",value:"AS"},{type:"WindowSpec",as:"spec",assert:!0}]}name(){return this._get("name")}spec(){return this._get("spec")}};var Mt=class extends y{static get syntaxRules(){let e={type:"operator",value:"AND"};return[{type:"keyword",as:"specifier",value:["ROWS","RANGE","GROUPS"]},{syntaxes:[[{type:"operator",as:"with_between_clause",value:"BETWEEN",booleanfy:!0},{type:"WindowFrameBound",as:"bounds",arity:2,itemSeparator:e,assert:!0}],{type:"WindowFrameBound",as:"bounds",arity:1,itemSeparator:e,assert:!0}]},{optional:!0,syntax:[{type:"keyword",value:"EXCLUDE"},{type:"keyword",as:"exclusion",value:["CURRENT ROW","GROUP","TIES","NO OTHERS"],assert:!0}]}]}specifier(){return this._get("specifier")}withBetweenClause(){return this._get("with_between_clause")}bounds(){return this._get("bounds")}exclusion(){return this._get("exclusion")}};var Pt=class extends y{static get syntaxRules(){return{syntaxes:[{type:"keyword",as:"specifier",value:"CURRENT ROW"},[{type:"keyword",as:"specifier",value:"UNBOUNDED"},{type:"keyword",as:"dir",value:["PRECEDING","FOLLOWING"]}],[{type:"number_literal",as:"specifier"},{type:"keyword",as:"dir",value:["PRECEDING","FOLLOWING"]}],[{type:"Expr",as:"specifier"},{type:"keyword",as:"dir",value:["PRECEDING","FOLLOWING"]}]]}}specifier(){return this._get("specifier")}dir(){return this._get("dir")}};var Bt=class extends y{static get syntaxRules(){return{type:"paren_block",syntax:[{type:"WindowRef",as:"super_window",optional:!0},{type:"PartitionByClause",as:"partition_by_clause",optional:!0,autoIndent:!0},{type:"OrderByClause",as:"order_by_clause",optional:!0,autoIndent:!0},{type:"WindowFrameSpec",as:"frame_spec",optional:!0,autoIndent:!0}],autoIndent:!0,autoIndentAdjust:-1}}superWindow(){return this._get("super_window")}partitionByClause(){return this._get("partition_by_clause")}orderByClause(){return this._get("order_by_clause")}frameSpec(){return this._get("frame_spec")}};var te=class extends H{static get syntaxRules(){return{type:["CompleteSelectStmt","CompositeSelectStmt"],expression:!0}}static _getSyntaxRules(e=!1){return[{type:"keyword",value:"SELECT"},{type:"DistinctClause",as:"distinct_clause",optional:!0},{type:"SelectElement",as:"select_list",arity:{min:1},itemSeparator:{type:"punctuation",value:","},assert:!0,autoIndent:2},{optional:!0,syntax:[{type:"FromClause",as:"from_clause",autoIndent:!0},{type:"JoinClause",as:"join_clauses",arity:1/0,optional:!0,autoIndent:!0},{type:"MYPartitionClause",as:"my_partition_clause",optional:!0,autoIndent:!0},{type:"WhereClause",as:"where_clause",optional:!0,autoIndent:!0},{optional:!0,syntax:[{type:"GroupByClause",as:"group_by_clause",autoIndent:!0},{type:"HavingClause",as:"having_clause",optional:!0,autoIndent:!0}]},{type:"WindowClause",as:"window_clause",optional:!0,autoIndent:!0},...e?this._getSyntaxRulesTail():[]]}]}static _getSyntaxRulesTail(){return[{type:"OrderByClause",as:"order_by_clause",optional:!0,autoIndent:!0},{type:"LimitClause",as:"limit_clause",optional:!0,autoIndent:!0},{type:"OffsetClause",as:"offset_clause",optional:!0,autoIndent:!0},{type:"PGFetchClause",as:"pg_fetch_clause",optional:!0,dialect:"postgres",autoIndent:!0},{type:"ForClause",as:"for_clause",optional:!0,autoIndent:!0}]}};var{LQObjectLiteral:Aa,BasicAlias:Ta,SelectElement:Oa}=R,Ee=class extends ue(te){static get syntaxRules(){return this._getSyntaxRules(!1)}static get syntaxPriority(){return-1}distinctClause(){return this._get("distinct_clause")}selectList(){return this._get("select_list")}fromClause(){return this._get("from_clause")}joinClauses(){return this._get("join_clauses")}whereClause(){return this._get("where_clause")}groupByClause(){return this._get("group_by_clause")}havingClause(){return this._get("having_clause")}windowClause(){return this._get("window_clause")}myPartitionClause(){return this._get("my_partition_clause")}get length(){return this.selectList()?.length??0}[Symbol.iterator](){return(this.selectList()||[])[Symbol.iterator]()}jsonfy(e={}){let r=super.jsonfy(e),t;if(e.deSugar&&(t=this.selectList()).length===1&&t[0].expr()instanceof Aa&&!t[0].alias()){let[n]=r.select_list[0].arguments.reduce(([o,s],l)=>s?[...o,[{nodeName:Ta.NODE_NAME,value:s.value},l]]:[o,l],[[]]);r={...r,select_list:n.map(([o,s])=>({nodeName:Oa.NODE_NAME,expr:s,alias:o,as_kw:!0}))}}return r}};var $t=class extends Ee{static get syntaxRules(){return this._getSyntaxRules(!0)}static get syntaxPriority(){return 99}orderByClause(){return this._get("order_by_clause")}offsetClause(){return this._get("offset_clause")}limitClause(){return this._get("limit_clause")}forClause(){return this._get("for_clause")}pgFetchClause(){return this._get("pg_fetch_clause")}};var Ut=class extends te{static get syntaxRules(){let e=["SubqueryConstructor","ValuesSetConstructor","ParenShape","BasicSelectStmt","CallExpr"];return[{type:e.concat("CompleteSelectStmt"),as:"left"},{type:"operator",as:"operator",value:["INTERSECT","UNION","EXCEPT"],autoSpacing:`
`},{type:"keyword",as:"all_or_distinct",value:["ALL","DISTINCT"],optional:!0},{type:e,as:"right",assert:!0,autoSpacing:`
`},...this._getSyntaxRulesTail()]}static get syntaxPriority(){return 100}left(){return this._get("left")}operator(){return this._get("operator")}allOrDistinct(){return this._get("all_or_distinct")}right(){return this._get("right")}orderByClause(){return this._get("order_by_clause")}offsetClause(){return this._get("offset_clause")}limitClause(){return this._get("limit_clause")}forClause(){return this._get("for_clause")}pgFetchClause(){return this._get("pg_fetch_clause")}get length(){return this.left()?.selectList()?.length??0}[Symbol.iterator](){return(this.left()?.selectList()||[])[Symbol.iterator]()}};var jt=class extends ie{static get syntaxRules(){return[{type:"keyword",value:"TABLE"},{type:"keyword",as:"pg_only_kw",value:"ONLY",optional:!0,dialect:"postgres"},{type:"ClassicTableRef",as:"table_name",assert:!0},{type:"StarRef",as:"pg_star_ref",optional:!0,dialect:"postgres"}]}tableName(){return this._get("table_name")}pgOnlyKW(){return this._get("pg_only_kw")}pgStarRef(){return this._get("pg_star_ref")}};var V={};ne(V,{AggrCallExpr:()=>xe,AtTimeZoneExpr:()=>ar,BetweenExpr:()=>nr,BinaryExpr:()=>L,BindVar:()=>wr,BitLiteral:()=>Wt,BoolLiteral:()=>Yt,CallExpr:()=>he,CaseBranch:()=>Jt,CaseExpr:()=>Ft,CastExpr:()=>or,ClassicColumnRef:()=>fr,ClassicDatabaseRef:()=>mr,ClassicTableRef:()=>gr,ComputedColumnRef:()=>hr,ComputedTableRef:()=>xr,DefaultLiteral:()=>Ht,DistinctFromExpr:()=>ur,Expr:()=>Le,ExtractExpr:()=>ir,HexLiteral:()=>Vt,Identifier:()=>X,LQArrayLiteral:()=>Ar,LQBackBackRef:()=>se,LQBackRef:()=>yr,LQBackRefConstructor:()=>ye,LQDeepDeepRef:()=>Ae,LQDeepRef:()=>Er,LQObjectLiteral:()=>Tr,LQObjectProperty:()=>Or,NullLiteral:()=>Kt,NumberLiteral:()=>Xt,PGArrayLiteral:()=>Rr,PGCastExpr2:()=>lr,PGFilterClause:()=>Gt,PGWithinGroupClause:()=>qt,ParenShape:()=>Z,QuantifiedExpr:()=>pr,RowConstructor:()=>fe,SetConstructor:()=>ee,StarRef:()=>Nr,StringLiteral:()=>Qt,SubqueryConstructor:()=>me,SystemVar:()=>vr,TypedDateLiteral:()=>zt,TypedIntervalLiteral:()=>Zt,TypedLiteral:()=>J,TypedTimeLiteral:()=>er,TypedTimeZoneLiteral:()=>rr,TypedTimestampLiteral:()=>tr,UnaryExpr:()=>cr,UnknownLiteral:()=>sr,UserVar:()=>br,WindowRef:()=>Sr});var Gt=class extends y{static get syntaxRules(){return{dialect:"postgres",syntax:[{type:"keyword",value:"FILTER"},{type:"paren_block",syntax:{type:"WhereClause",as:"where_clause"},assert:!0,autoIndent:!0}]}}static get syntaxPriority(){return-1}whereClause(){return this._get("where_clause")}};var qt=class extends y{static get syntaxRules(){return{dialect:"postgres",syntax:[{type:"keyword",value:"WITHIN"},{type:"keyword",value:"GROUP"},{type:"paren_block",syntax:{type:"OrderByClause",as:"order_by_clause"},assert:!0,autoIndent:!0}]}}static get syntaxPriority(){return-1}orderByClause(){return this._get("order_by_clause")}};var Ft=class extends T{static get syntaxRules(){return[{type:"keyword",value:"CASE"},{type:"Expr",as:"subject",optional:!0},{type:"CaseBranch",as:"entries",arity:{min:1},assert:!0,autoIndent:2},{optional:!0,syntax:[{type:"keyword",value:"ELSE"},{type:"Expr",as:"alternate",autoIndent:!0}],autoSpacing:`
`},{type:"keyword",value:"END",autoSpacing:`
`}]}subject(){return this._get("subject")}branches(){return this.entries()}alternate(){return this._get("alternate")}};var Jt=class extends y{static get syntaxRules(){return[{type:"keyword",value:"WHEN"},{type:"Expr",as:"condition"},{type:"keyword",value:"THEN"},{type:"Expr",as:"consequent"}]}static get syntaxPriority(){return-1}condition(){return this._get("condition")}consequent(){return this._get("consequent")}};var U=class extends y{static get syntaxPriority(){return 49}value(){return this._get("value")}};var Wt=class extends U{static get syntaxRules(){return{type:"bit_literal",as:"."}}};var Yt=class extends U{static get syntaxRules(){return{type:"bool_literal",as:"."}}};var Ht=class extends U{static get syntaxRules(){return{type:"keyword",as:".",value:"DEFAULT"}}};var Vt=class extends U{static get syntaxRules(){return{type:"hex_literal",as:"."}}};var Kt=class extends U{static get syntaxRules(){return{type:"null_literal",as:"."}}};var Xt=class extends U{static get syntaxRules(){return{type:"number_literal",as:"."}}};var Qt=class extends U{static get syntaxRules(){return{type:"string_literal",as:"."}}qualifier(){return this._get("qualifier")}};var J=class extends y{static get syntaxRules(){return[{type:"data_type",as:"data_type"},{type:"string_literal",as:"value"}]}static get syntaxPriority(){return 50}dataType(){return Number(this._get("data_type"))}value(){return Number(this._get("value"))}};var zt=class extends J{static get syntaxRules(){return[{type:"data_type",as:"data_type",value:"DATE"},{type:"string_literal",as:"value"}]}};var Zt=class extends J{static get syntaxRules(){return[{type:"data_type",as:"data_type",value:"INTERVAL"},{syntaxes:[{type:"string_literal",as:"value"},{type:"number_literal",as:"value",dialect:"mysql"}]},{optional:!0,syntax:[{type:"keyword",as:"unit",value:["YEAR","MONTH","DAY","HOUR","MINUTE","SECOND"]},{optional:!0,syntax:[{type:"keyword",value:"TO"},{type:"keyword",as:"to_unit",value:["YEAR","MONTH","DAY","HOUR","MINUTE","SECOND"],assert:!0}]}]}]}unit(){return Number(this._get("unit"))}toUnit(){return Number(this._get("to_unit"))}};var er=class extends J{static get syntaxRules(){return[{type:"data_type",as:"data_type",value:"TIME"},{type:"string_literal",as:"value"},{optional:!0,dialect:"postgres",syntax:[{type:"keyword",as:"pg_with_tz",value:["WITH","WITHOUT"]},{type:"keyword",value:"TIME ZONE",assert:!0}]}]}pgWithTZ(){return Number(this._get("pg_with_tz"))}};var tr=class extends J{static get syntaxRules(){return[{type:"data_type",as:"data_type",value:"TIMESTAMP",dialect:"postgres"},{type:"data_type",as:"data_type",value:["TIMESTAMP","DATETIME"],dialect:"mysql"},{type:"string_literal",as:"value"},{optional:!0,dialect:"postgres",syntax:[{type:"keyword",as:"pg_with_tz",value:["WITH","WITHOUT"]},{type:"keyword",value:"TIME ZONE",assert:!0}]}]}pgWithTZ(){return Number(this._get("pg_with_tz"))}};var rr=class extends J{static get syntaxRules(){return[{type:"keyword",value:"TIME ZONE"},{type:"Expr",as:"value"}]}};var sr=class extends U{static get syntaxRules(){return{type:"unknown_literal",as:"."}}};var ar=class extends L{static get syntaxRules(){return[{type:"Expr",as:"left",peek:[1,"operator","AT"]},{type:"operator",as:"operator",value:"AT"},{syntaxes:[{type:"TypedTimeZoneLiteral",as:"right"},{type:"keyword",as:"right",value:"LOCAL"}]}]}static get syntaxPriority(){return 0}left(){return this._get("left")}right(){return this._get("right")}};var nr=class extends L{static get syntaxRules(){return[{type:"Expr",as:"left",peek:[1,"operator",["NOT","BETWEEN"]]},{type:"operator",as:"negation",value:"NOT",booleanfy:!0,optional:!0},{type:"operator",as:"operator",value:"BETWEEN"},{type:"Expr",as:"right",arity:{min:2,max:2,eager:!1},itemSeparator:{type:"operator",value:"AND"},assert:!0}]}};var or=class extends y{static get syntaxRules(){return[{type:"keyword",value:"CAST"},{type:"paren_block",syntax:[{type:"Expr",as:"left"},{type:"keyword",value:"AS"},{type:"DataType",as:"right",assert:!0}],assert:!0,autoSpacing:!1}]}left(){return this._get("left")}right(){return this._get("right")}};var ir=class extends L{static get syntaxRules(){return[{type:"keyword",value:"EXTRACT"},{type:"paren_block",syntax:[{type:"Expr",as:"left"},{type:"keyword",value:"FROM"},{type:"Expr",as:"right",assert:!0}],autoSpacing:!1}]}left(){return this._get("left")}right(){return this._get("right")}};var ur=class extends L{static get syntaxRules(){return[{type:"Expr",as:"left",peek:[1,"operator",["IS","IS NOT"]]},{type:"operator",as:"logic",value:["IS","IS NOT"]},{type:"operator",as:"operator",value:"DISTINCT FROM"},{type:"Expr",as:"right",assert:!0}]}logic(){return this._get("logic")}};var lr=class extends L{static get syntaxRules(){return{dialect:"postgres",syntax:[{type:"Expr",as:"left",peek:[1,"operator","::"]},{type:"operator",as:"operator",value:"::",autoSpacing:!1},{type:"DataType",as:"right",assert:!0,autoSpacing:!1}]}}};var pr=class extends y{static get syntaxRules(){return[{type:"keyword",as:"quantifier",value:["ALL","ANY","SOME"]},{type:["SubqueryConstructor","SetConstructor"],as:"expr"}]}quantifier(){return this._get("quantifier")}expr(){return this._get("expr")}};var cr=class extends y{static get syntaxRules(){return[{type:"operator",as:"operator",value:["-","+","NOT","EXISTS"]},{type:"Expr",as:"operand",autoSpacing:["NOT","EXISTS"]}]}static get syntaxPriority(){return 1}operator(){return this._get("operator")}operand(){return this._get("operand")}};var Ne=class extends ce(L){};var re=class extends Error{constructor(e){super(e),this.name="ErrorFKInvalid"}};var{LQDeepRef:Ts}=R,se=class a extends Ne{static get _leftType(){return["ComputedColumnRef","LQBackBackRef"]}static get syntaxRules(){return[{type:this._leftType,as:"left",peek:[1,"operator","<~"]},{type:"operator",value:"<~"},{type:"ClassicColumnRef",as:"right",peek:[1,"operator","<~"]}]}static get syntaxPriority(){return 1}static morphsTo(){return Ts}jsonfy(e={},r=null){return e.reverseRef?{nodeName:Ts.NODE_NAME,left:this.right().jsonfy(e,r),right:this.left().jsonfy(e,r)}:super.jsonfy(e,r)}_capture(e,r){return e==="CONTEXT.TABLE_SCHEMA"&&r===this.left()?this.tableSchema():super._capture(e,r)}tableSchema(){let e=this.right().columnSchema().foreignKey();if(!e)throw new re(`[${this}]: Column ${this.right().clone({fullyQualified:!0})} is not a foreign key.`);return e.targetTable().tableSchema()}endpoint(){return this.left()instanceof a?this.left().endpoint():this.left()}};var{ComputedColumnRef:Ra,ClassicTableRef:wa}=R,yr=class extends se{static get syntaxRules(){return[{type:this._leftType,as:"left",peek:[1,"operator","<~"]},{type:"operator",value:"<~"},{type:"ClassicTableRef",as:"right"}]}static get syntaxPriority(){return 0}_capture(e,r){return e==="CONTEXT.TABLE_SCHEMA"?this.tableSchema():super._capture(e,r)}tableSchema(){return this.right().tableSchema()}getOperands(){let e,r,t=this.left(),n=t instanceof se?t.endpoint():t,o=n.columnSchema().foreignKey();if(!o)throw new re(`[${this}]: Column ${n.clone()} is not a foreign key.`);let s=o.targetTable(),l=this.capture("CONTEXT.QUERY_SCHEMA");for(let _ of l.columns())if(_.primaryKey()&&_.qualifier(!0).identifiesAs(s)){let d=Ra.fromJSON({qualifier:_.parentSchema(!0).name(),value:_.name()});if(e)throw new Error(`[${this}]: Target primary key for foreign key ${n.clone()} is ambiguous. (Is it ${e} or ${d}?)`);e=d}if(!e)throw new Error(`LQBackRef ${this} could not be resolved against table query.`);r=t instanceof se?t.clone({reverseRef:!0}):t.clone();let c=this.tableSchema();return{table:wa.fromJSON({qualifier:c.parentSchema(!0).name(),value:c.name()}),left:e,right:r}}};var W=class extends X{};var fr=class extends W{static get syntaxPriority(){return-1}selectSchema(e=null){let r=this.value(),t=this.capture("CONTEXT.TABLE_SCHEMA"),n=r?[].concat(t?.column(r)||[]):t.columns();return e?n.filter(e):n}};var mr=class extends W{static get syntaxRules(){return[...[].concat(super.syntaxRules),{type:"LQVersionSpec",as:"version_spec",optional:!0,autoSpacing:!1}]}static get syntaxPriority(){return-1}versionSpec(){return this._get("version_spec")}selectSchema(e=null){let r=this.value(),t=this.capture("CONTEXT.ROOT_SCHEMA"),n=r?[].concat(t?.database(r)||[]):t.databases();return e?n.filter(e):n}};var dr=class extends Error{};var _r=class extends Error{};var Se=a=>class extends a{jsonfy(e={},r=null){let t=super.jsonfy(e,r);if(!t.qualifier&&(e.deSugar||e.fullyQualified)){let n=this.qualifier(!0).jsonfy(e,r);t={...t,qualifier:n.value?n:void 0}}return t}qualifier(e=null){let r=this._get("qualifier");if(!arguments.length)return r;if(e!==!0&&typeof e!="string")throw new TypeError('"init" must be true or a string.');let t=this._get("value");if(!t&&!r&&e===!0)throw new TypeError("Can't auto-resolve qualifier for anonymous ident.");let o=R[this.constructor._qualifierType].fromJSON(e===!0&&r?.jsonfy()||{value:e!==!0?"":e});if(this._adoptNodes(o),e===!0&&!r){let s=`${this.constructor._refKind}s`,l=o.selectSchema(c=>c._has(s,t));if(l.length>1){let c=l.map(i=>this.constructor.fromJSON({qualifier:i.name(),value:this.value()}));throw new dr(`[${this.clone({fullyQualified:!0})}]: ${this.value()} is ambiguous. (Is it ${c.join(" or ")}?)`)}else if(!l.length)throw new _r(`[${this.clone({fullyQualified:!0})}]: ${this.value()} is unknown.`);o._set("value",l[0].name())}return o}selectSchema(e=null){let r=this.value(),t=this.qualifier(!0).schema(),n=`${this.constructor._refKind}s`;return t.reduce((o,s)=>{let l=r?[].concat(s._get(n,r)||[]):s._get(n);return o.concat(e?l.filter(e):l)},[])}identifiesAs(e){return e instanceof a?this._eq(this.value(),e.value(),"ci")&&(!e.qualifier()||!!this.qualifier(!0).identifiesAs(e.qualifier())):super.identifiesAs(e)}static fromJSON(e,r={},t=null){if(typeof e=="string")e={value:e,qualifier:null};else if(Array.isArray(e)&&e.some(n=>typeof n=="string")&&(e=e.slice()))e={value:e.pop(),qualifier:e.pop()};else if(!$(e))return;return super.fromJSON(e,r,t)}};var gr=class extends Se(W){static get _refKind(){return"table"}static get _qualifierType(){return"ClassicDatabaseRef"}static get syntaxRules(){return[{optional:!0,syntaxes:[[{type:this._qualifierType,as:"qualifier",peek:[1,"punctuation","."]},{type:"punctuation",value:".",assert:!0,autoSpacing:!1}],[{type:this._qualifierType,as:"qualifier",peek:[1,"version_spec"]},{type:"punctuation",value:".",assert:!0,autoSpacing:!1}]]},{...[].concat(super.syntaxRules)[0],autoSpacing:!1}]}static get syntaxPriority(){return-1}};var hr=class extends Se(W){static get _refKind(){return"column"}static get _qualifierType(){return"ComputedTableRef"}static get syntaxRules(){return[{optional:!0,syntaxes:[[{type:"LQBackRefConstructor",as:"qualifier",peek:[1,"punctuation","."]},{type:"punctuation",value:".",assert:!0,autoSpacing:!1}],[{type:this._qualifierType,as:"qualifier",peek:[1,"version_spec"]},{type:"punctuation",value:".",assert:!0,autoSpacing:!1}],[{type:this._qualifierType,as:"qualifier",peek:[1,"punctuation","."]},{type:"punctuation",value:".",assert:!0,autoSpacing:!1}]]},{syntaxes:[{...[].concat(super.syntaxRules)[0]},{type:"operator",as:".",value:"*"}],autoSpacing:!1}]}static get syntaxPriority(){return 51}};var xr=class extends Se(W){static get _refKind(){return"table"}static get _qualifierType(){return"ClassicDatabaseRef"}static get syntaxRules(){return[{optional:!0,syntaxes:[[{type:this._qualifierType,as:"qualifier",peek:[3,"punctuation","."]},{type:"punctuation",value:".",assert:!0,autoSpacing:!1}],[{type:this._qualifierType,as:"qualifier",peek:[1,"version_spec"]},{type:"punctuation",value:".",assert:!0,autoSpacing:!1}]]},{...[].concat(super.syntaxRules)[0],autoSpacing:!1}]}static get syntaxPriority(){return-1}selectSchema(e=null){let r=this.value(),t=this.capture("CONTEXT.QUERY_SCHEMA"),n=r?[].concat(t?.table(r)||[]):t.tables();return e?n.filter(e):n}};var Ae=class a extends Ne{static get _rightType(){return["LQDeepDeepRef","LQObjectLiteral","LQArrayLiteral","ColumnsConstructor","ClassicColumnRef"]}static get syntaxRules(){return[{type:"ClassicColumnRef",as:"left",peek:[1,"operator","~>"]},{type:"operator",value:"~>"},{type:this._rightType,as:"right"}]}static get syntaxPriority(){return-1}_capture(e,r){return e==="CONTEXT.TABLE_SCHEMA"&&r===this.right()?this.tableSchema():super._capture(e,r)}tableSchema(){let e=this.left().columnSchema().foreignKey();if(!e)throw new re(`[${this}]: Column ${this.left().clone({fullyQualified:!0})} is not a foreign key.`);return e.targetTable().tableSchema()}endpoint(){return this.right()instanceof a?this.right().endpoint():this.right()}};var{LQBackRefConstructor:va,ClassicColumnRef:ba,ClassicTableRef:Ca}=R,Er=class extends Ae{static get syntaxRules(){return[{syntaxes:[[{type:["ComputedColumnRef","LQBackRefConstructor"],as:"left",peek:[1,"operator","~>"]},{type:"operator",value:"~>"}],[{type:"ComputedColumnRef",as:"left",peek:[3,"operator","~>"]},{type:"operator",value:"~>"}]]},{type:this._rightType,as:"right"}]}static get syntaxPriority(){return 1}tableSchema(){return this.left()instanceof va?this.left().tableSchema():super.tableSchema()}getOperands(){let e=this.tableSchema(),r=this.left().clone({fullyQualified:!0}),t=ba.fromJSON({value:e.primaryKey().columns()[0]});return{table:Ca.fromJSON({qualifier:e.parentSchema(!0).name(),value:e.name()}),left:r,right:t}}};var Nr=class extends y{static get syntaxRules(){return{type:"operator",value:"*",as:"."}}static get syntaxPriority(){return-1}value(){return this._get("value")}};var Sr=class extends W{static get syntaxPriority(){return-1}};var Te=class extends ce(T){};var{CallExpr:ka}=R,Ar=class extends Te{static get syntaxRules(){return{syntax:[{type:"bracket_block",syntax:{type:"Expr",as:"entries",arity:1/0,itemSeparator:{type:"punctuation",value:","},autoIndent:2}}]}}jsonfy(e={},r=null){return e.deSugar?{nodeName:ka.NODE_NAME,name:(e.toDialect||this.options.dialect)==="mysql"?"JSON_ARRAY":"JSON_BUILD_ARRAY",entries:this.entries().map(t=>t.jsonfy(e,r))}:super.jsonfy(e,r)}};var{StringLiteral:Ia,CallExpr:Da}=R,Tr=class extends Te{static get syntaxRules(){return{syntax:[{type:"brace_block",syntax:{type:"LQObjectProperty",as:"entries",arity:1/0,itemSeparator:{type:"punctuation",value:","},autoIndent:2}}]}}jsonfy(e={},r=null){let t=super.jsonfy(e,r);return e.deSugar&&(t={nodeName:Da.NODE_NAME,name:(e.toDialect||this.options.dialect)==="mysql"?"JSON_OBJECT":"JSON_BUILD_OBJECT",arguments:t.entries.reduce((n,o)=>n.concat({nodeName:Ia.NODE_NAME,value:o.key},o.value),[])}),t}};var{AggrCallExpr:La,ComputedColumnRef:Ma}=R,Or=class a extends y{static get syntaxRules(){return[{type:"identifier",as:"key"},{optional:!0,syntax:[{type:"AggrNotation",as:"is_aggr",optional:!0},{type:"punctuation",value:":",autoSpacing:!1},{type:"Expr",as:"value",assert:!0}],autoSpacing:!1}]}static get syntaxPriority(){return-1}get isProperty(){return!0}key(){return this._get("key")}isAggr(){return this._get("is_aggr")}value(){return this._get("value")}jsonfy(e={},r=null){if(e.deSugar){let t;return this.isAggr()?t={nodeName:La.NODE_NAME,name:(e.toDialect||this.options.dialect)==="mysql"?"JSON_ARRAYAGG":"JSON_AGG",arguments:[this.value().jsonfy({...e,asAggr:!0},r)]}:t=this.value()?.jsonfy(e,r)??{nodeName:Ma.NODE_NAME,value:this.key()},{nodeName:a.NODE_NAME,key:this.key(),is_aggr:!1,value:t}}return super.jsonfy(e,r)}};var{CallExpr:Pa}=R,Rr=class extends T{static get syntaxRules(){return{dialect:"postgres",syntax:[{type:"keyword",value:"ARRAY"},{type:"bracket_block",syntax:{type:"Expr",as:"entries",arity:1/0,itemSeparator:{type:"punctuation",value:","},autoIndent:2},autoSpacing:!1}]}}jsonfy(e={},r=null){return(e.toDialect||this.options.dialect)==="mysql"?{nodeName:Pa.NODE_NAME,name:"JSON_ARRAY",arguments:this.entries().map(t=>t.jsonfy(e,r))}:super.jsonfy(e,r)}};var wr=class extends y{static get syntaxRules(){return{type:"bind_var",as:"."}}value(){return Number(this._get("value"))}};var vr=class extends y{static get syntaxRules(){return{type:"system_var",as:"."}}value(){return this._get("value")}};var br=class extends y{static get syntaxRules(){return{type:"user_var",as:"."}}value(){return this._get("value")}};var Le=class extends y{static get syntaxRules(){return{type:$a,expression:!0}}static[Symbol.hasInstance](e){return e.constructor.name in V}},Ba=Object.keys(V),$a=Ba.filter(a=>V[a]!==Le&&V[a].syntaxPriority!==-1).sort((a,e)=>{let r=(V[e].syntaxPriority??100)-(V[a].syntaxPriority??100);return r===0?V[e].prototype.isPrototypeOf(V[a].prototype)?-1:1:r});var Qr={};ne(Qr,{AggrNotation:()=>Cr,LQVersionSpec:()=>kr});var Cr=class extends y{static get syntaxRules(){return{type:"bracket_block",syntax:{type:"Expr",as:"_",arity:0,assert:!0}}}static get syntaxPriority(){return-1}};var kr=class extends y{static get syntaxRules(){return{type:"version_spec",as:"."}}static get syntaxPriority(){return-1}value(){return this._get("value")}};var zr={};ne(zr,{DataType:()=>Ir});var Ir=class extends y{static get syntaxRules(){return[{type:"data_type",as:"."},{type:"paren_block",syntax:{type:"Expr",as:"specificity",arity:1/0,itemSeparator:{type:"punctuation",value:","},assert:!0},optional:!0,optionalParens:!0,autoSpacing:!1},{type:"AggrNotation",as:"pg_is_aggr",autoSpacing:!1,optional:!0,dialect:"postgres"}]}value(){return this._get("value")}specificity(){return this._get("specificity")}pgIsAggr(){return this._get("pg_is_aggr")}};Object.assign(R,{...Br,...ps,...Kr,...Xr,...V,...Qr,...zr});var Zr=class extends T{static get _contentTypes(){return["SelectStmt","TableStmt","InsertStmt","UpsertStmt","UpdateStmt","DeleteStmt","MYSetStmt","CTE"]}static get syntaxRules(){let e={type:"punctuation",value:";"};return{type:this._contentTypes,as:"entries",arity:1/0,itemSeparator:e,autoSpacing:`
`}}stringify(e={}){return`${super.stringify(e)};`}};})();
//# sourceMappingURL=main.js.map
