(()=>{function Dt(u){return u instanceof String||typeof u=="string"&&u!==null}function Tt(u){return arguments.length&&(u===void 0||typeof u>"u")}function qt(u){return typeof u=="function"}function Y(u){return qt(u)||u&&{}.toString.call(u)==="[object function]"}function L(u){return Array.isArray(u)}function Pe(u){return!Dt(u)&&!Tt(u.length)}function Je(u){return u===null||u===""}function tt(u){return Array.isArray(u)||typeof u=="object"&&u||qt(u)}function Fe(u){return Je(u)||Tt(u)||u===!1||u===0||tt(u)&&!Object.keys(u).length}function g(u){return!Array.isArray(u)&&typeof u=="object"&&u}function Rt(u,t=!0){return L(u)?u:!t&&g(u)?[u]:u!==!1&&u!==0&&Fe(u)?[]:Pe(u)?Array.prototype.slice.call(u):g(u)?Object.values(u):[u]}function Mt(u){return u instanceof Number||typeof u=="number"}function It(u){return Mt(u)||u!==!0&&u!==!1&&u!==null&&u!==""&&!isNaN(u*1)}var tr=function(u,t=1,e=!0){return!It(t)||t<=0||(!L(u)&&g(u)&&e&&(u=Object.values(u)),!L(u))?u:u.reduce((r,i)=>L(i)||g(i)&&e?r.concat(tr(L(i)?i:Object.values(i),t-1,e)):r.concat(i),[])},Be=tr;function Pt(u,t=1){var e=0;u.forEach(i=>{e++});var r=u.slice(u.length-e,t);return arguments.length>1?r:r[0]}function ht(u,t=1){return arguments.length>1?Pt(u.slice().reverse(),t).reverse():Pt(u.slice().reverse())}function we(u,...t){return t.forEach(e=>{u.indexOf(e)<0&&u.push(e)}),u}function er(r,t){t=t||Object.prototype,t=t&&!L(t)?[t]:t;for(var e=[],r=r;r&&(!t||t.indexOf(r)<0)&&r.name!=="default";)e.push(r),r=r?Object.getPrototypeOf(r):null;return e}function rr(u,t){var e=[];return er(u,t).forEach(r=>{we(e,...Object.getOwnPropertyNames(r))}),e}function Jt(u,t,e=!1,r=!1,i=!1){var s=0,n=u.shift();if((It(n)||n===!0||n===!1)&&(s=n,n=u.shift()),!u.length)throw new Error("_merge() requires two or more array/objects.");return u.forEach((f,o)=>{!tt(f)&&!Y(f)||(e?rr(f):Object.keys(f)).forEach(c=>{if(t(c,n,f,o)){var h=n[c],l=f[c];if((L(h)&&L(l)||g(h)&&g(l))&&(s===!0||s>0))n[c]=L(h)&&L(l)?[]:{},Jt([It(s)?s-1:s,n[c],h,l],t,e,r,i);else if(L(n)&&L(f))r?n[c]=l:n.push(l);else try{i?Object.defineProperty(n,c,Object.getOwnPropertyDescriptor(f,c)):n[c]=f[c]}catch{}}})}),n}function $e(...u){return Jt(u,(t,e,r)=>!0,!1,!1,!1)}function Ue(u){return g(u)&&Object.getPrototypeOf(u)===Object.prototype}function ie(u){return u===!0||u===!1}function be(u,t){var e=void 0;return tt(u)&&Object.keys(u).forEach((r,i)=>{e!==!1&&(e=t(It(r)?parseFloat(r):r,u[r],i))}),e}function ir(u,t,e=!0,r=!0,i=!1,s=!1){if(L(u)&&L(t)){var n=[],f=!0;return u.forEach(o=>{if(f){var c=!1;be(t,(h,l)=>{(!c||r&&tt(o))&&(c=e(o,l),(L(c)&&!c.length||g(c)&&!Object.keys(c).length)&&(c=!1),tt(c)&&r&&(o=c))}),tt(c)?n.push(r?c:o):ie(c)?i&&!c||!i&&c?n.push(o):s&&(f=!1):n.push(c)}}),n}if(g(u)&&g(t)){var n={},f=!0;return Object.keys(u).forEach(h=>{if(f){var l=e(u[h],t[h]);(L(l)&&!l.length||g(l)&&!Object.keys(l).length)&&(l=!1),tt(l)?n[h]=r?l:u[h]:ie(l)?i&&!l||!i&&l?n[h]=u[h]:s&&(f=!1):n[h]=l}}),n}}var ve=function(u,t,e=!0,r=1){if(L(u)&&L(t)&&u.length!==t.length)return!e;if(g(u)&&g(t)){var i=Object.keys(u),s=Object.keys(t);if(!i.length&&!s.length)return Ue(u)&&Ue(t)?e:u===t===e;if(!ve(i,s))return!e}if(r>0&&(L(u)&&L(t)||g(u)&&g(t))){var n=ir(u,t,(f,o)=>ve(f,o,e,r-1),!1,!1,!0);return L(n)?n.length===u.length&&n.length===t.length:g(n)&&g(u)?Object.keys(n).length===Object.keys(u).length&&Object.keys(n).length===Object.keys(t).length:n}return Y(e)?e(u,t):Mt(u)&&Mt(t)&&isNaN(u)&&isNaN(t)?e:u===t===e},sr=ve;function Ye(u,t=[]){return Jt([{},u],(e,r,i)=>{if(!Y(i[e]))return Y(t)?t(e):L(t)&&t.length?t.indexOf(e)>-1:!0},!1,!1,!1)}function Lt(u,t,e=null){return L(t)?u.filter(r=>e?t.filter(i=>e(r,i)).length:t.indexOf(r)!==-1):[]}var lt=class u{static lex(t,e,r={}){if(!Dt(t=t+""))throw new Error("Argument1 must be a string!");var i=c=>({delims:c.delims.slice(),options:Ye(c.options),nesting:c.nesting.slice(),maxDepth:c.maxDepth,comments:c.comments.slice(),tokens:c.tokens.slice(),matches:c.matches.slice(),matchesi:Ye(c.matchesi)});if(u.$cache[t]&&r.cache!==!1)for(var s=0;s<u.$cache[t].length;s++){var n=u.$cache[t][s];if(sr(n.delims,e))return i(n)}var f=new u(t,r),o=f.lex(e);return r.cache!==!1&&(u.$cache[t]=u.$cache[t]||[],u.$cache[t].push(o)),i(o)}static split(t,e,r){return u.lex(t,e,r).tokens}static match(t,e,r){return u.lex(t,e,r).matches}constructor(t,e){if(!Dt(t))throw new Error("Lexer requires the first argument to be a string.");this.$str=t,this.$options=e||{},this.$options.blocks||(this.$options.blocks=u.$blocks),this.$options.quotes||(this.$options.quotes=u.$quotes),this.$options.comments||(this.$options.comments=u.$comments)}lex(t,e){for(var r={delims:Rt(t),options:$e(!0,{},this.$options,e||{}),nesting:[],maxDepth:0,comments:[],tokens:[],matches:[],matchesi:{}},i=0;typeof i=="number";)i=this._evalCharsAt(r,i);if(r.nesting.length)throw new Error("Error parsing the string: "+this.$str+". Unterminated blocks: "+Be(r.nesting).join(", "));return r}_evalCharsAt(t,e){if(!(e>=this.$str.length)){var r=1,i={},s={},n={};if(t.openComment||(s=this._testQuotes(t,e)),t.openQuote||(i=this._testComments(t,e)),t.openComment||i.ending)if(!t.nesting.length&&!n.ending){var f=i.starting||i.ending||this.$str[e];r=f.length,this._push(t,f,"comments",i.starting)}else this._push(t,this.$str[e]);else if(t.openQuote||s.ending)this._push(t,this.$str[e]);else{if(t.options.limit&&t.matches.length===t.options.limit)return this._push(t,this.$str[e]),e+1;n=this._testNesting(t,e);var n=this._testNesting(t,e),o=this._testChars(t.options.stopChars||[],t,e);if(!t.nesting.length&&o!==!1){t.options.stopChar=o,t.options.stopCharForward=this.$str.substr(e);return}if(!t.delims.length)t.nesting.length===2&&n.starting?(t.matches.push(null),this._push(t,n.starting),r=n.starting.length):!t.nesting.length&&n.ending?(this._push(t,n.ending),r=n.ending.length,t.matches.push(null)):this._push(t,this.$str[e]);else if(!t.nesting.length&&!n.ending){this._push(t,"");var c=this._testChars(t.delims,t,e);if(c!==!1&&(t.matches.push(c),t.matchesi[e]=c,r=c.length||1,!t.options.preserveDelims)){var h=e+(c.length||1);return h===this.$str.length&&this._push(t,""),h}this._push(t,c||this.$str[e])}else{var f=n.starting||n.ending||this.$str[e];r=f.length,this._push(t,f)}}return e+r}}_testQuotes(t,e){var r={};return(t.options.quotes||[]).forEach(i=>{this.$str.substr(e,1)===i&&(t.openQuote?i===t.openQuote&&(t.openQuote=!1,r.ending=i):(t.openQuote=i,r.starting=i))}),r}_testComments(t,e){var r={};return(t.options.comments||[]).forEach(i=>{if(t.openComment){if(ht(i)===ht(t.openComment)){var n=ht(i);this.$str.substr(e).startsWith(n)&&(t.openComment=!1,r.ending=n)}}else{var s=Pt(i);this.$str.substr(e).startsWith(s)&&(t.openComment=i,r.starting=s)}}),r}_testNesting(t,e){var r={};return(t.options.blocks||[]).forEach(i=>{let s=Pt(i),n;if(s instanceof RegExp?[n]=s.exec(this.$str.substr(e))||[]:this.$str.substr(e).startsWith(s)&&(n=s),n)t.nesting=t.nesting.concat([i]),r.starting=n;else if(t.nesting.length&&ht(i)===ht(ht(t.nesting))){var f=ht(i),o;f instanceof RegExp?[o]=f.exec(this.$str.substr(e))||[]:this.$str.substr(e).startsWith(f)&&(o=f),o&&(t.nesting=t.nesting.slice(0,-1),r.ending=o)}}),t.maxDepth=Math.max(t.maxDepth,t.nesting.length),r}_testChars(t,e,r){for(var i=0;i<t.length;i++){let f={useRegex:e.options.useRegex,ci:e.options.ci,...g(t[i])?t[i]:{test:t[i]}};if(Y(f.test)){var s=f.test(this.$str.substr(0,r),this.$str.substr(r),e.tokens.slice());if(s!==!1)return s;continue}if(f.useRegex){let c=f.useRegex!==!0?f.useRegex:"";var n=this.$str.substr(r).match(new RegExp("^"+f.test,c));if(n&&(!f.backtest||this.$str.substr(0,r).match(new RegExp(f.backtest,c))))return n[0];continue}let o=(c,h)=>f.ci?c.toLowerCase()===h.toLowerCase():c===h;if(o(this.$str.substr(r,f.test.length),f.test)&&(!f.backtest||o(this.$str.substr(r-f.backtest.length,r),f.backtest)))return f.test}return!1}_push(t,e,r="tokens",i=!1){var s=t.matches.length;if(Tt(t.tokens[s])&&(t.tokens[s]=""),r==="comments"){t.tokens[s].comments||(t.tokens[s]=new String(t.tokens[s]),t.tokens[s].comments=[]);var n=t.tokens[s].comments.length-(!t.tokens[s].comments.length||i?0:1);t.tokens[s].comments[n]=(t.tokens[s].comments[n]||"")+e}else{var f=t.tokens[s].comments;t.tokens[s]=t.tokens[s]+e}}split(t,e,r){return this.lex(e,r).tokens}match(t,e,r){return this.lex(e,r).matches}regParse(t,e){return this.lex(t,$e({useRegex:!0},e||{}))}regSplit(t,e){return this.regParse(t,e).tokens}regMatch(t,e){return this.regParse(t,e).matches}};lt.$blocks=[["(",")"],["[","]"],["{","}"]];lt.$quotes=['"',"'","`"];lt.$comments=[["/*","*/"],["//",`
`]];lt.$cache=Object.create(null);var p=class extends lt{static $blocks=[...lt.$blocks,[new RegExp("^CASE ","i"),new RegExp("^ END","i")]]};function se(u,t,e=!1){if(t=="")return u;var r=e?u.lastIndexOf(t):u.indexOf(t);return r===-1?"":u.substr(r+t.length)}function He(u,t,e=!1){if(t=="")return u;var r=e?u.lastIndexOf(t):u.indexOf(t);return r===-1?u:u.substr(0,r)}function We(u,t,e=null){return L(t)?u.filter(r=>e?t.filter(i=>e(r,i)).length:t.indexOf(r)===-1):[]}var _=class u{CONTEXT;FLAGS=[];constructor(t){this.CONTEXT=t,this.CONTEXT?.$trace?.("event:CONNECTED",this)}$trace(t,...e){return t==="get:ROOT_NODE"&&!(this.CONTEXT instanceof u)?this:this.CONTEXT?.$trace?.(t,...e)}get client(){return this.CONTEXT?.client||this.CONTEXT}get params(){return this.CONTEXT?.params||{}}get quoteChars(){return this.constructor.getQuoteChars(this)}static getQuoteChars(t,e=!1){return(e&&t?.params?.inputDialect||t?.params?.dialect)==="mysql"&&!t.params.ansiQuotes?["'",'"']:["'"]}get escChar(){return this.constructor.getEscChar(this)}autoEsc(t){let e=(Array.isArray(t)?t:[t]).map(r=>r&&!/^(\*|[\w]+)$/.test(r)?`${this.escChar}${r.replace(new RegExp(this.escChar,"g"),this.escChar.repeat(2))}${this.escChar}`:r);return Array.isArray(t)?e:e[0]}static autoUnesc(t,e,r=!1){let i=this.getEscChar(t,r);return(e||"").replace(new RegExp(i+i,"g"),i)}static getEscChar(t,e=!1){return(e&&t?.params?.inputDialect||t?.params?.dialect)==="mysql"&&!t.params.ansiQuotes?"`":'"'}static parseIdent(t,e,r=!1){let i=this.getEscChar(t,r),s=p.split(e,["."]),n=s.map(o=>new RegExp(`^(?:(\\*|[\\w]+)|(${i})((?:\\2\\2|[^\\2])+)\\2)$`).exec(o.trim())).filter(o=>o);if(n.length!==s.length)return;let f=o=>o?.[1]||this.autoUnesc(t,o?.[3]);return[f(n.pop()),f(n.pop())]}with(t){for(let e in t)this[e]=t[e];return this}withFlag(...t){return t=new Set(t.filter(e=>e)),this.FLAGS=this.FLAGS.reduce((e,r)=>{let i=r.split(":");for(let s of t){let n=s.split(":");n[0]===i[0]&&(r=[...new Set([...i,...n])].join(":"),t.delete(s))}return e.concat(r)},[]).concat(...t),this}getFlag(t){let e=t.toUpperCase().split(":");return this.FLAGS.find(r=>{let i=r.split(":");return e[0]===i[0]&&e.every(s=>i.includes(s))})}hasFlag(t){return!!this.getFlag(t)}build(t,e,r,i){let s=Array.isArray(r)?r:r?[r]:[];if(!s.length)throw new Error("At least one node type must be defined.");let n=o=>s.find(c=>o instanceof c)?o:s.reduce((c,h)=>c||h.fromJSON(this,o),null),f=(...o)=>{for(let c of o)Array.isArray(this[t])?this[t].push(c):this[t]=c};if(e.length===1&&typeof e[0]!="function"){let o=n(e[0]);if(o)return f(o)}if(i){if(s.length!==1)throw new Error("To support argument delegation, number of node types must be 1.");let o=this[t]&&!Array.isArray(this[t])?this[t]:new s[0](this);return f(o),o[i](...e)}for(let o of e){if(typeof o=="function"){if(this[t]&&!Array.isArray(this[t])){o(this[t]);continue}if(s.length===1){let m=new s[0](this);f(m),o(m);continue}let l=m=>(...E)=>{let A=s.reduce((N,S)=>N||(S.factoryMethods?typeof S.factoryMethods[m]=="function"&&S.factoryMethods[m](this,...E):typeof S.prototype[m]=="function"&&new S(this)),null);if(!A)throw new Error(`Unknow method: ${m}()`);if(f(A),A[m])return A[m](...E);for(let N of E)N(A)};o(new Proxy({},{get:(m,E)=>l(E)}));continue}let c=n(o);if(c){f(c);continue}let h;if(typeof o=="object"&&o)try{h=JSON.stringify(o)}catch{h=o.constructor.name}else h=o+"";throw new Error(`Arguments must be of type ${s.map(l=>l.name).join(", ")} or a JSON equivalent. Recieved: ${h}`)}}clone(){return this.constructor.fromJSON(this.CONTEXT,this.toJSON())}static parse(t,e,r=null){}toString(){return this.stringify()}static fromJSON(t,e){}toJSON(){return{flags:this.FLAGS.slice(0)}}};var T=class extends _{NAME;PREFIX;name(t){if(!arguments.length)return this.NAME;if(g(t)||Array.isArray(t))throw new TypeError("Invalid object or array.");return this.NAME=t,this}prefix(t){return arguments.length?(this.PREFIX=t,this):this.PREFIX}toJSON(){return{name:this.NAME,prefix:this.PREFIX,...this.FLAGS.length?{flags:this.FLAGS.slice()}:{}}}static fromJSON(t,e){if(typeof e=="string")e={name:e};else if(Array.isArray(e)&&e.some(i=>typeof i=="string")&&(e=e.slice()))e={name:e.pop(),prefix:e.pop()};else if(typeof e?.name!="string")return;let r=new this(t).withFlag(...e?.flags||[]);return r.name(e.name).prefix(e.prefix),r}stringify(){return this.autoEsc([this.PREFIX,this.NAME].filter(t=>t)).join(".")+""}static parse(t,e){if(/^(TRUE|FALSE|NULL)$/i.test(e))return;let[r,i]=this.parseIdent(t,e,!0)||[];if(r)return new this(t).name(r).prefix(i)}};function Ke(u,t){return se(u,t,!0)}function ne(u,t){return He(u,t,!0)}function ae(u,t){return u===void 0?"":u.split(/(?=[A-Z])/).join(t||" ")}function ke(u,t){return typeof u!="string"?u:u.replace(/\w\S*/g,function(e){return e.charAt(0).toUpperCase()+(typeof t!==void 0&&t?e.substr(1).toLowerCase():e.substr(1))})}function Xe(u,t){return u=ke(u.replace(/-/g," ")).replace(/ /g,""),t?u:u[0].toLowerCase()+u.substr(1)}function b(u,t,e){return ne(se(u,t),e)}function M(u,t,e){return u.startsWith(t)&&u.endsWith(e)}var et=class extends _{INPUT;true(){return this.INPUT=!0,this}false(){return this.INPUT=!1,this}null(){return this.INPUT=null,this}literal(t){return this.INPUT=t,this}toJSON(){return{input:this.INPUT}}static fromJSON(t,e){if(!(typeof e?.input>"u"))return new this(t).literal(e.input)}stringify(){return g(this.INPUT)||Array.isArray(this.INPUT)?JSON.stringify(this.INPUT):`${this.INPUT}`}static parse(t,e){let r=new this(t);if(/^TRUE$/i.test(e))return r.true();if(/^FALSE$/i.test(e))return r.false();if(/^NULL$/i.test(e))return r.null();let i=[["{","}"],["[","]"]],s={};return(s.braces=i.find(n=>M(e,n[0],n[1])))&&!p.match(e,[" "]).length?new this(t).literal(JSON.parse(e)):r.literal(e)}static factoryMethods={true:t=>new this(t),false:t=>new this(t),null:t=>new this(t),literal:(t,e)=>typeof e<"u"&&new this(t)}};var rt=class extends _{QUOTE;VALUE="";constructor(t,e="'"){super(t),this.QUOTE=e}value(t){return this.VALUE=t,this}toJSON(){return{quote:this.QUOTE,value:this.VALUE||""}}static fromJSON(t,e){if(!(typeof e?.value!="string"||!['"',"'"].includes(e.quote)))return new this(t,e.quote).value(e.value)}stringify(){return this.stringifyText(this.VALUE)}static parse(t,e){let[r,i]=this.parseText(t,e,!0)||[];if(i)return new this(t,i).value(r)}stringifyText(t){let e=this.QUOTE||this.quoteChars[0];return`${e}${((t||"")+"").replace(new RegExp(e,"g"),e.repeat(2))}${e}`}static parseText(t,e,r=!1){let i=this.getQuoteChars(t,r),s={};if(!(!(s.quote=i.find(n=>M(e,n,n)))||p.match(e,[" "]).length))return[b(e,s.quote,s.quote).replace(new RegExp(s.quote+s.quote,"g"),s.quote),s.quote]}};var xe=u=>class extends u{ENTRIES=[];get length(){return this.ENTRIES.length}entries(...t){return arguments.length?(this.build("ENTRIES",t,this.constructor.Types),this):this.ENTRIES}getEntry(t){return this.ENTRIES[t]}removeEntry(t){let e=this.getEntry(t);return e&&(this.ENTRIES=this.ENTRIES.filter(r=>r!==e)),e&&e.$trace("event:DISCONNECTED",e),e}filterInplace(t){return this.ENTRIES=this.ENTRIES.filter((e,r)=>{let i=t(e,r);return i||e.$trace("event:DISCONNECTED",e),i})}toJSON(){return{entries:this.ENTRIES.map(t=>t.toJSON())}}static fromJSON(t,e){if(!Array.isArray(e?.entries))return;let r=new this(t);for(let i of e.entries)r.entries(i);return r}stringify(){return`(${this.ENTRIES.join(", ")})`}static parse(t,e,r){if(!M(e,"(",")"))return;let i=new this(t);return i.entries(...p.split(b(e,"(",")"),[","]).map(s=>r(i,s.trim(),this.Types))),i}};var st=class extends xe(_){getEntry(t){return typeof t=="number"?super.getEntry(t):this.ENTRIES.find(e=>e.name().toLowerCase()===t.toLowerCase())}static Types=[T]};var Qt=class extends _{CONDITION=null;CONSEQUENCE=null;condition(t){return this.build("CONDITION",[t],C.Types),this}then_(t){return this.build("CONSEQUENCE",[t],C.Types)}toJSON(){return{condition:this.CONDITION?.toJSON(),consequence:this.CONSEQUENCE?.toJSON()}}static fromJSON(t,e){if(!(typeof e=="object"&&e&&"condition"in e))return;let r=new this(t);return r.condition(e.condition),r.then_(e.consequence),r}stringify(){return`${this.CONDITION} THEN ${this.CONSEQUENCE}`}static parse(t,e,r){let i=p.split(e,["\\s+THEN\\s+"],{useRegex:"i"});if(i.length!==2)return;let s=new this(t),[n,f]=i.map(o=>r(s,o.trim()));return s.condition(n).then_(f),s}};var Ft=class extends _{BASE_VALUE;WHEN_CLAUSES=[];ELSE_CLAUSE;compare(t){if(this.WHEN_CLAUSES.length||this.ELSE_CLAUSE)throw new Error('A "case" clause must come before any "when" or "else" clauses.');return this.build("BASE_VALUE",[t],C.Types)}when(t){if(this.ELSE_CLAUSE)throw new Error('A "when" clause cannot come after an "else" clause.');return this.build("WHEN_CLAUSES",[t],Qt,"condition"),this.WHEN_CLAUSES[this.WHEN_CLAUSES.length-1]}else(t){if(!this.WHEN_CLAUSES.length)throw new Error('An "else" clause cannot come before "when" clauses.');return this.build("ELSE_CLAUSE",[t],C.Types)}toJSON(){return{base_value:this.BASE_VALUE?.toJSON(),when_clauses:this.WHEN_CLAUSES.map(t=>t.toJSON()),else_clause:this.ELSE_CLAUSE?.toJSON(),flags:this.FLAGS}}static fromJSON(t,e){if(!Array.isArray(e?.when_clauses))return;let r=new this(t).withFlag(...e.flags||[]);e.base_value&&r.compare(e.base_value);for(let i of e.when_clauses)r.when(i);return e.else_clause&&r.else(e.else_clause),r}stringify(){let t=[];return this.BASE_VALUE&&t.push(this.BASE_VALUE),t.push(`WHEN ${this.WHEN_CLAUSES.join(" WHEN ")}`),this.ELSE_CLAUSE&&t.push("ELSE",this.ELSE_CLAUSE),`CASE ${t.join(" ")} END${this.params.dialect==="mysql"?" CASE":""}`}static parse(t,e,r){let[i,s]=e.match(/^CASE\s+([\s\S]*)\s+END(\s+CASE)?$/i)||[];if(!i)return;let{tokens:[n,...f],matches:o}=p.lex(s,["WHEN","ELSE"],{useRegex:"i"}),c=new this(t);n.trim()&&c.compare(r(c,n.trim()));for(let h of o){let l=f.shift();if(/ELSE/i.test(h))c.else(r(c,l.trim()));else if(/WHEN/i.test(h))c.when(r(c,l.trim(),[Qt]));else throw new Error(`Can't have multiple "${h}" clauses in a CASE construct.`)}return c}static factoryMethods={case:t=>new this(t)}};var B=class extends _{OPERATOR="";OPERANDS=[];constructor(t,e,...r){super(t),this.OPERATOR=e,this.OPERANDS=r}assert(t,...e){return this.OPERATOR&&this.OPERANDS.splice(0),this.OPERATOR=t,this.build("OPERANDS",e,C.Types),this}equals(...t){return this.assert("=",...t)}eq(...t){return this.equals(...t)}notEqual(...t){return this.assert("<>",...t)}notEq(...t){return this.notEqual(...t)}lesserThan(...t){return this.assert("<",...t)}lt(...t){return this.lesserThan(...t)}lessThanOrEqual(...t){return this.assert("<=",...t)}ltOrEq(...t){return this.lessThanOrEqual(...t)}greaterThan(...t){return this.assert(">",...t)}gt(...t){return this.greaterThan(...t)}greaterThanOrEqual(...t){return this.assert(">=",...t)}gtOrEq(...t){return this.greaterThanOrEqual(...t)}in(...t){return this.assert("IN",...t)}any(...t){return this.assert("ANY",...t)}like(...t){return this.assert("LIKE",...t)}isNull(...t){return this.assert("IS NULL",...t)}isNotNull(...t){return this.assert("IS NOT NULL",...t)}isTrue(...t){return this.assert("IS TRUE",...t)}isNotTrue(...t){return this.assert("IS NOT TRUE",...t)}isFalse(...t){return this.assert("IS FALSE",...t)}isNotFalse(...t){return this.assert("IS NOT FALSE",...t)}isUnknow(...t){return this.assert("IS UNKNOWN",...t)}isNotUnknow(...t){return this.assert("IS NOT UNKNOWN",...t)}isDistinctFrom(...t){return this.assert("IS DISTINCT FROM",...t)}isNotDistinctFrom(...t){return this.assert("IS NOT DISTINCT FROM",...t)}isBetween(...t){return this.assert("IS BETWEEN",...t)}isNotBetween(...t){return this.assert("IS NOT BETWEEN",...t)}isBetweenSymmetric(...t){return this.assert("IS BETWEEN SYMMETRIC",...t)}isNotBetweenSymmetric(...t){return this.assert("IS NOT BETWEEN SYMMETRIC",...t)}and(...t){return new $(this,"AND").and(this,...t)}or(...t){return new $(this,"OR").or(this,...t)}toJSON(){return{operator:this.OPERATOR,operands:this.OPERANDS.map(t=>t.toJSON()),flags:this.FLAGS}}static fromJSON(t,e){if(!Array.isArray(e?.operands)||typeof e?.operator!="string"||!this.regexes.some(i=>new RegExp(i.regex||i.test||i).test(` ${e.operator} `)))return;let r=new this(t).withFlag(...e.flags||[]);return r.assert(e.operator,...e.operands),r}stringify(){let t=this.OPERANDS.slice(0),e=[t.shift(),this.OPERATOR.toUpperCase()],r=t;return this.OPERATOR==="IN"?e.push(`(${r.join(", ")})`):/BETWEEN/i.test(this.OPERATOR)?e.push(`(${r.join(" AND ")})`):e.push(`${r.join(" ")}`),e.filter(i=>i).join(" ")}static parse(t,e,r){let{tokens:[i,s=""],matches:[n]}=p.lex(e,this.regexes,{useRegex:"i"});if(!n)return;let f=n.trim().toUpperCase(),o=[i];return f==="IN"?o.push(...p.split(b(s.trim(),"(",")"),[","])):/BETWEEN/.test(f)?o.push(...p.split(s,[" AND "])):s&&o.push(s),new this(t,f,...o.map(c=>r(t,c.trim())))}static regexes=[{test:"<(?!~)"},{backtest:"^(?!.*~$)",test:">",regex:"(?<!~)>"},"((\\s+(?:NOT\\s+)?IS\\s+(?:NOT\\s+)?(TRUE|FALSE|NULL|UNKNOWN|DISTINCT\\s+FROM\\s+))|\\s+(ISNULL|NOTNULL|IN|ANY|LIKE|(?:NOT\\s+)?BETWEEN(?:\\s+SYMMETRIC)?)\\s+|(?:\\s+)?(=|<=|>=|!=|<>)(?:\\s+)?)"]};var nt=class extends _{constructor(t){super(t),this._QUERY_BINDINGS=[],this._ROOT_SCHEMA=null}get BINDINGS(){return this._QUERY_BINDINGS}$trace(t,...e){if(t==="get:STATEMENT_NODE")return this;if(t==="get:QUERY_BINDINGS")return this._QUERY_BINDINGS;if(["get:TABLE_NAME","get:DATABASE_NAME"].includes(t)&&!this._ongoingNameTrace){let r=this.$trace("get:TABLE_NODE");if(r&&!(r instanceof T)&&(r=r.EXPR,!(r instanceof T))){this._ongoingNameTrace=!0;let i=r.expr().$trace(t,...e);return delete this._ongoingNameTrace,i}if(r&&t==="get:TABLE_NAME")return r.name();if(r&&t==="get:DATABASE_NAME"&&r.prefix())return r.prefix()}return t==="get:ROOT_SCHEMA"?(this._ROOT_SCHEMA||(this._ROOT_SCHEMA=this.CONTEXT?.$trace?.(t)),this._ROOT_SCHEMA):this.CONTEXT?.$trace?.(t,...e)}clone(){let t=super.clone();return t._QUERY_BINDINGS=this._QUERY_BINDINGS.slice(0),t._ROOT_SCHEMA=this._ROOT_SCHEMA,t}static mySubstitutePlaceholders(t,e){return(t?.params?.inputDialect||t?.params?.dialect)!=="mysql"||e.indexOf("?")===-1?e:p.split(e,["?"],{blocks:[]}).reduce((r,i,s)=>r?r+"?"+s+i:i,null)}get expandable(){return!1}async expand(t=!1){return t?this:this.clone()}};var Bt=class extends _{OFFSET;constructor(t,e){super(t),this.OFFSET=parseInt(e)}$var(t){this.OFFSET=t}$bind(t,e){this.OFFSET=t;let r=this.$trace("get:QUERY_BINDINGS");r?.push(e),this.OFFSET===0&&(this.OFFSET=r?.length)}toJSON(){return{offset:this.OFFSET}}static fromJSON(t,e){if(typeof e?.offset=="number")return new this(t,e.offset)}stringify(){return this.params.dialect==="mysql"?"?":"$"+this.OFFSET}static parse(t,e){let r=(t?.params?.inputDialect||t?.params?.dialect)==="mysql"?"?":"$",[i,s]=new RegExp(`^\\${r}(\\d)$`).exec(e)||[];if(i)return new this(t,parseInt(s))}};var Ct=class extends _{VALUE=0;constructor(t,e){super(t),this.VALUE=e}value(t){this.VALUE=t}toJSON(){return{value:this.VALUE,flags:this.FLAGS}}static fromJSON(t,e){if(typeof e=="number"||typeof e=="string"&&/^[.\d]+$/.test(e)&&(e=parseFloat(e)))e={value:e};else if(typeof e?.value!="number")return;return new this(t,e.value).withFlag(...e.flags||[])}stringify(){return`${this.VALUE}`}static parse(t,e){if(/^\d+$/.test(e))return new this(t,parseFloat(e))}static factoryMethods={value:(t,e)=>/^\d+$/.test(e)&&new this(t)}};var mt=class extends rt{json(t){if(!Array.isArray(t)&&!g(t))throw new Error("An array or object expected.");return this.VALUE=t,this}static fromJSON(t,e){if(!(!Array.isArray(e?.value)&&!g(e?.value)))return new this(t).value(e.value)}stringify(){return this.stringifyText(JSON.stringify(this.VALUE))}static parse(t,e){let r=[["{","}"],["[","]"]],i={},[s,n]=this.parseText(t,e)||[];if(n&&!(!(i.braces=r.find(f=>M(e,f[0],f[1])))||p.match(e,[" "]).length))return new this(t,n).json(JSON.parse(s))}static factoryMethods={json:(t,e)=>(Array.isArray(e)||g(e))&&new this(t)}};var at=class extends _{static OPERATORS=["->","->>","#>","#>>"];OPERATOR="";LHS=null;RHS=null;path(t,e,r){if(!this.constructor.OPERATORS.includes(e))throw new Error(`Unknown operator: "${e}".`);this.build("LHS",[t],[mt,T]),this.build("RHS",[r],[mt,Ct,rt]),this.OPERATOR=e}toJSON(){return{lhs:this.LHS?.toJSON(),rhs:this.RHS?.toJSON(),operator:this.OPERATOR,flags:this.FLAGS}}static fromJSON(t,e){if(!this.OPERATORS.includes(e?.operator))return;let r=new this(t).withFlag(...e.flags||[]);return r.path(e.lhs,e.operator,e.rhs),r}stringify(){return`${this.LHS} ${this.OPERATOR} ${this.RHS}`}static parse(t,e,r){if((t?.params?.inputDialect||t?.params?.dialect)==="mysql")return;let{tokens:i,matches:s}=p.lex(e,this.OPERATORS,{limit:1});if(!s.length)return;let n=new this(t),f=r(n,i[0],[mt,T]),o=r(n,i[1].trim(),[mt,Ct,rt]);return n.path(f,s[0],o),n}static factoryMethods={path:(t,e,r,i)=>this.OPERATORS.includes(r)&&new this(t)}};var it=class u extends _{static ARR_RIGHT="~>";static ARR_LEFT="<~";OPERATOR="";LHS=null;RHS=null;UUID=null;get isOutgoing(){return this.OPERATOR===this.constructor.ARR_RIGHT}get isIncoming(){return this.OPERATOR===this.constructor.ARR_LEFT}get uuid(){return this.UUID||(this.UUID=`$path:${(0|Math.random()*9e6).toString(36)}`),this.UUID}path(t,e,r){let i=this.constructor;if(![i.ARR_LEFT,i.ARR_RIGHT].includes(e))throw new Error(`Unknown operator: "${e}".`);this.build("LHS",[t],T),this.build("RHS",[r],[i,at,T]),this.OPERATOR=e}async eval(){let t=this.$trace("get:STATEMENT_NODE"),e=await this.$trace("get:ROOT_SCHEMA");if(!e)throw new Error("Root schema not associated with query.");let r=m=>m.primaryKey()?.columns()[0],i=async(m,E)=>{let A=m.foreignKeys().find(S=>S.columns().includes(E.name())),N=A?T.fromJSON(this,[A.targetSchema(),A.targetTable()]):null;return N&&!N.prefix()?N.prefix((await t.structure()).findPath(A.targetTable())):N};if(this.isIncoming){if(!(this.RHS instanceof u))throw new Error(`Unterminated path: ${this.RHS}`);let m,E,A,N;if(this.RHS.isIncoming){if(!(this.RHS.RHS instanceof u))throw new Error(`Unterminated path: ${this.RHS.RHS}`);({LHS:m,RHS:N}=this),{schema:A,table:E}=(await N.eval()).lhs}else if({LHS:m,RHS:{LHS:E,RHS:N}}=this,E.prefix()||(E=T.fromJSON(this,[e.findPath(E.name()),E.name()])),A=e.database(E.prefix())?.table(E.name()),!A)throw new Error(`[${this}]: The implied table ${E} does not exist.`);let S=await i(A,m);if(!S)throw new Error(`[${this}]: Table ${E} does not define the implied foreign key: ${m}.`);let d=e.database(S.prefix())?.table(S.name());if(!d)throw new Error(`[${this}]: The implied table ${S} does not exist.`);let R=r(d);if(!R)throw new Error(`[${this}]: Table ${d} does not define a primary key.`);return{lhs:{table:S,schema:d,primaryKey:R},rhs:{table:E,schema:A,foreignKey:m,path:N}}}let s=await ur.call(this);if(!s)throw new Error("No tables in query.");let n=e.database(s.prefix())?.table(s.name());if(!n)throw new Error(`[${this}]: The implied table ${s} does not exist.`);let{LHS:f,RHS:o}=this,c=await i(n,f);if(!c)throw new Error(`[${this}]: Table ${s} does not define the implied foreign key: ${f}.`);let h=e.database(c.prefix())?.table(c.name());if(!h)throw new Error(`[${this}]: The implied table ${c} does not exist.`);let l=r(h);if(!l)throw new Error(`[${this}]: Table ${c} does not define a primary key.`);return{lhs:{table:s,schema:n,foreignKey:f},rhs:{table:c,schema:h,primaryKey:l,path:o}}}async plot(){if(this.JOINT)return;let t=this.$trace("get:STATEMENT_NODE"),e=await ur.call(this);if(!e)throw new Error("No tables in query.");let{lhs:r,rhs:i}=await this.eval(),s=r.foreignKey?.name()||r.primaryKey,n=i.primaryKey||i.foreignKey.name();if(r.primaryKey&&(r.table.name().toLowerCase()!==e.name().toLowerCase()||r.table.prefix().toLowerCase()!==e.prefix().toLowerCase()))throw new Error(`[${this}]: Cannot resolve incoming path to base table ${e.EXPR}.`);let f=`_view:${[s,i.table.prefix(),i.table.name(),n].join(":")}`,o=()=>this.JOINT=t.JOIN_LIST.find(c=>c.ALIAS.name().toLowerCase()===f.toLowerCase());if(!o()){let c=this.$trace("get:TABLE_NODE").ALIAS?.name()||e.name(),h=`${n}:${(0|Math.random()*9e6).toString(36)}`;t.leftJoin(l=>l.query(m=>m.select(E=>E.expr(n).as(h)),m=>m.from([i.table.prefix(),i.table.name()].filter(E=>E)))).with({IS_SMART_JOIN:!0}).as(f).on(l=>l.equals([f,h],[c,s])),o()}this.JOINT.EXPR.EXPR.select(c=>c.expr(i.path.toJSON()).as(this.uuid))}toJSON(){return{lhs:this.LHS?.toJSON(),rhs:this.RHS?.toJSON(),operator:this.OPERATOR,flags:this.FLAGS}}static fromJSON(t,e){if(![this.ARR_LEFT,this.ARR_RIGHT].includes(e?.operator))return;let r=new this(t).withFlag(...e.flags||[]);return r.path(e.lhs,e.operator,e.rhs),r}stringify(){return this.JOINT?this.autoEsc([this.JOINT.ALIAS.name(),this.uuid]).join("."):`${this.LHS} ${this.OPERATOR} ${this.RHS}`}static parse(t,e,r){let{tokens:i,matches:s}=p.lex(e,[this.ARR_LEFT,this.ARR_RIGHT],{limit:1});if(!s.length)return;let n=new this(t),f=r(n,i[0],[T]),o=r(n,i[1],s[0]===this.ARR_LEFT?[this]:[this,at,T]);return n.path(f,s[0],o),n}static factoryMethods={path:(t,e,r,i)=>[this.ARR_LEFT,this.ARR_RIGHT].includes(r)&&new this(t)}};async function ur(){let u=this.$trace("get:TABLE_NAME");if(!u)return;let t=this.$trace("get:DATABASE_NAME");return T.fromJSON(this,[t||(await this.$trace("get:ROOT_SCHEMA")).findPath(u),u])}var vt=class extends _{EXPR;ALIAS;CLAUSED;expr(t){return arguments.length?(this.build("EXPR",[t],this.constructor.exprTypes),this):this.EXPR}query(...t){return arguments.length?(this.build("EXPR",t,Q,"query"),this):this.EXPR instanceof Q?this.EXPR:null}as(t,e=!0){return this.build("ALIAS",[t],T),this.CLAUSED=e,this}toJSON(){return{expr:this.EXPR?.toJSON(),alias:this.ALIAS?.toJSON(),claused:this.CLAUSED,flags:this.FLAGS}}static fromJSON(t,e){let r=new this(t).withFlag(...e.flags||[]);return e?.expr?(r.expr(e.expr),e.alias&&r.as(e.alias,e.claused)):e&&r.expr(e),r}stringify(){let t=this.ALIAS||this.EXPR instanceof it&&this.EXPR.JOINT&&this.autoEsc(this.EXPR.clone().stringify());return[this.EXPR,this.CLAUSED?"AS":"",t].filter(e=>e).join(" ")}static parse(t,e,r){let i=new this(t),s=this.getEscChar(t,!0),[,n,f,o,,c]=new RegExp(`^([\\s\\S]+?)(?:(\\s+AS\\s+|(?<!(?:~>|<~))\\s+)(?:([\\w]+)|(${s})((?:\\4\\4|[^\\4])+)\\4))?$`,"i").exec(e.trim())||[],h,l=o||c;if(l&&!f?.trim()&&!n.trim().endsWith(")")){try{h=r(i,n,this.exprTypes)}catch{}h||(l=o=c=null,n=e)}if(h||(h=r(i,n,this.exprTypes)),i.expr(h),l){let m=o||this.autoUnesc(i,c),E=!!f?.trim();i.as(m,E)}return i}static get exprTypes(){return C.Types.filter(t=>t!==et)}};var J=class extends vt{static get exprTypes(){return[Q,T]}};var U=class extends J{TYPE="";CORRELATION=null;full(t){return this.TYPE="JOIN",this.expr(t),this}left(t){return this.TYPE="LEFT_JOIN",this.expr(t),this}right(t){return this.TYPE="RIGHT_JOIN",this.expr(t),this}inner(t){return this.TYPE="INNER_JOIN",this.expr(t),this}cross(t){return this.TYPE="CROSS_JOIN",this.expr(t),this}on(...t){return this.build("CORRELATION",t,$,"and")}using(t){return this.build("CORRELATION",[t],T)}toJSON(){return{type:this.TYPE,correlation:this.CORRELATION?.toJSON(),...super.toJSON()}}static fromJSON(t,e){let r=super.fromJSON(t,e);if(!(!r||!e.type))return e?.expr&&e.type&&(r.TYPE=e.type),e?.expr&&e.correlation&&r.build("CORRELATION",[e.correlation],[T,$]),r}stringify(){return[this.TYPE?.replace(/_/," ").toUpperCase()||"JOIN",super.stringify(),this.CORRELATION instanceof T?`USING ${this.CORRELATION}`:`ON ${this.CORRELATION}`].filter(t=>t).join(" ")}static parse(t,e,r){let[i,s,n]=e.match(new RegExp(`^${this.regex}([\\s\\S]*)$`,"i"))||[];if(!i)return;let{tokens:[f,o],matches:c}=p.lex(n,["\\s+(?:ON|USING)\\s+"],{useRegex:"i"}),h=super.parse(t,f.trim(),r);return h.TYPE=s.trim().toUpperCase()+"_JOIN",/USING/i.test(c[0])?h.using(r(h,o.trim(),[T])):/ON/i.test(c[0])&&h.on(r(h,o.trim(),[$,B])),h}static regex="(INNER\\s+|CROSS\\s+|(?:LEFT|RIGHT)(?:\\s+OUTER)?\\s+)?JOIN"};var At=class extends _{NAME="";ARGS=[];fn(t,...e){return this.NAME=t,this.build("ARGS",e,C.Types)}toJSON(){return{name:this.NAME,args:this.ARGS.map(t=>t.toJSON()),flags:this.FLAGS}}static fromJSON(t,e){if(typeof e?.name!="string"||!Array.isArray(e.args))return;let r=new this(t).withFlag(...e.flags||[]);return r.fn(e.name,...e.args),r}stringify(){return`${this.NAME.toUpperCase()}(${this.ARGS.join(", ")})`}static parse(t,e,r){if(!e.endsWith(")")||p.match(e,[" "]).length)return;let[,i,s=""]=/^(\w+)\(([\s\S]+)?\)$/i.exec(e),n=new this(t);return n.fn(i,...p.split(s,[","]).map(f=>r(n,f.trim()))),n}};var oe=class extends _{CRITERIA=[];criterion(...t){return this.build("CRITERIA",t,C.Types)}toJSON(){return{criteria:this.CRITERIA.map(t=>t.toJSON()),flags:this.FLAGS}}static fromJSON(t,e){if(!Array.isArray(e?.criteria))return;let r=new this(t).withFlag(...e.flags||[]);return r.criterion(...e.criteria),r}stringify(){return this.CRITERIA.map(t=>[t,...t.FLAGS].join(" ")).join(", ")}static parse(t,e,r){let[i,s]=e.match(new RegExp(`^${this.regex}([\\s\\S]*)$`,"i"))||[];if(!i)return;let n=new this(t);for(let f of p.split(s.trim(),[","])){let[,o,c]=/([\s\S]+)\s+(ASC|DESC)$/i.exec(f)||[,f];n.criterion(r(n,o).withFlag(c))}return n}static regex="ORDER\\s+BY"};var v=class extends oe{withRollup(){return this.withFlag("WITH_ROLLUP")}stringify(){return["ORDER BY",super.stringify(),...this.FLAGS.map(t=>t.replace(/_/g," "))].join(" ")}static parse(t,e,r){let{tokens:[i],matches:s}=p.lex(e,["\\s+WITH\\s+ROLLUP$"],{useRegex:"i"}),n=super.parse(t,i.trim(),r);if(n)return s.length&&n.withFlag("WITH_ROLLUP"),n}};var Yt=class extends _{CRITERIA=[];criterion(...t){return this.build("CRITERIA",t,C.Types)}stringify(){return this.CRITERIA.map(t=>t.stringify()).join(",")}toJSON(){return{criteria:this.CRITERIA.map(t=>t.toJSON()),flags:this.FLAGS}}static fromJSON(t,e){if(!Array.isArray(e?.criteria))return;let r=new this(t).withFlag(...e.flags||[]);return r.criterion(...e.criteria),r}static parse(t,e,r){let[i,s]=e.match(new RegExp(`^${this.regex}([\\s\\S]*)$`,"i"))||[];if(!i)return;let n=new this(t);for(let f of p.split(s.trim(),[","]))n.criterion(r(n,f));return n}static regex="GROUP\\s+BY"};var zt=class extends Yt{stringify(){return["PARTITION BY",super.stringify()].join(" ")}static regex="PARTITION\\s+BY"};var yt=class extends _{NAME;WINDOW_REF;PARTITION_BY_CLAUSE;ORDER_BY_CLAUSE;name(t){return this.NAME=t,this}existing(t){return this.WINDOW_REF=t,this}extends(t){return this.WINDOW_REF=t,this}partitionBy(...t){if(this.WINDOW_REF)throw new Error("The PARTITION BY clause is not allowed when inheriting from a base window.");return this.build("PARTITION_BY_CLAUSE",t,zt,"criterion")}orderBy(...t){return this.build("ORDER_BY_CLAUSE",t,v,"criterion")}toJSON(){return{name:this.NAME,window_ref:this.WINDOW_REF,partition_by_clause:this.PARTITION_BY_CLAUSE?.toJSON(),order_by_clause:this.ORDER_BY_CLAUSE?.toJSON()}}static fromJSON(t,e){if(typeof e=="string")e={window_ref:e};else if(!(typeof e=="object"&&e)||!["name","window_ref","partition_by_clause","order_by_clause"].some(i=>i in e))return;let r=new this(t);return e.name&&r.name(e.name),e.window_ref&&r.extends(e.window_ref),e.partition_by_clause&&r.partitionBy(e.partition_by_clause),e.order_by_clause&&r.orderBy(e.order_by_clause),r}stringify(){let t=[];return!this.NAME&&this.WINDOW_REF&&!this.PARTITION_BY_CLAUSE&&!this.ORDER_BY_CLAUSE?t.push(this.WINDOW_REF):(this.NAME&&t.push(`${this.NAME} AS `),t.push(`(${[this.WINDOW_REF,this.PARTITION_BY_CLAUSE,this.ORDER_BY_CLAUSE].filter(e=>e).join(" ")})`)),t.join("")}static parse(t,e,r){let i=new this(t),s=async o=>{let{tokens:[c,...h],matches:l}=p.lex(b(o.trim(),"(",")"),["PARTITION\\s+BY","ORDER\\s+BY"],{useRegex:"i",preserveDelims:!0});c.trim()&&i.extends(c.trim());for(let m of l){if(/PARTITION\s+BY/i.test(m)){i.partitionBy(r(i,h.shift().trim(),[zt]));continue}i.orderBy(r(i,h.shift().trim(),[v]))}},n=e.endsWith(")");if(n&&!e.startsWith("(")){let[o,c]=spec.split(new RegExp(" AS ","i"));i.name(o.trim()),s(c)}else n?s(e):i.existing(e);return i}static regex="WINDOW|OVER"};var pt=class extends At{ORDER_BY_CLAUSE;OVER_CLAUSE;fn(...t){return super.fn(...t),this}orderBy(...t){return this.build("ORDER_BY_CLAUSE",t,v,"criterion"),this}over(t){return t||(t={name:""}),this.build("OVER_CLAUSE",[t],yt),this.OVER_CLAUSE}toJSON(){return{...super.toJSON(),order_by_clause:this.ORDER_BY_CLAUSE?.toJSON(),over_clause:this.OVER_CLAUSE?.toJSON()}}static fromJSON(t,e){let r=super.fromJSON(t,e);if(r)return this.names.flat().includes(r.NAME.toUpperCase())&&(e.order_by_clause&&r.orderBy(e.order_by_clause),e.over_clause&&r.over(e.over_clause)),r}stringify(){return`${this.NAME.toUpperCase()}(${[...this.FLAGS,this.ARGS.join(","),this.ORDER_BY_CLAUSE].filter(e=>e).join(" ")})`+(this.OVER_CLAUSE?` OVER ${this.OVER_CLAUSE}`:"")}static parse(t,e,r){let[i,s]=p.split(e,["OVER\\s+"],{useRegex:"i"}).map(m=>m.trim());if(!i.endsWith(")")||p.match(i,[" "]).length)return;let[,n,f,o=""]=/^(\w+)\((?:\s+)?(?:(ALL|DISTINCT)\s+)?([\s\S]+)?\)$/i.exec(i);if(!this.names.flat().includes(n.toUpperCase()))return;let[,c,h]=/^([\s\S]+)(?:\s+(ORDER\s+BY\s+.+))$/i.exec(o)||[,o],l=super.parse(t,`${n}(${c})`,r);return f&&l.withFlag(f),h?l.orderBy(r(l,h,[v])):s&&l.over(r(l,s,[yt])),l}static factoryMethods={fn:(t,e,...r)=>this.names.flat().includes(e?.toUpperCase())&&new this(t)};static names=[["AVG","BIT_AND","BIT_OR","BIT_XOR","COUNT","JSON_ARRAYAGG","JSON_OBJECTAGG","MAX","MIN","STDDEV_POP","STDDEV","STD","STDDEV_SAMP","SUM","VAR_POP","VARIANCE","VAR_SAMP","GROUP_CONCAT","GROUP_CONCAT_WS"],["CUME_DIST","DENSE_RANK","FIRST_VALUE","LAG","LAST_VALUE","LEAD","NTH_VALUE","NTLE","PERCENT_RANK","RANK","ROW_NUMBER"],["ANY_VALUE","COLUMN","COLUMNS","GROUPING"]]};var k=class extends vt{path(t,e,r){return this.build("EXPR",[t,e,r],at.OPERATORS.includes(e)?at:it,"path"),this}fn(t,...e){return this.build("EXPR",[t,...e],pt.names.flat().includes(t.toUpperCase())?pt:At,"fn"),this}case(...t){return this.build("EXPR",t,Ft),this}};var Zt=class extends _{WINDOWS_LIST=[];define(...t){return this.build("WINDOWS_LIST",t,yt)}toJSON(){return{window_list:this.WINDOWS_LIST.map(t=>t.toJSON())}}static fromJSON(t,e){if(!Array.isArray(e?.window_list))return;let r=new this(t);return r.define(...e.window_list),r}stringify(){return`WINDOW ${this.WINDOWS_LIST.join(",")}`}static parse(t,e,r){let[i,s]=e.match(new RegExp(`^${this.regex}([\\s\\S]*)$`,"i"))||[];if(!i)return;let n=new this(t);for(let f of p.split(s,[","]))n.define(r(n,f.trim(),[Window]));return n}static regex="WINDOW"};var jt=class extends Yt{withRollup(){return this.withFlag("WITH_ROLLUP")}stringify(){return["GROUP BY",super.stringify(),...this.FLAGS.map(t=>t.replace(/_/g," "))].join(" ")}static parse(t,e,r){let{tokens:[i],matches:s}=p.lex(e,["\\s+WITH\\s+ROLLUP$"],{useRegex:"i"}),n=super.parse(t,i,r);if(n)return s.length&&n.withFlag("WITH_ROLLUP"),n}};var W=class u extends nt{SELECT_LIST=[];FROM_LIST=[];JOIN_LIST=[];WHERE_CLAUSE=null;GROUP_BY_CLAUSE=null;HAVING_CLAUSE=null;WINDOW_CLAUSE=null;ORDER_BY_CLAUSE=null;OFFSET_CLAUSE=null;LIMIT_CLAUSE=null;UNION_CLAUSE=null;AGGRS=[];PATHS=[];VARS=[];SUBQUERIES=[];select(...t){return arguments.length?this.build("SELECT_LIST",t,k):this.SELECT_LIST}from(...t){return this.build("FROM_LIST",t,J),this.FROM_LIST[this.FROM_LIST.length-1]}join(t){return this.build("JOIN_LIST",[t],U,"full")}leftJoin(t){return this.build("JOIN_LIST",[t],U,"left")}rightJoin(t){return this.build("JOIN_LIST",[t],U,"right")}innerJoin(t){return this.build("JOIN_LIST",[t],U,"inner")}crossJoin(t){return this.build("JOIN_LIST",[t],U,"cross")}where(...t){return arguments.length?this.build("WHERE_CLAUSE",t,$,"and"):this.WHERE_CLAUSE}groupBy(...t){return arguments.length?(this.build("GROUP_BY_CLAUSE",t,jt,"criterion"),this.GROUP_BY_CLAUSE):this.GROUP_BY_CLAUSE}having(...t){return arguments.length?this.build("HAVING_CLAUSE",t,$,"and"):this.HAVING_CLAUSE}window(...t){return arguments.length?this.build("WINDOW_CLAUSE",t,Zt,"define"):this.WINDOW_CLAUSE}orderBy(...t){return arguments.length?(this.build("ORDER_BY_CLAUSE",t,v,"criterion"),this.ORDER_BY_CLAUSE):this.ORDER_BY_CLAUSE}offset(t){if(!arguments.length)return this.OFFSET_CLAUSE;if(typeof t!="number")throw new Error("Offsets must be of type number.");this.OFFSET_CLAUSE=t}limit(...t){if(!arguments.length)return this.LIMIT_CLAUSE;if(!t.every(e=>typeof e=="number"))throw new Error("Limits must be of type number.");this.LIMIT_CLAUSE=t}union(...t){return arguments.length?(this.build("UNION_CLAUSE",t,this.constructor,"select"),this.UNION_CLAUSE):this.UNION_CLAUSE}get expandable(){return this.PATHS.length>0||this.SUBQUERIES.some(t=>t.expandable)}async expand(t=!1){let e=t?this:this.clone();if(!e.expandable)return e;for(let r of e.PATHS)await r.plot();for(let r of e.SUBQUERIES)await r.expand(!0);return e}toJSON(){return{select_list:this.SELECT_LIST.map(t=>t.toJSON()),from_list:this.FROM_LIST.map(t=>t.toJSON()),join_list:this.JOIN_LIST.map(t=>t.toJSON()),where_clause:this.WHERE_CLAUSE?.toJSON(),group_by_clause:this.GROUP_BY_CLAUSE?.toJSON(),having_clause:this.HAVING_CLAUSE?.toJSON(),window_clause:this.WINDOW_CLAUSE?.toJSON(),order_by_clause:this.ORDER_BY_CLAUSE?.toJSON(),offset_clause:this.OFFSET_CLAUSE,limit_clause:this.LIMIT_CLAUSE,union_clause:this.UNION_CLAUSE,flags:this.FLAGS}}static fromJSON(t,e){if(!Array.isArray(e?.select_list))return;let r=new this(t).withFlag(...e.flags||[]);return r.select(...e.select_list),e.from_list?.length&&r.from(...e.from_list),e.join_list?.length&&r.join(...e.join_list),e.where_clause&&r.where(e.where_clause),e.group_by_clause&&r.groupBy(e.group_by_clause),e.having_clause&&r.having(e.having_clause),e.window_clause&&r.window(e.window_clause),e.order_by_clause&&r.orderBy(e.order_by_clause),e.offset_clause&&r.offset(e.offset_clause),e.limit_clause&&r.limit(e.limit_clause),e.union_clause&&r.union(e.union_clause),r}stringify(t={}){let e=["SELECT"];return this.FLAGS.length&&e.push(this.FLAGS.map(r=>r.replace(/_/g," "))),e.push(this.SELECT_LIST.join(", ")),this.FROM_LIST.length&&e.push("FROM",this.FROM_LIST.join(", ")),this.JOIN_LIST.length&&e.push(...this.JOIN_LIST),this.WHERE_CLAUSE&&e.push("WHERE",this.WHERE_CLAUSE),this.GROUP_BY_CLAUSE&&e.push(this.GROUP_BY_CLAUSE),this.HAVING_CLAUSE&&e.push("HAVING",this.HAVING_CLAUSE),this.WINDOW_CLAUSE&&e.push(this.WINDOW_CLAUSE),this.ORDER_BY_CLAUSE&&e.push(this.ORDER_BY_CLAUSE),this.OFFSET_CLAUSE&&e.push("OFFSET",this.OFFSET_CLAUSE),this.LIMIT_CLAUSE&&e.push("LIMIT",(Array.isArray(this.LIMIT_CLAUSE)?this.LIMIT_CLAUSE:[this.LIMIT_CLAUSE]).join(",")),this.UNION_CLAUSE&&e.push("UNION",this.UNION_CLAUSE),e.join(" ")}static parse(t,e,r){let[i,s,n,f]=/^SELECT\s+(?:(WITH\s+UAC)\s+)?(ALL|DISTINCT)?([\s\S]+)$/i.exec(e.trim())||[];if(!i)return;let o=new this(t);s&&o.withFlag("WITH_UAC"),n&&o.withFlag(n);let c=this.mySubstitutePlaceholders(o,f.trim()),h={from:{backtest:"^(?!.*\\s+DISTINCT\\s+$)",test:"FROM"},join:U,where:"WHERE",groupBy:jt,having:"HAVING",window:Zt,orderBy:v,offset:"OFFSET",limit:"LIMIT",union:"UNION"},{tokens:[l,...m],matches:E}=p.lex(c,Object.values(h).map(A=>typeof A=="string"||A.test?A:A.regex),{useRegex:"i"});for(let A of p.split(l,[","])){let N=r(o,A.trim(),[k]);o.select(N)}for(let A of E){let N=A.replace(/\s+/g,""),S=Object.keys(h).find(d=>new RegExp(d,"i").test(N));if(S==="from")for(let d of p.split(m.shift(),[","])){let R=r(o,d.trim(),[J]);o.from(R)}else if(["where","having"].includes(S)){let d=r(o,m.shift().trim(),[$,B]);o[S](d)}else if(S==="UNION"){let d=r(o,m.shift().trim(),[this]);o[S](d)}else if(["offset","limit"].includes(S)){let d=m.shift().split(",").map(R=>parseInt(R.trim()));o[S](...d)}else{let d=r(o,`${A} ${m.shift().trim()}`,[h[S]]);o[S](d)}}return o}$trace(t,...e){if(t==="get:TABLE_NODE")return this.FROM_LIST[0];if(["event:CONNECTED","event:DISCONNECTED"].includes(t)){let r;e[0]instanceof pt&&(r=this.AGGRS),e[0]instanceof it&&!(e[0].CONTEXT instanceof it)&&(r=this.PATHS),e[0]instanceof Bt&&(r=this.VARS),e[0]instanceof u&&(r=this.SUBQUERIES),t==="event:DISCONNECTED"&&r?r.splice(r.indexOf(e[0]),1):t==="event:CONNECTED"&&r&&r.push(e[0])}return super.$trace(t,...e)}};var Q=class extends _{EXPR;expr(...t){return arguments.length?(this.build("EXPR",t,[W,...C.Types]),this):this.EXPR}query(...t){return arguments.length?(this.build("EXPR",t,W),this):this.EXPR instanceof W?this.EXPR:null}toJSON(){return{expr:this.EXPR?.toJSON(),flags:this.FLAGS.slice()}}static fromJSON(t,e){if(!e?.expr||Object.keys(e).length!==(e.flags?2:1))return;let r=new this(t).withFlag(...e.flags||[]);return r.expr(e.expr),r}stringify(){return"("+this.EXPR.stringify()+")"}static parse(t,e,r){if(!(!M(e,"(",")")||p.match(e,[" "]).length&&p.split(e,[]).length===2))return new this(t).expr(r(t,b(e,"(",")"),[W,...C.Types]))}};var $=class u extends _{LOGIC="";ASSERTIONS=[];constructor(t,e){super(t),this.LOGIC=e}and(...t){return this.LOGIC==="OR"?new this.constructor(this).and(this,...t):(this.LOGIC="AND",this.build("ASSERTIONS",t,[u,B,Q]),this)}or(...t){return this.LOGIC==="AND"?new this.constructor(this).or(this,...t):(this.LOGIC="OR",this.build("ASSERTIONS",t,[u,B,Q]),this)}toJSON(){return{logic:this.LOGIC,assertions:this.ASSERTIONS.map(t=>t.toJSON()),flags:this.FLAGS}}static fromJSON(t,e){if(typeof e?.logic!="string"||!/AND|OR/i.test(e.logic)||!Array.isArray(e.assertions))return;let r=new this(t).withFlag(...e.flags||[]);return r[e.logic.toLowerCase()](...e.assertions),r}stringify(){return this.ASSERTIONS.map(t=>t instanceof u?`(${t.stringify()})`:t.stringify()).join(" "+this.LOGIC+" ")}static parse(t,e,r){for(let i of["AND","OR"]){let s=p.split(e,[`\\s+${i}\\s+`],{useRegex:"i"});if(s.length>1){let n=new this(t,i);for(let f of s)n[i.toLowerCase()](r(n,f));return n}}}};var ue=class extends _{OPERAND=null;TYPE="";SYNTAX2=!1;cast(t,e,r=!1){return this.TYPE=e,this.SYNTAX2=r,this.build("OPERAND",[t],C.Types)}toJSON(){return{operand:this.OPERAND?.toJSON(),type:this.TYPE,syntax2:this.SYNTAX2,flags:this.FLAGS}}static fromJSON(t,e){if(!e?.operand||!e?.type)return;let r=new this(t).withFlag(...e.flags||[]);return r.cast(e.operand,e.type,e.syntax2),r}stringify(){return this.SYNTAX2?`${this.OPERAND}::${this.TYPE}`:`CAST(${this.OPERAND} AS ${this.TYPE})`}static parse(t,e,r){let i,s,n=!1;if(/^CAST(?:\s+)?\([\s\S]+\)$/i.test(e)){let[,o]=p.split(e,[]);[i,s]=p.split(o.slice(1,-1),["AS"],{useRegex:"i"})}else{if((t?.params?.inputDialect||t?.params?.dialect)==="mysql"||([i,s]=p.split(e,["::"]),!s))return;n=!0}let f=new this(t);return f.cast(r(f,i.trim()),s.trim(),n),f}};var fe=class extends _{OPERATOR="";OPERANDS=[];constructor(t,e,...r){super(t),this.OPERATOR=e,this.OPERANDS=r}calc(t,...e){return this.OPERATOR&&this.OPERATOR!==t?new this.constructor(this).calc(t,this,...e):(this.OPERATOR=t,this.build("OPERANDS",e,C.Types),this)}sum(...t){return this.calc("+",...t)}sub(...t){return this.calc("-",...t)}div(...t){return this.calc("/",...t)}times(...t){return this.calc("*",...t)}toJSON(){return{operator:this.OPERATOR,operands:this.OPERANDS.map(t=>t.toJSON()),flags:this.FLAGS}}static fromJSON(t,e){if(typeof e?.operator!="string"||!/\+|\-|\*|\//.test(e.operator)||!Array.isArray(e.operands))return;let r=new this(t).withFlag(...e.flags||[]);return r.calc(e.operator,...e.operands),r}stringify(){return this.OPERANDS.join(` ${this.OPERATOR} `)}static parse(t,e,r){for(let i of["\\*","\\/","\\+","\\-"]){let{tokens:s,matches:n}=p.lex(e,[`(\\s+)?${i}(\\s+)?`],{useRegex:"i"});if(!(s.filter(f=>f.trim()).length<2))return new this(t,n.pop().trim(),...s.map(f=>r(t,f.trim())))}}};var ce=class extends _{STRINGS=[];join(...t){return this.build("STRINGS",t,C.Types)}toJSON(){return{strings:this.STRINGS.map(t=>t.toJSON()),flags:this.FLAGS}}static fromJSON(t,e){if(!Array.isArray(e?.strings))return;let r=new this(t).withFlag(...e.flags||[]);return r.join(...e.strings),r}stringify(){return this.STRINGS.join(" || ")}static parse(t,e,r){if((t?.params?.inputDialect||t?.params?.dialect)==="mysql")return;let i=p.split(e,["||"]);if(i.length<2)return;let s=new this(t);return s.join(...i.map(n=>r(s,n.trim()))),s}};var C=class{static cast(t,e,r=this.Types){if(typeof e=="function"){if(r.length===1){let n=new r[0](t);return e(n),n}let i,s=n=>(...f)=>{let o=r.reduce((c,h)=>c||(h.factoryMethods?typeof h.factoryMethods[n]=="function"&&h.factoryMethods[n](t,...f):typeof h.prototype[n]=="function"&&new h(t)),null);if(!o)throw new Error(`Unknown method: ${n}()`);if(i=o,o[n])return o[n](...f);for(let c of f)c(o)};return e(new Proxy({},{get:(n,f)=>s(f)})),i}return this.fromJSON(t,e,r)}static fromJSON(t,e,r=this.Types){let i=r.find(s=>e instanceof s)?e:r.reduce((s,n)=>s||n.fromJSON(t,e),null);if(!i)throw new Error("");return i}static parse(t,e,r){return r(t,e,this.Types)}static get Types(){return[Q,Ft,ce,$,it,at,B,fe,ue,pt,At,mt,Ct,rt,Bt,T,et]}};var ot=class extends xe(_){static Types=C.Types};var De=u=>class extends u{get dimensional(){return!1}async resolveDimensions(t=!1){if(!t)return await this.clone().resolveDimensions(!0);let e=this.constructor.name==="UpdateStatement"?"update":this.onConflict()?"upsert":"insert",r=await this.client.structure({depth:2,inSearchPathOrder:!0}),i=this.$trace("get:TABLE_NAME"),s=this.$trace("get:DATABASE_NAME")||r.findPath(i,!0),n=r.database(s).table(i),f=_r(n),o=Object.fromEntries(n.COLUMNS.map(N=>[N.name(),N])),c={dependencies:new Map,dependents:new Map},h=(N,S,d)=>{if(o[S]?.foreignKey()&&[et].some(R=>d instanceof R)&&g(d.INPUT)){let R=o[S].foreignKey(),x=R.targetTable(),O=R.targetColumns()[0];c.dependencies.has(x)||c.dependencies.set(x,new Map),c.dependencies.get(x).set([N,S,O],d);return}if(S.includes(":")&&!o[S]&&[et].some(R=>d instanceof R)&&Array.isArray(d.INPUT)){let[R,x]=[ne(S,":"),Ke(S,":")];return c.dependents.has(R)||c.dependents.set(R,new Map),c.dependents.get(R).set([N,f,x],d),!0}if(!o[S]){let R=T.fromJSON(this,[s,i]);throw new Error(`Unknown column name ${R}."${S}"`)}};this.set()?this.set().filterInplace((N,S,d)=>{if(N instanceof st)return S instanceof ot?S.filterInplace((x,O)=>{let I=N.getEntry(O).name().toLowerCase(),w=h(0,I,x);return w&&N.removeEntry(O),!w}).length:!0;let R=N.name().toLowerCase();return!h(0,R,S)}):this.columns?.()&&this.values().length&&this.values().forEach((N,S)=>N.filterInplace((d,R)=>{let x=this.columns().getEntry(R).name().toLowerCase(),O=h(S,x,d);return O&&this.columns().removeEntry(R),!O}));let l=async()=>{for(let[N,S]of c.dependencies){let d=[...S.keys()],R=[...S.values()],x=await this.client.database(s).table(N)[e](R.map(O=>O.INPUT),{experimentalRecursive:!0,returning:d[0][2]});d.forEach(([,,O],I)=>{let w=(D=>typeof D=="number"?D:rt.fromJSON(this,D))(x[I][O]);R[I].literal(w)})}},m=this.returning().slice(),E=N=>m.find(S=>[N,"*"].includes(S.expr().name?.())),A=async N=>{for(let[S,d]of c.dependents){let R=[...d.keys()],x=[...d.values()],O=[],I;R.forEach(([D,y,Qe],ze)=>{x[ze].INPUT.forEach(ye=>O.push({...ye,[Qe]:N[D][y]}));let Ze=`${S}:${Qe}`;if(E(Ze)){I=!0;let ye=x[ze].INPUT.length,je=O.length-ye;N[D][Ze]=hr=>hr.slice(je,je+ye)}});let w=await this.client.database(s).table(S)[e](O,{experimentalRecursive:!0,returning:I&&"*"});I&&N.forEach(D=>Object.keys(D).forEach(y=>{typeof D[y]=="function"&&(D[y]=D[y](w))}))}return m.length?(E(f)||(N=N.map(S=>{let{[f]:d,...R}=S;return R})),N):N.length};return c.dependents.size&&!E(f)&&this.RETURNING_LIST.push(T.fromJSON(this,f)),[this,l,A]}$trace(t,...e){return["event:CONNECTED","event:DISCONNECTED"].includes(t),super.$trace(t,...e)}},_r=u=>{let t=u.primaryKey()?.columns()[0];if(!t)throw new Error("Cannot resolve primary key name for implied record.");return t};var ut=class extends _{ENTRIES=[];get length(){return this.ENTRIES.length}set(t,e){return Array.isArray(t)?(t=st.fromJSON(this,t),Array.isArray(e)?e=ot.fromJSON(this,e):e=C.cast(this,e)):(t=t instanceof _?t:T.fromJSON(this,t),e=e instanceof _?e:C.cast(this,e)),this.ENTRIES.push([t,e]),this}entries(...t){if(!arguments.length)return this.ENTRIES;for(let[e,r]of t)this.set(e,r);return this}getEntry(t){return typeof t=="number"?this.ENTRIES[t]:this.ENTRIES.find(([e])=>e instanceof T&&e.name().toLowerCase()===t.toLowerCase())}removeEntry(t){let e=this.getEntry(t);return e&&(this.ENTRIES=this.ENTRIES.filter(r=>r!==e)),e&&e.forEach(r=>r.$trace?.("event:DISCONNECTED",r)),e}filterInplace(t){return this.ENTRIES=this.ENTRIES.filter((e,r)=>{let i=t(e[0],e[1],r);return i||e.forEach(s=>s.$trace?.("event:DISCONNECTED",s)),i})}toJSON(){return{entries:this.ENTRIES.map(([t,e])=>[t.toJSON(),e.toJSON()])}}static fromJSON(t,e){if(!Array.isArray(e?.entries))return;let r=new this(t);for(let[i,s]of e.entries)r.set(i,s);return r}stringify(){return`
	${this.ENTRIES.map(([t,e])=>`${t} = ${e}`).join(`,
	`)}`}static parse(t,e,r){let i=new this(t);for(let s of p.split(e,[","])){let[n,f]=p.split(s,["="]).map(o=>o.trim()).filter(o=>o);if(!f)return;if(M(n,"(",")")){let o=r(i,f.trim(),[st]);if(!M(f,"(",")"))return;let c=/^\((\s+)?SELECT\s+/i.test(f)?r(i,f.trim()):r(i,f.trim(),[ot]);i.set(o,c)}else{let o=r(i,n),c=r(i,f);i.set(o,c)}}return i}};var te=class extends ut{WHERE_CLAUSE=null;CONFLICT_TARGET=[];target(...t){return arguments.length?(this.build("CONFLICT_TARGET",t,T),this):this.CONFLICT_TARGET}where(...t){return arguments.length?(this.build("WHERE_CLAUSE",t,$,"and"),this):this.WHERE_CLAUSE}toJSON(){return{...super.toJSON(),conflict_target:this.CONFLICT_TARGET.map(t=>t.toJSON()),where_clause:this.WHERE_CLAUSE?.toJSON()}}static fromJSON(t,e){let r=super.fromJSON(t,e);if(r)return e.conflict_target&&r.target(...[].concat(e.conflict_target)),e.where_clause&&r.where(e.where_clause),r}stringify(){let t=[];return this.params.dialect==="mysql"?t.push("ON DUPLICATE KEY UPDATE"):t.push(`ON CONFLICT ${this.CONFLICT_TARGET.length?`(${this.CONFLICT_TARGET.join(", ")})`:""} ${this.ENTRIES.length?"DO UPDATE SET":"DO NOTHING"}`),t.push(super.stringify()),this.WHERE_CLAUSE&&t.push("WHERE",this.WHERE_CLAUSE),t.join(" ")}static parse(t,e,r){let[i,s,n,f]=e.match(new RegExp(`^${this.regex}([\\s\\S]*)$`,"i"))||[];if(!i)return;if(/DO\s+NOTHING/i.test(n))return new this(t);let[o,c]=p.split(f,["WHERE"],{ci:!0}),h=super.parse(t,o,r);if(s){let l=p.split(M(s,"(",")")?b(s,"(",")"):s,[","]).map(m=>r(h,m.trim(),[T]));h.target(...l)}return c&&h.where(r(h,c.trim(),[$,B])),h}static regex="ON\\s+(?:DUPLICATE\\s+KEY|CONFLICT(?:\\s+([\\s\\S]+))?)\\s+(UPDATE|DO\\s+NOTHING|DO\\s+UPDATE\\s+SET\\s+)"};var z=class extends De(nt){TABLE=null;COLUMNS_CLAUSE=null;VALUES_LIST=[];SET_CLAUSE=null;SELECT_CLAUSE=null;ON_CONFLICT_CLAUSE=null;RETURNING_LIST=[];into(t){return this.build("TABLE",[t],J)}columns(...t){return arguments.length?this.build("COLUMNS_CLAUSE",t,st,"entries"):this.COLUMNS_CLAUSE}values(...t){return arguments.length?this.build("VALUES_LIST",t,ot,"entries"):this.VALUES_LIST}set(...t){return arguments.length?this.build("SET_CLAUSE",t,ut,"set"):this.SET_CLAUSE}select(t){return arguments.length?this.build("SELECT_CLAUSE",[t],W):this.SELECT_CLAUSE}onConflict(...t){return arguments.length?this.build("ON_CONFLICT_CLAUSE",t,te,"entries"):this.ON_CONFLICT_CLAUSE}returning(...t){return arguments.length?this.build("RETURNING_LIST",t,k):this.RETURNING_LIST}toJSON(){return{table:this.TABLE.toJSON(),columns_clause:this.COLUMNS_CLAUSE?.toJSON(),values_list:this.VALUES_LIST.map(t=>t.toJSON()),set_clause:this.SET_CLAUSE?.toJSON(),select_clause:this.SELECT_CLAUSE?.toJSON(),on_conflict_clause:this.ON_CONFLICT_CLAUSE?.toJSON(),returning_list:this.RETURNING_LIST.slice(0),flags:this.FLAGS}}static fromJSON(t,e){if(!e?.table)return;let r=new this(t).withFlag(...e.flags||[]);r.into(e.table),e.columns_clause&&r.columns(e.columns_clause);for(let i of e.values_list||[])r.values(...i.entries);return e.set_clause&&r.set(e.set_clause),e.select_clause&&r.select(e.select_clause),e.on_conflict_clause&&r.onConflict(e.on_conflict_clause),e.returning_list?.length&&r.returning(...e.returning_list),r}stringify(){let t=["INSERT"];return this.FLAGS.length&&t.push(this.FLAGS.map(e=>e.replace(/_/g," "))),t.push("INTO",this.TABLE),this.SET_CLAUSE?t.push("SET",this.SET_CLAUSE):(this.COLUMNS_CLAUSE&&t.push(this.COLUMNS_CLAUSE),this.SELECT_CLAUSE?t.push(this.SELECT_CLAUSE):t.push("VALUES",this.VALUES_LIST.join(", "))),this.ON_CONFLICT_CLAUSE&&t.push(this.ON_CONFLICT_CLAUSE),this.RETURNING_LIST.length&&t.push("RETURNING",this.RETURNING_LIST.join(", ")),t.join(" ")}static parse(t,e,r){let[i,s,n,f]=/^INSERT(\s+WITH\s+UAC)?(?:\s+(IGNORE))?(?:\s+INTO)?([\s\S]+)$/i.exec(e.trim())||[];if(!i)return;let o=new this(t);s&&o.withFlag("WITH_UAC"),n&&o.withFlag(n);let c=this.mySubstitutePlaceholders(t,f.trim()),h={payload:"(VALUES|VALUE|SET|SELECT)",onConflict:"ON\\s+(DUPLICATE\\s+KEY|CONFLICT)",returning:"RETURNING"},{tokens:[l,...m],matches:E}=p.lex(c,Object.values(h).map(A=>A),{useRegex:"i"});for(let A of E){let N=A.replace(/\s+/g,""),S=Object.keys(h).find(d=>new RegExp(h[d],"i").test(N));if(S==="payload")if(/^SET$/i.test(N))o.into(r(o,l,[J])),o.set(r(o,m.shift().trim(),[ut]));else{let d=p.split(l,[]);if(o.into(r(o,d.shift().trim(),[J])),d.length&&o.columns(r(o,d.shift().trim(),[st])),/^SELECT$/i.test(N))o.select(r(o,`SELECT ${m.shift()}`));else for(let R of p.split(m.shift(),[","]))o.values(r(o,R.trim(),[ot]))}else S==="onConflict"?o.onConflict(r(o,`${N} ${m.shift().trim()}`,[te])):S==="returning"&&o.returning(...p.split(m.shift(),[","]).map(d=>r(o,d.trim(),[k])))}return o}$trace(t,...e){return t==="get:TABLE_NODE"?this.TABLE:super.$trace(t,...e)}};var ft=class extends De(nt){TABLE_LIST=[];JOIN_LIST=[];SET_CLAUSE=null;WHERE_CLAUSE=null;ORDER_BY_CLAUSE=null;LIMIT_CLAUSE=null;RETURNING_LIST=[];table(...t){return this.build("TABLE_LIST",t,J)}join(t){return this.build("JOIN_LIST",[t],U,"full")}leftJoin(t){return this.build("JOIN_LIST",[t],U,"left")}rightJoin(t){return this.build("JOIN_LIST",[t],U,"right")}innerJoin(t){return this.build("JOIN_LIST",[t],U,"inner")}crossJoin(t){return this.build("JOIN_LIST",[t],U,"cross")}set(...t){return arguments.length?this.build("SET_CLAUSE",t,ut,"set"):this.SET_CLAUSE}where(...t){return arguments.length?this.build("WHERE_CLAUSE",t,$,"and"):this.WHERE_CLAUSE}orderBy(...t){return arguments.length?(this.build("ORDER_BY_CLAUSE",t,v,"criterion"),this.ORDER_BY_CLAUSE):this.ORDER_BY_CLAUSE}limit(...t){if(!arguments.length)return this.LIMIT_CLAUSE;if(!t.every(e=>typeof e=="number"))throw new Error("Limits must be of type number.");this.LIMIT_CLAUSE=t}returning(...t){return arguments.length?this.build("RETURNING_LIST",t,k):this.RETURNING_LIST}toJSON(){return{table_list:this.TABLE_LIST.map(t=>t.toJSON()),join_list:this.JOIN_LIST.map(t=>t.toJSON()),set_clause:this.SET_CLAUSE?.toJSON(),where_clause:this.WHERE_CLAUSE?.toJSON(),order_by_clause:this.ORDER_BY_CLAUSE?.toJSON(),limit_clause:this.LIMIT_CLAUSE,returning_list:this.RETURNING_LIST,flags:this.FLAGS}}static fromJSON(t,e){if(!Array.isArray(e?.table_list))return;let r=new this(t).withFlag(...e.flags||[]);return r.table(...e.table_list),e.join_list?.length&&r.join(...e.join_list),e.set_clause&&r.set(e.set_clause),e.where_clause&&r.where(e.where_clause),e.order_by_clause&&r.orderBy(e.order_by_clause),e.limit_clause&&r.limit(e.limit_clause),e.returning_list?.length&&r.returning(...e.returning_list),r}stringify(){let t=["UPDATE"];return this.FLAGS.length&&t.push(this.FLAGS.map(e=>e.replace(/_/g," "))),t.push(this.TABLE_LIST.join(", ")),this.JOIN_LIST.length&&t.push(...this.JOIN_LIST),t.push("SET",this.SET_CLAUSE),this.WHERE_CLAUSE&&t.push("WHERE",this.WHERE_CLAUSE),this.ORDER_BY_CLAUSE&&t.push(this.ORDER_BY_CLAUSE),this.LIMIT_CLAUSE&&t.push("LIMIT",this.LIMIT_CLAUSE),this.RETURNING_LIST.length&&t.push("RETURNING",this.RETURNING_LIST.join(", ")),t.join(" ")}static parse(t,e,r){let[i,s,n,f]=/^UPDATE(\s+WITH\s+UAC)?(?:\s+(IGNORE))?([\s\S]+)$/i.exec(e.trim())||[];if(!i)return;let o=new this(t);s&&o.withFlag("WITH_UAC"),n&&o.withFlag(n);let c=this.mySubstitutePlaceholders(o,f.trim()),h={join:U,set:"SET",where:"WHERE",orderBy:v,limit:"LIMIT",returning:"RETURNING"},{tokens:[l,...m],matches:E}=p.lex(c,Object.values(h).map(A=>typeof A=="string"||A.test?A:A.regex),{useRegex:"i"});for(let A of p.split(l,[","])){let N=r(o,A.trim(),[J]);o.table(N)}for(let A of E){let N=A.replace(/\s+/g,""),S=Object.keys(h).find(d=>new RegExp(d,"i").test(N));if(S==="set"){let d=r(o,m.shift().trim(),[ut]);o.set(d)}else if(S==="where"){let d=r(o,m.shift().trim(),[$,B]);o.where(d)}else if(S==="limit")o.limit(parseInt(m.shift().trim()));else if(S==="returning")o.returning(...p.split(m.shift(),[","]).map(d=>r(o,d.trim(),[k])));else{let d=r(o,`${A} ${m.shift().trim()}`,[h[S]]);o[S](d)}}return o}$trace(t,...e){return t==="get:TABLE_NODE"?this.TABLE_LIST[0]:super.$trace(t,...e)}};var Et=class extends nt{DELETE_LIST=[];FROM_LIST=[];USING_LIST=[];JOIN_LIST=[];WHERE_CLAUSE=null;ORDER_BY_CLAUSE=null;LIMIT_CLAUSE=null;RETURNING_LIST=[];$trace(t,...e){return t==="get:TABLE_NODE"?this.USING_LIST[0]||this.FROM_LIST[0]:super.$trace(t,...e)}delete(...t){return this.build("DELETE_LIST",t,T)}from(...t){return this.build("FROM_LIST",t,[T,J])}using(...t){return arguments.length?this.build("USING_LIST",t,J):this.USING_LIST}join(t){return this.build("JOIN_LIST",[t],U,"full")}leftJoin(t){return this.build("JOIN_LIST",[t],U,"left")}rightJoin(t){return this.build("JOIN_LIST",[t],U,"right")}innerJoin(t){return this.build("JOIN_LIST",[t],U,"inner")}crossJoin(t){return this.build("JOIN_LIST",[t],U,"cross")}where(...t){return arguments.length?this.build("WHERE_CLAUSE",t,$,"and"):this.WHERE_CLAUSE}orderBy(...t){return arguments.length?(this.build("ORDER_BY_CLAUSE",t,v,"criterion"),this.ORDER_BY_CLAUSE):this.ORDER_BY_CLAUSE}limit(...t){if(!arguments.length)return this.LIMIT_CLAUSE;if(!t.every(e=>typeof e=="number"))throw new Error("Limits must be of type number.");this.LIMIT_CLAUSE=t}returning(...t){return arguments.length?this.build("RETURNING_LIST",t,k):this.RETURNING_LIST}toJSON(){return{delete_list:this.DELETE_LIST.map(t=>t.toJSON()),from_list:this.FROM_LIST.map(t=>t.toJSON()),using_list:this.USING_LIST.map(t=>t.toJSON()),join_list:this.JOIN_LIST.map(t=>t.toJSON()),where_clause:this.WHERE_CLAUSE?.toJSON(),order_by_clause:this.ORDER_BY_CLAUSE?.toJSON(),limit_clause:this.LIMIT_CLAUSE,returning_list:this.RETURNING_LIST,flags:this.FLAGS}}static fromJSON(t,e){if(!Array.isArray(e?.from_list))return;let r=new this(t).withFlag(...e.flags||[]);return e.delete_list?.length&&r.delete(...e.delete_list),r.from(...e.from_list),e.using_list?.length&&r.using(...e.using_list),e.join_list?.length&&r.join(...e.join_list),e.where_clause&&r.where(e.where_clause),e.order_by_clause&&r.orderBy(e.order_by_clause),e.limit_clause&&r.limit(e.limit_clause),e.returning_list&&r.returning(...e.returning_list),r}stringify(){let t=["DELETE"];return this.FLAGS.length&&t.push(this.FLAGS.map(e=>e.replace(/_/g," "))),this.DELETE_LIST.length&&t.push(this.DELETE_LIST.join(", ")),t.push("FROM",this.FROM_LIST.join(", ")),this.USING_LIST.length&&t.push("USING",this.USING_LIST.join(", ")),this.JOIN_LIST.length&&t.push(...this.JOIN_LIST),this.WHERE_CLAUSE&&t.push("WHERE",this.WHERE_CLAUSE),this.ORDER_BY_CLAUSE&&t.push(this.ORDER_BY_CLAUSE),this.LIMIT_CLAUSE&&t.push("LIMIT",this.LIMIT_CLAUSE),this.RETURNING_LIST.length&&t.push("RETURNING",this.RETURNING_LIST.join(", ")),t.join(" ")}static parse(t,e,r){let[i,s,n,f]=/^DELETE(\s+WITH\s+UAC)?(?:\s+(IGNORE))?([\s\S]+)$/i.exec(e.trim())||[];if(!i)return;let o=new this(t);s&&o.withFlag("WITH_UAC"),n&&o.withFlag(n);let c=this.mySubstitutePlaceholders(o,f.trim()),h={from:{backtest:"^(?!.*\\s+DISTINCT\\s+$)",test:"FROM"},using:{backtest:"^(?!.*\\s+JOIN\\s+)",test:"USING"},join:U,where:"WHERE",orderBy:v,limit:"LIMIT",returning:"RETURNING"},{tokens:[l,...m],matches:E}=p.lex(c,Object.values(h).map(A=>typeof A=="string"||A.test?A:A.regex),{useRegex:"i"});for(let A of p.split(l,[","])){let N=r(o,A.trim(),[T]);o.delete(N)}for(let A of E){let N=A.replace(/\s+/g,""),S=Object.keys(h).find(d=>new RegExp(d,"i").test(N));if(["from","using"].includes(S))for(let d of p.split(m.shift(),[","])){let R=S==="from"&&E.some(O=>O.toLowerCase()==="using")?T:J,x=r(o,d.trim(),[R]);o[S](x)}else if(S==="where"){let d=r(o,m.shift().trim(),[$,B]);o.where(d)}else if(S==="limit")o.limit(parseInt(m.shift().trim()));else if(S==="returning")o.returning(...p.split(m.shift(),[","]).map(d=>r(o,d.trim(),[k])));else{let d=r(o,`${A} ${m.shift().trim()}`,[h[S]]);o[S](d)}}return o}};var wt=u=>class extends u{clone(){let t=super.clone();return t._ROOT_SCHEMA=this._ROOT_SCHEMA,t}$trace(t,...e){if(t==="get:STATEMENT_NODE")return this;if(t==="get:TABLE_NAME"&&this.KIND==="TABLE")return this.ident().name();if(t==="get:DATABASE_NAME"){if(["SCHEMA","DATABASE"].includes(this.KIND))return this.ident().name();if(this.KIND==="TABLE"&&this.ident().prefix())return this.ident().prefix()}return t==="get:ROOT_SCHEMA"?(this._ROOT_SCHEMA||(this._ROOT_SCHEMA=this.CONTEXT?.$trace?.(t)),this._ROOT_SCHEMA):this.CONTEXT?.$trace?.(t,...e)}};var X=class extends _{get CLAUSE(){return this.constructor.CLAUSE}KIND;constructor(t,e){super(t),this.KIND=e}toJSON(){return{clause:this.CLAUSE,...this.KIND?{kind:this.KIND}:{},...super.toJSON()}}static fromJSON(t,e){if(!(e?.clause&&e.clause!==this.CLAUSE||e?.kind&&!this.KINDS.includes(e.kind)))return new this(t,e.kind).withFlag(...e.flags||[])}static KINDS=[]};var $t=class extends X{IDENT;ARGUMENT;ident(t){return arguments.length?(this.build("IDENT",[t],T),this):this.IDENT}argument(t){return arguments.length?(this.build("ARGUMENT",[t],T),this):this.ARGUMENT}toJSON(){return{...this.IDENT?{ident:this.IDENT.toJSON()}:{},argument:this.ARGUMENT.toJSON(),...super.toJSON()}}static fromJSON(t,e){if(e?.kind&&!T.fromJSON(t,e.ident)||!T.fromJSON(t,e.argument))return;let r=super.fromJSON(t,e);if(r)return e.ident&&r.ident(e.ident),r.argument(e.argument),r}stringify(){return`${this.CLAUSE}${this.KIND?` ${this.KIND}`:""}${this.IDENT?` ${this.IDENT}`:""} TO ${this.ARGUMENT}`}static parse(t,e,r){let[i,s="",n]=new RegExp(`^${this.CLAUSE}\\s+(?:(${this.KINDS.map(h=>h).join("|")})\\s+)?([\\s\\S]+)`,"i").exec(e.trim())||[];if(!i)return;let f=new this(t,s.replace(/\s+/g,"_").toUpperCase()),[o,c]=p.split(n,["(TO|AS)"],{useRegex:!0,limit:1});return s&&f.ident(r(f,o,[T])),f.argument(r(f,c,[T])),f}static get CLAUSE(){return"RENAME"}static KINDS=["COLUMN","CONSTRAINT","INDEX","KEY"]};var q=class extends _{NAME;$NAME;KEEP;static get WRITABLE_PROPS(){return["NAME"]}static get SUBTREE_PROPS(){return[]}get WRITABLE_PROPS(){return this.constructor.WRITABLE_PROPS}get SUBTREE_PROPS(){return this.constructor.SUBTREE_PROPS}name(t){return arguments.length?(this[this.smartKey("NAME",!0)]=t,this):this[this.smartKey("NAME")]}diffWith(t){typeof t.keep()=="boolean"&&this.keep(t.keep()),this.isSame(t.name(),this.name(),"ci")||this.name(t.name())}smartKey(t,e=!1){if(this.keep()===!0)return e||Me(this[`$${t}`])?`$${t}`:t;if(this.keep()===!1){if(e)throw new Error(`Cannot alter ${this.constructor.name} after having been dropped.`);return t}return t}hardSet(...t){let e=t.pop();if(t.length){let s=t[0],n=()=>{if(this.keep()===!1)throw new Error(`Diffing cannot be done on a node ${this.constructor.name} after having been dropped.`);return typeof this.keep()!="boolean"&&this.keep(!0),e(s)};return typeof this.CONTEXT?.hardSet=="function"?this.CONTEXT.hardSet(s,n):Me(s)?n():void 0}let r=this.KEEP;this.KEEP=null;let i=e();return this.KEEP=r,i}keep(t,e=!1){if(!arguments.length)return this.KEEP;if(![void 0,!0,!1].includes(t))throw new Error(`Status can only be true, false, or undefined. Received: ${t}`);if(this.KEEP=t,e)for(let r of this.SUBTREE_PROPS.reduce((i,s)=>[...i,...this[s]],[]))t!==!0?r.keep(void 0,!0):r.keep(e==="auto"?r.keep():!0,e);return this}drop(){return this.keep(!1)}dropped(){return this.keep()===!1||this.CONTEXT?.dropped?.()}commitAlt(t=!1){this.keep(void 0);for(let e of this.WRITABLE_PROPS)Me(this[`$${e}`])&&(this[e]=this[`$${e}`],this[`$${e}`]=Array.isArray(this[`$${e}`])?[]:void 0);if(t)for(let e of this.SUBTREE_PROPS.reduce((r,i)=>[...r,...this[i]],[]))e.commitAlt(t)}reverseAlt(t=!1){if(this.keep()===!0){for(let e of this.WRITABLE_PROPS)if(Me(this[`$${e}`])){let r=this[e];this[e]=this[`$${e}`],this[`$${e}`]=r}}else this.keep()===!1?this.keep(void 0):typeof this.keep()!="boolean"&&this.keep(!1);if(t)for(let e of this.SUBTREE_PROPS.reduce((r,i)=>[...r,...this[i]],[]))e.reverseAlt(t)}isSame(t,e,r=null){if(typeof t=="string"&&typeof e=="string"&&r==="ci")return t.toLowerCase()===e.toLowerCase();if(t===e)return!0;if(Array.isArray(t)&&Array.isArray(e)&&t.length===e.length){let s=e.slice(0).sort();return t.slice(0).sort().every((n,f)=>this.isSame(n,s[f],r))}let i={};return typeof t=="object"&&t&&typeof e=="object"&&e&&(i.keys_a=Object.keys(t)).length===(i.keys_b=Object.keys(e)).length?i.keys_a.reduce((s,n)=>s&&this.isSame(t[n],e[n],r),!0):!1}toJSON(t={}){return{...this.NAME?{name:this.NAME}:{},...this.$NAME?{$name:this.$NAME}:{},...t,...typeof this.KEEP=="boolean"?{keep:this.KEEP}:{},...this.FLAGS.length?{flags:[...this.FLAGS]}:{}}}static fromJSON(t,e,r=null){if(e?.name&&typeof e.name!="string"||e.$name&&typeof e.$name!="string")return;let i=r?r():new this(t);return i.hardSet(()=>i.name(e.name)),i.hardSet(e.$name,s=>i.name(s)),typeof e.keep=="boolean"&&i.keep(e.keep),e.flags&&i.withFlag(...e.flags),i}},Me=u=>Array.isArray(u)?u.length:typeof u=="object"&&u?Object.keys(u).length:![void 0,null,""].includes(u);var F=class extends q{static get WRITABLE_PROPS(){return["TYPE"].concat(super.WRITABLE_PROPS)}static get TYPE(){return ae(this.name.replace(/TABLE|COLUMN|CONSTRAINT|CLAUSE/ig,""),"_").toUpperCase()}get TYPE(){return this.constructor.TYPE}toJSON(t={}){return super.toJSON({type:this.TYPE,...t})}static fromJSON(t,e,r=null){if(e?.type===this.TYPE)return super.fromJSON(t,e,r)}stringify(){return this.TYPE==="AUTO_INCREMENT"?this.TYPE:`${this.stringifyName()}${this.TYPE.replace("_"," ")}`}static parse(t,e){let{name:r,expr:i}=this.parseName(t,e,!0);if(!(!i||!new RegExp(`^${this.TYPE==="AUTO_INCREMENT"?this.TYPE:this.TYPE.replace("_","\\s+")}$`,"i").test(i)))return new this(t).name(r)}stringifyName(){return this.name()?`CONSTRAINT ${this.autoEsc(this.name())} `:""}static parseName(t,e,r=!1){let s=`(?:CONSTRAINT(?:\\s+(\\w+)|\\s+(${this.getEscChar(t,r)})((?:\\2\\2|[^\\2])+)\\2)\\s+)?`,[,n,,f,o=""]=e.match(new RegExp(`^${s}([\\s\\S]+)$`,"i"))||[];return{name:n||this.autoUnesc(t,f),expr:o.trim()}}};var Gt=class extends F{static get TYPE(){return"AUTO_INCREMENT"}stringify(){return this.params.dialect!=="mysql"?new dt(this.CONTEXT).stringify():"AUTO_INCREMENT"}};var dt=class extends F{ALWAYS;$ALWAYS;static get WRITABLE_PROPS(){return["ALWAYS"].concat(super.WRITABLE_PROPS)}always(t){return arguments.length?(this[this.smartKey("ALWAYS",!0)]=!!t,this):this[this.smartKey("ALWAYS")]}diffWith(t){return super.diffWith(t),t.always()!==this.always()&&this.always(t.always()),this}toJSON(){return super.toJSON({always:!!this.ALWAYS,...typeof this.$ALWAYS=="boolean"?{$always:this.$ALWAYS}:{}})}static fromJSON(t,e){return super.fromJSON(t,e,()=>{let r=new this(t).always(e.always);return r.hardSet(e.$always,i=>r.always(i)),r})}stringify(){return this.params.dialect==="mysql"?new Gt(this.CONTEXT).stringify():`GENERATED ${this.always()?"ALWAYS":"BY DEFAULT"} AS IDENTITY`}static parse(t,e){let{name:r,expr:i}=this.parseName(t,e,!0);if(!(!i||!(i=i.match(new RegExp("^GENERATED\\s+(ALWAYS|BY[ ]+DEFAULT)(?:\\s+AS\\s+IDENTITY)?$","i"))?.[1])))return new this(t).name(r).always(/^ALWAYS$/i.test(i))}};var P=class extends F{columns(){return"COLUMNS"in this?[]:[this.CONTEXT.name()]}toJSON(t={}){let e=super.toJSON(t);return!("name"in e)&&this.params.dialect!=="mysql"&&(e={name:void 0,...e}),e}static fromJSON(t,e,r=null){if(e?.type===this.TYPE)return!("name"in e)&&t?.params?.dialect!=="mysql"&&(e={name:`auto_name_${(0|Math.random()*9e6).toString(36)}`,...e}),super.fromJSON(t,e,r)}static parseColumns(t,e,r=!1){return p.split(b(e,"(",")"),[","]).map(i=>this.parseIdent(t,i.trim(),r)[0])}};var Ht=class extends P{};var ee=u=>class extends u{COLUMNS=[];$COLUMNS=[];static get WRITABLE_PROPS(){return["COLUMNS"].concat(super.WRITABLE_PROPS)}columns(t){return arguments.length?(this[this.smartKey("COLUMNS",!0)]=[].concat(t),this):this[this.smartKey("COLUMNS")]}diffWith(t){return super.diffWith(t),this.isSame(t.columns(),this.columns())||this.columns(t.columns()),this}toJSON(){return super.toJSON({columns:this.COLUMNS,...this.$COLUMNS.length?{$columns:this.$COLUMNS}:{}})}static fromJSON(t,e){if(e?.columns?.length)return super.fromJSON(t,e,()=>{let r=new this(t).columns(e.columns);return r.hardSet(e.$columns,i=>r.columns(i)),r})}stringify(){return this.TYPE==="FOREIGN_KEY"?super.stringify():`${super.stringify()} (${this.autoEsc(this.columns()).join(", ")})`}static parse(t,e,r){if(this.TYPE==="FOREIGN_KEY")return super.parse(t,e,r);let[i,s]=p.split(e,[]),n=super.parse(t,i.trim(),r);if(n)return n.columns(this.parseColumns(t,s))}};var Ut=class extends ee(Ht){};var Wt=class extends P{TARGET_SCHEMA;$TARGET_SCHEMA;TARGET_TABLE;$TARGET_TABLE;TARGET_COLUMNS=[];$TARGET_COLUMNS=[];MATCH_RULE;$MATCH_RULE;UPDATE_RULE;$UPDATE_RULE;DELETE_RULE;$DELETE_RULE;static get WRITABLE_PROPS(){return["TARGET_SCHEMA","TARGET_TABLE","TARGET_COLUMNS","MATCH_RULE","UPDATE_RULE","DELETE_RULE"].concat(super.WRITABLE_PROPS)}targetSchema(t){return arguments.length?(this[this.smartKey("TARGET_SCHEMA",!0)]=t,this):this[this.smartKey("TARGET_SCHEMA")]}targetTable(t){return arguments.length?(this[this.smartKey("TARGET_TABLE",!0)]=t,this):this[this.smartKey("TARGET_TABLE")]}targetColumns(t){return arguments.length?(this[this.smartKey("TARGET_COLUMNS",!0)]=[].concat(t),this):this[this.smartKey("TARGET_COLUMNS")]}matchRule(t){return arguments.length?(this[this.smartKey("MATCH_RULE",!0)]=t,this):this[this.smartKey("MATCH_RULE")]}updateRule(t){return arguments.length?(this[this.smartKey("UPDATE_RULE",!0)]=t,this):this[this.smartKey("UPDATE_RULE")]}deleteRule(t){return arguments.length?(this[this.smartKey("DELETE_RULE",!0)]=t,this):this[this.smartKey("DELETE_RULE")]}diffWith(t){return super.diffWith(t),this.isSame(t.targetSchema(),this.targetSchema(),"ci")||this.targetSchema(t.targetSchema()),this.isSame(t.targetTable(),this.targetTable(),"ci")||this.targetTable(t.targetTable()),this.isSame(t.targetColumns(),this.targetColumns())||this.targetColumns(t.targetColumns()),this.isSame(t.matchRule(),this.matchRule())||this.matchRule(t.matchRule()),this.isSame(t.updateRule(),this.updateRule())||this.updateRule(t.updateRule()),this.isSame(t.deleteRule(),this.deleteRule())||this.deleteRule(t.deleteRule()),this}toJSON(t={}){return super.toJSON({...t,...this.TARGET_SCHEMA?{targetSchema:this.TARGET_SCHEMA}:{},...this.$TARGET_SCHEMA?{$targetSchema:this.$TARGET_SCHEMA}:{},targetTable:this.TARGET_TABLE,...this.$TARGET_TABLE?{$targetTable:this.$TARGET_TABLE}:{},targetColumns:this.TARGET_COLUMNS,...this.$TARGET_COLUMNS.length?{$targetColumns:this.$TARGET_COLUMNS}:{},...this.MATCH_RULE?{matchRule:this.MATCH_RULE}:{},...this.$MATCH_RULE?{$matchRule:this.$MATCH_RULE}:{},...this.UPDATE_RULE?{updateRule:this.UPDATE_RULE}:{},...this.$UPDATE_RULE?{$updateRule:this.$UPDATE_RULE}:{},...this.DELETE_RULE?{deleteRule:this.DELETE_RULE}:{},...this.$DELETE_RULE?{$deleteRule:this.$DELETE_RULE}:{}})}static fromJSON(t,e,r=null){if(!(!e?.targetTable||!e.targetColumns?.length))return super.fromJSON(t,e,()=>{let i=r?r():new this(t);return i.hardSet(()=>i.targetSchema(e.targetSchema)),i.hardSet(()=>i.targetTable(e.targetTable)),i.hardSet(()=>i.targetColumns(e.targetColumns)),i.hardSet(()=>i.matchRule(e.matchRule)),i.hardSet(()=>i.updateRule(e.updateRule)),i.hardSet(()=>i.deleteRule(e.deleteRule)),i.hardSet(e.$targetSchema,s=>i.targetSchema(s)),i.hardSet(e.$targetTable,s=>i.targetTable(s)),i.hardSet(e.$targetColumns,s=>i.targetColumns(s)),i.hardSet(e.$matchRule,s=>i.matchRule(s)),i.hardSet(e.$updateRule,s=>i.updateRule(s)),i.hardSet(e.$deleteRule,s=>i.deleteRule(s)),i})}stringify(){let t=T.fromJSON(this,[this.targetSchema(),this.targetTable()]);t.prefix()||t.prefix(this.$trace("get:DATABASE_NAME"));let e=`${this.stringifyName()}REFERENCES ${t} (${this.autoEsc(this.targetColumns()).join(", ")})`,r=i=>typeof i=="object"&&i?`${i.rule} (${i.columns.join(", ")})`:i;return this.matchRule()&&(e+=` MATCH ${this.matchRule()}`),this.updateRule()&&(e+=` ON UPDATE ${r(this.updateRule())}`),this.deleteRule()&&(e+=` ON DELETE ${r(this.deleteRule())}`),e}static parse(t,e){let{name:r,expr:i}=this.parseName(t,e,!0);if(!i||!(i=i.match(/^REFERENCES\s+([\s\S]+)$/i)?.[1]))return;let[s,n,f=""]=p.split(i,[]),[o,c]=this.parseIdent(t,s.trim(),!0),h=p.split(b(n,"(",")"),[","]).map(m=>this.parseIdent(t,m.trim(),!0)[0]),l=(m,E)=>{if(E==="MATCH")return m.match(/MATCH\s+(\w+)/i)?.[1];let A=/(NO\s+ACTION|RESTRICT|CASCADE|(SET\s+NULL|SET\s+DEFAULT)(?:\s+\(([^\)]+)\))?)/,[,N,S,d]=m.match(new RegExp(`ON\\s+${E}\\s+${A.source}`,"i"))||[];return S?d?{rule:S,columns:d.split(",").map(R=>R.trim())}:S:N};return new this(t).name(r).targetSchema(c).targetTable(o).targetColumns(h).matchRule(l(f,"MATCH")).updateRule(l(f,"UPDATE")).deleteRule(l(f,"DELETE"))}};var St=class extends ee(Wt){stringify(){let t=this.stringifyName(),e=this.NAME,r=this.$NAME;this.NAME=null,this.$NAME=null;let i=`${t}FOREIGN KEY (${this.autoEsc(this.columns()).join(", ")}) ${super.stringify()}`;return this.NAME=e,this.$NAME=r,i}static parse(t,e,r){let{name:i="",expr:s}=this.parseName(t,e,!0);if(!s||!/^FOREIGN\s+KEY/i.test(s))return;let[,n,...f]=p.split(s,[]);return super.parse(t,f.join("").trim(),r).name(i).columns(this.parseColumns(t,n))}};var Kt=class extends P{stringify(){return`${this.stringifyName()}UNIQUE`}static parse(t,e){let{name:r,expr:i}=this.parseName(t,e,!0);if(!(!i||!/^UNIQUE(\s+KEY)?$/i.test(i)))return new this(t).name(r)}};var bt=class extends ee(Kt){};var xt=u=>class extends u{EXPR;static get WRITABLE_PROPS(){return["EXPR"].concat(super.WRITABLE_PROPS)}expr(t){return arguments.length?(this[this.smartKey("EXPR",!0)]=t,this):this[this.smartKey("EXPR")]}diffWith(t){return super.diffWith(t),t.expr()!==this.expr()&&this.expr(t.expr()),this}toJSON(){return super.toJSON({expr:this.EXPR})}static fromJSON(t,e){if(![void 0,null].includes(e?.expr))return super.fromJSON(t,e,()=>{let r=new this(t).expr(e.expr);return r.hardSet(e.$expr,i=>r.expr(i)),r})}stringify(){return`${super.stringify()} (${this.expr()})`}static parse(t,e){let{name:r,expr:i}=this.parseName(t,e,!0);return!i||!(i=i.match(new RegExp(`^${this.TYPE.replace(/_/g,"\\s+")}\\s+([\\s\\S]+)$`,"i"))?.[1])?void 0:new this(t).expr(M(i.trim(),"(",")")?b(i.trim(),"(",")"):i).name(r)}};var Nt=class extends xt(P){};var he=class extends xt(F){STORED;$STORED;static get WRITABLE_PROPS(){return["STORED"].concat(super.WRITABLE_PROPS)}stored(t){return arguments.length?(this[this.smartKey("STORED",!0)]=!!t,this):this[this.smartKey("STORED")]}diffWith(t){return super.diffWith(t),t.stored()!==this.stored()&&this.stored(t.stored()),this}toJSON(){return super.toJSON({stored:!!this.STORED,...typeof this.$STORED=="boolean"?{$stored:this.$STORED}:{}})}static fromJSON(t,e){return super.fromJSON(t,e,()=>{let r=new this(t).stored(e.stored);return r.hardSet(e.$stored,i=>r.stored(i)),r})}stringify(){return`GENERATED ALWAYS AS (${this.expr()})${this.stored()?" STORED":""}`}static parse(t,e){let r,{name:i,expr:s}=this.parseName(t,e,!0);if([,s,r=""]=s.match(new RegExp("^GENERATED\\s+ALWAYS\\s+AS\\s+\\(([\\s\\S]+)\\)(?:\\s+(VIRTUAL|STORED))?$","i"))||[],!!s)return new this(t).name(i).expr(s).stored(/^STORED$/i.test(r))}};var le=class extends xt(F){};var me=class extends F{};var pe=class extends xt(F){};var Ee=class extends F{};var V=class extends _{SPEC=[];constructor(t,e){super(t),this.SPEC=e}toJSON(){return this.SPEC.length===1?this.SPEC[0]:this.SPEC}static fromJSON(t,e){let r=[].concat(e);if(typeof r[0]!="string")return;let[i,s,n]=fr.call(this,r[0]);return i?new this(t,Ve(i,...s.split(","),...n,...r.slice(1))):new this(t,Ve(...[].concat(e)))}stringify(){let[t,e]=this.SPEC.slice(1).reduce(([r,i],s)=>/^\d+$/.test(s)?[r.concat(s),i]:[r,i.concat(s)],[[],[]]);return`${this.SPEC[0]}${t.length?`(${t.join(",")})`:""}${e.length?` ${e.join(" ")}`:""}`}static parse(t,e){let[r,i,s]=fr.call(this,e);if(r)return new this(t,Ve(r,...i.split(","),...s))}static pgFixedTypesRe=/^(bigint|int8|bigserial|serial8|boolean|bool|box|bytea|cidr|circle|date|double\s+precision|float8|inet|integer|int|int4|jsonb|json|line|lseg|macaddr8|macaddr|money|path|pg_lsn|pg_snapshot|point|polygon|real|float4|smallint|int2|smallserial|serial2|serial4|serial|text|timetz|timestamptz|tsquery|tsvector|txid_snapshot|uuid|xml)$/;static pgVariableTypesRe=/^(bit\s+varying|bit|varbit|character\s+varying|character|char|varchar|interval|numeric|timestamp|time)(?:\s+)?(?:\(([\d, ]+)\))?(\s+(?:with|without)\s+time\s+zone)?$/;static myFixedTypesRe=/^(tinyint|smallint|mediumint|enum|set|tinyblob|mediumblob|longblob|geometry|longstring|geometrycollection|multilinestring|multipoint|multipolygon)$/;static myVariableTypesRe=/^(float|decimal|double|tinytext|mediumtext|longtext|binary|varbinary|blob)(?:\s+)?(?:\(([\d, ]+)\))?$/};function fr(u){let t,e,r;for(let i of["pgFixedTypesRe","pgVariableTypesRe","myFixedTypesRe","myVariableTypesRe"])if([,t,e="",...r]=u.match(new RegExp(this[i].source,"i"))||[],t)break;return[t,e,r]}function Ve(...u){return u.map(t=>/^\d+$/.test(t)?parseFloat(t):t?.trim().replace(/\s+/," ").toUpperCase()).filter(t=>t)}var G=class extends q{TYPE;$TYPE;CONSTRAINTS=[];static get WRITABLE_PROPS(){return["TYPE"].concat(super.WRITABLE_PROPS)}static get SUBTREE_PROPS(){return["CONSTRAINTS"]}static CONSTRAINT_TYPES=[Gt,dt,he,le,me,Ee,pe,Ht,Wt,Kt,Nt];type(t){return arguments.length?(this.build(this.smartKey("TYPE",!0),[t],V),this):this[this.smartKey("TYPE")]}autoIncrement(...t){return this.constraint("AUTO_INCREMENT",...t)}identity(...t){return this.constraint("IDENTITY",...t)}expression(...t){return this.constraint("EXPRESSION",...t)}default(...t){return this.constraint("DEFAULT",...t)}notNull(...t){return this.constraint("NOT_NULL",...t)}null(...t){return this.constraint("NULL",...t)}onUpdate(...t){return this.constraint("ON_UPDATE",...t)}primaryKey(...t){return this.constraint("PRIMARY_KEY",...t)}foreignKey(...t){return this.constraint("FOREIGN_KEY",...t)}uniqueKey(...t){return this.constraint("UNIQUE_KEY",...t)}check(...t){return this.constraint("CHECK",...t)}constraint(t,...e){let r,i=s=>this.CONSTRAINTS.find(n=>n.TYPE===s);if(typeof t=="string"){if(r=i(t),e.length){if(e[0]===!1)return r?.keep(!1)}else return r;t={type:t,...typeof e[0]=="object"?e[0]:typeof e[0]=="string"?{expr:e[0]}:{}}}else t instanceof q||(r=i(t.type));if(r){let s=this.constructor.CONSTRAINT_TYPES.reduce((n,f)=>n||f.fromJSON(this,t));r.diffWith(s)}else this.build("CONSTRAINTS",[t],this.constructor.CONSTRAINT_TYPES);return this}diffWith(t){super.diffWith(t);let e=this.type().toJSON(),r=t.type().toJSON();this.isSame(e,r)||this.type(r);for(let i of["IDENTITY","EXPRESSION","NOT_NULL","NULL","DEFAULT","AUTO_INCREMENT","ON_UPDATE"]){let s=this.constraint(i),n=t.constraint(i);s&&(!n||n.dropped())?s.keep(!1):!s&&n&&!n.dropped()?this.constraint(n.toJSON()):s&&n&&s.diffWith(n)}return this}toJSON(){let t={type:this.TYPE.toJSON(),...this.$TYPE?{$type:this.$TYPE.toJSON()}:{}};for(let e of this.CONSTRAINTS){let{type:r,...i}=e.toJSON(),s=r==="FOREIGN_KEY"?"references":Xe(r.toLowerCase().replace("_"," ")),n=Object.keys(i),f=n.length===1?i[n[0]]:null,o=n.length?f===!1&&n[0]==="keep"?!1:n.length===1&&n[0]==="expr"?f:i:!0;t={...t,[s]:o}}return super.toJSON(t)}static fromJSON(t,e){let{type:r,$type:i,name:s,$name:n,keep:f,...o}=e;if(V.fromJSON({},r))return super.fromJSON(t,e,()=>{let c=new this(t);c.type(V.fromJSON(c,r)),c.hardSet(i,l=>c.type(V.fromJSON(c,l)));let h=Object.entries(o).reduce((l,[m,E])=>{if([void 0,null].includes(E))return l;if(!["boolean","number","string"].includes(typeof E)&&!(typeof E=="object"&&E))throw new Error(`Invalid value for constraint "${m}": ${E}`);let A={...E===!1?{keep:!1}:E===!0?{}:["number","string"].includes(typeof E)?{expr:E}:E};return m.startsWith("$")&&(A=Object.fromEntries(Object.entries(A).map(([N,S])=>[`$${N}`,S])),m=m.slice(1)),m==="references"&&(m="foreignKey"),m in l?Object.assign(l[m],A):l[m]=A,l},{});for(let l in h)c.constraint(ae(l,"_").toUpperCase(),h[l]);return c})}stringify(){let t=this.CONSTRAINTS;return this.params.dialect==="mysql"&&(t=t.filter(e=>e.TYPE!=="FOREIGN_KEY")),`${this.autoEsc(this.name())} ${this.type()}${t.length?` ${t.join(" ")}`:""}`}static parse(t,e,r){let[i,s]=p.split(e,["\\s+"],{useRegex:!0,limit:1}),[n]=this.parseIdent(t,i.trim(),!0)||[];if(!n)return;let f=new this(t).name(n),o="(CONSTRAINT\\s+.+?\\s+)?",c=[{test:`${o}(PRIMARY[ ]+KEY|NOT[ ]+NULL|GENERATED|REFERENCES|UNIQUE(?:[ ]+KEY)?|CHECK|AUTO_INCREMENT)`},{backtest:"^(?!.*\\s+(NOT|SET)\\s+$)",test:`${o}NULL`},{backtest:"^(?!.*\\s+BY\\s+$)",test:`${o}DEFAULT`},{backtest:"^(?!.*\\s+REFERENCES\\s+)",test:"ON\\s+UPDATE"}],[h,...l]=p.split(s,c,{useRegex:"i",preserveDelims:!0});f.type(r(f,h.trim(),[V]));for(let m of l){let E=r(f,m,this.CONSTRAINT_TYPES);f.build("CONSTRAINTS",[E],this.CONSTRAINT_TYPES)}return f}};var Z=class extends q{TYPE;$TYPE;COLUMNS=[];$COLUMNS=[];static get WRITABLE_PROPS(){return["TYPE","COLUMNS"].concat(super.WRITABLE_PROPS)}type(t){return arguments.length?(this[this.smartKey("TYPE",!0)]=t,this):this[this.smartKey("TYPE")]}columns(t){return arguments.length?(this[this.smartKey("COLUMNS",!0)]=[].concat(t),this):this[this.smartKey("COLUMNS")]}diffWith(t){return super.diffWith(t),this.isSame(this.type(),t.type())||this.type(t.type()),this.isSame(this.columns(),t.columns())||this.columns(t.columns()),this}toJSON(){return super.toJSON({type:this.TYPE,...this.$TYPE?{$type:this.$TYPE}:{},columns:this.COLUMNS,...this.$COLUMNS.length?{$columns:this.$COLUMNS}:{}})}static fromJSON(t,e){if(!(typeof e?.type!="string"||!/^(INDEX|KEY|FULLTEXT)$/i.test(e.type)||!e.columns?.length))return super.fromJSON(t,e,()=>{let r=new this(t).columns(e.columns).type(e.type);return r.hardSet(e.$columns,i=>r.columns(i)),r.hardSet(e.$type,i=>r.type(i)),r})}stringify(){return`${this.type()}${this.name()?` ${this.name()}`:""} (${this.columns().join(", ")})`}static parse(t,e){let[r,i,s]=/^((?:(?:FULLTEXT|SPATIAL)(?:\s+INDEX|\s+KEY)?)|(?:INDEX|KEY))([\s\S]+)$/i.exec(e)||[];if(!r)return;let[n,f]=p.split(s,[]),[o]=this.parseIdent(t,n.trim(),!0),c=p.split(b(f,"(",")"),[","]).map(h=>this.parseIdent(t,h.trim(),!0)[0]);return new this(t).type(i.replace(/\s+(INDEX|KEY)/i,"").toUpperCase()).columns(c).name(o)}};var _t=class extends X{ARGUMENT;argument(t=void 0){return arguments.length?(this.build("ARGUMENT",[t],this.constructor.NODE_TYPES),this):this.ARGUMENT}toJSON(){return{argument:this.ARGUMENT.toJSON(),...super.toJSON()}}static fromJSON(t,e){if(e?.argument)return super.fromJSON(t,e)?.argument(e.argument)}stringify(){let t=[`${this.CLAUSE}${this.KIND&&/^(COLUMN|TABLE|SCHEMA|DATABASE)$/i.test(this.KIND)?` ${this.KIND.replace(/_/g," ")}${this.hasFlag("IF_NOT_EXISTS")?" IF NOT EXISTS":""}`:""} ${this.argument()}`];return this.argument()instanceof G&&(this.hasFlag("AFTER")?t.push(this.getFlag("AFTER")?.replace(":"," ")):this.hasFlag("FIRST")&&t.push("FIRST"),this.params.dialect==="mysql"&&this.argument().foreignKey())?[t.join(" "),`ADD ${St.fromJSON(this,constraint.toJSON()).columns([this.argument().name()])}`].join(`;
`):t.join(" ")}static parse(t,e,r){let[i,s="",n,f]=new RegExp(`^${this.CLAUSE}\\s+(?:(${this.KINDS.map(c=>c.replace(/_/g,"\\s+")).join("|")})\\s+)?(IF\\s+NOT\\s+EXISTS\\s+)?([\\s\\S]+)$`,"i").exec(e.trim())||[];if(!i)return;let o=new this(t,s.replace(/\s+/g,"_").toUpperCase());if(n&&o.withFlag("IF_NOT_EXISTS"),!s||/^COLUMN$/i.test(s)){let[,c,h,l]=f.trim().match(/([\s\S]+)\s+(?:(FIRST)|AFTER\s+(.+))$/i)||[,f.trim()];h&&o.withFlag("FIRST"),l&&o.withFlag(`AFTER:${l}`),o.argument(r(o,c,[G]))}else/^TABLE|SCHEMA|DATABASE$/i.test(s)?o.argument(r(o,f,this.NODE_TYPES)):o.argument(r(o,`${s} ${f}`,this.NODE_TYPES));return o}static get CLAUSE(){return"ADD"}static NODE_TYPES=[dt,Ut,St,bt,Nt,Z,G];static KINDS=["COLUMN","CONSTRAINT","PRIMARY_KEY","FOREIGN_KEY","UNIQUE_KEY","CHECK","FULLTEXT_INDEX","SPATIAL_INDEX","INDEX","KEY"]};var gt=class extends X{IDENT;ident(t){return arguments.length?(this.build("IDENT",[t],T),this):this.IDENT}toJSON(){return{...this.IDENT?{ident:this.IDENT.toJSON()}:{},...super.toJSON()}}static fromJSON(t,e){if(!e?.kind&&!T.fromJSON(t,e?.ident))return;let r=super.fromJSON(t,e);return e.ident&&r?.ident(e.ident),r}stringify(){let t=this.getFlag("RESTRICT")||this.getFlag("CASCADE"),e=this.KIND?.replace(/_/g," "),r=this.IDENT;return["PRIMARY_KEY","FOREIGN_KEY","CHECK"].includes(this.KIND)&&(this.params.dialect==="mysql"?this.KIND==="PRIMARY_KEY"&&(r=null):e="CONSTRAINT"),`${this.CLAUSE}${e?` ${e}`:""}${this.hasFlag("IF_EXISTS")?" IF EXISTS":""}${r?` ${r}`:""}${t?` ${t}`:""}`}static parse(t,e,r){let[i,s,n,f,o,c]=new RegExp(`^${this.CLAUSE}(\\s+TEMPORARY)?(?:\\s+(${this.KINDS.map(l=>l.replace(/_/g,"\\s+")).join("|")}))?(\\s+IF\\s+EXISTS)?(?:\\s+([\\s\\S]+?)(?:\\s+(RESTRICT|CASCADE|FORCE))?)?$`,"i").exec(e.trim())||[];if(!i)return;let h=new this(t,n?.replace(/\s+/g,"_").toUpperCase());return o&&h.ident(r(t,o,[T])),s&&h.withFlag("TEMPORARY"),f&&h.withFlag("IF_EXISTS"),c&&h.withFlag(c),h}static get CLAUSE(){return"DROP"}static KINDS=["COLUMN","CONSTRAINT","PRIMARY_KEY","FOREIGN_KEY","UNIQUE_KEY","CHECK","INDEX","KEY","IDENTITY","EXPRESSION","DEFAULT","NOT_NULL","NULL","AUTO_INCREMENT","ON_UPDATE"]};var Ot=class extends X{ARGUMENT;argument(t=void 0){return arguments.length?(["DATA_TYPE","TYPE"].includes(this.KIND)?this.build("ARGUMENT",[t],V):this.KIND==="SCHEMA"?this.build("ARGUMENT",[t],T):this.ARGUMENT=t,this):this.ARGUMENT}toJSON(){return{argument:this.ARGUMENT?.toJSON?.()||this.ARGUMENT,...super.toJSON()}}static fromJSON(t,e){if(e?.kind)return super.fromJSON(t,e)?.argument(e.argument)}stringify(){return this.KIND==="IDENTITY"?`SET GENERATED ${/^ALWAYS$/i.test(this.ARGUMENT)?"AS ALWAYS":"BY DEFAULT"}`:`${this.CLAUSE} ${this.KIND.replace(/_/g," ")}${this.ARGUMENT?` ${this.ARGUMENT}`:""}`}static parse(t,e,r){let[i,s,n]=new RegExp(`^${this.CLAUSE}\\s+(${this.KINDS.map(c=>c==="IDENTITY"?"GENERATED":c.replace(/_/g,"\\s+")).join("|")})(?:\\s+([\\s\\S]+))?$`,"i").exec(e.trim())||[];if(!i)return;let f=/^GENERATED$/i.test(s),o=new this(t,f?"IDENTITY":s.replace(/\s+/g,"_").toUpperCase());return/^(DATA\s+)?TYPE$/i.test(s)?o.argument(r(o,n,[V])):/^SCHEMA$/i.test(s)?o.argument(r(o,n,[T])):o.argument(f?/^AS\s+ALWAYS$/i.test(n)?"always":!0:n),o}static get CLAUSE(){return"SET"}static KINDS=["SCHEMA","DATA_TYPE","TYPE","IDENTITY","DEFAULT","NOT_NULL","NULL","AUTO_INCREMENT","ON_UPDATE"]};var kt=class extends X{ARGUMENT;argument(t){return arguments.length?(this.build("ARGUMENT",[t],this.constructor.NODE_TYPES),this):this.ARGUMENT}toJSON(){return{argument:this.ARGUMENT.toJSON(),...super.toJSON()}}static fromJSON(t,e){if(!(!e?.kind||!e.argument))return super.fromJSON(t,e)?.argument(e.argument)}stringify(){let t=[`${this.CLAUSE} ${this.KIND} ${this.ARGUMENT}`];return this.hasFlag("AFTER")?t.push(this.getFlag("AFTER")?.replace(":"," ")):this.hasFlag("FIRST")&&t.push("FIRST"),t.join(" ")}static parse(t,e,r){let[i,s,n]=new RegExp(`^${this.CLAUSE}\\s+(${this.KINDS.map(o=>o).join("|")})\\s+([\\s\\S]+)$`,"i").exec(e.trim())||[];if(!i)return;let f=new this(t,s.toUpperCase());return this.handleArgumentExpr(f,n,r),f}static handleArgumentExpr(t,e,r){let{tokens:[i,s],matches:n}=p.lex(e,["FIRST","AFTER"],{useRegex:"i"});t.argument(r(t,i,this.NODE_TYPES)),s?t.withFlag(`AFTER:${s}`):n.length&&t.withFlag("FIRST")}static get CLAUSE(){return"MODIFY"}static NODE_TYPES=[G];static KINDS=["COLUMN"]};var Xt=class extends kt{IDENT;ident(t){return arguments.length?(this.build("IDENT",[t],T),this):this.IDENT}toJSON(){return{ident:this.IDENT.toJSON(),...super.toJSON()}}static fromJSON(t,e){if(T.fromJSON(t,e?.ident))return super.fromJSON(t,e)?.ident(e.ident)}stringify(){let t=[`${this.CLAUSE} ${this.KIND} ${this.IDENT} ${this.ARGUMENT}`];return this.hasFlag("AFTER")?t.push(this.getFlag("AFTER")?.replace(":"," ")):this.hasFlag("FIRST")&&t.push("FIRST"),t.join(" ")}static parse(t,e,r){let[i,s,n]=new RegExp(`^${this.CLAUSE}\\s+(${this.KINDS.map(h=>h).join("|")})\\s+([\\s\\S]+)$`,"i").exec(e.trim())||[];if(!i)return;let f=new this(t,s.toUpperCase()),[o,c]=p.split(n,["\\s+"],{useRegex:"i",limit:1});return f.ident(r(f,o,[T])),this.handleArgumentExpr(f,c,r),f}static get CLAUSE(){return"CHANGE"}};var Se=class extends Xt{add(t,e){return this.argument({clause:"ADD",kind:t,argument:e})}drop(t){return this.argument({clause:"DROP",kind:t})}set(t,e){return this.argument({clause:"SET",kind:t,argument:e})}static handleArgumentExpr(t,e,r){/^(DATA\+)?TYPE\s+/i.test(e)?t.argument(r(t,`SET ${e}`,[Ot])):t.argument(r(t,e,this.NODE_TYPES))}static get CLAUSE(){return"ALTER"}static NODE_TYPES=[_t,gt,Ot,et];static KINDS=["COLUMN","CONSTRAINT","INDEX"]};var j=class extends wt(X){IDENT;ACTIONS=[];SUBTREE=[];get length(){return this.ACTIONS.length+this.SUBTREE.length}ident(t){return arguments.length?(this.build("IDENT",[t],T),this):this.IDENT}action(...t){return arguments.length?(this.build("ACTIONS",t,this.constructor.NODE_TYPES),this):this.ACTIONS[this.ACTIONS.length-1]}create(t,e){return this.action({clause:"CREATE",kind:t,argument:e})}rename(t,e,r){return this.action({clause:"RENAME",kind:t,ident:e,argument:r})}modify(t,e){return this.action({clause:"MODIFY",kind:t,argument:e})}change(t,e,r){return this.action({clause:"CHANGE",kind:t,ident:e,argument:r})}alter(t,e,r){return this.action({clause:"ALTER",kind:t,ident:e,argument:r})}add(t,e){return this.action({clause:"ADD",kind:t,argument:e})}drop(t,e){return this.action({clause:"DROP",kind:t,ident:e})}set(t,e){return this.action({clause:"SET",kind:t,argument:e})}toJSON(){return{ident:this.IDENT.toJSON(),actions:this.ACTIONS.map(t=>t.toJSON()),...super.toJSON()}}static fromJSON(t,e){if(!e?.kind||!Array.isArray(e.actions)||!T.fromJSON(t,e?.ident))return;let r=super.fromJSON(t,e);return r?.ident(e.ident).action(...e.actions),r}stringify(){if(!this.length)return"";let t=c=>c.prefix()||["SCHEMA","DATABASE"].includes(this.KIND)?c:c.clone().prefix(this.$trace("get:DATABASE_NAME")),[e,r,i,s]=this.ACTIONS.reduce(([c,h,l,m],E)=>E instanceof $t?E.KIND?[c,h.concat(E),l,m]:[c,h,E,m]:E instanceof Ot&&E.KIND==="SCHEMA"?[c,h,l,E]:[c.concat(E),h,l,m],[[],[]]),n=c=>`${this.CLAUSE} ${this.KIND}${this.hasFlag("IF_EXISTS")?" IF EXISTS":""} ${c}`,f=[...this.SUBTREE],o=t(this.ident());e.length&&f.push(`${n(o)}
	${e.join(`,
	`)}`);for(let c of r.concat(i||[]))f.push(`${n(o)} ${c}`);return s&&f.push(`${n(i&&t(i.ARGUMENT)||o)} ${s}`),f.join(`;
`)}static parse(t,e,r){let[i,s,n]=new RegExp(`^${this.CLAUSE}\\s+(${this.KINDS.map(h=>h).join("|")})\\s+([\\s\\S]+)$`,"i").exec(e.trim())||[];if(!i)return;let f=new this(t,s.toUpperCase()),[o,c]=p.split(n,["\\s+"],{useRegex:"i",limit:1});return f.ident(r(f,o,[T])),f.action(...p.split(c,[","]).map(h=>r(f,h,this.NODE_TYPES))),f}static get CLAUSE(){return"ALTER"}static NODE_TYPES=[$t,Se,Xt,kt,_t,gt,Ot];static KINDS=["TABLE","SCHEMA","DATABASE"]};var K=class extends wt(gt){stringify(){let t=this.getFlag("RESTRICT")||this.getFlag("CASCADE"),e=this.ident();return!e.prefix()&&this.KIND==="TABLE"&&(e=e.clone().prefix(this.$trace("get:DATABASE_NAME"))),`${this.CLAUSE}${this.getFlag("TEMPORARY")?" TEMPORARY":""} ${this.KIND}${this.hasFlag("IF_EXISTS")?" IF EXISTS":""} ${e}${t?` ${t}`:""}`}static get CLAUSE(){return"DROP"}static KINDS=["TABLE","SCHEMA","DATABASE"]};var Vt=class extends q{PREFIX;$PREFIX;COLUMNS=[];CONSTRAINTS=[];INDEXES=[];NODES=new Set;static get WRITABLE_PROPS(){return["PREFIX"].concat(super.WRITABLE_PROPS)}static get SUBTREE_PROPS(){return["COLUMNS","CONSTRAINTS","INDEXES"]}static CONSTRAINT_TYPES=[Ut,St,bt,Nt];primaryKey(){return[...this.NODES].find(t=>t.TYPE==="PRIMARY_KEY")}foreignKeys(){return[...this.NODES].filter(t=>t.TYPE==="FOREIGN_KEY")}uniqueKeys(){return[...this.NODES].filter(t=>t.TYPE==="UNIQUE_KEY")}checks(){return[...this.NODES].filter(t=>t.TYPE==="CHECK")}prefix(t){return arguments.length?(this[this.smartKey("PREFIX",!0)]=t,this):this[this.smartKey("PREFIX")]}column(t){return typeof t=="string"?this.COLUMNS.find(e=>this.isSame(e.name(),t,"ci")):(this.build("COLUMNS",[t],G),this.COLUMNS[this.COLUMNS.length-1])}constraint(t){return typeof t=="string"?this.CONSTRAINTS.find(e=>this.isSame(e.name(),t,"ci")):(this.build("CONSTRAINTS",[t],this.constructor.CONSTRAINT_TYPES),this.CONSTRAINTS[this.CONSTRAINTS.length-1])}index(t){return typeof t=="string"?this.INDEXES.find(e=>this.isSame(e.name(),t,"ci")):(this.build("INDEXES",[t],Z),this.INDEXES[this.INDEXES-1])}diffWith(t){super.diffWith(t),this.isSame(t.prefix(),this.prefix(),"ci")||this.prefix(t.prefix());let e=(o,c)=>[...o.NODES].find(h=>this.isSame(h.NAME,c,"ci")),r=o=>[...o.NODES].reduce(([c,h],l)=>[G,P,Z].some(m=>l instanceof m)?l.NAME?[c.add(l.NAME),h]:[c,h.add(l)]:[c,h],[new Set,new Set]),[i]=r(this),[s,n]=r(t),f=o=>{if(o instanceof P)if(o.CONTEXT instanceof G){let c=o.CONTEXT.NAME;if(!i.has(c))return;e(this,c).constraint(o.toJSON())}else this.constraint(o.toJSON());else o instanceof Z?this.index(o.toJSON()):this.column(o.toJSON())};for(let o of new Set([...i,...s])){let c=e(this,o),h=e(t,o);i.has(o)&&!s.has(o)?c.keep(!1):i.has(o)?c.diffWith(h):f(h)}for(let o of n)f(o);return this}alterWith(t){let e=(r,i=!1)=>{let s=[...this.NODES].find(n=>(r.kind==="COLUMN"?n instanceof G:r.kind==="CONSTRAINT"?n instanceof P:n.TYPE===r.kind)&&(r.name?this.isSame(n.NAME,r.name,"ci"):r.kind==="PRIMARY_KEY"));if(!s&&!i)throw new Error(`${r.kind}${r.name?` "${r.name}"`:""} does not exist.`);return s};for(let r of t.ACTIONS)if(r.CLAUSE==="RENAME")r.KIND?e({kind:r.KIND,name:r.ident().name()}).name(r.argument().name()):(this.name(r.argument().name()),this.prefix(r.argument().prefix()));else if(r.CLAUSE==="SET")r.KIND==="SCHEMA"&&this.prefix(r.argument());else if(r.CLAUSE==="ADD")r.argument()instanceof P?r.argument().columns().length===1?e({kind:"COLUMN",name:r.argument().columns()[0]}).constraint(r.argument().toJSON()):this.constraint(r.argument().toJSON()):r.argument()instanceof Z?this.index(r.argument().toJSON()):(!r.hasFlag("IF_NOT_EXISTS")||!e({kind:"COLUMN",name:r.argument().name()},!0))&&this.column(r.argument().toJSON());else if(r.CLAUSE==="DROP")e({kind:r.KIND,name:r.ident().name()},r.hasFlag("IF_EXISTS"))?.keep(!1);else if(["CHANGE","MODIFY"].includes(r.CLAUSE))(r.CLAUSE==="CHANGE"?e({kind:"COLUMN",name:r.ident().name()}):e({kind:"COLUMN",name:r.argument().name()})).diffWith(r.argument());else if(r.CLAUSE==="ALTER"){let i=e({kind:r.KIND,name:r.ident().name()},r.hasFlag("IF_EXISTS"));if(!i)continue;let s=r.argument();if(s.CLAUSE==="ADD"){if(s.argument().TYPE==="EXPRESSION")throw new Error("Cannot add EXPRESSION constraint after column creation.");if(i.constraint(s.argument().TYPE))throw new Error(`Constraint ${s.argument().TYPE} already exists on ${i.name()}.`);i.constraint(s.argument())}else if(s.CLAUSE==="DROP"){let n=i.constraint(s.KIND);if(n)n.keep(!1);else if(["IDENTITY","EXPRESSION"].includes(s.KIND)&&!s.hasFlag("IF_EXISTS"))throw new Error(`Cannot drop ${s.KIND}; does not exist.`)}else if(s.CLAUSE==="SET"){if(s.argument()instanceof V)i.type(s.argument().toJSON());else if(["DEFAULT","ON_UPDATE"].includes(s.KIND))i.constraint(s.KIND,s.argument());else if(["NOT_NULL","NULL","AUTO_INCREMENT"].includes(s.KIND))i.constraint(s.KIND,!0);else if(s.KIND==="IDENTITY"){let n=i.identity();if(!n)throw new Error(`Cannot modify IDENTITY constraint on ${i.name()}; does not exist.`);n.always(/^ALWAYS$/i.test(s.argument()))}}}return this}getAlt(){let t=j.fromJSON(this.CONTEXT,{kind:"TABLE",ident:[this.PREFIX,this.NAME],actions:[]});this.$NAME&&this.NAME&&(this.isSame(this.$NAME,this.NAME,"ci")||t.rename(null,null,this.$NAME),this.$PREFIX&&!this.isSame(this.$PREFIX,this.PREFIX,"ci")&&t.set("SCHEMA",this.$PREFIX));let e=(i,s=!1)=>i.keep()!==!0||["$EXPR","$ALWAYS","$TARGET_TABLE","$TARGET_COLUMNS","$MATCH_RULE","$UPDATE_RULE","$DELETE_RULE"].concat(s?"$NAME":[]).some(n=>n in i&&(Array.isArray(i[n])?i[n].length:![void 0,null].includes(i[n]))&&!this.isSame(i[n.slice(1)],i[n],"ci"));for(let i of this.COLUMNS){if(i.keep()===!1){t.drop("COLUMN",i.NAME);continue}if(i.keep()!==!0){t.add("COLUMN",i.clone());continue}if(i.keep()===!0){if(this.params.dialect==="mysql")if(i.$TYPE&&!this.isSame(i.$TYPE.toJSON(),i.TYPE.toJSON(),"ci")||i.CONSTRAINTS.some(n=>["EXPRESSION","NOT_NULL","NULL","AUTO_INCREMENT","ON_UPDATE"].includes(n.TYPE)&&e(n,!0))){let n=i.clone();n.CONSTRAINTS=n.CONSTRAINTS.filter(f=>!(f instanceof P)),t.modify("COLUMN",n)}else{let n=i.CONSTRAINTS.find(f=>f.TYPE==="DEFAULT"&&e(f,!0));n&&t.alter("COLUMN",i.NAME,f=>{n.keep()===!1?f.drop("DEFAULT"):a.set("DEFAULT",n.expr())}),i.$NAME&&!this.isSame(i.$NAME,i.NAME,"ci")&&t.rename("COLUMN",i.NAME,i.$NAME)}else{i.$TYPE&&!this.isSame(i.$TYPE.toJSON(),i.TYPE.toJSON(),"ci")&&t.alter("COLUMN",i.NAME,{clause:"SET",kind:"DATA_TYPE",argument:V.fromJSON(i,i.$TYPE.toJSON())});let n=i.CONSTRAINTS.filter(f=>!(f instanceof P)&&e(f,!0));for(let f of n)t.alter("COLUMN",i.NAME,(()=>{if(f.keep()===!1)return{clause:"DROP",kind:f.TYPE};if(f.TYPE==="EXPRESSION")throw new Error("EXPRESSION constraints cannot be added or modified after column creation.");if(f.TYPE==="IDENTITY")return f.keep()?{clause:"SET",kind:"IDENTITY",argument:f.always()?"ALWAYS":!0}:{clause:"ADD",argument:f.clone()};if(["DEFAULT"].includes(f.TYPE))return{clause:"SET",kind:f.TYPE,argument:f.expr()};if(["NOT_NULL"].includes(f.TYPE))return{clause:"SET",kind:f.TYPE}})());i.$NAME&&!this.isSame(i.$NAME,i.NAME,"ci")&&t.rename("COLUMN",i.NAME,i.$NAME)}let s=i.CONSTRAINTS.filter(n=>n instanceof P);for(let n of s)if(e(n)){if([!0,!1].includes(n.keep())&&t.drop(n.TYPE,n.NAME),n.keep()!==!1){let f=i.$trace("get:TABLE_SCHEMA").altsCascaded?i.name():i.NAME,o=this.constructor.CONSTRAINT_TYPES.find(c=>c.TYPE===n.TYPE).fromJSON(n.CONTEXT,{...n.toJSON(),columns:[f]});t.add(o.TYPE,o)}}else n.keep()===!0&&n.$NAME&&!this.isSame(n.$NAME,n.NAME,"ci")&&t.rename("CONSTRAINT",n.NAME,n.$NAME)}}let r=i=>e(i)||i.$COLUMNS?.length&&!this.isSame(i.$COLUMNS,i.COLUMNS,"ci");for(let i of this.CONSTRAINTS)r(i)?([!0,!1].includes(i.keep())&&t.drop(i.TYPE,i.NAME),i.keep()!==!1&&t.add(i.TYPE,i.clone())):i.keep()===!0&&i.$NAME&&!this.isSame(i.$NAME,i.NAME,"ci")&&t.rename("CONSTRAINT",i.NAME,i.$NAME);return t}toJSON(){return super.toJSON({...this.PREFIX?{prefix:this.PREFIX}:{},...this.$PREFIX?{$prefix:this.$PREFIX}:{},columns:this.COLUMNS.map(t=>t.toJSON()),constraints:this.CONSTRAINTS.map(t=>t.toJSON()),indexes:this.INDEXES.map(t=>t.toJSON())})}static fromJSON(t,e){if(!(!Array.isArray(e?.columns)||["constraints","indexes"].some(r=>r in e&&!Array.isArray(e[r]))))return super.fromJSON(t,e,()=>{let r=new this(t);r.hardSet(()=>r.prefix(e.prefix)),r.hardSet(e.$prefix,i=>r.prefix(i));for(let i of e.columns)r.column(i);for(let i of e.constraints||[])r.constraint(i);for(let i of e.indexes||[])r.index(i);return r})}stringify(){let t=[this.COLUMNS.map(s=>s.stringify()).join(`,
	`)],e=this.CONSTRAINTS.slice(0),r=this.INDEXES.slice(0);this.params.dialect==="mysql"&&e.push(...this.COLUMNS.reduce((s,n)=>{let f=n.foreignKey();return f?s.concat(St.fromJSON(this,{...f.toJSON(),columns:[n.name()]})):s},[])),e.length&&t.push(e.map(s=>s.stringify()).join(`,
	`)),r.length&&t.push(r.map(s=>s.stringify()).join(`,
	`));let i=T.fromJSON(this,[this.prefix(),this.name()]);return i.prefix()||i.prefix(this.$trace("get:DATABASE_NAME")),`${i} (
	${t.join(`,
	`)}
)`}static parse(t,e,r){let[i,s,...n]=p.split(e,[],{limit:2});if(!i||!M(s||"","(",")"))return;let f=new this(t),o=r(f,i.trim(),[T]);f.name(o.name()),f.prefix(o.prefix());let c=p.split(b(s,"(",")"),[","]).map(h=>r(f,h.trim(),[Ut,St,bt,Nt,Z,G]));for(let h of c)h instanceof G?f.column(h):h instanceof Z?f.index(h):f.constraint(h);return f}$trace(t,...e){return t==="get:TABLE_SCHEMA"?this:t==="get:TABLE_NAME"?this.NAME:t==="get:DATABASE_NAME"&&this.prefix()?this.PREFIX:(["event:CONNECTED","event:DISCONNECTED"].includes(t)&&[G,P,Z].some(r=>e[0]instanceof r)&&(t==="event:DISCONNECTED"?this.NODES.delete(e[0]):this.NODES.add(e[0])),super.$trace(t,...e))}};var ct=class extends q{TABLES=[];TABLE_LIST=[];get[Symbol.iterator](){return this.TABLES[Symbol.iterator]}get length(){return this.TABLES.length}static get SUBTREE_PROPS(){return["TABLES"]}tables(){return this.TABLES.length?this.TABLES.reduce((t,e)=>t.concat(e.name()),[]):this.TABLE_LIST.slice()}foreignKeys(){return this.TABLES.reduce((t,e)=>t.concat(e.foreignKeys()),[])}table(t){return typeof t=="string"?this.TABLES.find(e=>this.isSame(e.name(),t,"ci")):(this.build("TABLES",[t],Vt),this.TABLES[this.TABLES.length-1])}diffWith(t){super.diffWith(t);let e=s=>new Set(s.TABLES.map(n=>n.NAME)),r=e(this),i=e(t);for(let s of new Set([...r,...i])){let n=this.table(s),f=t.table(s);r.has(s)&&!i.has(s)?n.keep(!1):r.has(s)?n.diffWith(f):this.table(f.toJSON())}return this}alterWith(t){let e=(r,i=!1)=>{let s=this.table(r);if(!s&&!i)throw new Error(`TABLE ${r} does not exist.`);return s};for(let r of t.ACTIONS)if(r.CLAUSE==="RENAME")r.KIND?e(r.ident().name()).name(r.argument().name()):this.name(r.argument().name());else if(r.CLAUSE==="DROP")e(r.ident().name(),r.hasFlag("IF_EXISTS"))?.keep(!1);else if(r.CLAUSE==="ADD")(!r.hasFlag("IF_NOT_EXISTS")||!e(r.argument().name(),!0))&&this.table(r.argument().toJSON());else if(r.CLAUSE==="MODIFY"){let i=e(r.argument().name(),r.hasFlag("IF_EXISTS"));if(!i)continue;i.diffWith(r.argument())}return this}getAlt(){let t=j.fromJSON(this.CONTEXT,{kind:"SCHEMA",ident:this.NAME,actions:[]});this.$NAME&&!this.isSame(this.$NAME,this.NAME,"ci")&&t.rename(null,null,this.$NAME);for(let e of this.TABLES)if(typeof e.keep()!="boolean")t.SUBTREE.push(H.fromJSON(this,{kind:"TABLE",argument:e.clone()}));else if(e.keep()===!1)t.SUBTREE.push(K.fromJSON(this,{kind:"TABLE",ident:e.name()}));else{let r=e.getAlt();r.length&&t.SUBTREE.push(r)}return t}toJSON(){return this.TABLES.length?super.toJSON({tables:this.TABLES.map(t=>t.toJSON())}):super.toJSON({tables:this.TABLE_LIST.slice()})}static fromJSON(t,e){if(!(!(typeof e=="object"&&e)||"tables"in e&&!Array.isArray(e.tables)))return super.fromJSON(t,e,()=>{let r=new this(t);for(let i of e.tables||[])typeof i=="string"?r.TABLE_LIST.push(i):r.table(i);return r})}stringify(){return this.autoEsc(this.name())}static parse(t,e,r){let[i]=this.parseIdent(t,e,!0);if(i)return new this(t).name(i)}$trace(t,...e){return t==="get:DATABASE_SCHEMA"?this:t==="get:DATABASE_NAME"?this.NAME:super.$trace(t,...e)}};var H=class extends wt(_t){ident(){return this.ARGUMENT&&T.fromJSON(this,[this.ARGUMENT.prefix?.(),this.ARGUMENT.name()])}stringify(){let t=[super.stringify()];return["SCHEMA","DATABASE"].includes(this.KIND)&&t.push(...this.argument().TABLES.map(e=>this.constructor.fromJSON(this,{kind:"TABLE",argument:e.toJSON()}))),t.join(`;
`)}static get CLAUSE(){return"CREATE"}static NODE_TYPES=[Vt,ct];static KINDS=["TABLE","SCHEMA","DATABASE"]};var Ne=class extends wt($t){static KINDS=["TABLE","SCHEMA","DATABASE"]};var cr=[H,j,K,Ne,z,ft,Et,W,...C.Types];var Te=class{static grammar=cr;static parse(t,e,r,i={}){if(!e?.length)return;let s=r?.length?r:this.grammar;for(let n of s){let f=this.parseOne(t,e,n,i);if(f)return i.log&&console.log(".................",e,".................>",f.constructor.name),f}if(i.assert!==!1)throw new SyntaxError(e)}static parseOne(t,e,r,i={}){return r.parse(t,e,(s,n,f,o={})=>this.parse(s,n,f,{...i,...o}))}};var Ae=class extends _{DATABASES=[];get[Symbol.iterator](){return this.DATABASES[Symbol.iterator]}get length(){return this.DATABASES.length}databases(){return this.DATABASES.map(t=>t.name())}tables(){return this.DATABASES.reduce((t,e)=>t.concat(e.tables().map(r=>[e.name(),r])),[])}foreignKeys(){return this.DATABASES.reduce((t,e)=>t.concat(e.foreignKeys()),[])}database(t){return typeof t=="string"?this.DATABASES.find(e=>e.isSame(e.name(),t,"ci")):(this.build("DATABASES",[t],ct),this.DATABASES[this.DATABASES.length-1])}findPath(t,e=!1){let r=this.tables().find(i=>i[1].toLowerCase()===t.toLowerCase())?.[0];return!r&&e?this.databases()[0]:r}cascadeAlt(t=[]){this.keep(this.keep(),"auto");let e=t.filter(i=>i.isSame(i.name(),this.name(),"ci")),r=this.dropped()?"DOWN":this.$NAME&&this.$NAME!==this.NAME?"RENAME":null;if(r==="DOWN"&&(t=t.filter(i=>i!==e)),r)for(let i of t.reduce((s,n)=>s.concat(n.TABLES)))i.updateDatabaseReferences(this,r);for(let i of this.TABLES)i.cascadeAlt();return this.altsCascaded=!0,this}cascadeAlt(){this.keep(this.keep(),"auto");let t=r=>r.dropped()?"DOWN":r.$NAME&&!this.isSame(r.$NAME,r.NAME,"ci")?"RENAME":null,e=t(this);for(let r of this.COLUMNS){let i=t(r);if(i)for(let s of this.CONSTRAINTS){if(s instanceof CheckConstraint)continue;let n=s.$COLUMNS.length?s.$COLUMNS:s.COLUMNS,f=n.indexOf(r.NAME);f>-1&&(i==="DOWN"?n.splice(f,1):i==="RENAME"&&(n[f]=r.$NAME))}}return this.altsCascaded=!0,this}updateDatabaseReferences(t,e){for(let r of this.foreignKeys())r.targetTable().PREFIX===t.NAME&&(e==="DOWN"?r.keep(!1):e==="RENAME"&&r.targetTable().name([t.$NAME,r.targetTable().NAME]))}updateTableReferences(t,e){for(let r of this.foreignKeys())r.targetTable().PREFIX&&t.PREFIX&&node.targetTable().prefix()!==t.prefix()||node.targetTable().name()===t.NAME&&(e==="DOWN"?node.keep(!1):e==="RENAME"&&node.targetTable().name(t.$NAME))}updateColumnReferences(t,e){for(let r of this.NODES){if(!(r instanceof ForeignKey)||r.targetTable().prefix()&&t.$trace("get:DATABASE_NAME")&&r.targetTable().prefix()!==t.$trace("get:DATABASE_NAME")||r.targetTable().name()!==t.$trace("get:TABLE_NAME"))continue;let i=cons.$TARGET_COLUMNS.length?cons.$TARGET_COLUMNS:cons.TARGET_COLUMNS,s=i.indexOf(t.NAME);s>-1&&(e==="DOWN"?i.splice(s,1):e==="RENAME"&&(i[s]=t.$NAME))}}toJSON(){return this.DATABASES.map(t=>t.toJSON())}static fromJSON(t,e){if(!Array.isArray(e))return;let r=new this(t);for(let i of e)r.database(i);return r}$trace(t,...e){return t==="get:ROOT_SCHEMA"?this:super.$trace(t,...e)}};var re=class{constructor(t,e,r="backward"){Object.defineProperty(this,"$",{value:{client:t,json:e,direction:r}})}get client(){return this.$.client}get direction(){return this.$.direction}get id(){return this.$.json.id}get databaseTag(){return this.$.json.database_tag}get versionTag(){return this.$.json.version_tag}get versionMax(){return this.$.json.version_max}get cursor(){return this.$.json.$cursor}get commitDate(){return this.$.json.commit_date}get commitDesc(){return this.$.json.commit_desc}get commitRef(){return this.$.json.commit_ref}get rollbackDate(){return this.$.json.rollback_date}get rollbackDesc(){return this.$.json.rollback_desc}get rollbackRef(){return this.$.json.rollback_ref}get keep(){return this.$.json.keep}get rollbackEffect(){let t=typeof this.$.json.keep!="boolean"?["DROP","RECREATE"]:this.$.json.keep===!1?["RECREATE","DROP"]:["ALTER"];return this.direction==="forward"?t.reverse()[0]:t[0]}get rollbackQuery(){let t=ct.fromJSON(this.client,this.schema());return this.direction!=="forward"&&(t.reverseAlt(!0),t.keep(t.keep(),"auto")),t.keep()===!1?K.fromJSON(this.client,{kind:"SCHEMA",ident:t.name()}).withFlag(this.client.params.dialect==="mysql"?"":"CASCADE"):t.keep()===!0?t.getAlt().with({resultSchema:t}):H.fromJSON(this.client,{kind:"SCHEMA",argument:t})}name(t=!1){return t?this.direction==="forward"&&this.$.json.$name||this.$.json.name:this.direction!=="forward"&&this.$.json.$name||this.$.json.name}schema(){let{name:t,$name:e,tables:r=[],keep:i}=this.$.json;return{name:t,...e?{$name:e}:{},tables:r,keep:i}}toJSON(){let{id:t,database_tag:e,version_tag:r,version_max:i,$cursor:s,commit_date:n,commit_desc:f,commit_ref:o,rollback_date:c,rollback_desc:h,rollback_ref:l}=this.$.json;return{id:t,name:this.name(),databaseTag:e,versionTag:r,versionMax:i,cursor:s,commitDate:n,commitDesc:f,commitRef:o,rollbackDate:c,rollbackDesc:h,rollbackRef:l,rollbackEffect:this.rollbackEffect}}async isNextPointInTime(){return(await this.client.database(this.name()).savepoint({direction:this.direction})||{}).id===this.$.json.id}async rollback(t={}){if(!await this.isNextPointInTime())throw new Error("Invalid rollback order.");await this.client.query(this.rollbackQuery,{noCreateSavepoint:!0});let r=await(await this.client.linkedDB()).table("savepoints").update({rollback_date:i=>this.direction==="forward"?i.null():i.fn("now"),rollback_desc:t.desc,rollback_ref:t.ref||this.client.params.commitRef,rollback_pid:i=>i.literal(this.client.params.dialect==="mysql"?"connection_id()":"pg_backend_pid()")},{where:{id:i=>i.value(this.$.json.id)},returning:["rollback_date"]});return this.$.json.rollback_date=r[0].rollback_date,!0}};var de=class{constructor(t={}){Object.defineProperty(this,"$",{value:t})}get params(){return this.$.params||{}}async $init(){this.$.initialised||(this.$.initialised=!0,this.params.nameResolution&&await this.nameResolution(this.params.nameResolution))}database(t,e={}){return new this.constructor.Database(this,...arguments)}async hasDatabase(t){return await this.$init(),(await this.databases()).includes(t)}async createDatabase(t,e={}){if(typeof t=="string")t={name:t};else if(typeof t?.name!="string")throw new Error("createDatabase() called with invalid arguments.");let r=H.fromJSON(this,{kind:"SCHEMA",argument:t});return e.ifNotExists&&r.withFlag("IF_NOT_EXISTS"),await this.query(r,e)}async alterDatabase(t,e,r={}){if(typeof e!="function")throw new Error("alterDatabase() called with invalid arguments.");if(typeof t=="string")t={name:t};else if(typeof t?.name!="string")throw new Error("alterDatabase() called with invalid arguments.");return await this.structure({depth:2,inSearchPathOrder:!0},async()=>{let i=(await this.structure([{name:t.name,tables:t.tables}])).database(t.name);if(!i)throw new Error(`Database "${t.name}" does not exist.`);await e(i.keep(!0,!0));let s=i.getAlt().with({resultSchema:i});if(s.length)return await this.query(s,r)})}async dropDatabase(t,e={}){if(typeof t!="string")throw new Error(`dropDatabase() called with an invalid name: ${t}.`);let r=K.fromJSON(this,{kind:"SCHEMA",ident:t});return e.ifExists&&r.withFlag("IF_EXISTS"),e.cascade&&r.withFlag("CASCADE"),await this.query(r,e)}async createSavepoint(t,e=null){let i=(await this.linkedDB()).table("savepoints"),{name:s,$name:n,...f}=t.toJSON(),o={name:s,$name:n,database_tag:null,...f,version_tag:null,commit_date:m=>m.fn("now"),commit_desc:e.desc,commit_ref:e.ref||this.params.commitRef,commit_pid:m=>m.literal(this.params.dialect==="mysql"?"connection_id()":"pg_backend_pid()")},c=t.NAME,h=await this.database(c).savepoint({direction:"forward"})||await this.database(c).savepoint();h?(o.database_tag=h.databaseTag,o.version_tag=h.versionMax+1,h.direction==="forward"?await i.delete(m=>m.where(E=>E.equals("database_tag",A=>A.value(h.databaseTag)),E=>E.isNotNull("rollback_date"))):o.version_tag=h.versionTag+1):(o.database_tag=`db:${(0|Math.random()*9e6).toString(36)}`,o.version_tag=1);let l=await i.insert(o,{returning:"*"});return new re(this,{...l,version_max:o.version_tag,$cursor:null})}async savepoints(t={}){let e=await this.linkedDB();return(await this.query(`
            SELECT id, database_tag, name, ${T.fromJSON(this,"$name")}, keep, version_tag, version_max, CONCAT(rank_for_cursor, '/', total) AS ${T.fromJSON(this,"$cursor")}, tables, commit_date, commit_desc, commit_ref, rollback_date, rollback_desc, rollback_ref FROM (
                SELECT *,
                ROW_NUMBER() OVER (PARTITION BY database_tag ORDER BY rollback_date IS NOT NULL ${t.direction==="forward"?"DESC":"ASC"}, version_tag ${t.direction==="forward"?"ASC":"DESC"}) AS rank_for_target,
                ROW_NUMBER() OVER (PARTITION BY database_tag ORDER BY version_tag ASC) AS rank_for_cursor,
                MAX(version_tag) OVER (PARTITION BY database_tag) AS version_max,
                COUNT(version_tag) OVER (PARTITION BY database_tag) AS total
                FROM ${e.table("savepoints").ident}
            ) AS savepoint WHERE rollback_date IS ${t.direction==="forward"?"NOT NULL":"NULL"} AND rank_for_target = 1${t.name?t.direction==="forward"?` AND name = '${t.name}'`:` AND COALESCE(${T.fromJSON(this,"$name")}, name) = '${t.name}'`:""}
        `)).map(i=>new re(this,i,t.direction))}async queryCallback(t,e,r={}){if(typeof e=="string")e=Te.parse(this,e,null,{log:r.log});else if(!(e instanceof _))throw new Error("query() called with invalid arguments.");let i=e.$trace("get:DATABASE_NAME"),s=e.$trace("get:TABLE_NAME"),n=[H,j,K].some(c=>e instanceof c)&&!r.noCreateSavepoint,f=[z,ft].some(c=>e instanceof c),o=s&&!i||n||f;return await this.structure(o&&{depth:2,inSearchPathOrder:!0},async c=>{let h={},l=T.fromJSON(this,s?[i||c.findPath(s,e instanceof H),s]:[i]);if(n){if(["DATABASE","SCHEMA"].includes(e.KIND)){if(e instanceof K){let E=c.database(l.name())?.keep(!1);e.with({resultSchema:E})}else if(e instanceof j&&!e.resultSchema){let E=e.ACTIONS.map(N=>N.CLAUSE==="MODIFY"?N.ARGUMENT.$trace("get:TABLE_NAME"):N.CLAUSE==="DROP"?N.ident().name():null).filter(N=>N),A=c.database(l.name());E.length&&(A.TABLES=A.TABLES.filter(N=>!E.includes(N.name()))),A.keep(!0,!0).alterWith(e),e.with({resultSchema:A})}else e instanceof H&&e.with({resultSchema:e.ARGUMENT});h.savepoint=e.resultSchema}else if(e.KIND==="TABLE"){if(e instanceof K){let E=c.database(l.prefix())?.table(s)?.keep(!1);e.with({resultSchema:E})}else if(e instanceof j&&!e.resultSchema){let E=c.database(l.prefix())?.table(s)?.keep(!0,!0).alterWith(e);e.with({resultSchema:E})}else e instanceof H&&e.with({resultSchema:e.ARGUMENT});h.savepoint=e.resultSchema&&ct.fromJSON(this,{name:l.prefix(),tables:[e.resultSchema]}).keep(!0)}}else e.expandable&&await e.expand(!0),f&&([e,h.preHook,h.postHook]=await e.resolveDimensions(),h.preHook&&await h.preHook());let m=await t(l,e,r);return h.postHook&&(m=await h.postHook(m)),h.savepoint?(h.savepoint.keep(h.savepoint.keep(),"auto"),await this.createSavepoint(h.savepoint,r)):m})}structureMemoStack=new Set;async structureCallback(t,e={},...r){let i=l=>[...this.structureMemoStack].find(m=>{if(g(m.selector)&&g(e))return Object.keys(e).every(E=>!l&&E==="depth"?(m.selector[E]||0)>=(e[E]||0):E==="inSearchPathOrder"?m.selector[E]||!e[E]:m.selector[E]===e[E]);if(Array.isArray(m.selector)&&Array.isArray(e))return e.every(E=>m.selector.find(A=>E.name===A.name&&((N,S)=>l?Lt(N,S).length===N.length:!We(N,S).length)(Rt(E.tables),Rt(A.tables))));if(g(m.selector)&&m.selector.depth&&Array.isArray(e)){let E=e.reduce((A,N)=>Math.max(A,[].concat(N.tables||[]).length),0)?2:1;return m.selector.depth>=E}}),s=typeof r[0]=="boolean"?r.shift():!0,n=typeof r[0]=="function"?r.shift():l=>l;if(!e)return n();let f=i(s)?.resultPromise||t(e),o=(l=>(this.structureMemoStack.add(l),l))({selector:e,resultPromise:f}),c=(l=>Array.isArray(e)?l.reduce((m,E)=>{let A=e.find(S=>S.name===E.name),N=[].concat(A?.tables||[]);return N.length&&N[0]!=="*"&&(E={...E,tables:E.tables.filter(S=>N.includes(S.name))}),m.concat(A&&E||[])},[]):l)(await f),h=await n(Ae.fromJSON(this,c));return this.structureMemoStack.delete(o),h}async searchPath(t=[]){return arguments.length?(this.$.searchPath=[].concat(searchPath),this):this.$.searchPath||[]}async linkedDB(){let t=[async o=>{await this.createDatabase({name:o,tables:[{name:"savepoints",columns:[{name:"id",...this.params.dialect==="mysql"?{type:"char(36)",default:{expr:"uuid()"}}:{type:"uuid",default:{expr:"gen_random_uuid()"}},primaryKey:!0},{name:"name",type:["varchar",255],notNull:!0},{name:"$name",type:["varchar",255]},{name:"tables",type:"json"},{name:"keep",type:this.params.dialect==="mysql"?["bit",1]:"boolean"},{name:"database_tag",type:["varchar",12],notNull:!0},{name:"version_tag",type:"int",notNull:!0},{name:"commit_date",type:["timestamp",3],notNull:!0},{name:"commit_desc",type:["varchar",255]},{name:"commit_ref",type:["varchar",50]},{name:"commit_pid",type:["varchar",50]},{name:"rollback_date",type:["timestamp",3]},{name:"rollback_desc",type:["varchar",255]},{name:"rollback_ref",type:["varchar",50]},{name:"rollback_pid",type:["varchar",50]}]}]},{noCreateSavepoint:!0}),this.params.dialect==="postgres"&&await this.driver.query(`
                        -- The Function
                        CREATE OR REPLACE FUNCTION fire_savepoints_event() RETURNS trigger AS $$
                        BEGIN
                            PERFORM pg_notify('savepoints_stream', json_build_object(
                                'action', TG_OP,
                                'entry', CASE WHEN TG_OP = 'DELETE' THEN row_to_json(OLD) ELSE row_to_json(NEW) END
                            )::text);
                            RETURN NEW;
                        END;
                        $$ LANGUAGE plpgsql;
                        -- The trigger
                        DROP TRIGGER IF EXISTS savepoints_event_trigger ON "${o}"."savepoints";
                        CREATE TRIGGER savepoints_event_trigger
                            AFTER INSERT OR UPDATE OR DELETE ON "${o}"."savepoints"
                            FOR EACH ROW EXECUTE FUNCTION fire_savepoints_event();
                    `)}],e=t.length,r=o=>"linked_db"+(o&&`_v${o}`||""),i=this.database(r(e));if(Object.defineProperty(i,"uninstall",{value:async o=>{await this.dropDatabase(i.name,{cascade:o,noCreateSavepoint:!0})}}),this.installed)return i;this.installed=!0;let n=(await this.structure({depth:1})).databases().find(o=>o.startsWith(r())||o==="obj_information_schema"),f=n&&/^.+?([\d]+)$/.exec(n)?.[1]||-1;if(n&&f===-1&&console.warn("Your database has a old version of Linked DB that is no longer supported. Any savepoint record in there will be retained but won't be migrated to the new Linked DB version you have now. You may file an issue on github for any assistance."),e<f)throw new Error(`Your database has a higher version of Linked DB "${f}" than this query client is designed to support "${e}". Consider upgrading this client to latest version.`);for(let o=1;o<=t.length;o++){if(o<=f)continue;let c=r(o-1),h=r(o);try{this.structureMemoStack.clear(),o>1&&await this.alterDatabase(c,l=>l.name(h),{noCreateSavepoint:!0}),await t[o-1](h)}catch(l){throw new Error(`Error upgrading your Linked DB version from ${c} to ${h}. Consider filing an issue on github. (${l})`)}}return i}$trace(t,...e){if(t==="get:CLIENT_API")return this;if(t==="get:ROOT_SCHEMA")return this.structure({depth:2})}};var _e=class{constructor(t,e,r={}){Object.defineProperty(this,"$",{value:{client:t,name:e,params:r}})}get client(){return this.$.client}get name(){return this.$.name}get ident(){return T.fromJSON(this,this.name)}get params(){return Object.assign({},this.client.params,this.$.params)}async $init(){await this.client.$init()}async savepoint(t={}){return(await this.client.savepoints({...t,name:this.name}))[0]}async structure(t=["*"]){return(await this.client.structure([{name:this.name,tables:t}])).database(this.name)}table(t,e={}){return new this.constructor.Table(this,...arguments)}async createTable(t,e={}){if(typeof t?.name!="string")throw new Error("createTable() called with invalid arguments.");let r=H.fromJSON(this,{kind:"TABLE",argument:t});return e.ifNotExists&&r.withFlag("IF_NOT_EXISTS"),this.client.query(r,e)}async alterTable(t,e,r={}){if(typeof e!="function"||typeof t!="string")throw new Error("alterTable() called with invalid arguments.");return await this.client.structure({depth:2,inSearchPathOrder:!0},async()=>{let i=(await this.table(t).structure())?.keep(!0,!0);if(!i)throw new Error(`Table "${t}" does not exist.`);await e(i);let s=i.getAlt().with({resultSchema:i});if(s.length)return r.ifExists&&s.withFlag("IF_EXISTS"),this.client.query(s,r)})}async dropTable(t,e={}){if(typeof t!="string")throw new Error("dropTable() called with invalid arguments.");let r=K.fromJSON(this,{kind:"TABLE",ident:t});return e.ifExists&&r.withFlag("IF_EXISTS"),e.cascade&&r.withFlag("CASCADE"),this.client.query(r,e)}$trace(t,...e){return t==="get:DATABASE_API"?this:t==="get:DATABASE_NAME"?this.name:this.client.$trace(t,...e)}};var ge=class{constructor(t,e,r={}){this.$={database:t,name:e,params:r}}get database(){return this.$.database}get name(){return this.$.name}get ident(){return T.fromJSON(this,[this.database.name,this.name])}get params(){return Object.assign({},this.database.params,this.$.params)}async $init(){await this.database.$init()}async savepoint(){await this.$init()}async structure(){return(await this.database.structure(this.name)).table(this.name)}async count(...t){let e=[].concat(Array.isArray(t[0])?t.shift():"*");if(e.length!==1)throw new Error("Count expects exactly one field.");let r=await this.select([i=>i.fn("COUNT",e[0]).as("c")],...t);return Array.isArray(r)?r[0].c:r.c}async select(...t){let e=new W(this.database.client);e.from(this.ident.toJSON());let i={fields:Array.isArray(t[0])?t.shift():["*"],...t.shift()||{}};return e.select(...i.fields),await this.$applyModifiers(e,i,async()=>{let s=await this.database.client.query(e);return["string","number"].includes(typeof i.where)?s[0]:s})}async insert(...t){let e,r=[],i=[],s,n;if(typeof t[0]=="function"&&(e=t.shift()),Array.isArray(t[0])&&t[0].every(l=>typeof l=="string")&&Array.isArray(t[1])){if(!t[1].every(l=>Array.isArray(l)))throw new TypeError("Invalid payload format.");[r,i,s]=t.splice(0,3)}else{let l=g(t[0]),m=[].concat(t.shift());if(!g(m[0]))throw new TypeError("Invalid payload format.");r=Object.keys(m[0]),i=m.map(E=>Object.values(E)),s=t.shift(),n=l&&s?.returning}let f,o,c=new z(this.database.client);c.into(this.ident.toJSON()),r.length&&c.columns(...r);for(let l of i)c.values(...l.map(m=>qe(m,this.params.autoBindings)));g(s)&&s.returning?c.returning(...[].concat(s.returning)):Y(s)&&s(c);let h=e&&this.params.dialect==="postgres";return await this.database.client.structure(h&&{depth:2,inSearchPathOrder:!0},async()=>{e&&await e(c);let l=await this.database.client.query(c);return n&&(l=l[0]),l})}async upsert(...t){return await this.insert(async e=>{let r=(e.columns()?.entries()||[]).map(s=>s.name()),i=this.params.dialect==="postgres"?s=>n=>n.expr(["EXCLUDED",s]):s=>n=>n.fn("VALUES",s);if(e.onConflict(...r.map(s=>[s,i(s)])),this.params.dialect==="postgres"){let n=(await this.structure()).uniqueKeys().map(o=>o.columns());if(!n.length)throw new Error("Table has no unique keys defined. You may want to perform a direct INSERT operation.");let f=n.find(o=>Lt(o,r).length)||n[0];e.onConflict().target(...f)}},...t)}async update(t,e){if(!e)throw new Error('The "modifiers" parameter cannot be ommitted.');let r=["string","number"].includes(typeof e.where)&&e.returning,i=Object.keys(t),s=Object.values(t),n,f,o=new ft(this.database.client);return o.table(this.ident.toJSON()),i.forEach((c,h)=>o.set(c,qe(s[h],this.params.autoBindings))),await this.$applyModifiers(o,e,async()=>{let c=await this.database.client.query(o);return r&&(c=c[0]),c})}async delete(t){if(!t)throw new Error('The "modifiers" parameter cannot be ommitted.');let e=new Et(this.database.client);return e.from(this.ident.toJSON()),await this.$applyModifiers(e,t,async()=>{let r=await this.database.client.query(e);return["string","number"].includes(typeof t.where)&&t.returning&&(r=r[0]),r})}async $applyModifiers(t,e,r){if(e===!0)return await r();let i=s=>t.where(...Object.entries(s).map(([n,f])=>f===null?o=>o.isNull(n):o=>o.equals(n,qe(f,this.params.autoBindings))));if(g(e)){if(e.limit&&t.limit(e.limit),e.returning&&t.returning(...[].concat(e.returning)),["string","number"].includes(typeof e.where))return await this.database.client.structure({depth:2,inSearchPathOrder:!0},async()=>{let s=await this.structure();return i({[gr(s)]:e.where}),await r()});g(e.where)?i(e.where):e.where&&e.where!==!0&&t.where(e.where)}else Y(e)?e(t):/^\d+$/.test(e)&&t.limit(e);return await r()}$trace(t,...e){return t==="get:TABLE_API"?this:t==="get:TABLE_NAME"?this.name:this.database.$trace(t,...e)}},qe=(u,t)=>typeof u=="function"?u:u instanceof Date?e=>e.value(u.toISOString().split(".")[0]):Array.isArray(u)||g(u)?e=>e.json(u):[!0,!1,null,void 0].includes(u)?e=>e.literal(u===void 0?null:u):e=>e.value(u),gr=u=>{let t=u.primaryKey()?.columns()[0];if(!t)throw new Error("Cannot resolve primary key name for implied record.");return t};var Oe=class{_pos=0;_eof=!1;_onfinish=[];constructor(t){this._cache=t}get eof(){return!this._cache.length||this._pos===this._cache.length-1}onfinish(t){this._onfinish.push(t)}next(){if(this.eof){this._onfinish.forEach(t=>t()),this._pos=0;return}this._pos++}async fetch(){if(!this.eof)return this._cache[this._pos]}};var Re=class extends Oe{constructor(t){super([]),this._store=t,this._storeFetch=new Promise(async e=>{this.cache=await this._store.select(),e()})}async fetch(){return await this._storeFetch,super.fetch()}};var Ie=class extends ge{getCursor(){return new Re(this)}};var Le=class extends _e{static Table=Ie;async tables(){return await this.tablesCallback(async()=>{let t=`SELECT table_name FROM information_schema.tables WHERE table_schema = '${this.name}'`,e=await this.client.driver.query(t);return(e.rows||e).map(r=>r.table_name)})}};var Ce=class extends de{constructor(t,e={}){if(typeof t!="object")throw new Error("The options.driver parameter is required and must be an object.");if(typeof t.query!="function")throw new Error("The provided driver must expose a .query() function.");super({driver:t,params:e})}get driver(){return this.$.driver}static kind="sql";static Database=Le;async query(t,e={}){return await this.queryCallback(async(r,i,s)=>{let n=[z,ft,Et].some(c=>i instanceof c),f=n&&this.params.dialect==="mysql"&&i.RETURNING_LIST.length;if(f&&!this.params.mysqlReturningClause)throw new Error('Support for a "RETURNING" clause for mysql has not been enabled via "options.mysqlReturningClause".');let o=i.expandable||f;return await this.structure(o&&{depth:2,inSearchPathOrder:!0},async()=>{let[c,h]=f?await this.$mysqlReturningMagic(r,i):[i],l=(c.BINDINGS||[]).concat(s.values||[]).map(E=>Array.isArray(E)||typeof E=="object"&&E?JSON.stringify(E):E),m=await this.driver.query(c.toString(),l);return h&&(m=await h()),i instanceof W||n&&i.RETURNING_LIST.length?m.rows||m:"rowCount"in m?m.rowCount:m.affectedRows})},...arguments)}async structure(t={},...e){let r=async i=>{let[s,n]=this.$composeSchemasSQL(i),f=await this.driver.query(s),o=await this.driver.query(n);return this.$formatSchemasResult(i,f.rows||f,o.rows||o,[])};return await this.structureCallback(async i=>{if(Array.isArray(i))return await r(i);let s="excluding"in i?i.excluding:["information_schema"];if(!Array.isArray(s))throw new Error("If present, selector.excluding must be an array.");let n=`SELECT schema_name${i.depth?", table_name":""}
                FROM information_schema.schemata
                ${i.depth?"LEFT JOIN information_schema.tables ON table_schema = schema_name AND table_type = 'BASE TABLE'":""}
                WHERE
                    ${s.length?`schema_name NOT IN ('${s.join("', '")}')`:""}
                    AND schema_name NOT LIKE 'pg_%'
                ${i.inSearchPathOrder?"ORDER BY array_position(current_schemas(false), schema_name)":""};`,f=await this.driver.query(n);if(!i.depth)return[...new Set((f.rows||f).map(c=>({name:c.schema_name})))];let o=Object.values((f.rows||f).reduce((c,h)=>(h.schema_name in c||(c[h.schema_name]={name:h.schema_name,tables:[]}),h.table_name&&c[h.schema_name].tables.push(h.table_name),c),{}));return i.depth<2?o:await r(o)},...arguments)}async searchPath(t=[]){if(arguments.length){t=[].concat(t).map(f=>T.fromJSON(this,f));let n=this.params.dialect==="mysql"?`USE ${t[0]}`:`SET SEARCH_PATH TO ${t.join(",")}`;return await this.driver.query(n)}let e,r;this.params.dialect==="mysql"?(e="SELECT database() AS default_db",r="default_db"):(e="SHOW SEARCH_PATH",r="search_path",e="SELECT current_setting('SEARCH_PATH')",r="current_setting");let i=await this.driver.query(e),s=((i.rows||i)[0]||{})[r];return p.split(s,[","]).map(n=>T.parseIdent(this,n.trim())[0])}async $mysqlReturningMagic(t,e){e=e.clone();let r=e.returning().splice(0);if(e instanceof Et){let o=await this.driver.query(`SELECT ${r.join(", ")} FROM ${t}${e.WHERE_CLAUSE?` WHERE ${e.WHERE_CLAUSE}`:""}`);return[e,()=>o]}let i="obj_column_for_returning_clause_support",s=T.fromJSON(this,i);(await this.database(t.prefix()).table(t.name()).structure()).column(i)||await this.driver.query(`ALTER TABLE ${t} ADD COLUMN ${s} char(36) INVISIBLE`);let f=(0|Math.random()*9e6).toString(36);if(e.set())e.set(i,o=>o.value(f));else if(e instanceof z){if(!e.columns()&&(e.select()||e.values().length))throw new Error("Support for the RETURNING clause currently requires explicit column list in INSERT statements.");if(e.columns(i),e.select())e.select().select(o=>o.value(f));else if(e.values().length)for(let o of e.values())o.entries(c=>c.value(f));else e.values(f)}return e instanceof z&&e.onConflict()&&e.onConflict().set(i,o=>o.value(f)),[e,async()=>{let o=await this.driver.query(`SELECT ${r.join(", ")} FROM ${t} WHERE ${s} = '${f}'`);return this.params.mysqlReturningClause==="WITH_AUTO_CLEANUP"&&await this.driver.query(`ALTER TABLE ${t} DROP COLUMN ${s}`),o}]}$composeSchemasSQL(t=[]){let e="",r="",i=(c,h)=>{t.length&&(e=`${c} IN ('${t.map(E=>E.name).join("', '")}')`);let l=t.reduce((E,A)=>{let N=[].concat(A.tables);return N[0]==="*"?E:E.concat(`WHEN '${A.name}' THEN ${h} IN ('${N.join("', '")}')`)},[]);l.length&&(r=`CASE ${c} ${l.join(" ")} END`);let m=r?`${e} AND ${r}`:e;return m?`WHERE ${m}`:""},s=`
        SELECT
            COLUMNS.table_schema,
            COLUMNS.table_name,
            COLUMNS.column_name,
            COLUMNS.ordinal_position,
            COLUMNS.column_default,
            COLUMNS.is_nullable,
            COLUMNS.data_type,
            COLUMNS.character_maximum_length,
            ${this.params.dialect==="mysql"?`
            COLUMNS.extra,
            `:`
            COLUMNS.is_identity,
            COLUMNS.identity_generation,
            COLUMNS.identity_start,
            COLUMNS.identity_increment,
            COLUMNS.identity_maximum,
            COLUMNS.identity_minimum,
            COLUMNS.identity_cycle,
            `}
            COLUMNS.is_generated,
            COLUMNS.generation_expression
        FROM INFORMATION_SCHEMA.COLUMNS AS COLUMNS
        ${i("COLUMNS.TABLE_SCHEMA","COLUMNS.TABLE_NAME")}
        ORDER BY COLUMNS.ordinal_position
        `,n=c=>this.params.dialect==="mysql"?c:`MAX(${c})`,f=(c,h)=>this.params.dialect==="mysql"?`GROUP_CONCAT(${c}${h?` ORDER BY ${h}`:""} SEPARATOR ',')`:`STRING_AGG(${c}, ','${h?` ORDER BY ${h}`:""})`,o=`
        SELECT
            ${n("TABLE_CONSTRAINTS.constraint_schema")} AS table_schema,
            ${n("TABLE_CONSTRAINTS.table_name")} AS table_name,
            ${f("TABLE_CONSTRAINTS_DETAILS.column_name","TABLE_CONSTRAINTS_DETAILS.ordinal_position")} AS column_name,
            TABLE_CONSTRAINTS.constraint_name AS constraint_name,
            ${n("TABLE_CONSTRAINTS.constraint_type")} AS constraint_type,
            ${n("CHECK_CONSTRAINTS_DETAILS.check_clause")} AS check_clause,
            ${this.params.dialect==="mysql"?`
            ${n("CHECK_CONSTRAINTS_DETAILS.level")} AS check_constraint_level,
            ${f("TABLE_CONSTRAINTS_DETAILS.referenced_column_name")} AS referenced_column_name,
            ${n("TABLE_CONSTRAINTS_DETAILS.referenced_table_name")} AS referenced_table_name,
            ${n("TABLE_CONSTRAINTS_DETAILS.referenced_table_schema")} AS referenced_table_schema,
            `:`
            ${f("RELATION_DETAILS.column_name")} AS referenced_column_name,
            ${n("RELATION_DETAILS.table_name")} AS referenced_table_name,
            ${n("RELATION_DETAILS.table_schema")} AS referenced_table_schema,
            `}
            --${f("RELATION.unique_constraint_name")} AS referenced_constraint_name,
            ${n("RELATION.match_option")} AS match_rule,
            ${n("RELATION.update_rule")} AS update_rule,
            ${n("RELATION.delete_rule")} AS delete_rule
        FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS AS TABLE_CONSTRAINTS
        LEFT JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE AS TABLE_CONSTRAINTS_DETAILS
            ON TABLE_CONSTRAINTS_DETAILS.CONSTRAINT_NAME = TABLE_CONSTRAINTS.CONSTRAINT_NAME
            AND TABLE_CONSTRAINTS_DETAILS.TABLE_NAME = TABLE_CONSTRAINTS.TABLE_NAME
            AND TABLE_CONSTRAINTS_DETAILS.CONSTRAINT_SCHEMA = TABLE_CONSTRAINTS.CONSTRAINT_SCHEMA
            AND TABLE_CONSTRAINTS_DETAILS.CONSTRAINT_CATALOG = TABLE_CONSTRAINTS.CONSTRAINT_CATALOG
        LEFT JOIN INFORMATION_SCHEMA.CHECK_CONSTRAINTS AS CHECK_CONSTRAINTS_DETAILS
            ON CHECK_CONSTRAINTS_DETAILS.CONSTRAINT_NAME = TABLE_CONSTRAINTS.CONSTRAINT_NAME
            AND CHECK_CONSTRAINTS_DETAILS.CONSTRAINT_SCHEMA = TABLE_CONSTRAINTS.CONSTRAINT_SCHEMA
            AND CHECK_CONSTRAINTS_DETAILS.CONSTRAINT_CATALOG = TABLE_CONSTRAINTS.CONSTRAINT_CATALOG
        LEFT JOIN INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS AS RELATION
            ON RELATION.CONSTRAINT_NAME = TABLE_CONSTRAINTS.CONSTRAINT_NAME
            AND RELATION.CONSTRAINT_SCHEMA = TABLE_CONSTRAINTS.CONSTRAINT_SCHEMA
            AND RELATION.CONSTRAINT_CATALOG = TABLE_CONSTRAINTS.CONSTRAINT_CATALOG
        ${this.params.dialect==="mysql"?"":`
        LEFT JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE AS RELATION_DETAILS
            ON RELATION_DETAILS.CONSTRAINT_NAME = RELATION.UNIQUE_CONSTRAINT_NAME
            AND RELATION_DETAILS.CONSTRAINT_SCHEMA = RELATION.UNIQUE_CONSTRAINT_SCHEMA
            AND RELATION_DETAILS.CONSTRAINT_CATALOG = RELATION.UNIQUE_CONSTRAINT_CATALOG
            `}
        ${i("TABLE_CONSTRAINTS.CONSTRAINT_SCHEMA","TABLE_CONSTRAINTS.TABLE_NAME")}
        GROUP BY (TABLE_CONSTRAINTS.constraint_name)
        `;return[s,o]}$formatSchemasResult(t,e,r,i){let s=o=>o==="character varying"?"varchar":o==="integer"?"int":o,n=(o,c=!1)=>({...c?{}:{name:o.constraint_name},targetSchema:o.referenced_table_schema,targetTable:o.referenced_table_name,targetColumns:o.referenced_column_name.split(",").map(h=>h.trim()),...o.match_rule!=="NONE"?{matchRule:o.match_rule}:{},updateRule:o.update_rule,deleteRule:o.delete_rule}),f=new Map((t||[]).map(o=>[o.name,new Map([].concat(o.tables||[]).map(c=>[c,null]))]));for(let o of e)f.has(o.table_schema)||f.set(o.table_schema,new Map),f.get(o.table_schema).get(o.table_name)?f.get(o.table_schema).get(o.table_name).columns.push(o):f.get(o.table_schema).set(o.table_name,{columns:[o],constraints:r.filter(c=>c.table_schema===o.table_schema&&c.table_name===o.table_name),indexes:i.filter(c=>c.table_schema===o.table_schema&&c.table_name===o.table_name)});return[...f.entries()].map(([o,c])=>({name:o,tables:[...c.entries()].map(([l,m])=>{let E=m.columns.map(O=>O.column_name),A=O=>{O.check_clause||(O.check_clause="");let I=(O.check_clause.replace(/(["'])(?:(?=(\\?))\2.)*?\1/g,"").match(/\w+/g)||[]).map(w=>w.toLowerCase());return O.columns=Lt(E,I),O},[N,S,d,R]=m.constraints.reduce(([O,I,w,D],y)=>y.constraint_type==="PRIMARY KEY"?[O.concat(y),I,w,D]:y.constraint_type==="UNIQUE"?[O,I.concat(y),w,D]:y.constraint_type==="FOREIGN KEY"?[O,I,w.concat(y),D]:y.constraint_type==="CHECK"&&!(this.params.dialect==="postgres"&&/^[\d_]+not_null/.test(y.constraint_name))?[O,I,w,D.concat(A(y))]:[O,I,w,D],[[],[],[],[]]),x={name:l,columns:m.columns.reduce((O,I)=>{let w={},D=I.extra?.split(",").map(y=>y.trim())||[];return O.concat({name:I.column_name,type:I.character_maximum_length?[s(I.data_type),I.character_maximum_length]:s(I.data_type),...N.length===1&&N[0].column_name===I.column_name&&(w.pKeys=N.pop())?{primaryKey:{name:w.pKeys.constraint_name}}:{},...(w.uKeys=S.filter(y=>y.column_name===I.column_name)).length===1&&(S=S.filter(y=>y!==w.uKeys[0]))?{uniqueKey:{name:w.uKeys[0].constraint_name}}:{},...(w.fKeys=d.filter(y=>y.column_name===I.column_name)).length===1&&(d=d.filter(y=>y!==w.fKeys[0]))?{references:n(w.fKeys[0])}:{},...(w.cKeys=R.filter(y=>y.check_constraint_level!=="Table"&&y.columns.length===1&&y.columns[0]===I.column_name)).length===1&&(R=R.filter(y=>y!==w.cKeys[0]))?{check:{name:w.cKeys[0].constraint_name,expr:w.cKeys[0].check_clause}}:{},...I.is_identity==="YES"?{identity:{always:I.identity_generation==="ALWAYS"}}:{},...I.is_generated!=="NEVER"?{expression:{always:I.is_generated==="ALWAYS",expr:I.generation_expression}}:{},...D.includes("auto_increment")?{autoIncrement:!0}:{},...I.is_nullable==="NO"?{notNull:!0}:{},...I.column_default&&I.column_default!=="NULL"?{default:{expr:I.column_default}}:{},...D.includes("INVISIBLE")?{flags:["INVISIBLE"]}:{}})},[]),constraints:[],indexes:[]};return x.constraints.push(...[...N,...S,...d].map(O=>({name:O.constraint_name,type:O.constraint_type==="UNIQUE"?"UNIQUE_KEY":O.constraint_type.replace(" ","_"),columns:O.column_name.split(",").map(I=>I.trim()),...O.constraint_type==="FOREIGN KEY"?{references:n(O,!0)}:{}}))),x.constraints.push(...R.map(O=>({name:O.constraint_name,type:O.constraint_type,columns:O.columns,expr:O.check_clause}))),x})}))}};self.webqit||(self.webqit={});self.webqit.ObjectiveSQL={SQL:Ce};})();
//# sourceMappingURL=main.js.map
