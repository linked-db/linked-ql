(()=>{var ai=Object.defineProperty;var be=(u,e)=>{for(var t in e)ai(u,t,{get:e[t],enumerable:!0})};var oa={};be(oa,{CTE:()=>er,CTEItem:()=>tr,CTEItemAlias:()=>rr,PGCycleClause:()=>Xt,PGSearchClause:()=>Zt});function _e(u){return!Array.isArray(u)&&typeof u=="object"&&u}function V(u,e,t=!1,r=null){if(Array.isArray(u)&&Array.isArray(e))return u.length===e.length&&(e=e.slice(0).sort())&&u.slice(0).sort().every((s,n)=>V(s,e[n],t,r));if(typeof u?.jsonfy=="function"&&(u=u.jsonfy()),typeof e?.jsonfy=="function"&&(e=e.jsonfy()),_e(u)&&_e(e)){let s={indexs_a:Object.keys(u),indexs_b:Object.keys(e)};if(r?.length){let n=[].concat(r);s.indexs_a=s.indexs_a.filter(a=>!n.includes(a)),s.indexs_b=s.indexs_b.filter(a=>!n.includes(a))}return s.indexs_a.length===s.indexs_b.length&&s.indexs_a.reduce((n,a)=>n&&V(u[a],e[a],t,r),!0)}return typeof u=="string"&&typeof e=="string"&&t===!1?u.toLowerCase()===e.toLowerCase():u===e}function Ga(u){let e=u.replace(/([a-z0-9])([A-Z])/g,"$1_$2");return e=e.replace(/([A-Z])([A-Z][a-z])/g,"$1_$2"),e.toUpperCase()}var aa={};be(aa,{TOK_TYPES:()=>Lt,aggrFunctionNames:()=>mi,dataTypes:()=>yi,functionNames:()=>pi,keywords:()=>fi,operators:()=>zt,statements:()=>ci});var Lt={data_type:{type:"data_type",value:void 0,resolve(){return this}},identifier:{type:"identifier",value:void 0,delim:[void 0],resolve({dialect:u,mysqlAnsiQuotes:e}={}){return{...this,delim:this.delim.concat(u==="mysql"?e?['"',"`"]:["`"]:['"'])}}},keyword:{type:"keyword",value:void 0,resolve(){return this}},operator:{type:"operator",value:void 0,prec:void 0,assoc:void 0,resultType:void 0,resolve(){return this}},punctuation:{type:"punctuation",value:void 0,resolve(){return this}},string_literal:{type:"string_literal",value:void 0,delim:["'"],modifier:[void 0],resolve({dialect:u,mysqlAnsiQuotes:e}={}){return{...this,delim:this.delim.concat(u==="mysql"?e?[]:['"']:[/^(\$\$|\$[a-zA-Z_][a-zA-Z0-9_]*\$)$/]),modifier:this.modifier.concat(u==="mysql"?["N"]:["E"])}}},number_literal:{type:"number_literal",value:void 0,match({value:u}){return!!/^[+-]?(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?$/.test(u)}},null_literal:{type:"null_literal",value:void 0,resolve(){return this}},unknown_literal:{type:"unknown_literal",value:void 0,resolve(){return this}},bool_literal:{type:"bool_literal",value:void 0,resolve(){return this}},hex_literal:{type:"hex_literal",value:void 0,resolve(){return this}},bit_literal:{type:"bit_literal",value:void 0,resolve(){return this}},bind_var:{type:"bind_var",value:void 0,delim:[],resolve({dialect:u}={}){return{...this,delim:this.delim.concat(u==="mysql"?["?"]:["$"])}}},version_spec:{type:"version_spec",value:void 0,delim:[void 0,"'"],resolve(){return this}},user_var:{type:"user_var",value:void 0,delim:[void 0],resolve({dialect:u}={}){return{...this,delim:this.delim.concat(u==="mysql"?["'"]:[])}}},system_var:{type:"system_var",value:void 0,resolve(){return this}},brace_block:{type:"brace_block",value:void 0,resolve(){return this}},bracket_block:{type:"bracket_block",value:void 0,resolve(){return this}},parent_block:{type:"paren_block",value:void 0,resolve(){return this}},block_comment:{type:"block_comment",value:void 0,resolve(){return this}},line_comment:{type:"line_comment",value:void 0,delim:["--"],resolve({dialect:u}={}){return{...this,delim:this.delim.concat(u==="mysql"?["#"]:[])}}}},ci={common:["ALTER","CREATE","DROP","SELECT","INSERT","UPSERT","UPDATE","MERGE","DELETE","BEGIN","COMMIT","ROLLBACK","RELEASE","DESCRIBE","EXPLAIN","USE"],postgres:["ANALYZE","CLUSTER","COMMENT ON","REFRESH","REINDEX","VACUUM"],mysql:["ANALYZE","FLUSH","LOCK","OPTIMIZE","RENAME","REPAIR","RESET","SET","SHOW","TRUNCATE","UNLOCK"]},fi={common:["ALL","ON","NO","KEY","ANY","AS","BY","ASC","CASE","CAST","DEFAULT","DESC","DO","DISTINCT","ELSE","END","ESCAPE","EXISTS","FIRST","LAST","FOLLOWING","FOR","HAVING","FILTER","SHARE","UNIQUE","JOIN","SEPARATOR","SKIP","LOCKED","NOWAIT","OF","RECURSIVE","LIMIT","LOAD","NEXT","NOTHING","NULLS","OFFSET","ONLY","TIES","OVER","PARTITION","PRECEDING","RANGE","RETURNING","ROW","ROWS","INCLUDE","EXCLUDE","SET","SOME","THEN","USING","MATERIALIZED","MODE","TEMPORARY","MATCH","PARTIAL","SIMPLE","WITHIN","BOTH","CHECK","PRIMARY","FOREIGN","CONSTRAINT","REFERENCES","INHERITS","DATABASE","TABLE","COLUMN","INDEX","SEQUENCE","TRIGGER","VIEW","SAVEPOINT","VALUES","WHEN","WHERE","WINDOW","WITH","WITHOUT","TO","TABLESPACE","INTO","FROM","GROUP","ORDER","PARTITION","BREADTH","DEPTH","GENERATED","ALWAYS","INNER","LEFT","RIGHT","OUTER","FULL","CROSS","NATURAL","NO OTHERS","NO INHERIT","ROLLUP","UNBOUNDED","CURRENT ROW","GROUPS","IGNORE","RESPECT","CHARACTER SET","NO ACTION","SET NULL","SET DEFAULT","RESTRICT","CASCADE","STORED","GIST","SCHEMA"],postgres:["ARRAY","GROUPING SETS","CUBE","TABLESAMPLE","REPEATABLE","SEARCH","LATERAL","ORDINALITY","OVERLAPS","SIMILAR","BERNOULLI","SYSTEM","UNLOGGED","PERFORM","CURRENT OF","TYPE","EXTENSION","IMMUTABLE","STABLE","VOLATILE","CYCLE","CONFLICT","TEMP","TIME ZONE","FETCH","LOCAL","IDENTITY","DEFERRABLE","INITIALLY","DEFERRED","IMMEDIATE","AUTHORIZATION","CURRENT_ROLE","CURRENT_USER","SESSION_USER"],mysql:["LOCK","RENAME","REPLACE","SHOW","UNLOCK","VIRTUAL","VISIBLE","INVISIBLE","HIGH_PRIORITY","CACHE","SQL_CACHE","SQL_NO_CACHE","STRAIGHT_JOIN","COMMENT","DATABASES","TABLES","COLUMNS","PROCEDURE","FUNCTION","AUTO_INCREMENT","CHARACTER SET","ENGINE","VALUE","DUPLICATE"]},pi={common:["NOW","CURRENT_DATE","CURRENT_TIME","CURRENT_TIMESTAMP","IF","NULLIF","IFNULL","COALESCE","GREATEST","LEAST","CONCAT","GROUPING","CONCAT_WS","FORMAT","UNNEST","MD5","SHA1","ST_ASTEXT","ST_ASGEOJSON","ST_GEOMFROMTEXT","ST_WITHIN","ST_CONTAINS","ST_INTERSECTS","ST_DISTANCE","ST_BUFFER"],postgres:["MAKE_DATE","MAKE_TIME","MAKE_TIMESTAMP","TO_JSON","TO_JSONB","JSON_TYPEOF","JSONB_TYPEOF","JSON_BUILD_ARRAY","JSONB_BUILD_ARRAY","JSON_BUILD_OBJECT","JSONB_BUILD_OBJECT","JSON_POPULATE_RECORD","JSONB_POPULATE_RECORD","JSON_PATH_QUERY","JSON_PATH_EXISTS"],mysql:["CURDATE","CURTIME","SYSDATE","STR_TO_DATE","MAKEDATE","MAKETIME","JSON_ARRAY","JSON_OBJECT","JSON_EXTRACT","JSON_UNQUOTE","JSON_SET","JSON_INSERT","JSON_REPLACE","JSON_REMOVE","JSON_SEARCH","JSON_CONTAINS","JSON_CONTAINS_PATH","JSON_KEYS","JSON_ARRAY_APPEND","JSON_ARRAY_INSERT","JSON_DEPTH","JSON_LENGTH","JSON_MERGE_PRESERVE","JSON_MERGE_PATCH","JSON_PRETTY","JSON_STORAGE_FREE"]},mi={common:["COUNT","SUM","AVG","MIN","MAX","COVAR_POP","COVAR_SAMP","CORR","ROW_NUMBER","BIT_AND","BIT_OR","STDDEV_POP","STDDEV_SAMP","VAR_POP","VAR_SAMP","VARIANCE","STD","LEAD","LAG","NTILE","FIRST_VALUE","LAST_VALUE"],postgres:["ARRAY_AGG","STRING_AGG","REGR_SLOPE","PERCENTILE_CONT","PERCENTILE_DISC","MODE","RANK","DENSE_RANK","EVERY","BOOL_AND","BOOL_OR","JSON_AGG","JSON_OBJECT_AGG","JSONB_OBJECT_AGG","XMLAGG"],mysql:["GROUP_CONCAT","BIT_XOR","JSON_ARRAYAGG","JSON_OBJECTAGG"]},yi={common:["SMALLINT","INTEGER","INT","BIGINT","DECIMAL","DEC","NUMERIC","REAL","FLOAT","DATE","TIME","TIMESTAMP","INTERVAL","CHAR","CHARACTER","VARCHAR","TEXT","BINARY","VARBINARY","BOOLEAN","JSON","GEOMETRY","POINT","LINESTRING","POLYGON","DOUBLE PRECISION","CHARACTER VARYING","BYTEA","ENUM"],postgres:["SERIAL","BIGSERIAL","MONEY","BIT","CIDR","INET","MACADDR","MACADDR8","TIMESTAMPTZ","TIMETZ","TSVECTOR","TSQUERY","UUID","XML","INT4RANGE","INT8RANGE","NUMRANGE","TSRANGE","TSTZRANGE","DATERANGE","BOX","PATH","CIRCLE","LINE","LSEG","POLYGON","OID","BIT VARYING","JSONB","REGCLASS"],mysql:["TINYINT","MEDIUMINT","BIT","YEAR","DATETIME","TINYTEXT","QUERY","MEDIUMTEXT","LONGTEXT","TINYBLOB","BLOB","MEDIUMBLOB","LONGBLOB","GEOMETRYCOLLECTION","MULTIPOINT","MULTILINESTRING","MULTIPOLYGON","BOOL"]},zt={common:[["<~",{prec:90,assoc:"left",resultType:":right"}],["~>",{prec:90,assoc:"right",resultType:":right"}],["BETWEEN",{prec:85,assoc:"left",resultType:"boolean"}],["NOT",{prec:80,assoc:"right",resultType:"boolean"}],["*",{prec:70,assoc:"left",resultType:"number"}],["/",{prec:70,assoc:"left",resultType:"number"}],["%",{prec:70,assoc:"left",resultType:"number"}],["+",{prec:60,assoc:"left",resultType:"number"}],["-",{prec:60,assoc:"left",resultType:"number"}],["&",{prec:60,assoc:"left",resultType:"number"}],["|",{prec:60,assoc:"left",resultType:"number"}],["<<",{prec:60,assoc:"left",resultType:"number"}],[">>",{prec:60,assoc:"left",resultType:"number"}],["=",{prec:50,assoc:"left",resultType:"boolean"}],["!=",{prec:50,assoc:"left",resultType:"boolean"}],["<>",{prec:50,assoc:"left",resultType:"boolean"}],["<",{prec:50,assoc:"left",resultType:"boolean"}],["<=",{prec:50,assoc:"left",resultType:"boolean"}],[">",{prec:50,assoc:"left",resultType:"boolean"}],[">=",{prec:50,assoc:"left",resultType:"boolean"}],["IS",{prec:50,assoc:"left",resultType:"boolean"}],["IS NOT",{prec:50,assoc:"left",resultType:"boolean"}],["DISTINCT FROM",{prec:50,assoc:"left",resultType:"boolean"}],["IN",{prec:50,assoc:"left",resultType:"boolean"}],["LIKE",{prec:50,assoc:"left",resultType:"boolean"}],["AND",{prec:40,assoc:"left",resultType:"boolean"}],["OR",{prec:30,assoc:"left",resultType:"boolean"}],["INTERSECT",{prec:20,assoc:"left",resultType:"set",isSetOp:!0}],["UNION",{prec:10,assoc:"left",resultType:"set",isSetOp:!0}],["EXCEPT",{prec:10,assoc:"left",resultType:"set",isSetOp:!0}]],postgres:[["COLLATE",{prec:83,assoc:"left",resultType:"string"}],["||",{prec:60,assoc:"left",resultType:"string"}],["::",{prec:100,assoc:"left",resultType:"casted"}],["AT",{prec:95,assoc:"left",resultType:"timestamptz"}],["^",{prec:90,assoc:"left",resultType:"number"}],["#",{prec:60,assoc:"left",resultType:"number"}],["->",{prec:80,assoc:"left",resultType:"json"}],["->>",{prec:80,assoc:"left",resultType:"text"}],["#>",{prec:80,assoc:"left",resultType:"json"}],["#>>",{prec:80,assoc:"left",resultType:"text"}],["@>",{prec:80,assoc:"left",resultType:"boolean"}],["<@",{prec:80,assoc:"left",resultType:"boolean"}],["?",{prec:80,assoc:"left",resultType:"boolean"}],["?|",{prec:80,assoc:"left",resultType:"boolean"}],["?&",{prec:80,assoc:"left",resultType:"boolean"}],["-@",{prec:80,assoc:"left",resultType:"boolean"}],["#-",{prec:80,assoc:"left",resultType:"json"}],["@?",{prec:80,assoc:"left",resultType:"boolean"}],["@@",{prec:80,assoc:"left",resultType:"boolean"}],["ILIKE",{prec:50,assoc:"left",resultType:"boolean"}],["~",{prec:50,assoc:"left",resultType:"boolean"}],["!~",{prec:50,assoc:"left",resultType:"boolean"}],["~*",{prec:50,assoc:"left",resultType:"boolean"}],["!~*",{prec:50,assoc:"left",resultType:"boolean"}],["SIMILAR TO",{prec:50,assoc:"left",resultType:"boolean"}],["&&",{prec:60,assoc:"left",resultType:"boolean"}],["<->",{prec:60,assoc:"left",resultType:"number"}],["@",{prec:60,assoc:"left",resultType:"geometry"}],["&<",{prec:60,assoc:"left",resultType:"boolean"}],["&>",{prec:60,assoc:"left",resultType:"boolean"}],["|-",{prec:60,assoc:"left",resultType:"boolean"}],["-|",{prec:60,assoc:"left",resultType:"boolean"}],["<<",{prec:60,assoc:"left",resultType:"boolean"}],[">>",{prec:60,assoc:"left",resultType:"boolean"}],["<<|",{prec:60,assoc:"left",resultType:"boolean"}],["|>>",{prec:60,assoc:"left",resultType:"boolean"}],["&<|",{prec:60,assoc:"left",resultType:"boolean"}],["|&>",{prec:60,assoc:"left",resultType:"boolean"}],["~=",{prec:50,assoc:"left",resultType:"boolean"}],["?#",{prec:60,assoc:"left",resultType:"boolean"}],["?-",{prec:60,assoc:"left",resultType:"boolean"}],["?-|",{prec:60,assoc:"left",resultType:"boolean"}],["?|",{prec:60,assoc:"left",resultType:"boolean"}],["?||",{prec:60,assoc:"left",resultType:"boolean"}],["#",{prec:60,assoc:"left",resultType:"number"}],["##",{prec:60,assoc:"left",resultType:"geometry"}],["@-@",{prec:60,assoc:"left",resultType:"number"}]],mysql:[["DIV",{prec:70,assoc:"left",resultType:"number"}],["MOD",{prec:70,assoc:"left",resultType:"number"}],["BINARY",{prec:90,assoc:"right",resultType:"binary"}],["^",{prec:80,assoc:"left",resultType:"number"}],["~",{prec:85,assoc:"right",resultType:"number"}],["<=>",{prec:50,assoc:"left",resultType:"boolean"}],["REGEXP",{prec:50,assoc:"left",resultType:"boolean"}],["RLIKE",{prec:50,assoc:"left",resultType:"boolean"}],["!",{prec:80,assoc:"right",resultType:"boolean"}],["XOR",{prec:40,assoc:"left",resultType:"boolean"}],["&&",{prec:40,assoc:"left",resultType:"boolean"}],["||",{prec:30,assoc:"left",resultType:"boolean"}],[":=",{prec:10,assoc:"right",resultType:":right"}],["SOUNDS LIKE",{prec:50,assoc:"left",resultType:"boolean"}]]};var Mt=class{buffer="";cursor=0;line=1;column=1;mysqlBindingIndex=0;nestingContext=[];nextTokenEscape=0;next(e=1,t=!1){t&&(this.line++,this.column=0),this.column+=e,this.cursor+=e,this.nextTokenEscape===1?this.nextTokenEscape=2:this.nextTokenEscape===2&&(this.nextTokenEscape=0)}},Pt=class{#e;#t;#r=!1;#n=!1;#i=!1;#s=null;#a=[];#o;#f=[];constructor(e,{state:t,...r}={}){this.#e=e,this.#t=r}[Symbol.asyncIterator](){return this}get options(){return this.#t}get locked(){return this.#r}get started(){return this.#n}get done(){return this.#i&&!this.#f.length}previous(){return this.#a[this.#a.length-1]}current(){return this.#o}async next(){this.#m("next()"),this.#n=!0;let e,t=!1;return this.#f.length?(this.#p(this.#o),this.#o=this.#c(),e=this.#o):({value:e,done:t}=await this.#e.next(),this.#p(this.#o),this.#o=e,this.#i=t),this.#s!==null&&e?.type.endsWith("_block")&&e.value.savepoint(),{value:e,done:t}}async match(e,t=void 0){let[r,s,n]=typeof arguments[0]=="number"?arguments:[0,e,t],a=o=>o&&(Array.isArray(s)?s.includes(o.type):s===o.type)&&(n===void 0||(Array.isArray(n)?n.includes(o.value)||n.includes(void 0):n===o.value))&&o||void 0;if(r===1/0){let o=0,c;for(;c=await this.peek(o++);)if(a(c))return c;return}return a(r?await this.peek(r):this.current())}async peek(e=1){if(e===0)return this.#o;let t=e-this.#f.length;for(;t;){let s=await this.#e.next();if(s.done)break;this.#E(s.value),t--}return this.#f[e-1]}async eat(e=void 0,t=void 0){let r=e?await this.match(e,t):this.current();return r&&(await this.next())?.value,r}async expect(e,t=void 0){let r=await this.eat(e,t);if(!r)throw new Error(`Expected token: ${e}${t?` (${t})`:""}`);return r}#p(e){e?.type.endsWith("_block"),this.#s!==null?this.#a.push(e):this.#a=[e]}#c(){let e=this.#f.shift();return e?.type.endsWith("_block")&&(e.value.#r=!1),e}#g(){let e=this.#a.pop();return e?.type.endsWith("_block")&&e.value.restore(e.value.#s),e}#h(e){e?.type.endsWith("_block")&&(e.value.restore(e.value.#s),e.value.#r=!0),this.#f.unshift(e)}#E(e){e?.type.endsWith("_block")&&(e.value.#r=!0),this.#f.push(e)}#m(e){if(this.#r)throw new Error(`Can't execute ${e}; TokenStream is locked`)}savepoint(){this.#m("savepoint()");let e=this.#a.length;return this.#s===null&&(this.#s=e),e}savepointStatus(){return this.#s!==null?this.#a.length:null}restore(e){if(this.#m("restore()"),this.#s===null||typeof e!="number"||e>this.#a.length)throw new Error(`Invalid restore point ${e}${this.#s===null?". Not in savepoint mode":""}`);for(;e<this.#a.length;)this.#o&&this.#h(this.#o),this.#o=this.#g()}commit(e){if(this.#m("commit()"),e!==this.#s)return;let t;for(;e<this.#a.length&&(t=this.#g());)t.type.endsWith("_block")&&t.value.commit(t.value.#s);this.#s=null}static async create(e,{dialect:t="postgres",state:r=new Mt,...s}={}){return Array.isArray(e)&&e.every(n=>typeof n=="object"&&n?.type)&&(e=e.slice())?new this(e[Symbol.iterator](),{dialect:t,...s}):(s.normalized||(s=Wa({dialect:t,...s,normalized:!0})),new this(await this.createIterator(e,{dialect:t,state:r,...s,extendedAPI:!0}),{dialect:t,...s}))}static toIterator(e){return typeof e[Symbol.asyncIterator]=="function"?typeof e.next=="function"?e:e[Symbol.asyncIterator]():typeof e[Symbol.iterator]=="function"&&typeof e!="string"&&!(e instanceof String)?typeof e.next=="function"?e:e[Symbol.iterator]():function*(){yield e+""}()}static async*createIterator(e,{dialect:t="postgres",state:r=new Mt,...s}={}){let n=this.toIterator(e);if(!["postgres","mysql"].includes(t))throw new Error(`Unknown dialect: ${t}`);if(!(r instanceof Mt))throw new Error("options.state must be an instance of TokenStreamState");s.normalized?s={dialect:t,...s}:s=Wa({dialect:t,...s,normalized:!0});let a={token:null,prevEmittedToken:null,nextTokenSpaceBefore:"",multiwordBuffer:[]},o=(l,f=!1)=>l?Ha(l,{options:s,state:r,localState:a},f):[],c={value:""};do{r.buffer+=c.value||"";let l;for(;l=r.buffer[r.cursor];){let f=r.buffer[r.cursor+1]===void 0&&!c.done,y=qa.has(l),p=()=>{throw new SyntaxError(`Unexpected token: ${l} at line ${r.line}, column ${r.column}`)};if(a.token?.type==="hex_literal"||a.token?.type==="bit_literal"){(a.token.delim?l===a.token.delim:y)?(yield*o(a.token),a.token=null,y&&s.spaces&&(a.nextTokenSpaceBefore+=l)):(a.token?.type==="hex_literal"?/[0-9A-Fa-f]/.test(l)||p():/[01]/.test(l)||p(),a.token.value+=l),r.next();continue}if(a.token?.type==="version_spec"){let _=a.token.delim&&l===a.token.delim,x=_||y||l==="."||l===","||l===";"||l===")";if(x?(yield*o(a.token),a.token=null):(a.token.value&&(l==="="?["<",">"].includes(a.token.value)||p():l==="_"?/\d$/.test(a.token.value)||p():/\d/.test(l)||p()),a.token.value+=l),!x||_){r.next();continue}}if(y){let _=a.token?.type==="string_literal",x=a.token?.type==="identifier"&&a.token.delim,E=a.token?.type==="block_comment",S=a.token?.type==="line_comment";if(_||x||E||S&&!(l==="\r"||l===`
`))a.token.value+=l;else{let N=r.buffer[r.cursor-1];!qa.has(N)&&a.token&&(yield*o(a.token),a.token=null),s.spaces&&(a.nextTokenSpaceBefore+=l)}l===`
`||l==="\r"?r.next(1,!0):r.next();continue}if(l==="\\"){if(f)break;let _=r.buffer[r.cursor+1],x=a.token?.type==="string_literal"&&(s.dialect==="mysql"?!s.mysqlNoBackslashEscapes:a.token.modifier==="E"),E=_===a.token?.delim||_==="\\"||_==="0"||_==="b"||_==="f"||_==="n"||_==="r"||_==="t"||_==="v"||_==="Z";if(x&&E){_={"\\":"\\",0:"\0",b:"\b",f:"\f",n:`
`,r:"\r",t:"	",v:"\v",Z:""}[_]||_,a.token.value+=_,r.next(2);continue}r.nextTokenEscape=1,r.next();continue}if(a.token?.type==="block_comment"||a.token?.type==="line_comment"||a.token?.type==="string_literal"||a.token?.type==="identifier"&&a.token.delim||a.token?.type==="user_var"&&a.token.delim){let _;if(a.token.type==="block_comment"){if(l==="*"){if(f)break;_=r.buffer[r.cursor+1]==="/"?2:0}}else if(l===a.token.delim){if(a.token.type==="identifier"||a.token.type==="string_literal"&&(s.dialect==="mysql"?s.mysqlNoBackslashEscapes:a.token.modifier!=="E")){if(f)break;if(r.buffer[r.cursor+1]===l){a.token.value+=l,r.next(2);continue}}_=1}else if(a.token.type==="string_literal"&&a.token.delim.startsWith("$")&&l==="$"){let x=r.cursor+1;r.buffer.slice(x-a.token.delim.length,x)===a.token.delim&&(a.token.value=a.token.value.slice(0,-a.token.delim.length+1),_=1)}if(_){yield*o(a.token),a.token=null,r.next(_);continue}a.token.value+=l,r.next();continue}if(r.nestingContext.length&&l==={"{":"}","[":"]","(":")"}[r.nestingContext[0]]){if(yield*o(a.token,!0),r.nestingContext.shift(),s.structured){r.next(),a.nestingEndTagSeen=!0;return}a.token=null}let m,h=0,g=0;if(s.dialect==="postgres"){if(a.token?.type==="pg_possible_dollar_delim"||l==="$"){if(a.token?.type==="pg_possible_dollar_delim"){if(l==="$"){let{type:x,value:E,delim:S,...N}=a.token;a.token={type:"string_literal",value:"",delim:`$${E}$`,...N}}else a.token.value+=l;r.next();continue}if(f)break;let _=r.buffer[r.cursor+1];/[0-9]/.test(_)?m={type:"bind_var"}:m={type:"pg_possible_dollar_delim",delim:l}}}else s.dialect==="mysql"&&(l==="?"&&(m={type:"bind_var"}),l==="#"&&(m={type:"line_comment",delim:l}),l==="`"&&(m={type:"identifier",delim:l}));if(l==="'"){let _=new RegExp(`(@)$|^\\W?(${s.dialect==="postgres"?"E|X|B":"N|X"})$`,"i"),x=r.buffer.slice(Math.max(r.cursor-2,0),r.cursor).match(_),E=x?.[1]||x?.[2];if(E==="@"&&a.prevEmittedToken?.type==="identifier"){if(f)break;let S=r.buffer[r.cursor+1];/[\^~=\d<>!]/.test(S)&&(m={type:"version_spec",delim:l},h=1)}if(!m)if(E&&(E!=="@"||s.dialect==="mysql")){let S=/^(E|N)/i.test(E)?"string_literal":E==="@"?"user_var":(E==="X"?"hex_":"bit_")+"literal";m={type:S,...S==="string_literal"?{modifier:E.toUpperCase()}:{},delim:l},h=E==="@"?1:E.length}else m={type:"string_literal",delim:l}}else l==='"'&&(m={type:s.dialect!=="mysql"||s.mysqlAnsiQuotes?"identifier":"string_literal",delim:l});if(l==="@"){if(f)break;let _=r.buffer[r.cursor+1];(a.token||a.prevEmittedToken)?.type==="identifier"&&/[\^~=\d<>!]/.test(_)?m={type:"version_spec"}:s.dialect==="mysql"&&(_==="@"?(m={type:"system_var"},g=1):/[a-zA-Z_$]/.test(_)&&(m={type:"user_var"}))}if(l==="/"||l==="-"){if(f)break;let _=r.buffer[r.cursor+1];l==="/"&&_==="*"?(m={type:"block_comment"},g=1):l==="-"&&_==="-"&&(m={type:"line_comment",delim:l+_},g=1)}if(m){a.token&&!h&&(yield*o(a.token)),a.token={type:m.type,value:"",...m,line:r.line,column:h?r.column-h:r.column},r.next(1+g);continue}if((l==="{"||l==="["||l==="(")&&(yield*o(a.token),a.token=null,r.nestingContext.unshift(l),s.structured)){r.next();let _={type:{"{":"brace_block","[":"bracket_block","(":"paren_block"}[l],value:await this[s.extendedAPI?"create":"createIterator"](n,{state:r,...s}),line:r.line,column:r.column};if(yield*o(_),s.extendedAPI)await _.value.peek(1/0);else for(;!(await _.value.next()).done;);continue}if(/[0-9]/.test(l)){if(a.token?.type!=="identifier"&&a.token?.type!=="bind_var"&&a.token?.type!=="version_spec"&&!a.token?.type.endsWith("_literal")&&!a.token?.type.endsWith("_var")){if(yield*o(a.token),l==="0"){if(f)break;let _=r.buffer[r.cursor+1]?.toUpperCase();if((_==="X"||_==="B")&&s.dialect==="mysql"){a.token={type:(_==="X"?"hex_":"bit_")+"literal",value:"",line:r.line,column:r.column},r.next(2);continue}}a.token={type:"number_literal",value:l,line:r.line,column:r.column},r.next();continue}}else if(/[a-zA-Z_]/.test(l)){if(a.token?.type!=="identifier"&&!a.token?.type.endsWith("_var")&&!(a.token?.type==="number_literal"&&/\d$/.test(a.token.value)&&/E/i.test(l))){a.token?.type==="number_literal"&&p(),yield*o(a.token),a.token={type:"identifier",value:l,line:r.line,column:r.column},r.next();continue}}else{let _="operator";if(l===";"||l===","||l===":"||l==="{"||l==="}"||l==="["||l==="]"||l==="("||l===")"){if(l===":"&&(r.nestingContext[0]!=="{"||r.nextTokenEscape)?_="operator":_="punctuation",s.dialect==="postgres"&&l===":"&&_==="operator"&&a.token?.type!=="operator"){let x=r.buffer[r.cursor-1];if(f)break;let E=r.buffer[r.cursor+1];x!==":"&&/[a-zA-Z_]/.test(E)&&s.PL_SQL!==!1&&(_="user_var",l="")}}else if(l===".")if(a.token?.type==="number_literal")a.token.value.includes(".")&&p(),_="number_literal";else{if(f)break;let x=r.buffer[r.cursor+1];/\d/.test(x)?_="number_literal":(_="punctuation",a.token?.type==="system_var"&&(_="system_var"))}else(l==="+"||l==="-")&&a.token?.type==="number_literal"&&/E$/i.test(a.token.value)&&(/\+|\-/.test(a.token.value)&&p(),_="number_literal");if(a.token?.type!==_||_==="punctuation"||_==="operator"&&!s.operators.classic.has(`${a.token.value}${l}`)){yield*o(a.token),a.token={type:_,value:l,line:r.line,column:r.column},r.next();continue}}a.token.value+=l,r.next()}if(c.done)break;r.buffer=r.buffer.slice(r.cursor),r.cursor=0}while(c=await n.next());if(a.token){if(a.token.type==="operator"&&a.token.value!=="*"||a.token.type==="number_literal"&&/E$/i.test(a.token.value)||a.token.type==="block_comment"||a.token.type==="pg_possible_dollar_delim"||["string_literal","hex_literal","bit_literal","identifier","version_spec","user_var"].includes(a.token.type)&&a.token.delim)throw new SyntaxError(`Unterminated ${a.token.type} at line ${r.line}, column ${r.column}`);yield*o(a.token,!0)}if(r.nestingContext.length&&!a.nestingEndTagSeen)throw new SyntaxError(`Unterminated nesting "${r.nestingContext[0]}" at line ${r.line}, column ${r.column}`)}},qa=new Set([" ","\f",`
`,"\r","	","\v"]);function Wa(u){let e=(t,r,s,n)=>{s.split(" ").reduce((a,o)=>(a=a?`${a} ${o}`:o,t.set(a,n),a),r)};for(let t of["statements","functionNames","aggrFunctionNames","keywords","operators","dataTypes"]){let r=["statements","functionNames","aggrFunctionNames"].includes(t)?"keywords":t,s=u[r]||{classic:new Map,compound:new Map};for(let n of["common",u.dialect==="mysql"?"mysql":"postgres"]){let a=aa[t][n];for(let o of a){let[c,l]=Array.isArray(o)?[o[0],{...o[1],value:o[0]}]:[o,{value:o}];c.includes(" ")?e(s.compound,"",c,l):s.classic.set(c,l)}}u={...u,[r]:s}}return u}function Ha(u,{options:e,state:t,localState:r},s=!1){if(r.nextTokenSpaceBefore){let{type:o,...c}=u;u={type:o,spaceBefore:r.nextTokenSpaceBefore,...c},r.nextTokenSpaceBefore=""}if(u.type==="block_comment"||u.type==="line_comment")return di(u,{options:e});let n,a=!1;if(e.dialect==="mysql"&&u.type==="bind_var")n=[{...u,value:`${++t.mysqlBindingIndex}`}];else if(u.type==="operator"){let{line:o,column:c,...l}=u;n=[{...l,...e.operators.classic.get(u.value)||{},line:o,column:c}]}else u.type==="identifier"&&!u.delim&&(n=hi(u,{options:e,state:t,localState:r},s),a=!0);return n||(n=[u]),n?.length?r.prevEmittedToken=n[0]:r.prevEmittedToken=u,!a&&n.length&&r.multiwordBuffer.length?r.multiwordBuffer.splice(0).concat(n):n}function di(u,{options:e}){return e.comments?(u.type==="block_comment"?u={...u,value:u.value.split(`
`).map(t=>t.replace(/^[ ]+\*[ ]+?/,"").trim()).join(`
`)}:u={...u,value:u.value.trim()},[u]):[]}function hi(u,{options:e,state:t,localState:r},s=!1){let n,a=r.multiwordBuffer.length,o=(a?r.multiwordBuffer.map(g=>g.value).concat(u.value).join(" "):u.value).toUpperCase(),c=g=>{for(let _ of["keywords","operators","dataTypes"]){let x=e[_][g].get(o);if(x)return[_,x]}return[]},l=g=>{let{type:_,spaceBefore:x,line:E,column:S,...N}=u;return a&&(x=r.multiwordBuffer[0].spaceBefore,E=r.multiwordBuffer[0].line,S=r.multiwordBuffer[0].column),{type:m==="dataTypes"?"data_type":m.replace(/s$/,""),...x?{spaceBefore:x}:{},...N,...g,value:o,line:E,column:S}},f=g=>{let _=l(g);a?(n=[_],r.multiwordBuffer.splice(0),a=0):n=[_]},y=g=>{let _=l(g);r.multiwordBuffer.push(_),n=[]},p=!1,[m,h]=c("compound");if(h?.value===o)f(h),p=!0;else if(h){let[g,_]=c("classic");_&&g!==m&&([m,h]=[g,_]),s?f(h):y(h),p=!0}else[m,h]=c("classic"),h&&(f(h),p=!0);if(!p&&a){let g=r.multiwordBuffer.splice(0),_=Ha(u,{options:e,state:t,localState:r});return[...g,..._]}if(!n&&/^(TRUE|FALSE|NULL|UNKNOWN)$/i.test(u.value)){let{type:g,..._}=u;n=[{type:/UNKNOWN/.test(u.value)?"unknown_literal":/NULL/i.test(u.value)?"null_literal":"bool_literal",..._,value:u.value.toUpperCase()}]}return n}var d=Object.create(null);var w=class u{static get NODE_NAME(){return Ga(this.name)}get NODE_NAME(){return this.constructor.NODE_NAME}#e;get _ast(){return this.#e}#t;get options(){return this.#t||this.#r?.options||{dialect:"postgres"}}#r;get parentNode(){return this.#r}get statementNode(){return this.#r?.statementNode}get rootNode(){return this.#r?.rootNode||this}constructor(e={},t={}){this.#e=e,this.#t=t;for(let r of Object.values(this.#e))this._adoptNodes(...[].concat(r))}_keys(){return Object.keys(this.#e).filter(e=>this.#e[e]!==void 0)}_has(e,t=void 0,r=void 0){return e in this.#e?typeof t=="number"?typeof this.#e[e][t]<"u":t?this.#e[e].some(s=>s.identifiesAs?.(t,r)):!0:!1}_get(e,t=void 0,r=void 0){if(!(e in this.#e))return;if(typeof t<"u"&&!Array.isArray(this.#e[e]))throw new Error(`Can't use index in field "${e}"; not an array.`);let s=this.#e[e];return typeof t=="number"?s=s[t]:t&&(s=s.find(n=>n.identifiesAs?.(t,r))),s}_set(e,t,r=void 0,s=void 0){let n=arguments.length>2?t:void 0,a=arguments.length>2?r:t,o=typeof n<"u"?this._get(e,n,s):void 0;return o&&this._unadoptNodes(...[].concat(o)),typeof n<"u"?this.#e[e]=o?this.#e[e].reduce((c,l)=>l===o?c.concat(a):c.concat(l),[]):this.#e[e].concat(a):this.#e[e]=a,this._adoptNodes(...[].concat(a)),!0}_delete(e,t=void 0,r=void 0){if(!(e in this.#e))return!1;if(typeof t<"u"&&!Array.isArray(this.#e[e]))throw new Error(`Can't use index in field "${e}"; not an array.`);return typeof t<"u"?this.#e[e]=this.#e[e].reduce((s,n,a)=>(typeof t=="number"?a===t:n.identifiesAs?.(t,r))?(this._unadoptNodes(n),s):s.concat(n),[]):(this._unadoptNodes(...[].concat(this.#e[e])),this.#e[e]=Array.isArray(this.#e[e])?[]:void 0),!0}_add(e,...t){if(!Array.isArray(this.#e[e]))throw new Error(`Can't add on field "${e}"; not an array.`);return this._adoptNodes(...t),this.#e[e]=this.#e[e].concat(t),!0}_adoptNodes(...e){for(let t of e)if(t instanceof u){if(t.#r&&t.#r!==this){let r=`${this.NODE_NAME}`;throw new Error(`[${r}] Illegal node operation`)}t.#r=this}}_unadoptNodes(...e){for(let t of e)if(t instanceof u){if(t.#r!==this){let r=`${this.NODE_NAME}`;throw new Error(`[${r}] Illegal node operation`)}t.#r=null}}climbTree(e){if(this.#r)return e(this.#r,()=>this.#r.climbTree(e))}walkTree(e){let t=(r,s)=>{!(r instanceof u)&&!Array.isArray(r)||e(r,s)!==r||(Array.isArray(r)?r.map(t):r.statementNode!==r&&r.walkTree(e))};for(let[r,s]of Object.entries(this.#e))t(s,r)}containsNode(e){return e?this===e.parentNode||this.containsNode(e.parentNode):!1}identifiesAs(e,t=!1){if(typeof e>"u")return!1;if(typeof e?.jsonfy=="function")return V(this.jsonfy({nodeNames:!1}),e.jsonfy({nodeNames:!1}),t)}static morphsTo(){return this}clone(e={},t=null,r=null){let s=this.jsonfy(e,t,r);return[this.constructor].concat(this.constructor.morphsTo()).reduce((o,c)=>o||c.fromJSON(s,{dialect:e.toDialect||this.options.dialect}),void 0)}deSugar(e,t={},r=null,s=null){return t={...t,deSugar:e},this.clone(t,r,s)}toDialect(e,t={},r=null,s=null){return t={...t,toDialect:e},this.clone(t,r,s)}static get syntaxRules(){return[]}static compileASTSchemaFromSyntaxRules({dialect:e="postgres"}={}){this._astSchemaCompileCache||(this._astSchemaCompileCache=new Map);let t=`${this.NODE_NAME}:${e}`;if(!this._astSchemaCompileCache.has(t)){let r,s=this.syntaxRules,n=[].concat(s);n.length===1&&Array.isArray(n[0].type)&&!n[0].as?r=n[0]:r=this._compileASTSchemaFromSyntaxRules(s,e,{trail:[this.NODE_NAME]}),this._astSchemaCompileCache.set(t,r)}return this._astSchemaCompileCache.get(t)}static _compileASTSchemaFromSyntaxRules(e,t="postgres",{trail:r=[],schemaSet:s=new Set([new Map]),assertionTrail:n={dependencies:new Set,optional:!1,assert:!1}}={}){let a=Array.isArray(e)?e:[e],o=new Set(n.dependencies),c=f=>new Set([...f].map(y=>new Map(y)));for(let[f,y]of a.entries()){if(y.dialect&&y.dialect!==t)continue;let{type:p,as:m,if:h=n.inference,value:g,arity:_,singletons:x,modifier:E,booleanfy:S,optional:N=n.optional,assert:A=n.assert,syntax:v,syntaxes:O,...T}=y,b=r.concat(`${Array.isArray(e)?f:""}${m?`<${m}>`:""}`||[]),R=b.join("."),M=Ka(T);if(M.length)throw new SyntaxError(`[${R}] Unsupported attributes in rule: "${M.join('", "')}".`);let G=typeof p=="string"&&p[0]===p[0].toLowerCase();if(m){if(!p)throw new SyntaxError(`[${R}] Field rules must have a "type" attribute of type string.`);if(v||O)throw new SyntaxError(`[${R}] Field rules ("${m}") can not have a "syntax" or "syntaxes" attribute.`);if(m==="."){if(!G)throw new SyntaxError(`[${R}] Terminal Node rules must be token-typed rules.`);if(N)throw new SyntaxError(`[${R}] Terminal Node rules can not be optional.`)}else if(E)throw new SyntaxError(`[${R}] Only Terminal Node rules can have a "modifier" attribute.`);if(G){if(![void 0,null].includes(_))throw new SyntaxError(`[${R}] Token rules can not be item-based.`);if(!Lt[p])throw new SyntaxError(`[${R}] Unknown token type "${p}".`)}else{if(g)throw new SyntaxError(`[${R}] Only token rules can have a "value" attribute.`);for(let j of[].concat(p))if(!d[j])throw new SyntaxError(`[${R}] Unknown node type "${j}".`);if(![void 0,null].includes(_)){if(_e(_)){let j=Object.keys(_);if(j.some(q=>!["min","max","eager"].includes(q)||typeof _[q]!=(q==="eager"?"boolean":"number")))throw new SyntaxError(`Invalid arity object "{ ${j.join(", ")} }" for field "${m}". Only "min: <number>", "max: <number>" and "eager: <bool>" expected.`)}else if([].concat(_).some(j=>typeof j!="number"))throw new SyntaxError(`[${R}] Invalid arity value "${[].concat(_).join(", ")}" for field "${m}". Number(s) expected.`)}}let B={rulePath:R,type:p};g&&(B.value=g),E&&(B.modifier=E),S&&(B.booleanfy=S),[void 0,null].includes(_)||(B.arity=_),x&&(B.singletons=x),N&&(B.optional=!0),A&&(B.assert=A),h&&(B.if=h),N&&n.dependencies.size&&(B.dependencies=Array.from(n.dependencies));for(let j of s)j.set(m,B);m!=="."&&N&&!y.optional&&o.add(m)}if(v||O){let B={dependencies:o,optional:N,assert:A,inference:h};if(v){s=this._compileASTSchemaFromSyntaxRules(v,t,{trail:b.concat("syntax"),schemaSet:s,assertionTrail:B});continue}let j=new Set;for(let[q,I]of O.entries()){let P=c(s),K=this._compileASTSchemaFromSyntaxRules(I,t,{trail:b.concat("syntaxes",q),schemaSet:P,assertionTrail:B});for(let J of K)j.add(J)}s=j}}let l=Array.from(s);for(let f=0;f<l.length;f++){let y=l[f],p=Object.fromEntries(y);if(!y.size){s.delete(y);continue}for(let m=f+1;m<l.length;m++){let h=l[m],g=Object.fromEntries(h);V(p,g,"cs","rulePath")&&s.delete(h)}}return s}static fromJSON(e,t={},r=null){let s=this.compileASTSchemaFromSyntaxRules(t);if(Array.isArray(s.type)){for(let y of s.type){let m=d[y].fromJSON(e,t,r);if(m)return m}return}if(e instanceof u){if(e instanceof this)return e;e=e.jsonfy()}if(!_e(e))return;let n=null;if("nodeName"in e){if(e.nodeName&&e.nodeName!==this.NODE_NAME)return;({nodeName:n,...e}=e)}let a,o=(y,p=null,m=!1)=>{if(!(!n&&t.assert!==!0&&!(t.assert instanceof RegExp&&t.assert.test(activeTrailStr)))){if(p&&(y=`[${p}] ${y}`),m){a=y;return}throw new Error(y)}},c=(y,p)=>{if(y.value!==void 0){let m=y.booleanfy?[!0,!1]:y.value;return[].concat(m).includes(p.value)}return Lt[y.type].match?.(p,t)!==!1},l=(y,p)=>{for(let m of[].concat(y.type))if(typeof m=="string"&&m[0]===m[0].toLowerCase()){if(c(y,{value:p})===!0)return p}else{let g=d[m].fromJSON(p,{...t,assert:!1});if(g)return g}},f=(y,p,m,h=!1)=>{if(m.dependencies?.length){for(let _ of m.dependencies)if(!(_ in y))return o(`Missing dependency field "${_}" required by "${p}"`,m.rulePath,h),!1}if(m.if&&!ia(m.if,y,m.rulePath))return!0;if(![void 0,null].includes(m.arity)){if(e[p]===void 0)return m.optional?(y[p]=void 0,!0):(o(`Missing required field "${p}"`,m.rulePath,h),!1);if(!Array.isArray(e[p]))return o(`Field "${p}" must be an array`,m.rulePath,h),!1;if(m.arity!==1/0){let E=e[p].length;if(_e(m.arity)){if("min"in m.arity&&E<m.arity.min)return o(`A minimum of ${m.arity.min} argument(s) expected but got ${E}`,m.rulePath,h),!1;if("max"in m.arity&&E>m.arity.max)return o(`A maximum of ${m.arity.max} argument(s) expected but got ${E}`,m.rulePath,h),!1}else if(![].concat(m.arity).includes(E))return o(`Exactly ${[].concat(m.arity).join(" or ")} argument(s) expected but got ${E}`,m.rulePath,h),!1}let _=e[p].map(E=>l(m,E)).filter(E=>E!==void 0),x=_.length;if(e[p].length>x)return x?(o(`Failed to resolve some arguments for "${p}"`,m.rulePath,h),!1):(o(`Failed to resolve any argument for "${p}"`,m.rulePath,h),!1);if(m.singletons){let E=_.find((S,N)=>_.slice(N+1).some(A=>m.singletons==="BY_KEY"?A.identifiesAs?.(S):A instanceof S.constructor));if(E)return o(`Duplicate entry of type "${E.constructor.name}"`,m.rulePath,h),!1}return y[p]=_,!0}if(e[p]===void 0)return m.optional?(y[p]=m.booleanfy?!1:void 0,!0):(o(`Missing required field "${p}"`,m.rulePath,h),!1);let g=l(m,e[p]);return g===void 0?(o(`Failed to resolve field "${p}"`,m.rulePath,h),!1):(y[p]=g,!0)};e:for(let y of s instanceof Map?[s]:s){let p=Object.create(null),m=new Map(y),h=e;if(m.has(".")){let g=m.get("."),_=Lt[g.type];if([void 0,null].includes(h.value))continue e;({value:p.value,...h}=h);for(let x of Object.keys(_))typeof _[x]!="function"&&x in h&&({[x]:p[x],...h}=h);if(c(g,p)===!1)continue e;m.delete(".")}for(let g of new Set(Object.keys(h).concat(...m.keys()))){if(!m.has(g)){if(e[g]===void 0)continue;continue e}let _=m.get(g);if(f(p,g,_,!0)===!1)continue e}return typeof r=="function"?r(p,t):new this(p,t)}o(`Failed to match any schema${a?`. ${a}`:""}`,this.NODE_NAME)}toJSON(){return this.jsonfy()}jsonfy(e={},t=null,r=null){let s=(n,a,o)=>{let c=(f=e,y=o)=>Array.isArray(a)?a.reduce((p,m,h)=>{let g=s(h,m,y);return g===void 0?p:p.concat(g)},[]):a instanceof u?a.jsonfy(f,y,r):a;if(a===void 0)return;let l=o?o.transform(a,c,n,e):c();if(l instanceof u)throw new Error('"jsonfy" transforms must return plain JSON objects.');return l};return{...e.nodeNames!==!1?{nodeName:this.NODE_NAME}:{},...Object.fromEntries(Object.entries(this.#e).reduce((n,[a,o])=>{let c=s(a,o,t);return c===void 0?n:[...n,[a,c]]},[]))}}static async toStream(e,t={}){let r=e instanceof Pt?e:await Pt.create(e,{structured:!0,spaces:!0,...t});return!r.current()&&!r.done&&await r.next(),r}static async parse(e,{left:t=void 0,minPrecedence:r=0,trail:s=[],...n}={}){let a=await this.toStream(e,n),o=a.savepoint(),c=this.syntaxRules,l,f;if((f=[].concat(c)).length===1&&Array.isArray(f[0].type)&&!f[0].as)f[0].expression?l=await this._parseAsExpression(a,f[0].type,{exprClass:f[0].expression,left:t,minPrecedence:r,trail:s.concat(this.NODE_NAME),...n}):l=await this._parseFromTypes(a,f[0].type,{left:t,minPrecedence:r,trail:s.concat(this.NODE_NAME),...n});else{let y=await this._parseFromRules(a,c,{left:t,minPrecedence:r,trail:s.concat(this.NODE_NAME),...n});y&&(l=new this(y,{...n,dialect:a.options.dialect}))}return l||a.restore(o),l}static async _parseAsExpression(e,t,{exprClass:r=1,left:s=void 0,minPrecedence:n,trail:a,...o}){if(s)throw new Error("TODO");for(s=await this._parseFromTypes(e,t,{minPrecedence:n,trail:a,...o});s;){let c=await e.match("operator");if(!c||c.prec<n||c.isSetOp&&r!==2)break;let l=await this._parseFromTypes(e,t,{left:s,minPrecedence:n,trail:a,...o});if(!l)return s;s=l}return s}static async _parseFromRules(e,t,{left:r,minPrecedence:s,trail:n,...a},o={}){let c=Array.isArray(t)?t:[t],l=0,f=s;for(let[y,p]of c.entries()){if(p.dialect&&p.dialect!==e.options.dialect){l++;continue}let{requiredSpacing:m,peek:h,type:g,value:_,syntax:x,syntaxes:E,as:S,if:N,arity:A,optionalParens:v,singletons:O,itemSeparator:T,optional:b=!1,assert:R=!1,booleanfy:M,...G}=p,B=n.concat(`${Array.isArray(t)?y:""}${S?`<${S}>`:""}`||[]),j=B.join("."),q=Ka(G);if(q.length)throw new SyntaxError(`[${j}] Unsupported attributes in rule: "${q.join('", "')}".`);let I=typeof g=="string"&&g[0]===g[0].toLowerCase(),P=S&&!I&&c[y+1]?.type==="operator"||c[y+1]?.type==="punctuation"&&c[y+1]?.value===".",K=async()=>{if(!(Array.isArray(h)&&!await Y(-1))){for(let D of[].concat(g))if(r instanceof d[D])return o[S]=r,!0;return!1}},J=()=>{let D=e.current();return m===!1&&!D?.spaceBefore||m===!0&&D?.spaceBefore||m===`
`&&/\n/.test(D?.spaceBefore)},Y=async(D=0)=>D?await e.match(h[0]+D,...h.slice(1)):await e.match(...h),k=async()=>{let D;if((D=await e.match("operator"))&&D.prec<s)return;let U=await e.eat(g,g.endsWith("_block")?void 0:_);return U?.type==="operator"&&(f=U.prec+(U.assoc==="right"?0:1)),U},$=async(D,U)=>{if(Array.isArray(g))return await this._parseFromTypes(D,g,{minPrecedence:U,trail:B,...a});let fe=d[g];if(!fe)throw new SyntaxError(`[${j}] Unknown node type <${g}>.`);return await fe.parse(D,{minPrecedence:U,trail:B,...a})},H=(D,U,fe=!1,ne=!1)=>{if(!(!R&&!ne&&a.assert!==!0&&!(a.assert instanceof RegExp&&a.assert.test(j)))){if(fe){let ue=D.current()||D.previous(),Ee=D.current()?fe===1?":":" near":" by";U+=ue?`${Ee}${typeof ue.value=="string"?` "${ue.value}"`:""} (${ue.type}) at <line ${ue.line}, column ${ue.column}>`:`${Ee} end of stream`}throw new SyntaxError(`[${j}] ${U}.`)}};if(g){if(r){if(!P||!await K())return;r=null;continue}else if(r===!1&&P){if(b){r=null;continue}return}}if(N&&!ia(N,o,j))continue;if(m!==void 0&&!J()){H(e,"Required spacing mismatch",!0);return}if(Array.isArray(h)&&!await Y()){H(e,"Peek failure",!0);return}if(S==="."){if(!g||!I)throw new SyntaxError(`[${j}] Terminal node rules must be token-typed rules.`);let D=await k();if(!D){H(e,`Token of type "${g}"${_?` and value "${_}"`:""} expected but got "${e.current()?.type}"`,!0);return}let U,fe,ne,ue,Ee,ea,ve,Le;({type:U,line:fe,column:ne,spaceBefore:ue,prec:Ee,assoc:ea,resultType:ve,...Le}=D),Object.assign(o,Le);continue}let C=e;if(typeof g=="string"&&g.endsWith("_block")){if(!(C=(await k())?.value)){if(b)continue;H(e,`Token of type "${g}" expected but got "${e.current()?.type}"`,!0);return}f=0,!C.current()&&!C.done&&await C.next()}if(![void 0,null].includes(A)){if(!S)throw new SyntaxError(`[${j}] Multi-argument field rules must have a "as" attribute.`);if(!g)throw new SyntaxError(`[${j}] Multi-argument field rules must have a "type" attribute.`);if(I)throw new SyntaxError(`[${j}] Multi-argument field rules must be node-typed rules.`);let D,U=[],fe=f;if(T?.type==="operator"){let ne=T.value&&(C.options.operators?.classic.get(T.value)||C.options.operators?.compound.get(T.value));ne?.prec&&(fe=ne?.prec+1)}for(;D=await $(C,fe);){if(O&&(O==="BY_KEY"?U.some(ue=>ue.identifiesAs?.(D)):U.some(ue=>ue instanceof D.constructor))){H(C,`Duplicate entry of type "${D.constructor.name}"`,!0,!0);return}if(U.push(D),_e(A)&&A.eager===!1&&U.length===A.max||T&&!await C.eat(T.type,T.value))break}if(A!==1/0){let ne=U.length;if(!ne&&b)continue;let ue=C.current(),Ee=ue?`. Unexpected ${ue.type}${typeof ue.value=="string"?` "${ue.value}"`:""}`:"";if(_e(A)){if("min"in A&&ne<A.min){H(C,`A minimum of ${A.min} argument(s) expected but got ${ne}${Ee}`,!0);return}if("max"in A&&ne>A.max){H(C,`A maximum of ${A.max} argument(s) expected but got ${ne}${Ee}`,!0);return}}else if(![].concat(A).includes(ne)){H(C,`Exactly ${[].concat(A).join(" or ")} argument(s) expected but got ${ne}${Ee}`,!0);return}}o[S]=U;continue}let W;if(x){let D=C.savepoint();W=await this._parseFromRules(C,x,{left:r,minPrecedence:f,trail:B.concat("syntax"),...a}),W===void 0?C.restore(D):r&&(r=null)}else if(E){for(let[D,U]of E.entries()){let fe=C.savepoint();if(W=await this._parseFromRules(C,U,{left:r,minPrecedence:f,trail:B.concat("syntaxes",D),...a}),W===void 0)C.restore(fe);else break}W!==void 0&&r&&(r=null)}else if(!(typeof g=="string"&&g.endsWith("_block")))W=I?(await k())?.value:await $(C,f);else if(!g)throw new SyntaxError(`[${j}] Rules must have a "type", "syntax" or "syntaxes" attribute.`);if(W===void 0&&!b){H(C,g?"Unexpected token":null,1);return}if(typeof g=="string"&&g.endsWith("_block")&&!C.done&&C.current())return;S?(M&&(W=W!==void 0),o[S]=W):(x||E)&&Object.assign(o,W)}if(l!==c.length)return o}static async _parseFromTypes(e,t,{left:r,minPrecedence:s,trail:n,...a}){for(let o of t)if(typeof o=="string"&&o[0]===o[0].toLowerCase()){if(await e.match(o))return await e.eat()}else{let l=d[o];if(!l)throw new SyntaxError(`[${this.NODE_NAME}] Unknown node type "${o}".`);let f=await l.parse(e,{left:r,minPrecedence:s,trail:n,...a});if(f!==void 0)return f}}toString(){return this.stringify()}stringify(e={}){return this._stringifyFromRules(this.constructor.syntaxRules,{trail:[this.NODE_NAME],...e})}_stringifyFromRules(e,{trail:t=[],startingIndentLevel:r=0,autoLineBreakThreshold:s=60,...n},a=null){let o=()=>" ",c=p=>`
${(n.tabSpaces===4?"	":" ".repeat(n.tabSpaces||2)).repeat(p)}`,l=[],f=[].concat(e),y=0;for(let[p,m]of f.entries()){if(m.dialect&&m.dialect!==this.options.dialect)continue;let{requiredSpacing:h,type:g,value:_,booleanfy:x,syntax:E,syntaxes:S,as:N,if:A,arity:v,itemSeparator:O,optional:T=!1,autoSpacing:b=h,optionalParens:R,autoIndent:M=!1,autoIndentAdjust:G=0}=m,B=t.concat(`${Array.isArray(e)?p:""}${N?`<${N}>`:""}`||[]),j=B.join("."),q=M;if(A&&!ia(A,this.#e,this.NODE_NAME))continue;let I={startingIndentLevel:r+(M?1:0)+G,autoLineBreakThreshold:s,...n},P;if([void 0,null].includes(v))if(E)P=this._stringifyFromRules(E,{trail:B.concat("syntax"),...I},a);else if(S){let k=-1;for(let[$,H]of S.entries()){let C={score:0},W=this._stringifyFromRules(H,{trail:B.concat("syntaxes",$),...I},C);typeof W=="string"&&C.score>k&&(P=W,k=C.score)}a&&(a.score+=k)}else if(N){let k=this._get(N==="."?"value":N),$=_!=null;if($&&x&&k===!0&&(k=_),$&&([].concat(_).includes(k)?a&&a.score++:k=void 0),k!==void 0){k instanceof u&&(k=k.stringify(I));let H=N==="."?{...m,...this.#e}:{...m,value:k};P=this._stringifyTerminal(H,I)}}else P=this._stringifyTerminal(m,I);else{let k=!1,$=this._get(N),H=$?.length||0;if(typeof M=="number"&&H<M&&(I.startingIndentLevel-=1),$&&((k=v===1/0)||(_e(v)?k=(!("min"in v)||H>=v.min)&&(!("max"in v)||H<=v.max):k=[].concat(v).includes(H))),k){let C=$.map(fe=>fe.stringify(I));q=M===!0||typeof M=="number"&&$.length>=M||b===`
`;let W=C.join(" "),D=I.prettyPrint&&q&&(W.length>s||W.includes(`
`))?c(I.startingIndentLevel):o(),U=O?this._stringifyTerminal(O,I):"";/^\w+$/.test(U)?U=`${D}${U}${D}`:U===";"&&I.prettyPrint?U=`${U}
${D}`:U=`${U}${D}`,P=C.join(U)}}if(g==="paren_block"&&R&&!P?.trim()){if(R===!0||n.pruneOptionalParens){a&&a.score++,y++;continue}P=""}if(P===void 0){if(T){y++;continue}return}N&&a&&a.score++;let K=!1,J=P.length>s||P.includes(`
`);if(typeof g=="string"&&g.endsWith("_block")){let k=I.prettyPrint&&M&&J,$={brace_block:"{}",bracket_block:"[]",paren_block:"()"}[g];P=[$[0],k&&!/^\s/.test(P)?c(r+1):$[0]==="{"?o():"",P,k||/^\s/.test(P)?c(r):$[1]==="}"?o():"",$[1]].join("")}else I.prettyPrint&&q&&(l.length||J)&&P!==""&&(P=[c(r+(b===`
`?0:1)),P].join(""),K=!0);let Y=l[l.length-1];P!==""&&!K&&l.length&&!/\s$/.test(Y)&&(Array.isArray(b)?b.includes(Y):b!==!1)&&(b===`
`&&I.prettyPrint?l.push(c(r)):l.push(o())),l.push(P)}if(l.length||y===f.length)return l.join("")}_stringifyTerminal(e,t={}){switch(e.type){case"data_type":return this._stringifyDataType(e,t);case"identifier":return this._stringifyIdentifier(e,t);case"keyword":return this._stringifyKeyword(e,t);case"operator":return this._stringifyOperator(e,t);case"punctuation":return this._stringifyPunctuation(e,t);case"bind_var":return this._stringifyBindVar(e,t);case"version_spec":return`@${e.value}`}if(!Array.isArray(e.type)){if(e.type.endsWith("_literal"))return this._stringifyLiteral(e,t);if(e.type.endsWith("_var"))return this._stringifyVariable(e,t);if(e.type.endsWith("_comment"))return this._stringifyComment(e,t)}return String(e.value)}_stringifyIdentifier(e){let{value:t}=e,r=['"'];this.options.dialect==="mysql"&&(this.options.mysqlAnsiQuotes?r.push("`"):r.fill("`"));let s=r.includes(e.delim)?e.delim:r[0];return e.delim||/^\d/.test(t)||!/^(\*|[\w]+)$/.test(t)?`${s}${String(t||"").replace(new RegExp(s,"g"),s.repeat(2))}${s}`:t}_stringifyKeyword(e){return String(e.value)}_stringifyOperator(e){return e.value===":"&&this.#r?.isProperty?"\\:":String(e.value)}_stringifyPunctuation(e){return String(e.value)}_stringifyDataType(e){return String(e.value)}_stringifyLiteral(e,t){let{value:r}=e;switch(e.type){case"bit_literal":return this._stringifyBitLiteral(e,t);case"hex_literal":return this._stringifyHexLiteral(e,t);case"number_literal":return this._stringifyNumberLiteral(e,t);case"string_literal":return this._stringifyStringLiteral(e,t);case"bool_literal":return/^true$/i.test(r+"")?"TRUE":"FALSE";case"null_literal":return"NULL"}return String(r)}_stringifyBindVar(e){let{value:t}=e;return this.options.dialect==="mysql"?"?":`$${t}`}_stringifyBitLiteral(e){let{value:t}=e;return this.options.dialect==="mysql"?`0b${t}`:`B'${t}'`}_stringifyHexLiteral(e){let{value:t}=e;return this.options.dialect==="mysql"?`0x${t}`:`X'${t}'`}_stringifyNumberLiteral(e){let{value:t}=e;return String(t)}_stringifyStringLiteral(e){let{value:t}=e,r=["'"],s=null;this.options.dialect==="postgres"&&e.delim?.startsWith("$")?r.fill(e.delim):this.options.dialect==="mysql"&&!this.options.mysqlAnsiQuotes&&r.push('"');let n=r.includes(e.delim)?e.delim:r[0];if((this.options.dialect==="mysql"&&!this.options.mysqlNoBackslashEscapes||this.options.dialect==="postgres"&&e.modifier==="E")&&(s="\\"),n.length>1)return`${n}${t}${n}`;if(!s)s=n;else if(s==="\\"){let a={"\\":"\\\\","\0":"\\0","\b":"\\b","\f":"\\f","\n":"\\n","\r":"\\r","	":"\\t","\v":"\\v","":"\\Z"};t=t.replace(/[\\\0\b\r\n\t\x1A]/g,o=>a[o])}return t=`${n}${(t||"").replace(new RegExp(n,"g"),`${s}${n}`)}${n}`,e.modifier?`${e.modifier}${t}`:t}_stringifyVariable(e){let{type:t,value:r}=e;return this.options.dialect==="mysql"?`${t==="system_var"?"@@":"@"}${r}`:`${this.#r?.isProperty?"\\:":":"}${r}`}_stringifyComment(e,t={}){let{value:r}=e;if(e.type==="block_comment"){let a="  ".repeat(t.startingIndentLevel||0),o=r.trim().split(`
`).map(l=>l.trim());return[`${a}/**`,...o.map(l=>`${a} * ${l}`),`${a} */`].join(`
`)}let s=["--"];return this.options.dialect==="mysql"&&s.push("#"),`${s.includes(e.delim)?e.delim:s[0]} ${r}`}},Ka=u=>Object.keys(u).filter(e=>!_i.has(e)),_i=new Set(["dialect","autoSpacing","optionalParens","autoIndent","autoIndentAdjust","type","value","delim","modifier","syntax","syntaxes","as","booleanfy","if","arity","itemSeparator","singletons","keyed","requiredSpacing","peek","optional","assert"]),ia=(u,e,t)=>[].concat(u).some(r=>{if(_e(r))return Object.entries(r).every(([n,a])=>{let o=!0;return n.startsWith("!")&&(n=n.slice(1),o=!1),(Array.isArray(a)?a.includes(e[n]):e[n]===a)===o});if(typeof r!="string")throw new SyntaxError(`[${t}] A specifier of type string or object expected in inferenceMatch but got ${r===null?"null":`type ${typeof r}`}`);let s=!0;return r.startsWith("!")&&(r=r.slice(1),s=!1),![void 0,null,!1].includes(e[r])===s});var Xt=class extends w{static get syntaxRules(){return{dialect:"postgres",syntax:[{type:"keyword",value:"CYCLE"},{assert:!0,syntax:[{type:"ColumnRef1",as:"column_names",arity:{min:1},itemSeparator:{type:"punctuation",value:","},assert:!0,autoIndent:2},{type:"keyword",value:"SET"},{type:"ColumnRef1",as:"mark_col_name"},{optional:!0,syntax:[{type:"keyword",value:"TO"},{type:"Expr",as:"mark_value"},{type:"keyword",value:"DEFAULT"},{type:"Expr",as:"mark_default"}]},{type:"keyword",value:"USING"},{type:"ColumnRef1",as:"path_col_name"}]}]}}breadthOrDepthFirst(){return this._get("breadth_or_depth_first")}columnNames(){return this._get("column_names")}markColName(){return this._get("mark_col_name")}markValue(){return this._get("mark_value")}markDefault(){return this._get("mark_default")}pathColName(){return this._get("path_col_name")}};var Zt=class extends w{static get syntaxRules(){return{dialect:"postgres",syntax:[{type:"keyword",value:"SEARCH"},{assert:!0,syntax:[{type:"keyword",as:"breadth_or_depth_first",value:["BREADTH","DEPTH"]},{type:"keyword",value:"FIRST"},{type:"keyword",value:"BY"},{type:"ColumnRef1",as:"column_names",arity:{min:1},itemSeparator:{type:"punctuation",value:","},assert:!0,autoIndent:2},{type:"keyword",value:"SET"},{type:"ColumnRef1",as:"seq_col_name"}]}]}}breadthOrDepthFirst(){return this._get("breadth_or_depth_first")}columnNames(){return this._get("column_names")}seqColName(){return this._get("seq_col_name")}};var X=u=>class extends u{#e;resultSchema(){return this.#e}static fromJSON(e,t={},r=null){if(!e||e instanceof w)return super.fromJSON(e,t,r);let{result_schema:s,...n}=e,a=super.fromJSON(n,t,r);if(a&&s){if(!(s instanceof w))throw new Error("Invalid Schema object passed at inputJson.result_schema");a.#e=s}return a}jsonfy(e={},t=null,r=null){let s=super.jsonfy(e,t,r);return this.#e&&e.resultSchemas!==!1&&(s={...s,result_schema:this.#e}),s}};var Ya=u=>class extends u{#e;originSchemas(){return this.#e}static fromJSON(e,t={},r=null){if(!e||e instanceof w)return super.fromJSON(e,t,r);let{origin_schemas:s,...n}=e,a=super.fromJSON(n,t,r);if(a&&s){if(!Array.isArray(s))throw new Error("Invalid list passed at inputJson.origin_schemas");a.#e=s}return a}jsonfy(e={},t=null,r=null){let s=super.jsonfy(e,t,r);return this.#e&&e.originSchemas!==!1&&(s={...s,origin_schemas:this.#e}),s}getOriginSchemas(e){let t=[],r=!1;for(let{resultSchema:s}of e.statementContext.artifacts.get("tableSchemas")){if(s instanceof d.JSONSchema){if(r)throw new Error("Multiple anonymous origin schemas detected");r=!0}t.push(s)}return t}};var Fe=class extends w{get statementNode(){return this}#e;get uuid(){return this.#e||(this.#e=`$query${(0|Math.random()*9e6).toString(36)}`),this.#e}static fromJSON(e,t={},r=null){if(e instanceof w)return super.fromJSON(e,t,r);let{uuid:s,...n}=e,a=super.fromJSON(n,t,r);return a&&(a.#e=s),a}jsonfy(e={},t=null,r=null){let s=super.jsonfy(e,t,r);return this.#e&&(s={uuid:this.#e,...s}),s}};var Se=class extends X(Ya(Fe)){renderBindings(e){if(!Array.isArray(e))throw new Error("Values must be an array");let t=[...this.queryBindings()];for(let r=0;r<e.length;r++){let s=t.filter(n=>n.offset()===r+1);if(!s.length)throw new Error(`No bindings exists at offset #${r}`);s.forEach(n=>n.value(e[r]))}}normalizeBindings(e=!1){let t=[...this.queryBindings()];if(!e)return t.forEach((n,a)=>n.offset(a+1)),t;let r=new Map,s=1;for(let n of t)if(n.offset()===0||!r.has(n.offset())){let a=s++;r.set(n.offset(),a),n.offset(a)}else n.offset(r.get(n.offset())).withDetail("redundant",!0);return t.filter(n=>!n.getDetail("redundant"))}};var ae=class u{#e;get cb(){return this.#e}#t=new Map;#r=new Map;#n;get parentTransformer(){return this.#n}#i;get statementNode(){return this.#i}get statementContext(){return this.#s?this:this.#n.statementContext}get rootContext(){return this.#n?.rootContext||this}#s;get isStatementContext(){return this.#s}#a=new Map([["outputSchemas",new Set],["tableSchemas",new Set],["selectorDimensions",new Map],["payloadDimensions",new Set]]);get artifacts(){return this.#a}constructor(e,t=null,r=null){this.#e=e,this.#n=t,this.#i=r,this.#s=!t||r!==t.statementNode}rand(e,{asSalt:t=!1,rands:r=this.#t}={}){return r.set(e,r.has(e)?r.get(e)+1:0),`${t?"~":"$"}${e}~${r.get(e)}`}hash(e,t,{hashes:r=this.#r}={}){return r.has(e)||r.set(e,this.rand(t)),r.get(e)}transform(e,t,r,s,n=this){let a=(o=s,c=n)=>(typeof o=="function"&&(c=new u(o,c,this.#i),o=s),n.statementNode!==this.#i?t(o,c):this.#e(e,(l=o)=>(typeof l=="function"&&(c=new u(l,c,this.#i),l=o),t(l,c)),r,o));return this.#n?this.#n.transform(e,a,r,s,n):a()}};var er=class extends Se{static get _bodyTypes(){return["SelectStmt","TableStmt","InsertStmt","UpsertStmt","UpdateStmt","DeleteStmt","ValuesConstructor"]}static get syntaxRules(){return[{type:"keyword",value:"WITH"},{type:"keyword",as:"recursive",value:"RECURSIVE",booleanfy:!0,optional:!0},{type:"CTEItem",as:"declarations",arity:{min:1},itemSeparator:{type:"punctuation",value:","},assert:!0,autoIndent:2},{type:this._bodyTypes,as:"body",assert:!0,autoSpacing:`
`}]}recursive(){return this._get("recursive")}declarations(){return this._get("declarations")}body(){return this._get("body")}jsonfy(e={},t=null,r=null){if(!e.deSugar)return super.jsonfy(e,t,r);let s;return t=new ae((a,o,c)=>{if(c==="body"&&a.parentNode===this){let l=o();return s=l.result_schema,l}return o()},t,this),{...super.jsonfy(e,t,r),result_schema:s}}};var tr=class extends Se{static get syntaxRules(){return[{type:"CTEItemAlias",as:"alias",assert:!0},{type:"keyword",value:"AS"},{optional:!0,dialect:"postgres",syntaxes:[[{type:"operator",as:"not_materialized_kw",value:"NOT",booleanfy:!0},{type:"keyword",value:"MATERIALIZED",assert:!0}],{type:"keyword",as:"materialized",value:"MATERIALIZED",booleanfy:!0}]},{type:"paren_block",syntax:{type:["SelectStmt","InsertStmt","UpsertStmt","UpdateStmt","DeleteStmt","TableStmt","ValuesConstructor"],as:"expr",autoIndent:!0}},{type:"PGSearchClause",as:"search_clause",optional:!0},{type:"PGCycleClause",as:"cycle_clause",optional:!0}]}alias(){return this._get("alias")}notMaterializedKW(){return this._get("not_materialized_kw")}materialized(){return this._get("materialized")}expr(){return this._get("expr")}searchClause(){return this._get("search_clause")}cycleClause(){return this._get("cycle_clause")}jsonfy(e={},t=null,r=null){let s=super.jsonfy(e,t,r);if(e.deSugar){let n={nodeName:d.Identifier.NODE_NAME,value:s.alias.value,delim:s.alias.delim},a=s.expr.result_schema;if(a instanceof d.TableSchema?a=a.clone({renameTo:n}):a=d.TableSchema.fromJSON({name:n,entries:a?.entries().map(o=>o.jsonfy())||[]}),s.alias.columns?.length){if(s.alias.columns.length!==a.length)throw new SyntaxError(`[${this}] Number of column aliases must match number of result columns.`);a=a.clone({},new ae((o,c,l)=>typeof l=="number"&&o.parentNode===a?o instanceof d.ColumnSchema?o.jsonfy({renameTo:s.alias.columns[l]}):{...o.jsonfy(),nodeName:d.ColumnSchema.NODE_NAME,name:s.alias.columns[l]}:c()))}t.statementContext.artifacts.get("tableSchemas").add({type:"CTEItem",resultSchema:a}),s={...s,result_schema:a}}return s}};var le=class u extends w{static get syntaxRules(){return{type:"identifier",as:"."}}static get syntaxPriority(){return-1}value(){return this._get("value")}identifiesAs(e,t=void 0){return e instanceof u?V(this.value(),e.value(),t===void 0?this._has("delim")||e._has("delim"):t):typeof e=="string"?V(this._get("value"),e,t===void 0?this._has("delim"):t):super.identifiesAs(e,t)}};var rr=class extends le{static get syntaxRules(){let e={type:"punctuation",value:","};return[{...[].concat(super.syntaxRules)[0]},{type:"paren_block",syntax:{type:"Identifier",as:"columns",arity:{min:1},itemSeparator:e,assert:!0},if:"value",optional:!0,optionalParens:!0}]}columns(){return this._get("columns")}};var la={};be(la,{CheckConstraint:()=>yr,ColumnDefaultConstraint:()=>dr,ColumnDiff:()=>sr,ColumnExpressionConstraint:()=>hr,ColumnFKConstraint:()=>_r,ColumnIdent:()=>gs,ColumnIdentityConstraint:()=>ft,ColumnNullConstraint:()=>gr,ColumnPKConstraint:()=>xr,ColumnSchema:()=>nr,ColumnUKConstraint:()=>Er,ConstraintSchema:()=>Z,CreateSchemaStmt:()=>Os,CreateTableStmt:()=>bs,DDLStmt:()=>Ae,DropSchemaStmt:()=>vs,DropTableStmt:()=>Rs,FKDeleteRule:()=>ir,FKMatchRule:()=>ar,FKUpdateRule:()=>or,IndexDiff:()=>Ss,IndexSchema:()=>Ns,MYColumnAutoIncrementModifier:()=>ct,MYColumnCommentModifier:()=>Sr,MYColumnOnUpdateModifier:()=>Nr,MYColumnVisibilityModifier:()=>wr,PGIndexParamInclude:()=>ur,PGIndexParamUsing:()=>cr,PGIndexParamWith:()=>fr,PGIndexParameters:()=>lr,PGTableEXConstraint:()=>Ar,PGTableEXConstraintItem:()=>pr,ReferentialAction:()=>mr,SchemaDiff:()=>ws,SchemaIdent:()=>xs,SchemaSchema:()=>xt,TableDiff:()=>As,TableFKConstraint:()=>Tr,TableIdent:()=>Es,TablePKConstraint:()=>Or,TableSchema:()=>Ts,TableUKConstraint:()=>vr});var L=class extends w{static get syntaxRules(){return[]}get length(){return(this._get("entries")||[]).length}[Symbol.iterator](){return(this._get("entries")||[])[Symbol.iterator]()}entries(){return(this._get("entries")||[]).slice(0)}delete(e){return this._delete("entries",e)}get(e){return this._get("entries",e)}set(e,t){return this._set("entries",e,t)}has(e){return this._has("entries",e)}add(...e){return this._add("entries",...e)}};var Re=class extends L{};var sr=class extends Re{};var Ne=class u extends L{name(){return this._get("name")}identifiesAs(e,...t){return this.name()?.identifiesAs(e instanceof u?e.name():e,...t)}static fromJSON(e,t={},r=null){if(e instanceof w)return super.fromJSON(e,t,r);let{ddl_name:s,...n}=e,a=super.fromJSON(n,t,r);if(s&&a){let o=[d.SchemaIdent,d.TableIdent,d.ColumnIdent].reduce((c,l)=>c||l.fromJSON(s),null);a._set("ddl_name",o)}return a}jsonfy({renameTo:e,...t}={},r=null,s=null){let n=super.jsonfy(t,r,s);if(e){if(e instanceof w)throw new Error("options.renameTo must be a JSON value.");return n.name?.value&&!n.ddl_name&&(n={...n,ddl_name:n.name}),{...n,name:e}}return n}};var nr=class extends Ne{static get syntaxRules(){return[{type:["ColumnIdent","Identifier"],as:"name"},{type:"DataType",as:"data_type"},{type:["CheckConstraint","ColumnDefaultConstraint","ColumnExpressionConstraint","ColumnFKConstraint","ColumnIdentityConstraint","ColumnNullConstraint","ColumnPKConstraint","ColumnUKConstraint","MYColumnAutoIncrementModifier","MYColumnCommentModifier","MYColumnOnUpdateModifier","MYColumnVisibilityModifier"],as:"entries",arity:1/0,singletons:!0,optional:!0}]}dataType(){return this._get("data_type")}defaultConstraint(){for(let e of this)if(e instanceof d.ColumnDefaultConstraint)return e}expressionConstraint(){for(let e of this)if(e instanceof d.ColumnExpressionConstraint)return e}identityConstraint(){for(let e of this)if(e instanceof d.ColumnIdentityConstraint)return e}autoIncrementConstraint(){for(let e of this)if(e instanceof d.MYColumnAutoIncrementModifier)return e}nullConstraint(){for(let e of this)if(e instanceof d.ColumnNullConstraint)return e}pkConstraint(e=!1){for(let t of this)if(t instanceof d.ColumnPKConstraint)return t;if(e&&this.parentNode instanceof d.TableSchema){let t=this.parentNode.pkConstraint(!1),r=t?.columns()||[];if(r.length===1&&r[0].identifiesAs(this.name())){let{nodeName:s,columns:n,...a}=t.jsonfy(),o=d.ColumnPKConstraint.fromJSON(a);return this._adoptNodes(o),o}}}fkConstraint(e=!1){for(let t of this)if(t instanceof d.ColumnFKConstraint)return t;if(e&&this.parentNode instanceof d.TableSchema){let{nodeName:t,columns:r,...s}=this.parentNode.fkConstraints(!1).find(n=>{let a=n.columns();return a.length===1&&a[0].identifiesAs(this.name())})?.jsonfy()||{};if(t){let n=d.ColumnFKConstraint.fromJSON(s);return this._adoptNodes(n),n}}}ukConstraint(e=!1){for(let t of this)if(t instanceof d.ColumnUKConstraint)return t;if(e&&this.parentNode instanceof d.TableSchema){let{nodeName:t,columns:r,...s}=this.parentNode.ukConstraints(!1).find(n=>{let a=n.columns();return a.length===1&&a[0].identifiesAs(this.name())})?.jsonfy()||{};if(t){let n=d.ColumnUKConstraint.fromJSON(s);return this._adoptNodes(n),n}}}ckConstraint(e=!1){for(let t of this)if(t instanceof d.CheckConstraint)return t;if(e&&this.parentNode instanceof d.TableSchema){let t=this.parentNode.ckConstraints(!1).find(r=>{let s=r.columns();return s.length===1&&s[0].identifiesAs(this.name())});if(t=t?.clone())return this._adoptNodes(t),t}}jsonfy({normalized:e=!1,...t}={},r=null,s=null){let n=super.jsonfy(t,r,s);if(e){let a=[];for(let o of["pk","fk","uk","ck"]){let c=`${o}Constraint`;this[c]()||a.push(this[c](!0)?.jsonfy())}if((a=a.filter(o=>o)).length)return{...n,entries:n.entries.concat(a)}}return n}};var ar=class extends w{static get syntaxRules(){return[{type:"keyword",value:"MATCH"},{type:"keyword",as:"value",value:["FULL","PARTIAL","SIMPLE"],assert:!0}]}value(){return this._get("value")}};var ir=class extends w{static get syntaxRules(){return[{type:"keyword",value:"ON"},{type:"keyword",value:"DELETE"},{type:"ReferentialAction",as:"action",assert:!0}]}action(){return this._get("action")}};var or=class extends w{static get syntaxRules(){return[{type:"keyword",value:"ON"},{type:"keyword",value:"UPDATE"},{type:"ReferentialAction",as:"action",assert:!0}]}action(){return this._get("action")}};var lr=class extends L{static get syntaxRules(){return[{type:["PGIndexParamInclude","PGIndexParamUsing","PGIndexParamWith"],as:"entries",arity:1/0,singletons:!0}]}};var ur=class extends L{static get syntaxRules(){return[{type:"keyword",value:"INCLUDE"},{type:"paren_block",syntax:{type:"ColumnRef2",as:"entries",arity:{min:1},itemSeparator:{type:"punctuation",value:","}}}]}};var cr=class extends w{static get syntaxRules(){return[{type:"keyword",value:"USING"},{type:"keyword",value:"INDEX"},{type:"keyword",value:"TABLESPACE"},{type:"identifier",as:"."}]}};var fr=class extends L{static get syntaxRules(){return[{type:"keyword",value:"WITH"},{type:"paren_block",syntax:{type:"ConfigAssignmentExprAlt2",as:"entries",arity:{min:1},itemSeparator:{type:"punctuation",value:","}}}]}};var Z=class extends Ne{static buildSyntaxRules(e){return[{optional:!0,syntax:[{type:"keyword",value:"CONSTRAINT"},{type:"Identifier",as:"name",assert:!0}]},...e,{optional:!0,dialect:"postgres",syntaxes:[[{type:"operator",as:"pg_deferrable",value:"NOT"},{type:"keyword",value:"DEFERRABLE"}],{type:"keyword",as:"pg_deferrable",value:"DEFERRABLE"}]},{optional:!0,dialect:"postgres",syntax:[{type:"keyword",value:"INITIALLY"},{type:"keyword",as:"pg_deferred",value:["DEFERRED","IMMEDIATE"]}]}]}static get syntaxRules(){return{type:["TableFKConstraint","TablePKConstraint","TableUKConstraint","CheckConstraint","ColumnDefaultConstraint","ColumnExpressionConstraint","ColumnFKConstraint","ColumnIdentityConstraint","ColumnNullConstraint","ColumnPKConstraint","ColumnUKConstraint"]}}get isColumnLevel(){return this.parentNode instanceof d.ColumnSchema}pgDeferrable(){return this._get("pg_deferrable")}pgDeferred(){return this._get("pg_deferred")}};var pr=class extends Z{static get syntaxRules(){return[{syntaxes:[{type:"ColumnRef2",as:"expr"},{type:"ParenExpr",as:"expr"}]},{optional:!0,syntax:[{type:"operator",value:"COLLATE"},{type:"string_literal",as:"collation",assert:!0}]},{optional:!0,syntax:[{type:"Identifier",as:"opclass"},{optional:!0,type:"paren_block",syntax:{type:"ConfigAssignmentExpr",as:"opclass_parameters",arity:{min:1},itemSeparator:{type:"punctuation",value:","},assert:!0}}]},{type:"keyword",value:["ASC","DESC"],as:"dir",optional:!0},{optional:!0,syntax:[{type:"keyword",value:"NULLS"},{type:"keyword",as:"nulls_spec",value:["FIRST","LAST"],assert:!0}]},{type:"keyword",value:"WITH"},{type:"operator",as:"operator"}]}expr(){return this._get("expr")}collation(){return this._get("collation")}opclass(){return this._get("opclass")}opclassParameters(){return this._get("opclass_parameters")}dir(){return this._get("dir")}nullsSpec(){return this._get("nulls_spec")}operator(){return this._get("operator")}};var mr=class extends w{static get syntaxRules(){return{syntaxes:[{type:"keyword",as:"value",value:["NO ACTION","RESTRICT","CASCADE"]},[{type:"keyword",as:"value",value:["SET NULL","SET DEFAULT"]},{optional:!0,dialect:"postgres",type:"paren_block",syntax:{type:"Identifier",as:"columns",arity:{min:1},itemSeparator:{type:"punctuation",value:","}}}]]}}value(){return this._get("value")}columns(){return this._get("columns")}};var yr=class extends Z{static get syntaxRules(){return this.buildSyntaxRules([{type:"keyword",value:"CHECK"},{type:"paren_block",syntax:{type:"Expr",as:"expr",assert:!0},assert:!0},{type:"keyword",as:"no_inherit_kw",value:"NO INHERIT",optional:!0}])}expr(){return this._get("expr")}noInheritKW(){return this._get("no_inherit_kw")}columns(){let e=[];return this.expr()?.walkTree(t=>{if(t instanceof d.ColumnRef1)e.push(d.ColumnRef2.fromJSON({value:t.value()}));else return t}),e}};var dr=class extends Z{static get syntaxRules(){return this.buildSyntaxRules([{type:"keyword",value:"DEFAULT"},{type:"Expr",as:"expr",assert:!0,dialect:"postgres"},{type:["NumberLiteral","StringLiteral","NullLiteral","BoolLiteral","CallExpr","RowConstructor"],as:"expr",assert:!0,dialect:"mysql"}])}expr(){return this._get("expr")}};var hr=class extends Z{static get syntaxRules(){return this.buildSyntaxRules([{dialect:"postgres",syntax:[{type:"keyword",value:"GENERATED"},{type:"keyword",value:"ALWAYS"},{type:"keyword",value:"AS"},{type:"paren_block",syntax:{type:"Expr",as:"expr",assert:!0}},{type:"keyword",as:"stored",value:"STORED",assert:!0}]},{dialect:"mysql",syntax:[{optional:!0,syntax:[{type:"keyword",as:"my_generated_kw",value:"GENERATED",booleanfy:!0},{type:"keyword",value:"ALWAYS"}]},{type:"keyword",value:"AS"},{type:"paren_block",syntax:{type:"Expr",as:"expr",assert:!0}},{type:"keyword",as:"stored",value:["STORED","VIRTUAL"],optional:!0}]}])}myGeneratedKW(){return this._get("my_generated_kw")}expr(){return this._get("expr")}stored(){return this._get("stored")}};var{ColumnSchema:gi,ColumnRef2:xi}=d,_r=class extends Z{static get syntaxRules(){let e={type:"punctuation",value:","};return this.buildSyntaxRules([{type:"keyword",value:"REFERENCES"},{type:"TableRef2",as:"target_table",assert:!0},{dialect:"postgres",optional:!0,type:"paren_block",syntax:{type:"Identifier",as:"target_columns",arity:1,itemSeparator:e,singletons:"BY_KEY",assert:!0}},{dialect:"mysql",type:"paren_block",syntax:{type:"Identifier",as:"target_columns",arity:1,itemSeparator:e,singletons:"BY_KEY",assert:!0}},{type:["FKMatchRule","FKDeleteRule","FKUpdateRule"],as:"referential_rules",arity:1/0,singletons:!0}])}targetTable(){return this._get("target_table")}targetColumns(){return this._get("target_columns")}referentialRules(){return this._get("referential_rules")}columns(){return this.parentNode instanceof gi?[xi.fromJSON({value:this.parentNode.name().value()})]:[]}};var ct=class extends w{static get syntaxRules(){return{dialect:"mysql",syntax:{type:"keyword",as:".",value:"AUTO_INCREMENT"}}}jsonfy(e={},t=null,r=null){return(e.toDialect||this.options.dialect)==="postgres"?new ft().jsonfy(e,t,r):super.jsonfy(e,t,r)}};var ft=class extends Z{static get syntaxRules(){return this.buildSyntaxRules([{type:"keyword",value:"GENERATED"},{syntaxes:[{type:"keyword",as:"always_kw",value:"ALWAYS",booleanfy:!0},{syntax:[{type:"keyword",as:"by_default_kw",value:"BY",booleanfy:!0},{type:"keyword",value:"DEFAULT",assert:!0}]}]},{optional:!0,syntax:[{type:"keyword",as:"as_identity_kw",value:"AS",booleanfy:!0},{type:"keyword",value:"IDENTITY",assert:!0}]}])}alwaysKW(){return this._get("always_kw")}byDefaultKW(){return this._get("by_default_kw")}asIdentityKW(){return this._get("as_identity_kw")}jsonfy(e={},t=null,r=null){return(e.toDialect||this.options.dialect)==="mysql"?new ct().jsonfy(e,t,r):super.jsonfy(e,t,r)}};var gr=class extends Z{static get syntaxRules(){return this.buildSyntaxRules([{syntaxes:[[{type:"operator",as:".",value:"NOT"},{type:"null_literal",value:"NULL"}],{type:"null_literal",as:".",value:"NULL"}]}])}value(){return this._get("value")}};var xr=class extends Z{static get syntaxRules(){return this.buildSyntaxRules([{type:"keyword",value:"PRIMARY"},{type:"keyword",as:".",value:"KEY",assert:!0},{type:"PGIndexParameters",as:"pg_index_parameters",optional:!0,dialect:"postgres"}])}primaryKW(){return this._get("primary_kw")}pgIndexParameters(){return this._get("pg_index_parameters")}columns(){return this.parentNode instanceof d.ColumnSchema?[d.ColumnRef2.fromJSON({value:this.parentNode.name().value()})]:[]}};var Er=class extends Z{static get syntaxRules(){return this.buildSyntaxRules([{type:"keyword",value:"UNIQUE"},{type:"keyword",as:"my_key_kw",value:["KEY","INDEX"],optional:!0,dialect:"mysql"},{optional:!0,dialect:"postgres",syntaxes:[[{type:"keyword",value:"NULLS"},{type:"operator",as:"pg_nulls_distinct",value:"NOT"},{type:"keyword",value:"DISTINCT",assert:!0}],[{type:"keyword",value:"NULLS"},{type:"keyword",as:"pg_nulls_distinct",value:"DISTINCT",assert:!0}]]},{type:"PGIndexParameters",as:"pg_index_parameters",optional:!0,dialect:"postgres"}])}myKeyKW(){return this._get("my_key_kw")}pgNullsDistinct(){return this._get("pg_nulls_distinct")}pgIndexParameters(){return this._get("pg_index_parameters")}columns(){let{ColumnSchema:e,ColumnRef2:t}=d;return this.parentNode instanceof e?[t.fromJSON({value:this.parentNode.name().value()})]:[]}};var Sr=class extends w{static get syntaxRules(){return{dialect:"mysql",syntax:[{type:"keyword",value:"COMMENT"},{type:"string_literal",as:"."}]}}};var Nr=class extends w{static get syntaxRules(){return{dialect:"mysql",syntax:[{type:"keyword",value:"ON"},{type:"keyword",value:"UPDATE"},{type:"keyword",as:"."}]}}};var wr=class extends w{static get syntaxRules(){return{dialect:"mysql",syntaxes:[{type:"keyword",as:".",value:"VISIBLE"},{type:"keyword",as:".",value:"INVISIBLE"}]}}};var Ar=class extends Z{static get syntaxRules(){let e={type:"punctuation",value:","};return{dialect:"postgres",syntax:this.buildSyntaxRules([{type:"keyword",value:"EXCLUDE"},{optional:!0,syntax:[{type:"keyword",value:"USING"},{type:"keyword",as:"index_method",assert:!0}]},{type:"paren_block",syntax:{type:"PGTableEXConstraintItem",as:"entries",arity:{min:1},itemSeparator:e,assert:!0},assert:!0},{type:"PGIndexParameters",as:"pg_index_parameters",optional:!0},{optional:!0,syntax:[{type:"keyword",value:"WHERE"},{type:"paren_block",syntax:{type:"Expr",as:"where_predicate",assert:!0},assert:!0}]}])}}indexMethod(){return this._get("index_method")}entries(){return this._get("entries")}pgIndexParameters(){return this._get("pg_index_parameters")}wherePredicate(){return this._get("where_predicate")}};var Tr=class extends Z{static get syntaxRules(){let e={type:"punctuation",value:","};return this.buildSyntaxRules([{type:"keyword",value:"FOREIGN"},{type:"keyword",value:"KEY",assert:!0},{type:"paren_block",syntax:{type:"ColumnRef2",as:"columns",arity:{min:1},itemSeparator:e,assert:!0,singletons:"BY_KEY"}},{type:"keyword",value:"REFERENCES"},{type:"TableRef2",as:"target_table",assert:!0},{dialect:"postgres",optional:!0,type:"paren_block",syntax:{type:"Identifier",as:"target_columns",arity:{min:1},itemSeparator:e,singletons:"BY_KEY",assert:!0}},{dialect:"mysql",type:"paren_block",syntax:{type:"Identifier",as:"target_columns",arity:{min:1},itemSeparator:e,singletons:"BY_KEY",assert:!0}},{type:["FKMatchRule","FKDeleteRule","FKUpdateRule"],as:"referential_rules",arity:1/0,assert:!0,singletons:!0}])}columns(){return this._get("columns")}targetTable(){return this._get("target_table")}targetColumns(){return this._get("target_columns")}referentialRules(){return this._get("referential_rules")}};var Or=class extends Z{static get syntaxRules(){let e={type:"punctuation",value:","};return this.buildSyntaxRules([{type:"keyword",value:"PRIMARY"},{type:"keyword",as:".",value:"KEY",assert:!0},{type:"paren_block",syntax:{type:"ColumnRef2",as:"columns",arity:{min:1},itemSeparator:e,singletons:"BY_KEY",assert:!0},assert:!0},{type:"PGIndexParameters",as:"pg_index_parameters",optional:!0,dialect:"postgres"}])}columns(){return this._get("columns")}pgIndexParameters(){return this._get("pg_index_parameters")}};var vr=class extends Z{static get syntaxRules(){let e={type:"punctuation",value:","};return this.buildSyntaxRules([{type:"keyword",value:"UNIQUE"},{type:"keyword",as:"my_key_kw",value:["KEY","INDEX"],optional:!0,dialect:"mysql"},{optional:!0,dialect:"postgres",syntaxes:[[{type:"keyword",value:"NULLS"},{type:"operator",as:"pg_nulls_distinct",value:"NOT"},{type:"keyword",value:"DISTINCT",assert:!0}],[{type:"keyword",value:"NULLS"},{type:"keyword",as:"pg_nulls_distinct",value:"DISTINCT",assert:!0}]]},{type:"paren_block",syntax:{type:"ColumnRef2",as:"columns",arity:{min:1},itemSeparator:e,singletons:"BY_KEY",assert:!0},assert:!0},{type:"PGIndexParameters",as:"pg_index_parameters",optional:!0,dialect:"postgres"}])}myKeyKW(){return this._get("my_key_kw")}pgNullsDistinct(){return this._get("pg_nulls_distinct")}columns(){return this._get("columns")}pgIndexParameters(){return this._get("pg_index_parameters")}};var Ge=u=>class extends u{static get _qualifierType(){return"Identifier"}static buildSyntaxRules(e=null){return[{optional:!0,syntax:[{type:this._qualifierType,as:"qualifier"},{type:"punctuation",value:".",autoSpacing:!1}]},e||{...[].concat(super.syntaxRules)[0],autoSpacing:!1}]}static get syntaxRules(){return this.buildSyntaxRules()}static get syntaxPriority(){return-1}qualifier(){return this._get("qualifier")}identifiesAs(e,t=void 0){let r=super.identifiesAs(e,t);return r&&this.qualifier()&&e.qualifier?.()?this.qualifier().identifiesAs(e.qualifier(),t):r}static async _parseFromRules(e,t,{left:r=void 0,minPrecedence:s=0,trail:n,...a},o={}){if(r)return super._parseFromRules(e,t,{left:r,minPrecedence:s,trail:n,...a},o);let c=[];for(;;){if(await e.match(1,"punctuation","."))c.push(await e.eat());else if(await e.match(1,"version_spec")&&await e.match(2,"punctuation","."))c.push(await e.eat()),c.push(await e.eat());else break;(await e.match(2,"punctuation",".")||await e.match(2,"version_spec")&&await e.match(3,"punctuation","."))&&c.push(await e.eat())}let l="qualifier";if(c.length){let f=[].concat(this._qualifierType),y=await this.toStream(c,a),p={minPrecedence:s,trail:n.concat(this.NODE_NAME,`<${l}>`),...a};r=await this._parseFromTypes(y,f,p)}else r=!1;return await super._parseFromRules(e,t,{left:r,minPrecedence:s,trail:n,...a},o)}};var we={};be(we,{AggrCallExpr:()=>Cr,AtTimeZoneExpr:()=>es,BetweenExpr:()=>ts,BinaryExpr:()=>te,BindVar:()=>ds,BitLiteral:()=>jr,BoolLiteral:()=>Ur,CallExpr:()=>mt,CaseBranch:()=>kr,CaseExpr:()=>Ir,CastExpr:()=>Dr,ColumnRef0:()=>is,ColumnRef1:()=>_t,ColumnRef2:()=>tt,DefaultLiteral:()=>Br,DistinctFromExpr:()=>rs,Expr:()=>$t,ExtractExpr:()=>Lr,HexLiteral:()=>$r,Identifier:()=>le,InExpr:()=>ss,LQArrayLiteral:()=>Qr,LQBackBackRef:()=>Ke,LQBackRef:()=>os,LQBackRefAbstraction:()=>Bt,LQBackRefEndpoint:()=>ls,LQDeepDeepRef1:()=>Pe,LQDeepDeepRef2:()=>us,LQDeepRef1:()=>gt,LQDeepRef2:()=>cs,LQObjectLiteral:()=>zr,LQObjectProperty:()=>Xr,NullLiteral:()=>Jr,NumberLiteral:()=>Fr,PGCastExpr2:()=>ns,PGFilterClause:()=>br,PGTypedArrayLiteral:()=>Zr,PGWithinGroupClause:()=>Rr,ParenExpr:()=>qe,PredicateExpr:()=>Mr,QuantitativeExpr:()=>Pr,RowConstructor:()=>et,ScalarSubquery:()=>jt,SchemaRef:()=>fs,StringLiteral:()=>Gr,SystemVar:()=>hs,TableRef0:()=>ps,TableRef1:()=>Ye,TableRef2:()=>ms,TypedDateLiteral:()=>qr,TypedIntervalLiteral:()=>Wr,TypedLiteral:()=>xe,TypedRowConstructor:()=>Ut,TypedTimeLiteral:()=>Hr,TypedTimeZoneLiteral:()=>Yr,TypedTimestampLiteral:()=>Kr,UnaryExpr:()=>as,UnknownLiteral:()=>Vr,UserVar:()=>_s,WindowRef:()=>ys});var Ce=u=>class extends u{dataType(){return d.DataType.fromJSON({value:"TEXT"})}};var se=class extends Ce(w){};var qe=class u extends se{static get syntaxRules(){return{type:"paren_block",syntax:{type:"Expr",as:"expr"},autoIndent:!0}}static get syntaxPriority(){return-1}expr(){return this._get("expr")}exprUnwrapped(){let e=this._get("expr");return e instanceof u?e.exprUnwrapped():e}dataType(){return this.expr()?.dataType()}};var et=class u extends X(Ce(L)){static get syntaxRules(){return{syntax:[{type:"paren_block",syntax:{type:["DerivedQuery","ValuesTableLiteral","Expr"],as:"entries",arity:1/0,itemSeparator:{type:"punctuation",value:","},autoIndent:10}}]}}static get syntaxPriority(){return 49}exprUnwrapped(){return this._get("entries")?.length===1&&this._get("entries")[0]instanceof u?this._get("entries")[0].exprUnwrapped():this}dataType(){return d.DataType.fromJSON({value:"SET"})}jsonfy(e={},t=null,r=null){let s=super.jsonfy(e,t,r);if(e.deSugar?.rowConstructorSchemas||e.forceDeSugar){let n=this.entries()||[],o=(s.entries||[]).map((c,l)=>{let f={nodeName:d.Identifier.NODE_NAME,value:l};return c.result_schema instanceof d.ColumnSchema?c.result_schema.clone({renameTo:f}):d.ColumnSchema.fromJSON({name:f,data_type:n[l].dataType().jsonfy()})});s={...s,result_schema:d.JSONSchema.fromJSON({entries:o},{assert:!0})}}return s}};var pt=class extends X(qe){static get syntaxRules(){return{type:"paren_block",syntax:{type:["SelectStmt","TableStmt","CTE"],as:"expr",autoIndent:!0}}}static get syntaxPriority(){return-1}dataType(){return this.expr()?.dataType()}#e=!1;isCorrelated(){return this.#e}static fromJSON(e,t={},r=null){if(!e||e instanceof w)return super.fromJSON(e,t,r);let{is_correlated:s,...n}=e,a=super.fromJSON(n,t,r);if(a&&s){if(typeof s!="boolean")throw new Error("Invalid value passed at inputJson.is_correlated");a.#e=s}return a}jsonfy(e={},t=null,r=null){let s=t?.statementContext?.artifacts||new Map;s.set("derivedQueryCorrelationFlag",null);let n=super.jsonfy(e,t,r),a=s.get("derivedQueryCorrelationFlag");if(s.delete("derivedQueryCorrelationFlag"),e.deSugar){let o=n.expr?.result_schema;n={...n,is_correlated:!!a,result_schema:o}}else n={...n,is_correlated:this.#e};return n}};var jt=class extends pt{static get syntaxRules(){return{type:"paren_block",syntax:{type:["SelectStmt","CTE"],as:"expr"},autoIndent:!0}}static get syntaxPriority(){return 48}dataType(){return this.resultSchema()?this.resultSchema().dataType():d.DataType.fromJSON({value:"TEXT"})}jsonfy(e={},t=null,r=null){let s=super.jsonfy(e,t,r);if(e.deSugar){let n=s.expr?.result_schema;if(n?.length!==1)throw new Error("Scalar subqueries must return a scalar value.");n=n.entries()[0],s={...s,result_schema:n}}return s}};var Ut=class extends et{static get syntaxRules(){return[{type:"keyword",value:"ROW"},...[].concat(super.syntaxRules)]}static get syntaxPriority(){return 52}};var br=class extends w{static get syntaxRules(){return{dialect:"postgres",syntax:[{type:"keyword",value:"FILTER"},{type:"paren_block",syntax:{type:"WhereClause",as:"where_clause"},assert:!0,autoIndent:!0}]}}static get syntaxPriority(){return-1}whereClause(){return this._get("where_clause")}};var Rr=class extends w{static get syntaxRules(){return{dialect:"postgres",syntax:[{type:"keyword",value:"WITHIN"},{type:"keyword",value:"GROUP"},{type:"paren_block",syntax:{type:"OrderByClause",as:"order_by_clause"},assert:!0,autoIndent:!0}]}}static get syntaxPriority(){return-1}orderByClause(){return this._get("order_by_clause")}};var mt=class extends X(se){static get syntaxRules(){let e={type:"punctuation",value:","};return{syntaxes:[{peek:[0,"keyword",["NOW","CURRENT_DATE","CURRENT_TIME","CURRENT_TIMESTAMP","IF","NULLIF","IFNULL","COALESCE","GREATEST","LEAST","CONCAT","CONCAT_WS","FORMAT","MD5","SHA1","TO_JSON","TO_JSONB","JSON_TYPEOF","JSONB_TYPEOF","JSON_BUILD_ARRAY","JSONB_BUILD_ARRAY","JSON_BUILD_OBJECT","JSONB_BUILD_OBJECT","JSON_POPULATE_RECORD","JSONB_POPULATE_RECORD","JSON_PATH_QUERY","JSON_PATH_EXISTS","JSON_ARRAY","JSON_OBJECT","JSON_EXTRACT","JSON_UNQUOTE","JSON_SET","JSON_INSERT","JSON_REPLACE","JSON_REMOVE","JSON_SEARCH","JSON_CONTAINS","JSON_CONTAINS_PATH","JSON_KEYS","JSON_ARRAY_APPEND","JSON_ARRAY_INSERT","JSON_DEPTH","JSON_LENGTH","JSON_MERGE_PRESERVE","JSON_MERGE_PATCH","JSON_PRETTY","JSON_STORAGE_FREE","ST_ASTEXT","ST_ASGEOJSON","ST_GEOMFROMTEXT","ST_WITHIN","ST_CONTAINS","ST_INTERSECTS","ST_DISTANCE","ST_BUFFER","MAKE_DATE","MAKE_TIME","MAKE_TIMESTAMP","ARRAY","CURDATE","CURTIME","SYSDATE","STR_TO_DATE","MAKEDATE","MAKETIME"]],syntaxes:[[{type:"keyword",as:"name",value:["CURRENT_DATE","CURRENT_TIME","CURRENT_TIMESTAMP"]},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:0,itemSeparator:e,assert:!0},optional:!0,optionalParens:!0,autoSpacing:!1}],[{type:"keyword",as:"name",value:["NOW"]},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:0,itemSeparator:e,assert:!0},optional:!0,autoSpacing:!1}],[{type:"keyword",as:"name",value:["IF","NULLIF","IFNULL"]},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:{min:2,max:3},itemSeparator:e,assert:!0},autoSpacing:!1}],[{type:"keyword",as:"name",value:["COALESCE","GREATEST","LEAST","CONCAT"]},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:{min:1},itemSeparator:e,assert:!0},autoSpacing:!1}],[{type:"keyword",as:"name",value:["CONCAT_WS","FORMAT"]},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:{min:2},itemSeparator:e,assert:!0},autoSpacing:!1}],[{type:"keyword",as:"name",value:["MD5","SHA1"]},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:1,itemSeparator:e,assert:!0},autoSpacing:!1}],[{type:"keyword",as:"name",value:["ST_ASTEXT","ST_ASGEOJSON","ST_GEOMFROMTEXT"]},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:1,itemSeparator:e,assert:!0},autoSpacing:!1}],[{type:"keyword",as:"name",value:["ST_WITHIN","ST_CONTAINS","ST_INTERSECTS","ST_DISTANCE","ST_BUFFER"]},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:2,itemSeparator:e,assert:!0},autoSpacing:!1}],{dialect:"postgres",syntax:[{type:"keyword",as:"name",value:["TO_JSON","TO_JSONB","JSON_TYPEOF","JSONB_TYPEOF"]},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:1,itemSeparator:e,assert:!0},autoSpacing:!1}]},{dialect:"postgres",syntax:[{type:"keyword",as:"name",value:["JSON_BUILD_ARRAY","JSONB_BUILD_ARRAY","JSON_BUILD_OBJECT","JSONB_BUILD_OBJECT"]},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:{min:0},itemSeparator:e,assert:!0},autoSpacing:!1}]},{dialect:"postgres",syntax:[{type:"keyword",as:"name",value:["JSON_POPULATE_RECORD","JSONB_POPULATE_RECORD","JSON_PATH_QUERY","JSON_PATH_EXISTS"]},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:2,itemSeparator:e,assert:!0},autoSpacing:!1}]},{dialect:"postgres",syntax:[{type:"keyword",as:"name",value:["ARRAY"]},{type:"paren_block",syntax:{type:"SelectStmt",as:"arguments",arity:1,itemSeparator:e,assert:!0},autoIndent:!0,autoSpacing:!0}]},{dialect:"postgres",syntax:[{type:"keyword",as:"name",value:["MAKE_DATE","MAKE_TIME","MAKE_TIMESTAMP"]},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:1/0,itemSeparator:e,assert:!0},autoSpacing:!1}]},{dialect:"mysql",syntax:[{type:"keyword",as:"name",value:["JSON_ARRAY","JSON_OBJECT","JSON_EXTRACT","JSON_UNQUOTE","JSON_SET","JSON_INSERT","JSON_REPLACE","JSON_REMOVE","JSON_SEARCH","JSON_CONTAINS","JSON_CONTAINS_PATH","JSON_KEYS","JSON_ARRAY_APPEND","JSON_ARRAY_INSERT","JSON_DEPTH","JSON_LENGTH","JSON_MERGE_PRESERVE","JSON_MERGE_PATCH","JSON_PRETTY","JSON_STORAGE_FREE"]},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:{min:1},itemSeparator:e,assert:!0},autoSpacing:!1}]},{dialect:"mysql",syntax:[{type:"keyword",as:"name",value:["CURDATE","CURTIME","SYSDATE"]},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:0,itemSeparator:e,optional:!0,assert:!0},autoSpacing:!1}]},{dialect:"mysql",syntax:[{type:"keyword",as:"name",value:"STR_TO_DATE"},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:2,itemSeparator:e,assert:!0},autoSpacing:!1}]},{dialect:"mysql",syntax:[{type:"keyword",as:"name",value:["MAKEDATE","MAKETIME"]},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:2,itemSeparator:e,assert:!0},autoSpacing:!1}]}]},[{type:"keyword",as:"name"},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:1/0,itemSeparator:e},autoSpacing:!1}],[{type:"identifier",as:"name"},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:1/0,itemSeparator:e},autoSpacing:!1}]]}}static get syntaxPriority(){return 51}name(){return this._get("name")}arguments(){return this._get("arguments")}};var Cr=class extends mt{static get syntaxRules(){let e={type:"punctuation",value:","},t={type:"keyword",as:"distinct",value:"DISTINCT",booleanfy:!0,optional:!0},r={optional:!0,syntax:[{type:"keyword",value:"SEPARATOR"},{type:"Expr",as:"separator",assert:!0}]},s={type:"OrderByClause",as:"order_by_clause",optional:!0},n={type:"PGFilterClause",as:"pg_filter_clause",optional:!0,dialect:"postgres"},a={type:"PGWithinGroupClause",as:"pg_within_group_clause",optional:!0,dialect:"postgres"},o={optional:!0,syntax:[{type:"keyword",as:"null_handling",value:["IGNORE","RESPECT"]},{type:"keyword",value:"NULLS",assert:!0}]},c={optional:!0,syntax:[{type:"keyword",value:"OVER"},{type:["WindowRef","WindowSpec"],as:"over_clause",assert:!0}]};return{peek:[0,"keyword",["COUNT","SUM","AVG","MIN","MAX","ARRAY_AGG","STRING_AGG","GROUP_CONCAT","REGR_SLOPE","COVAR_POP","COVAR_SAMP","CORR","PERCENTILE_CONT","PERCENTILE_DISC","MODE","RANK","DENSE_RANK","ROW_NUMBER","EVERY","BOOL_AND","BOOL_OR","BIT_AND","BIT_OR","BIT_XOR","JSON_AGG","JSON_ARRAYAGG","JSON_OBJECT_AGG","JSONB_OBJECT_AGG","JSON_OBJECTAGG","STDDEV_POP","STDDEV_SAMP","VAR_POP","VAR_SAMP","VARIANCE","STD","XMLAGG","LEAD","LAG","NTILE","FIRST_VALUE","LAST_VALUE"]],syntaxes:[[{type:"keyword",as:"name",value:"COUNT"},{type:"paren_block",syntax:[{dialect:"postgres",type:"ColumnRef0",as:"arguments",arity:1,assert:!1,itemSeparator:e},{dialect:"mysql",type:"ColumnRef0",as:"arguments",arity:1/0,assert:!1,itemSeparator:e,optional:!0}],autoSpacing:!1},{...n},{...c}],[{type:"keyword",as:"name",value:["COUNT","SUM","AVG","MIN","MAX"]},{type:"paren_block",syntax:[{...t},{type:"Expr",as:"arguments",arity:1,itemSeparator:e,assert:!0}],autoSpacing:!1},{...n},{...c}],{dialect:"postgres",syntax:[{type:"keyword",as:"name",value:"ARRAY_AGG"},{type:"paren_block",syntax:[{...t},{type:"Expr",as:"arguments",arity:{min:1},itemSeparator:e,assert:!0},{...s}],autoSpacing:!1},{...n},{...c}]},{dialect:"postgres",syntax:[{type:"keyword",as:"name",value:"STRING_AGG"},{type:"paren_block",syntax:[{...t},{type:"Expr",as:"arguments",arity:2,itemSeparator:e,assert:!0},{...s},{...r}],autoSpacing:!1},{...n},{...c}]},{dialect:"mysql",syntax:[{type:"keyword",as:"name",value:"GROUP_CONCAT"},{type:"paren_block",syntax:[{...t},{type:"Expr",as:"arguments",arity:{min:1},itemSeparator:e,assert:!0},{...s},{...r}],autoSpacing:!1},{...c}]},{dialect:"postgres",syntax:[{type:"keyword",as:"name",value:"REGR_SLOPE"},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:2,itemSeparator:e,assert:!0},autoSpacing:!1},{...n},{...c}]},[{type:"keyword",as:"name",value:["COVAR_POP","COVAR_SAMP","CORR"]},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:2,itemSeparator:e,assert:!0},autoSpacing:!1},{...n},{...c}],{dialect:"postgres",syntax:[{type:"keyword",as:"name",value:["PERCENTILE_CONT","PERCENTILE_DISC"]},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:1,itemSeparator:e,assert:!0},autoSpacing:!1},{...n},{...a,optional:!1}]},{dialect:"postgres",syntax:[{type:"keyword",as:"name",value:"MODE"},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:0,itemSeparator:e,assert:!0},autoSpacing:!1},{...n},{...a,optional:!1}]},{dialect:"postgres",syntax:[{type:"keyword",as:"name",value:["RANK","DENSE_RANK"]},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:0,itemSeparator:e,assert:!0},autoSpacing:!1},{...n},{...c,optional:!1}]},[{type:"keyword",as:"name",value:"ROW_NUMBER"},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:0,itemSeparator:e,assert:!0},autoSpacing:!1},{...c,optional:!1}],{dialect:"postgres",syntax:[{type:"keyword",as:"name",value:["EVERY","BOOL_AND","BOOL_OR"]},{type:"paren_block",syntax:[{...t},{type:"Expr",as:"arguments",arity:1,itemSeparator:e,assert:!0}],autoSpacing:!1},{...n},{...c}]},{dialect:"postgres",syntax:[{type:"keyword",as:"name",value:"JSON_AGG"},{type:"paren_block",syntax:[{...t},{type:"Expr",as:"arguments",arity:{min:1},itemSeparator:e,assert:!0}],autoSpacing:!1},{...n},{...c}]},{dialect:"mysql",syntax:[{type:"keyword",as:"name",value:"JSON_ARRAYAGG"},{type:"paren_block",syntax:[{...t},{type:"Expr",as:"arguments",arity:{min:1},itemSeparator:e,assert:!0}],autoSpacing:!1},{...c}]},{dialect:"mysql",syntax:[{type:"keyword",as:"name",value:"BIT_XOR"},{type:"paren_block",syntax:[{...t},{type:"Expr",as:"arguments",arity:1,itemSeparator:e,assert:!0}],autoSpacing:!1},{...c}]},[{type:"keyword",as:"name",value:["BIT_AND","BIT_OR"]},{type:"paren_block",syntax:[{...t},{type:"Expr",as:"arguments",arity:1,itemSeparator:e,assert:!0}],autoSpacing:!1},{...n},{...c}],{dialect:"postgres",syntax:[{type:"keyword",as:"name",value:["JSON_OBJECT_AGG","JSONB_OBJECT_AGG"]},{type:"paren_block",syntax:[{...t},{type:"Expr",as:"arguments",arity:2,itemSeparator:e,assert:!0}],autoSpacing:!1},{...n},{...c}]},{dialect:"mysql",syntax:[{type:"keyword",as:"name",value:"JSON_OBJECTAGG"},{type:"paren_block",syntax:[{...t},{type:"Expr",as:"arguments",arity:2,itemSeparator:e,assert:!0}],autoSpacing:!1},{...c}]},[{type:"keyword",as:"name",value:["STDDEV_POP","STDDEV_SAMP","VAR_POP","VAR_SAMP","VARIANCE","STD"]},{type:"paren_block",syntax:[{...t},{type:"Expr",as:"arguments",arity:1,itemSeparator:e,assert:!0}],autoSpacing:!1},{...n},{...c}],{dialect:"postgres",syntax:[{type:"keyword",as:"name",value:"XMLAGG"},{type:"paren_block",syntax:[{type:"Expr",as:"arguments",arity:1,itemSeparator:e,assert:!0},{...s}],autoSpacing:!1},{...n},{...c}]},[{type:"keyword",as:"name",value:["LEAD","LAG"]},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:{max:3},itemSeparator:e,optional:!0,assert:!0},autoSpacing:!1},{...o},{...c}],[{type:"keyword",as:"name",value:["NTILE","FIRST_VALUE","LAST_VALUE"]},{type:"paren_block",syntax:{type:"Expr",as:"arguments",arity:1,itemSeparator:e,assert:!0},autoSpacing:!1},{...c,optional:!1}]]}}distinct(){return this._get("distinct")}orderByClause(){return this._get("order_by_clause")}separator(){return this._get("separator")}overClause(){return this._get("over_clause")}pgFilterClause(){return this._get("pg_filter_clause")}pgWithinGroupClause(){return this._get("pg_within_group_clause")}};var Ir=class extends Ce(L){static get syntaxRules(){return[{type:"keyword",value:"CASE"},{type:"Expr",as:"subject",optional:!0},{type:"CaseBranch",as:"entries",arity:{min:1},assert:!0,autoIndent:2},{optional:!0,syntax:[{type:"keyword",value:"ELSE"},{type:"Expr",as:"alternate",autoIndent:!0}],autoSpacing:`
`},{type:"keyword",value:"END",autoSpacing:`
`}]}subject(){return this._get("subject")}branches(){return this.entries()}alternate(){return this._get("alternate")}};var kr=class extends w{static get syntaxRules(){return[{type:"keyword",value:"WHEN"},{type:"Expr",as:"condition"},{type:"keyword",value:"THEN"},{type:"Expr",as:"consequent"}]}static get syntaxPriority(){return-1}condition(){return this._get("condition")}consequent(){return this._get("consequent")}};var Dr=class extends se{static get syntaxRules(){return[{type:"keyword",value:"CAST"},{type:"paren_block",syntax:[{type:"Expr",as:"expr"},{type:"keyword",value:"AS"},{type:"DataType",as:"data_type",assert:!0}],assert:!0,autoSpacing:!1}]}expr(){return this._get("expr")}dataType(){return this._get("data_type")}};var te=class extends se{static get syntaxRules(){return[{type:"Expr",as:"left",peek:[1,"operator",["NOT",void 0]]},{type:"operator",as:"negation",value:"NOT",booleanfy:!0,optional:!0},{type:"operator",as:"operator"},{type:"Expr",as:"right"}]}static get syntaxPriority(){return 0}left(){return this._get("left")}negation(){return this._get("negation")}operator(){return this._get("operator")}right(){return this._get("right")}dataType(){let e=this.operator();if(!e)return this.left()?.dataType();let t=this.options.dialect,s=new Map(zt.common.concat(zt[t])).get(e)?.resultType;if(s)return s===":right"?this.right()?.dataType():s===":left"?this.left()?.dataType():d.DataType.fromJSON({value:s.toUpperCase()})}};var Lr=class extends te{static get syntaxRules(){return[{type:"keyword",value:"EXTRACT"},{type:"paren_block",syntax:[{type:"Expr",as:"left"},{type:"keyword",value:"FROM"},{type:"Expr",as:"right",assert:!0}],autoSpacing:!1}]}left(){return this._get("left")}right(){return this._get("right")}};var Mr=class extends se{static get syntaxRules(){return[{type:"keyword",as:"predicate",value:["EXISTS"]},{type:"ScalarSubquery",as:"expr"}]}predicate(){return this._get("predicate")}expr(){return this._get("expr")}dataType(){return d.DataType.fromJSON({value:"BOOLEAN"})}};var Pr=class extends w{static get syntaxRules(){return[{type:"keyword",as:"quantifier",value:["ALL","ANY","SOME"]},{syntaxes:[{type:"DerivedQuery",as:"expr"},{type:"paren_block",syntax:{type:"Expr",as:"expr"}}]}]}quantifier(){return this._get("quantifier")}expr(){return this._get("expr")}};var me=class extends se{static get syntaxPriority(){return 49}value(){return this._get("value")}};var jr=class extends me{static get syntaxRules(){return{type:"bit_literal",as:"."}}dataType(){return d.DataType.fromJSON({value:"BINARY"})}};var Ur=class extends me{static get syntaxRules(){return{type:"bool_literal",as:"."}}dataType(){return d.DataType.fromJSON({value:"BOOLEAN"})}};var Br=class extends me{static get syntaxRules(){return{type:"keyword",as:".",value:"DEFAULT"}}};var $r=class extends me{static get syntaxRules(){return{type:"hex_literal",as:"."}}dataType(){return d.DataType.fromJSON({value:"BINARY"})}};var Jr=class extends me{static get syntaxRules(){return{type:"null_literal",as:"."}}};var Fr=class extends me{static get syntaxRules(){return{type:"number_literal",as:"."}}dataType(){return d.DataType.fromJSON({value:"INT"})}};var Gr=class extends me{static get syntaxRules(){return{type:"string_literal",as:"."}}qualifier(){return this._get("qualifier")}dataType(){return d.DataType.fromJSON({value:"TEXT"})}};var xe=class extends se{static get syntaxRules(){return[{type:"data_type",as:"data_type"},{type:"string_literal",as:"value"}]}static get syntaxPriority(){return 50}dataType(){return d.DataType.fromJSON({value:this._get("data_type")})}value(){return this._get("value")}};var qr=class extends xe{static get syntaxRules(){return[{type:"data_type",as:"data_type",value:"DATE"},{type:"string_literal",as:"value"}]}};var Wr=class extends xe{static get syntaxRules(){return[{type:"data_type",as:"data_type",value:"INTERVAL"},{syntaxes:[{type:"string_literal",as:"value"},{type:"number_literal",as:"value",dialect:"mysql"}]},{optional:!0,syntax:[{type:"keyword",as:"unit",value:["YEAR","MONTH","DAY","HOUR","MINUTE","SECOND"]},{optional:!0,syntax:[{type:"keyword",value:"TO"},{type:"keyword",as:"to_unit",value:["YEAR","MONTH","DAY","HOUR","MINUTE","SECOND"],assert:!0}]}]}]}unit(){return this._get("unit")}toUnit(){return this._get("to_unit")}parseInterval(){let e=this._get("value");if(!e)return{};let t="";if(e.type==="string_literal")t=e.value.toString().trim();else if(e.type==="number_literal"){let c=e.value,l=(this.unit()||"").toUpperCase();return this.#e(c,l)}let r=t.startsWith("-")?-1:1;r===-1&&(t=t.slice(1).trim());let s={years:0,months:0,days:0,hours:0,minutes:0,seconds:0},n=this.unit()?this.unit().toUpperCase():null,a=this.toUnit()?this.toUnit().toUpperCase():null;if(n&&a)switch(`${n} TO ${a}`){case"YEAR TO MONTH":{let[l,f]=t.split("-").map(Number);return s.years=l,s.months=f,this.#t(s,r)}case"DAY TO HOUR":{let[l,f]=t.split(/\s+/);return s.days=Number(l),s.hours=Number(f),this.#t(s,r)}case"DAY TO MINUTE":{let[l,f]=t.split(/\s+/);s.days=Number(l);let[y,p]=f.split(":").map(Number);return s.hours=y,s.minutes=p,this.#t(s,r)}case"DAY TO SECOND":{let[l,f]=t.split(/\s+/);s.days=Number(l);let[y,p,m]=f.split(":").map(Number);return s.hours=y,s.minutes=p,s.seconds=m,this.#t(s,r)}case"HOUR TO MINUTE":{let[l,f]=t.split(":").map(Number);return s.hours=l,s.minutes=f,this.#t(s,r)}case"HOUR TO SECOND":{let[l,f,y]=t.split(":").map(Number);return s.hours=l,s.minutes=f,s.seconds=y,this.#t(s,r)}case"MINUTE TO SECOND":{let[l,f]=t.split(":").map(Number);return s.minutes=l,s.seconds=f,this.#t(s,r)}}let o=t.split(/\s+/);for(let c=0;c<o.length;c++){let l=o[c];if(/^\d{1,2}:\d{1,2}(:\d{1,2}(\.\d+)?)?$/.test(l)){let[y,p,m]=l.split(":").map(Number);isNaN(y)||(s.hours+=y),isNaN(p)||(s.minutes+=p),isNaN(m)||(s.seconds+=m);continue}let f=parseFloat(l);if(!isNaN(f)){let y=(o[c+1]||"").toUpperCase();if(y){let p=this.#e(f,y);for(let[m,h]of Object.entries(p))s[m]+=h;c++}}}return this.#t(s,r)}#e(e,t){let r={};switch(t){case"YEAR":r.years=e;break;case"MONTH":r.months=e;break;case"DAY":r.days=e;break;case"HOUR":r.hours=e;break;case"MINUTE":r.minutes=e;break;case"SECOND":r.seconds=e;break;default:break}return r}#t(e,t){for(let r of Object.keys(e))e[r]*=t;return e}applyToDate(e,t="FOLLOWING"){let r=this.parseInterval(),s=new Date(e),n=t==="FOLLOWING"?1:-1;return r.years&&s.setFullYear(s.getFullYear()+n*r.years),r.months&&s.setMonth(s.getMonth()+n*r.months),r.days&&s.setDate(s.getDate()+n*r.days),r.hours&&s.setHours(s.getHours()+n*r.hours),r.minutes&&s.setMinutes(s.getMinutes()+n*r.minutes),r.seconds&&s.setSeconds(s.getSeconds()+n*r.seconds),s.getTime()}};var Hr=class extends xe{static get syntaxRules(){return[{type:"data_type",as:"data_type",value:"TIME"},{type:"string_literal",as:"value"},{optional:!0,dialect:"postgres",syntax:[{type:"keyword",as:"pg_with_tz",value:["WITH","WITHOUT"]},{type:"keyword",value:"TIME ZONE",assert:!0}]}]}pgWithTZ(){return this._get("pg_with_tz")}};var Kr=class extends xe{static get syntaxRules(){return[{type:"data_type",as:"data_type",value:"TIMESTAMP",dialect:"postgres"},{type:"data_type",as:"data_type",value:["TIMESTAMP","DATETIME"],dialect:"mysql"},{type:"string_literal",as:"value"},{optional:!0,dialect:"postgres",syntax:[{type:"keyword",as:"pg_with_tz",value:["WITH","WITHOUT"]},{type:"keyword",value:"TIME ZONE",assert:!0}]}]}pgWithTZ(){return this._get("pg_with_tz")}};var Yr=class extends xe{static get syntaxRules(){return[{type:"keyword",value:"TIME ZONE"},{type:"Expr",as:"value"}]}};var Vr=class extends me{static get syntaxRules(){return{type:"unknown_literal",as:"."}}};var yt=u=>class extends u{get isSugar(){return!0}};var dt=class extends yt(Ce(L)){dataType(){return d.DataType.fromJSON({value:"JSON"})}};var Qr=class extends dt{static get syntaxRules(){return{syntax:[{type:"bracket_block",syntax:{type:"Expr",as:"entries",arity:1/0,itemSeparator:{type:"punctuation",value:","},autoIndent:2}}]}}static morphsTo(){return d.CallExpr}jsonfy(e={},t=null,r=null){let s=super.jsonfy(e,t,r);if(e.deSugar){let n=[];s={nodeName:d.CallExpr.NODE_NAME,name:(e.toDialect||this.options.dialect)==="mysql"?"JSON_ARRAY":"JSON_BUILD_ARRAY",arguments:s.entries.map((a,o)=>{let c=a.result_schema,l={value:o,nodeName:d.Identifier.NODE_NAME};return c instanceof d.ColumnSchema?c=c.clone({renameTo:l}):c=d.ColumnSchema.fromJSON({name:l,data_type:this.entries()[o].dataType().jsonfy()}),n.push(c),a}),result_schema:d.JSONSchema.fromJSON({entries:n},{assert:!0})}}return s}};var zr=class extends dt{static get syntaxRules(){return{syntax:[{type:"brace_block",syntax:{type:"LQObjectProperty",as:"entries",arity:1/0,itemSeparator:{type:"punctuation",value:","},autoIndent:3}}]}}static morphsTo(){return d.CallExpr}jsonfy(e={},t=null,r=null){let s=super.jsonfy(e,t,r);if(e.deSugar){let n=s.entries.reduce((o,c)=>{if(c.star_ref){for(let l of c.star_ref.result_schema){let f={key:{value:l.value(),delim:l._get("delim")},value:l.jsonfy()};o=o.reduce((y,p)=>V(f.key.value,p.key.value,f.key.delim||p.key.delim)?y:y.concat(p),[]),o=o.concat(f)}return o}return o.concat(c)},[]),a=[];s={nodeName:d.CallExpr.NODE_NAME,name:(e.toDialect||this.options.dialect)==="mysql"?"JSON_OBJECT":"JSON_BUILD_OBJECT",arguments:n.reduce((o,c,l)=>{let f=c.value.result_schema,y={...c.key,nodeName:d.Identifier.NODE_NAME};return f instanceof d.ColumnSchema?f=f.clone({renameTo:y}):f=d.ColumnSchema.fromJSON({name:y,data_type:this.entries()[l].value()?.dataType().jsonfy()||{nodeName:d.DataType.NODE_NAME,value:"TEXT"}}),a.push(f),o.concat({...c.key,nodeName:d.StringLiteral.NODE_NAME},{...c.value})},[]),result_schema:d.JSONSchema.fromJSON({entries:a},{assert:!0})}}return s}};var Xr=class u extends w{static get syntaxRules(){return{syntaxes:[{type:"ColumnRef0",as:"star_ref"},[{type:"SelectItemAlias",as:"key"},{optional:!0,syntax:[{type:"punctuation",value:":"},{type:"Expr",as:"value",assert:!0}],autoSpacing:!1}]]}}static get syntaxPriority(){return-1}get isProperty(){return!0}starRef(){return this._get("star_ref")}key(){return this._get("key")}value(){return this._get("value")}jsonfy(e={},t=null,r=null){if(e.deSugar&&!this.starRef()){let s=this.key(),n,a=t?t.transform(s,(f=e)=>s.jsonfy(f),"key",e):s.jsonfy(e);a.is_aggr&&({is_aggr:n,...a}=a);let o=this.value();o||(o=d.ColumnRef1.fromJSON({...a,nodeName:void 0}),this._adoptNodes(o));let c;n&&!(o instanceof d.LQDeepRef1)?c=(f=e,y=t)=>({nodeName:d.AggrCallExpr.NODE_NAME,name:(e.toDialect||this.options.dialect)==="mysql"?"JSON_ARRAYAGG":"JSON_AGG",arguments:[o.jsonfy(f,y,r)]}):c=(f=e,y=t)=>o.jsonfy(f,y,r);let l=t?t.transform(o,c,"value",{...e,asAggr:n}):c();return{nodeName:u.NODE_NAME,key:a,value:l}}return super.jsonfy(e,t,r)}};var Zr=class extends L{static get syntaxRules(){return{dialect:"postgres",syntax:[{type:"keyword",value:"ARRAY"},{type:"bracket_block",syntax:{type:"Expr",as:"entries",arity:1/0,itemSeparator:{type:"punctuation",value:","},autoIndent:2},autoSpacing:!1}]}}static morphsTo(){return d.CallExpr}dataType(){return d.DataType.fromJSON({value:"JSON"})}jsonfy(e={},t=null,r=null){let s=super.jsonfy(e,t,r);return(e.toDialect||this.options.dialect)==="mysql"&&(s={nodeName:d.CallExpr.NODE_NAME,name:"JSON_ARRAY",arguments:s.entries}),s}};var es=class extends te{static get syntaxRules(){return[{type:"Expr",as:"left",peek:[1,"operator","AT"]},{type:"operator",as:"operator",value:"AT"},{syntaxes:[{type:"TypedTimeZoneLiteral",as:"right"},{type:"keyword",as:"right",value:"LOCAL"}]}]}static get syntaxPriority(){return 0}left(){return this._get("left")}right(){return this._get("right")}dataType(){return d.DataType.fromJSON({value:"TIME ZONE"})}};var ts=class extends te{static get syntaxRules(){return[{type:"Expr",as:"left",peek:[1,"operator",["NOT","BETWEEN"]]},{type:"operator",as:"negation",value:"NOT",booleanfy:!0,optional:!0},{type:"operator",as:"operator",value:"BETWEEN"},{type:"Expr",as:"right",arity:{min:2,max:2,eager:!1},itemSeparator:{type:"operator",value:"AND"},assert:!0}]}};var rs=class extends te{static get syntaxRules(){return[{type:"Expr",as:"left",peek:[1,"operator",["IS","IS NOT"]]},{type:"operator",as:"logic",value:["IS","IS NOT"]},{type:"operator",as:"operator",value:"DISTINCT FROM"},{type:"Expr",as:"right",assert:!0}]}logic(){return this._get("logic")}};var ss=class extends te{static get syntaxRules(){return[{type:"Expr",as:"left",peek:[1,"operator",["NOT","IN"]]},{type:"operator",as:"negation",value:"NOT",booleanfy:!0,optional:!0},{type:"operator",as:"operator",value:"IN"},{type:["DerivedQuery","RowConstructor","TypedRowConstructor"],as:"right",assert:!0}]}};var ns=class extends te{static get syntaxRules(){return{dialect:"postgres",syntax:[{type:"Expr",as:"left",peek:[1,"operator","::"]},{type:"operator",as:"operator",value:"::",autoSpacing:!1},{type:"DataType",as:"right",assert:!0,autoSpacing:!1}]}}expr(){return this.left()}dataType(){return this.right()}};var as=class extends se{static get syntaxRules(){return[{type:"operator",as:"operator",value:["-","+","NOT"]},{type:"Expr",as:"operand",autoSpacing:["NOT"]}]}static get syntaxPriority(){return 1}operator(){return this._get("operator")}operand(){return this._get("operand")}dataType(){let e=this.operator();return e?d.DataType.fromJSON({value:e==="NOT"?"BOOLEAN":"NUMBER"}):super.dataType()}};var Me=class extends Error{};var ht=class extends Error{};var Ie=class extends X(Ce(le)){#e;resolution(){return this.#e}lookup(e,t){return[]}resolve(e,t){let r=this.lookup(null,e,t)||[],s=this.constructor.name.match(/schema/i)?"Schema":this.constructor.name.match(/table/i)?"Table":"Column";if(r.length>1)throw new ht(`[${this.parentNode?.parentNode||this.parentNode||this}] ${s} ${this} is ambiguous. (Is it ${r.join(" or ")}?)`);if(!r.length)throw new Me(`[${this.parentNode?.parentNode||this.parentNode||this}] ${s} ${this} does not exist.`);return r[0]}static fromJSON(e,t={},r=null){if(!e||e instanceof w)return super.fromJSON(e,t,r);let{resolution:s,...n}=e,a=super.fromJSON(n,t,r);if(a&&s){if(typeof s!="string")throw new Error('Invalid "resolution" hint passed at inputJson.resolution');a.#e=s}return a}jsonfy(e={},t=null,r=null){let s=super.jsonfy(e,t,r);return this.#e&&(s={...s,resolution:this.#e}),s}};var _t=class u extends Ge(Ie){static get _qualifierType(){return["TableRef1","LQBackRefAbstraction"]}static get syntaxRules(){return this.buildSyntaxRules({type:"identifier",as:".",autoSpacing:!1})}static get syntaxPriority(){return 51}static morphsTo(){return d.ColumnRef2}dataType(){return this.resultSchema()?.dataType()||super.dataType()}canReferenceOutputColumns(){return this.climbTree((e,t)=>e instanceof d.SelectStmt?!1:e instanceof d.GroupByClause||e instanceof d.HavingClause||e instanceof d.OrderByClause?e:t())}lookup(e=null,t=null,r=null){if(!t&&!r)return[];let s=this._get("value"),n=(!s||s==="*")&&!e,a=[],o=(l,f=void 0,y="default")=>{if(!(l instanceof d.ColumnSchema)||s&&s!=="*"&&!l.identifiesAs(this))return!1;let p;if(e&&!(p=e(l,f,y)))return!1;if(p instanceof w||Array.isArray(p))return p;let m=l.clone({normalized:!0});l.parentNode?._adoptNodes(m);let h=u.fromJSON({...l.name().jsonfy({nodeNames:!1}),resolution:y,qualifier:f,result_schema:m});return this.parentNode._adoptNodes(h),h};if(((this.options.dialect||"postgres")==="postgres"?["CTID","OID","XMIN","XMAX","TABLEOID"]:[]).includes(s?.toUpperCase())){let l=d.ColumnSchema.fromJSON({name:{nodeName:d.Identifier.NODE_NAME,value:s},data_type:{nodeName:d.DataType.NODE_NAME,value:"INT"}},{assert:!0});return[].concat(o(l,void 0,"system")||[])}if(this.canReferenceOutputColumns()&&t){let l=t.statementContext;for(let f of l.artifacts.get("outputSchemas"))if(a=a.concat(o(f,void 0,"scope")||[]),!n&&a.length)break}if(n||!a.length){let l=new d.TableRef1(this.qualifier()?.jsonfy()||{});this._adoptNodes(l),a=a.concat(l.lookup((f,y=void 0,p=void 0)=>f._get("entries").reduce((m,h)=>{if(f instanceof d.JSONSchema)return m.concat(o(h)||[]);let g={...f.name().jsonfy({nodeNames:!1}),resolution:p,qualifier:y,result_schema:f};return m.concat(o(h,g)||[])},[]),t,r))}if(s==="*"){let l=d.ColumnRef0.fromJSON({value:this.value(),result_schema:d.JSONSchema.fromJSON({entries:a.map(f=>f.clone())},{assert:!0})});this.parentNode._adoptNodes(l),a=[l]}return a}jsonfy({toKind:e=1,...t}={},r=null,s=null){let n;if(t.deSugar&&((t.deSugar===!0||t.deSugar.columnQualifiers)&&!this.qualifier()||!this.resultSchema())&&(r||s)){let a=this.resolve(r,s);if(a.value?.()!==this.value())return a.jsonfy();n=a.jsonfy(),(t.deSugar===!0||t.deSugar.normalizeCasing)&&!n.delim&&(n={...n,value:n.resolution==="system"?n.value.toUpperCase():n.value.toLowerCase()}),!(t.deSugar===!0||t.deSugar.columnQualifiers)&&!this.qualifier()&&(n={...n,qualifier:void 0})}else n=super.jsonfy(t,r,s),e===2&&(n={...n,nodeName:d.ColumnRef2.NODE_NAME},delete n.qualifier);return n}};var is=class extends _t{static get _qualifierType(){return["TableRef1"]}static get syntaxRules(){return this.buildSyntaxRules({type:"operator",as:".",value:"*",autoSpacing:!1})}static get syntaxPriority(){return-1}dataType(){return d.DataType.fromJSON({value:"SET"})}};var We=class extends Error{constructor(e){super(e),this.name="ErrorFKInvalid"}};var He=class extends yt(te){rhsTable(e,t){let s=(this.operand()?.resolve(e,t)).resultSchema()?.fkConstraint(!0);if(!s)throw new We(`[${this.parentNode||this}] Column ${this.operand()} is not a foreign key.`);return s.targetTable()?.resolve(null,t)}rhsSchema(e,t){return this.rhsTable(e,t)?.resultSchema()}};var tt=class u extends Ie{static get syntaxPriority(){return-1}static morphsTo(){return d.ColumnRef1}dataType(){return this.resultSchema()?.dataType()||super.dataType()}lookup(e,t=null,r=null){if(!t&&!r)return[];let s=this._get("value"),n=!s&&!e,a=[],o=l=>{if(!(l instanceof d.ColumnSchema)||s&&!l.identifiesAs(this))return!1;let f;if(e&&!(f=e(l)))return!1;if(f instanceof w||Array.isArray(f))return f;let y=l.clone({normalized:!0});l.parentNode._adoptNodes(y);let p=u.fromJSON({...l.name().jsonfy({nodeNames:!1}),result_schema:y});return this.parentNode._adoptNodes(p),p},c;this.parentNode instanceof He?this===this.parentNode.operand()?c=[this.parentNode.parentNode.rhsSchema(t,r)]:c=[this.parentNode.rhsSchema(t,r)]:c=this.climbTree((l,f)=>{if(l instanceof d.InsertStmt||l instanceof d.UpdateStmt){let y=[...t.statementContext.artifacts.get("tableSchemas")].map(p=>p.resultSchema);return this.options.dialect!=="mysql"&&(y=y.slice(0,1)),y}return l instanceof d.TableSchema?[l]:f()});e:for(let l of c||[])for(let f of l)if(a=a.concat(o(f)||[]),!n&&a.length)break e;return a}jsonfy({toKind:e=2,...t}={},r=null,s=null){if(t.deSugar&&!this.resultSchema()&&(r||s))return this.resolve(r,s).jsonfy();let n=super.jsonfy(t,r,s);return e===1&&(n={...n,nodeName:d.ColumnRef1.NODE_NAME},delete n.qualifier),n}};var Ke=class u extends He{static get _leftType(){return["LQBackRefEndpoint","LQBackBackRef"]}static get syntaxRules(){return[{type:this._leftType,as:"left",peek:[1,"operator","<~"]},{type:"operator",value:"<~"},{type:"ColumnRef2",as:"right",peek:[1,"operator","<~"]}]}static get syntaxPriority(){return 1}static morphsTo(){return[d.LQDeepRef1,d.LQDeepRef2,d.LQDeepDeepRef1,d.LQDeepDeepRef2]}operand(){return this.right()}endpoint(){return this.left()instanceof u?this.left().endpoint():this.left()}jsonfy({reverseRef:e=!1,toKind:t=1,...r}={},s=null,n=null){return e?{nodeName:t===2?e===1/0?d.LQDeepDeepRef2.NODE_NAME:d.LQDeepRef2.NODE_NAME:e===1/0?d.LQDeepDeepRef1.NODE_NAME:d.LQDeepRef1.NODE_NAME,left:this.right().jsonfy({toKind:e!==1/0?1:2,...r}),right:this.left()instanceof d.LQBackRefEndpoint?{nodeName:d.ColumnRef2.NODE_NAME,value:this.left().value(),delim:this.left()._get("delim")}:this.left().jsonfy({reverseRef:1/0,toKind:t,...r})}:super.jsonfy(r,s,n)}};var os=class extends Ke{static get syntaxRules(){return[{type:this._leftType,as:"left",peek:[1,"operator","<~"]},{type:"operator",value:"<~"},{type:"TableRef2",as:"right"}]}static get syntaxPriority(){return 0}rhsTable(e,t){if(!t)return;let r=this.right()?.lookup(null,null,t)||[];if(!r.length)throw new Me(`[${this.parentNode||this}] Implied RHS table ${this.right()} does not exist.`);return r[0]}resolve(e,t,r=1){if(!e||!t)return;let s=this.left(),n=s instanceof Ke?s.endpoint():s,a=n.qualifier(),o=d.ColumnRef2.fromJSON({...n.jsonfy({nodeNames:!1}),qualifier:void 0}),l=n.resolve(e,t).resultSchema().fkConstraint(!0);if(!l)throw new We(`[${this.parentNode||this}] Endpoint column ${o} is not a foreign key.`);let f=l.targetTable(),y,p=(_,x)=>{let E=x.pkConstraint(!0)?.columns()[0]?.resolve(e,t);if(!E)throw new We(`[${this.parentNode||this}] The referenced LHS table ${_} does not have a primary key.`);let S=d.ColumnRef1.fromJSON({qualifier:{...x.name().jsonfy({nodeNames:!1}),result_schema:x},value:E.value(),delim:E._get("delim"),result_schema:E.resultSchema()});if(y)throw new ht(`[${this.parentNode||this}]: The referenced endpoint for foreign key ${o} is ambiguous. (Is it ${y} or ${S}?)`);y=S},m=e.statementContext;e:do for(let{type:_,resultSchema:x}of m.artifacts.get("tableSchemas")){if(_==="CTEItem")continue;let E=x._get("ddl_name")||x.name();if(a){if(!x.identifiesAs(a))continue;if(!f.identifiesAs(E))throw new We(`[${this.parentNode||this}] The endpoint table implied by ${a} (${E}) is not the actual target (${f}) of the foreign key column ${o}.`);p(E,x);break e}else f.identifiesAs(E)&&p(E,x)}while(!y&&(m=m.parentTransformer?.statementContext));if(!y)throw new Me(`[${this.parentNode||this}] Ref does not correlate with current query.`);let h=this.rhsTable(e,t),g=s instanceof Ke?s.clone({reverseRef:!0,toKind:r}):o.constructor.fromJSON({...o.jsonfy(),result_schema:h.resultSchema()._get("entries",o)});return{lhsOperand:y,rhsOperand:g.clone({toKind:r}),rhsTable:h}}};var Bt=class extends qe{static get syntaxRules(){return{type:"paren_block",syntaxes:[{type:"Expr",as:"expr",peek:[1,"operator","<~"]},{type:"Expr",as:"expr",peek:[2,"operator","<~"]}]}}static get syntaxPriority(){return 51}expr(){return this._get("expr")}};var ls=class extends tt{static get syntaxRules(){return[{optional:!0,type:"paren_block",syntax:{type:"Identifier",as:"qualifier"}},{...[].concat(super.syntaxRules)[0],peek:[1,"operator","<~"]}]}static get syntaxPriority(){return 52}static morphsTo(){return tt}qualifier(){return this._get("qualifier")}};var Pe=class u extends He{static get _rightType(){return["LQDeepDeepRef1","LQObjectLiteral","LQArrayLiteral","RowConstructor","ColumnRef2"]}static get syntaxRules(){return[{type:["ColumnRef2","LQBackRefAbstraction"],as:"left",peek:[1,"operator","~>"]},{type:"operator",value:"~>"},{type:this._rightType,as:"right"}]}static get syntaxPriority(){return-1}static morphsTo(){return[d.LQDeepRef1,d.LQDeepRef2,d.LQDeepDeepRef1,d.LQDeepDeepRef2]}operand(){return this.left()}endpoint(){return this.right()instanceof u?this.right().endpoint():this.right()}jsonfy({toDeepRef:e=!1,toKind:t=1,...r}={},s=null,n=null){if(e||t===1||t===2){let a=[d.LQDeepRef1.NODE_NAME,d.LQDeepRef2.NODE_NAME,d.LQDeepDeepRef1.NODE_NAME,d.LQDeepDeepRef2.NODE_NAME],o=a.indexOf(this.NODE_NAME);return e&&o>1&&(o-=2),{nodeName:a[(o+1)%2===t%2?o:t%2?o-1:o+1],left:this.left().jsonfy({toKind:o>1?2:1}),right:this.right().jsonfy({toKind:this.right()instanceof u?t:void 0})}}return super.jsonfy(r,s,n)}};var us=class extends Pe{static get _rightType(){return["LQDeepDeepRef2","ColumnRef2","ColumnsConstructor"]}jsonfy({toDeepRef:e=!1,toKind:t=2,...r}={},s=null,n=null){return super.jsonfy({toDeepRef:e,toKind:t,...r},s=null,n)}};var gt=class u extends Pe{static get syntaxRules(){return[{syntaxes:[[{type:["ColumnRef1","LQBackRefAbstraction"],as:"left",peek:[1,"operator","~>"]},{type:"operator",value:"~>"}],[{type:"ColumnRef1",as:"left",peek:[3,"operator","~>"]},{type:"operator",value:"~>"}]]},{type:this._rightType,as:"right"}]}static get syntaxPriority(){return 1}rhsTable(e,t){return this.left()?.qualifier?.()instanceof d.LQBackRefAbstraction?this._normalize().rhsTable(e,t):this.left()instanceof d.LQBackRefAbstraction?this.left().expr().rhsTable(e,t):super.rhsTable(e,t)}_normalize(){let e=this.left(),t=this.right(),r=e.qualifier().jsonfy(),s={...e.jsonfy(),qualifier:void 0,nodeName:d.ColumnRef2.NODE_NAME},n=u.fromJSON({left:r,right:{nodeName:Pe.NODE_NAME,left:s,right:t.jsonfy()}});return this._adoptNodes(n),n}resolve(e,t,r=1){if(!e||!t)return;if(this.left()?.qualifier?.()instanceof d.LQBackRefAbstraction)return this._normalize().resolve(e,t,r);let s;if(this.right()instanceof d.ColumnRef2?s=this.right().clone({toKind:r}):this.right()instanceof d.LQDeepDeepRef1?s=this.right().clone({toDeepRef:!0,toKind:r}):s=this.right(),this.left()instanceof d.LQBackRefAbstraction)return{...this.left().expr().resolve(e,t,r),detail:s};let n=this.left().resolve(e,t),a=this.rhsTable(e,t),o=a.resultSchema().pkConstraint(!0)?.columns()[0]?.resolve(e,t);if(!o)throw new Error(`[${this.parentNode||this}] The referenced RHS table ${a} does not have a primary key.`);return{lhsOperand:n,rhsOperand:o.clone({toKind:r}),rhsTable:a,detail:s}}};var cs=class extends gt{static get _rightType(){return["LQDeepDeepRef2","ColumnRef2","ColumnsConstructor"]}static get syntaxPriority(){return-1}resolve(e,t,r=2){return super.resolve(e,t,r)}jsonfy({toDeepRef:e=!1,toKind:t=2,...r}={},s=null,n=null){return super.jsonfy({toDeepRef:e,toKind:t,...r},s,n)}};var fs=class extends Ie{static get syntaxRules(){return[{type:"identifier",as:"."},{type:"LQVersionSpec",as:"version_spec",optional:!0,autoSpacing:!1}]}static get syntaxPriority(){return-1}versionSpec(){return this._get("version_spec")}lookup(e=null,t=null,r=null){if(!r)return[];let s=this._get("value"),n=!s&&!e,a=[],o=c=>{if(!(c instanceof d.SchemaSchema)||s&&!c.identifiesAs(this))return!1;let l;if(e&&!(l=e(c)))return!1;if(l instanceof w||Array.isArray(l))return l;let f=ColumnRef2.fromJSON({...c.name().jsonfy({nodeNames:!1}),ddl_schema:c});return this.parentNode._adoptNodes(f),f};for(let c of r.catalog)if(a=a.concat(o(c)||[]),!n&&a.length)break;return a}jsonfy(e={},t=null,r=null){let s;return e.deSugar&&!this.resultSchema()&&r?s=this.resolve(t,r).jsonfy():s=super.jsonfy(e,t,r),(e.deSugar===!0||e.deSugar?.normalizeCasing)&&!s.delim&&(s={...s,value:s.value.toLowerCase()}),(e.deSugar===!0||e.deSugar?.dropVersionSpecs)&&s.version_spec&&(s={...s,version_spec:void 0}),s}};var Ye=class extends Ge(Ie){static get _qualifierType(){return"SchemaRef"}static get syntaxRules(){return this.buildSyntaxRules({syntax:[{type:"identifier",as:"."},{type:"LQVersionSpec",as:"version_spec",optional:!0,autoSpacing:!1}],autoSpacing:!1})}versionSpec(){return this._get("version_spec")}dataType(){return d.DataType.fromJSON({value:"SET"})}canReferenceInlineTables(){return!0}lookup(e=null,t=null,r=null){if(!t&&!r)return[];let s=this._get("value"),n=(!s||s==="*")&&(!e||this.parentNode?.value?.()==="*"),a=this.parentNode instanceof d.FromItem,o=this.statementNode?.parentNode instanceof d.DerivedQuery?this.statementNode?.parentNode:null,c=a||!o||!(o.parentNode instanceof d.FromItem)||!(o.parentNode.parentNode?.parentNode instanceof d.SelectStmt)||o.parentNode.lateralKW(),l=[],f=(p,m=void 0,h="default")=>{if(p instanceof d.JSONSchema&&(!s||s==="*")&&e)return e(p,m,h);if(!(p instanceof d.TableSchema)||s&&s!=="*"&&!p.identifiesAs(this))return!1;let g;if(e&&!(g=e(p,m,h)))return!1;if(g instanceof w||Array.isArray(g))return g;let _=this.constructor.fromJSON({...p.name().jsonfy({nodeNames:!1}),resolution:h,qualifier:m,result_schema:p});return this.parentNode?._adoptNodes(_),_};if(((this.options.dialect||"postgres")==="postgres"?["EXCLUDED"]:[]).includes(s?.toUpperCase())&&t){let p=[...t.statementContext.artifacts.get("tableSchemas")][0].resultSchema.clone({renameTo:{nodeName:d.Identifier.NODE_NAME,value:s}});return[].concat(f(p,void 0,"system")||[])}if(this.canReferenceInlineTables()&&t){let p=t.statementContext,m,h,g=new Set;do{h=p!==t.statementContext,a||g.add(p);for(let{type:_,resultSchema:x}of p.artifacts.get("tableSchemas")){if(a){if(_!=="CTEItem")continue}else{if(_==="CTEItem"||m&&m!=="dml"&&_==="dml")continue;m||(m=_)}if(l=l.concat(f(x,void 0,_==="CTEItem"?"cte":h?"scope":"default")||[]),l.length&&!n){for(let E of g)E.artifacts.has("derivedQueryCorrelationFlag")&&E.artifacts.set("derivedQueryCorrelationFlag",!0);break}}}while(c&&(n||!l.length)&&(p=p.parentTransformer?.statementContext))}if(!e&&(n||!l.length)){let p=new d.SchemaRef(this.qualifier()?.jsonfy()||{});this._adoptNodes(p),l=l.concat(p.lookup(m=>m._get("entries").reduce((h,g)=>{let _={...m.name().jsonfy({nodeNames:!1}),result_schema:m};return h.concat(f(g,_)||[])},[]),t,r))}if(s==="*"){let p=d.TableRef0.fromJSON({value:this.value(),result_schema:d.JSONSchema.fromJSON({entries:l.map(m=>m.clone())},{assert:!0})});this.parentNode._adoptNodes(p),l=[p]}return l}jsonfy(e={},t=null,r=null){let s;return e.deSugar&&((e.deSugar===!0||e.deSugar.tableQualifiers)&&!this.qualifier()||!this.resultSchema())&&(t||r)?(s=this.resolve(t,r).jsonfy(),(e.deSugar===!0||e.deSugar.normalizeCasing)&&!s.delim&&(s={...s,value:s.resolution==="system"?s.value.toUpperCase():s.value.toLowerCase()}),!(e.deSugar===!0||e.deSugar.tableQualifiers)&&!this.qualifier()&&(s={...s,qualifier:void 0})):s=super.jsonfy(e,t,r),(e.deSugar===!0||e.deSugar?.dropVersionSpecs)&&s.version_spec&&(s={...s,version_spec:void 0}),s}};var ps=class extends Ye{static get _qualifierType(){return["SchemaRef"]}static get syntaxRules(){return this.buildSyntaxRules({type:"operator",as:".",value:"*",autoSpacing:!1})}static get syntaxPriority(){return-1}dataType(){return d.DataType.fromJSON({value:"SET"})}};var ms=class extends Ye{canReferenceInlineTables(){return!1}};var ys=class extends le{static get syntaxPriority(){return-1}};var ds=class extends se{static get syntaxRules(){return{type:"bind_var",as:"."}}value(){return this._get("value")}};var hs=class extends se{static get syntaxRules(){return{type:"system_var",as:"."}}value(){return this._get("value")}};var _s=class extends se{static get syntaxRules(){return{type:"user_var",as:"."}}value(){return this._get("value")}};var $t=class extends se{static get syntaxRules(){return{type:Si,expression:1}}static[Symbol.hasInstance](e){return e instanceof se||e.constructor.name in we}},Ei=Object.keys(we),Si=Ei.filter(u=>we[u]!==$t&&we[u].syntaxPriority!==-1).sort((u,e)=>{let t=(we[e].syntaxPriority??100)-(we[u].syntaxPriority??100);return t===0?we[e].prototype.isPrototypeOf(we[u].prototype)?-1:1:t});var gs=class extends Ge(le){static get _qualifierType(){return"TableRef2"}};var xs=class extends le{};var Es=class extends Ge(le){static get _qualifierType(){return"SchemaRef"}};var Ss=class extends Re{};var Ns=class extends Ne{static get syntaxRules(){return[{type:"Identifier",as:"name",assert:!0}]}};var ws=class extends Re{};var xt=class extends Ne{static get syntaxRules(){return[{type:"SchemaIdent",as:"name",assert:!0},{type:"paren_block",syntax:{type:"TableSchema",as:"entries",arity:1/0,itemSeparator:{type:"punctuation",value:","},singletons:"BY_KEY",autoIndent:!0}}]}tables(){let e=[];for(let t of this)t instanceof d.TableSchema&&e.push(t);return e}};var As=class extends Re{};var Ts=class extends Ne{static get syntaxRules(){let e={type:"punctuation",value:","},t=["TablePKConstraint","TableFKConstraint","TableUKConstraint","PGTableEXConstraint","CheckConstraint","ColumnSchema","IndexSchema"];return[{type:["TableIdent","Identifier"],as:"name"},{type:"paren_block",syntaxes:[{type:t,as:"entries",arity:1/0,itemSeparator:e,singletons:"BY_KEY",optional:!0,dialect:"postgres",autoIndent:!0},{type:t,as:"entries",arity:{min:1},itemSeparator:e,singletons:"BY_KEY",dialect:"mysql",autoIndent:!0}]}]}columns(){let e=[];for(let t of this)t instanceof d.ColumnSchema&&e.push(t);return e}pkConstraint(e=!1){for(let t of this){if(t instanceof d.TablePKConstraint)return t;let r;if(e&&t instanceof d.ColumnSchema&&(r=t.pkConstraint())){let s=d.TablePKConstraint.fromJSON({...r.jsonfy(),nodeName:void 0,columns:[d.ColumnRef2.fromJSON({value:t.name().value()})]});return this._adoptNodes(s),s}}}fkConstraints(e=!1){let t=[];for(let r of this){r instanceof d.TableFKConstraint&&t.push(r);let s;if(e&&r instanceof d.ColumnSchema&&(s=r.fkConstraint())){let n=d.TableFKConstraint.fromJSON({...s.jsonfy(),nodeName:void 0,columns:[d.ColumnRef2.fromJSON({value:r.name().value()})]});this._adoptNodes(n),t.push(n)}}return t}ukConstraints(e=!1){let t=[];for(let r of this){r instanceof d.TableUKConstraint&&t.push(r);let s;if(e&&r instanceof d.ColumnSchema&&(s=r.ukConstraint())){let n=d.TableUKConstraint.fromJSON({...s.jsonfy(),nodeName:void 0,columns:[d.ColumnRef2.fromJSON({value:r.name().value()})]});this._adoptNodes(n),t.push(n)}}return t}ckConstraints(e=!1){let t=[];for(let r of this){r instanceof d.CheckConstraint&&t.push(r);let s;e&&r instanceof d.ColumnSchema&&(s=r.ckConstraint()?.clone())&&(this._adoptNodes(s),t.push(s))}return t}jsonfy({normalized:e=!1,...t}={},r=null,s=null){let n=[],a={[d.ColumnPKConstraint.NODE_NAME]:d.TablePKConstraint.NODE_NAME,[d.ColumnFKConstraint.NODE_NAME]:d.TableFKConstraint.NODE_NAME,[d.ColumnUKConstraint.NODE_NAME]:d.TableUKConstraint.NODE_NAME,[d.CheckConstraint.NODE_NAME]:d.CheckConstraint.NODE_NAME};e&&(r=new ae((c,l)=>{if(c?.NODE_NAME in a&&c.parentNode instanceof d.ColumnSchema){n.push({...c.jsonfy(),nodeName:a[c.NODE_NAME],...c instanceof d.CheckConstraint?{}:{columns:[d.ColumnRef2.fromJSON({value:c.parentNode.name().value()})]}});return}return l()},r));let o=super.jsonfy(t,r,s);return e&&(o={...o,entries:o.entries.concat(n)}),o}};var Ae=class extends Fe{static get syntaxRules(){return{type:["CreateSchemaStmt","DropSchemaStmt","CreateTableStmt","DropTableStmt"]}}};var Os=class extends Ae{static get syntaxRules(){let e={type:["SchemaIdent","Identifier"],as:"name"},t={syntax:[{type:"keyword",value:"AUTHORIZATION"},{syntaxes:[{type:"keyword",as:"pg_authorization",value:["CURRENT_ROLE","CURRENT_USER","SESSION_USER"]},{type:"Identifier",as:"pg_authorization"}]}]},r={type:["CreateTableStmt"],as:"pg_entries",arity:1/0,optional:!0,dialect:"postgres"};return[{type:"keyword",value:"CREATE"},{type:"keyword",value:"SCHEMA",dialect:"postgres"},{type:"keyword",value:["SCHEMA","DATABASE"],dialect:"mysql"},{dialect:"postgres",syntaxes:[[{type:"keyword",as:"if_not_exists",value:"IF",booleanfy:!0},{type:"operator",value:"NOT"},{type:"keyword",value:"EXISTS"},{syntaxes:[[{...e},{...t,optional:!0}],{...t}]}],[{...e},{...t,optional:!0},{...r}],[{...t},{...r}]]},{dialect:"mysql",syntax:[{optional:!0,syntax:[{type:"keyword",as:"if_not_exists",value:"IF",booleanfy:!0},{type:"operator",value:"NOT"},{type:"keyword",value:"EXISTS"}]},{...e}]}]}ifNotExists(){return this._get("if_not_exists")}name(){return this._get("name")}pgAuthorization(){return this._get("pg_authorization")}pgEntries(){return this._get("pg_entries")}};var vs=class extends Ae{static get syntaxRules(){return[{type:"keyword",value:"DROP"},{type:"keyword",value:"SCHEMA",dialect:"postgres"},{type:"keyword",value:["SCHEMA","DATABASE"],dialect:"mysql"},{optional:!0,syntax:[{type:"keyword",as:"if_exists",value:"IF",booleanfy:!0},{type:"keyword",value:"EXISTS"}]},{type:["SchemaIdent","Identifier"],as:"pg_names",arity:{min:1},itemSeparator:{type:"punctuation",value:","},dialect:"postgres"},{type:["SchemaIdent","Identifier"],as:"my_name",dialect:"mysql"},{type:"keyword",as:"pg_cascade_rule",value:["CASCADE","RESTRICT"],optional:!0,dialect:"postgres"}]}ifExists(){return this._get("if_exists")}pgNames(){return this._get("pg_names")}myName(){return this._get("my_name")}pgCascadeRule(){return this._get("pg_cascade_rule")}};var bs=class extends Ae{static get syntaxRules(){return[{type:"keyword",value:"CREATE"},{optional:!0,syntaxes:[{type:"keyword",as:"temporary_kw",value:"TEMPORARY",booleanfy:!0},{type:"keyword",as:"temporary_kw",value:"TEMP",booleanfy:!0,dialect:"postgres"}]},{type:"keyword",value:"TABLE"},{optional:!0,syntax:[{type:"keyword",as:"if_not_exists",value:"IF",booleanfy:!0},{type:"operator",value:"NOT"},{type:"keyword",value:"EXISTS"}]},{type:"TableSchema",as:"argument"},{type:["ConfigAssignmentExprAlt1","ConfigAssignmentExprAlt2"],as:"my_create_options",arity:1/0,dialect:"mysql"}]}temporaryKW(){return this._get("temporary_kw")}ifNotExists(){return this._get("if_not_exists")}argument(){return this._get("argument")}myCreateOptions(){return this._get("my_create_options")}};var Rs=class extends Ae{static get syntaxRules(){return[{type:"keyword",value:"DROP"},{type:"keyword",as:"my_temporary_kw",value:"TEMPORARY",booleanfy:!0,optional:!0,dialect:"mysql"},{type:"keyword",value:"TABLE"},{optional:!0,syntax:[{type:"keyword",as:"if_exists",value:"IF",booleanfy:!0},{type:"keyword",value:"EXISTS"}]},{type:["TableIdent","Identifier"],as:"names",arity:{min:1},itemSeparator:{type:"punctuation",value:","}},{type:"keyword",as:"cascade_rule",value:["CASCADE","RESTRICT"],optional:!0}]}myTemporaryKW(){return this._get("my_temporary_kw")}ifExists(){return this._get("if_exists")}names(){return this._get("names")}cascadeRule(){return this._get("cascade_rule")}};var ua={};be(ua,{AssignmentExpr:()=>Js,ColumnsConstructor:()=>$s,ConfigAssignmentExpr:()=>Fs,ConfigAssignmentExprAlt1:()=>Gs,ConfigAssignmentExprAlt2:()=>qs,DeleteStmt:()=>Ys,InsertStmt:()=>Qe,MYOnDuplicateKeyUpdateClause:()=>Cs,MYPartitionClause:()=>Is,MYSetStmt:()=>Qs,MYVarAssignmentExpr:()=>Ws,PGConflictTarget:()=>ks,PGConflictTargetIndexSpec:()=>Ds,PGDefaultValuesClause:()=>Ls,PGOnConflictClause:()=>Ms,PGWhereCurrentClause:()=>js,ReturningClause:()=>Ps,SetClause:()=>Us,TableAbstraction1:()=>Ks,TableAbstraction2:()=>Hs,UpdateStmt:()=>zs,UpsertStmt:()=>Xs,UsingFromClause:()=>Bs,ValuesConstructor:()=>St});var Cs=class extends L{static get syntaxRules(){return{dialect:"mysql",syntax:[{type:"keyword",value:"ON"},{type:"keyword",value:"DUPLICATE"},{type:"keyword",value:"KEY"},{type:"keyword",value:"UPDATE"},{type:"AssignmentExpr",as:"entries",arity:{min:1},itemSeparator:{type:"punctuation",value:","},assert:!0,autoIndent:!0}]}}};var Is=class extends L{static get syntaxRules(){return{dialect:"mysql",syntax:[{type:"keyword",value:"PARTITION"},{type:"Identifier",as:"entries",arity:{min:1},itemSeparator:{type:"punctuation",value:","},assert:!0}]}}};var ks=class extends w{static get syntaxRules(){return{syntaxes:[[{type:"keyword",value:"ON"},{type:"keyword",value:"CONSTRAINT"},{type:"Identifier",as:"constraint_name",assert:!0}],[{type:"paren_block",syntax:{type:"PGConflictTargetIndexSpec",as:"index_list",arity:{min:1},itemSeparator:{type:"punctuation",value:","},assert:!0},autoIndent:!0},{type:"WhereClause",as:"where_clause",optional:!0,autoIndent:!0}]]}}constraintName(){return this._get("constraint_name")}indexList(){return this._get("index_list")}whereClause(){return this._get("where_clause")}};var Ds=class extends w{static get syntaxRules(){return[{syntaxes:[{type:"ColumnRef2",as:"column_name"},{type:"paren_block",syntax:{type:"Expr",as:"expr",assert:!0},autoIndent:!0},{type:"CallExpr",as:"expr"}]},{optional:!0,syntax:[{type:"operator",value:"COLLATE"},{type:"string_literal",as:"collation",assert:!0}]},{type:"Identifier",as:"opclass",optional:!0}]}columnName(){return this._get("column_name")}expr(){return this._get("expr")}collation(){return this._get("collation")}opclass(){return this._get("opclass")}};var Ls=class extends w{static get syntaxRules(){return{dialect:"postgres",syntax:[{type:"keyword",as:".",value:"DEFAULT"},{type:"keyword",value:"VALUES"}]}}};var Ms=class extends L{static get syntaxRules(){return{dialect:"postgres",syntax:[{type:"keyword",value:"ON"},{type:"keyword",value:"CONFLICT"},{syntaxes:[[{type:"PGConflictTarget",as:"conflict_target",optional:!0},{type:"keyword",as:"do_nothing_kw",value:"DO",booleanfy:!0},{type:"keyword",value:"NOTHING"}],[{type:"PGConflictTarget",as:"conflict_target"},{type:"keyword",value:"DO"},{type:"keyword",value:"UPDATE"},{type:"keyword",value:"SET"},{type:"AssignmentExpr",as:"entries",arity:{min:1},itemSeparator:{type:"punctuation",value:","},assert:!0,autoIndent:!0},{type:"WhereClause",as:"where_clause",optional:!0,autoIndent:!0}]]}]}}conflictTarget(){return this._get("conflict_target")}doNothingKW(){return this._get("do_nothing_kw")}whereClause(){return this._get("where_clause")}};var Et=class extends X(L){static get syntaxRules(){return{type:"SelectItem",as:"entries",arity:{min:1},itemSeparator:{type:"punctuation",value:","},assert:!0,autoIndent:2}}jsonfy(e={},t=null,r=null){let s=super.jsonfy(e,t,r);if(!e.deSugar)return s;let n=[],a=e.deSugar===!0||e.deSugar?.flattenUnaliasedRootObjects,o=!1,c=l=>{o&&(n=n.reduce((f,y)=>l.alias&&y.alias&&V(l.alias.value,y.alias.value,l.alias.delim||y.alias.delim)?f:f.concat(y),[])),n=n.concat(l)};for(let[l,f]of s.entries.entries())if(f.expr.value==="*")for(let y of f.result_schema){let p=y.jsonfy(),m={nodeName:d.SelectItemAlias.NODE_NAME,as_kw:!0,value:p.value,delim:p.delim};c({nodeName:d.SelectItem.NODE_NAME,expr:p,alias:m,result_schema:p.result_schema.clone(),_originalStarJson:f})}else if(a&&this.entries()[l].expr()instanceof d.LQObjectLiteral&&!this.entries()[l].alias()){let[y]=f.expr.arguments.reduce(([m,h],g)=>h?[[...m,[h,g]]]:[m,g],[[]]),p=f.expr.result_schema.entries();for(let m=0;m<y.length;m++)c({nodeName:d.SelectItem.NODE_NAME,expr:y[m][1],alias:{...y[m][0],nodeName:d.SelectItemAlias.NODE_NAME,as_kw:!0},result_schema:p[m]})}else c(f);return{...s,entries:n}}finalizeJSON(e,t,r,s){let n=s.deSugar===!0||s.deSugar?.expandStarRefs,a,[o,c]=e.entries.reduce(([l,f],{_originalStarJson:y,...p})=>{if(y&&(a=!0),y&&!n)return y.result_schema||(y.result_schema=d.JSONSchema.fromJSON({entries:[]},{assert:!0})),y.result_schema._add("entries",p.result_schema),[l.concat(y),f.concat(p.result_schema.clone())];if(!p.result_schema){let m=d.SelectItem.fromJSON(p,this.options);this._adoptNodes(m),p=m.jsonfy(s,t,r)}return[l.concat(p),f.concat(p.result_schema.clone())]},[[],[]]);return e={...e,entries:a&&!n?[...new Set(o)]:o,result_schema:d.JSONSchema.fromJSON({entries:c},{assert:!0})},t.statementContext.artifacts.set("outputSchemas",new Set(c)),e}};var Ps=class extends Et{static get syntaxRules(){return[{type:"keyword",value:"RETURNING"},...[].concat(super.syntaxRules)]}};var js=class extends w{static get syntaxRules(){return{dialect:"postgres",syntax:[{type:"keyword",value:"WHERE"},{type:"keyword",value:"CURRENT OF"},{type:"identifier",as:"cursor_name",assert:!0}]}}cursorName(){return this._get("cursor_name")}};var Us=class extends L{static get syntaxRules(){return[{type:"keyword",value:"SET"},{type:"AssignmentExpr",as:"entries",arity:{min:1},itemSeparator:{type:"punctuation",value:","},assert:!0,autoIndent:2}]}};var Bs=class extends L{static get syntaxRules(){return[{type:"keyword",value:"USING"},{type:"FromItem",as:"entries",arity:{min:1},itemSeparator:{type:"punctuation",value:","},assert:!0}]}};var $s=class extends L{static get syntaxRules(){return{syntax:[{type:"paren_block",syntax:{type:["LQDeepRef2","ColumnRef2"],as:"entries",arity:1/0,itemSeparator:{type:"punctuation",value:","},autoIndent:10}}]}}static get syntaxPriority(){return-1}};var St=class extends X(L){static get syntaxRules(){let e={type:"punctuation",value:","};return{syntaxes:[[{type:"keyword",value:"VALUES"},{type:["TypedRowConstructor","RowConstructor"],as:"entries",arity:{min:1},itemSeparator:e,assert:!0,autoIndent:2}],{dialect:"mysql",syntax:[{type:"keyword",value:["VALUES","VALUE"]},{type:["TypedRowConstructor","RowConstructor"],as:"entries",arity:{min:1},itemSeparator:e,assert:!0,autoIndent:2}]}]}}static get syntaxPriority(){return-1}jsonfy(e={},t=null,r=null){let s=super.jsonfy({...e,forceDeSugar:e.deSugar},t,r);if(e.deSugar){let n=s.entries?.[0]?.result_schema;s={...s,result_schema:n?.clone()}}return s}};var Js=class extends te{static get syntaxRules(){return[{type:["LQDeepRef2","ColumnsConstructor","ColumnRef2"],as:"left",dialect:"postgres"},{type:["LQDeepRef2","ColumnRef1"],as:"left",dialect:"mysql"},{type:"operator",as:"operator",value:"="},{type:["ValuesTableLiteral","DerivedQuery","Expr"],as:"right"}]}};var Fs=class extends te{static get syntaxRules(){return[{type:"keyword",as:"my_default_kw",value:"DEFAULT",booleanfy:!0,dialect:"mysql",optional:!0},{syntaxes:[{type:"keyword",as:"left"},{type:"identifier",as:"left"}]},{type:"operator",as:"operator",value:"="},{syntaxes:[{type:"Expr",as:"right"},{type:"keyword",as:"right"}]}]}myDefaultKW(){return this._get("my_default_kw")}};var Gs=class extends te{static get syntaxRules(){return[{type:"keyword",as:"my_default_kw",value:"DEFAULT",booleanfy:!0,dialect:"mysql",optional:!0},{syntaxes:[{type:"keyword",as:"left"},{type:"identifier",as:"left"}]},{type:"operator",as:"operator",value:"=",optional:!0},{syntaxes:[{type:"Expr",as:"right"},{type:"keyword",as:"right"}]}]}myDefaultKW(){return this._get("my_default_kw")}};var qs=class extends te{static get syntaxRules(){return[{type:"keyword",as:"default_kw",value:"DEFAULT",booleanfy:!0,optional:!0},{syntaxes:[{type:"keyword",as:"left"},{type:"identifier",as:"left"}]},{optional:!0,syntax:[{type:"operator",as:"operator",value:"="},{syntaxes:[{type:"Expr",as:"right"},{type:"keyword",as:"right"}]}]}]}myDefaultKW(){return this._get("my_default_kw")}};var Ws=class extends te{static get syntaxRules(){return{dialect:"mysql",syntax:[{type:["UserVar","SystemVar"],as:"left"},{type:"operator",as:"operator",value:["=",":="]},{type:"Expr",as:"right"}]}}};var Hs=class extends X(w){static get syntaxRules(){return[{type:"keyword",as:"pg_only_kw",value:"ONLY",optional:!0,dialect:"postgres"},{type:"TableRef1",as:"table_ref",assert:!0},{type:"operator",as:"pg_star_ref",value:"*",booleanfy:!0,optional:!0,dialect:"postgres"},{type:"SelectItemAlias",as:"alias",optional:!0}]}tableRef(){return this._get("table_ref")}alias(){return this._get("alias")}pgOnlyKW(){return this._get("pg_only_kw")}pgStarRef(){return this._get("pg_star_ref")}deriveAlias(){let e;return this.alias()?e=this.alias():e=d.SelectItemAlias.fromJSON({as_kw:!0,value:this.tableRef().value(),delim:this.tableRef()._get("delim")}),e}jsonfy(e={},t=null,r=null){let s=super.jsonfy(e,t,r);if(e.deSugar){let n=s.alias||this.deriveAlias().jsonfy(),a={nodeName:d.Identifier.NODE_NAME,value:n.value,delim:n.delim},o=s.table_ref.result_schema.clone({renameTo:a});s.alias&&(o=o.clone({renameTo:{nodeName:d.Identifier.NODE_NAME,value:s.alias.value,delim:s.alias.delim}})),t.statementContext.artifacts.get("tableSchemas").add({resultSchema:o});let c=(e.deSugar===!0||e.deSugar?.tableAliases)&&n||s.alias;s={...s,alias:c,result_schema:o}}return s}};var Ks=class extends X(w){static get syntaxRules(){return[{type:"TableRef1",as:"table_ref"},{optional:!0,dialect:"mysql",syntax:[{type:"punctuation",value:".",autoSpacing:!1},{type:"operator",as:"my_star_ref",value:"*",booleanfy:!0,autoSpacing:!1}]},{type:"SelectItemAlias",as:"alias",optional:!0}]}tableRef(){return this._get("table_ref")}myStarRef(){return this._get("my_star_ref")}alias(){return this._get("alias")}deriveAlias(){let e;return this.alias()?e=this.alias():e=d.SelectItemAlias.fromJSON({as_kw:!0,value:this.tableRef().value(),delim:this.tableRef()._get("delim")}),e}jsonfy(e={},t=null,r=null){let s=super.jsonfy(e,t,r);if(e.deSugar){let n=s.alias||this.deriveAlias().jsonfy(),a={nodeName:d.Identifier.NODE_NAME,value:n.value,delim:n.delim},o=s.table_ref.result_schema.clone({renameTo:a});s.alias&&(o=o.clone({renameTo:{nodeName:d.Identifier.NODE_NAME,value:s.alias.value,delim:s.alias.delim}})),t.statementContext.artifacts.get("tableSchemas").add({resultSchema:o});let c=(e.deSugar===!0||e.deSugar?.tableAliases)&&n||s.alias;s={...s,alias:c,result_schema:o}}return s}};var Nt=u=>class extends u{get isSelectorStmt(){return!0}jsonfy(e={},t=null,r=null){if(!e.deSugar)return super.jsonfy(e,t,r);let{ColumnRef1:s,ColumnRef2:n,AggrCallExpr:a,LQBackRefAbstraction:o,LQDeepRef1:c,LQBackRef:l}=d;return t=new ae((f,y,p,{deSugar:m,asAggr:h,...g})=>{let _=S=>S instanceof s&&S.qualifier()instanceof o,x=S=>{let N=S.qualifier().jsonfy(),A={...S.jsonfy(),qualifier:void 0,nodeName:n.NODE_NAME},v=c.fromJSON({left:N,right:A});return S.parentNode._adoptNodes(v),v},E=S=>({nodeName:a.NODE_NAME,name:(g.toDialect||this.options.dialect)==="mysql"?"JSON_ARRAYAGG":"JSON_AGG",arguments:[S]});if(_(f)&&(f=x(f)),f instanceof c){let{select:S,detail:N}=this.createSelectorDimension(f,t,r,{...g,asAggr:h}),A=h?E(N.jsonfy()):N.jsonfy();return S(A)}if(f instanceof l||f instanceof o){f instanceof o&&(f=f.expr());let{alias:S}=this.createSelectorDimension(f,t,r,g);return S()}return y()},t,this),super.jsonfy(e,t,r)}createSelectorDimension(e,t,r,{asAggr:s=!1,...n}={}){let{lhsOperand:a,rhsOperand:o,rhsTable:c,detail:l}=e.resolve(t,r),f=t.statementContext.artifacts.get("selectorDimensions"),{CompleteSelectStmt:y,DerivedQuery:p,FromClause:m,JoinClause:h,OnClause:g,GroupByClause:_,GroupingElement:x,FromItem:E,SelectList:S,SelectItem:N,FromItemAlias:A,SelectItemAlias:v,TableRef1:O,ColumnRef1:T,BinaryExpr:b}=d,R=`dimension${s?"/g":""}|${[a,o,c].join("|")}`,M=t.statementContext.hash(R,"join");if(f?.has(M))return{...f.get(M),detail:l};let G=new Map,B=t.rand("key",G),j=o.jsonfy(),q={nodeName:N.NODE_NAME,expr:j,alias:{nodeName:v.NODE_NAME,as_kw:!0,value:B}},I={nodeName:h.NODE_NAME,join_type:"LEFT",expr:{nodeName:p.NODE_NAME,expr:{nodeName:y.NODE_NAME,select_list:{nodeName:S.NODE_NAME,entries:[q]},from_clause:{nodeName:m.NODE_NAME,entries:[{nodeName:E.NODE_NAME,expr:c.jsonfy({...n,deSugar:null})}]},group_by_clause:s?{nodeName:_.NODE_NAME,entries:[{nodeName:x.NODE_NAME,expr:{nodeName:T.NODE_NAME,value:B}}]}:void 0}},alias:{nodeName:A.NODE_NAME,as_kw:!0,value:M},condition_clause:{nodeName:g.NODE_NAME,expr:{nodeName:b.NODE_NAME,operator:"=",left:a.jsonfy({...n,deSugar:null},t,r),right:{nodeName:T.NODE_NAME,qualifier:{nodeName:O.NODE_NAME,value:M},value:B}}}},J={id:M,type:"join",query:I,alias:()=>({nodeName:O.NODE_NAME,value:M}),select:Y=>{let k=t.rand("ref",G);return I.expr.expr.select_list.entries.push({nodeName:N.NODE_NAME,expr:Y,alias:{nodeName:v.NODE_NAME,as_kw:!0,value:k}}),{nodeName:T.NODE_NAME,qualifier:{nodeName:O.NODE_NAME,value:M},value:k}},detail:l};return f.set(M,J),J}finalizeSelectorJSON(e,t,r,s){let n;[e,n]=this.preprocessSelectorDimensions(e,t,r,s),e={...e,join_clauses:e.join_clauses?.slice(0)||[]};for(let a of n){let o=d.JoinClause.fromJSON(a,this.options);this._adoptNodes(o);let c=t.transform(o,(l=s,f=t)=>o.jsonfy(l,f,r),null,s);e.join_clauses.push(c)}return e}preprocessSelectorDimensions(e,t,r,s){let n=t.statementContext.artifacts.get("selectorDimensions");if(!n.size)return[e,[]];if(this.options.dialect==="postgres"&&(this instanceof d.DeleteStmt||this instanceof d.UpdateStmt)){if(e.where_clause?.cursor_name)throw new Error('Deep/Back Refs are currently not supported with a "WHERE CURRENT OF..." statement');let{DerivedQuery:a,CompleteSelectStmt:o,SelectList:c,SelectItem:l,FromItemAlias:f,FromClause:y,WhereClause:p,TableRef1:m,BinaryExpr:h,FromItem:g}=d,_=t.rand("join"),x=e.table_expr,E=x.alias.value,S=x.alias.delim,N=`${_}:${E}`,v=x.result_schema.pkConstraint(!0)?.columns()[0].jsonfy({toKind:1}),O,T,b=q=>({nodeName:h.NODE_NAME,left:{...q,qualifier:{nodeName:m.NODE_NAME,value:E,delim:S}},operator:"=",right:{...q,qualifier:{nodeName:m.NODE_NAME,value:N}}}),R,M=q=>{if(!V(q.qualifier.value,E,q.qualifier.delim||S))return q;if(!O){let I={nodeName:g.NODE_NAME,expr:{nodeName:a.NODE_NAME,expr:{nodeName:o.NODE_NAME,select_list:{nodeName:c.NODE_NAME,entries:[]},from_clause:{nodeName:y.NODE_NAME,entries:[{nodeName:g.NODE_NAME,expr:x.table_ref}]}}},alias:{nodeName:f.NODE_NAME,as_kw:!0,value:N}};R=I.expr.expr.select_list.entries,v&&(R.push({nodeName:l.NODE_NAME,expr:v}),T={nodeName:p.NODE_NAME,expr:b(v)}),O=I}if(R.find(I=>V(I.expr.value,q.value,I.expr.delim||q.delim))||R.push({nodeName:l.NODE_NAME,expr:q}),!v){let I=b(q);T&&(I={nodeName:h.NODE_NAME,left:T.expr,operator:"AND",right:I}),T={nodeName:p.NODE_NAME,expr:I}}return{...q,qualifier:{nodeName:m.NODE_NAME,value:N}}},G=[];for(let[,{query:q}]of n)G.push({...q,condition_clause:{...q.condition_clause,expr:{...q.condition_clause.expr,left:M(q.condition_clause.expr.left)}}});let[B,j]=this instanceof d.DeleteStmt?["pg_using_clause","UsingFromClause"]:["pg_from_clause","FromClause"];if(O){let q=g.fromJSON(O,this.options);this._adoptNodes(q),e={...e,[B]:{nodeName:d[j].NODE_NAME,entries:(e[B]?.entries||[]).concat(q.jsonfy(s,t,r))},where_clause:e.where_clause?{nodeName:p.NODE_NAME,expr:{nodeName:h.NODE_NAME,left:T.expr,operator:"AND",right:e.where_clause.expr}}:T}}return[e,G]}return[e,[...n].map(([,{query:a}])=>a)]}};var Ve=class extends Se{static get syntaxRules(){return{type:["InsertStmt","UpsertStmt","UpdateStmt","DeleteStmt"]}}finalizeOutputJSON(e,t,r,s){if(e.returning_clause){let n=this.returningClause().finalizeJSON(e.returning_clause,t,r,s);e={...e,returning_clause:n,result_schema:n.result_schema}}else e={...e,result_schema:d.JSONSchema.fromJSON({entries:[]},this.options)};return e}};var Ys=class extends Nt(Ve){static get syntaxRules(){let e={type:"punctuation",value:","};return[{type:"keyword",value:"DELETE"},{assert:!0,syntaxes:[{dialect:"postgres",syntax:[{type:"keyword",value:"FROM"},{type:"TableAbstraction2",as:"table_expr"},{type:"UsingFromClause",as:"pg_using_clause",optional:!0,autoIndent:!0},{type:"JoinClause",as:"join_clauses",arity:1/0,optional:!0,autoIndent:!0},{type:["PGWhereCurrentClause","WhereClause"],as:"where_clause",optional:!0,autoIndent:!0},{type:"ReturningClause",as:"returning_clause",optional:!0,autoIndent:!0}]},{dialect:"mysql",syntax:[{type:"Identifier",as:"my_delete_list",arity:{min:1},itemSeparator:e},{type:"FromClause",as:"my_from_clause",autoIndent:!0},{type:"JoinClause",as:"join_clauses",arity:1/0,optional:!0,autoIndent:!0},{type:"WhereClause",as:"where_clause",optional:!0,autoIndent:!0}]},{dialect:"mysql",syntax:[{type:"keyword",value:"FROM"},{type:"Identifier",as:"my_delete_list",arity:{min:1},itemSeparator:e},{type:"UsingFromClause",as:"my_using_clause",autoIndent:!0},{type:"JoinClause",as:"join_clauses",arity:1/0,optional:!0,autoIndent:!0},{type:"WhereClause",as:"where_clause",optional:!0,autoIndent:!0}]},{dialect:"mysql",syntax:[{type:"keyword",value:"FROM"},{type:"TableAbstraction2",as:"table_expr"},{type:"MYPartitionClause",as:"my_partition_clause",optional:!0,autoIndent:!0},{type:"WhereClause",as:"where_clause",optional:!0,autoIndent:!0},{type:"OrderByClause",as:"my_order_by_clause",optional:!0,dialect:"mysql",autoIndent:!0},{type:"LimitClause",as:"my_limit_clause",optional:!0,dialect:"mysql",autoIndent:!0}]}]}]}tableExpr(){return this._get("table_expr")}joinClauses(){return this._get("join_clauses")}whereClause(){return this._get("where_clause")}returningClause(){return this._get("returning_clause")}pgUsingClause(){return this._get("pg_using_clause")}myUsingClause(){return this._get("my_using_clause")}myPartitionClause(){return this._get("my_partition_clause")}myDeleteList(){return this._get("my_delete_list")}myFromClause(){return this._get("my_from_clause")}myOrderByClause(){return this._get("my_order_by_clause")}myLimitClause(){return this._get("my_limit_clause")}jsonfy(e={},t=null,r=null){if(!e.deSugar)return super.jsonfy(e,t,r);t=new ae((n,a)=>a(),t,this);let s=super.jsonfy(e,t,r);return(e.toDialect||this.options.dialect)==="mysql"?s={uuid:s.uuid,nodeName:s.nodeName,my_delete_list:s.my_delete_list,my_from_clause:s.my_from_clause,my_using_clause:s.my_using_clause,join_clauses:s.join_clauses,where_clause:s.where_clause,table_expr:s.table_expr,my_partition_clause:s.my_partition_clause,my_order_by_clause:s.my_order_by_clause,my_limit_clause:s.my_limit_clause,returning_clause:s.returning_clause,result_schema:s.result_schema}:s={uuid:s.uuid,nodeName:s.nodeName,table_expr:s.table_expr,pg_using_clause:s.pg_using_clause,join_clauses:s.join_clauses,where_clause:s.where_clause,returning_clause:s.returning_clause,result_schema:s.result_schema},s=this.finalizeOutputJSON(s,t,r,e),s=this.finalizeSelectorJSON(s,t,r,e),s={...s,origin_schemas:this.getOriginSchemas(t)},s}};var Vs=u=>class extends u{get isPayloadStmt(){return!0}static morphsTo(){return d.CTE}jsonfy(e={},t=null,r=null){if(!e.deSugar)return super.jsonfy(e,t,r);let{LQDeepRef2:s,AssignmentExpr:n,DerivedQuery:a,ColumnsConstructor:o,ValuesConstructor:c,TypedRowConstructor:l,RowConstructor:f}=d,y=["column_list","pg_default_values_clause","values_clause","select_clause"].map(S=>this._get(S)),[p,m,h,g]=y,_=p?.entries().some(S=>S instanceof s),x=_?new Set(y):new Set;t=new ae((S,N,A,{deSugar:v,...O})=>{if(x.has(S))return;if(!(S instanceof n))return N();let T=!!this._get("conflict_handling_clause")?.containsNode(S);if(T&&this.options.dialect!=="postgres")return N();let b={...O,conflictHandlingClauseContext:T};if(S.left()instanceof s){let[[R],[[M]]]=this.deSugarPayload(o.fromJSON({entries:[S.left().jsonfy()]}),[[S.right()]],t,r,b);return R?{nodeName:n.NODE_NAME,operator:"=",left:R,right:M}:void 0}if(S.left()instanceof o&&S.left().entries().some(R=>R instanceof s)){let R=S.left(),M,G;return S.right()instanceof f?([M,[G]]=this.deSugarPayload(R,[S.right().entries()],t,r,b),G={nodeName:l.NODE_NAME,entries:G}):S.right()instanceof a?([M,G]=this.deSugarPayload(R,S.right().expr(),t,r,b),G={nodeName:a.NODE_NAME,expr:G}):[M,[G]]=this.deSugarPayload(R,[[S.right()]],t,r,b),M.length?{nodeName:n.NODE_NAME,operator:"=",left:{nodeName:o.NODE_NAME,entries:M},right:G}:void 0}return N()},t,this);let E=super.jsonfy(e,t,r);if(_){let[S,N]=this.deSugarPayload(p,m||h?.entries().map(A=>A.entries())||g,t,r,e);if(E={...E,column_list:{nodeName:o.NODE_NAME,entries:S}},m&&Array.isArray(N)||h){let A=N.map(v=>({nodeName:l.NODE_NAME,entries:v}));E={...E,values_clause:{nodeName:c.NODE_NAME,entries:A}}}else m?E={...E,pg_default_values_clause:N}:E={...E,select_clause:N}}return E}deSugarPayload(e,t,r,s,{conflictHandlingClauseContext:n=!1,deSugar:a,...o}={}){let c=r.statementContext.artifacts.get("payloadDimensions"),{LQDeepRef2:l,TableRef1:f,ColumnRef1:y,SelectItemAlias:p,ColumnRef2:m,ColumnsConstructor:h,TypedRowConstructor:g,RowConstructor:_,DefaultLiteral:x,SelectStmt:E,CompleteSelectStmt:S,PGDefaultValuesClause:N,SelectList:A,SelectItem:v,FromClause:O,FromItem:T}=d,b=(P,K=a)=>P.jsonfy({...o,deSugar:K},r,s),R=(P,K)=>P.entries().reduce((J,Y,k)=>{if(Y instanceof l){let $=this.createPayloadDimension(Y,r,s,{conflictHandlingClauseContext:n,...o});return K.set(k,$),$.refMode==="dependency"&&$.lhsOperandJson?J.concat({nodeName:m.NODE_NAME,value:$.lhsOperandJson.value,delim:$.lhsOperandJson.delim,result_schema:$.lhsOperandJson.result_schema}):J}return J.concat(b(Y))},[]),M=(P,K)=>{let J=e.entries().reduce((Y,k,$)=>{let H=K.has($)?K.get($).offload(P):{nodeName:x.NODE_NAME,value:"DEFAULT"};return H?Y.concat(H):Y},[]);return e.length-J.length===K.size?P.jsonfy():[J]},G=(P,K)=>P.map((J,Y)=>J.reduce((k,$,H)=>{let C;return e.get(H)instanceof l&&$ instanceof x?C=K.get(H).offload(N.fromJSON({value:"DEFAULT"},this.options),Y):K.has(H)?C=K.get(H).offload($,Y):C=b($),C?k.concat(C):k},[])),B=(P,K)=>{let J={...b(P,2),result_schema:void 0},Y=J.select_list.entries;if(Y.length!==e.length)throw new Error(`Select list (${Y.length}) does not match columns length (${e.length})`);let k;if(!n&&J.from_clause&&!/^[`"]\$memo~.+[`"]$/.test(P.fromClause().entries()[0].expr()+"")){let C=r.rootContext.rand("memo");k={...J,uuid:C,select_list:{nodeName:A.NODE_NAME,entries:[Qa("$row_number~a")]}},c.add({refMode:"memo",query:k});let W={nodeName:T.NODE_NAME,expr:{nodeName:f.NODE_NAME,value:C}};J={nodeName:S.NODE_NAME,select_list:{nodeName:A.NODE_NAME,entries:[]},from_clause:{nodeName:O.NODE_NAME,entries:[W]}}}let $=(C,W=!1)=>k?(C.alias&&W?C={...C,alias:{...C.alias,value:C.alias.value+r.rand("rand",{asSalt:!0})}}:C.alias||(C.alias={nodeName:p.NODE_NAME,as_kw:!0,value:r.rand("value")}),k.select_list.entries.push(C),{nodeName:v.NODE_NAME,expr:{nodeName:y.NODE_NAME,value:C.alias.value,delim:C.alias.delim}}):C,H=Y.reduce((C,W,D)=>{if(K.has(D)){let U;[g.NODE_NAME,_.NODE_NAME].includes(W.expr.nodeName)?(U=W.expr.entries.map(ne=>$({nodeName:v.NODE_NAME,expr:ne,alias:W.alias},!0)),e.get(D).right()instanceof h||(U=[{nodeName:v.NODE_NAME,expr:{nodeName:g.NODE_NAME,entries:U.map(ne=>ne.expr)}}])):U=[$(W)];let fe=E.fromJSON({...J,select_list:{nodeName:A.NODE_NAME,entries:U}},this.options);if(W=K.get(D).offload(fe),W){let ne=K.get(D).lhsOperandJson;return C.concat({nodeName:v.NODE_NAME,expr:W,alias:{nodeName:p.NODE_NAME,as_kw:!0,value:ne.value,delim:ne.delim}})}return C}if(!W.alias){let U=e.get(D);W={...W,alias:{nodeName:p.NODE_NAME,as_kw:!0,value:U.value(),delim:U._get("delim")}}}return C.concat($(W))},[]);return J={...J,select_list:{nodeName:A.NODE_NAME,entries:H}},J},j=new Map,q=R(e,j),I=t instanceof N?M(t,j):t instanceof E?B(t,j):G(t,j);return j.clear(),[q,I]}createPayloadDimension(e,t,r,{conflictHandlingClauseContext:s=!1,...n}={}){let{lhsOperand:a,rhsOperand:o,rhsTable:c,detail:l}=e.resolve(t,r,2),f=t.statementContext.artifacts.get("payloadDimensions"),{LQDeepRef2:y,LQBackRefAbstraction:p,ReturningClause:m,ColumnRef2:h,ColumnRef1:g,TableRef1:_,SelectList:x,SelectItem:E,SelectItemAlias:S,AssignmentExpr:N,ColumnsConstructor:A,TypedRowConstructor:v,RowConstructor:O,PGDefaultValuesClause:T,ValuesConstructor:b,ValuesTableLiteral:R,DefaultLiteral:M,SelectStmt:G,WhereClause:B,CompleteSelectStmt:j,ScalarSubquery:q,DerivedQuery:I,FromItem:P,FromClause:K,SetClause:J,BinaryExpr:Y,BoolLiteral:k,NumberLiteral:$,UpdateStmt:H,TableAbstraction2:C}=d,W=t.rootContext.hash(this,"main"),D=F=>F.jsonfy(n,t,r),U=D(a),fe=D(o),ne=D(c),ue=a.jsonfy({toKind:1}),Ee=o.jsonfy({toKind:1}),ea={...ne,nodeName:_.NODE_NAME},ve=e.left()instanceof p?"dependent":"dependency",Le=l instanceof y,Je;if(l instanceof A)Je=D(l);else if(l instanceof h||l instanceof y)Je={nodeName:A.NODE_NAME,entries:[D(l)]};else throw new Error(`Invalid columns spec: ${e}`);let Ma=Je.entries.length,lt=(F,z=null)=>{if(Le)return F;let ie=1;if(z?ie=z.length:F instanceof O||F instanceof G||F instanceof G?ie=F.length:F instanceof I&&(ie=F.expr().length),ie>Ma)throw new Error(`[${F}] Payload has more columns than target columns: ${l}.`);if(ie<Ma)throw new Error(`[${F}] Payload has fewer columns than target columns: ${l}.`);return F},Qt=(F,z,ie=null,pe=null)=>{let Q,ee;typeof ie=="number"?ee={nodeName:$.NODE_NAME,value:ie+1}:ie&&(ee=ie),ee?Q={nodeName:Y.NODE_NAME,left:{nodeName:g.NODE_NAME,value:"$row_number~b"},operator:"=",right:ee}:pe&&(Q={nodeName:Y.NODE_NAME,left:{nodeName:g.NODE_NAME,value:pe},operator:"IS",right:{nodeName:k.NODE_NAME,value:"TRUE"}});let re={nodeName:P.NODE_NAME,expr:{nodeName:_.NODE_NAME,value:ee?`${F}~indices`:F}},kt={nodeName:j.NODE_NAME,select_list:{nodeName:x.NODE_NAME,entries:[{nodeName:E.NODE_NAME,expr:{...z,qualifier:void 0}}]},from_clause:{nodeName:K.NODE_NAME,entries:[re]},where_clause:Q&&{nodeName:B.NODE_NAME,expr:Q}};return{nodeName:q.NODE_NAME,expr:kt}};if(this instanceof H||s){let F=s?`${W}_conflict_based_update`:null,z={nodeName:Y.NODE_NAME,left:Ee,operator:"IN",right:Qt(W,U,null,F)},ie={uuid:t.rootContext.rand(ve),nodeName:H.NODE_NAME,table_expr:{nodeName:C.NODE_NAME,table_ref:ea},set_clause:{nodeName:J.NODE_NAME,entries:[]},where_clause:{nodeName:B.NODE_NAME,expr:z}},Q={refMode:ve,query:ie,offload:ee=>{if(ee instanceof R)throw new Error(`Single-row payload structure expected for column structure: ${l}. Recieved ${ee.NODE_NAME}.`);if(ie.set_clause.entries.length)throw new Error(`Unexpected multiple offload() call on ${e}`);let re=D(ee);if(Le&&!(ee instanceof T)&&(ee=v.fromJSON({entries:[re]},this.options),re=D(ee)),ee instanceof G?(re={nodeName:I.NODE_NAME,expr:re,result_schema:re.result_schema},lt(ee,re.result_schema)):ee instanceof I?lt(ee,re.result_schema):ee instanceof O?lt(ee):ee instanceof T||(re={nodeName:v.NODE_NAME,entries:[re]}),ie.set_clause.entries.push({nodeName:N.NODE_NAME,left:Je,operator:"=",right:re}),ve==="dependency")return ue},lhsOperandJson:U,conflictHandlingClauseContext:s};return f.add(Q),Q}let ge=[],ta=(F,z,ie=null)=>{if(z instanceof T)if(ie){let pe=F.column_list.entries.length-1;F.values_clause.entries.push({nodeName:v.NODE_NAME,entries:F.column_list.entries.map((Q,ee)=>ee===pe?ie:{nodeName:M.NODE_NAME,value:"DEFAULT"})})}else delete F.values_clause,F.pg_default_values_clause=D(z);else{lt(z);let pe=D(z);z instanceof O||(pe={nodeName:v.NODE_NAME,entries:[pe]}),ie&&(pe={...pe,entries:pe.entries.concat(ie)}),F.values_clause.entries.push(pe)}};if(ve==="dependent"){let F=()=>({uuid:t.rootContext.rand(ve),nodeName:this.NODE_NAME,table_ref:ne,column_list:A.fromJSON({entries:Je.entries.concat(fe)}).jsonfy()}),z=(Q,ee)=>{let re={nodeName:E.NODE_NAME,expr:ee,alias:o instanceof h?{nodeName:S.NODE_NAME,as_kw:!0,value:o.value(),delim:o._get("delim")}:void 0};return{...Q,select_list:{...Q.select_list,entries:Q.select_list.entries.concat(re)}}},pe={refMode:ve,queries:ge,offload:(Q,ee=null)=>{ge.length||ge.push(F());let re=ge[ge.length-1];Q instanceof G&&(ee={nodeName:g.NODE_NAME,value:"$row_number~a"});let kt=Qt(W,U,ee),Ua;if(Q instanceof I&&(Q=Q.expr(),(re.select_clause||re.values_clause)&&(re=F(),ge.push(re)),Ua=!0),Q instanceof G){let ut=D(Q);!Ua&&!Le&&(ut=Va(ut,Je)),lt(Q,ut.result_schema),re.select_clause=z(ut,kt);return}if(re.select_clause&&(re=F(),ge.push(re)),re.values_clause||(re.values_clause={nodeName:b.NODE_NAME,entries:[]}),Le&&!(Q instanceof T)&&(Q=v.fromJSON({entries:[D(Q)]})),Q instanceof R)for(let ut of Q.entries())ta(re,ut,kt);else ta(re,Q,kt)},lhsOperandJson:U};return f.add(pe),pe}let Pa={nodeName:g.NODE_NAME,value:o.value(),delim:o._get("delim")},ra=()=>({uuid:t.rootContext.rand(ve),nodeName:this.NODE_NAME,table_ref:ne,column_list:Je,returning_clause:{nodeName:m.NODE_NAME,entries:[{nodeName:E.NODE_NAME,expr:Ee}]}}),ja={refMode:ve,queries:ge,offload:F=>{if(F instanceof R)throw new Error(`Single-row payload structure expected for column structure: ${e.right()}. Recieved ${F.NODE_NAME}.`);ge.length||ge.push(ra());let z=ge[ge.length-1],ie=!1;if(F instanceof I&&(F=F.expr(),(z.select_clause||z.values_clause)&&(z=ra(),ge.push(z)),ie=!0),F instanceof G){let Q=D(F),ee;return ie||(Le||(Q=Va(Q,Je)),ee={nodeName:g.NODE_NAME,value:"$row_number~a"}),lt(F,Q.result_schema),z.select_clause=Q,Qt(z.uuid,Pa,ee)}z.select_clause&&(z=ra(),ge.push(z)),z.values_clause||(z.values_clause={nodeName:b.NODE_NAME,entries:[]}),Le&&!(F instanceof T)&&(F=v.fromJSON({entries:[D(F)]})),ta(z,F);let pe;return z.values_clause&&(pe=z.values_clause.entries.length-1),Qt(z.uuid,Pa,pe)},lhsOperandJson:U,rhsOperandJson:Ee};return f.add(ja),ja}finalizePayloadJSON(e,t,r,s){let n=t.statementContext.artifacts.get("payloadDimensions");if(!n.size)return e;let{ColumnRef0:a,ColumnRef1:o,TableRef1:c,FromItem:l,FromClause:f,AggrCallExpr:y,ReturningClause:p,SelectList:m,SelectItem:h,SelectItemAlias:g,NumberLiteral:_,BinaryExpr:x,CTE:E,CTEItem:S,CTEItemAlias:N,CompleteSelectStmt:A,UpdateStmt:v}=d,O=t.rootContext.hash(this,"main"),T={nodeName:E.NODE_NAME,declarations:[],body:null},b=t,R=(I,P,K=[],J=b)=>{let Y=S.fromJSON({nodeName:S.NODE_NAME,alias:{nodeName:N.NODE_NAME,value:I},expr:P},this.options).jsonfy(s,J,r);if(Y.expr?.nodeName===E.NODE_NAME){if(T.declarations.push(...Y.expr.declarations),this instanceof v&&Y.expr.body.nodeName===A.NODE_NAME)return;Y={nodeName:S.NODE_NAME,alias:{nodeName:N.NODE_NAME,value:I},expr:Y.expr.body}}T.declarations.push(Y),K.length&&T.declarations.push(S.fromJSON({nodeName:S.NODE_NAME,alias:{nodeName:N.NODE_NAME,value:`${I}~indices`},expr:Ni(K,I)},this.options).jsonfy(s,J,r))},M=[],G=[],B=[],j=!1,q=e.returning_clause?.entries||[];for(let{refMode:I,query:P,queries:K,lhsOperandJson:J,rhsOperandJson:Y,conflictHandlingClauseContext:k}of n)for(let{uuid:$,...H}of P&&[P]||K)if(I==="dependent"||this instanceof v&&I==="dependency"||k){if(!B.find(C=>V(C.expr.value,J.value))){let C={nodeName:h.NODE_NAME,expr:J};q.find(W=>V((W.alias||W.expr).value,J.value))&&(C.alias={nodeName:g.NODE_NAME,as_kw:!0,value:t.rand("key")}),B.push(C)}k&&(j=!0),M.push({uuid:$,...H})}else if(I==="dependency"){let C=[{nodeName:h.NODE_NAME,expr:Y}];e.select_clause?G.push({uuid:$,wherePredicate:C,...H}):H.pg_default_values_clause||H.select_clause?R($,H):R($,H,C)}else R($,H);for(let{uuid:I,wherePredicate:P,...K}of G)R(I,K,P);if(M.length){let I=[],P=[];for(let k of q)k.alias||(k={...k,alias:{nodeName:g.NODE_NAME,as_kw:!0,value:t.rand("key")}}),I.push(k),P.push({...k,expr:{nodeName:o.NODE_NAME,value:k.alias.value,delim:k.alias.delim}});if(j){let k=`${O}_conflict_based_update`;I.push({nodeName:h.NODE_NAME,expr:{nodeName:x.NODE_NAME,left:{nodeName:o.NODE_NAME,value:"XMAX"},operator:"!=",right:{nodeName:_.NODE_NAME,value:"0"}},alias:{nodeName:g.NODE_NAME,as_kw:!0,value:k}})}let K={nodeName:p.NODE_NAME,entries:[...I,...B]};this instanceof v||j?R(O,{...e,returning_clause:K}):e.pg_default_values_clause?R(O,{...e,returning_clause:K}):R(O,{...e,returning_clause:K},B);for(let{uuid:k,...$}of M)R(k,$);let J=P;J.length||(J=[{nodeName:h.NODE_NAME,expr:{nodeName:y.NODE_NAME,name:"COUNT",arguments:[{nodeName:a.NODE_NAME,value:"*"}]},alias:{nodeName:g.NODE_NAME,as_kw:!0,value:"COUNT"}}]);let Y={nodeName:l.NODE_NAME,expr:{nodeName:c.NODE_NAME,value:O}};T.body=A.fromJSON({nodeName:A.NODE_NAME,select_list:{nodeName:m.NODE_NAME,entries:J},from_clause:{nodeName:f.NODE_NAME,entries:[Y]}},this.options).jsonfy(s,b,r)}else{let P=[this.constructor].concat(this.constructor.morphsTo()).reduce((K,J)=>K||J.fromJSON(e,this.options),void 0);T.body=P.jsonfy(s,b,r)}return{...T,origin_schemas:T.body.origin_schemas,result_schema:T.body.result_schema}}},Va=(u,e)=>{let t=u.select_list.entries.reduce((r,s,n)=>{if(!s.alias){let a=e.entries[n];s={...s,alias:{nodeName:d.SelectItemAlias.NODE_NAME,as_kw:!0,value:a.value,delim:a.delim}}}return r.concat(s)},[]);return{...u,select_list:{...u.select_list,entries:t}}},Ni=(u,e)=>{let t=Qa("$row_number~b");u=u.map(s=>s.alias?{...s,expr:{...s.expr,value:s.alias.value,delim:s.alias.delim,qualifier:void 0},alias:{...s.alias,value:s.expr.value,delim:s.expr.delim}}:s.expr.nodeName===d.ColumnRef0.NODE_NAME?i:{...s,expr:{...s.expr,qualifier:void 0},alias:{nodeName:d.SelectItemAlias.NODE_NAME,as_kw:!0,value:s.expr.value,delim:s.expr.delim}}).concat(t);let r={nodeName:d.FromItem.NODE_NAME,expr:{nodeName:d.TableRef1.NODE_NAME,value:e}};return{nodeName:d.CompleteSelectStmt.NODE_NAME,select_list:{nodeName:d.SelectList.NODE_NAME,entries:u},from_clause:{nodeName:d.FromClause.NODE_NAME,entries:[r]}}},Qa=u=>({nodeName:d.SelectItem.NODE_NAME,expr:{nodeName:d.AggrCallExpr.NODE_NAME,name:"ROW_NUMBER",arguments:[],over_clause:{nodeName:d.WindowSpec.NODE_NAME}},alias:{nodeName:d.SelectItemAlias.NODE_NAME,as_kw:!0,value:u||3}});var Qe=class extends Vs(Ve){static get _clause(){return"INSERT"}static get syntaxRules(){let e={optional:!0,syntax:[{type:"keyword",value:"AS",booleanfy:!0},{type:"Identifier",as:"pg_table_alias",assert:!0}]},t={optional:!0,dialect:"mysql",if:["!select_clause","!my_table_clause"],syntax:[{type:"keyword",value:"AS"},{type:"FromItemAlias",as:"my_row_alias",assert:!0}]};return[{type:"keyword",value:this._clause},{type:"keyword",value:"INTO"},{assert:!0,syntax:[{dialect:"postgres",syntax:[{type:"TableRef2",as:"table_ref"},{...e},{type:"ColumnsConstructor",as:"column_list",optional:!0,autoIndent:!0},{syntaxes:[{type:"PGDefaultValuesClause",as:"pg_default_values_clause"},{type:"ValuesConstructor",as:"values_clause"},{type:"SelectStmt",as:"select_clause"}],autoSpacing:`
`},...this._clause==="INSERT"?[{type:"PGOnConflictClause",as:"conflict_handling_clause",optional:!0,autoSpacing:`
`}]:[],{type:"ReturningClause",as:"returning_clause",optional:!0,autoSpacing:`
`}]},{dialect:"mysql",syntax:[{type:"TableRef2",as:"table_ref"},{type:"MYPartitionClause",as:"my_partition_clause",optional:!0,autoIndent:!0},{syntaxes:[[{type:"ColumnsConstructor",as:"column_list",optional:!0,autoIndent:!0},{syntaxes:[{type:"ValuesConstructor",as:"values_clause"},{type:"SelectStmt",as:"select_clause"},{type:"TableStmt",as:"my_table_clause"}],autoSpacing:`
`}],{type:"SetClause",as:"my_set_clause",autoSpacing:`
`}]},{...t},...this._clause==="INSERT"?[{type:"MYOnDuplicateKeyUpdateClause",as:"conflict_handling_clause",optional:!0,autoSpacing:`
`}]:[],{type:"ReturningClause",as:"returning_clause",optional:!0,autoSpacing:`
`}]}]}]}tableRef(){return this._get("table_ref")}columnList(){return this._get("column_list")}valuesClause(){return this._get("values_clause")}selectClause(){return this._get("select_clause")}conflictHandlingClause(){return this._get("conflict_handling_clause")}returningClause(){return this._get("returning_clause")}pgTableAlias(){return this._get("pg_table_alias")}pgDefaultValuesClause(){return this._get("pg_default_values_clause")}myRowAlias(){return this._get("my_row_alias")}myPartitionClause(){return this._get("my_partition_clause")}mySetClause(){return this._get("my_set_clause")}myTableClause(){return this._get("my_table_clause")}jsonfy(e={},t=null,r=null){if(!e.deSugar)return super.jsonfy(e,t,r);t=new ae((a,o)=>{if(a instanceof d.TableRef2){let c=o(),l=c.result_schema;return c.pg_table_alias&&(l=l.clone({renameTo:c.pg_table_alias})),t.statementContext.artifacts.get("tableSchemas").add({type:"dml",resultSchema:l}),c}return o()},t,this);let s=super.jsonfy(e,t,r),n=e.toDialect||this.options.dialect;if(n==="mysql"?s={uuid:s.uuid,nodeName:s.nodeName,table_ref:s.table_ref,my_partition_clause:s.my_partition_clause,column_list:s.column_list,values_clause:s.values_clause,select_clause:s.select_clause,my_table_clause:s.my_table_clause,my_set_clause:s.my_set_clause,my_row_alias:s.my_row_alias,conflict_handling_clause:s.conflict_handling_clause,returning_clause:s.returning_clause,result_schema:s.result_schema}:s={uuid:s.uuid,nodeName:s.nodeName,table_ref:s.table_ref,pg_table_alias:s.pg_table_alias,column_list:s.column_list,pg_default_values_clause:s.pg_default_values_clause,values_clause:s.values_clause,select_clause:s.select_clause,conflict_handling_clause:s.conflict_handling_clause,returning_clause:s.returning_clause,result_schema:s.result_schema},s.conflict_handling_clause?.entries&&!s.conflict_handling_clause.entries.length){let o=s.table_ref.result_schema.pkConstraint(!0).columns()[0];s={...s,conflict_handling_clause:{...s.conflict_handling_clause,entries:[{nodeName:d.AssignmentExpr.NODE_NAME,left:o.jsonfy(),operator:"=",right:o.jsonfy({toKind:1})}]}}}return n==="postgres"&&!s.pg_table_alias&&(e.deSugar===!0||Number(e.deSugar?.tableAliases)===1)&&(s={...s,pg_table_alias:{nodeName:d.Identifier.NODE_NAME,value:s.table_ref.value,delim:s.table_ref.delim}}),s=this.finalizeOutputJSON(s,t,r,e),s={...s,origin_schemas:this.getOriginSchemas(t)},s=this.finalizePayloadJSON(s,t,r,e),s}};var Qs=class extends L{static get syntaxRules(){return[{type:"keyword",value:"SET"},{type:"MYVarAssignmentExpr",as:"entries",arity:{min:1},itemSeparator:{type:"punctuation",value:","},assert:!0,autoIndent:2}]}};var zs=class extends Vs(Nt(Ve)){static get syntaxRules(){return[{type:"keyword",value:"UPDATE"},{assert:!0,syntaxes:[{dialect:"postgres",syntax:[{type:"TableAbstraction2",as:"table_expr"},{type:"SetClause",as:"set_clause",autoSpacing:`
`},{type:"FromClause",as:"pg_from_clause",optional:!0,dialect:"postgres",autoSpacing:`
`},{type:"JoinClause",as:"join_clauses",arity:1/0,optional:!0,autoSpacing:`
`},{type:["PGWhereCurrentClause","WhereClause"],as:"where_clause",optional:!0,autoSpacing:`
`},{type:"ReturningClause",as:"returning_clause",optional:!0,autoSpacing:`
`}]},{dialect:"mysql",syntax:[{type:"TableAbstraction2",as:"table_expr"},{type:"SetClause",as:"set_clause",autoSpacing:`
`},{type:"WhereClause",as:"where_clause",optional:!0,autoSpacing:`
`},{type:"OrderByClause",as:"my_order_by_clause",optional:!0,autoSpacing:`
`},{type:"LimitClause",as:"my_limit_clause",optional:!0,autoSpacing:`
`},{type:"ReturningClause",as:"returning_clause",optional:!0,autoSpacing:`
`}]},{dialect:"mysql",syntax:[{type:"TableAbstraction1",as:"my_update_list",arity:{min:1},itemSeparator:{type:"punctuation",value:","}},{type:"JoinClause",as:"join_clauses",arity:1/0,optional:!0,autoSpacing:`
`},{type:"SetClause",as:"set_clause",autoSpacing:`
`},{type:"WhereClause",as:"where_clause",optional:!0,autoSpacing:`
`},{type:"ReturningClause",as:"returning_clause",optional:!0,autoSpacing:`
`}]}]}]}tableExpr(){return this._get("table_expr")}joinClauses(){return this._get("join_clauses")}setClause(){return this._get("set_clause")}whereClause(){return this._get("where_clause")}returningClause(){return this._get("returning_clause")}pgFromClause(){return this._get("pg_from_clause")}myUpdateList(){return this._get("my_update_list")}myOrderByClause(){return this._get("my_order_by_clause")}myLimitClause(){return this._get("my_limit_clause")}jsonfy(e={},t=null,r=null){if(!e.deSugar)return super.jsonfy(e,t,r);let s={set_clause:null};t=new ae((a,o)=>{if(a instanceof d.SetClause){s.set_clause=o;return}return o()},t,this);let n=super.jsonfy(e,t,r);if(n={...n,set_clause:s.set_clause()},(e.toDialect||this.options.dialect)==="mysql"?n={uuid:n.uuid,nodeName:n.nodeName,table_expr:n.table_expr,my_update_list:n.my_update_list,join_clauses:n.join_clauses,set_clause:n.set_clause,where_clause:n.where_clause,my_order_by_clause:n.my_order_by_clause,my_limit_clause:n.my_limit_clause,returning_clause:n.returning_clause,result_schema:n.result_schema}:n={uuid:n.uuid,nodeName:n.nodeName,table_expr:n.table_expr,set_clause:n.set_clause,pg_from_clause:n.pg_from_clause,join_clauses:n.join_clauses,where_clause:n.where_clause,returning_clause:n.returning_clause,result_schema:n.result_schema},!n.set_clause?.entries.length){let o=n.table_expr.result_schema.pkConstraint(!0).columns()[0];n={...n,set_clause:{...n.set_clause,entries:[{nodeName:d.AssignmentExpr.NODE_NAME,left:o.jsonfy(),operator:"=",right:o.jsonfy({toKind:1})}]}}}return n=this.finalizeOutputJSON(n,t,r,e),n=this.finalizeSelectorJSON(n,t,r,e),n={...n,origin_schemas:this.getOriginSchemas(t)},n=this.finalizePayloadJSON(n,t,r,e),n}};var Xs=class extends yt(Qe){static get _clause(){return"UPSERT"}static morphsTo(){return[Qe].concat(super.morphsTo())}finalizePayloadJSON(e,t,r,s){if(e.conflict_handling_clause)throw new Error("An explicit conflict handling clause is forbidden on the UPSERT statement.");let n=[...t.statementContext.artifacts.get("tableSchemas")].map(l=>l.resultSchema)[0],a=s.toDialect||this.options.dialect,o;e.my_set_clause?o=e.my_set_clause.entries.map(l=>({value:l.left.value,delim:l.left.delim})):e.column_list?o=e.column_list.entries.map(l=>({value:l.value,delim:l.delim})):o=n.columns().map(l=>l.name().jsonfy({nodeNames:!1}));let c={nodeName:a==="mysql"?d.MYOnDuplicateKeyUpdateClause.NODE_NAME:d.PGOnConflictClause.NODE_NAME,entries:o.map(l=>({nodeName:d.AssignmentExpr.NODE_NAME,left:{nodeName:a==="mysql"?d.ColumnRef1.NODE_NAME:d.ColumnRef2.NODE_NAME,...l},operator:"=",right:{...l,nodeName:d.ColumnRef1.NODE_NAME,qualifier:{value:a==="mysql"?"VALUES":"EXCLUDED"}}}))};if(a==="postgres"){let l=[].concat(n.pkConstraint(!0)||[]).concat(n.ukConstraints(!0)).map(y=>y.columns().map(p=>p.jsonfy()));if(!l.length)throw new Error(`Table ${this.tableRef()} has no unique keys defined to process an UPSERT operation. You may want to perform a direct INSERT operation.`);let f=l.find(y=>y.find(p=>o.find(m=>V(p.value,m.value,p.delim||m.delim))))||l[0];c.conflict_target={nodeName:d.PGConflictTarget.NODE_NAME,index_list:f.map(y=>({nodeName:d.PGConflictTargetIndexSpec.NODE_NAME,column_name:y}))}}return super.finalizePayloadJSON({...e,nodeName:Qe.NODE_NAME,conflict_handling_clause:c},t,r,s)}};var ca={};be(ca,{BasicSelectStmt:()=>At,CompleteSelectStmt:()=>kn,CompositeSelectStmt:()=>Dn,DerivedQuery:()=>pt,DistinctClause:()=>Zs,ForClause:()=>en,FromClause:()=>tn,FromItem:()=>wt,FromItemAlias:()=>Nn,GroupByClause:()=>rn,GroupingElement:()=>sn,HavingClause:()=>nn,JoinClause:()=>an,LimitClause:()=>on,OffsetClause:()=>ln,OnClause:()=>un,OrderByClause:()=>cn,OrderElement:()=>fn,PGFetchClause:()=>mn,PGOrderOperator:()=>yn,PartitionByClause:()=>pn,SRFExpr1:()=>Tn,SRFExpr2:()=>On,SRFExpr3:()=>vn,SRFExpr4:()=>bn,SRFExprDDL1:()=>Rn,SRFExprDDL2:()=>Cn,SelectItem:()=>wn,SelectItemAlias:()=>An,SelectList:()=>Et,SelectStmt:()=>ze,TableStmt:()=>Ln,UsingClause:()=>dn,ValuesTableLiteral:()=>In,WhereClause:()=>hn,WindowClause:()=>_n,WindowDeclaration:()=>gn,WindowFrameBound:()=>En,WindowFrameSpec:()=>xn,WindowSpec:()=>Sn});var Zs=class extends w{static get syntaxRules(){return{syntaxes:[{dialect:"postgres",syntax:[{type:"keyword",value:"DISTINCT"},{type:"keyword",value:"ON"},{type:"paren_block",syntax:{type:"Expr",as:"pg_distinct_on_list",arity:{min:1},itemSeparator:{type:"punctuation",value:","},assert:!0}}]},{type:"keyword",as:"all_or_distinct",value:["ALL","DISTINCT"]}]}}allOrDistinct(){return this._get("all_or_distinct")}pgDistinctOnList(){return this._get("pg_distinct_on_list")}};var en=class extends w{static get syntaxRules(){return[{type:"keyword",value:"FOR"},{optional:!0,dialect:"postgres",syntaxes:[[{type:"keyword",as:"pg_no_key_kw",value:"NO",booleanfy:!0},{type:"keyword",value:"KEY",if:"pg_no_key_kw",assert:!0}],{type:"keyword",as:"pg_key_kw",value:"KEY",booleanfy:!0}]},{type:"keyword",as:"intent_kw",value:["UPDATE","SHARE"],assert:!0},{optional:!0,syntax:[{type:"keyword",value:"OF"},{type:"TableRef2",as:"table_names",arity:{min:1},itemSeparator:{type:"punctuation",value:","},assert:!0}]},{optional:!0,syntaxes:[[{type:"keyword",as:"skip_locked_kw",value:"SKIP",booleanfy:!0},{type:"keyword",value:"LOCKED",assert:!0}],{type:"keyword",as:"nowait_kw",value:"NOWAIT",booleanfy:!0},{dialect:"mysql",syntax:[{type:"keyword",as:"my_lock_in_share_mode",value:"LOCK",booleanfy:!0},{type:"operator",value:"IN",assert:!0},{type:"keyword",value:"SHARE",assert:!0},{type:"keyword",value:"MODE",assert:!0}]}]}]}intentKW(){return this._get("intent_kw")}tableNames(){return this._get("table_names")}skipLockedKW(){return this._get("skip_locked_kw")}nowaitKW(){return this._get("nowait_kw")}pgKeyKW(){return this._get("pg_key_kw")}pgNoKeyKW(){return this._get("pg_no_key_kw")}myLockInShareMode(){return this._get("my_lock_in_share_mode")}};var tn=class extends L{static get syntaxRules(){return[{type:"keyword",value:"FROM"},{type:"FromItem",as:"entries",arity:{min:1},itemSeparator:{type:"punctuation",value:","},assert:!0}]}};var rn=class extends L{static get syntaxRules(){return[{type:"keyword",value:"GROUP"},{type:"keyword",value:"BY",assert:!0},{type:"keyword",as:"all_or_distinct",value:["ALL","DISTINCT"],optional:!0},{type:"GroupingElement",as:"entries",arity:{min:1},itemSeparator:{type:"punctuation",value:","},assert:!0,autoIndent:2},{optional:!0,autoIndent:!0,syntax:[{type:"keyword",as:"with_rollup",value:"WITH",booleanfy:!0},{type:"keyword",value:"ROLLUP",assert:!0}]}]}allOrDistinct(){return this._get("all_or_distinct")}withRollup(){return this._get("with_rollup")}};var sn=class extends w{static get syntaxRules(){return{syntaxes:[[{type:"keyword",value:"GROUPING SETS"},{type:"paren_block",syntax:{type:"GroupingElement",as:"grouping_sets",arity:{min:1},itemSeparator:{type:"punctuation",value:","},assert:!0,autoIndent:2},autoIndent:!0}],[{type:"keyword",value:"ROLLUP"},{type:"RowConstructor",as:"rollup_set",assert:!0}],[{type:"keyword",value:"CUBE"},{type:"RowConstructor",as:"cube_set",assert:!0}],{type:"Expr",as:"expr"}]}}groupingSets(){return this._get("grouping_sets")}rollupSet(){return this._get("rollup_set")}cubeSet(){return this._get("cube_set")}expr(){return this._get("expr")}};var nn=class extends w{static get syntaxRules(){return[{type:"keyword",value:"HAVING"},{type:"Expr",as:"expr",assert:!0}]}static get syntaxPriority(){return-1}expr(){return this._get("expr")}};var wt=class extends X(w){static get syntaxRules(){let e={type:"punctuation",value:","};return{syntaxes:[[{type:"keyword",as:"lateral_kw",value:"LATERAL",booleanfy:!0,optional:!0},{type:"SRFExpr1",as:"expr"}],[{type:"keyword",as:"lateral_kw",value:"LATERAL",booleanfy:!0,optional:!0},{type:["SRFExpr2","SRFExpr4"],as:"expr"},{type:"FromItemAlias",as:"alias",optional:!0}],[{type:"keyword",as:"lateral_kw",value:"LATERAL",booleanfy:!0,optional:!0},{type:["DerivedQuery","ValuesTableLiteral"],as:"expr",dialect:"postgres"},{type:"DerivedQuery",as:"expr",dialect:"mysql"},{type:"FromItemAlias",as:"alias",optional:!0}],[{type:"keyword",as:"pg_only_kw",value:"ONLY",optional:!0,dialect:"postgres"},{type:["TableRef1","TableRef2"],as:"expr"},{type:"operator",as:"pg_star_ref",value:"*",booleanfy:!0,optional:!0,dialect:"postgres"},{type:"FromItemAlias",as:"alias",optional:!0},{...{optional:!0,dialect:"postgres",syntax:[{type:"keyword",value:"TABLESAMPLE"},{syntaxes:[[{type:"keyword",as:"pg_sampling_method",value:["BERNOULLI","SYSTEM"]},{type:"paren_block",syntax:{type:"Expr",as:"pg_sampling_arguments",arity:1,itemSeparator:e,assert:!0}}],[{type:"identifier",as:"pg_sampling_method"},{type:"paren_block",syntax:{type:"Expr",as:"pg_sampling_arguments",arity:1/0,itemSeparator:e,assert:!0}}]],assert:!0},{optional:!0,syntax:[{type:"keyword",value:"REPEATABLE"},{type:"paren_block",syntax:{type:"Expr",as:"pg_repeatable_seed"},assert:!0}]}]}}]]}}lateralKW(){return this._get("lateral_kw")}expr(){return this._get("expr")}alias(){return this._get("alias")}pgOnlyKW(){return this._get("pg_only_kw")}pgStarRef(){return this._get("pg_star_ref")}pgSamplingMethod(){return this._get("pg_sampling_method")}pgSamplingArguments(){return this._get("pg_sampling_arguments")}pgRepeatableSeed(){return this._get("pg_repeatable_seed")}deriveAlias(){let e;if(this.alias()?.value()?e={as_kw:!0,value:this.alias().value(),delim:this.alias()._get("delim")}:this.expr()instanceof d.TableRef1||this.expr()instanceof d.TableRef2?e={as_kw:!0,value:this.expr().value(),delim:this.expr()._get("delim")}:this.expr()instanceof d.SRFExpr1&&this.expr().qualif()instanceof d.SRFExprDDL2&&(e={as_kw:!0,value:this.expr().qualif().alias().value(),delim:this.expr().qualif().alias()._get("delim")}),e)return d.FromItemAlias.fromJSON(e)}jsonfy(e={},t=null,r=null){let s=super.jsonfy(e,t,r);if(e.deSugar){let n=s.alias||this.deriveAlias()?.jsonfy(),a=n?.value&&{nodeName:d.Identifier.NODE_NAME,value:n.value,delim:n.delim},o=s.expr.result_schema;if(o instanceof d.TableSchema?o=o.clone({renameTo:a}):a&&(o=d.TableSchema.fromJSON({name:a,entries:o?.entries().map(l=>l.jsonfy())||[]},{assert:!0})),s.alias?.columns?.length){if(s.alias.columns.length!==o.length)throw new SyntaxError(`[${this}] Number of column aliases must match number of result columns.`);o=o.clone({},new ae((l,f,y)=>typeof y=="number"&&l.parentNode===o?l instanceof d.ColumnSchema?l.jsonfy({renameTo:s.alias.columns[y]}):{...l.jsonfy(),nodeName:d.ColumnSchema.NODE_NAME,name:s.alias.columns[y]}:f()))}t.statementContext.artifacts.get("tableSchemas").add({type:this.joinType?.()||"dql",lateral:this.lateralKW(),resultSchema:o});let c=!(this.expr()instanceof d.SRFExpr1)&&(e.deSugar===!0||Number(e.deSugar?.tableAliases)===1||e.deSugar?.tableAliases===-1&&(this.parentNode?.length||0)>1)&&n||s.alias;s={...s,alias:c,result_schema:o}}return s}};var an=class extends wt{static get syntaxRules(){return{syntaxes:[[{type:"keyword",as:"join_type",value:"CROSS"},{type:"keyword",value:"JOIN",assert:!0},...[].concat(super.syntaxRules)],[{type:"keyword",as:"natural_kw",value:"NATURAL",booleanfy:!0,optional:!0},{optional:!0,syntaxes:[{type:"keyword",as:"join_type",value:"INNER"},[{type:"keyword",as:"join_type",value:["LEFT","RIGHT","FULL"],dialect:"postgres"},{type:"keyword",as:"join_type",value:["LEFT","RIGHT"],dialect:"mysql"},{type:"keyword",as:"outer_kw",value:"OUTER",booleanfy:!0,optional:!0}]]},{type:"keyword",value:"JOIN"},...[].concat(super.syntaxRules),{type:["OnClause","UsingClause"],as:"condition_clause",if:"!natural_kw",assert:!0,autoIndent:!0}]]}}naturalKW(){return this._get("natural_kw")}joinType(){return this._get("join_type")}outerKW(){return this._get("outer_kw")}conditionClause(){return this._get("condition_clause")}jsonfy(e={},t=null,r=null){let s;e.deSugar&&(t=new ae((a,o,c)=>{if(c==="condition_clause")s=o;else return o()},t,this.statementNode));let n=super.jsonfy(e,t,r);return s&&(n={...n,condition_clause:s()}),n}};var on=class extends w{static get syntaxRules(){return[{type:"keyword",value:"LIMIT"},{dialect:"mysql",syntax:[{optional:!0,syntax:[{type:"Expr",as:"my_offset"},{type:"punctuation",value:",",autoSpacing:!1}]},{type:"Expr",as:"expr",assert:!0}]},{dialect:"postgres",syntaxes:[{type:"keyword",as:"pg_all_kw",value:"ALL"},{type:"Expr",as:"expr",assert:!0}]}]}expr(){return this._get("expr")}pgAllKW(){return this._get("pg_all_kw")}myOffset(){return this._get("my_offset")}};var ln=class extends w{static get syntaxRules(){return[{type:"keyword",value:"OFFSET"},{type:"Expr",as:"expr",assert:!0},{type:"keyword",as:"pg_row_kw",value:["ROW","ROWS"],optional:!0,dialect:"postgres"}]}expr(){return this._get("expr")}pgRowKW(){return this._get("pg_row_kw")}};var un=class extends w{static get syntaxRules(){return[{type:"keyword",value:"ON"},{type:"Expr",as:"expr",assert:!0}]}expr(){return this._get("expr")}};var cn=class extends L{static get syntaxRules(){return[{type:"keyword",value:"ORDER"},{type:"keyword",value:"BY",assert:!0},{type:"OrderElement",as:"entries",arity:{min:1},itemSeparator:{type:"punctuation",value:","},assert:!0,autoIndent:2},{optional:!0,autoIndent:!0,syntax:[{type:"keyword",as:"with_rollup",value:"WITH",booleanfy:!0},{type:"keyword",value:"ROLLUP",assert:!0}]}]}withRollup(){return this._get("with_rollup")}};var fn=class extends w{static get syntaxRules(){return[{type:"Expr",as:"expr"},{optional:!0,syntaxes:[{type:"keyword",value:["ASC","DESC"],as:"dir"},{type:"PGOrderOperator",as:"dir"}]},{optional:!0,syntax:[{type:"keyword",value:"NULLS"},{type:"keyword",as:"nulls_spec",value:["FIRST","LAST"],assert:!0}]}]}expr(){return this._get("expr")}dir(){return this._get("dir")}nullsSpec(){return this._get("nulls_spec")}};var pn=class extends L{static get syntaxRules(){return[{type:"keyword",value:"PARTITION"},{type:"keyword",value:"BY",assert:!0},{type:"Expr",as:"entries",arity:{min:1},itemSeparator:{type:"punctuation",value:","},assert:!0,autoIndent:2}]}};var mn=class extends w{static get syntaxRules(){return{dialect:"postgres",syntax:[{type:"keyword",value:"FETCH"},{type:"keyword",as:"rel_kw",value:["FIRST","NEXT"]},{type:"Expr",as:"expr",optional:!0},{type:"keyword",as:"row_kw",value:["ROW","ROWS"],assert:!0},{syntaxes:[{type:"keyword",value:"ONLY"},[{type:"keyword",as:"with_ties",value:"WITH"},{type:"keyword",value:"TIES",assert:!0}]]}]}}relKW(){return this._get("rel_kw")}expr(){return this._get("expr")}rowKW(){return this._get("row_kw")}withTies(){return this._get("with_ties")}};var yn=class extends w{static get syntaxRules(){return{dialect:"postgres",syntax:[{type:"keyword",value:"USING"},{type:"operator",as:".",assert:!0}]}}value(){return this._get("value")}};var dn=class extends w{static get syntaxRules(){return[{type:"keyword",value:"USING"},{syntaxes:[{type:"Identifier",as:"column"},{type:"paren_block",syntax:{type:"Identifier",as:"columns",arity:{min:1},itemSeparator:{type:"punctuation",value:","},assert:!0}}],assert:!0}]}column(){return this._get("column")}columns(){return this._get("columns")}};var hn=class extends w{static get syntaxRules(){return[{type:"keyword",value:"WHERE"},{type:"Expr",as:"expr",assert:!0}]}expr(){return this._get("expr")}};var _n=class extends L{static get syntaxRules(){return[{type:"keyword",value:"WINDOW"},{type:"WindowDeclaration",as:"entries",arity:{min:1},itemSeparator:{type:"punctuation",value:","},assert:!0,autoIndent:2}]}};var gn=class extends w{static get syntaxRules(){return[{type:"Identifier",as:"name"},{type:"keyword",value:"AS"},{type:"WindowSpec",as:"spec",assert:!0}]}name(){return this._get("name")}spec(){return this._get("spec")}};var xn=class extends w{static get syntaxRules(){let e={type:"operator",value:"AND"};return[{type:"keyword",as:"specifier",value:["ROWS","RANGE","GROUPS"]},{syntaxes:[[{type:"operator",as:"with_between_clause",value:"BETWEEN",booleanfy:!0},{type:"WindowFrameBound",as:"bounds",arity:2,itemSeparator:e,assert:!0}],{type:"WindowFrameBound",as:"bounds",arity:1,itemSeparator:e,assert:!0}]},{optional:!0,syntax:[{type:"keyword",value:"EXCLUDE"},{type:"keyword",as:"exclusion",value:["CURRENT ROW","GROUP","TIES","NO OTHERS"],assert:!0}]}]}specifier(){return this._get("specifier")}withBetweenClause(){return this._get("with_between_clause")}bounds(){return this._get("bounds")}exclusion(){return this._get("exclusion")}};var En=class extends w{static get syntaxRules(){return{syntaxes:[{type:"keyword",as:"specifier",value:"CURRENT ROW"},[{type:"keyword",as:"specifier",value:"UNBOUNDED"},{type:"keyword",as:"dir",value:["PRECEDING","FOLLOWING"]}],[{type:"number_literal",as:"specifier"},{type:"keyword",as:"dir",value:["PRECEDING","FOLLOWING"]}],[{type:"Expr",as:"specifier"},{type:"keyword",as:"dir",value:["PRECEDING","FOLLOWING"]}]]}}specifier(){return this._get("specifier")}dir(){return this._get("dir")}};var Sn=class extends w{static get syntaxRules(){return{type:"paren_block",syntax:[{type:"WindowRef",as:"super_window",optional:!0},{type:"PartitionByClause",as:"partition_by_clause",optional:!0,autoIndent:!0},{type:"OrderByClause",as:"order_by_clause",optional:!0,autoIndent:!0},{type:"WindowFrameSpec",as:"frame_spec",optional:!0,autoIndent:!0}],autoIndent:!0,autoIndentAdjust:-1}}superWindow(){return this._get("super_window")}partitionByClause(){return this._get("partition_by_clause")}orderByClause(){return this._get("order_by_clause")}frameSpec(){return this._get("frame_spec")}};var Nn=class extends le{static get syntaxRules(){let e={type:"punctuation",value:","};return[{syntaxes:[{...[].concat(super.syntaxRules)[0]},[{type:"keyword",as:"as_kw",value:"AS",booleanfy:!0},{...[].concat(super.syntaxRules)[0],assert:!0}]]},{type:"paren_block",syntax:{type:"Identifier",as:"columns",arity:{min:1},itemSeparator:e,assert:!0},if:"value",optional:!0,optionalParens:!0}]}asKW(){return this._get("as_kw")}columns(){return this._get("columns")}jsonfy(e={},t=null,r=null){let s=super.jsonfy(e,t,r);return(e.deSugar===!0||e.deSugar?.normalizeCasing)&&!s.delim&&(s={...s,value:s.value.toLowerCase()}),s}};var wn=class u extends X(w){static get syntaxRules(){return[{type:["Expr","ColumnRef0","MYVarAssignmentExpr"],as:"expr"},{type:"SelectItemAlias",as:"alias",optional:!0}]}expr(){return this._get("expr")}alias(){return this._get("alias")}deriveAlias(){let e=this.alias()?.jsonfy(),t=this.expr();if(!(t instanceof d.ColumnRef0)){if(t instanceof d.RowConstructor&&(t=t.exprUnwrapped()),(t instanceof d.CastExpr||t instanceof d.PGCastExpr2)&&(t=t.expr()),!e)if(t instanceof d.ColumnRef1)e={as_kw:!0,value:t.value(),delim:t._get("delim")};else if(t instanceof d.LQDeepRef1&&t.endpoint()instanceof d.ColumnRef2){let r=t.endpoint();e={as_kw:!0,value:r.value(),delim:r._get("delim")}}else{let r=this.options.dialect==="postgres";t instanceof d.CallExpr&&r&&(e={as_kw:!0,value:t.name().toLowerCase()})}return d.SelectItemAlias.fromJSON(e)}}jsonfy(e={},t=null,r=null){if(e.deSugar){let s=this.deriveAlias(),n,a=s&&(t?t.transform(s,(m=e)=>s.jsonfy(m),"alias",e):s.jsonfy(e));a?.is_aggr&&({is_aggr:n,...a}=a);let o=this.expr(),c;n&&!(o instanceof d.LQDeepRef1)?c=(m=e,h=t)=>({nodeName:d.AggrCallExpr.NODE_NAME,name:(e.toDialect||this.options.dialect)==="mysql"?"JSON_ARRAYAGG":"JSON_AGG",arguments:[o.jsonfy(m,h,r)]}):c=(m=e,h=t)=>o.jsonfy(m,h,r);let l=t?t.transform(o,c,"expr",{...e,asAggr:n}):c(),f=a&&{nodeName:d.Identifier.NODE_NAME,value:a.value,delim:a.delim}||{nodeName:d.Identifier.NODE_NAME,value:this.options.dialect==="postgres"?"?column?":o.stringify()},y=l.result_schema;if(y instanceof d.ColumnSchema){let m=y.parentNode;y=y.clone({renameTo:f}),m?._adoptNodes(y)}else!(o instanceof d.LQDeepRef1)&&!(o instanceof d.ColumnRef0)&&(y=d.ColumnSchema.fromJSON({name:f,data_type:this.expr().dataType().jsonfy()}),o._adoptNodes(y));let p=(n||e.deSugar===!0||Number(e.deSugar?.selectAliases)===1||e.deSugar?.selectAliases===-1&&(this.parentNode?.entries().length||0)>1)&&a||this.alias()?.jsonfy();return{nodeName:u.NODE_NAME,expr:l,alias:p,result_schema:y}}return super.jsonfy(e,t,r)}};var An=class extends le{static get syntaxRules(){return[{syntaxes:[{...[].concat(super.syntaxRules)[0]},[{type:"keyword",as:"as_kw",value:"AS",booleanfy:!0},{...[].concat(super.syntaxRules)[0],assert:!0}]]},{type:"AggrNotation",as:"is_aggr",autoSpacing:!1,optional:!0}]}asKW(){return this._get("as_kw")}isAggr(){return this._get("is_aggr")}jsonfy(e={},t=null,r=null){let s=super.jsonfy(e,t,r);return(e.deSugar===!0||e.deSugar?.normalizeCasing)&&!s.delim&&(s={...s,value:s.value.toLowerCase()}),s}};var Tn=class extends X(w){static get syntaxRules(){return[{type:"CallExpr",as:"call_expr"},{type:["SRFExprDDL1","SRFExprDDL2"],as:"qualif"}]}callExpr(){return this._get("call_expr")}qualif(){return this._get("qualif")}jsonfy(e={},t=null,r=null){let s=super.jsonfy(e,t,r);if(e.deSugar){let n=s.qualif?.column_defs||[],a=s.qualif?.alias?d.TableSchema.fromJSON({name:s.qualif.alias,entries:n}):d.JSONSchema.fromJSON({entries:n});s={...s,result_schema:a}}return s}};var On=class extends X(w){static get syntaxRules(){return[{type:"CallExpr",as:"call_expr"},{optional:!0,syntax:[{type:"keyword",as:"with_ordinality",value:"WITH",booleanfy:!0},{type:"keyword",value:"ORDINALITY",assert:!0}]}]}callExpr(){return this._get("call_expr")}withOrdinality(){return this._get("with_ordinality")}jsonfy(e={},t=null,r=null){let s=super.jsonfy(e,t,r);if(e.deSugar){let n,a;s.with_ordinality&&(a=d.ColumnSchema.fromJSON({name:{nodeName:d.Identifier.NODE_NAME,value:"ordinality"},data_type:{nodeName:d.DataType.NODE_NAME,value:"INT"}}));let o={nodeName:d.Identifier.NODE_NAME,value:s.call_expr.name};if(s.call_expr?.result_schema)if(n=s.call_expr.result_schema,n instanceof d.TableSchema||n instanceof d.JSONSchema)if(a){let c=n.jsonfy();n=n.constructor.fromJSON({name:o,...c,entries:[...c.entries,a]})}else n=n.clone();else n=d.JSONSchema.fromJSON({entries:[n.jsonfy()].concat(a||[])});else n=d.JSONSchema.fromJSON({entries:[{nodeName:d.ColumnSchema.NODE_NAME,name:o,data_type:this.callExpr().dataType().jsonfy()}].concat(a||[])});s={...s,result_schema:n}}return s}};var vn=class extends X(w){static get syntaxRules(){return[{type:"CallExpr",as:"call_expr"},{type:"SRFExprDDL1",as:"qualif",optional:!0}]}callExpr(){return this._get("call_expr")}qualif(){return this._get("qualif")}jsonfy(e={},t=null,r=null){let s=super.jsonfy(e,t,r);if(e.deSugar){let n;if(s.qualif?.column_defs.length)n=d.JSONSchema.fromJSON({entries:s.qualif.column_defs});else if(s.call_expr?.result_schema){let a=s.call_expr.result_schema;n=a instanceof d.TableSchema||a instanceof d.JSONSchema?a.clone():d.JSONSchema.fromJSON({entries:[a.jsonfy()]})}else{let a={nodeName:d.Identifier.NODE_NAME,value:s.call_expr.name};n=d.JSONSchema.fromJSON({entries:[{nodeName:d.ColumnSchema.NODE_NAME,name:a,data_type:this.callExpr().dataType().jsonfy()}]})}s={...s,result_schema:n}}return s}};var bn=class extends X(L){static get syntaxRules(){return[{type:"keyword",value:"ROWS"},{type:"keyword",value:"FROM"},{type:"paren_block",syntax:{type:"SRFExpr3",as:"entries",arity:{min:1},itemSeparator:{type:"punctuation",value:","},assert:!0,autoIndent:2},autoIndent:!0},{optional:!0,syntax:[{type:"keyword",as:"with_ordinality",value:"WITH",booleanfy:!0},{type:"keyword",value:"ORDINALITY",assert:!0}]}]}static get syntaxPriority(){return-1}withOrdinality(){return this._get("with_ordinality")}jsonfy(e={},t=null,r=null){let s=super.jsonfy(e,t,r);if(e.deSugar){let n=1,a=s.entries.reduce((c,l)=>{let f=l.result_schema.jsonfy().entries.map(y=>({...y,name:{...y.name,value:n++}}));return c.concat(f)},[]);s.with_ordinality&&a.push({name:{nodeName:d.Identifier.NODE_NAME,value:n},data_type:{nodeName:d.DataType.NODE_NAME,value:"INT"}});let o=d.JSONSchema.fromJSON({entries:a});s={...s,result_schema:o}}return s}};var Rn=class extends w{static get syntaxRules(){return[{type:"keyword",as:"as_kw",value:"AS"},{type:"paren_block",syntax:{type:"ColumnSchema",as:"column_defs",arity:{min:1},itemSeparator:{type:"punctuation",value:","}}}]}asKW(){return this._get("as_kw")}columnDefs(){return this._get("column_defs")}};var Cn=class extends w{static get syntaxRules(){return[{syntaxes:[{type:"Identifier",as:"alias",peek:[1,"paren_block"]},[{type:"keyword",as:"as_kw",value:"AS",peek:[2,"paren_block"]},{type:"Identifier",as:"alias",assert:!0}]]},{type:"paren_block",syntax:{type:"ColumnSchema",as:"column_defs",arity:{min:1},itemSeparator:{type:"punctuation",value:","}}}]}asKW(){return this._get("as_kw")}alias(){return this._get("alias")}columnDefs(){return this._get("column_defs")}};var In=class extends St{static get syntaxRules(){return{type:"paren_block",syntax:super.syntaxRules,autoIndent:!0}}};var ze=class extends Se{static get syntaxRules(){return{type:["CompleteSelectStmt","CompositeSelectStmt"],expression:2}}static buildSyntaxRules(e=null){let t=(s=[])=>[{type:"keyword",value:"SELECT"},{type:"DistinctClause",as:"distinct_clause",optional:!0},{type:"SelectList",as:"select_list"},{optional:!0,syntax:[{type:"FromClause",as:"from_clause",autoSpacing:`
`},{type:"JoinClause",as:"join_clauses",arity:1/0,optional:!0,autoSpacing:`
`},{type:"MYPartitionClause",as:"my_partition_clause",optional:!0,autoSpacing:`
`},{type:"WhereClause",as:"where_clause",optional:!0,autoSpacing:`
`},{optional:!0,syntax:[{type:"GroupByClause",as:"group_by_clause",autoSpacing:`
`},{type:"HavingClause",as:"having_clause",optional:!0,autoSpacing:`
`}]},{type:"WindowClause",as:"window_clause",optional:!0,autoSpacing:`
`},...s],autoSpacing:`
`}],r=()=>[{type:"OrderByClause",as:"order_by_clause",optional:!0,autoSpacing:`
`},{type:"LimitClause",as:"limit_clause",optional:!0,autoSpacing:`
`},{type:"OffsetClause",as:"offset_clause",optional:!0,autoSpacing:`
`},{type:"PGFetchClause",as:"pg_fetch_clause",optional:!0,dialect:"postgres",autoSpacing:`
`},{type:"ForClause",as:"for_clause",optional:!0,autoSpacing:`
`}];return e===1?t():e===2?r():t(r())}dataType(){return d.DataType.fromJSON({value:"SET"})}};var At=class extends Nt(ze){static get syntaxRules(){return this.buildSyntaxRules(1)}static get syntaxPriority(){return-1}distinctClause(){return this._get("distinct_clause")}selectList(){return this._get("select_list")}fromClause(){return this._get("from_clause")}joinClauses(){return this._get("join_clauses")}whereClause(){return this._get("where_clause")}groupByClause(){return this._get("group_by_clause")}havingClause(){return this._get("having_clause")}windowClause(){return this._get("window_clause")}myPartitionClause(){return this._get("my_partition_clause")}get length(){return this.selectList()?.length??0}[Symbol.iterator](){return(this.selectList()||[])[Symbol.iterator]()}jsonfy(e={},t=null,r=null){if(!e.deSugar)return super.jsonfy(e,t,r);let s={select_list:null,group_by_clause:new Set,having_clause:new Set,order_by_clause:new Set};t=new ae((l,f,y)=>{if(l instanceof d.SelectList){s.select_list=f;return}return l instanceof d.GroupByClause||l instanceof d.HavingClause||l instanceof d.OrderByClause&&l.parentNode===this?f((p,m,h)=>{if((typeof h=="number"||h==="expr")&&p.parentNode===l){try{s[y].add(m())}catch(g){if(g instanceof Me)s[y].add(m);else throw g}return}return m()}):f()},t,this);let n=super.jsonfy(e,t,r),a=s.select_list(),{select_list:o,...c}=this.finalizeSelectorJSON(n,t,r,e);a=this.selectList().finalizeJSON(a,t,r,e),n={select_list:a,...c,result_schema:a.result_schema,origin_schemas:this.getOriginSchemas(t)};for(let[l,f]of Object.entries(s)){if(l==="select_list"||!f.size)continue;let y=[];for(let p of f)typeof p=="function"&&(p=p()),y.push(p);l==="having_clause"?n={...n,[l]:{expr:y[0]}}:(l==="group_by_clause"||l==="order_by_clause")&&(n={...n,[l]:{entries:y}})}return n}};var kn=class extends At{static get syntaxRules(){return this.buildSyntaxRules()}static get syntaxPriority(){return 99}orderByClause(){return this._get("order_by_clause")}offsetClause(){return this._get("offset_clause")}limitClause(){return this._get("limit_clause")}forClause(){return this._get("for_clause")}pgFetchClause(){return this._get("pg_fetch_clause")}};var Dn=class extends ze{static get syntaxRules(){let e=["DerivedQuery","ValuesTableLiteral","ValuesConstructor","TableStmt","BasicSelectStmt"];return[{type:[...e,"CompositeSelectStmt"],as:"left"},{type:"operator",as:"operator",value:["INTERSECT","UNION","EXCEPT"],autoSpacing:`
`},{type:"keyword",as:"all_or_distinct",value:["ALL","DISTINCT"],optional:!0},{type:e,as:"right",assert:!0,autoSpacing:`
`},...this.buildSyntaxRules(2)]}static get syntaxPriority(){return-1}left(){return this._get("left")}operator(){return this._get("operator")}allOrDistinct(){return this._get("all_or_distinct")}right(){return this._get("right")}orderByClause(){return this._get("order_by_clause")}offsetClause(){return this._get("offset_clause")}limitClause(){return this._get("limit_clause")}forClause(){return this._get("for_clause")}pgFetchClause(){return this._get("pg_fetch_clause")}get length(){return this.left()?.length??0}[Symbol.iterator](){return(this.left()||[])[Symbol.iterator]()}jsonfy(e={},t=null,r=null){if(!e.deSugar)return super.jsonfy(e,t,r);let s={order_by_clause:null};t=new ae((c,l)=>{if(c instanceof d.OrderByClause){s.order_by_clause=l;return}return l()},t,this);let n=super.jsonfy(e,t,r),a=n.left.result_schema;t.statementContext.artifacts.set("outputSchemas",new Set(a?.entries()||[]));let o=s.order_by_clause?.();return n={...n,order_by_clause:o,result_schema:a},n}static async _parseFromRules(e,t,{left:r=void 0,minPrecedence:s=0,trail:n,...a},o={}){let c=n.slice(-3);if(!(c[0]===this.NODE_NAME&&c[2]===this.NODE_NAME)){if((await e.match("operator"))?.isSetOp&&r instanceof d.CompleteSelectStmt){if(r.orderByClause()||r.offsetClause()||r.limitClause()||r.forClause()){let l=e.current(),f=`[${this.NODE_NAME}] Unexpected ${l.type} token:${typeof l.value=="string"?` "${l.value}"`:""} at <line ${l.line}, column ${l.column}>`;throw new SyntaxError(f)}r=d.BasicSelectStmt.fromJSON({...r.jsonfy(),nodeName:void 0})}return await super._parseFromRules(e,t,{left:r,minPrecedence:s,trail:n,...a},o)}}};var Ln=class extends Se{static get syntaxRules(){return[{type:"keyword",value:"TABLE"},{type:"keyword",as:"pg_only_kw",value:"ONLY",optional:!0,dialect:"postgres"},{type:"TableRef2",as:"table_ref",assert:!0},{type:"operator",as:"pg_star_ref",value:"*",booleanfy:!0,optional:!0,dialect:"postgres"}]}tableRef(){return this._get("table_ref")}pgOnlyKW(){return this._get("pg_only_kw")}pgStarRef(){return this._get("pg_star_ref")}jsonfy(e={},t=null,r=null){let s=super.jsonfy({...e,forceDeSugar:e.deSugar},t,r);if(e.deSugar){let n=s.table_ref.result_schema;s={...s,result_schema:d.JSONSchema.fromJSON({entries:n.jsonfy().entries}),origin_schemas:[n]}}return s}};var fa={};be(fa,{AggrNotation:()=>Mn,LQVersionSpec:()=>Pn});var Mn=class extends w{static get syntaxRules(){return{type:"bracket_block",syntax:{type:"Expr",as:"_",arity:0,assert:!0}}}static get syntaxPriority(){return-1}};var Pn=class extends w{static get syntaxRules(){return{type:"version_spec",as:"."}}static get syntaxPriority(){return-1}value(){return this._get("value")}};var pa={};be(pa,{DataType:()=>jn});var jn=class extends w{static get syntaxRules(){return[{syntaxes:[{type:"data_type",as:"."},{type:"keyword",as:".",value:["SET"]}]},{type:"paren_block",syntax:{type:"Expr",as:"specificity",arity:1/0,itemSeparator:{type:"punctuation",value:","},assert:!0},optional:!0,optionalParens:!0,autoSpacing:!1},{type:"AggrNotation",as:"pg_is_aggr",autoSpacing:!1,optional:!0,dialect:"postgres"}]}value(){return this._get("value")}specificity(){return this._get("specificity")}pgIsAggr(){return this._get("pg_is_aggr")}};var Un=class extends L{static get syntaxRules(){return{type:["JSONSchema","TableSchema","ColumnSchema","ColumnRef1"],as:"entries",arity:1/0}}};var Jt=class extends L{static get _contentTypes(){return["SelectStmt","TableStmt","InsertStmt","UpsertStmt","UpdateStmt","DeleteStmt","MYSetStmt","CTE","CreateSchemaStmt","DropSchemaStmt","CreateTableStmt","DropTableStmt"]}static get syntaxRules(){let e={type:"punctuation",value:";"};return{type:this._contentTypes,as:"entries",arity:1/0,itemSeparator:e,autoSpacing:`
`}}static async parse(e,t={}){let r=await this.toStream(e,t),s=await super.parse(r,t);if(!r.done&&r.current()){let n=r.current(),a=`[${this.NODE_NAME}] Unexpected ${n.type} token:${typeof n.value=="string"?` "${n.value}"`:""} at <line ${n.line}, column ${n.column}>`;throw new SyntaxError(a)}return s}stringify(e={}){return`${super.stringify(e)};`}};Object.assign(d,{...oa,...la,...ua,...ca,...we,...fa,...pa,Script:Jt,JSONSchema:Un});function Tt(u,e=!1){if(u==="*")u={"*":["*"]};else if(Array.isArray(u)&&u.length)u=u.reduce((t,r,s)=>{let n;if(!(typeof r=="object"&&r)||!(n=Object.keys(r)).length||n.filter(c=>c!=="schema"&&c!=="tables").length)throw new SyntaxError(`Given selector ${JSON.stringify(u)} invalid at index ${s}`);let a=r.schema||"*",o=r.tables||"*";return{...t,[a]:[...new Set((t[a]||[]).concat(o))]}},{});else if(typeof u=="object"&&u&&Object.keys(u).length)u=Object.fromEntries(Object.entries(u).map(([t,r])=>[t,[].concat(r)]));else throw new SyntaxError(`Given selector ${JSON.stringify(u)} invalid`);return e&&(u=new Set(Object.entries(u).reduce((t,[r,s])=>t.concat([].concat(s).map(n=>JSON.stringify([r,n]))),[]))),u}function wi(u){let[e,t,r,s]=u.reduce(([n,a,o,c],l)=>/^!%|^!.+%$/.test(l)?[n,a,o,c.concat(l.slice(1))]:/^%|%$/.test(l)?[n,a,o.concat(l),c]:/^!/.test(l)?[n,a.concat(l.slice(1)),o,c]:[n.concat(l),a,o,c],[[],[],[],[]]);return[e,t,r,s]}function Ft(u,e){let[t,r,s,n]=wi(e),a=t.length?t.includes(u)||t.length===1&&t[0]==="*":!1,o=r.length?!r.includes(u):!1,c=s.length?s.some(f=>new RegExp(f.replace("%",".+?")).test(u)):!1,l=n.length?!n.some(f=>new RegExp(f.replace("%",".+?")).test(u)):!1;return[a,o,c,l].some(f=>f)}function Bn(...u){let e,t={};return typeof u[0]=="object"&&u[0]&&u[0].text?{text:e,...t}=u[0]:(e=u.shift(),Array.isArray(u[0])&&(t.values=u.shift()),typeof u[0]=="function"&&(t.callback=u.shift()),typeof u[0]=="object"&&u[0]&&(t={...t,...u.shift()})),[e,t]}function ce(u,e){if(Array.isArray(u)&&Array.isArray(e)){if(u.length!==e.length)return!1;for(let[s,n]of u.entries())if(!ce(n,e[s]))return!1;return!0}if(!(u instanceof w)||!(e instanceof w))return V(u,e);if(!(u instanceof e.constructor)&&!(e instanceof u.constructor))return!1;if(u instanceof d.BinaryExpr){let s=a=>[u,e].every(o=>a.includes(o.operator())),n;if(s([n="AND"])||s([n="OR"])){let a=ma(u,n),o=ma(e,n);return Ai(a,o,n)}if(s(["=","=="])||s(["!=","<>"])||u.operator()===e.operator()&&["IS","IS NOT","DISTINCT FROM"].includes(u.operator()))return ce(u.left(),e.left())&&ce(u.right(),e.right())||ce(u.right(),e.left())&&ce(u.left(),e.right());if(u.operator()==="<"&&e.operator()===">"||u.operator()==="<="&&e.operator()===">="||u.operator()===">"&&e.operator()==="<"||u.operator()===">="&&e.operator()==="<=")return ce(u.right(),e.left())&&ce(u.left(),e.right())}let t=new Set(u._keys().filter(s=>u._get(s)!==void 0)),r=new Set(e._keys().filter(s=>e._get(s)!==void 0));if(t.size!==r.size)return!1;for(let s of new Set([...t,...r]))if(!t.has(s)||!r.has(s)||!ce(u._get(s),e._get(s)))return!1;return!0}function Ai(u,e,t="AND"){if(t==="OR"){for(let[s,n]of u.entries())if(!ce(n,e[s]))return!1;return!0}let r=new Set(e);e:for(let s of u){for(let n of r)if(ce(s,n)){r.delete(n);continue e}return!1}return t==="AND~"?r:r.size===0}function ma(u,e="AND"){if(u instanceof d.BinaryExpr&&u.operator()===e){let t=ma(u.right(),e);return[u.left()].concat(t)}return[u]}var $n=class{#e=["public"];get searchPath(){return this.#e}#t;#r=new Map;#n;get catalog(){return this.#n}#i;get options(){return this.#i}constructor({driver:e,catalog:t=[]}={},r={}){this.#t=e,this.#n=new Set(t),this.#i=r}async provide(e){let t=[...this.#r.entries()],r={},s=!1,n=[],a=[],o=(h,g)=>g.includes(h)?!0:/^!|^%|%$|^\*$/.test(h)?!1:Ft(h,g),c=(h,g,_)=>g[0]===h?-1:_[0]===h||g[0]==="*"?1:_[0]==="*"?-1:0,l=(h,g)=>{r[h]=g;let _=[].concat(this.#r.get(h)?.tables||[]).concat(g),x={schema:h,tables:_,fulfilment:null};this.#r.set(h,x),a.push(x)},f=(h,g)=>{if(!t.length)return l(h,g);let _=t.sort((x,E)=>c(h,x,E));for(let[x,E]of _)if(o(h,[x])){let S=g.filter(N=>!o(N,E.tables));S.length<g.length&&(s=!0,E.fulfilment&&n.push(E.fulfilment)),S.length&&l(h,S)}else l(h,g)};e=Tt(e);for(let[h,g]of Object.entries(e))f(h,g);let y,p=Promise.resolve(0);if(Object.keys(r).length){y=this.#t?.showCreate(r,!0),n.push(y);for(let h of a)h.fulfilment=y;y.finally(()=>{for(let h of a)h.fulfilment=null}),p=Promise.all(n).then(()=>s?2:1)}else n.length&&(p=Promise.all(n).then(()=>-1));let m=await y;if(m?.length)for(let h of m){let g=xt.fromJSON(h,{dialect:this.#t.dialect});for(let _ of this.#n)if(_.name().identifiesAs(g.name())){for(let x of _.tables())g.has(x.name())||g.add(x.clone());this.#n.delete(_)}this.#n.add(g)}return await p}};var ke=class{#e=new Map;#t=new Set;on(e,t){return this.#e.has(e)||this.#e.set(e,new Set),this.#e.get(e).add(t),()=>{if(this.#e.get(e).delete(t),!this.#e.get(e).size&&(this.#e.delete(e),!this.#e.size)){for(let r of this.#t)r();this.#t.clear()}}}onClose(e){this.#t.add(e)}emit(e,t){let r=this.#e.get(e);if(r)for(let s of r){s(t);try{}catch(n){console.error("emitter handler error",n)}}}};var Ot=class extends ke{get dialect(){throw new Error("Not implemented")}get enableLive(){throw new Error("Not implemented")}async connect(){throw new Error("Not implemented")}async disconnect(){throw new Error("Not implemented")}async query(e,t="public"){throw new Error("Not implemented")}async showCreate(e,t=!1){throw new Error("Not implemented")}#e;#t=new Map;get schemaInference(){return this.#e}constructor(){super(),this.#e=new $n({driver:this})}async _normalizeQueryArgs(...e){let[t,r]=Bn(...e);if(typeof t=="string")t=await d.Script.parse(t,{dialect:r.dialect||this.dialect});else if(!(t instanceof d.Script)&&!(t instanceof Fe))throw new TypeError("query must be a string or an instance of Script | AbstractStmt");if(t instanceof d.Script&&t.length===1&&(t=t.entries()[0]),t instanceof d.DDLStmt&&!t.returningClause?.()||t.originSchemas?.()?.length)return[t,r];let s={},n=!1;return t.walkTree(a=>{if(a instanceof d.DDLStmt&&!a.returningClause?.())return;if((!(a instanceof d.TableRef2)||a.parentNode instanceof d.ColumnIdent)&&(!(a instanceof d.TableRef1)||a.parentNode instanceof d.ColumnRef1))return a;let o=a.qualifier()?._get("delim")?a.qualifier().value():a.qualifier()?.value().toLowerCase()||"*",c=a._get("delim")?a.value():a.value().toLowerCase();o in s||(s[o]=[]),s[o].includes(c)||(s[o].push(c),n=!0)}),n&&await this.#e.provide(s),t=t.deSugar(!0,{},null,this.#e),[t,r]}subscribe(e,t){typeof e=="function"&&(t=e,e="*");let r=Tt(e,!0);return this.#t.set(t,r),()=>this.#t.delete(t)}_fanout(e){let t=[],r=new Set;for(let s of e){let n=[JSON.stringify([s.relation.schema,s.relation.name]),JSON.stringify(["*",s.relation.name]),JSON.stringify([s.relation.schema,"*"])];t.push({event:s,patterns:n}),r.add(n[0]),r.add(n[1]),r.add(n[2])}for(let[s,n]of this.#t.entries()){let a=[];for(let o of n)if(o==='["*","*"]'){a=[...e];break}else if(r.has(o)){for(let{event:c,patterns:l}of t)l.includes(o)&&a.push(c);break}a.length&&s(a)}}};var ka={};be(ka,{any:()=>qi,apply:()=>Oa,batch:()=>Ia,construct:()=>Ta,defineProperties:()=>Yi,defineProperty:()=>Ht,deleteProperties:()=>Vi,deleteProperty:()=>Kt,get:()=>$e,getOwnPropertyDescriptor:()=>Wn,getOwnPropertyDescriptors:()=>Hi,getPrototypeOf:()=>Na,has:()=>Hn,intercept:()=>Wi,isExtensible:()=>wa,map:()=>Ki,observe:()=>Ca,ownKeys:()=>Aa,path:()=>Fi,preventExtensions:()=>ba,reduce:()=>Ra,set:()=>at,setPrototypeOf:()=>va,subtree:()=>Gi});function he(u){return!Array.isArray(u)&&typeof u=="object"&&u}function vt(u){return typeof u}function Te(u){return Array.isArray(u)}function bt(u){return typeof u=="function"}function ya(u){return u===null||u===""}function rt(u){return arguments.length&&(u===void 0||typeof u>"u")}function de(u){return Array.isArray(u)||typeof u=="object"&&u||bt(u)}function da(u){return ya(u)||rt(u)||u===!1||u===0||de(u)&&!Object.keys(u).length}function je(u){return bt(u)||u&&{}.toString.call(u)==="[object function]"}function Jn(u){return u instanceof String||typeof u=="string"&&u!==null}function ha(u){return!Jn(u)&&!rt(u.length)}function Gn(u,...e){if(!u||!["object","function"].includes(typeof u))throw new Error("Argument #1 must be of type object");let t=u[Symbol.for("wq")];if(t||(t=new Fn,Object.defineProperty(u,Symbol.for("wq"),{value:t,enumerable:!1,configurable:!1,writable:!1})),!e.length)return t;let r,s;for(;r=e.shift();)(s=t)&&!(t=t.get(r))&&(t=new Fn,s.set(r,t));return t}var Fn=class extends Map{};function Xe(u,e=!0){return Te(u)?u:!e&&he(u)?[u]:u!==!1&&u!==0&&da(u)?[]:ha(u)?Array.prototype.slice.call(u):he(u)?Object.values(u):[u]}var oe=(u,...e)=>Gn(u,"observerAPI",...e),Rt=(u,e)=>u instanceof Promise?u.then(e):e(u),qn={};var st=class{constructor(e,t){this.registry=e,Object.assign(this,{...t,target:e.target}),this.params.signal&&this.params.signal.addEventListener("abort",()=>this.remove())}remove(){return this.removed=!0,this.registry.removeRegistration(this)}};var Gt=class extends st{constructor(){super(...arguments),this.emit.currentRegistration=this,Object.defineProperty(this,"abortController",{value:new AbortController}),Object.defineProperty(this,"signal",{value:this.abortController.signal}),qn.setMaxListeners?.(0,this.signal)}remove(){this.abortController.abort(),super.remove()}fire(e){if(this.emit.recursionTarget&&!["inject","force-async","force-sync"].includes(this.params.recursions))return;let t=e,r=this.filter;if(r!==1/0&&(r=Xe(r,!1))&&(t=e.filter(n=>r.includes(n.key))),this.params.diff&&(t=t.filter(n=>n.type!=="set"||n.value!==n.oldValue)),!t.length)return;if(["inject","defer"].includes(this.params.recursions)){if(this.emit.recursionTarget){this.emit.recursionTarget.push(...t);return}this.emit.recursionTarget=this.params.recursions==="inject"?t:[]}let s=this.filter===1/0||Array.isArray(this.filter)?this.emit(t,this):this.emit(t[0],this);return Rt(s,n=>{let a=this.emit.recursionTarget;return delete this.emit.recursionTarget,this.params.recursions==="defer"&&a?.length?this.emit.currentRegistration.fire(a):n})}};var nt=class{constructor(e){this.target=e,this.entries=[]}addRegistration(e){return this.entries.push(e),e}removeRegistration(e){this.entries=this.entries.filter(t=>t!==e)}static _getInstance(e,t,r=!0,s=this.__namespace){if(!de(t))throw new Error(`Subject must be of type object; "${vt(t)}" given!`);let n=this;return s&&oe(globalThis,"observerAPI","namespaces").has(e+"-"+s)&&(n=oe(globalThis,"observerAPI","namespaces").get(e+"-"+s),e+="-"+s),!oe(t,"registry").has(e)&&r&&oe(t,"registry").set(e,new n(t)),oe(t,"registry").get(e)}static _namespace(e,t,r=null){if(e+="-"+t,arguments.length===2)return oe(globalThis,"observerAPI","namespaces").get(e);if(!(r.prototype instanceof this))throw new Error(`The implementation of the namespace ${this.name}.${t} must be a subclass of ${this.name}.`);oe(globalThis,"observerAPI","namespaces").set(e,r),r.__namespace=t}};var ye=class{constructor(e,t){if(this.target=e,!t.operation)throw new Error("Descriptor operation must be given in definition!");Object.assign(this,t)}};var Ue=class extends nt{static getInstance(e,t=!0,r=null){return super._getInstance("listeners",...arguments)}static namespace(e,t=null){return super._namespace("listeners",...arguments)}constructor(e){super(e),this.batches=[]}addRegistration(e,t,r){return super.addRegistration(new Gt(this,{filter:e,emit:t,params:r}))}emit(e,{eventsArePropertyDescriptors:t=!1,eventIsArrayMethodDescriptor:r=!1}={}){if(this.batches.length){let s=this.batches[0].params.arrayMethodName;this.batches[0].snapshots.push({events:[...e],arrayMethodName:s,eventsArePropertyDescriptors:t,eventIsArrayMethodDescriptor:r});return}this.$emit(this.entries,[{events:e,eventsArePropertyDescriptors:t,eventIsArrayMethodDescriptor:r}])}$emit(e,t){let r=0,s=0,n=0;for(let f of e)r+=1,f.params.withPropertyDescriptors&&(s+=1),f.params.withArrayMethodDescriptors&&(n+=1);let a=[],o=[],c=[],l=[];for(let f of t){let y=f.arrayMethodName,p=f.eventsArePropertyDescriptors,m=f.eventIsArrayMethodDescriptor;for(let h of f.events)if(y&&(h.operation=y),s&&(n&&a.push(h),m||n!==r&&o.push(h)),s!==r){let g=h;if(p){let{target:_,type:x,...E}=h;g=new ye(_,{type:"set",...E}),Object.defineProperty(g,"value","get"in E.value?{get:()=>E.value.get()}:{value:E.value.value}),E.oldValue&&Object.defineProperty(g,"oldValue","get"in E.oldValue?{get:()=>E.oldValue.get()}:{value:E.oldValue.value})}n&&c.push(g),m||n!==r&&l.push(g)}}for(let f of e)f.params.withPropertyDescriptors?f.params.withArrayMethodDescriptors?a.length&&f.fire(a):o.length&&f.fire(o):f.params.withArrayMethodDescriptors?c.length&&f.fire(c):l.length&&f.fire(l)}batch(e,t={}){this.batches.unshift({entries:[...this.entries],snapshots:[],params:t});let r=e();return Rt(r,s=>{let n=this.batches.shift();return n.snapshots.length&&this.$emit(n.entries,n.snapshots),s})}};var qt=class extends st{exec(e,t,r){return this.running||!this.traps[e.operation]?t(...Array.prototype.slice.call(arguments,2)):(this.running=!0,this.traps[e.operation](e,r,(...s)=>(this.running=!1,t(...s))))}};var Be=class extends nt{static getInstance(e,t=!0,r=null){return super._getInstance("traps",...arguments)}static namespace(e,t=null){return super._namespace("traps",...arguments)}addRegistration(e){return super.addRegistration(new qt(this,e))}emit(e,t=null){let r=this;return function s(n,...a){let o=r.entries[n];return o?o.exec(e,(...c)=>s(n+1,...c),...a):t?t(e,...a):a[0]}(0)}};var Sa={};be(Sa,{accessorize:()=>$i,proxy:()=>xa,unaccessorize:()=>Ji,unproxy:()=>Wt});var ri=Symbol("wqOriginal");function $i(u,e,t={}){u=Ea(u);let r=oe(u,"accessorizedProps");function s(c){let l,f=u;do l=Object.getOwnPropertyDescriptor(f,c);while(!l&&(f=Object.getPrototypeOf(f)));return l?{proto:f,descriptor:l}:{descriptor:{value:void 0,configurable:!0,enumerable:!0,writable:!0}}}function n(c){if(r.has(c+""))return!0;let l=s(c);l.getValue=function(p=!1){return p?this.descriptor:this.descriptor.get?this.descriptor.get():this.descriptor.value},l.setValue=function(p,m=!1){if(this.dirty=!0,m){this.descriptor=p;return}return this.descriptor.set?this.descriptor.set(p)!==!1:(this.descriptor.value=p,!0)},l.intact=function(){let p=Object.getOwnPropertyDescriptor(u,c);return p?.get===y.get&&p?.set===y.set&&r.get(c+"")===this},l.restore=function(){return this.intact()?(this.proto&&this.proto!==u||!this.proto&&!this.dirty?delete u[c]:Object.defineProperty(u,c,this.descriptor),r.delete(c+""),!0):!1},r.set(isNaN(c)?c:parseInt(c),l);let{enumerable:f=!0}=l.descriptor,y={enumerable:f,configurable:!0};("value"in l.descriptor||l.descriptor.set)&&(y.set=function(p){return at(this,c,p,t)}),("value"in l.descriptor||l.descriptor.get)&&(y.get=function(){return $e(this,c,t)});try{return Object.defineProperty(u,c,y),!0}catch{return r.delete(c+""),!1}}let o=(Array.isArray(e)?e:e===void 0?Object.keys(u):[e]).map(n);return e===void 0||Array.isArray(e)?o:o[0]}function Ji(u,e,t={}){u=Ea(u);let r=oe(u,"accessorizedProps");function s(o){return r.has(o+"")?r.get(o+"").restore():!0}let a=(Array.isArray(e)?e:e===void 0?Object.keys(u):[e]).map(s);return e===void 0||Array.isArray(e)?a:a[0]}function xa(u,e={},t=void 0){let r=Ea(u);if(typeof e.membrane=="boolean")throw new Error("The params.membrane parameter cannot be of type boolean.");if(e.membrane&&oe(r,"membraneRef").has(e.membrane))return oe(r,"membraneRef").get(e.membrane);let s={apply:(o,c,l)=>Oa(o,c,l,void 0,e),construct:(o,c,l=null)=>Ta(o,c,l,e),defineProperty:(o,c,l)=>Ht(o,c,l,e),deleteProperty:(o,c)=>Kt(o,c,e),get:(o,c,l=null)=>{if(c===ri)return r;let f={...e,receiver:l},y=$e(o,c,f);return Array.isArray(o)&&typeof y=="function"&&!/^class\s?/.test(Function.prototype.toString.call(y))?xa(y,{...e,arrayMethodName:c,membrane:l},t):e.chainable&&de(y)&&c!=="prototype"&&!(typeof y=="function"&&/^class\s?|\{\s\[native\scode\]\s\}$/.test(Function.prototype.toString.call(y)))?xa(y,e,t):y},getOwnPropertyDescriptor:(o,c)=>Wn(o,c,e),getPrototypeOf:o=>Na(o,e),has:(o,c)=>Hn(o,c,e),isExtensible:o=>wa(o,e),ownKeys:o=>Aa(o,e),preventExtensions:o=>ba(o,e),set:(o,c,l,f=null)=>at(o,c,l,{...e,receiver:f}),setPrototypeOf:(o,c)=>va(o,c,e)},n=t?.(s)||s,a=new Proxy(r,n);return e.membrane&&oe(r,"membraneRef").set(e.membrane,a),a}function Wt(u){return u&&u[ri]||u}function Ea(u){if(!u||!de(u))throw new Error("Target must be of type object!");return Wt(u)}var Yt=class extends Array{};function Fi(...u){return new Yt(...u)}var it=class extends Array{};function Gi(){return new it}function qi(){return 1/0}function Ra(u,e,t,r=n=>n,s={}){let n=e instanceof it;if(!(!n&&!e?.length))return function a(o,c,l,f){let y=f||c[l.level]instanceof it,p=y?1/0:c[l.level],m=y?!1:l.level===c.length-1;return o instanceof ye&&o.operation!=="get"?l={...l,probe:"always"}:l.probe!=="always"&&(l={...l,probe:!m}),t(o,p,(h,...g)=>{let _=S=>{S instanceof ye&&(S.path="key"in S?[S.key]:[],o instanceof ye&&(S.path="key"in S?o.path.concat(S.key):o.path.slice(0),Object.defineProperty(S,"context",{get:()=>o,configurable:!0})))},x=g[0]||{},E=S=>{if(S instanceof ye&&"argumentsList"in S)return;let N=De(S,!1);return Rt(N,A=>(S instanceof ye?S.value=A:S=A,a(S,c,{...l,...x,keyInParent:S.key,level:l.level+1},y)))};if(Vt(p)&&Array.isArray(h)){if(h.forEach(_),m)return r(h,...g);y&&h[0]instanceof ye&&(h[0].operation!=="get"||s.asGet)&&r(h,...g);for(let S of h)E(S);return}return _(h),m?r(h,...g):E(h)},l)}(u,e.slice(0),{...s,level:0},n)}function Ca(u,e,t,r={}){let s=De(u,!r.level);if(je(arguments[1])&&([,t,r={}]=arguments,e=1/0),!je(t))throw new Error(`Handler must be a function; "${vt(t)}" given!`);if(e instanceof Yt||e instanceof it)return Ra(s,e,Ca,t,r);if(r={...r,descripted:!0},delete r.live,!de(s))return r.probe&&$e(s,e,t,r)||void 0;let n=si(s,e,t,r);return r.probe?$e(s,e,n,r):n()}function Wi(u,e,t={}){let r=De(u);return he(e)||([,,,t={}]=arguments,e={[arguments[1]]:arguments[2]}),Be.getInstance(r,!0,t.namespace).addRegistration({traps:e,params:t})}function Wn(u,e,t=s=>s,r={}){return Oe(u,"getOwnPropertyDescriptor",{key:e},t,r)}function Hi(u,e,t=s=>s,r={}){return Oe(u,"getOwnPropertyDescriptors",{key:e},t,r)}function Na(u,e=r=>r,t={}){return Oe(u,"getPrototypeOf",{},e,t)}function wa(u,e=r=>r,t={}){return Oe(u,"isExtensible",{},e,t)}function Aa(u,e=r=>r,t={}){return Oe(u,"ownKeys",{},e,t)}function Hn(u,e,t=s=>s,r={}){return Oe(u,"has",{key:e},t,r)}function $e(u,e,t=s=>s,r={}){let s,n=De(u,!r.level);return he(t)?[r,t]=[t,a=>a]:r.live&&(s=!0),e instanceof Yt||e instanceof it?Ra(n,e,$e,t,{...r,asGet:!0}):Qi(n,e,a=>{let o=[...a];return function c(l,f,y){if(!f.length)return y(l);let p=f.shift();if(!["string","number","symbol"].includes(typeof p))throw new Error(`Property name/key ${p} invalid.`);function m(_,x=void 0){let E=A=>(_.value=A,c([...l,r.live||r.descripted?_:A],f,y));if(arguments.length>1)return E(x);if(!de(n))return E(n?.[_.key]);let S=oe(n,"accessorizedProps",!1),N=S&&S.get(_.key);if(N&&N.intact())return E(N.getValue(r.withPropertyDescriptors));if(r.withPropertyDescriptors){let A=Object.getOwnPropertyDescriptor(n,_.key);return E(A)}return E(Reflect.get(n,_.key))}let h=new ye(n,{type:"get",key:p,value:void 0,operation:"get",related:o});if(!de(n))return m(h);let g=Be.getInstance(n,!1,r.namespace);return g?g.emit(h,m):m(h)}([],a.slice(0),c=>{let l=Vt(e)?c:c[0];return s&&de(n)?si(n,e,t,r,u.key)(l):t(l)})},r)}function Ia(u,e,t={}){let r=De(u);return Ue.getInstance(r,!0,t.namespace).batch(e,t)}function Ki(u,e,t={}){e=De(e),u=De(u);let r=(t.only||[]).slice(0),s=(t.except||[]).slice(0),n=Object.keys(t.spread?[...u]:u).map(l=>isNaN(l)?l:parseInt(l)),a=r.length?r.filter(l=>n.includes(l)):n.filter(l=>!s.includes(l)),o=l=>!Array.isArray(e)||isNaN(l)?l:l-s.filter(f=>f<l).length,c=l=>{let f=Wn(u,l,t);"value"in f&&f.writable&&f.enumerable&&f.configurable?at(e,o(l),f.value,t):(f.enumerable||t.onlyEnumerable===!1)&&Ht(e,l,{...f,configurable:!0},t)};return Ia(e,()=>{a.forEach(c)}),Ca(u,l=>{l.filter(f=>r.length?r.includes(f.key):!s.includes(f.key)).forEach(f=>{if(f.type==="delete")return Kt(e,o(f.key),t);if(f.type==="def"){(f.value.enumerable||t.onlyEnumerable===!1)&&Ht(e,o(f.key),{...f.value,configurable:!0},t);return}c(f.key)})},{...t,withPropertyDescriptors:!0})}function at(u,e,t,r=a=>a,s={},n=!1){let a=De(u),o=[[e,t]];he(e)&&([,,r=l=>l,s={},n=!1]=arguments,o=Object.entries(e)),he(r)&&([n,s,r]=[typeof s=="boolean"?s:n,r,l=>l]);let c=o.map(([l])=>l);return function l(f,y,p){if(!y.length)return p(f);let[m,h]=y.shift();function g(x,E=void 0){let S=v=>(x.status=v,l(f.concat(x),y,p));if(arguments.length>1)return S(x,E);let N=oe(a,"accessorizedProps",!1),A=N&&N.get(x.key);return x.type==="def"?(A&&!A.restore()&&S(!1),Object.defineProperty(a,x.key,x.value),S(!0)):A&&A.intact()?S(A.setValue(x.value)):S(Reflect.set(a,x.key,x.value))}function _(x,E){if(s.diff&&h===E)return l(f,y,p);let S=new ye(a,{type:n?"def":"set",key:m,value:h,isUpdate:x,oldValue:E,related:[...c],operation:n?"defineProperty":"set",detail:s.detail}),N=Be.getInstance(a,!1,s.namespace);return N?N.emit(S,g):g(S)}return Hn(a,m,x=>{if(!x)return _(x);if(m==="length"&&Array.isArray(a)&&oe(a).has("$length"))return _(!0,oe(a).get("$length"));let E={...s,withPropertyDescriptors:n};return $e(a,m,S=>_(x,S),E)},s)}([],o.slice(0),l=>{let f=Ue.getInstance(a,!1,s.namespace);return f&&f.emit(l,{eventsArePropertyDescriptors:!!n}),r(Vt(e)?l.map(y=>y.status):l[0]?.status)})}function Ht(u,e,t,r=n=>n,s={}){return at(u,e,t,r,s,!0)}function Yi(u,e,t=s=>s,r={}){return at(u,e,t,r,!0)}function Kt(u,e,t=s=>s,r={}){let s=De(u);he(t)&&([r,t]=[t,o=>o]);let n=Xe(e,!1),a=[...n];return function o(c,l,f){if(!l.length)return f(c);let y=l.shift();function p(h,g=void 0){let _=S=>(h.status=S,o(c.concat(h),l,f));if(arguments.length>1)return _(h,g);let x=oe(s,"accessorizedProps",!1),E=x&&x.get(h.key);return E&&!E.restore()&&_(!1),_(Reflect.deleteProperty(s,h.key))}function m(h){let g=new ye(s,{type:"delete",key:y,oldValue:h,related:[...a],operation:"deleteProperty",detail:r.detail}),_=Be.getInstance(s,!1,r.namespace);return _?_.emit(g,p):p(g)}return $e(s,y,m,r)}([],n.slice(0),o=>{let c=Ue.getInstance(s,!1,r.namespace);return c&&c.emit(o),t(Vt(e)?o.map(l=>l.status):o[0].status)})}function Vi(u,e,t=s=>s,r={}){return Kt(...arguments)}function Ta(u,e,t=null,r=n=>n,s={}){return Oe(u,"construct",arguments.length>2?{argumentsList:e,newTarget:t}:{argumentsList:e},r,s)}function Oa(u,e,t,r=n=>n,s={}){let n=Wt(e),a;if(Array.isArray(e)){if(s.arrayMethodName){let o=new ye(n,{operation:s.arrayMethodName,argumentsList:t});Ue.getInstance(n,!1,s.namespace)?.emit([o],{eventIsArrayMethodDescriptor:!0})}oe(n).set("$length",n.length),a=Ia(n,()=>Oe(u,"apply",{thisArgument:e,argumentsList:t},r,s),s),oe(n).delete("$length")}else a=Oe(u,"apply",{thisArgument:n,argumentsList:t},r,s);return a}function va(u,e,t=s=>s,r={}){return Oe(u,"setPrototypeOf",{proto:e},t,r)}function ba(u,e=r=>r,t={}){return Oe(u,"preventExtensions",{},e,t)}function si(u,e,t,r={}){let s=new AbortController;qn.setMaxListeners?.(0,s.signal),r.signal&&r.signal.addEventListener("abort",()=>s.abort());let n={...r,signal:s.signal},a=Ue.getInstance(u,!0,n.namespace),o=new Map;return function c(l=[],f=null){let y,p,m;if(Vt(e)){if(f){m=!0,p=f;for(let h of l)o.get(h.key)?.remove(),o.delete(h.key)}else p=a.addRegistration(e,c,n);y={signal:p.signal,childRegistrations:o}}else f?.remove(),p=a.addRegistration(e,c,n),y={signal:p.signal};if(n.childRegistrations&&n.keyInParent&&n.childRegistrations.set(n.keyInParent,p),arguments.length){let h=t(l,y);if(arguments.length>1)return h}return s}}function Oe(u,e,t={},r=n=>n,s={}){u=De(u),he(r)&&([s,r]=[r,c=>c]);function n(c,l){return arguments.length>1?r(l):r((Reflect[e]||Object[e])(u,...Object.values(t)))}let a=new ye(u,{operation:e,...t}),o=Be.getInstance(u,!1,s.namespace);return o?o.emit(a,n):n(a)}function Vt(u){return u===1/0||Array.isArray(u)}function De(u,e=!0,t=!0){if((!u||!de(u))&&e)throw new Error(`Object must be of type object or array! "${vt(u)}" given.`);return u instanceof ye&&(u.type==="def"&&t?u=typeof u.value.get=="function"?u.value.get():u.value.value:u=u.value),u&&Wt(u)}function Qi(u,e,t,r={}){return e===1/0?r.level&&!de(u)?t([]):t(Object.entries(Object.getOwnPropertyDescriptors(u)).filter(([,s])=>s.writable!==!1&&!s.get&&!s.set).map(([s])=>s)):t(Xe(e,!1))}var zi={...ka,...Sa},Ct=zi;var Ze=class{#e;#t;get rows(){return this.#e}get rowCount(){return this.#t}constructor({rows:e=[],rowCount:t=0}={}){this.#e=e,this.#t=t}};var Kn=class extends Ze{#e;#t;#r;get _hashes(){return this.#t}constructor({rows:e=[],hashes:t=[]}={},r=()=>{},s=void 0){super({rows:e}),this.#e=Ct.proxy(e),this.#t=t,this.#r=r,s&&s.addEventListener("abort",()=>this.abort())}abort(){this.#r()}_apply(e,t){e==="diff"&&Ct.batch(this.#e,()=>{for(let r of t){if(r.type==="update"){let s=this.#t.indexOf(r.oldHash);s>-1?(Ct.set(this.#e[s],r.new,{diff:!0}),this.#t[s]=r.newHash):r={...r,type:"insert"}}if(r.type==="insert"&&(this.#e.push(r.new),this.#t.push(r.newHash)),r.type==="delete"){let s=this.#t.indexOf(r.oldHash);s>-1&&(this.#e.splice(s,1),this.#t.splice(s,1))}}}),e==="swap"&&Ct.batch(this.#e,()=>{let r=this.rows.slice(0),s=this.#t.slice(0);for(let[n,a]of t){let o=s.indexOf(n),c=s.indexOf(a);this.#e[c]=r[o],this.#t[c]=n}}),e==="result"&&(this.#t=t.hashes,Ct.batch(this.#e,()=>{let r=Math.max(this.#e.length,t.rows.length);for(let s=0;s<r;s++){if(!t.rows[s]){this.#e.splice(s);break}V(t.rows[s],this.#e[s])||(this.#e[s]=t.rows[s])}}))}};var ni=Symbol.for("grouping_meta"),Yn=Symbol.for("window_meta"),It=class{#e;#t;constructor(e=null,t={}){this.#e=e,this.#t=t}async evaluate(e,t,r={}){if(!e)throw new Error("ExprEngine: Cannot evaluate null/undefined node");if(["DERIVED_QUERY","SCALAR_SUBQUERY"].includes(e.NODE_NAME)){if(!this.#e)throw new Error(`ExprEngine: Node ${e.NODE_NAME} not supported in this context`);return await this.#e(e,t,r)}let s=this[e.NODE_NAME];if(!s)throw new Error(`ExprEngine: Unsupported AST node: ${e.NODE_NAME}`);return await s.call(this,e,t,r)}async evaluateToScalar(e,t,r){if(e instanceof d.DerivedQuery){let s=[];for await(let a of await this.evaluate(e,t,r))s.push(a);if(!s.length)return;if(s.length>1)throw new Error(`[${node}] Subquery returned more than one row`);let n=Object.values(s[0]);if(n.length>1)throw new Error(`[${node}] Subquery returned more than one column`);return n[0]??null}if(e instanceof d.RowConstructor){if(e.length!==1)throw new Error(`Expects a scalar expression but got ${e}`);return await this.evaluateToScalar(e.entries()[0],t,r)}return await this.evaluate(e,t,r)}async evaluateToList(e,t,r){if(e instanceof d.DerivedQuery){let n=[];for await(let a of await this.evaluate(e,t,r))n.push(a);if(!n.length)return[];if(Object.values(n[0]).length>1)throw new Error(`[${node}] Subquery returned more than one column`);return n.map(a=>Object.values(a)[0])}if(e instanceof d.RowConstructor)return await Promise.all(e.entries().map(n=>this.evaluateToScalar(n,t,r)));let s=await this.evaluate(e,t,r);if(!Array.isArray(s))throw new Error(`[${e}] Not a list`);return s}async SELECT_ITEM(e,t,r={}){let s=e.alias()?.value()||(this.#t.dialect==="mysql","?column?"),n=await this.evaluateToScalar(e.expr(),t,r);return{alias:s,value:n}}async ON_CLAUSE(e,t,r={}){return await this.evaluate(e.expr(),t,r)}async USING_CLAUSE(e,t){return(e.columns()||[e.column()]).every(s=>{let n=s.value(),a=Object.keys(t).filter(o=>o&&n in t[o]);if(a.length<2)throw new Error(`USING clause column ${n} not found in both tables`);return a.reduce((o,c)=>o&&V(t[c][n],t[a[0]][n]),!0)})}async ROW_CONSTRUCTOR(e,t,r={}){let s=await Promise.all(e.entries().map(n=>this.evaluateToScalar(n,t,r)));return s.length>1?s:s[0]}async TYPED_ROW_CONSTRUCTOR(e,t,r={}){return await this.ROW_CONSTRUCTOR(e,t,r)}async PG_TYPED_ARRAY_LITERAL(e,t,r={}){return await Promise.all(e.entries().map(s=>this.evaluate(s,t,r)))}async CASE_EXPR(e,t,r={}){let s=e.subject()?await this.evaluate(e.subject(),t,r):void 0;for(let n of e){let a=await this.evaluate(n.condition(),t,r);if(s===void 0?!!a:V(s,a))return await this.evaluate(n.consequent(),t,r)}return e.alternate()?await this.evaluate(e.alternate(),t,r):null}async CAST_EXPR(e,t,r={}){return await this._CAST_EXPR(e.expr(),e.dataType(),t,r)}async PG_CAST_EXPR2(e,t,r={}){return await this._CAST_EXPR(e.left(),e.right(),t,r)}async _CAST_EXPR(e,t,r,s={}){let n=await this.evaluateToScalar(e,r,s);switch(t.value()){case"INT":return parseInt(n);case"TEXT":return String(n);case"BOOLEAN":return!!n;default:return n}}async PREDICATE_EXPR(e,t,r={}){switch(e.predicate()){case"EXISTS":return!!(await(await this.evaluate(e.expr(),t,r)).next()).value;default:throw new Error(`ExprEngine: Unimplemented predicate ${e.predicate()}`)}}async IN_EXPR(e,t,r={}){let s=await this.evaluateToScalar(e.left(),t,r),n=await this.evaluateToList(e.right(),t,r),a=e.negation();return(c=>a?!c:c)(n.some(c=>V(s,c)))}async BETWEEN_EXPR(e,t,r={}){let s=await this.evaluateToScalar(e.left(),t,r),n=await Promise.all(e.right().map(c=>this.evaluateToScalar(c,t,r))),a=e.negation();return(c=>a?!c:c)(s>=n[0]&&s<=n[1])}async DISTINCT_FROM_EXPR(e,t,r={}){let s=await this.evaluate(e.left(),t,r),n=await this.evaluate(e.right(),t,r),a=e.logic()==="IS NOT";return(c=>a?!c:c)(!V(s,n))}async BINARY_EXPR(e,t,r={}){let s=e.operator().toUpperCase(),n=e.negation(),a=f=>n?!f:f,o=(f,y)=>{if((f===null||y===null)&&s!=="IS"&&s!=="IS NOT")return!1;switch(s){case"=":case"IS":return V(f,y);case"<>":case"!=":case"IS NOT":return!V(f,y);case"<":return f<y;case"<=":return f<=y;case">":return f>y;case">=":return f>=y;case"LIKE":return Xi(String(f),String(y));default:throw new Error(`ExprEngine: Unsupported comparison operator ${s}`)}};if(e.right()instanceof d.QuantitativeExpr){let f=e.right().quantifier(),y=await this.evaluateToScalar(e.left(),t,r),p=await this.evaluateToList(e.right().expr(),t,r);switch(f){case"ALL":return a(p.every(m=>o(y,m)));case"ANY":case"SOME":return a(p.some(m=>o(y,m)))}}let c=await this.evaluateToScalar(e.left(),t,r),l=await this.evaluateToScalar(e.right(),t,r);switch(s){case"=":case"IS":case"<>":case"!=":case"IS NOT":case"<":case"<=":case">":case">=":case"LIKE":return a(o(c,l));case"+":return Number(c)+Number(l);case"-":return Number(c)-Number(l);case"/":return Number(c)/Number(l);case"*":return Number(c)*Number(l);case"%":return Number(c)%Number(l);case"||":return String(c??"")+String(l??"");case"AND":return a(!!c&&!!l);case"OR":return a(!!c||!!l);case"->":case"->>":{if(c==null)return null;let f;return typeof l=="number"?f=Array.isArray(c)?c[l]:void 0:typeof l=="string"&&(typeof c=="object"&&!Array.isArray(c)?f=c[l]:Array.isArray(c)&&!isNaN(l)&&(f=c[Number(l)])),s==="->"?f:f==null?null:String(f)}case"#>":case"#>>":{if(c==null||!Array.isArray(l))return null;let f=c;for(let y of l){if(f==null)return null;if(Array.isArray(f)&&!isNaN(y))f=f[Number(y)];else if(typeof f=="object")f=f[y];else return null}return s==="#>"?f:f==null?null:String(f)}case"@>":{if(c==null||l==null||typeof c!="object"||typeof l!="object")return!1;let f=(y,p)=>typeof p!="object"||p==null?y===p:Array.isArray(p)?Array.isArray(y)?p.every((m,h)=>f(y[h],m)):!1:Object.keys(p).every(m=>f(y[m],p[m]));return f(c,l)}case"<@":{if(c==null||l==null||typeof c!="object"||typeof l!="object")return!1;let f=(y,p)=>typeof p!="object"||p==null?y===p:Array.isArray(p)?Array.isArray(y)?p.every((m,h)=>f(y[h],m)):!1:Object.keys(p).every(m=>f(y[m],p[m]));return f(l,c)}case"?":return c==null||typeof c!="object"?!1:Array.isArray(c)?c.includes(l):Object.prototype.hasOwnProperty.call(c,l);case"?|":return c==null||typeof c!="object"||!Array.isArray(l)?!1:Array.isArray(c)?l.some(f=>c.includes(f)):l.some(f=>Object.prototype.hasOwnProperty.call(c,f));case"?&":return c==null||typeof c!="object"||!Array.isArray(l)?!1:Array.isArray(c)?l.every(f=>c.includes(f)):l.every(f=>Object.prototype.hasOwnProperty.call(c,f));default:throw new Error(`ExprEngine: Unsupported binary operator ${s}`)}}async UNARY_EXPR(e,t,r={}){let s=e.operator().toUpperCase(),n=await this.evaluateToScalar(e.operand(),t,r);switch(s){case"NOT":return!n;case"-":return-n;default:throw new Error(`ExprEngine: Unsupported unary operator ${s}`)}}async CALL_EXPR(e,t,r={}){let s=e.name().toUpperCase();if(s==="UNNEST"||s==="GENERATE_SERIES"){let a=await Promise.all(e.arguments().map(o=>this.evaluate(o,t,r)));return function*(){if(s==="UNNEST")for(let o=0;o<a[0].length;o++)yield a.map(c=>c[o]??null);if(s==="GENERATE_SERIES")for(let o=a[0];o<=a[1];o+=a[2]??1)yield[o]}()}if(s==="GROUPING"||s==="GROUPING_ID"){let a=t[ni];if(!a)throw new Error(`${s}() called outside of grouping pipeline`);let o=e.arguments(),c=f=>{let y=a.exprIndex.get(f);if(y!==void 0)return a.groupingId>>y&1;if(!(f instanceof d.ColumnRef1))throw new Error(`${s}() argument must be a grouping column reference`);let p=f.qualifier()?.value()||"",m=f.value();return a.groupingColumnsMap.get(p)?.has(m)?0:1};if(s==="GROUPING_ID"&&o.length===a.exprIndex.size&&o.every((f,y)=>a.exprIndex.has(f)&&a.exprIndex.get(f)===y))return a.groupingId;let l=0;for(let f=0;f<o.length;f++){let y=c(o[f]);if(s==="GROUPING")return y;l=l<<1|y}return l}if(s==="VALUES"&&t.EXCLUDED&&typeof t.EXCLUDED=="object"){let o=e.arguments()[0].value();return t.EXCLUDED[o]}let n=await Promise.all(e.arguments().map(a=>this.evaluate(a,t,r)));switch(s){case"LOWER":return String(n[0]??"").toLowerCase();case"UPPER":return String(n[0]??"").toUpperCase();case"LENGTH":return n[0]==null?null:String(n[0]).length;case"ABS":return Math.abs(Number(n[0]));case"COALESCE":return n.reduce((a,o)=>a!==null?a:o,null);case"NULLIF":return V(n[0],n[1])?null:n[0];case"JSON_BUILD_ARRAY":case"JSON_ARRAY":return n;case"JSON_BUILD_OBJECT":case"JSON_OBJECT":{if(n.length%2!==0)throw new Error("JSON_BUILD_OBJECT requires an even number of arguments");let a=Object.create(null);for(let o=0;o<n.length;o+=2)a[n[o]]=n[o+1];return a}default:throw new Error(`ExprEngine: Unsupported function ${e.name()}`)}}async AGGR_CALL_EXPR(e,t,r={}){let s;if(e.overClause()){let p=t[Yn];if(!p)throw new Error(`${e} called outside of window processing pipeline (1)`);if(!e.winHash)throw new Error(`${e} called outside of window processing pipeline (2)`);if(!p[e.winHash])throw new Error(`${e} called outside of window processing pipeline (3)`);s=p[e.winHash]}else{let p=t[ni];if(!p)throw new Error("GROUPING() called outside of grouping pipeline");s=p}let{window:n,frameStart:a,frameEnd:o,offset:c=0}=s,l=e.name().toUpperCase(),f=e.arguments(),y=f[0]||null;switch(l){case"COUNT":{if(!y||y instanceof d.ColumnRef0)return o-a+1;let p=0;for(let m=a;m<=o;m++){let h=n[m],g=await this.evaluate(y,h,r);g!=null&&p++}return p}case"SUM":case"AVG":{if(!y)return null;let p=0,m=0;for(let h=a;h<=o;h++){let g=n[h],_=await this.evaluate(y,g,r);_!==null&&!Number.isNaN(Number(_))&&(p+=Number(_),m++)}return l==="SUM"?m===0?null:p:m===0?null:p/m}case"MIN":case"MAX":{if(!y)return null;let p=null;for(let m=a;m<=o;m++){let h=n[m],g=await this.evaluate(y,h,r);g!=null&&(p==null?p=g:(l==="MIN"&&g<p&&(p=g),l==="MAX"&&g>p&&(p=g)))}return p}case"JSON_AGG":case"JSON_ARRAYAGG":{if(!y)return[];let p=[];for(let m=a;m<=o;m++){let h=n[m];p.push(await this.evaluate(y,h,r))}return p}case"JSON_OBJECT_AGG":case"JSON_OBJECTAGG":{let p=f[0],m=f[1];if(!p||!m)return{};let h=Object.create(null);for(let g=a;g<=o;g++){let _=n[g],x=await this.evaluate(p,_,r),E=await this.evaluate(m,_,r);h[x]=E}return h}case"STRING_AGG":{let p=f[0],m=f[1]?await this.evaluate(f[1],t,r):",",h=[];for(let g=a;g<=o;g++){let _=await this.evaluate(p,n[g],r);_!=null&&h.push(String(_))}return h.join(m)}case"ARRAY_AGG":{let p=f[0],m=[];for(let h=a;h<=o;h++)m.push(await this.evaluate(p,n[h],r));return m}case"BIT_AND":{let p=f[0],m=-1;for(let h=a;h<=o;h++){let g=await this.evaluate(p,n[h],r);g!=null&&(m&=Number(g))}return m}case"BIT_OR":{let p=f[0],m=0;for(let h=a;h<=o;h++){let g=await this.evaluate(p,n[h],r);g!=null&&(m|=Number(g))}return m}case"BOOL_AND":{let p=f[0];for(let m=a;m<=o;m++)if(!await this.evaluate(p,n[m],r))return!1;return!0}case"BOOL_OR":{let p=f[0];for(let m=a;m<=o;m++)if(await this.evaluate(p,n[m],r))return!0;return!1}case"ROW_NUMBER":return c+1;case"RANK":case"PERCENT_RANK":{let p=s.orderKeysHash,m;for(let g=0;g<=c;g++){let _=n[g][Yn][e.winHash].orderKeysHash;if(p===_){m=g+1;break}}if(l==="RANK")return m;let h=n.length;return h===1?0:(m-1)/(h-1)}case"DENSE_RANK":{let p=new Set;for(let m=0;m<=c;m++){let h=n[m][Yn][e.winHash].orderKeysHash;p.has(h)||p.add(h)}return p.size}case"NTILE":{let p=Number(await this.evaluateToScalar(f[0],t,r));if(!Number.isInteger(p)||p<=0)throw new Error(`[${e}] NTILE(n) requires a positive integer`);let m=n.length,h=Math.floor(m/p),g=m%p,_=0;for(let x=1;x<=p;x++){let E=h+(x<=g?1:0);if(c<_+E)return x;_+=E}}case"CUME_DIST":{let p=n.length,m=s.orderKeysHash,h=c;for(let g=c+1;g<p&&n[g][Yn][e.winHash].orderKeysHash===m;g++)h=g;return(h+1)/p}case"LAG":{let p=f[0],m=Number(await this.evaluate(f[1]??{value:1},t,r)),h=f[2]?await this.evaluate(f[2],t,r):null,g=c-m;return g>=0?await this.evaluate(p,n[g],r):h}case"LEAD":{let p=f[0],m=Number(await this.evaluate(f[1]??{value:1},t,r)),h=f[2]?await this.evaluate(f[2],t,r):null,g=c+m;return g<n.length?await this.evaluate(p,n[g],r):h}case"FIRST_VALUE":{let p=f[0];return await this.evaluate(p,n[a],r)}case"LAST_VALUE":{let p=f[0];return await this.evaluate(p,n[o],r)}case"NTH_VALUE":{let p=f[0],m=Number(await this.evaluateToScalar(f[1],t,r));if(!Number.isInteger(m)||m<=0)throw new Error(`[${e}] NTH_VALUE(n) requires a positive integer`);let h=a+(m-1);return h>o?null:await this.evaluate(p,n[h],r)}default:throw new Error(`ExprEngine: Unsupported window function ${e.name()}`)}}async COLUMN_REF1(e,t){if(!e)return;let r=e.value(),s=e.qualifier()?.value()||"";if(s){let n=t[s];if(!n)throw new Error(`Table alias ${s} not found in the current context`);return n[r]}for(let n of Object.keys(t)){let a=t[n];if(r in a)return a[r]}throw new Error(`Column ${r} not found in the current context`)}async DEFAULT_LITERAL(e){return null}async STRING_LITERAL(e){return e.value()}async NUMBER_LITERAL(e){return Number(e.value())}async BOOL_LITERAL(e){return!!e.value()}async NULL_LITERAL(){return null}resolveScopedRefsInClause(e,t){return e.entries().map(r=>{let s;if(r.expr()instanceof d.NumberLiteral){if(!(s=t.entries()[parseInt(r.expr().value())-1]?.expr()))throw new Error(`[${e}] The reference by offset ${r.expr().value()} does not resolve to a select list entry`)}else r.expr()?.resolution?.()==="scope"&&(s=t.entries().find((n,a)=>n.alias()?.identifiesAs(r.expr()))?.expr());return s&&(r=r.constructor.fromJSON({...r.jsonfy(),expr:s.jsonfy()},{assert:!0}),e._adoptNodes(r)),r})}applySorting(e,t,r={}){e.sort((s,n)=>{for(let a=0;a<t.length;a++){let o=t[a].dir()==="DESC",c=o?-1:1,l=t[a].nullsSpec()||(r.options?.dialect==="mysql"?o?"LAST":"FIRST":o?"FIRST":"LAST"),f=s.keys[a],y=n.keys[a],p=f===null,m=y===null;if(!(p&&m)){if(p||m)if(l==="FIRST"){if(p)return-1;if(m)return 1}else{if(p)return 1;if(m)return-1}if(f<y)return-c;if(f>y)return c}}return 0})}};function Xi(u,e){let t=e.replace(/([.+^=!:${}()|\[\]\\/])/g,"\\$1").replace(/%/g,".*").replace(/_/g,".");try{return new RegExp(`^${t}$`,"i").test(u)}catch{return!1}}var Vn=class u extends ke{static analyseQuery(e){let t={hasSubqueryExprsInSelect:0,hasSubqueryExprsInWhere:0,hasSubqueryExprsInOrderBy:0,hasSubqueryExprs:0,hasWindowFunctions:!1,hasAggrFunctions:!1,hasGroupByClause:!1,hasOrderByClause:!1,hasOffsetClause:!1,hasLimitClause:!1,fromItemsBySchema:{},fromItemsByAlias:{},isSingleTable:!1};e.walkTree(n=>{if(n instanceof d.AggrCallExpr)n.overClause()?t.hasWindowFunctions=!0:t.hasAggrFunctions=!0;else if(n instanceof d.DerivedQuery){let a=new Set;r(n.expr(),t.fromItemsBySchema,a);let o=a.size||!(n.expr()instanceof d.SelectStmt)?2:n.isCorrelated()?1:0;if(o===0)return;t.hasSubqueryExprs<o&&(t.hasSubqueryExprs=o),t.hasSubqueryExprsInSelect<o&&e.selectList().containsNode(n)?t.hasSubqueryExprsInSelect=o:t.hasSubqueryExprsInWhere<o&&e.whereClause()?.containsNode(n)?t.hasSubqueryExprsInWhere=o:t.hasSubqueryExprsInOrderBy<o&&e.orderByClause()?.containsNode(n)&&(t.hasSubqueryExprsInOrderBy=o)}else if(n instanceof d.FromItem){let a=n.alias()?.value()||"";if(n.expr()instanceof d.DerivedQuery){let o=new Set;r(n.expr().expr(),t.fromItemsBySchema,o),t.fromItemsByAlias[a]=o}else if(n.expr()instanceof d.TableRef1&&n.expr().resolution()==="default"){let o=new Set;s(n.expr(),t.fromItemsBySchema,o),t.fromItemsByAlias[a]=o}else t.fromItemsByAlias[a]=new Set}else return n});function r(n,a,o=null){n.walkTree(c=>{if(c instanceof d.FromItem&&c.expr()instanceof d.TableRef1&&c.expr().resolution()==="default")s(c.expr(),a,o);else return c})}function s(n,a,o=null){let c=n.value(),l=n.qualifier().value();a[l]=[].concat(a[l]||[]).concat(c),o&&o.add(JSON.stringify([l,c]))}return e.groupByClause()&&(t.hasGroupByClause=!0),e.orderByClause()&&(t.hasOrderByClause=!0),e.offsetClause()&&(t.hasOffsetClause=!0),e.limitClause()&&(t.hasLimitClause=!0),t.isSingleTable=!e.joinClauses()?.length&&!(t.hasAggrFunctions||t.hasGroupByClause)&&!t.hasWindowFunctions&&t.hasSubqueryExprs!==2&&(n=>n.length===1&&!(n[0].expr()instanceof d.DerivedQuery))(e.fromClause().entries()),t}static intersectQueries(e,t,r){let s=["select_list","where_clause","order_by_clause","offset_clause","limit_clause"],n=new Set(e._keys().filter(E=>!s.includes(E))),a=new Set(t._keys().filter(E=>!s.includes(E)));if(n.size!==a.size)return!1;for(let E of new Set([...n,...a]))if(!n.has(E)||!a.has(E)||!ce(e._get(E),t._get(E)))return!1;let o=[];if(r.projection==="="){let E=e.selectList().entries(),S=t.selectList().entries();for(let N of S){let A=E.findIndex(v=>ce(v.expr(),N.expr()));if(A===-1)return!1;o.push(A)}}let c=[],l=e.whereClause()?.expr(),f=t.whereClause()?.expr();if(l||f){if(r.whereClause===">="){let E=ce(l,f,"AND~");if(E===!1)return!1;c.push(...E)}else if(!ce(l,f))return!1}let y=e.orderByClause()?.entries()||[],p=t.orderByClause()?.entries()||[];if(r.ordinality==="="&&(y.length!==p.length||!y.every((E,S)=>ce(E.expr(),p[S].expr()))||r.orderDirections==="="&&!y.every((E,S)=>ce(E.dir(),p[S].dir()))))return!1;let m=0,h=e.offsetClause()?.expr(),g=t.offsetClause()?.expr();if(r.offsetClause==="="){if((h||g)&&!ce(h,g))return}else if((h||g)&&(!(g instanceof d.NumberLiteral)||(m=g.value()-(h?.value()||0))<0))return!1;let _=e.limitClause()?.expr(),x=t.limitClause()?.expr();if(r.limitClause==="="){if((_||x)&&!ce(_,x))return}else if((_||x)&&(!(x instanceof d.NumberLiteral)||(_?.value()||1/0)-x.value()<0))return!1;return{selectMapping:o,filters:c,offset:m}}#e;#t;#r=0;#n;#i;#s;#a;#o;#f;#p={ssr:!1,requeryMode:"selective",requeryWrappedSelectivity:!1,diffing:"key"};#c={projection:"~",whereClause:">=",ordinality:"~",orderDirections:"~",offsetClause:">=",limitClause:"<="};#g;#h;#E=[];#m=new Map;#u;#_={selectMapping:[],filters:[],offset:0};#S=0;#l=new Map;#N=!1;#x=[];#y;get driver(){return this.#e}get analysis(){return this.#f}get strategy(){return this.#p}get subwindowingRules(){return this.#c}get status(){return this.#r}get parentWindow(){return this.#u}get inheritanceDepth(){return this.#S}constructor(e,t,r={}){if(super(),this.#e=e,!(t instanceof d.BasicSelectStmt))throw new Error("Only SELECT statements are supported in live mode");if(!t.fromClause())throw new Error("Query has no FROM clause");if(!Array.isArray(t.originSchemas()))throw new Error("Expected a pre-resolved query object with originSchemas() returning an array");this.#a=t,this.#o=this.#a.jsonfy({resultSchemas:!1,originSchemas:!1}),this.#t=r,this.#y={dialect:this.#e.dialect,assert:!0};let s=this;this.#i=new It(async function*(o,c,l){let f=o.expr();if(!(f instanceof d.SelectStmt))throw new Error(`Unexpected expression: ${f}`);let y=Object.create(null);for(let p of f.selectList()){let{alias:m,value:h}=await s.#i.evaluate(p,{},l);y[m]=h}yield y},this.#t),this.#a.orderByClause()&&(this.#x=this.#i.resolveScopedRefsInClause(this.#a.orderByClause(),this.#a.selectList()));let n=this.constructor.analyseQuery(t);this.#f=n;let a=this.#p;(n.hasAggrFunctions||n.hasGroupByClause)&&(a.ssr=!0,a.requeryMode="wholistic",this.#t.forceDiffing?a.diffing="deep":a.diffing=!1),n.hasWindowFunctions&&(a.ssr=!0,a.requeryMode==="selective"&&(a.requeryWrappedSelectivity=!0),a.diffing!==!1&&(a.diffing="deep")),(n.hasSubqueryExprsInSelect||n.hasSubqueryExprsInOrderBy)&&(a.ssr=!0,a.diffing!==!1&&n.hasSubqueryExprsInSelect&&(a.diffing="deep")),n.hasOffsetClause&&!this.#t.noOffsetRevalidate&&(a.requeryMode="wholistic"),(n.hasOffsetClause||n.hasLimitClause&&n.hasOrderByClause)&&a.requeryMode==="selective"&&(a.requeryWrappedSelectivity=!0),a.ssr?(this.#c.projection="=",this.#c.whereClause="=",this.#c.ordinality="="):n.hasSubqueryExprsInWhere&&(this.#c.whereClause="="),(n.hasOffsetClause||n.hasLimitClause&&n.hasOrderByClause)&&(this.#c.whereClause="=",this.#c.ordinality="=",this.#c.orderDirections="=")}async inherit(e){if(e===null){this.#_={selectMapping:[],filters:[],offset:0},this.#S=0,this.#u&&(this.#u=null,await this.stop());return}if(!(e instanceof u))throw new Error("Parent window must be instance of QueryWindow or null");if(!V(this.#c,e.#c))return!1;let t=this.constructor.intersectQueries(e.#a,this.#a,this.#c);return t===!1?!1:(this.#_=t,this.#S=e.inheritanceDepth+1,this.#u=e,await this.start(),!0)}async start(){await this.stop(),this.#u?await this.#M():await this.#L(),this.#r=1}async stop(){this.#n?.(),this.#n=null,this.#r=0}async#L(){let e=this.#f,t=this.#p,r=c=>{let l=c.value(),f=c._get("delim");return{value:f?l:l.toLowerCase(),delim:f}};for(let[c,l]of Object.entries(e.fromItemsByAlias)){let f=this.#a.originSchemas().find(_=>_ instanceof d.JSONSchema?c==="":_.identifiesAs(c)),y,p,m=!1;f instanceof d.JSONSchema?(y=f.entries().map(_=>r(_.name())),(l.size>1||!(p=f.entries().filter(_=>_.pkConstraint()).map(r)).length)&&(p=structuredClone(y),m=!0)):(y=f.columns().map(_=>r(_.name())),(l.size>1||!(p=f.pkConstraint(!0)?.columns().map(r)))&&(p=structuredClone(y),m=!0));let h=l.size===1?(([_,x])=>({schema:_,name:x}))(JSON.parse([...l][0])):null;this.#m.set(c,{relation:h,relationHashes:l,columns:y.map(_=>_.value),keyColumns:p.map(_=>_.value),usingAllColumnsForKeyColumns:m,$columns:y,$keyColumns:p});let g=c!==c.toLowerCase()||/^\d/.test(c)||!/^(\*|[\w]+)$/.test(c);this.#E.push({value:c,delim:g&&'"'||""})}let s=this.#x.map(c=>c.jsonfy()),n=this.#E.reduce((c,l)=>{let f=this.#m.get(l.value),y=_=>{let x={nodeName:"STRING_LITERAL",..._},E={nodeName:"COLUMN_REF1",..._,qualifier:{nodeName:"TABLE_REF1",...l}};return e.hasAggrFunctions&&(E={nodeName:"CALL_EXPR",name:this.#e.dialect==="mysql"?"JSON_STRINGAGG":"JSON_AGG",arguments:[E]}),[x,E]},p=this.#e.dialect==="mysql"?"JSON_OBJECT":"JSON_BUILD_OBJECT",m=(t.ssr?f.$keyColumns:f.$columns).reduce((_,x)=>[..._,...y(x)],[]),h={nodeName:"CALL_EXPR",name:p,arguments:m};if(t.ssr){let _={nodeName:"STRING_LITERAL",...l};return c.concat(_,h)}let g={nodeName:"SELECT_ITEM_ALIAS",...l};return c.concat({nodeName:"SELECT_ITEM",alias:g,expr:h})},[]);if(t.ssr){let c=this.#e.dialect==="mysql"?"JSON_OBJECT":"JSON_BUILD_OBJECT",l=this.#o.select_list.entries.reduce((p,m)=>p.concat({nodeName:"STRING_LITERAL",value:m.alias.value},m.expr),[]),f={nodeName:"CALL_EXPR",name:c,arguments:l},y={nodeName:"CALL_EXPR",name:c,arguments:n};if(n=[{nodeName:"SELECT_ITEM",alias:{nodeName:"SELECT_ITEM_ALIAS",value:"ssr"},expr:f}],t.diffing&&(n.push({nodeName:"SELECT_ITEM",alias:{nodeName:"SELECT_ITEM_ALIAS",value:"key"},expr:y}),e.hasOrderByClause)){let m={nodeName:"CALL_EXPR",name:this.#e.dialect==="mysql"?"JSON_ARRAY":"JSON_BUILD_ARRAY",entries:s.map(h=>h.expr)};n.push({nodeName:"SELECT_ITEM",alias:{nodeName:"SELECT_ITEM_ALIAS",value:"ord"},expr:m})}}let a={entries:n},o=s.length?{entries:s}:void 0;this.#h={...this.#o,select_list:a,order_by_clause:o},this.#g=this.#a.constructor.fromJSON(this.#h,this.#y),this.#n=this.#e.subscribe(e.fromItemsBySchema,c=>{this.#J(c).catch(l=>this.emit("error",l))})}async#M(){let e=this.#u.on("rawresult",async r=>{r=await this.#v(r),await this.#w(r,!0)}),t=this.#u.on("rawdiff",async r=>{let s=new Set;for(let n of r){if(n.type==="delete"){if(!this.#l.has(n.oldHash))continue}else{let a=await this.#b(n.logicalRecord);this.#l.has(n.oldHash)?n=a?{...n}:{...n,type:"delete"}:a&&(n={...n,type:"insert"})}s.add(n)}await this.#O(s)});this.#n=()=>{e(),t()}}async#v(e){let t=this.#f,r=this.#p,s=[];for(let[n,a]of e.entries())await this.#b(a)&&s.push([n,a]);if(r.diffing&&t.hasOrderByClause&&(this.#c.ordinality==="~"||this.#c.orderDirections==="~")&&(s=await this.#D(s)),t.hasOffsetClause||t.hasLimitClause){let n=await this.#i.evaluate(this.#a.limitClause().expr(),{},this.#s);s=s.slice(this.#_.offset,n)}return new Map(s)}async#b(e){for(let t of this.#_.filters)if(!await this.#i.evaluate(t,e,this.#s))return!1;return!0}async currentRendering(){let e=await this.currentRecords(),t=[],r=[];for(let[s,n]of e.entries()){let a=await this.#C(n);t.push(a),r.push(s)}return{rows:t,hashes:r}}async currentRecords(){if(!this.#N){let e;this.#u?(e=await this.#u.currentRecords(),e=await this.#v(e)):e=await this.#A(),await this.#w(e),this.#N=!0}return this.#l}async#A(e=null){let t=this.#p,r=this.#g;if(e&&t.requeryWrappedSelectivity){let a=c=>({...c,expr:{...c.expr,qualifier:void 0}}),o={nodeName:"BASIC_SELECT_STMT",select_list:{entries:this.#h.select_list.entries.map(a)},from_clause:{entries:[{nodeName:"FROM_ITEM",expr:{nodeName:"DERIVED_QUERY",expr:this.#h}}]},where_clause:{expr:e}};r=this.#a.constructor.fromJSON(o,this.#y)}else if(e){let a=this.#h,o=a.where_clause?.expr?{nodeName:"BINARY_EXPR",left:e,operator:"AND",right:a.where_clause.expr}:e;a={...a,where_clause:{nodeName:"WHERE_CLAUSE",expr:o}},r=this.#a.constructor.fromJSON(a,this.#y)}let s=await this.#e.query(r),n=new Map;for(let[a,o]of s.rows.entries()){let c=t.diffing?this.#j(o):`$${a}`;n.set(c,o)}return n}#P(e,t,r){return this.#p.ssr?e.key[t][r]:e[t][r]}#j(e){let t=[...this.#m.entries()].map(([r,s])=>{let n=s.keyColumns.map(a=>this.#P(e,r,a));return n.every(a=>a===null)?null:n});return this.#d(t)}#d(e){return JSON.stringify(e)}#R(e){return JSON.parse(e)}#T(e,t){this.#l.set(e,t)}#U(e){this.#l.delete(e)}#B(e){this.#l=new Map([...this.#l.entries()].map(([t,r])=>(e.has(t)&&(t=e.get(t)),[t,r])))}async#C(e){let t=Object.create(null);if(this.#p.ssr){if(!this.#_.filters.length)return e.ssr;let r=Object.values(e.ssr);for(let[s,n]of this.#a.selectList().entries().entries()){let a=r[s],o=n.alias()?.value()||"?column?";t[o]=a}return t}for(let r of this.#a.selectList()){let{alias:s,value:n}=await this.#i.evaluate(r,e,this.#s);t[s]=n}return t}#$(e){let t=new Map,r=new Map,s=new Set;for(let n of e){if(!(n.type==="insert"||n.type==="update"||n.type==="delete"))continue;let a=JSON.stringify([n.relation.schema,n.relation.name]),o=[...this.#m.entries()].filter(([,_])=>_.relationHashes.has(a));if(!o.length||o.find(([,_])=>_.relationHashes.size>1))return!0;let c=o.map(([_])=>_);for(let _ of c)s.add(_);let l=n.relation.keyColumns,f=n.key?Object.values(n.key):l.map(_=>n.new[_]),y=n.new?l.map(_=>n.new[_]):f.slice(0),p={...n,keyColumns:l,oldKeys:f,newKeys:y,relationHash:a,affectedAliases:c},m=this.#d([n.relation.schema,n.relation.name,p.oldKeys]),h,g;if((g=t.get(m))||r.has(m)&&(g=t.get(m=r.get(m)))){if(g.type==="insert"&&p.type==="delete")continue;if(g.type==="delete"&&p.type==="insert"){let _={...p,type:"update",old:g.old};t.set(m,_);continue}if(g.type==="insert"&&p.type==="update"){let _={...p,oldKeys:g.oldKeys,old:null,type:"insert"};t.delete(m),t.set(m,_),(h=this.#d([n.relation.schema,n.relation.name,p.newKeys]))!==m&&r.set(h,m);continue}if(g.type==="update"&&p.type==="update"){let _={...p,oldKeys:g.oldKeys,old:g.old};t.delete(m),t.set(m,_),(h=this.#d([n.relation.schema,n.relation.name,p.newKeys]))!==m&&r.set(h,m);continue}if(g.type==="update"&&p.type==="delete"){t.delete(m),t.set(m,p);continue}}else p.type==="update"&&(h=this.#d([n.relation.schema,n.relation.name,p.newKeys]))!==m&&r.set(h,m),t.set(m,p)}return[t,r,s]}async#J(e){let t=this.#f;if(this.#p.requeryMode==="wholistic")return await this.#I();let s=this.#$(e);if(s===!0)return await this.#I();if(t.isSingleTable){let[c]=s;return await this.#F(c)}let[n,a,o]=s;return await this.#G(n,a,o)}async#F(e){let t=new Set;for(let r of e.values()){if(r.type==="insert"){let s=this.#d([r.newKeys]),n={[r.affectedAliases[0]]:r.new};if(!(!this.#a.whereClause()||await this.#i.evaluate(this.#a.whereClause().expr(),n,this.#s)))continue;let o={type:"insert",newHash:s,logicalRecord:n};t.add(o)}if(r.type==="update"){let s=this.#d([r.oldKeys]),n=this.#d([r.newKeys]),a={[r.affectedAliases[0]]:r.new},o,c=!this.#a.whereClause()||await this.#i.evaluate(this.#a.whereClause().expr(),a,this.#s);this.#l.has(s)?o=c?{type:"update",oldHash:s,newHash:n,logicalRecord:a}:{type:"delete",oldHash:s}:c&&(o={type:"insert",newHash:n,logicalRecord:a}),o&&t.add(o)}if(r.type==="delete"){let s=this.#d([r.oldKeys]);if(this.#l.has(s)){let n={type:"delete",oldHash:s,logicalRecord:this.#l.get(s)};t.add(n)}}}return await this.#O(t)}async#G(e,t,r){let s=this.#p,n=(y,p,m,h=0)=>{if(p.length>1){let N=p.map((A,v)=>n(y,[A],[m[v]],h));return N.reduce((A,v)=>d.BinaryExpr.fromJSON({nodeName:"BINARY_EXPR",left:A,operator:"AND",right:v},this.#y),N.shift())}let g=s.requeryWrappedSelectivity?{nodeName:"BINARY_EXPR",left:{nodeName:"COLUMN_REF1",value:"key"},operator:"->",right:{nodeName:"BINARY_EXPR",left:{nodeName:"COLUMN_REF1",value:y},operator:"->>",right:{nodeName:"COLUMN_REF1",value:p[0]}}}:{nodeName:"COLUMN_REF1",value:p[0],qualifier:{nodeName:"TABLE_REF1",value:y}},_={nodeName:"NULL_LITERAL",value:"NULL"},x=d.BinaryExpr.fromJSON({nodeName:"BINARY_EXPR",left:g,operator:"IS",right:_},this.#y);if(h===0)return x;let E={nodeName:typeof m[0]=="number"?"NUMBER_LITERAL":"STRING_LITERAL",value:m[0]},S=d.BinaryExpr.fromJSON({nodeName:"BINARY_EXPR",left:g,operator:"=",right:E},this.#y);if(h===2){let N={nodeName:"BINARY_EXPR",left:x,operator:"OR",right:S};return d.RowConstructor.fromJSON({nodeName:"ROW_CONSTRUCTOR",entries:[N]},this.#y)}return S},a=new Map,o=[];for(let y of e.values()){let p=[],m=y.affectedAliases;y.type==="insert"&&(p=[m.map(g=>n(g,y.keyColumns,y.oldKeys,0)),m.map(g=>n(g,y.keyColumns,y.newKeys,2))]),y.type==="update"&&(p=[m.map(g=>n(g,y.keyColumns,y.oldKeys,2)),m.map(g=>n(g,y.keyColumns,y.newKeys,2))]),y.type==="delete"&&(p=[m.map(g=>n(g,y.keyColumns,y.oldKeys,2)),m.map(g=>n(g,y.keyColumns,y.newKeys,0))]);e:for(let[g,_]of this.#l.entries()){for(let x of p[0])if(!await this.#i.evaluate(x,_,this.#s))continue e;a.set(g,_)}let h=p[1].reduce((g,_)=>d.BinaryExpr.fromJSON({nodeName:"BINARY_EXPR",left:g,operator:"AND",right:_}),p[1].shift());o.push(h)}let c=o[0];if(o.length>1){let y=o.reduce((p,m)=>d.BinaryExpr.fromJSON({nodeName:"BINARY_EXPR",left:p,operator:"OR",right:m}),o.shift());s.requeryWrappedSelectivity?c=y:c=d.RowConstructor.fromJSON({nodeName:"ROW_CONSTRUCTOR",entries:[y]})}let l=(y,p)=>{let m=this.#R(y),h;for(let[g,_]of this.#m.entries()){if(r.has(g)){let x=_.relation,E,S;m[h]===null?p=p.filter(([N])=>{if(N[h]!==null&&(E=JSON.parse([x.schema,x.name,N[h]]))&&((S=e.get(E))||t.has(E)&&(S=e.get(E=t.get(E)))))return!0}):(E=JSON.parse([x.schema,x.name,m[h]]))&&(S=e.get(E))&&(p=p.filter(([N])=>S.type==="delete"?N[h]===null:V(S.newKeys,N[h])))}p=p.filter(([x])=>V(m[h],x[h])),h++}return p.length?[this.#d(p[0][0]),p[0][1]]:[]},f=await this.#A(c);return await this.#k(a,f,l)}async#I(){let e=await this.#A();return this.#p.diffing?await this.#k(this.#l,e):await this.#w(e,!0)}async#k(e,t,r=null){let s=new Set,n=()=>[...t.entries()].map(([o,c])=>[this.#R(o),c]),a=n();for(let[o,c]of e.entries()){if(t.has(o)){let f=t.get(o);t.delete(o),a=n();let y={type:"update",oldHash:o,newHash:o,logicalRecord:f};s.add(y);continue}if(r){let[f,y]=r(o,a);if(f){t.delete(f),a=n();let p={type:"update",oldHash:o,newHash:y,logicalRecord:y};s.add(p);continue}}let l={type:"delete",oldHash:o,logicalRecord:c};s.add(l)}for(let[o,c]of t.entries()){let l={type:"insert",newHash:o,logicalRecord:c};s.add(l)}return await this.#O(s)}async#O(e){if(!e?.size)return!1;let t=this.#f,r=new Map,s=new Map,n=new Map,a=new Set,o=t.hasLimitClause?await this.#i.evaluate(this.#a.limitClause().expr(),{},this.#s):0,c=async f=>{let y=await this.#C(f.logicalRecord);return{type:f.type,...f.type==="update"?{oldHash:f.oldHash,old:f.old}:{},newHash:f.newHash,new:y}};for(let f of e){if(f.type==="delete"){let p={type:f.type,oldHash:f.oldHash};this.#U(f.oldHash),r.set(f.oldHash,f),s.set(f.oldHash,p);continue}if(f.type==="update"&&f.newHash!==f.oldHash)n.set(f.oldHash,f.newHash);else if(f.type==="insert"&&o&&!t.hasOrderByClause&&this.#l.size===o){a.add(f);continue}let y=f.oldHash||f.newHash;this.#T(y,f.logicalRecord),r.set(y,f),s.set(y,await c(f))}n.size&&this.#B(n);let l=[];if(t.hasOrderByClause){let[f,y,p]=await this.#D(this.#l,!0);await this.#w(f);let m=[];if(o&&this.#l.size>=o){let _=y.slice(o);for(let[x,E]of _)this.#l.delete(x),m.push(x),r.get(x)?.type==="insert"?(r.delete(x),s.delete(x)):(r.set(x,{type:"delete",oldHash:x,old:E}),s.set(x,{type:"delete",oldHash:x}))}let h=p.map(_=>_[0]),g=y.map(_=>_[0]);for(let[_,x]of h.entries()){if(m.includes(x))continue;let E=g.indexOf(x),S=h[E];m.includes(S)&&(E=g.indexOf(S),S=h[E]),E!==_&&l.push([x,S])}}else for(let f of a){if(this.#l.size===o)break;this.#T(f.newHash,f.logicalRecord),r.set(f.newHash,f),s.set(f.newHash,await c(f))}return r.size&&this.emit("rawdiff",[...r.values()]),s.size&&this.emit("diff",[...s.values()]),l.length&&this.emit("swap",l),!0}async#w(e,t=!1){this.#l.clear();for(let[r,s]of e.entries())this.#T(r,s);t&&(this.emit("rawresult",new Map(this.#l)),this.emit("result",await this.currentRendering()))}async#D(e,t=!1){let r=Array.isArray(e)?e:[...e.entries()],s;this.#p.ssr?s=s.map(o=>({entry:o,keys:o[1].ord})):s=await Promise.all(r.map(async o=>{let c=await Promise.all(this.#x.map(l=>this.#i.evaluate(l.expr(),o[1],this.#s)));return{entry:o,keys:c}})),this.#i.applySorting(s,this.#x,this.#s);let n=s.map(o=>o.entry),a=Array.isArray(e)?n:new Map(n);return t?[a,n,r]:a}};var Qn=class{#e=new Set;#t;constructor(e){if(!(e instanceof Ot))throw new TypeError("driver must be an instance of AbstractClient");this.#t=e}async query(...e){let[t,{callback:r,signal:s,...n}]=Bn(...e);if(!(t instanceof d.BasicSelectStmt))throw new Error("Only SELECT statements are supported in live mode");if(!t.fromClause())throw new Error("Query has no FROM clause");let a=await this.createWindow(t,n),o=await a.currentRendering(),c=new Kn(o,()=>f.forEach(y=>y()),s),l=r||((y,p)=>c._apply(y,p)),f=["result","diff","swap"].map(y=>a.on(y,p=>l(y,p)));return c}async createWindow(e,t){let r=new Vn(this.#t,e,t),s=[...this.#e].sort((a,o)=>a.inheritanceDepth>o.inheritanceDepth?1:-1),n=[];for(let a of s){if(await r.inherit(a))break;n.unshift(a)}if(!r.parentWindow){await r.start();for(let a of n)if(await a.inherit(r))break}return this.#e.add(r),r.onClose(()=>{this.#e.delete(r),r.disconnect()}),r}};var ot=class extends Error{#e;get existing(){return this.#e}constructor(e,t){super(e),this.#e=t}};var zn=class extends ke{#e;#t;#r;#n;#i;#s=new Map;constructor({dialect:e="postgres",defaultSchemaName:t="public",defaultPrimaryKey:r="id",defaultAutoIncr:s=!0,...n}={}){super(),this.#e=e,this.#t=t,this.#r=r,this.#n=s,this.#i=n}async createSchema(e,{ifNotExists:t=!1}={}){if(await this.#s.has(e)){if(t)return!1;throw new Error(`Schema ${e} already exists`)}return await this.#s.set(e,{schemas:new d.SchemaSchema({entries:[]}),storage:new Map,counters:new Map}),!0}async dropSchema(e,{ifExists:t=!1,cascade:r=!1}={}){let s=await this.#s.get(e);if(!s){if(t)return!1;throw new Error(`Schema ${e} does not exist`)}if(s.schemas.length&&!r)throw new Error(`Schema ${e} is not empty.`);return await this.#s.delete(e),!0}async schemaNames(){return[...await this.#s.keys()]}async getSchema(e){let t=await this.#s.get(e);if(!t)throw new Error(`Schema ${e} does not exist`);return t}async createTable(e,t=this.#t,{ifNotExists:r=!1,options:s={}}={}){let n=s.dialect||this.#e;if(typeof e=="string"){if(e={name:{value:e},entries:[]},this.#r){let o={nodeName:"COLUMN_SCHEMA",name:{value:this.#r},data_type:{value:"INT"},entries:[{nodeName:"COLUMN_PK_CONSTRAINT",value:"KEY"}]};this.#n&&(n==="mysql"?o.entries.push({nodeName:"MY_COLUMN_AUTO_INCREMENT_MODIFIER",value:"AUTO_INCREMENT"}):o.entries.push({nodeName:"COLUMN_IDENTITY_CONSTRAINT",by_default_kw:!0,as_identity_kw:!0})),e.entries.push(o)}e=d.TableSchema.fromJSON(e,{dialect:n})}else{if(!(e instanceof d.TableSchema))throw new Error("tableSchema must be an instance of TableSchema");e=e.clone()}e.name().qualifier()&&(t=e.name().qualifier().value());let a=await this.getSchema(t);if(await a.schemas.has(e.name().value())){if(r)return!1;throw new Error(`Table ${e.name()} already exists`)}return await a.schemas.set(e.name().value(),e),await a.storage.set(e.name().value(),new Map),!0}async dropTable(e,t=this.#t,{ifExists:r=!1,cascade:s=!1}={}){let n=await this.getSchema(t);if(!n)return;let a=await n.storage.get(e);if(!a){if(r)return!1;throw new Error(`Table ${e} does not exist`)}if(a.length&&!s)throw new Error(`Table ${t} is not empty.`);return await n.counters.delete(e),await n.schemas.delete(e),await n.storage.delete(e),!0}async tableNames(e=this.#t){return[...await(await this.getSchema(e)).storage.keys()]}async tableStorage(e,t=this.#t){let r=await this.getSchema(t);if(!r)return;let s=await r.storage.get(e);if(!s)throw new Error(`Table ${e} does not exist`);return s}async tableSchema(e,t=this.#t){let s=await(await this.getSchema(t)).schemas.get(e);if(!s)throw new Error(`Table ${e} does not exist`);return s}async tableKeyColumns(e,t=this.#t){let r=await this.tableSchema(e,t),s;return(s=r.pkConstraint(!0)?.columns())?.length?s.map(n=>r.get(n)):[]}async#a(e,t,r){let s=await this.getSchema(e),n=`${t}:${r}`;await s.counters.has(n)||await s.counters.set(n,1);let a=await s.counters.get(n);return await s.counters.set(n,a+1),a}async#o(e,t,r,s=!1){let n;if((n=await this.tableKeyColumns(t,e)).length){let o=n.some(f=>f.identityConstraint()||f.autoIncrementConstraint()),c=[];for(let f of n){let y=f.name().value(),p=r[y];if(p==null)if(s&&o)p=await this.#a(e,t,y),r[y]=p;else throw new Error(`Missing value for primary key field ${f.name()} in table "${t}"`);c.push(p)}return[JSON.stringify(c),n]}return[JSON.stringify(Object.values(r)),n]}async insert(e,t,r=this.#t,{txId:s}={}){let n=await this.tableStorage(e,r),a={...t},[o,c]=await this.#o(r,e,a,!0),l=o,f=await n.get(o);if(f){if(c.length)throw new ot(`Duplicate key for "${e}": ${l}`,f);let p=0;for(;await n.get(l=`${o}${p}`);)p++}await n.set(l,a);let y=c.map(p=>p.name().value());return this.emit("changefeed",{type:"insert",relation:{schema:r,name:e,keyColumns:y},new:{...a},txId:s}),s?Object.defineProperty({...a},"XMAX",{value:0}):a}async update(e,t,r=this.#t,{txId:s}={}){let n=await this.tableStorage(e,r),a={...t},[o,c]=await this.#o(r,e,a,!1),l=await n.get(o);if(!l)throw new Error(`Record not found in "${e}" for key ${o}`);await n.set(o,a);let f=c.map(p=>p.name().value()),y=Object.fromEntries(f.map(p=>[p,l[p]]));return this.emit("changefeed",{type:"update",relation:{schema:r,name:e,keyColumns:f},key:y,old:l,new:{...a},txId:s}),s?Object.defineProperty({...a},"XMAX",{value:s}):a}async delete(e,t,r=this.#t,{txId:s}={}){let n=await this.tableStorage(e,r),[a,o]=await this.#o(r,e,{...t},!1),c=await n.get(a);if(!c)throw new Error(`Record not found in "${e}" for key ${a}`);await n.delete(a);let l=o.map(y=>y.name().value()),f=Object.fromEntries(l.map(y=>[y,c[y]]));return this.emit("changefeed",{type:"delete",relation:{schema:r,name:e,keyColumns:l},key:f,old:c,txId:s}),s?Object.defineProperty({...c},"XMAX",{value:s}):c}async fetch(e,t,r=this.#t){let s=await this.tableStorage(e,r),n;if(typeof t=="string")n=t;else if(typeof t=="object"&&t!==null)[n]=await this.#o(r,e,{...t},!1);else throw new Error(`Invalid keyOrRecord type for fetch(): ${typeof t}`);let a=await s.get(n);return a?{...a}:void 0}async*getCursor(e,t=this.#t){let r=await this.tableStorage(e,t);for await(let s of r.values())yield{...s}}};var Xn=Symbol.for("grouping_meta"),Da=Symbol.for("window_meta"),Zn=class extends ke{#e;#t;#r;constructor(e,{dialect:t="postgres",...r}={}){super(),this.#e=e,this.#r={dialect:t,...r};let s=this;this.#t=new It(async function*(n,a,o){let c,l;if(n.isCorrelated()||!(l=o.cteRegistry?.get(c=n.stringify()))){let f={...o,lateralCtx:{...o.lateralCtx||{},...a},depth:o.depth+1};if(l=await s.#n(n.expr(),f),o.cteRegistry&&c){let y=l,p=[];o.cteRegistry.set(c,p),l=async function*(){for await(let m of y)p.push(m),yield m}()}}yield*l},this.#r)}async query(e,t={}){let r=[],s=`$tx${(0|Math.random()*9e6).toString(36)}`,n={options:{...this.#r,...t},txId:s,lateralCtx:null,cteRegistry:new Map,depth:0},a=this.#e.on("changefeed",c=>{c.txId===s&&r.push(c)}),o=await this.#n(e,n);if(a(),r.length&&this.emit("changefeed",r),o&&typeof o?.[Symbol.asyncIterator]=="function"&&t.bufferResultRows!==!1){let c=[];for await(let l of o)c.push(l);return c}return o}async#n(e,t){let r;for(let s of e instanceof d.Script&&e||[e])switch(s.NODE_NAME){case"CREATE_SCHEMA_STMT":r=await this.#i(s,t);break;case"ALTER_SCHEMA_STMT":r=await this.#s(s,t);break;case"DROP_SCHEMA_STMT":r=await this.#a(s,t);break;case"CREATE_TABLE_STMT":r=await this.#o(s,t);break;case"ALTER_TABLE_STMT":r=await this.#f(s,t);break;case"DROP_TABLE_STMT":r=await this.#p(s,t);break;case"CTE":r=await this.#c(s,t);break;case"INSERT_STMT":r=await this.#g(s,t);break;case"UPDATE_STMT":r=await this.#h(s,t);break;case"DELETE_STMT":r=await this.#E(s,t);break;case"TABLE_STMT":r=await this.#_(s,t);break;case"BASIC_SELECT_STMT":case"COMPLETE_SELECT_STMT":r=await this.#S(s,t);break;case"COMPOSITE_SELECT_STMT":r=await this.#N(s,t);break;default:throw new Error(`Unknown statement type: ${s.NODE_NAME}`)}return r}async#i(e,t){let r=e.name().value();if(!r)throw new Error("Cannot create a schema with an empty name");let s={...t,ifNotExists:!!e.ifNotExists()},n=await this.#e.createSchema(r,s);if(n&&e.pgEntries()?.length){if(ifNotExists)throw new Error("CREATE SCHEMA ... IF NOT EXISTS ... with entries is not supported");let a={...s,schemaName:r};for(let o of e.pgEntries())await this.#n(o,a)}return n}async#s(e,t){throw new Error("ALTER SCHEMA is not supported yet in the in-memory StorageEngine")}async#a(e,t){let r=e.myName()?[e.myName().value()]:e.pgNames().map(a=>a.value()),s={...t,ifExists:!!e.ifExists(),cascade:e.pgCascadeRule()==="CASCADE"},n;for(let a of r)n=await this.#e.dropSchema(a,s);return n}async#o(e,t){if(e.temporaryKW())throw new Error("TEMPORARY tables are not supported yet in the in-memory StorageEngine");let r=e.argument();if(t.schemaName&&r.name().qualifier()&&!r.name().qualifier().identifiesAs(t.schemaName))throw new Error(`Cannot create table ${r.name().toString()} in schema ${t.schemaName} as it is qualified to schema ${r.name().qualifier().toString()}`);let s={...t,ifNotExists:!!e.ifNotExists()};return await this.#e.createTable(r,t.schemaName,s)}async#f(e,t){throw new Error("ALTER TABLE is not supported yet in the in-memory StorageEngine")}async#p(e,t){if(e.myTemporaryKW())throw new Error("MySQL TEMPORARY tables are not supported yet in the in-memory StorageEngine");let r=e.names().map(a=>[a.value(),a.qualifier?.()?.value()]),s={...t,ifExists:!!e.ifExists(),cascade:e.cascadeRule()==="CASCADE"},n;for(let[a,o]of r)n=await this.#e.dropTable(a,o,s);return n}async#c(e,t){let r=new Map(t.cteRegistry||[]);t={...t,cteRegistry:r};for(let s of e.declarations()){let n=s.alias().value();if(r?.has(n))throw new Error(`CTE name ${n} already exists in the current context`);let a=s.expr(),o=await this.#n(a,t);r.set(n,o)}return await this.#n(e.body(),t)}async#g(e,t){let r={};if(!Array.isArray(r.originSchemas=e.originSchemas()))throw new Error("Expected a pre-resolved query object with originSchemas() returning an array");let s=e.tableRef().qualifier()?.value(),n=e.tableRef().value(),a=e.pgTableAlias()?.value()||n,o=r.originSchemas[0],c=Object.fromEntries(o.columns().map(_=>[_.name().value(),_])),l=e.columnList()?.entries().map(_=>_.value())||Object.keys(c),f=Object.create(null);for(let[_,x]of Object.entries(c))f[_]=null,(r.cons=x.defaultConstraint())&&(f[_]=await this.#t.evaluate(r.cons.expr()));let y=[];if(r.valuesClause=e.valuesClause())for(let _ of r.valuesClause){let x={...f},E={[a]:x};for(let[S,N]of _.entries().entries()){let A=l[S],v=c[A];if(N instanceof d.DefaultLiteral){let T=v.defaultConstraint();T&&(N=T.expr())}let O=await this.#t.evaluate(N,E,t);this.#u(x,v,O)}y.push(x)}else if((r.selectClause=e.selectClause())||(r.myTableClause=e.myTableClause())){let _={...t,depth:t.depth+1},x=r.myTableClause?this.#_(r.myTableClause,_):await this.#n(r.selectClause,_);for await(let E of x){let S={...f};for(let[N,A]of Object.values(E).entries()){let v=l[N],O=c[v];this.#u(S,O,A)}y.push(S)}}else if(e.pgDefaultValuesClause()){let _={...f};y.push(_)}else if(r.mySetClause=e.mySetClause()){let _=await this.#m({[a]:f},r.mySetClause,null,t);y.push(_[a])}let p=0,m=[],h=e.conflictHandlingClause(),g=e.returningClause();for(let _ of y){let x;try{x=await this.#e.insert(n,_,s,t)}catch(E){if(E instanceof ot&&h?.length)if(h.whereClause?.()&&!await this.evaluateWhereClause(h.whereClause(),[{[a]:E.existing}],t))x=null;else{let S=await this.#m({[a]:E.existing,EXCLUDED:_},h,r.originSchemas,t);x=await this.#e.update(n,S[a],s,t)}else if(E instanceof ot&&h?.doNothingKW?.())x=null;else throw E}if(g){if(x){let E=Object.create(null),S={[a]:x};for(let N of g){let{alias:A,value:v}=await this.#t.evaluate(N,S,t);E[A]=v}m.push(E)}}else p++}return g?async function*(){yield*m}():p}async#h(e,t){let r={};if(!Array.isArray(r.originSchemas=e.originSchemas()))throw new Error("Expected a pre-resolved query object with originSchemas() returning an array");let s,n,a;if(r.myUpdateList=e.myUpdateList())s=r.myUpdateList,n=e.joinClauses()||[],a=s.concat(n).map(p=>{let m=p.expr?.()||p.tableRef(),h=m.value(),g=p.alias()?.value()||h,_=m.qualifier()?.value();return[g,h,_]});else{let p=e.tableExpr();s=[p],n=(e.pgFromClause()?.entries()||[]).concat(e.joinClauses()||[]);let m=p.tableRef().qualifier()?.value(),h=p.tableRef().value();a=[[p.alias()?.value()||h,h,m]]}let o=await this.evaluateFromItems(s,n,r.originSchemas,t);(r.whereClause=e.whereClause())&&(o=this.evaluateWhereClause(r.whereClause,o,t));let c=0,l=[],f=e.returningClause(),y=e.setClause();for await(let p of o){let m=await this.#m(p,y,r.originSchemas,t);for(let[h,g,_]of a)m[h]!==p[h]&&(m[h]=await this.#e.update(g,m[h],_,t));if(f){let h=Object.create(null);for(let g of f){let{alias:_,value:x}=await this.#t.evaluate(g,m,t);h[_]=x}l.push(h)}else c++}return f?async function*(){yield*l}():c}async#E(e,t){let r={};if(!Array.isArray(r.originSchemas=e.originSchemas()))throw new Error("Expected a pre-resolved query object with originSchemas() returning an array");let s,n,a;if(r.myDeleteList=e.myDeleteList()){s=(e.myFromClause()||e.usingClause())?.entries()||[],n=e.joinClauses()||[];let y=[...s,...n];a=r.myDeleteList.map(p=>{let m=y.find(x=>(x.alias()||x.expr()).identifiesAs(p)),h=m.expr(),g=h.value?.();if(!g)throw new Error(`Cannot delete from ${p}; ${m} isn't a table reference.`);let _=h.qualifier()?.value();return[p.value(),g,_]})}else{let y=e.tableExpr();s=[y],n=(e.pgUsingClause()?.entries()||[]).concat(e.joinClauses()||[]);let p=y.tableRef(),m=p.value(),h=y.alias()?.value()||m,g=p.qualifier()?.value();a=[[h,m,g]]}let o=await this.evaluateFromItems(s,n,r.originSchemas,t);(r.whereClause=e.whereClause())&&(o=this.evaluateWhereClause(r.whereClause,o,t));let c=0,l=[],f=e.returningClause();for await(let y of o){for(let[p,m,h]of a)y[p]=await this.#e.delete(m,y[p],h,t);if(f){let p=Object.create(null);for(let m of f){let{alias:h,value:g}=await this.#t.evaluate(m,y,t);p[h]=g}l.push(p)}else c++}return f?async function*(){yield*l}():c}async#m(e,t,r,s){let n={...e},a=Object.keys(e)[0],o=async(c,l,f)=>{if(f instanceof d.DefaultLiteral){let m=r.find(h=>h.identifiesAs(c)).columns().find(h=>h.identifiesAs(l)).defaultConstraint();m&&(f=m.expr())}let y=await this.#t.evaluate(f,e,s);n[c]={...n[c],[l]:y}};for(let c of t){let l=c.left(),f=c.right();if(l instanceof d.ColumnsConstructor){if(!(f instanceof d.RowConstructor))throw new Error(`Expected a RHS of type ROW_CONSTRUCTOR for a LHS of type COLUMNS_CONSTRUCTOR, but got ${f.NODE_NAME}`);for(let[y,p]of l.entries().entries()){let m=p.value(),h=f.entries()[y];if(!h)throw new Error(`Mismatched number of entries in SET clause: LHS has ${l.entries().length} but RHS has ${f.entries().length}`);await o(a,m,h)}}else{let y=l.value(),p=l.qualifier?.()?.value()||a;await o(p,y,f)}}return n}#u(e,t,r,s=!1){let n=t.name().value();return e[n]=r,e;return!t.identityConstraint()&&!t.autoIncrementConstraint()&&(_cons=t.nullConstraint())&&_cons.value()==="NOT"&&requireds.add(n),inputValue}async*#_(e,t){let r=e.tableRef(),s=r.value(),n=r.qualifier()?.value();yield*this.#e.getCursor(s,n)}async*#S(e,t){let r={};if(!Array.isArray(r.originSchemas=e.originSchemas()))throw new Error("Expected a pre-resolved query object with originSchemas() returning an array");let s=await this.evaluateFromClause(e.fromClause(),e.joinClauses(),r.originSchemas,t);(r.whereClause=e.whereClause())&&(s=this.evaluateWhereClause(r.whereClause,s,t));let n=[],a=[];e.walkTree(m=>{if(!(m instanceof d.DerivedQuery||m instanceof d.ScalarSubquery))if(m instanceof d.AggrCallExpr)m.overClause()?a.push(m):n.push(m);else return m});let o=e.groupByClause(),c=e.havingClause(),l=e.selectList();if(o?.length){let m=this.#t.resolveScopedRefsInClause(o,l);s=this.evaluateGroupByClause(m,c,s,t)}else n.length&&(s=this.evaluateGlobalGroup(s));if(a.length){let m=new Map(e.windowClause()?.entries().map(h=>[h.name().value(),h.spec()])||[]);s=this.evaluateWindowing(a,m,s,t)}let f=e.orderByClause?.();if(f){let m=this.#t.resolveScopedRefsInClause(f,l);s=this.evaluateOrderByClause(m,s,t)}s=this.evaluateSelectList(l,s,t);let y=e.limitClause?.(),p=e.offsetClause?.();(y||p)&&(s=this.evaluateLimitClause(y,p,s,t)),yield*s}async evaluateFromClause(e,t,r,s){return e?.length?await this.evaluateFromItems(e.entries(),t,r,s):async function*(){yield{...s.lateralCtx||{}}}()}async evaluateFromItems(e,t,r,s){let n=[...e,...t||[]],a=n[0],o=a.alias?.()?.value(),c=f=>r.find(y=>f?y.identifiesAs(f):!y.name?.()),l=this.evaluateFromItem(a,c(o),s);for(let f=1;f<n.length;f++){let y=n[f],p=y.alias?.()?.value(),m=c(p),h,g=y.lateralKW?.();if(g)h=E=>this.evaluateFromItem(y,m,{...s,lateralCtx:E});else{let E=this.evaluateFromItem(y,m,{...s,lateralCtx:null}),S=[];h=async function*(){if(S.length)yield*S;else for await(let N of E)S.push(N),yield N}}let _=y.joinType?.()||(e.includes(y)?"CROSS":"INNER"),x=y.conditionClause?.();if(!x&&y.naturalKW?.()){let E=n[f-1].alias?.()?.value(),S=c(E),N=S.columns?.()||S.entries(),v=(m.columns?.()||m.entries()).reduce((O,T)=>N.find(b=>b.identifiesAs(T))?O.concat({value:T.name().value(),delim:T._get("delim")}):O,[]);v.length&&(x=d.UsingClause.fromJSON({columns:v},{assert:!0}))}l=this.evaluateJoin(l,{alias:p,isLateral:g},h,_,x,r,s)}return l}async*evaluateFromItem(e,t,r){if(e instanceof d.TableAbstraction2||e instanceof d.TableAbstraction1){let m=e.tableRef(),h=e.alias(),g=m.qualifier()?.value(),_=m.value(),x=h?.value()||_;for await(let E of this.#e.getCursor(_,g))yield{[x]:E};return}let s=e.expr(),n=e.alias()?.value()||"",a=t.length;if(s instanceof d.DerivedQuery){for await(let m of await this.#n(s.expr(),r)){let h=Object.entries(m),g=h.length;if(g!==a)throw new Error(`Expected number of columns from DerivedQuery function to be ${a} but got ${g}`);let _=Object.create(null);for(let[x,E]of h)this.#u(_,t._get("entries",x),E);yield{[n]:_}}return}if(s instanceof d.ValuesTableLiteral){for(let m of s.entries()){let h=m.length;if(h!==a)throw new Error(`Expected number of columns in ROW_CONSTRUCTOR to be ${a} but got ${h}`);let g=Object.create(null);for(let[_,x]of m.entries().entries())this.#u(g,t.entries()[_],await this.#t.evaluate(x,r.lateralCtx,r));yield{[n]:g}}return}let o=async m=>{let h=await this.#t.evaluate(m,r.lateralCtx,r),g;if(Symbol.asyncIterator in h)g=h[Symbol.asyncIterator]();else if(Symbol.iterator in h)g=async function*(){yield*h}();else throw new Error(`Function ${m.name()} did not return an iterable value or a promise of such thereof.`);return g},c=async(m,h)=>await o(m);if(s instanceof d.SRFExpr1){let m=s.callExpr(),h=s.qualif(),g=h.alias?.()?.value()||"";for await(let _ of await c(m,h.columnDefs())){if(!Array.isArray(_)&&!(_&&typeof _=="object"))throw new Error(`Function ${m.name()} did not return an object or array value or a promise of such thereof.`);let x=Object.values(_),E=x.length;if(E!==a)throw new Error(`Expected number of columns from SRF function to be ${a} but got ${E}`);let S=Object.create(null);for(let N=0;N<E;N++)this.#u(S,t.entries()[N],x[N]);yield{[g]:S}}return}if(s instanceof d.SRFExpr2){let m=s.callExpr(),h=s.withOrdinality(),g=0;for await(let _ of await o(m)){if(!Array.isArray(_)&&!(_&&typeof _=="object"))throw new Error(`Function ${m.name()} did not return an object or array value or a promise of such thereof.`);let x=Object.values(_);h&&x.push(++g);let E=x.length;if(E!==a)throw new Error(`Expected number of columns from SRF function to be ${a} but got ${E}`);let S=Object.create(null);for(let N=0;N<E;N++)this.#u(S,t.entries()[N],x[N]);yield{[n]:S}}return}if(s instanceof d.SRFExpr4){let m=s.withOrdinality(),h=[];for(let x of s.entries()){if(!(x instanceof d.SRFExpr3))throw new Error(`Expected SRFExpr3 but got ${x?.NODE_NAME}`);let E=x.callExpr(),S=x.qualif(),N=await c(E,S?.columnDefs());h.push({stream:N,callExpr:E})}let g=0,_={};for(;;){let x=0,E=!0,S=Object.create(null);for(let N=0;N<h.length;N++){let{stream:A,callExpr:v}=h[N],O=await A.next();if(O.done)for(let T=0;T<(_[N]||1);T++)this.#u(S,t.entries()[x],null,!0),x++;else{E=!1;let T=O.value;if(!Array.isArray(T)&&!(T&&typeof T=="object"))throw new Error(`Function ${v.name()} did not return an object or array value or a promise of such thereof.`);let b=Object.values(T);if(_[N]){if(_[N]!==b.length)throw new Error(`Inconsistent number of columns from SRF function: expected ${_[N]} but got ${b.length}`)}else if(_[N]=b.length,_[N]+x+(m?1:0)>a)throw new Error(`Number of columns from SRF function(s) (${_[N]+x+(m?1:0)}) exceeds expected: expected ${a}`);for(let R of b)this.#u(S,t.entries()[x],R),x++}}if(E)break;m&&(this.#u(S,t.entries()[x],g+1),x++),yield{[n]:S},g++}return}let l=s.qualifier()?.value(),f=s.value(),y;if(s.resolution()==="cte"){if(y=r.cteRegistry?.get(f),!y)throw new Error(`Implied CTE ${f} does not exist in the current context`);if(typeof y[Symbol.asyncIterator]!="function")throw new Error(`Implied CTE ${f} does not return a record set`)}else y=this.#e.getCursor(f,l);let p=null;for await(let m of y){let h=Object.entries(m),g=h.length;if(g!==a)throw new Error(`Expected number of columns from ${n} to be ${a} but got ${g}`);let _=Object.create(null);for(let[x,E]of h)this.#u(_,t._get("entries",x),E);yield{...r.lateralCtx||{},[n]:_}}}async*evaluateJoin(e,{alias:t,isLateral:r},s,n,a,o,c){let l=m=>o.find(h=>h.identifiesAs(m)),f=(m,h)=>{for(let g of h){if(m[g])continue;let _=l(g),x=_.columns?.()||_.entries();m[g]=Object.fromEntries(x.map(E=>[E.name().value(),null]))}return m},y=new Set,p=new Map;for await(let m of e){for(let g of Object.keys(m))y.add(g);let h=!1;for await(let g of s(m)){let _={...m,...g},x=()=>E||(E=r?JSON.stringify(g):g),E;!a||await this.#t.evaluate(a,_,c)?(h=!0,p.set(x(),!0),yield _):(n==="RIGHT"||n==="FULL")&&!p.has(x())&&p.set(x(),!1)}!h&&(n==="LEFT"||n==="FULL")&&(yield f({...m},[t]))}if(n==="RIGHT"||n==="FULL")for(let[m,h]of p.entries())h||(typeof m=="string"&&(m=JSON.parse(m)),yield f({...m},[...y]))}async*evaluateWhereClause(e,t,r){for await(let s of t)await this.#t.evaluate(e.expr(),s,r)&&(yield s)}async*evaluateGroupByClause(e,t,r,s){function n(y){return y instanceof d.RowConstructor?y.entries().flatMap(n):[y]}function a(y){if(y.groupingSets())return y.groupingSets().flatMap(a);if(y.rollupSet()){let p=y.rollupSet().entries(),m=[];for(let h=p.length;h>=0;h--)m.push(p.slice(0,h).flatMap(n));return m}if(y.cubeSet()){let p=y.cubeSet().entries(),m=p.length,h=[];for(let g=0;g<1<<m;g++){let _=[];for(let x=0;x<m;x++)g&1<<x&&_.push(p[x]);h.push(_.flatMap(n))}return h}return y.expr()?[n(y.expr())]:[[]]}function o(y){if(y.groupingSets())return y.groupingSets().flatMap(o);if(y.rollupSet())return[...y.rollupSet().entries()];if(y.cubeSet())return[...y.cubeSet().entries()];if(y.expr()){let p=y.expr();return p instanceof d.RowConstructor?p.entries():[p]}return[]}let c;e.every(y=>y.expr()&&!y.rollupSet()&&!y.cubeSet()&&!y.groupingSets())?c=[e.flatMap(y=>a(y)[0])]:c=e.flatMap(a);let l=new Map;for(let y=0;y<e.length;y++){let p=o(e[y]);l.set(y,p)}let f=new Map;for await(let y of r)for(let p=0;p<c.length;p++){let m=c[p],h=m.length?await Promise.all(m.map(x=>this.#t.evaluate(x,y,s))):[],g=0;for(let x=0;x<e.length;x++){let E=l.get(x)||[];if(E.length===0){g|=1<<x;continue}E.every(N=>m.includes(N))||(g|=1<<x)}let _=JSON.stringify([p,h]);f.has(_)||f.set(_,{window:[],mask:g,setIndex:p,keyVals:h,set:m}),f.get(_).window.push(y)}for(let{window:y,mask:p,setIndex:m,keyVals:h,set:g}of f.values()){let _={},x=new Map,E=N=>{let A=N.qualifier()?.value()||"",v=x.get(A)??new Set;v.add(N.value()),x.set(A,v)};for(let N of g)N instanceof d.ColumnRef1?E(N):N.walkTree(A=>(A instanceof d.ColumnRef1&&E(A),A));let S=new Map;for(let N=0;N<e.length;N++){let A=l.get(N)||[];for(let v of A)S.set(v,N)}for(let N of Object.keys(y[0])){let A={...y[0][N]};for(let v of Object.keys(A))x.get(N)?.has(v)||(A[v]=null);_[N]=A}_[Xn]={window:y,frameStart:0,frameEnd:y.length-1,groupValues:h,groupingId:p,setIndex:m,exprIndex:S,isGrandTotal:g.length===0,groupingColumnsMap:x},!(t&&!await this.#t.evaluate(t.expr(),_,s))&&(yield _)}}async*evaluateGlobalGroup(e){let t=[];for await(let s of e)t.push(s);let r=t[0]?{...t[0]}:{};r[Xn]={window:t,frameStart:0,frameEnd:t.length-1,groupValues:[],groupingId:0,setIndex:0,exprIndex:new Map},yield r}async*evaluateWindowing(e,t,r,s){let n=Array.isArray(r)?r:[];if(!Array.isArray(r))for await(let o of r)n.push(o);let a=new Map;for(let o of e){let c=o.overClause(),l;if(c instanceof d.WindowRef){let y=t.get(c.value());if(!y)throw new Error(`[${o}] Window '${c.value()}' not found`);l={partitionBy:y.partitionByClause(),orderBy:y.orderByClause(),frameSpec:y.frameSpec()}}else if(c instanceof d.WindowSpec){let y=c.superWindow()?t.get(c.superWindow().value()):null;l={partitionBy:c.partitionByClause()??y?.partitionByClause(),orderBy:c.orderByClause()??y?.orderByClause(),frameSpec:c.frameSpec()??y?.frameSpec()}}let f=JSON.stringify(l);a.has(f)||a.set(f,l),o.winHash=f}for(let[o,c]of a.entries()){let l=new Map,f=!!n[0]?.[Xn],y=new WeakMap;for(let p of n){let m=p,h=p;f&&(h={...p[Xn].window[0]},y.set(h,m));let g=await Promise.all(c.partitionBy?.map(x=>this.#t(x,h,s))??[]),_=JSON.stringify(g);if(!l.has(_)){let x=[];l.set(_,x)}l.get(_).push(h)}for(let p of l.values()){if(c.orderBy){let g=this.evaluateOrderByClause(c.orderBy.entries(),p,s,!0),_=[];for await(let x of g)_.push(x);p=_}let m=0,h=!!c.orderBy;for(let g of p){let{row:_,keys:x}=h?g:{row:g,keys:[m]},E=f?y.get(_):_,{frameStart:S,frameEnd:N}=this.#l(c,p,m,h);E[Da]||(E[Da]={}),E[Da][o]={window:h?p.map(A=>A.row):p,orderKeysHash:JSON.stringify(x),orderKeys:x,offset:m++,frameStart:S,frameEnd:N}}}}yield*n}#l(e,t,r,s=!1){let n=e.frameSpec,a=t.length;if(!n)return{frameStart:0,frameEnd:a-1};let o=n.specifier(),[c,l]=n.bounds()??[],f=0,y=a-1,p=m=>Math.min(Math.max(m,0),a-1);if(o==="ROWS"){if(!c||c.specifier()==="CURRENT ROW")f=r;else if(c.specifier()==="UNBOUNDED"&&c.dir()==="PRECEDING")f=0;else if(c.specifier()instanceof d.NumberLiteral){let m=c.specifier().value();f=p(c.dir()==="PRECEDING"?r-m:r+m)}if(!l||l.specifier()==="CURRENT ROW")y=r;else if(l.specifier()==="UNBOUNDED"&&l.dir()==="FOLLOWING")y=a-1;else if(l.specifier()instanceof d.NumberLiteral){let m=l.specifier().value();y=p(l.dir()==="FOLLOWING"?r+m:r-m)}}else if(o==="RANGE"){if(!e.orderBy)return{frameStart:0,frameEnd:a-1};let g=(N=>s?N.keys:[r])(t[r])[0],_=N=>s?N.keys[0]:r,x=r;for(;x>0&&_(t[x-1])===g;)x--;let E=r;for(;E<a-1&&_(t[E+1])===g;)E++;f=x,y=E;let S=(N,A)=>{if(N){if(N.specifier()==="UNBOUNDED"&&N.dir()==="PRECEDING")f=0;else if(N.specifier()==="UNBOUNDED"&&N.dir()==="FOLLOWING")y=a-1;else if(N.specifier()==="CURRENT ROW")A?f=x:y=E;else if(N.specifier()instanceof d.NumberLiteral){let v=N.specifier().value(),O=g+(N.dir()==="FOLLOWING"?v:-v);if(A){let T=0;for(;T<a&&_(t[T])<O;)T++;f=T}else{let T=a-1;for(;T>=0&&_(t[T])>O;)T--;y=T}}else if(N.specifier()instanceof d.TypedIntervalLiteral){let v=new Date(g).getTime(),O=N.specifier().applyToDate(new Date(v),N.dir());if(A){let T=0;for(;T<a&&new Date(_(t[T])).getTime()<O;)T++;f=T}else{let T=a-1;for(;T>=0&&new Date(_(t[T])).getTime()>O;)T--;y=T}}}};S(c,!0),S(l,!1)}else if(o==="GROUPS"){if(!e.orderBy)return{frameStart:0,frameEnd:a-1};let m=N=>JSON.stringify(s?N.keys:[r]),h=[],g=[0],_=m(t[0]);for(let N=1;N<a;N++){let A=m(t[N]);A===_?g.push(N):(h.push(g),g=[N],_=A)}h.push(g);let x=h.findIndex(N=>N.includes(r)),E=x,S=x;if(c){if(c.specifier()==="UNBOUNDED"&&c.dir()==="PRECEDING")E=0;else if(c.specifier()==="CURRENT ROW")E=x;else if(c.specifier()instanceof d.NumberLiteral){let N=c.specifier().value();E=p(x-N)}}if(l){if(l.specifier()==="UNBOUNDED"&&l.dir()==="FOLLOWING")S=h.length-1;else if(l.specifier()==="CURRENT ROW")S=x;else if(l.specifier()instanceof d.NumberLiteral){let N=l.specifier().value();S=p(x+N)}}f=h[E][0],y=h[S][h[S].length-1]}return{frameStart:f,frameEnd:y}}async*evaluateSelectList(e,t,r){for await(let s of t){let n=Object.create(null),a=1;for(let o of e){let{alias:c,value:l}=await this.#t.evaluate(o,s,r);n[c]&&r.depth&&(c+=a),n[c]=l,a++}yield n}}async*evaluateOrderByClause(e,t,r,s=!1){let n=Array.isArray(t)?t:[];if(!Array.isArray(t))for await(let o of t)n.push(o);let a=await Promise.all(n.map(async o=>{let c=await Promise.all(e.map(l=>this.#t.evaluate(l.expr(),o,r)));return{row:o,keys:c}}));this.#t.applySorting(a,e,r);for(let o of a)s?yield o:yield o.row}async*evaluateLimitClause(e,t,r,s){let n=e?await this.#t.evaluate(e.expr(),{},s):0,a=t?await this.#t.evaluate(t.expr(),{},s):e.myOffset()?await this.#t.evaluate(e.myOffset(),{},s):0,o=0,c=0;for await(let l of r)if(!(o++<a)){if(n&&c++>=n)break;yield l}}async*#N(e,t){let r=this;async function*s(O){if(O instanceof d.SelectStmt){yield*await r.#n(O,{...t,depth:t.depth+1});return}if(O instanceof d.TableStmt){yield*r.#_(O,{...t,depth:t.depth+1});return}let T=O.resultSchema(),b=O.jsonfy();O instanceof d.ValuesConstructor&&(b={...b,nodeName:"VALUES_TABLE_LITERAL"});let R=d.FromItem.fromJSON({nodeName:"FROM_ITEM",expr:b},{dialect:r.#r.dialect,assert:!0});e._adoptNodes(R);let M=r.evaluateFromItem(R,T,t);for await(let G of M)yield G[""]}let n=await s(e.left()),a=await s(e.right()),o=[],c=[];for await(let O of n)o.push(O);for await(let O of a)c.push(O);let l=e.left().resultSchema?.().entries()||[],f=e.right().resultSchema?.().entries()||[];if(l.length!==f.length)throw new Error(`Set operation column mismatch: left has ${l.length} columns, right has ${f.length}`);let y=l.map((O,T)=>{let b=f[T],R=O.dataType().value(),M=b.dataType().value(),G=this.#y(R,M);return{name:O.name().value()??`col${T+1}`,coercedType:G}}),p=[],m=[];for(let O of o)p.push(this.#x(O,y));for(let O of c)m.push(this.#x(O,y));let h=e.operator(),g=e.allOrDistinct()||"DISTINCT",_=[],x=O=>JSON.stringify(Object.values(O),(T,b)=>b==null?{__sql_null__:!0}:typeof b=="number"&&Number.isNaN(b)?{__sql_NaN__:!0}:b),E=Symbol("hash"),S=O=>{let T=new Map;for(let b of O){let R=b[E]??(b[E]=x(b));T.set(R,(T.get(R)||0)+1)}return T};if(h==="UNION")if(g==="ALL")_=[...p,...m];else{let O=new Map;for(let T of p)O.set(x(T),T);for(let T of m){let b=x(T);O.has(b)||O.set(b,T)}_=Array.from(O.values())}else if(h==="INTERSECT"){let O=S(p),T=S(m);if(g==="ALL")for(let[b,R]of O.entries()){let M=T.get(b)||0,G=Math.min(R,M),B=p.find(j=>x(j)===b);for(let j=0;j<G;j++)_.push({...B})}else for(let b of O.keys())if(T.has(b)){let R=p.find(M=>x(M)===b);_.push({...R})}}else if(h==="EXCEPT"){let O=S(p),T=S(m);if(g==="ALL")for(let[b,R]of O.entries()){let M=T.get(b)||0,G=Math.max(0,R-M),B=p.find(j=>x(j)===b);for(let j=0;j<G;j++)_.push({...B})}else for(let b of O.keys())if(!T.has(b)){let R=p.find(M=>x(M)===b);_.push({...R})}}let N=e.orderByClause();N&&(_=await this.evaluateSetOpOrderByClause(N.entries(),_,t));let A=e.limitClause(),v=e.offsetClause();(A||v)&&(_=await this.evaluateSetOpLimitClause(A,v,_,t)),yield*_}#x(e,t){let r=Object.values(e),s=Object.create(null);for(let n=0;n<t.length;n++){let{name:a,coercedType:o}=t[n],c=r[n];o==="numeric"?typeof c=="string"&&c!==""&&!isNaN(+c)&&(c=+c):o==="text"&&c!=null&&typeof c!="string"&&(c=String(c)),c===void 0&&(c=null),s[a]=c}return s}#y(e,t){if(!e&&!t)return null;if(!e)return t;if(!t||e===t)return e;let r=new Set(["smallint","integer","bigint","numeric","decimal","float","double"]);return r.has(e)&&r.has(t)?"numeric":e==="text"||t==="text"?"text":e==="boolean"&&t==="boolean"?"boolean":e}async evaluateSetOpOrderByClause(e,t,r){let s=await Promise.all(t.map(async n=>{let a=await Promise.all(e.map(o=>{let c,l=()=>{throw new Error(`[ORDER BY] The reference by offset ${o.expr()} does not resolve to a select list entry`)};if(o.expr()instanceof d.NumberLiteral){let f=Object.values(n),y=o.expr().value()-1;return(y<0||y>=f.length)&&l(),f[y]}return o.expr()?.resolution?.()==="scope"?((c=n[o.expr().value()])===void 0&&l(),c):this.#t.evaluate(o.expr(),{...r.lateralCtx||{}," ":n},r)}));return{row:n,keys:a}}));return this.#t.applySorting(s,e,r),s.map(n=>n.row)}async evaluateSetOpLimitClause(e,t,r,s){let n=e?await this.#t.evaluate(e.expr(),{},s):0,a=t?await this.#t.evaluate(t.expr(),{},s):e.myOffset()?await this.#t.evaluate(e.myOffset(),{},s):0;return r.slice(a,n?a+n:void 0)}};var La=class extends Ot{#e;#t;#r;#n;#i;#s;get dialect(){return this.#e}get enableLive(){return this.#t}get storageEngine(){return this.#r}constructor({dialect:e="postgres",enableLive:t=!1,...r}={},s=null){super(),this.#e=e,this.#t=!!t,this.#r=s||new zn({dialect:e,...r}),this.#n=new Zn(this.#r,{dialect:e,...r}),this.#s=new Qn(this)}async connect(){this.#t&&(this.#i=this.#n.on("changefeed",e=>this._fanout(e)))}async disconnect(){this.#i?.(),this.#i=null}async query(...e){let[t,r]=await this._normalizeQueryArgs(...e);if(r.live&&t.fromClause?.())return await this.#s.query(t,r);let s=await this.#n.query(t,r);return Array.isArray(s)||typeof s?.[Symbol.asyncIterator]=="function"?new Ze({rows:s}):typeof s=="number"?new Ze({rowCount:s}):new Ze}async showCreate(e,t=!1){e=Tt(e);let r=[];for(let s of await this.#r.schemaNames()){let n=Object.entries(e).reduce((o,[c,l])=>Ft(s,[c])?o.concat(l):o,[]);if(!n.length)continue;let a={nodeName:"SCHEMA_SCHEMA",name:{nodeName:"SCHEMA_IDENT",value:s},entries:[]};for(let o of await this.#r.tableNames(s)){if(!Ft(o,n))continue;let c=(await this.#r.tableSchema(o,s)).jsonfy();c.name.qualifier={nodeName:"SCHEMA_REF",value:s},(t?a.entries:r).push(d.TableSchema.fromJSON(c,{dialect:this.dialect}))}t&&r.push(d.SchemaSchema.fromJSON(a,{dialect:this.dialect}))}return r}};})();
//# sourceMappingURL=main.js.map
