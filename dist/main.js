(()=>{function ie(c,t,e=!1){if(t=="")return c;var r=e?c.lastIndexOf(t):c.indexOf(t);return r===-1?"":c.substr(r+t.length)}function Pe(c,t,e=!1){if(t=="")return c;var r=e?c.lastIndexOf(t):c.indexOf(t);return r===-1?c:c.substr(0,r)}function mt(c){return arguments.length&&(c===void 0||typeof c>"u")}function kt(c){return typeof c=="function"}function J(c){return kt(c)||c&&{}.toString.call(c)==="[object function]"}function $e(c,...t){return t.forEach(e=>{c.indexOf(e)<0&&c.push(e)}),c}function L(c){return Array.isArray(c)}function Ut(c){return c instanceof String||typeof c=="string"&&c!==null}function Je(c){return!Ut(c)&&!mt(c.length)}function Fe(c){return c===null||c===""}function q(c){return Array.isArray(c)||typeof c=="object"&&c||kt(c)}function ve(c){return Fe(c)||mt(c)||c===!1||c===0||q(c)&&!Object.keys(c).length}function O(c){return!Array.isArray(c)&&typeof c=="object"&&c}function se(c,t=!0){return L(c)?c:!t&&O(c)?[c]:c!==!1&&c!==0&&ve(c)?[]:Je(c)?Array.prototype.slice.call(c):O(c)?Object.values(c):[c]}function xt(c,t=1){var e=0;c.forEach(i=>{e++});var r=c.slice(c.length-e,t);return arguments.length>1?r:r[0]}function Mt(c){return c instanceof Number||typeof c=="number"}function Rt(c){return Mt(c)||c!==!0&&c!==!1&&c!==null&&c!==""&&!isNaN(c*1)}var qe=function(c,t=1,e=!0){return!Rt(t)||t<=0||(!L(c)&&O(c)&&e&&(c=Object.values(c)),!L(c))?c:c.reduce((r,i)=>L(i)||O(i)&&e?r.concat(qe(L(i)?i:Object.values(i),t-1,e)):r.concat(i),[])},Be=qe;function ne(c){return c===!0||c===!1}function Xt(c,t,e=null){return L(t)?c.filter(r=>e?t.filter(i=>e(r,i)).length:t.indexOf(r)!==-1):[]}function at(c,t=1){return arguments.length>1?xt(c.slice().reverse(),t).reverse():xt(c.slice().reverse())}function we(c,t){var e=void 0;return q(c)&&Object.keys(c).forEach((r,i)=>{e!==!1&&(e=t(Rt(r)?parseFloat(r):r,c[r],i))}),e}function Qe(r,t){t=t||Object.prototype,t=t&&!L(t)?[t]:t;for(var e=[],r=r;r&&(!t||t.indexOf(r)<0)&&r.name!=="default";)e.push(r),r=r?Object.getPrototypeOf(r):null;return e}function ze(c,t){var e=[];return Qe(c,t).forEach(r=>{$e(e,...Object.getOwnPropertyNames(r))}),e}function Dt(c,t,e=!1,r=!1,i=!1){var s=0,n=c.shift();if((Rt(n)||n===!0||n===!1)&&(s=n,n=c.shift()),!c.length)throw new Error("_merge() requires two or more array/objects.");return c.forEach((u,o)=>{!q(u)&&!J(u)||(e?ze(u):Object.keys(u)).forEach(f=>{if(t(f,n,u,o)){var l=n[f],h=u[f];if((L(l)&&L(h)||O(l)&&O(h))&&(s===!0||s>0))n[f]=L(l)&&L(h)?[]:{},Dt([Rt(s)?s-1:s,n[f],l,h],t,e,r,i);else if(L(n)&&L(u))r?n[f]=h:n.push(h);else try{i?Object.defineProperty(n,f,Object.getOwnPropertyDescriptor(u,f)):n[f]=u[f]}catch{}}})}),n}function be(...c){return Dt(c,(t,e,r)=>!0,!1,!1,!1)}function Ue(c){return O(c)&&Object.getPrototypeOf(c)===Object.prototype}function Ze(c,t,e=!0,r=!0,i=!1,s=!1){if(L(c)&&L(t)){var n=[],u=!0;return c.forEach(o=>{if(u){var f=!1;we(t,(l,h)=>{(!f||r&&q(o))&&(f=e(o,h),(L(f)&&!f.length||O(f)&&!Object.keys(f).length)&&(f=!1),q(f)&&r&&(o=f))}),q(f)?n.push(r?f:o):ne(f)?i&&!f||!i&&f?n.push(o):s&&(u=!1):n.push(f)}}),n}if(O(c)&&O(t)){var n={},u=!0;return Object.keys(c).forEach(l=>{if(u){var h=e(c[l],t[l]);(L(h)&&!h.length||O(h)&&!Object.keys(h).length)&&(h=!1),q(h)?n[l]=r?h:c[l]:ne(h)?i&&!h||!i&&h?n[l]=c[l]:s&&(u=!1):n[l]=h}}),n}}var Ye=function(c,t,e=!0,r=1){if(L(c)&&L(t)&&c.length!==t.length)return!e;if(O(c)&&O(t)){var i=Object.keys(c),s=Object.keys(t);if(!i.length&&!s.length)return Ue(c)&&Ue(t)?e:c===t===e;if(!Ye(i,s))return!e}if(r>0&&(L(c)&&L(t)||O(c)&&O(t))){var n=Ze(c,t,(u,o)=>Ye(u,o,e,r-1),!1,!1,!0);return L(n)?n.length===c.length&&n.length===t.length:O(n)&&O(c)?Object.keys(n).length===Object.keys(c).length&&Object.keys(n).length===Object.keys(t).length:n}return J(e)?e(c,t):Mt(c)&&Mt(t)&&isNaN(c)&&isNaN(t)?e:c===t===e},je=Ye;function Ke(c,t=[]){return Dt([{},c],(e,r,i)=>{if(!J(i[e]))return J(t)?t(e):L(t)&&t.length?t.indexOf(e)>-1:!0},!1,!1,!1)}var ot=class c{static lex(t,e,r={}){if(!Ut(t=t+""))throw new Error("Argument1 must be a string!");var i=f=>({delims:f.delims.slice(),options:Ke(f.options),nesting:f.nesting.slice(),maxDepth:f.maxDepth,comments:f.comments.slice(),tokens:f.tokens.slice(),matches:f.matches.slice(),matchesi:Ke(f.matchesi)});if(c.$cache[t]&&r.cache!==!1)for(var s=0;s<c.$cache[t].length;s++){var n=c.$cache[t][s];if(je(n.delims,e))return i(n)}var u=new c(t,r),o=u.lex(e);return r.cache!==!1&&(c.$cache[t]=c.$cache[t]||[],c.$cache[t].push(o)),i(o)}static split(t,e,r){return c.lex(t,e,r).tokens}static match(t,e,r){return c.lex(t,e,r).matches}constructor(t,e){if(!Ut(t))throw new Error("Lexer requires the first argument to be a string.");this.$str=t,this.$options=e||{},this.$options.blocks||(this.$options.blocks=c.$blocks),this.$options.quotes||(this.$options.quotes=c.$quotes),this.$options.comments||(this.$options.comments=c.$comments)}lex(t,e){for(var r={delims:se(t),options:be(!0,{},this.$options,e||{}),nesting:[],maxDepth:0,comments:[],tokens:[],matches:[],matchesi:{}},i=0;typeof i=="number";)i=this._evalCharsAt(r,i);if(r.nesting.length)throw new Error("Error parsing the string: "+this.$str+". Unterminated blocks: "+Be(r.nesting).join(", "));return r}_evalCharsAt(t,e){if(!(e>=this.$str.length)){var r=1,i={},s={},n={};if(t.openComment||(s=this._testQuotes(t,e)),t.openQuote||(i=this._testComments(t,e)),t.openComment||i.ending)if(!t.nesting.length&&!n.ending){var u=i.starting||i.ending||this.$str[e];r=u.length,this._push(t,u,"comments",i.starting)}else this._push(t,this.$str[e]);else if(t.openQuote||s.ending)this._push(t,this.$str[e]);else{if(t.options.limit&&t.matches.length===t.options.limit)return this._push(t,this.$str[e]),e+1;n=this._testNesting(t,e);var n=this._testNesting(t,e),o=this._testChars(t.options.stopChars||[],t,e);if(!t.nesting.length&&o!==!1){t.options.stopChar=o,t.options.stopCharForward=this.$str.substr(e);return}if(!t.delims.length)t.nesting.length===2&&n.starting?(t.matches.push(null),this._push(t,n.starting),r=n.starting.length):!t.nesting.length&&n.ending?(this._push(t,n.ending),r=n.ending.length,t.matches.push(null)):this._push(t,this.$str[e]);else if(!t.nesting.length&&!n.ending){this._push(t,"");var f=this._testChars(t.delims,t,e);if(f!==!1&&(t.matches.push(f),t.matchesi[e]=f,r=f.length||1,!t.options.preserveDelims)){var l=e+(f.length||1);return l===this.$str.length&&this._push(t,""),l}this._push(t,f||this.$str[e])}else{var u=n.starting||n.ending||this.$str[e];r=u.length,this._push(t,u)}}return e+r}}_testQuotes(t,e){var r={};return(t.options.quotes||[]).forEach(i=>{this.$str.substr(e,1)===i&&(t.openQuote?i===t.openQuote&&(t.openQuote=!1,r.ending=i):(t.openQuote=i,r.starting=i))}),r}_testComments(t,e){var r={};return(t.options.comments||[]).forEach(i=>{if(t.openComment){if(at(i)===at(t.openComment)){var n=at(i);this.$str.substr(e).startsWith(n)&&(t.openComment=!1,r.ending=n)}}else{var s=xt(i);this.$str.substr(e).startsWith(s)&&(t.openComment=i,r.starting=s)}}),r}_testNesting(t,e){var r={};return(t.options.blocks||[]).forEach(i=>{let s=xt(i),n;if(s instanceof RegExp?[n]=s.exec(this.$str.substr(e))||[]:this.$str.substr(e).startsWith(s)&&(n=s),n)t.nesting=t.nesting.concat([i]),r.starting=n;else if(t.nesting.length&&at(i)===at(at(t.nesting))){var u=at(i),o;u instanceof RegExp?[o]=u.exec(this.$str.substr(e))||[]:this.$str.substr(e).startsWith(u)&&(o=u),o&&(t.nesting=t.nesting.slice(0,-1),r.ending=o)}}),t.maxDepth=Math.max(t.maxDepth,t.nesting.length),r}_testChars(t,e,r){for(var i=0;i<t.length;i++){let u={useRegex:e.options.useRegex,ci:e.options.ci,...O(t[i])?t[i]:{test:t[i]}};if(J(u.test)){var s=u.test(this.$str.substr(0,r),this.$str.substr(r),e.tokens.slice());if(s!==!1)return s;continue}if(u.useRegex){let f=u.useRegex!==!0?u.useRegex:"";var n=this.$str.substr(r).match(new RegExp("^"+u.test,f));if(n&&(!u.backtest||this.$str.substr(0,r).match(new RegExp(u.backtest,f))))return n[0];continue}let o=(f,l)=>u.ci?f.toLowerCase()===l.toLowerCase():f===l;if(o(this.$str.substr(r,u.test.length),u.test)&&(!u.backtest||o(this.$str.substr(r-u.backtest.length,r),u.backtest)))return u.test}return!1}_push(t,e,r="tokens",i=!1){var s=t.matches.length;if(mt(t.tokens[s])&&(t.tokens[s]=""),r==="comments"){t.tokens[s].comments||(t.tokens[s]=new String(t.tokens[s]),t.tokens[s].comments=[]);var n=t.tokens[s].comments.length-(!t.tokens[s].comments.length||i?0:1);t.tokens[s].comments[n]=(t.tokens[s].comments[n]||"")+e}else{var u=t.tokens[s].comments;t.tokens[s]=t.tokens[s]+e}}split(t,e,r){return this.lex(e,r).tokens}match(t,e,r){return this.lex(e,r).matches}regParse(t,e){return this.lex(t,be({useRegex:!0},e||{}))}regSplit(t,e){return this.regParse(t,e).tokens}regMatch(t,e){return this.regParse(t,e).matches}};ot.$blocks=[["(",")"],["[","]"],["{","}"]];ot.$quotes=['"',"'","`"];ot.$comments=[["/*","*/"],["//",`
`]];ot.$cache=Object.create(null);var m=class extends ot{static $blocks=[...ot.$blocks,[new RegExp("^CASE ","i"),new RegExp("^ END","i")]]};var d=class c{CONTEXT;FLAGS=[];constructor(t){this.CONTEXT=t,this.CONTEXT?.$trace?.("event:connected",this)}$trace(t,...e){return t==="get:node:root"&&!(this.CONTEXT instanceof c)?this:this.CONTEXT?.$trace?.(t,...e)}get params(){return this.CONTEXT?.params||{}}get quoteChars(){return this.constructor.getQuoteChars(this)}static getQuoteChars(t,e=!1){return(e&&t?.params?.inputDialect||t?.params?.dialect)==="mysql"&&!t.params.ansiQuotes?["'",'"']:["'"]}get escChar(){return this.constructor.getEscChar(this)}autoEsc(t){let e=(Array.isArray(t)?t:[t]).map(r=>r&&!/^(\*|[\w]+)$/.test(r)?`${this.escChar}${r.replace(new RegExp(this.escChar,"g"),this.escChar.repeat(2))}${this.escChar}`:r);return Array.isArray(t)?e:e[0]}static autoUnesc(t,e,r=!1){let i=this.getEscChar(t,r);return(e||"").replace(new RegExp(i+i,"g"),i)}static getEscChar(t,e=!1){return(e&&t?.params?.inputDialect||t?.params?.dialect)==="mysql"&&!t.params.ansiQuotes?"`":'"'}static parseIdent(t,e,r=!1){let i=this.getEscChar(t,r),s=m.split(e,["."]),n=s.map(o=>new RegExp(`^(?:(\\*|[\\w]+)|(${i})((?:\\2\\2|[^\\2])+)\\2)$`).exec(o.trim())).filter(o=>o);if(n.length!==s.length)return;let u=o=>o?.[1]||this.autoUnesc(t,o?.[3]);return[u(n.pop()),u(n.pop())]}with(t){for(let e in t)this[e]=t[e];return this}withFlag(...t){return t=new Set(t.filter(e=>e)),this.FLAGS=this.FLAGS.reduce((e,r)=>{let i=r.split(":");for(let s of t){let n=s.split(":");n[0]===i[0]&&(r=[...new Set([...i,...n])].join(":"),t.delete(s))}return e.concat(r)},[]).concat(...t),this}getFlag(t){let e=t.toUpperCase().split(":");return this.FLAGS.find(r=>{let i=r.split(":");return e[0]===i[0]&&e.every(s=>i.includes(s))})}hasFlag(t){return!!this.getFlag(t)}build(t,e,r,i){let s=Array.isArray(r)?r:r?[r]:[];if(!s.length)throw new Error("At least one node type must be defined.");let n=o=>s.find(f=>o instanceof f)?o:s.reduce((f,l)=>f||l.fromJSON(this,o),null),u=(...o)=>{for(let f of o)Array.isArray(this[t])?this[t].push(f):this[t]=f};if(e.length===1&&typeof e[0]!="function"){let o=n(e[0]);if(o)return u(o)}if(i){if(s.length!==1)throw new Error("To support argument delegation, number of node types must be 1.");let o=this[t]&&!Array.isArray(this[t])?this[t]:new s[0](this);return u(o),o[i](...e)}for(let o of e){if(typeof o=="function"){if(this[t]&&!Array.isArray(this[t])){o(this[t]);continue}if(s.length===1){let p=new s[0](this);u(p),o(p);continue}let h=p=>(...E)=>{let S=s.reduce((T,A)=>T||(A.factoryMethods?typeof A.factoryMethods[p]=="function"&&A.factoryMethods[p](this,...E):typeof A.prototype[p]=="function"&&new A(this)),null);if(!S)throw new Error(`Unknow method: ${p}()`);if(u(S),S[p])return S[p](...E);for(let T of E)T(S)};o(new Proxy({},{get:(p,E)=>h(E)}));continue}let f=n(o);if(f){u(f);continue}let l;if(typeof o=="object"&&o)try{l=JSON.stringify(o)}catch{l=o.constructor.name}else l=o+"";throw new Error(`Arguments must be of type ${s.map(h=>h.name).join(", ")} or a JSON equivalent. Recieved: ${l}`)}}clone(){return this.constructor.fromJSON(this.CONTEXT,this.toJSON())}static parse(t,e,r=null){}toString(){return this.stringify()}static fromJSON(t,e){}toJSON(){return{flags:this.FLAGS.slice(0)}}};var N=class extends d{PREFIX;NAME;name(t){let e=Array.isArray(t)?[...t]:[t];if(this.NAME=e.pop(),this.PREFIX=e.pop(),e.length)throw new Error(`Idents can be maximum of two parts. Recieved: ${e.join(".")}.${this.PREFIX}.${this.NAME}`);return this}toJSON(){let t=this.PREFIX?[this.PREFIX,this.NAME]:this.NAME;return this.FLAGS.length?{name:t,flags:this.FLAGS}:t}static fromJSON(t,e){if(typeof e=="string"||Array.isArray(e)&&e.every(i=>typeof i=="string"))e={name:e};else if(typeof e?.name!="string"&&!Array.isArray(e?.name))return;let r=new this(t).withFlag(...e?.flags||[]);return r.name(e.name),r}stringify(){return this.autoEsc([this.PREFIX,this.NAME].filter(t=>t)).join(".")+""}static parse(t,e){if(/^(TRUE|FALSE|NULL)$/i.test(e))return;let[r,i]=this.parseIdent(t,e,!0)||[];if(!r)return;let s=new this(t);return s.name(i?[i,r]:r),s}};function Ge(c,t){return ie(c,t,!0)}function Vt(c,t){return Pe(c,t,!0)}function ae(c,t){return c===void 0?"":c.split(/(?=[A-Z])/).join(t||" ")}function We(c,t){return typeof c!="string"?c:c.replace(/\w\S*/g,function(e){return e.charAt(0).toUpperCase()+(typeof t!==void 0&&t?e.substr(1).toLowerCase():e.substr(1))})}function He(c,t){return c=We(c.replace(/-/g," ")).replace(/ /g,""),t?c:c[0].toLowerCase()+c.substr(1)}function w(c,t,e){return Vt(ie(c,t),e)}function x(c,t,e){return c.startsWith(t)&&c.endsWith(e)}var et=class extends d{constructor(t){super(t),this._BINDINGS=[]}get BINDINGS(){return this._BINDINGS}$trace(t,...e){if(t==="get:node:statement")return this;if(t==="get:node:statement.bindings")return this._BINDINGS;if(t.startsWith("get:name:")){let r=this.$trace("get:node:table");if(!(r instanceof N)&&(r=r.EXPR,!(r instanceof N)&&!this._ongoingNameTrace)){this._ongoingNameTrace=!0;let i=r.$trace(t,...e);return delete this._ongoingNameTrace,i}if(r&&t==="get:name:table")return r.NAME;if(r&&t==="get:name:database"&&r.PREFIX)return r.PREFIX}return super.$trace?.(t,...e)}async $schema(t,e){this._SCHEMAS||(this._SCHEMAS=await this.$trace("get:api:client").schemas());let r=this._SCHEMAS.database(t);return e?r?.table(e).clone():r?.clone()}clone(){let t=super.clone();return t._BINDINGS=this._BINDINGS.slice(0),t._SCHEMAS=this._SCHEMAS,t}static mySubstitutePlaceholders(t,e){return(t?.params?.inputDialect||t?.params?.dialect)!=="mysql"||e.indexOf("?")===-1?e:m.split(e,["?"],{blocks:[]}).reduce((r,i,s)=>r?r+"?"+s+i:i,null)}get expandable(){return!1}async expand(t=!1){return t?this:this.clone()}};var qt=class extends d{CONDITION=null;CONSEQUENCE=null;condition(t){return this.build("CONDITION",[t],I.Types),this}then_(t){return this.build("CONSEQUENCE",[t],I.Types)}toJSON(){return{condition:this.CONDITION?.toJSON(),consequence:this.CONSEQUENCE?.toJSON()}}static fromJSON(t,e){if(!(typeof e=="object"&&e&&"condition"in e))return;let r=new this(t);return r.condition(e.condition),r.then_(e.consequence),r}stringify(){return`${this.CONDITION} THEN ${this.CONSEQUENCE}`}static parse(t,e,r){let i=m.split(e,["\\s+THEN\\s+"],{useRegex:"i"});if(i.length!==2)return;let s=new this(t),[n,u]=i.map(o=>r(s,o.trim()));return s.condition(n).then_(u),s}};var Pt=class extends d{BASE_VALUE;WHEN_CLAUSES=[];ELSE_CLAUSE;compare(t){if(this.WHEN_CLAUSES.length||this.ELSE_CLAUSE)throw new Error('A "case" clause must come before any "when" or "else" clauses.');return this.build("BASE_VALUE",[t],I.Types)}when(t){if(this.ELSE_CLAUSE)throw new Error('A "when" clause cannot come after an "else" clause.');return this.build("WHEN_CLAUSES",[t],qt,"condition"),this.WHEN_CLAUSES[this.WHEN_CLAUSES.length-1]}else(t){if(!this.WHEN_CLAUSES.length)throw new Error('An "else" clause cannot come before "when" clauses.');return this.build("ELSE_CLAUSE",[t],I.Types)}toJSON(){return{base_value:this.BASE_VALUE?.toJSON(),when_clauses:this.WHEN_CLAUSES.map(t=>t.toJSON()),else_clause:this.ELSE_CLAUSE?.toJSON(),flags:this.FLAGS}}static fromJSON(t,e){if(!Array.isArray(e?.when_clauses))return;let r=new this(t).withFlag(...e.flags||[]);e.base_value&&r.compare(e.base_value);for(let i of e.when_clauses)r.when(i);return e.else_clause&&r.else(e.else_clause),r}stringify(){let t=[];return this.BASE_VALUE&&t.push(this.BASE_VALUE),t.push(`WHEN ${this.WHEN_CLAUSES.join(" WHEN ")}`),this.ELSE_CLAUSE&&t.push("ELSE",this.ELSE_CLAUSE),`CASE ${t.join(" ")} END${this.params.dialect==="mysql"?" CASE":""}`}static parse(t,e,r){let[i,s]=e.match(/^CASE\s+([\s\S]*)\s+END(\s+CASE)?$/i)||[];if(!i)return;let{tokens:[n,...u],matches:o}=m.lex(s,["WHEN","ELSE"],{useRegex:"i"}),f=new this(t);n.trim()&&f.compare(r(f,n.trim()));for(let l of o){let h=u.shift();if(/ELSE/i.test(l))f.else(r(f,h.trim()));else if(/WHEN/i.test(l))f.when(r(f,h.trim(),[qt]));else throw new Error(`Can't have multiple "${l}" clauses in a CASE construct.`)}return f}static factoryMethods={case:t=>new this(t)}};var F=class extends d{OPERATOR="";OPERANDS=[];constructor(t,e,...r){super(t),this.OPERATOR=e,this.OPERANDS=r}assert(t,...e){return this.OPERATOR&&this.OPERANDS.splice(0),this.OPERATOR=t,this.build("OPERANDS",e,I.Types),this}equals(...t){return this.assert("=",...t)}eq(...t){return this.equals(...t)}notEqual(...t){return this.assert("<>",...t)}notEq(...t){return this.notEqual(...t)}lesserThan(...t){return this.assert("<",...t)}lt(...t){return this.lesserThan(...t)}lessThanOrEqual(...t){return this.assert("<=",...t)}ltOrEq(...t){return this.lessThanOrEqual(...t)}greaterThan(...t){return this.assert(">",...t)}gt(...t){return this.greaterThan(...t)}greaterThanOrEqual(...t){return this.assert(">=",...t)}gtOrEq(...t){return this.greaterThanOrEqual(...t)}in(...t){return this.assert("IN",...t)}any(...t){return this.assert("ANY",...t)}like(...t){return this.assert("LIKE",...t)}isNull(...t){return this.assert("IS NULL",...t)}isNotNull(...t){return this.assert("IS NOT NULL",...t)}isTrue(...t){return this.assert("IS TRUE",...t)}isNotTrue(...t){return this.assert("IS NOT TRUE",...t)}isFalse(...t){return this.assert("IS FALSE",...t)}isNotFalse(...t){return this.assert("IS NOT FALSE",...t)}isUnknow(...t){return this.assert("IS UNKNOWN",...t)}isNotUnknow(...t){return this.assert("IS NOT UNKNOWN",...t)}isDistinctFrom(...t){return this.assert("IS DISTINCT FROM",...t)}isNotDistinctFrom(...t){return this.assert("IS NOT DISTINCT FROM",...t)}isBetween(...t){return this.assert("IS BETWEEN",...t)}isNotBetween(...t){return this.assert("IS NOT BETWEEN",...t)}isBetweenSymmetric(...t){return this.assert("IS BETWEEN SYMMETRIC",...t)}isNotBetweenSymmetric(...t){return this.assert("IS NOT BETWEEN SYMMETRIC",...t)}and(...t){return new b(this,"AND").and(this,...t)}or(...t){return new b(this,"OR").or(this,...t)}toJSON(){return{operator:this.OPERATOR,operands:this.OPERANDS.map(t=>t.toJSON()),flags:this.FLAGS}}static fromJSON(t,e){if(!Array.isArray(e?.operands)||typeof e?.operator!="string"||!this.regexes.some(i=>new RegExp(i.regex||i.test||i).test(` ${e.operator} `)))return;let r=new this(t).withFlag(...e.flags||[]);return r.assert(e.operator,...e.operands),r}stringify(){let t=this.OPERANDS.slice(0),e=[t.shift(),this.OPERATOR.toUpperCase()],r=t;return this.OPERATOR==="IN"?e.push(`(${r.join(", ")})`):/BETWEEN/i.test(this.OPERATOR)?e.push(`(${r.join(" AND ")})`):e.push(`${r.join(" ")}`),e.filter(i=>i).join(" ")}static parse(t,e,r){let{tokens:[i,s=""],matches:[n]}=m.lex(e,this.regexes,{useRegex:"i"});if(!n)return;let u=n.trim().toUpperCase(),o=[i];return u==="IN"?o.push(...m.split(w(s.trim(),"(",")"),[","])):/BETWEEN/.test(u)?o.push(...m.split(s,[" AND "])):s&&o.push(s),new this(t,u,...o.map(f=>r(t,f.trim())))}static regexes=[{test:"<(?!~)"},{backtest:"^(?!.*~$)",test:">",regex:"(?<!~)>"},"((\\s+(?:NOT\\s+)?IS\\s+(?:NOT\\s+)?(TRUE|FALSE|NULL|UNKNOWN|DISTINCT\\s+FROM\\s+))|\\s+(ISNULL|NOTNULL|IN|ANY|LIKE|(?:NOT\\s+)?BETWEEN(?:\\s+SYMMETRIC)?)\\s+|(?:\\s+)?(=|<=|>=|!=|<>)(?:\\s+)?)"]};var Jt=class extends d{OFFSET;constructor(t,e){super(t),this.OFFSET=parseInt(e)}$var(t){this.OFFSET=t}$bind(t,e){this.OFFSET=t;let r=this.$trace("get:node:statement.bindings");r?.push(e),this.OFFSET===0&&(this.OFFSET=r?.length)}toJSON(){return{offset:this.OFFSET}}static fromJSON(t,e){if(typeof e?.offset=="number")return new this(t,e.offset)}stringify(){return this.params.dialect==="mysql"?"?":"$"+this.OFFSET}static parse(t,e){let r=(t?.params?.inputDialect||t?.params?.dialect)==="mysql"?"?":"$",[i,s]=new RegExp(`^\\${r}(\\d)$`).exec(e)||[];if(i)return new this(t,parseInt(s))}};var pt=class extends d{VALUE;true(){return this.VALUE=!0,this}false(){return this.VALUE=!1,this}null(){return this.VALUE=null,this}sql(t){return this.VALUE=t,this}toJSON(){return this.VALUE}static fromJSON(t,e){let r=new this(t);return e==!0?r.true():e==!1?r.false():e==null?r.null():r.sql(e)}stringify(){return`${this.VALUE}`}static parse(t,e){let r=new this(t);return/^TRUE$/i.test(e)?r.true():/^FALSE$/i.test(e)?r.false():/^NULL$/i.test(e)?r.null():r.sql(e)}};var ut=class extends d{VALUE="";QUOTE="";constructor(t,e,r="'"){super(t),this.VALUE=e,this.QUOTE=r}value(t){this.VALUE=t}stringify(){let t=this.QUOTE||this.quoteChars[0];return`${t}${(this.VALUE+"").replace(new RegExp(t,"g"),t.repeat(2))}${t}`}toJSON(){return{value:this.VALUE}}static fromJSON(t,e){if(typeof e?.value=="string")return new this(t,e.value,e.quote)}static parse(t,e){let[r,i]=this.parseText(t,e,!0)||[];if(i)return new this(t,r,i)}static parseText(t,e,r=!1){let i=this.getQuoteChars(t,r),s={};if(!(!(s.quote=i.find(n=>x(e,n,n)))||m.match(e,[" "]).length))return[w(e,s.quote,s.quote).replace(new RegExp(s.quote+s.quote,"g"),s.quote),s.quote]}};var Lt=class extends d{VALUE=0;constructor(t,e){super(t),this.VALUE=e}value(t){this.VALUE=t}toJSON(){return{value:this.VALUE,flags:this.FLAGS}}static fromJSON(t,e){if(typeof e=="number"||typeof e=="string"&&/^[.\d]+$/.test(e)&&(e=parseFloat(e)))e={value:e};else if(typeof e?.value!="number")return;return new this(t,e.value).withFlag(...e.flags||[])}stringify(){return`${this.VALUE}`}static parse(t,e){if(/^\d+$/.test(e))return new this(t,parseFloat(e))}static factoryMethods={value:(t,e)=>/^\d+$/.test(e)&&new this(t)}};var ct=class extends ut{TYPE;constructor(t,e,r,i){super(t,e,i),this.TYPE=r}array(t){this.VALUE=Array.isArray(t)?JSON.stringify(t):t,this.TYPE="ARRAY"}object(t){this.VALUE=O(t)?JSON.stringify(t):t,this.TYPE="OBJECT"}toJSON(){return{type:this.TYPE,...super.toJSON()}}static fromJSON(t,e){if(typeof e?.type!="string"||!/OBJECT|ARRAY/i.test(e.type)||!e.value)return;let r=new this(t);return r[e.type.toLowerCase()](e.value),r}stringify(){return`${super.stringify()}`}static parse(t,e){let r=[["{","}"],["[","]"]],i={},[s,n]=this.parseText(t,e)||[];if(n&&!(!(i.braces=r.find(u=>x(e,u[0],u[1])))||m.match(e,[" "]).length))return new this(t,s,i.braces[0]==="{"?"OBJECT":"ARRAY",n)}static factoryMethods={array:(t,e)=>Array.isArray(e)&&new this(t),object:(t,e)=>O(e)&&new this(t)}};var rt=class extends d{static OPERATORS=["->","->>","#>","#>>"];OPERATOR="";LHS=null;RHS=null;path(t,e,r){if(!this.constructor.OPERATORS.includes(e))throw new Error(`Unknown operator: "${e}".`);this.build("LHS",[t],[ct,N]),this.build("RHS",[r],[ct,Lt,ut]),this.OPERATOR=e}toJSON(){return{lhs:this.LHS?.toJSON(),rhs:this.RHS?.toJSON(),operator:this.OPERATOR,flags:this.FLAGS}}static fromJSON(t,e){if(!this.OPERATORS.includes(e?.operator))return;let r=new this(t).withFlag(...e.flags||[]);return r.path(e.lhs,e.operator,e.rhs),r}stringify(){return`${this.LHS} ${this.OPERATOR} ${this.RHS}`}static parse(t,e,r){if((t?.params?.inputDialect||t?.params?.dialect)==="mysql")return;let{tokens:i,matches:s}=m.lex(e,this.OPERATORS,{limit:1});if(!s.length)return;let n=new this(t),u=r(n,i[0],[ct,N]),o=r(n,i[1].trim(),[ct,Lt,ut]);return n.path(u,s[0],o),n}static factoryMethods={path:(t,e,r,i)=>this.OPERATORS.includes(r)&&new this(t)}};var Q=class c extends d{static ARR_RIGHT="~>";static ARR_LEFT="<~";OPERATOR="";LHS=null;RHS=null;UUID=null;get isOutgoing(){return this.OPERATOR===this.constructor.ARR_RIGHT}get isIncoming(){return this.OPERATOR===this.constructor.ARR_LEFT}get uuid(){return this.UUID||(this.UUID=`$path:${(0|Math.random()*9e6).toString(36)}`),this.UUID}path(t,e,r){let i=this.constructor;if(![i.ARR_LEFT,i.ARR_RIGHT].includes(e))throw new Error(`Unknown operator: "${e}".`);this.build("LHS",[t],N),this.build("RHS",[r],[i,rt,N]),this.OPERATOR=e}async eval(){let t=this.$trace("get:api:client"),e=this.$trace("get:node:statement");if(!t)throw new Error("No client API in context.");let r=p=>p.primaryKey()?.columns()[0],i=async(p,E)=>{let S=p.foreignKeys().find(T=>T.columns().includes(E.NAME))?.targetTable();return S&&!S.PREFIX?N.fromJSON(this,[await t.resolveName(S.NAME),S.NAME]):S};if(this.isIncoming){if(!(this.RHS instanceof c))throw new Error(`Unterminated path: ${this.RHS}`);let p,E,S,T;if(this.RHS.isIncoming){if(!(this.RHS.RHS instanceof c))throw new Error(`Unterminated path: ${this.RHS.RHS}`);({LHS:p,RHS:T}=this),{schema:S,table:E}=(await T.eval()).lhs}else if({LHS:p,RHS:{LHS:E,RHS:T}}=this,E.PREFIX||(E=N.fromJSON(this,[await t.resolveName(E.NAME),E.NAME])),S=await e.$schema(E.PREFIX,E.NAME),!S)throw new Error(`[${this}]: The implied table ${E} does not exist.`);let A=await i(S,p);if(!A)throw new Error(`[${this}]: Table ${E} does not define the implied foreign key: ${p}.`);let _=await e.$schema(A.PREFIX,A.NAME);if(!_)throw new Error(`[${this}]: The implied table ${A} does not exist.`);let C=r(_);if(!C)throw new Error(`[${this}]: Table ${_} does not define a primary key.`);return{lhs:{table:A,schema:_,primaryKey:C},rhs:{table:E,schema:S,foreignKey:p,path:T}}}let s=await er.call(this);if(!s)throw new Error("No tables in query.");let n=await e.$schema(s.PREFIX,s.NAME);if(!n)throw new Error(`[${this}]: The implied table ${s} does not exist.`);let{LHS:u,RHS:o}=this,f=await i(n,u);if(!f)throw new Error(`[${this}]: Table ${s} does not define the implied foreign key: ${u}.`);let l=await e.$schema(f.PREFIX,f.NAME);if(!l)throw new Error(`[${this}]: The implied table ${f} does not exist.`);let h=r(l);if(!h)throw new Error(`[${this}]: Table ${f} does not define a primary key.`);return{lhs:{table:s,schema:n,foreignKey:u},rhs:{table:f,schema:l,primaryKey:h,path:o}}}async plot(){if(this.JOINT)return;let t=this.$trace("get:node:statement"),e=await er.call(this);if(!e)throw new Error("No tables in query.");let{lhs:r,rhs:i}=await this.eval(),s=r.foreignKey?.NAME||r.primaryKey,n=i.primaryKey||i.foreignKey.NAME;if(r.primaryKey&&(r.table.NAME.toLowerCase()!==e.NAME.toLowerCase()||r.table.PREFIX.toLowerCase()!==e.PREFIX.toLowerCase()))throw new Error(`[${this}]: Cannot resolve incoming path to base table ${e.EXPR}.`);let u=`_view:${[s,i.table.PREFIX,i.table.NAME,n].join(":")}`,o=()=>this.JOINT=t.JOIN_LIST.find(f=>f.ALIAS.NAME.toLowerCase()===u.toLowerCase());if(!o()){let f=this.$trace("get:node:table").ALIAS?.NAME||e.NAME,l=`${n}:${(0|Math.random()*9e6).toString(36)}`;t.leftJoin(h=>h.query(p=>p.select(E=>E.name(n).as(l)),p=>p.from([i.table.PREFIX,i.table.NAME].filter(E=>E)))).with({IS_SMART_JOIN:!0}).as(u).on(h=>h.equals([u,l],[f,s])),o()}this.JOINT.EXPR.select(f=>f.expr(i.path.toJSON()).as(this.uuid))}toJSON(){return{lhs:this.LHS?.toJSON(),rhs:this.RHS?.toJSON(),operator:this.OPERATOR,flags:this.FLAGS}}static fromJSON(t,e){if(![this.ARR_LEFT,this.ARR_RIGHT].includes(e?.operator))return;let r=new this(t).withFlag(...e.flags||[]);return r.path(e.lhs,e.operator,e.rhs),r}stringify(){return this.JOINT?this.autoEsc([this.JOINT.ALIAS.NAME,this.uuid]).join("."):`${this.LHS} ${this.OPERATOR} ${this.RHS}`}static parse(t,e,r){let{tokens:i,matches:s}=m.lex(e,[this.ARR_LEFT,this.ARR_RIGHT],{limit:1});if(!s.length)return;let n=new this(t),u=r(n,i[0],[N]),o=r(n,i[1],s[0]===this.ARR_LEFT?[this]:[this,rt,N]);return n.path(u,s[0],o),n}static factoryMethods={path:(t,e,r,i)=>[this.ARR_LEFT,this.ARR_RIGHT].includes(r)&&new this(t)}};async function er(){let c=this.$trace("get:name:table");if(c){let t=this.$trace("get:name:database");return N.fromJSON(this,[t||await this.$trace("get:api:client")?.resolveName(c),c])}}var Ft=class extends d{$EXPR;ALIAS;CLAUSED;get NAME(){return this.$EXPR?.NAME}get PREFIX(){return this.$EXPR?.PREFIX}get EXPR(){return this.$EXPR?.EXPR||this.$EXPR}name(t){return this.build("$EXPR",[t],N,"name"),this}query(...t){return this.build("$EXPR",t,z,"query"),this}expr(t){return this.build("$EXPR",[t],this.constructor.exprTypes),this}as(t,e=!0){return this.build("ALIAS",[t],N),this.CLAUSED=e,this}toJSON(){return{expr:this.$EXPR?.toJSON(),alias:this.ALIAS?.toJSON(),claused:this.CLAUSED,flags:this.FLAGS}}static fromJSON(t,e){let r=new this(t).withFlag(...e.flags||[]);return e?.expr?(r.expr(e.expr),e.alias&&r.as(e.alias,e.claused)):e&&r.expr(e),r}stringify(){let t=this.ALIAS||this.$EXPR instanceof Q&&this.$EXPR.JOINT&&this.autoEsc(this.$EXPR.clone().stringify());return[this.$EXPR,this.CLAUSED?"AS":"",t].filter(e=>e).join(" ")}static parse(t,e,r){let i=new this(t),s=this.getEscChar(t,!0),[,n,u,o,,f]=new RegExp(`^([\\s\\S]+?)(?:(\\s+AS\\s+|(?<!(?:~>|<~))\\s+)(?:([\\w]+)|(${s})((?:\\4\\4|[^\\4])+)\\4))?$`,"i").exec(e.trim())||[],l,h=o||f;if(h&&!u?.trim()&&!n.trim().endsWith(")")){try{l=r(i,n,this.exprTypes)}catch{}l||(h=o=f=null,n=e)}if(l||(l=r(i,n,this.exprTypes)),i.expr(l),h){let p=o||this.autoUnesc(i,f),E=!!u?.trim();i.as(p,E)}return i}static get exprTypes(){return I.Types.filter(t=>t!==pt)}};var D=class extends Ft{static get exprTypes(){return[z,N]}};var U=class extends D{TYPE="";CORRELATION=null;full(t){return this.TYPE="JOIN",this.expr(t),this}left(t){return this.TYPE="LEFT_JOIN",this.expr(t),this}right(t){return this.TYPE="RIGHT_JOIN",this.expr(t),this}inner(t){return this.TYPE="INNER_JOIN",this.expr(t),this}cross(t){return this.TYPE="CROSS_JOIN",this.expr(t),this}on(...t){return this.build("CORRELATION",t,b,"and")}using(t){return this.build("CORRELATION",[t],N)}toJSON(){return{type:this.TYPE,correlation:this.CORRELATION?.toJSON(),...super.toJSON()}}static fromJSON(t,e){let r=super.fromJSON(t,e);if(!(!r||!e.type))return e?.expr&&e.type&&(r.TYPE=e.type),e?.expr&&e.correlation&&r.build("CORRELATION",[e.correlation],[N,b]),r}stringify(){return[this.TYPE?.replace(/_/," ").toUpperCase()||"JOIN",super.stringify(),this.CORRELATION instanceof N?`USING ${this.CORRELATION}`:`ON ${this.CORRELATION}`].filter(t=>t).join(" ")}static parse(t,e,r){let[i,s,n]=e.match(new RegExp(`^${this.regex}([\\s\\S]*)$`,"i"))||[];if(!i)return;let{tokens:[u,o],matches:f}=m.lex(n,["\\s+(?:ON|USING)\\s+"],{useRegex:"i"}),l=super.parse(t,u.trim(),r);return l.TYPE=s.trim().toUpperCase()+"_JOIN",/USING/i.test(f[0])?l.using(r(l,o.trim(),[N])):/ON/i.test(f[0])&&l.on(r(l,o.trim(),[b,F])),l}static regex="(INNER\\s+|CROSS\\s+|(?:LEFT|RIGHT)(?:\\s+OUTER)?\\s+)?JOIN"};var Et=class extends d{NAME="";ARGS=[];fn(t,...e){return this.NAME=t,this.build("ARGS",e,I.Types)}toJSON(){return{name:this.NAME,args:this.ARGS.map(t=>t.toJSON()),flags:this.FLAGS}}static fromJSON(t,e){if(typeof e?.name!="string"||!Array.isArray(e.args))return;let r=new this(t).withFlag(...e.flags||[]);return r.fn(e.name,...e.args),r}stringify(){return`${this.NAME.toUpperCase()}(${this.ARGS.join(", ")})`}static parse(t,e,r){if(!e.endsWith(")")||m.match(e,[" "]).length)return;let[,i,s=""]=/^(\w+)\(([\s\S]+)?\)$/i.exec(e),n=new this(t);return n.fn(i,...m.split(s,[","]).map(u=>r(n,u.trim()))),n}};var oe=class extends d{CRITERIA=[];criterion(...t){return this.build("CRITERIA",t,I.Types)}toJSON(){return{criteria:this.CRITERIA.map(t=>t.toJSON()),flags:this.FLAGS}}static fromJSON(t,e){if(!Array.isArray(e?.criteria))return;let r=new this(t).withFlag(...e.flags||[]);return r.criterion(...e.criteria),r}stringify(){return this.CRITERIA.map(t=>[t,...t.FLAGS].join(" ")).join(", ")}static parse(t,e,r){let[i,s]=e.match(new RegExp(`^${this.regex}([\\s\\S]*)$`,"i"))||[];if(!i)return;let n=new this(t);for(let u of m.split(s.trim(),[","])){let[,o,f]=/([\s\S]+)\s+(ASC|DESC)$/i.exec(u)||[,u];n.criterion(r(n,o).withFlag(f))}return n}static regex="ORDER\\s+BY"};var v=class extends oe{withRollup(){return this.withFlag("WITH_ROLLUP")}stringify(){return["ORDER BY",super.stringify(),...this.FLAGS.map(t=>t.replace(/_/g," "))].join(" ")}static parse(t,e,r){let{tokens:[i],matches:s}=m.lex(e,["\\s+WITH\\s+ROLLUP$"],{useRegex:"i"}),n=super.parse(t,i.trim(),r);if(n)return s.length&&n.withFlag("WITH_ROLLUP"),n}};var vt=class extends d{CRITERIA=[];criterion(...t){return this.build("CRITERIA",t,I.Types)}stringify(){return this.CRITERIA.map(t=>t.stringify()).join(",")}toJSON(){return{criteria:this.CRITERIA.map(t=>t.toJSON()),flags:this.FLAGS}}static fromJSON(t,e){if(!Array.isArray(e?.criteria))return;let r=new this(t).withFlag(...e.flags||[]);return r.criterion(...e.criteria),r}static parse(t,e,r){let[i,s]=e.match(new RegExp(`^${this.regex}([\\s\\S]*)$`,"i"))||[];if(!i)return;let n=new this(t);for(let u of m.split(s.trim(),[","]))n.criterion(r(n,u));return n}static regex="GROUP\\s+BY"};var Qt=class extends vt{stringify(){return["PARTITION BY",super.stringify()].join(" ")}static regex="PARTITION\\s+BY"};var It=class extends d{NAME;WINDOW_REF;PARTITION_BY_CLAUSE;ORDER_BY_CLAUSE;name(t){return this.NAME=t,this}existing(t){return this.WINDOW_REF=t,this}extends(t){return this.WINDOW_REF=t,this}partitionBy(...t){if(this.WINDOW_REF)throw new Error("The PARTITION BY clause is not allowed when inheriting from a base window.");return this.build("PARTITION_BY_CLAUSE",t,Qt,"criterion")}orderBy(...t){return this.build("ORDER_BY_CLAUSE",t,v,"criterion")}toJSON(){return{name:this.NAME,window_ref:this.WINDOW_REF,partition_by_clause:this.PARTITION_BY_CLAUSE?.toJSON(),order_by_clause:this.ORDER_BY_CLAUSE?.toJSON()}}static fromJSON(t,e){if(typeof e=="string")e={window_ref:e};else if(!(typeof e=="object"&&e)||!["name","window_ref","partition_by_clause","order_by_clause"].some(i=>i in e))return;let r=new this(t);return e.name&&r.name(e.name),e.window_ref&&r.extends(e.window_ref),e.partition_by_clause&&r.partitionBy(e.partition_by_clause),e.order_by_clause&&r.orderBy(e.order_by_clause),r}stringify(){let t=[];return!this.NAME&&this.WINDOW_REF&&!this.PARTITION_BY_CLAUSE&&!this.ORDER_BY_CLAUSE?t.push(this.WINDOW_REF):(this.NAME&&t.push(`${this.NAME} AS `),t.push(`(${[this.WINDOW_REF,this.PARTITION_BY_CLAUSE,this.ORDER_BY_CLAUSE].filter(e=>e).join(" ")})`)),t.join("")}static parse(t,e,r){let i=new this(t),s=async o=>{let{tokens:[f,...l],matches:h}=m.lex(w(o.trim(),"(",")"),["PARTITION\\s+BY","ORDER\\s+BY"],{useRegex:"i",preserveDelims:!0});f.trim()&&i.extends(f.trim());for(let p of h){if(/PARTITION\s+BY/i.test(p)){i.partitionBy(r(i,l.shift().trim(),[Qt]));continue}i.orderBy(r(i,l.shift().trim(),[v]))}},n=e.endsWith(")");if(n&&!e.startsWith("(")){let[o,f]=spec.split(new RegExp(" AS ","i"));i.name(o.trim()),s(f)}else n?s(e):i.existing(e);return i}static regex="WINDOW|OVER"};var ft=class extends Et{ORDER_BY_CLAUSE;OVER_CLAUSE;fn(...t){return super.fn(...t),this}orderBy(...t){return this.build("ORDER_BY_CLAUSE",t,v,"criterion"),this}over(t){return t||(t={name:""}),this.build("OVER_CLAUSE",[t],It),this.OVER_CLAUSE}toJSON(){return{...super.toJSON(),order_by_clause:this.ORDER_BY_CLAUSE?.toJSON(),over_clause:this.OVER_CLAUSE?.toJSON()}}static fromJSON(t,e){let r=super.fromJSON(t,e);if(r)return this.names.flat().includes(r.NAME.toUpperCase())&&(e.order_by_clause&&r.orderBy(e.order_by_clause),e.over_clause&&r.over(e.over_clause)),r}stringify(){return`${this.NAME.toUpperCase()}(${[...this.FLAGS,this.ARGS.join(","),this.ORDER_BY_CLAUSE].filter(e=>e).join(" ")})`+(this.OVER_CLAUSE?` OVER ${this.OVER_CLAUSE}`:"")}static parse(t,e,r){let[i,s]=m.split(e,["OVER\\s+"],{useRegex:"i"}).map(p=>p.trim());if(!i.endsWith(")")||m.match(i,[" "]).length)return;let[,n,u,o=""]=/^(\w+)\((?:\s+)?(?:(ALL|DISTINCT)\s+)?([\s\S]+)?\)$/i.exec(i);if(!this.names.flat().includes(n.toUpperCase()))return;let[,f,l]=/^([\s\S]+)(?:\s+(ORDER\s+BY\s+.+))$/i.exec(o)||[,o],h=super.parse(t,`${n}(${f})`,r);return u&&h.withFlag(u),l?h.orderBy(r(h,l,[v])):s&&h.over(r(h,s,[It])),h}static factoryMethods={fn:(t,e,...r)=>this.names.flat().includes(e?.toUpperCase())&&new this(t)};static names=[["AVG","BIT_AND","BIT_OR","BIT_XOR","COUNT","JSON_ARRAYAGG","JSON_OBJECTAGG","MAX","MIN","STDDEV_POP","STDDEV","STD","STDDEV_SAMP","SUM","VAR_POP","VARIANCE","VAR_SAMP","GROUP_CONCAT","GROUP_CONCAT_WS"],["CUME_DIST","DENSE_RANK","FIRST_VALUE","LAG","LAST_VALUE","LEAD","NTH_VALUE","NTLE","PERCENT_RANK","RANK","ROW_NUMBER"],["ANY_VALUE","COLUMN","COLUMNS","GROUPING"]]};var W=class extends Ft{path(t,e,r){return this.build("$EXPR",[t,e,r],rt.OPERATORS.includes(e)?rt:Q,"path"),this}fn(t,...e){return this.build("$EXPR",[t,...e],ft.names.flat().includes(t.toUpperCase())?ft:Et,"fn"),this}case(...t){return this.build("$EXPR",t,Pt),this}};var zt=class extends d{WINDOWS_LIST=[];define(...t){return this.build("WINDOWS_LIST",t,It)}toJSON(){return{window_list:this.WINDOWS_LIST.map(t=>t.toJSON())}}static fromJSON(t,e){if(!Array.isArray(e?.window_list))return;let r=new this(t);return r.define(...e.window_list),r}stringify(){return`WINDOW ${this.WINDOWS_LIST.join(",")}`}static parse(t,e,r){let[i,s]=e.match(new RegExp(`^${this.regex}([\\s\\S]*)$`,"i"))||[];if(!i)return;let n=new this(t);for(let u of m.split(s,[","]))n.define(r(n,u.trim(),[Window]));return n}static regex="WINDOW"};var Zt=class extends vt{withRollup(){return this.withFlag("WITH_ROLLUP")}stringify(){return["GROUP BY",super.stringify(),...this.FLAGS.map(t=>t.replace(/_/g," "))].join(" ")}static parse(t,e,r){let{tokens:[i],matches:s}=m.lex(e,["\\s+WITH\\s+ROLLUP$"],{useRegex:"i"}),n=super.parse(t,i,r);if(n)return s.length&&n.withFlag("WITH_ROLLUP"),n}};var H=class c extends et{SELECT_LIST=[];FROM_LIST=[];JOIN_LIST=[];WHERE_CLAUSE=null;GROUP_BY_CLAUSE=null;HAVING_CLAUSE=null;WINDOW_CLAUSE=null;ORDER_BY_CLAUSE=null;OFFSET_CLAUSE=null;LIMIT_CLAUSE=null;UNION_CLAUSE=null;AGGRS=[];PATHS=[];VARS=[];SUBQUERIES=[];$trace(t,...e){return t==="get:node:table"?this.FROM_LIST[0]:(t==="event:connected"&&(e[0]instanceof ft&&this.AGGRS.push(e[0]),e[0]instanceof Q&&!(e[0].CONTEXT instanceof Q)&&this.PATHS.push(e[0]),e[0]instanceof Jt&&this.VARS.push(e[0]),e[0]instanceof c&&this.SUBQUERIES.push(e[0])),super.$trace(t,...e))}select(...t){return this.build("SELECT_LIST",t,W)}from(...t){return this.build("FROM_LIST",t,D),this.FROM_LIST[this.FROM_LIST.length-1]}join(t){return this.build("JOIN_LIST",[t],U,"full")}leftJoin(t){return this.build("JOIN_LIST",[t],U,"left")}rightJoin(t){return this.build("JOIN_LIST",[t],U,"right")}innerJoin(t){return this.build("JOIN_LIST",[t],U,"inner")}crossJoin(t){return this.build("JOIN_LIST",[t],U,"cross")}where(...t){return this.build("WHERE_CLAUSE",t,b,"and")}groupBy(...t){return this.build("GROUP_BY_CLAUSE",t,Zt,"criterion"),this.GROUP_BY_CLAUSE}having(...t){return this.build("HAVING_CLAUSE",t,b,"and")}window(...t){return this.build("WINDOW_CLAUSE",t,zt,"define")}orderBy(...t){return this.build("ORDER_BY_CLAUSE",t,v,"criterion"),this.ORDER_BY_CLAUSE}offset(t){if(typeof t!="number")throw new Error("Offsets must be of type number.");this.OFFSET_CLAUSE=t}limit(...t){if(!t.every(e=>typeof e=="number"))throw new Error("Limits must be of type number.");this.LIMIT_CLAUSE=t}union(...t){return this.build("UNION_CLAUSE",t,this.constructor,"select"),this.UNION_CLAUSE}get expandable(){return this.PATHS.length>0||this.SUBQUERIES.some(t=>t.expandable)}async expand(t=!1){let e=t?this:this.clone();if(!e.expandable)return e;for(let r of e.PATHS)await r.plot();for(let r of e.SUBQUERIES)await r.expand(!0);return e}toJSON(){return{select_list:this.SELECT_LIST.map(t=>t.toJSON()),from_list:this.FROM_LIST.map(t=>t.toJSON()),join_list:this.JOIN_LIST.map(t=>t.toJSON()),where_clause:this.WHERE_CLAUSE?.toJSON(),group_by_clause:this.GROUP_BY_CLAUSE?.toJSON(),having_clause:this.HAVING_CLAUSE?.toJSON(),window_clause:this.WINDOW_CLAUSE?.toJSON(),order_by_clause:this.ORDER_BY_CLAUSE?.toJSON(),offset_clause:this.OFFSET_CLAUSE,limit_clause:this.LIMIT_CLAUSE,union_clause:this.UNION_CLAUSE,flags:this.FLAGS}}static fromJSON(t,e){if(!Array.isArray(e?.select_list))return;let r=new this(t).withFlag(...e.flags||[]);return r.select(...e.select_list),e.from_list?.length&&r.from(...e.from_list),e.join_list?.length&&r.join(...e.join_list),e.where_clause&&r.where(e.where_clause),e.group_by_clause&&r.groupBy(e.group_by_clause),e.having_clause&&r.having(e.having_clause),e.window_clause&&r.window(e.window_clause),e.order_by_clause&&r.orderBy(e.order_by_clause),e.offset_clause&&r.offset(e.offset_clause),e.limit_clause&&r.limit(e.limit_clause),e.union_clause&&r.union(e.union_clause),r}stringify(t={}){let e=["SELECT"];return this.FLAGS.length&&e.push(this.FLAGS.map(r=>r.replace(/_/g," "))),e.push(this.SELECT_LIST.join(", ")),this.FROM_LIST.length&&e.push("FROM",this.FROM_LIST.join(", ")),this.JOIN_LIST.length&&e.push(...this.JOIN_LIST),this.WHERE_CLAUSE&&e.push("WHERE",this.WHERE_CLAUSE),this.GROUP_BY_CLAUSE&&e.push(this.GROUP_BY_CLAUSE),this.HAVING_CLAUSE&&e.push("HAVING",this.HAVING_CLAUSE),this.WINDOW_CLAUSE&&e.push(this.WINDOW_CLAUSE),this.ORDER_BY_CLAUSE&&e.push(this.ORDER_BY_CLAUSE),this.OFFSET_CLAUSE&&e.push("OFFSET",this.OFFSET_CLAUSE),this.LIMIT_CLAUSE&&e.push("LIMIT",(Array.isArray(this.LIMIT_CLAUSE)?this.LIMIT_CLAUSE:[this.LIMIT_CLAUSE]).join(",")),this.UNION_CLAUSE&&e.push("UNION",this.UNION_CLAUSE),e.join(" ")}static parse(t,e,r){let[i,s,n,u]=/^SELECT\s+(?:(WITH\s+UAC)\s+)?(ALL|DISTINCT)?([\s\S]+)$/i.exec(e.trim())||[];if(!i)return;let o=new this(t);s&&o.withFlag("WITH_UAC"),n&&o.withFlag(n);let f=this.mySubstitutePlaceholders(o,u.trim()),l={from:{backtest:"^(?!.*\\s+DISTINCT\\s+$)",test:"FROM"},join:U,where:"WHERE",groupBy:Zt,having:"HAVING",window:zt,orderBy:v,offset:"OFFSET",limit:"LIMIT",union:"UNION"},{tokens:[h,...p],matches:E}=m.lex(f,Object.values(l).map(S=>typeof S=="string"||S.test?S:S.regex),{useRegex:"i"});for(let S of m.split(h,[","])){let T=r(o,S.trim(),[W]);o.select(T)}for(let S of E){let T=S.replace(/\s+/g,""),A=Object.keys(l).find(_=>new RegExp(_,"i").test(T));if(A==="from")for(let _ of m.split(p.shift(),[","])){let C=r(o,_.trim(),[D]);o.from(C)}else if(["where","having"].includes(A)){let _=r(o,p.shift().trim(),[b,F]);o[A](_)}else if(A==="UNION"){let _=r(o,p.shift().trim(),[this]);o[A](_)}else if(["offset","limit"].includes(A)){let _=p.shift().split(",").map(C=>parseInt(C.trim()));o[A](..._)}else{let _=r(o,`${S} ${p.shift().trim()}`,[l[A]]);o[A](_)}}return o}};var z=class extends d{$EXPR;constructor(t,e){super(t),this.$EXPR=e}get NAME(){return this.$EXPR?.NAME}get PREFIX(){return this.$EXPR?.PREFIX}get EXPR(){return this.$EXPR?.EXPR||this.$EXPR}query(...t){return this.build("$EXPR",t,H),this.$EXPR}expr(...t){return this.build("$EXPR",t,[H,...I.Types]),this.$EXPR}toJSON(){return{expr:this.$EXPR?.toJSON(),flags:this.FLAGS}}static fromJSON(t,e){if(!e?.expr||Object.keys(e).length!==(e.flags?2:1))return;let r=new this(t).withFlag(...e.flags||[]);return r.expr(e.expr),r}stringify(){return"("+this.$EXPR.stringify()+")"}static parse(t,e,r){if(!(!x(e,"(",")")||m.match(e,[" "]).length&&m.split(e,[]).length===2))return new this(t,r(t,w(e,"(",")"),[H,...I.Types]))}};var b=class c extends d{LOGIC="";ASSERTIONS=[];constructor(t,e){super(t),this.LOGIC=e}and(...t){return this.LOGIC==="OR"?new this.constructor(this).and(this,...t):(this.LOGIC="AND",this.build("ASSERTIONS",t,[c,F,z]),this)}or(...t){return this.LOGIC==="AND"?new this.constructor(this).or(this,...t):(this.LOGIC="OR",this.build("ASSERTIONS",t,[c,F,z]),this)}toJSON(){return{logic:this.LOGIC,assertions:this.ASSERTIONS.map(t=>t.toJSON()),flags:this.FLAGS}}static fromJSON(t,e){if(typeof e?.logic!="string"||!/AND|OR/i.test(e.logic)||!Array.isArray(e.assertions))return;let r=new this(t).withFlag(...e.flags||[]);return r[e.logic.toLowerCase()](...e.assertions),r}stringify(){return this.ASSERTIONS.map(t=>t instanceof c?`(${t.stringify()})`:t.stringify()).join(" "+this.LOGIC+" ")}static parse(t,e,r){for(let i of["AND","OR"]){let s=m.split(e,[`\\s+${i}\\s+`],{useRegex:"i"});if(s.length>1){let n=new this(t,i);for(let u of s)n[i.toLowerCase()](r(n,u));return n}}}};var ue=class extends d{OPERAND=null;TYPE="";SYNTAX2=!1;cast(t,e,r=!1){return this.TYPE=e,this.SYNTAX2=r,this.build("OPERAND",[t],I.Types)}toJSON(){return{operand:this.OPERAND?.toJSON(),type:this.TYPE,syntax2:this.SYNTAX2,flags:this.FLAGS}}static fromJSON(t,e){if(!e?.operand||!e?.type)return;let r=new this(t).withFlag(...e.flags||[]);return r.cast(e.operand,e.type,e.syntax2),r}stringify(){return this.SYNTAX2?`${this.OPERAND}::${this.TYPE}`:`CAST(${this.OPERAND} AS ${this.TYPE})`}static parse(t,e,r){let i,s,n=!1;if(/^CAST(?:\s+)?\([\s\S]+\)$/i.test(e)){let[,o]=m.split(e,[]);[i,s]=m.split(o.slice(1,-1),["AS"],{useRegex:"i"})}else{if((t?.params?.inputDialect||t?.params?.dialect)==="mysql"||([i,s]=m.split(e,["::"]),!s))return;n=!0}let u=new this(t);return u.cast(r(u,i.trim()),s.trim(),n),u}};var ce=class extends d{OPERATOR="";OPERANDS=[];constructor(t,e,...r){super(t),this.OPERATOR=e,this.OPERANDS=r}calc(t,...e){return this.OPERATOR&&this.OPERATOR!==t?new this.constructor(this).calc(t,this,...e):(this.OPERATOR=t,this.build("OPERANDS",e,I.Types),this)}sum(...t){return this.calc("+",...t)}sub(...t){return this.calc("-",...t)}div(...t){return this.calc("/",...t)}times(...t){return this.calc("*",...t)}toJSON(){return{operator:this.OPERATOR,operands:this.OPERANDS.map(t=>t.toJSON()),flags:this.FLAGS}}static fromJSON(t,e){if(typeof e?.operator!="string"||!/\+|\-|\*|\//.test(e.operator)||!Array.isArray(e.operands))return;let r=new this(t).withFlag(...e.flags||[]);return r.calc(e.operator,...e.operands),r}stringify(){return this.OPERANDS.join(` ${this.OPERATOR} `)}static parse(t,e,r){for(let i of["\\*","\\/","\\+","\\-"]){let{tokens:s,matches:n}=m.lex(e,[`(\\s+)?${i}(\\s+)?`],{useRegex:"i"});if(!(s.filter(u=>u.trim()).length<2))return new this(t,n.pop().trim(),...s.map(u=>r(t,u.trim())))}}};var fe=class extends d{STRINGS=[];join(...t){return this.build("STRINGS",t,I.Types)}toJSON(){return{strings:this.STRINGS.map(t=>t.toJSON()),flags:this.FLAGS}}static fromJSON(t,e){if(!Array.isArray(e?.strings))return;let r=new this(t).withFlag(...e.flags||[]);return r.join(...e.strings),r}stringify(){return this.STRINGS.join(" || ")}static parse(t,e,r){if((t?.params?.inputDialect||t?.params?.dialect)==="mysql")return;let i=m.split(e,["||"]);if(i.length<2)return;let s=new this(t);return s.join(...i.map(n=>r(s,n.trim()))),s}};var I=class{static cast(t,e,r=this.Types){if(typeof e=="function"){if(r.length===1){let n=new r[0](t);return e(n),n}let i,s=n=>(...u)=>{let o=r.reduce((f,l)=>f||(l.factoryMethods?typeof l.factoryMethods[n]=="function"&&l.factoryMethods[n](t,...u):typeof l.prototype[n]=="function"&&new l(t)),null);if(!o)throw new Error(`Unknown method: ${n}()`);if(i=o,o[n])return o[n](...u);for(let f of u)f(o)};return e(new Proxy({},{get:(n,u)=>s(u)})),i}return this.fromJSON(t,e,r)}static fromJSON(t,e,r=this.Types){let i=r.find(s=>e instanceof s)?e:r.reduce((s,n)=>s||n.fromJSON(t,e),null);if(!i)throw new Error("");return i}static parse(t,e,r){return r(t,e,this.Types)}static get Types(){return[z,Pt,fe,b,Q,rt,F,ce,ue,ft,Et,ct,Lt,ut,Jt,N,pt]}};var St=class extends d{LIST=[];list(...t){return this.build("LIST",t,N),this}toJSON(){return{list:this.LIST.map(t=>t.toJSON())}}static fromJSON(t,e){if(Array.isArray(e?.list))return new this(t).list(...e.list)}stringify(){return`(${this.LIST.join(", ")})`}static parse(t,e,r){if(!x(e,"(",")"))return;let i=new this(t);return i.list(...m.split(w(e,"(",")"),[","]).map(s=>r(i,s.trim(),[N]))),i}};var Nt=class extends d{LIST=[];list(...t){return this.build("LIST",t,I.Types),this}toJSON(){return{list:this.LIST.slice(0)}}static fromJSON(t,e){if(Array.isArray(e?.list))return new this(t).list(...e.list)}stringify(){return`(${this.LIST.join(", ")})`}static parse(t,e,r){if(!x(e,"(",")"))return;let i=new this(t);return i.list(...m.split(w(e,"(",")"),[","]).map(s=>r(i,s.trim(),I.Types))),i}};var it=class extends d{ENTRIES=[];set(t,e){return Array.isArray(t)?(t=St.fromJSON(this,t),Array.isArray(e)?e=Nt.fromJSON(this,e):e=I.cast(this,e)):(t=t instanceof d?t:N.fromJSON(this,t),e=e instanceof d?e:I.cast(this,e)),this.ENTRIES.push([t,e]),this}toJSON(){return{entries:this.ENTRIES.map(([t,e])=>[t.toJSON(),e.toJSON()])}}static fromJSON(t,e){if(!Array.isArray(e?.entries))return;let r=new this(t);for(let[i,s]of e.entries)r.set(i,s);return r}stringify(){return`
	${this.ENTRIES.map(([t,e])=>`${t} = ${e}`).join(`,
	`)}`}static parse(t,e,r){let i=new this(t);for(let s of m.split(e,[","])){let[n,u]=m.split(s,["="]).map(o=>o.trim()).filter(o=>o);if(!u)return;if(x(n,"(",")")){let o=r(i,u.trim(),[St]);if(!x(u,"(",")"))return;let f=/^\((\s+)?SELECT\s+/i.test(u)?r(i,u.trim()):r(i,u.trim(),[Nt]);i.set(o,f)}else{let o=r(i,n),f=r(i,u);i.set(o,f)}}return i}};var jt=class extends it{WHERE_CLAUSE=null;CONFLICT_TARGET=[];target(...t){return this.build("CONFLICT_TARGET",t,N),this}where(...t){return this.build("WHERE_CLAUSE",t,b,"and"),this}toJSON(){return{...super.toJSON(),conflict_target:this.CONFLICT_TARGET.map(t=>t.toJSON()),where_clause:this.WHERE_CLAUSE?.toJSON()}}static fromJSON(t,e){let r=super.fromJSON(t,e);if(r)return e.conflict_target&&r.target(...[].concat(e.conflict_target)),e.where_clause&&r.where(e.where_clause),r}stringify(){let t=[];return this.params.dialect==="mysql"?t.push("ON DUPLICATE KEY UPDATE"):t.push(`ON CONFLICT ${this.CONFLICT_TARGET.length?`(${this.CONFLICT_TARGET.join(", ")})`:""} ${this.ENTRIES.length?"DO UPDATE SET":"DO NOTHING"}`),t.push(super.stringify()),this.WHERE_CLAUSE&&t.push("WHERE",this.WHERE_CLAUSE),t.join(" ")}static parse(t,e,r){let[i,s,n,u]=e.match(new RegExp(`^${this.regex}([\\s\\S]*)$`,"i"))||[];if(!i)return;if(/DO\s+NOTHING/i.test(n))return new this(t);let[o,f]=m.split(u,["WHERE"],{ci:!0}),l=super.parse(t,o,r);if(s){let h=m.split(x(s,"(",")")?w(s,"(",")"):s,[","]).map(p=>r(l,p.trim(),[N]));l.target(...h)}return f&&l.where(r(l,f.trim(),[b,F])),l}static regex="ON\\s+(?:DUPLICATE\\s+KEY|CONFLICT(?:\\s+([\\s\\S]+))?)\\s+(UPDATE|DO\\s+NOTHING|DO\\s+UPDATE\\s+SET\\s+)"};var Z=class extends et{TABLE=null;COLUMNS_CLAUSE=null;VALUES_LIST=[];SET_CLAUSE=null;SELECT_CLAUSE=null;ON_CONFLICT_CLAUSE=null;RETURNING_LIST=[];$trace(t,...e){return t==="get:node:table"?this.TABLE:super.$trace(t,...e)}into(t){return this.build("TABLE",[t],D)}columns(...t){return this.build("COLUMNS_CLAUSE",t,St,"list")}values(...t){return this.build("VALUES_LIST",t,Nt,"list")}set(...t){return this.build("SET_CLAUSE",t,it,"set")}select(t){return this.build("SELECT_CLAUSE",[t],H)}onConflict(...t){return this.build("ON_CONFLICT_CLAUSE",t,jt)}returning(...t){return this.build("RETURNING_LIST",t,W)}toJSON(){return{table:this.TABLE.toJSON(),columns_clause:this.COLUMNS_CLAUSE?.toJSON(),values_list:this.VALUES_LIST.map(t=>t.toJSON()),set_clause:this.SET_CLAUSE?.toJSON(),select_clause:this.SELECT_CLAUSE?.toJSON(),on_conflict_clause:this.ON_CONFLICT_CLAUSE?.toJSON(),returning_list:this.RETURNING_LIST.slice(0),flags:this.FLAGS}}static fromJSON(t,e){if(!e?.table)return;let r=new this(t).withFlag(...e.flags||[]);return r.into(e.table),e.columns_clause&&r.columns(e.columns_clause),e.values_list?.length&&r.values(...e.values_list),e.set_clause&&r.set(e.set_clause),e.select_clause&&r.select(e.select_clause),e.on_conflict_clause&&r.onConflict(e.on_conflict_clause),e.returning_list?.length&&r.returning(...e.returning_list),r}stringify(){let t=["INSERT"];return this.FLAGS.length&&t.push(this.FLAGS.map(e=>e.replace(/_/g," "))),t.push("INTO",this.TABLE),this.SET_CLAUSE?t.push("SET",this.SET_CLAUSE):(this.COLUMNS_CLAUSE&&t.push(this.COLUMNS_CLAUSE),this.SELECT_CLAUSE?t.push(this.SELECT_CLAUSE):t.push("VALUES",this.VALUES_LIST)),this.ON_CONFLICT_CLAUSE&&t.push(this.ON_CONFLICT_CLAUSE),this.RETURNING_LIST.length&&t.push("RETURNING",this.RETURNING_LIST.join(", ")),t.join(" ")}static parse(t,e,r){let[i,s,n,u]=/^INSERT(\s+WITH\s+UAC)?(?:\s+(IGNORE))?(?:\s+INTO)?([\s\S]+)$/i.exec(e.trim())||[];if(!i)return;let o=this.mySubstitutePlaceholders(t,u.trim()),{tokens:[f,l,h,p],matches:[E,S]}=m.lex(o,["(VALUES|VALUE|SET|SELECT)","ON\\s+(DUPLICATE\\s+KEY|CONFLICT)","RETURNING"],{useRegex:"i"}),T=new this(t);if(s&&T.withFlag("WITH_UAC"),n&&T.withFlag(n),/^SET$/i.test(E))T.into(r(T,f,[D])),T.set(r(T,l.trim(),[it]));else{let A=m.split(f,[]);if(T.into(r(T,A.shift().trim(),[D])),A.length&&T.columns(r(T,A.shift().trim(),[St])),/^SELECT$/i.test(E))T.select(r(T,`SELECT ${l}`));else for(let _ of m.split(l,[","]))T.values(r(T,_.trim(),[Nt]))}return S&&T.onConflict(r(T,`${S} ${h}`,[jt])),p&&T.returning(...m.split(p,[","]).map(A=>r(T,A.trim(),[W]))),T}};var At=class extends et{TABLE_LIST=[];JOIN_LIST=[];SET_CLAUSE=null;WHERE_CLAUSE=null;ORDER_BY_CLAUSE=null;LIMIT_CLAUSE=null;RETURNING_LIST=[];$trace(t,...e){return t==="get:node:table"?this.TABLE_LIST[0]:super.$trace(t,...e)}table(...t){return this.build("TABLE_LIST",t,D)}join(t){return this.build("JOIN_LIST",[t],U,"full")}leftJoin(t){return this.build("JOIN_LIST",[t],U,"left")}rightJoin(t){return this.build("JOIN_LIST",[t],U,"right")}innerJoin(t){return this.build("JOIN_LIST",[t],U,"inner")}crossJoin(t){return this.build("JOIN_LIST",[t],U,"cross")}set(...t){return this.build("SET_CLAUSE",t,it,"set")}where(...t){return this.build("WHERE_CLAUSE",t,b,"and")}orderBy(...t){return this.build("ORDER_BY_CLAUSE",t,v,"criterion"),this.ORDER_BY_CLAUSE}limit(...t){if(!t.every(e=>typeof e=="number"))throw new Error("Limits must be of type number.");this.LIMIT_CLAUSE=t}returning(...t){return this.build("RETURNING_LIST",t,W)}toJSON(){return{table_list:this.TABLE_LIST.map(t=>t.toJSON()),join_list:this.JOIN_LIST.map(t=>t.toJSON()),set_clause:this.SET_CLAUSE?.toJSON(),where_clause:this.WHERE_CLAUSE?.toJSON(),order_by_clause:this.ORDER_BY_CLAUSE?.toJSON(),limit_clause:this.LIMIT_CLAUSE,returning_list:this.RETURNING_LIST,flags:this.FLAGS}}static fromJSON(t,e){if(!Array.isArray(e?.table_list))return;let r=new this(t).withFlag(...e.flags||[]);return r.table(...e.table_list),e.join_list?.length&&r.join(...e.join_list),e.set_clause&&r.set(e.set_clause),e.where_clause&&r.where(e.where_clause),e.order_by_clause&&r.orderBy(e.order_by_clause),e.limit_clause&&r.limit(e.limit_clause),e.returning_list?.length&&r.returning(...e.returning_list),r}stringify(){let t=["UPDATE"];return this.FLAGS.length&&t.push(this.FLAGS.map(e=>e.replace(/_/g," "))),t.push(this.TABLE_LIST.join(", ")),this.JOIN_LIST.length&&t.push(...this.JOIN_LIST),t.push("SET",this.SET_CLAUSE),this.WHERE_CLAUSE&&t.push("WHERE",this.WHERE_CLAUSE),this.ORDER_BY_CLAUSE&&t.push(this.ORDER_BY_CLAUSE),this.LIMIT_CLAUSE&&t.push("LIMIT",this.LIMIT_CLAUSE),this.RETURNING_LIST.length&&t.push("RETURNING",this.RETURNING_LIST.join(", ")),t.join(" ")}static parse(t,e,r){let[i,s,n,u]=/^UPDATE(\s+WITH\s+UAC)?(?:\s+(IGNORE))?([\s\S]+)$/i.exec(e.trim())||[];if(!i)return;let o=new this(t);s&&o.withFlag("WITH_UAC"),n&&o.withFlag(n);let f=this.mySubstitutePlaceholders(o,u.trim()),l={join:U,set:"SET",where:"WHERE",orderBy:v,limit:"LIMIT",returning:"RETURNING"},{tokens:[h,...p],matches:E}=m.lex(f,Object.values(l).map(S=>typeof S=="string"||S.test?S:S.regex),{useRegex:"i"});for(let S of m.split(h,[","])){let T=r(o,S.trim(),[D]);o.table(T)}for(let S of E){let T=S.replace(/\s+/g,""),A=Object.keys(l).find(_=>new RegExp(_,"i").test(T));if(A==="set"){let _=r(o,p.shift().trim(),[it]);o.set(_)}else if(A==="where"){let _=r(o,p.shift().trim(),[b,F]);o.where(_)}else if(A==="limit")o.limit(parseInt(p.shift().trim()));else if(A==="returning")o.returning(...m.split(p.shift(),[","]).map(_=>r(o,_.trim(),[W])));else{let _=r(o,`${S} ${p.shift().trim()}`,[l[A]]);o[A](_)}}return o}};var lt=class extends et{DELETE_LIST=[];FROM_LIST=[];USING_LIST=[];JOIN_LIST=[];WHERE_CLAUSE=null;ORDER_BY_CLAUSE=null;LIMIT_CLAUSE=null;RETURNING_LIST=[];$trace(t,...e){return t==="get:node:table"?this.USING_LIST[0]||this.FROM_LIST[0]:super.$trace(t,...e)}delete(...t){return this.build("DELETE_LIST",t,N)}from(...t){return this.build("FROM_LIST",t,[N,D])}using(...t){return this.build("USING_LIST",t,D)}join(t){return this.build("JOIN_LIST",[t],U,"full")}leftJoin(t){return this.build("JOIN_LIST",[t],U,"left")}rightJoin(t){return this.build("JOIN_LIST",[t],U,"right")}innerJoin(t){return this.build("JOIN_LIST",[t],U,"inner")}crossJoin(t){return this.build("JOIN_LIST",[t],U,"cross")}where(...t){return this.build("WHERE_CLAUSE",t,b,"and")}orderBy(...t){return this.build("ORDER_BY_CLAUSE",t,v,"criterion"),this.ORDER_BY_CLAUSE}limit(...t){if(!t.every(e=>typeof e=="number"))throw new Error("Limits must be of type number.");this.LIMIT_CLAUSE=t}returning(...t){return this.build("RETURNING_LIST",t,W)}toJSON(){return{delete_list:this.DELETE_LIST.map(t=>t.toJSON()),from_list:this.FROM_LIST.map(t=>t.toJSON()),using_list:this.USING_LIST.map(t=>t.toJSON()),join_list:this.JOIN_LIST.map(t=>t.toJSON()),where_clause:this.WHERE_CLAUSE?.toJSON(),order_by_clause:this.ORDER_BY_CLAUSE?.toJSON(),limit_clause:this.LIMIT_CLAUSE,returning_list:this.RETURNING_LIST,flags:this.FLAGS}}static fromJSON(t,e){if(!Array.isArray(e?.from_list))return;let r=new this(t).withFlag(...e.flags||[]);return e.delete_list?.length&&r.delete(...e.delete_list),r.from(...e.from_list),e.using_list?.length&&r.using(...e.using_list),e.join_list?.length&&r.join(...e.join_list),e.where_clause&&r.where(e.where_clause),e.order_by_clause&&r.orderBy(e.order_by_clause),e.limit_clause&&r.limit(e.limit_clause),e.returning_list&&r.returning(...e.returning_list),r}stringify(){let t=["DELETE"];return this.FLAGS.length&&t.push(this.FLAGS.map(e=>e.replace(/_/g," "))),this.DELETE_LIST.length&&t.push(this.DELETE_LIST.join(", ")),t.push("FROM",this.FROM_LIST.join(", ")),this.USING_LIST.length&&t.push("USING",this.USING_LIST.join(", ")),this.JOIN_LIST.length&&t.push(...this.JOIN_LIST),this.WHERE_CLAUSE&&t.push("WHERE",this.WHERE_CLAUSE),this.ORDER_BY_CLAUSE&&t.push(this.ORDER_BY_CLAUSE),this.LIMIT_CLAUSE&&t.push("LIMIT",this.LIMIT_CLAUSE),this.RETURNING_LIST.length&&t.push("RETURNING",this.RETURNING_LIST.join(", ")),t.join(" ")}static parse(t,e,r){let[i,s,n,u]=/^DELETE(\s+WITH\s+UAC)?(?:\s+(IGNORE))?([\s\S]+)$/i.exec(e.trim())||[];if(!i)return;let o=new this(t);s&&o.withFlag("WITH_UAC"),n&&o.withFlag(n);let f=this.mySubstitutePlaceholders(o,u.trim()),l={from:{backtest:"^(?!.*\\s+DISTINCT\\s+$)",test:"FROM"},using:{backtest:"^(?!.*\\s+JOIN\\s+)",test:"USING"},join:U,where:"WHERE",orderBy:v,limit:"LIMIT",returning:"RETURNING"},{tokens:[h,...p],matches:E}=m.lex(f,Object.values(l).map(S=>typeof S=="string"||S.test?S:S.regex),{useRegex:"i"});for(let S of m.split(h,[","])){let T=r(o,S.trim(),[N]);o.delete(T)}for(let S of E){let T=S.replace(/\s+/g,""),A=Object.keys(l).find(_=>new RegExp(_,"i").test(T));if(["from","using"].includes(A))for(let _ of m.split(p.shift(),[","])){let C=A==="from"&&E.some(g=>g.toLowerCase()==="using")?N:D,R=r(o,_.trim(),[C]);o[A](R)}else if(A==="where"){let _=r(o,p.shift().trim(),[b,F]);o.where(_)}else if(A==="limit")o.limit(parseInt(p.shift().trim()));else if(A==="returning")o.returning(...m.split(p.shift(),[","]).map(_=>r(o,_.trim(),[W])));else{let _=r(o,`${S} ${p.shift().trim()}`,[l[A]]);o[A](_)}}return o}};var B=class extends d{get CLAUSE(){return this.constructor.CLAUSE}KIND;constructor(t,e){super(t),this.KIND=e}toJSON(){return{clause:this.CLAUSE,...this.KIND?{kind:this.KIND}:{},...super.toJSON()}}static fromJSON(t,e){if(!(e?.clause&&e.clause!==this.CLAUSE||e?.kind&&!this.KINDS.includes(e.kind)))return new this(t,e.kind).withFlag(...e.flags||[])}static KINDS=[]};var j=class extends d{NAME;$NAME;KEEP;static get WRITABLE_PROPS(){return["NAME"]}static get SUBTREE_PROPS(){return[]}get WRITABLE_PROPS(){return this.constructor.WRITABLE_PROPS}get SUBTREE_PROPS(){return this.constructor.SUBTREE_PROPS}name(t){return arguments.length?(this[this.smartKey("NAME",!0)]=t,this):this[this.smartKey("NAME")]}diffWith(t){typeof t.keep()=="boolean"&&this.keep(t.keep()),t.name()!==this.name()&&this.name(t.name())}smartKey(t,e=!1){if(this.keep()===!0)return e||xe(this[`$${t}`])?`$${t}`:t;if(this.keep()===!1){if(e)throw new Error(`Cannot alter ${this.constructor.name} after having been dropped.`);return t}return t}hardSet(...t){let e=t.pop();if(t.length){let s=t[0],n=()=>{if(this.keep()===!1)throw new Error(`Diffing cannot be done on a node ${this.constructor.name} after having been dropped.`);return typeof this.keep()!="boolean"&&this.keep(!0),e(s)};return typeof this.CONTEXT?.hardSet=="function"?this.CONTEXT.hardSet(s,n):xe(s)?n():void 0}let r=this.KEEP;this.KEEP=null;let i=e();return this.KEEP=r,i}keep(t,e=!1){if(!arguments.length)return this.KEEP;if(![void 0,!0,!1].includes(t))throw new Error(`Status can only be true, false, or undefined. Received: ${t}`);if(this.KEEP=t,e)for(let r of this.SUBTREE_PROPS.reduce((i,s)=>[...i,...this[s]],[]))t!==!0?r.keep(void 0,!0):r.keep(e==="auto"?r.keep():!0,e);return this}drop(){return this.keep(!1)}dropped(){return this.keep()===!1||this.CONTEXT?.dropped?.()}commitAlt(t=!1){this.keep(void 0);for(let e of this.WRITABLE_PROPS)xe(this[`$${e}`])&&(this[e]=this[`$${e}`],this[`$${e}`]=Array.isArray(this[`$${e}`])?[]:void 0);if(t)for(let e of this.SUBTREE_PROPS.reduce((r,i)=>[...r,...this[i]],[]))e.commitAlt(t)}reverseAlt(t=!1){if(this.keep()===!0){for(let e of this.WRITABLE_PROPS)if(xe(this[`$${e}`])){let r=this[e];this[e]=this[`$${e}`],this[`$${e}`]=r}}else this.keep()===!1?this.keep(void 0):typeof this.keep()!="boolean"&&this.keep(!1);if(t)for(let e of this.SUBTREE_PROPS.reduce((r,i)=>[...r,...this[i]],[]))e.reverseAlt(t)}isSame(t,e,r=null){if(typeof t=="string"&&typeof e=="string"&&r==="ci")return t.toLowerCase()===e.toLowerCase();if(t===e)return!0;if(Array.isArray(t)&&Array.isArray(e)&&t.length===e.length){let s=e.slice(0).sort();return t.slice(0).sort().every((n,u)=>this.isSame(n,s[u],r))}let i={};return typeof t=="object"&&t&&typeof e=="object"&&e&&(i.keys_a=Object.keys(t)).length===(i.keys_b=Object.keys(e)).length?i.keys_a.reduce((s,n)=>s&&this.isSame(t[n],e[n],r),!0):!1}toJSON(t={}){return{...this.NAME?{name:this.NAME}:{},...this.$NAME?{$name:this.$NAME}:{},...t,...typeof this.KEEP=="boolean"?{keep:this.KEEP}:{},...this.FLAGS.length?{flags:[...this.FLAGS]}:{}}}static fromJSON(t,e,r=null){if(e?.name&&typeof e.name!="string"||e.$name&&typeof e.$name!="string")return;let i=r?r():new this(t);return i.hardSet(()=>i.name(e.name)),i.hardSet(e.$name,s=>i.name(s)),typeof e.keep=="boolean"&&i.keep(e.keep),e.flags&&i.withFlag(...e.flags),i}},xe=c=>Array.isArray(c)?c.length:typeof c=="object"&&c?Object.keys(c).length:![void 0,null,""].includes(c);var P=class extends j{static get WRITABLE_PROPS(){return["TYPE"].concat(super.WRITABLE_PROPS)}static get TYPE(){return ae(this.name.replace(/TABLE|COLUMN|CONSTRAINT|CLAUSE/ig,""),"_").toUpperCase()}get TYPE(){return this.constructor.TYPE}toJSON(t={}){return super.toJSON({type:this.TYPE,...t})}static fromJSON(t,e,r=null){if(e?.type===this.TYPE)return super.fromJSON(t,e,r)}stringify(){return this.TYPE==="AUTO_INCREMENT"?this.TYPE:`${this.stringifyName()}${this.TYPE.replace("_"," ")}`}static parse(t,e){let{name:r,expr:i}=this.parseName(t,e,!0);if(!(!i||!new RegExp(`^${this.TYPE==="AUTO_INCREMENT"?this.TYPE:this.TYPE.replace("_","\\s+")}$`,"i").test(i)))return new this(t).name(r)}stringifyName(){return this.name()?`CONSTRAINT ${this.autoEsc(this.name())} `:""}static parseName(t,e,r=!1){let s=`(?:CONSTRAINT(?:\\s+(\\w+)|\\s+(${this.getEscChar(t,r)})((?:\\2\\2|[^\\2])+)\\2)\\s+)?`,[,n,,u,o=""]=e.match(new RegExp(`^${s}([\\s\\S]+)$`,"i"))||[];return{name:n||this.autoUnesc(t,u),expr:o.trim()}}};var Bt=class extends P{static get TYPE(){return"AUTO_INCREMENT"}stringify(){return this.params.dialect!=="mysql"?new Tt(this.CONTEXT).stringify():"AUTO_INCREMENT"}};var Tt=class extends P{ALWAYS;$ALWAYS;static get WRITABLE_PROPS(){return["ALWAYS"].concat(super.WRITABLE_PROPS)}always(t){return arguments.length?(this[this.smartKey("ALWAYS",!0)]=!!t,this):this[this.smartKey("ALWAYS")]}diffWith(t){return super.diffWith(t),t.always()!==this.always()&&this.always(t.always()),this}toJSON(){return super.toJSON({always:!!this.ALWAYS,...typeof this.$ALWAYS=="boolean"?{$always:this.$ALWAYS}:{}})}static fromJSON(t,e){return super.fromJSON(t,e,()=>{let r=new this(t).always(e.always);return r.hardSet(e.$always,i=>r.always(i)),r})}stringify(){return this.params.dialect==="mysql"?new Bt(this.CONTEXT).stringify():`GENERATED ${this.always()?"ALWAYS":"BY DEFAULT"} AS IDENTITY`}static parse(t,e){let{name:r,expr:i}=this.parseName(t,e,!0);if(!(!i||!(i=i.match(new RegExp("^GENERATED\\s+(ALWAYS|BY[ ]+DEFAULT)(?:\\s+AS\\s+IDENTITY)?$","i"))?.[1])))return new this(t).name(r).always(/^ALWAYS$/i.test(i))}};var M=class extends P{columns(){return"COLUMNS"in this?[]:[this.CONTEXT.name()]}toJSON(t={}){let e=super.toJSON(t);return!("name"in e)&&this.params.dialect!=="mysql"&&(e={name:void 0,...e}),e}static fromJSON(t,e,r=null){if(e?.type===this.TYPE)return!("name"in e)&&t?.params?.dialect!=="mysql"&&(e={name:`auto_name_${(0|Math.random()*9e6).toString(36)}`,...e}),super.fromJSON(t,e,r)}static parseColumns(t,e,r=!1){return m.split(w(e,"(",")"),[","]).map(i=>this.parseIdent(t,i.trim(),r)[0])}};var Yt=class extends M{};var te=c=>class extends c{COLUMNS=[];$COLUMNS=[];static get WRITABLE_PROPS(){return["COLUMNS"].concat(super.WRITABLE_PROPS)}columns(t){return arguments.length?(this[this.smartKey("COLUMNS",!0)]=[].concat(t),this):this[this.smartKey("COLUMNS")]}diffWith(t){return super.diffWith(t),this.isSame(t.columns(),this.columns())||this.columns(t.columns()),this}toJSON(){return super.toJSON({columns:this.COLUMNS,...this.$COLUMNS.length?{$columns:this.$COLUMNS}:{}})}static fromJSON(t,e){if(e?.columns?.length)return super.fromJSON(t,e,()=>{let r=new this(t).columns(e.columns);return r.hardSet(e.$columns,i=>r.columns(i)),r})}stringify(){return this.TYPE==="FOREIGN_KEY"?super.stringify():`${super.stringify()} (${this.autoEsc(this.columns()).join(", ")})`}static parse(t,e,r){if(this.TYPE==="FOREIGN_KEY")return super.parse(t,e,r);let[i,s]=m.split(e,[]),n=super.parse(t,i.trim(),r);if(n)return n.columns(this.parseColumns(t,s))}};var Ct=class extends te(Yt){};var dt=class extends M{TARGET_TABLE;$TARGET_TABLE;TARGET_COLUMNS=[];$TARGET_COLUMNS=[];MATCH_RULE;$MATCH_RULE;UPDATE_RULE;$UPDATE_RULE;DELETE_RULE;$DELETE_RULE;static get WRITABLE_PROPS(){return["TARGET_TABLE","TARGET_COLUMNS","MATCH_RULE","UPDATE_RULE","DELETE_RULE"].concat(super.WRITABLE_PROPS)}targetTable(t){return arguments.length?(this.build(this.smartKey("TARGET_TABLE",!0),[t],N,"name"),this):this[this.smartKey("TARGET_TABLE")]}targetColumns(t){return arguments.length?(this[this.smartKey("TARGET_COLUMNS",!0)]=[].concat(t),this):this[this.smartKey("TARGET_COLUMNS")]}matchRule(t){return arguments.length?(this[this.smartKey("MATCH_RULE",!0)]=t,this):this[this.smartKey("MATCH_RULE")]}updateRule(t){return arguments.length?(this[this.smartKey("UPDATE_RULE",!0)]=t,this):this[this.smartKey("UPDATE_RULE")]}deleteRule(t){return arguments.length?(this[this.smartKey("DELETE_RULE",!0)]=t,this):this[this.smartKey("DELETE_RULE")]}diffWith(t){return super.diffWith(t),this.isSame(t.targetTable().toJSON(),this.targetTable().toJSON())||this.targetTable(t.targetTable().toJSON()),this.isSame(t.targetColumns(),this.targetColumns())||this.targetColumns(t.targetColumns()),this.isSame(t.matchRule(),this.matchRule())||this.matchRule(t.matchRule()),this.isSame(t.updateRule(),this.updateRule())||this.updateRule(t.updateRule()),this.isSame(t.deleteRule(),this.deleteRule())||this.deleteRule(t.deleteRule()),this}toJSON(t={}){return super.toJSON({...t,targetTable:this.TARGET_TABLE.toJSON(),...this.$TARGET_TABLE?{$targetTable:this.$TARGET_TABLE.toJSON()}:{},targetColumns:this.TARGET_COLUMNS,...this.$TARGET_COLUMNS.length?{$targetColumns:this.$TARGET_COLUMNS}:{},...this.MATCH_RULE?{matchRule:this.MATCH_RULE}:{},...this.$MATCH_RULE?{$matchRule:this.$MATCH_RULE}:{},...this.UPDATE_RULE?{updateRule:this.UPDATE_RULE}:{},...this.$UPDATE_RULE?{$updateRule:this.$UPDATE_RULE}:{},...this.DELETE_RULE?{deleteRule:this.DELETE_RULE}:{},...this.$DELETE_RULE?{$deleteRule:this.$DELETE_RULE}:{}})}static fromJSON(t,e,r=null){if(!(!e?.targetTable||!e.targetColumns?.length))return super.fromJSON(t,e,()=>{let i=r?r():new this(t);return i.hardSet(()=>i.targetTable(e.targetTable)),i.hardSet(()=>i.targetColumns(e.targetColumns)),i.hardSet(()=>i.matchRule(e.matchRule)),i.hardSet(()=>i.updateRule(e.updateRule)),i.hardSet(()=>i.deleteRule(e.deleteRule)),i.hardSet(e.$targetTable,s=>i.targetTable(s)),i.hardSet(e.$targetColumns,s=>i.targetColumns(s)),i.hardSet(e.$matchRule,s=>i.matchRule(s)),i.hardSet(e.$updateRule,s=>i.updateRule(s)),i.hardSet(e.$deleteRule,s=>i.deleteRule(s)),i})}stringify(){let t=this.targetTable();if(!t.PREFIX){let i=this.$trace("get:name:database");t=t.clone().name([i,t.NAME])}let e=`${this.stringifyName()}REFERENCES ${t} (${this.autoEsc(this.targetColumns()).join(", ")})`,r=i=>typeof i=="object"&&i?`${i.rule} (${i.columns.join(", ")})`:i;return this.matchRule()&&(e+=` MATCH ${this.matchRule()}`),this.updateRule()&&(e+=` ON UPDATE ${r(this.updateRule())}`),this.deleteRule()&&(e+=` ON DELETE ${r(this.deleteRule())}`),e}static parse(t,e){let{name:r,expr:i}=this.parseName(t,e,!0);if(!i||!(i=i.match(/^REFERENCES\s+([\s\S]+)$/i)?.[1]))return;let[s,n,u=""]=m.split(i,[]),[o,f]=this.parseIdent(t,s.trim(),!0),l=m.split(w(n,"(",")"),[","]).map(p=>this.parseIdent(t,p.trim(),!0)[0]),h=(p,E)=>{if(E==="MATCH")return p.match(/MATCH\s+(\w+)/i)?.[1];let S=/(NO\s+ACTION|RESTRICT|CASCADE|(SET\s+NULL|SET\s+DEFAULT)(?:\s+\(([^\)]+)\))?)/,[,T,A,_]=p.match(new RegExp(`ON\\s+${E}\\s+${S.source}`,"i"))||[];return A?_?{rule:A,columns:_.split(",").map(C=>C.trim())}:A:T};return new this(t).name(r).targetTable(f?[f,o]:o).targetColumns(l).matchRule(h(u,"MATCH")).updateRule(h(u,"UPDATE")).deleteRule(h(u,"DELETE"))}};var ht=class extends te(dt){stringify(){let t=this.stringifyName(),e=this.NAME,r=this.$NAME;this.NAME=null,this.$NAME=null;let i=`${t}FOREIGN KEY (${this.autoEsc(this.columns()).join(", ")}) ${super.stringify()}`;return this.NAME=e,this.$NAME=r,i}static parse(t,e,r){let{name:i="",expr:s}=this.parseName(t,e,!0);if(!s||!/^FOREIGN\s+KEY/i.test(s))return;let[,n,...u]=m.split(s,[]);return super.parse(t,u.join("").trim(),r).name(i).columns(this.parseColumns(t,n))}};var Kt=class extends M{stringify(){return`${this.stringifyName()}UNIQUE`}static parse(t,e){let{name:r,expr:i}=this.parseName(t,e,!0);if(!(!i||!/^UNIQUE(\s+KEY)?$/i.test(i)))return new this(t).name(r)}};var yt=class extends te(Kt){};var $t=c=>class extends c{EXPR;$EXPR;static get WRITABLE_PROPS(){return["EXPR"].concat(super.WRITABLE_PROPS)}expr(t){return arguments.length?(this[this.smartKey("EXPR",!0)]=t,this):this[this.smartKey("EXPR")]}diffWith(t){return super.diffWith(t),t.expr()!==this.expr()&&this.expr(t.expr()),this}toJSON(){return super.toJSON({expr:this.EXPR,...[void 0,null].includes(this.$EXPR)?{}:{$expr:this.$EXPR}})}static fromJSON(t,e){if(![void 0,null].includes(e?.expr))return super.fromJSON(t,e,()=>{let r=new this(t).expr(e.expr);return r.hardSet(e.$expr,i=>r.expr(i)),r})}stringify(){return`${super.stringify()} (${this.expr()})`}static parse(t,e){let{name:r,expr:i}=this.parseName(t,e,!0);return!i||!(i=i.match(new RegExp(`^${this.TYPE.replace(/_/g,"\\s+")}\\s+([\\s\\S]+)$`,"i"))?.[1])?void 0:new this(t).expr(x(i.trim(),"(",")")?w(i.trim(),"(",")"):i).name(r)}};var st=class extends $t(M){};var X=class extends j{TYPE;$TYPE;COLUMNS=[];$COLUMNS=[];static get WRITABLE_PROPS(){return["TYPE","COLUMNS"].concat(super.WRITABLE_PROPS)}type(t){return arguments.length?(this[this.smartKey("TYPE",!0)]=t,this):this[this.smartKey("TYPE")]}columns(t){return arguments.length?(this[this.smartKey("COLUMNS",!0)]=[].concat(t),this):this[this.smartKey("COLUMNS")]}diffWith(t){return super.diffWith(t),this.isSame(this.type(),t.type())||this.type(t.type()),this.isSame(this.columns(),t.columns())||this.columns(t.columns()),this}toJSON(){return super.toJSON({type:this.TYPE,...this.$TYPE?{$type:this.$TYPE}:{},columns:this.COLUMNS,...this.$COLUMNS.length?{$columns:this.$COLUMNS}:{}})}static fromJSON(t,e){if(!(typeof e?.type!="string"||!/^(INDEX|KEY|FULLTEXT)$/i.test(e.type)||!e.columns?.length))return super.fromJSON(t,e,()=>{let r=new this(t).columns(e.columns).type(e.type);return r.hardSet(e.$columns,i=>r.columns(i)),r.hardSet(e.$type,i=>r.type(i)),r})}stringify(){return`${this.type()}${this.name()?` ${this.name()}`:""} (${this.columns().join(", ")})`}static parse(t,e){let[r,i,s]=/^((?:(?:FULLTEXT|SPATIAL)(?:\s+INDEX|\s+KEY)?)|(?:INDEX|KEY))([\s\S]+)$/i.exec(e)||[];if(!r)return;let[n,u]=m.split(s,[]),[o]=this.parseIdent(t,n.trim(),!0),f=m.split(w(u,"(",")"),[","]).map(l=>this.parseIdent(t,l.trim(),!0)[0]);return new this(t).type(i.replace(/\s+(INDEX|KEY)/i,"").toUpperCase()).columns(f).name(o)}};var le=class extends $t(P){STORED;$STORED;static get WRITABLE_PROPS(){return["STORED"].concat(super.WRITABLE_PROPS)}stored(t){return arguments.length?(this[this.smartKey("STORED",!0)]=!!t,this):this[this.smartKey("STORED")]}diffWith(t){return super.diffWith(t),t.stored()!==this.stored()&&this.stored(t.stored()),this}toJSON(){return super.toJSON({stored:!!this.STORED,...typeof this.$STORED=="boolean"?{$stored:this.$STORED}:{}})}static fromJSON(t,e){return super.fromJSON(t,e,()=>{let r=new this(t).stored(e.stored);return r.hardSet(e.$stored,i=>r.stored(i)),r})}stringify(){return`GENERATED ALWAYS AS (${this.expr()})${this.stored()?" STORED":""}`}static parse(t,e){let r,{name:i,expr:s}=this.parseName(t,e,!0);if([,s,r=""]=s.match(new RegExp("^GENERATED\\s+ALWAYS\\s+AS\\s+\\(([\\s\\S]+)\\)(?:\\s+(VIRTUAL|STORED))?$","i"))||[],!!s)return new this(t).name(i).expr(s).stored(/^STORED$/i.test(r))}};var he=class extends $t(P){};var me=class extends P{};var pe=class extends $t(P){};var Ee=class extends P{};var k=class extends d{SPEC=[];constructor(t,e){super(t),this.SPEC=e}toJSON(){return this.SPEC.length===1?this.SPEC[0]:this.SPEC}static fromJSON(t,e){let r=[].concat(e);if(typeof r[0]!="string")return;let[i,s,n]=rr.call(this,r[0]);return i?new this(t,ke(i,...s.split(","),...n,...r.slice(1))):new this(t,ke(...[].concat(e)))}stringify(){let[t,e]=this.SPEC.slice(1).reduce(([r,i],s)=>/^\d+$/.test(s)?[r.concat(s),i]:[r,i.concat(s)],[[],[]]);return`${this.SPEC[0]}${t.length?`(${t.join(",")})`:""}${e.length?` ${e.join(" ")}`:""}`}static parse(t,e){let[r,i,s]=rr.call(this,e);if(r)return new this(t,ke(r,...i.split(","),...s))}static pgFixedTypesRe=/^(bigint|int8|bigserial|serial8|boolean|bool|box|bytea|cidr|circle|date|double\s+precision|float8|inet|integer|int|int4|jsonb|json|line|lseg|macaddr8|macaddr|money|path|pg_lsn|pg_snapshot|point|polygon|real|float4|smallint|int2|smallserial|serial2|serial4|serial|text|timetz|timestamptz|tsquery|tsvector|txid_snapshot|uuid|xml)$/;static pgVariableTypesRe=/^(bit\s+varying|bit|varbit|character\s+varying|character|char|varchar|interval|numeric|timestamp|time)(?:\s+)?(?:\(([\d, ]+)\))?(\s+(?:with|without)\s+time\s+zone)?$/;static myFixedTypesRe=/^(tinyint|smallint|mediumint|enum|set|tinyblob|mediumblob|longblob|geometry|longstring|geometrycollection|multilinestring|multipoint|multipolygon)$/;static myVariableTypesRe=/^(float|decimal|double|tinytext|mediumtext|longtext|binary|varbinary|blob)(?:\s+)?(?:\(([\d, ]+)\))?$/};function rr(c){let t,e,r;for(let i of["pgFixedTypesRe","pgVariableTypesRe","myFixedTypesRe","myVariableTypesRe"])if([,t,e="",...r]=c.match(new RegExp(this[i].source,"i"))||[],t)break;return[t,e,r]}function ke(...c){return c.map(t=>/^\d+$/.test(t)?parseFloat(t):t?.trim().replace(/\s+/," ").toUpperCase()).filter(t=>t)}var Y=class extends j{TYPE;$TYPE;CONSTRAINTS=[];static get WRITABLE_PROPS(){return["TYPE"].concat(super.WRITABLE_PROPS)}static get SUBTREE_PROPS(){return["CONSTRAINTS"]}static CONSTRAINT_TYPES=[Bt,Tt,le,he,me,Ee,pe,Yt,dt,Kt,st];type(t){return arguments.length?(this.build(this.smartKey("TYPE",!0),[t],k),this):this[this.smartKey("TYPE")]}autoIncrement(...t){return this.constraint("AUTO_INCREMENT",...t)}identity(...t){return this.constraint("IDENTITY",...t)}expression(...t){return this.constraint("EXPRESSION",...t)}default(...t){return this.constraint("DEFAULT",...t)}notNull(...t){return this.constraint("NOT_NULL",...t)}null(...t){return this.constraint("NULL",...t)}onUpdate(...t){return this.constraint("ON_UPDATE",...t)}primaryKey(...t){return this.constraint("PRIMARY_KEY",...t)}foreignKey(...t){return this.constraint("FOREIGN_KEY",...t)}uniqueKey(...t){return this.constraint("UNIQUE_KEY",...t)}check(...t){return this.constraint("CHECK",...t)}constraint(t,...e){let r,i=s=>this.CONSTRAINTS.find(n=>n.TYPE===s);if(typeof t=="string"){if(r=i(t),e.length){if(e[0]===!1)return r?.keep(!1)}else return r;t={type:t,...typeof e[0]=="object"?e[0]:typeof e[0]=="string"?{expr:e[0]}:{}}}else t instanceof j||(r=i(t.type));if(r){let s=this.constructor.CONSTRAINT_TYPES.reduce((n,u)=>n||u.fromJSON(this,t));r.diffWith(s)}else this.build("CONSTRAINTS",[t],this.constructor.CONSTRAINT_TYPES);return this}diffWith(t){super.diffWith(t);let e=this.type().toJSON(),r=t.type().toJSON();this.isSame(e,r)||this.type(r);for(let i of["IDENTITY","EXPRESSION","NOT_NULL","NULL","DEFAULT","AUTO_INCREMENT","ON_UPDATE"]){let s=this.constraint(i),n=t.constraint(i);s&&(!n||n.dropped())?s.keep(!1):!s&&n&&!n.dropped()?this.constraint(n.toJSON()):s&&n&&s.diffWith(n)}return this}toJSON(){let t={type:this.TYPE.toJSON(),...this.$TYPE?{$type:this.$TYPE.toJSON()}:{}};for(let e of this.CONSTRAINTS){let{type:r,...i}=e.toJSON(),s=r==="FOREIGN_KEY"?"references":He(r.toLowerCase().replace("_"," ")),n=Object.keys(i),u=n.length===1?i[n[0]]:null,o=n.length?u===!1&&n[0]==="keep"?!1:n.length===1&&n[0]==="expr"?u:i:!0;t={...t,[s]:o}}return super.toJSON(t)}static fromJSON(t,e){let{type:r,$type:i,name:s,$name:n,keep:u,...o}=e;if(k.fromJSON({},r))return super.fromJSON(t,e,()=>{let f=new this(t);f.type(k.fromJSON(f,r)),f.hardSet(i,h=>f.type(k.fromJSON(f,h)));let l=Object.entries(o).reduce((h,[p,E])=>{if([void 0,null].includes(E))return h;if(!["boolean","number","string"].includes(typeof E)&&!(typeof E=="object"&&E))throw new Error(`Invalid value for constraint "${p}": ${E}`);let S={...E===!1?{keep:!1}:E===!0?{}:["number","string"].includes(typeof E)?{expr:E}:E};return p.startsWith("$")&&(S=Object.fromEntries(Object.entries(S).map(([T,A])=>[`$${T}`,A])),p=p.slice(1)),p==="references"&&(p="foreignKey"),p in h?Object.assign(h[p],S):h[p]=S,h},{});for(let h in l)f.constraint(ae(h,"_").toUpperCase(),l[h]);return f})}stringify(){let t=this.CONSTRAINTS;return this.params.dialect==="mysql"&&(t=t.filter(e=>e.TYPE!=="FOREIGN_KEY")),`${this.autoEsc(this.name())} ${this.type()}${t.length?` ${t.join(" ")}`:""}`}static parse(t,e,r){let[i,s]=m.split(e,["\\s+"],{useRegex:!0,limit:1}),[n]=this.parseIdent(t,i.trim(),!0)||[];if(!n)return;let u=new this(t).name(n),o="(CONSTRAINT\\s+.+?\\s+)?",f=[{test:`${o}(PRIMARY[ ]+KEY|NOT[ ]+NULL|GENERATED|REFERENCES|UNIQUE(?:[ ]+KEY)?|CHECK|AUTO_INCREMENT)`},{backtest:"^(?!.*\\s+(NOT|SET)\\s+$)",test:`${o}NULL`},{backtest:"^(?!.*\\s+BY\\s+$)",test:`${o}DEFAULT`},{backtest:"^(?!.*\\s+REFERENCES\\s+)",test:"ON\\s+UPDATE"}],[l,...h]=m.split(s,f,{useRegex:"i",preserveDelims:!0});u.type(r(u,l.trim(),[k]));for(let p of h){let E=r(u,p,this.CONSTRAINT_TYPES);u.build("CONSTRAINTS",[E],this.CONSTRAINT_TYPES)}return u}};var _t=class extends B{ARGUMENT;argument(t=void 0){return arguments.length?(this.build("ARGUMENT",[t],this.constructor.NODE_TYPES),this):this.ARGUMENT}toJSON(){return{argument:this.ARGUMENT.toJSON(),...super.toJSON()}}static fromJSON(t,e){if(e?.argument)return super.fromJSON(t,e)?.argument(e.argument)}stringify(){let t=[`${this.CLAUSE}${this.KIND&&/^(COLUMN|TABLE|SCHEMA|DATABASE)$/i.test(this.KIND)?` ${this.KIND.replace(/_/g," ")}${this.hasFlag("IF_NOT_EXISTS")?" IF NOT EXISTS":""}`:""} ${this.argument()}`];return this.argument()instanceof Y&&(this.hasFlag("AFTER")?t.push(this.getFlag("AFTER")?.replace(":"," ")):this.hasFlag("FIRST")&&t.push("FIRST"),this.params.dialect==="mysql"&&this.argument().foreignKey())?[t.join(" "),`ADD ${ht.fromJSON(this,constraint.toJSON()).columns([this.argument().name()])}`].join(`;
`):t.join(" ")}static parse(t,e,r){let[i,s="",n,u]=new RegExp(`^${this.CLAUSE}\\s+(?:(${this.KINDS.map(f=>f.replace(/_/g,"\\s+")).join("|")})\\s+)?(IF\\s+NOT\\s+EXISTS\\s+)?([\\s\\S]+)$`,"i").exec(e.trim())||[];if(!i)return;let o=new this(t,s.replace(/\s+/g,"_").toUpperCase());if(n&&o.withFlag("IF_NOT_EXISTS"),!s||/^COLUMN$/i.test(s)){let[,f,l,h]=u.trim().match(/([\s\S]+)\s+(?:(FIRST)|AFTER\s+(.+))$/i)||[,u.trim()];l&&o.withFlag("FIRST"),h&&o.withFlag(`AFTER:${h}`),o.argument(r(o,f,[Y]))}else/^TABLE|SCHEMA|DATABASE$/i.test(s)?o.argument(r(o,u,this.NODE_TYPES)):o.argument(r(o,`${s} ${u}`,this.NODE_TYPES));return o}static get CLAUSE(){return"ADD"}static NODE_TYPES=[Tt,Ct,ht,yt,st,X,Y];static KINDS=["COLUMN","CONSTRAINT","PRIMARY_KEY","FOREIGN_KEY","UNIQUE_KEY","CHECK","FULLTEXT_INDEX","SPATIAL_INDEX","INDEX","KEY"]};var wt=c=>class extends c{$trace(t,...e){if(t==="get:node:statement")return this;if(t==="get:name:table"&&this.KIND==="TABLE")return this.NAME.NAME;if(t==="get:name:database"){if(["SCHEMA","DATABASE"].includes(this.KIND))return this.NAME.NAME;if(this.KIND==="TABLE"&&this.NAME.PREFIX)return this.NAME.PREFIX}return super.$trace(t,...e)}async $schema(t,e){this._SCHEMAS||(this._SCHEMAS=await this.$trace("get:api:client").schemas());let r=this._SCHEMAS.database(t);return e?r?.table(e).clone():r?.clone()}clone(){let t=super.clone();return t._SCHEMAS=this._SCHEMAS,t}name(t=void 0){return arguments.length?(this.build("NAME",[t],N),this):this.NAME}};var Gt=class extends j{NAME;$NAME;KEEP;$trace(t,...e){return t==="get:node:schema"?this:super.$trace(t,...e)}name(t){return arguments.length?(this.build(this.smartKey("NAME",!0),[t],N,"name"),this):this[this.smartKey("NAME")]}diffWith(t){typeof t.keep()=="boolean"&&this.keep(t.keep()),this.isSame(t.name().toJSON(),this.name().toJSON())||this.name(t.name().toJSON())}toJSON(t={}){return{name:this.NAME.toJSON(),...this.$NAME?{$name:this.$NAME.toJSON()}:{},...t,...typeof this.KEEP=="boolean"?{keep:this.KEEP}:{},...this.FLAGS.length?{flags:[...this.FLAGS]}:{}}}static fromJSON(t,e,r=null){if(!e?.name||!N.fromJSON({},e.name))return;let i=r?r():new this(t);return i.hardSet(()=>i.name(e.name)),i.hardSet(e.$name,s=>i.name(s)),typeof e.keep=="boolean"&&i.keep(e.keep),e.flags&&i.withFlag(...e.flags),i}};var bt=class extends B{NAME;ARGUMENT;name(t=void 0){return arguments.length?(this.NAME=t,this):this.NAME}argument(t=void 0){return arguments.length?(this.ARGUMENT=t,this):this.ARGUMENT}toJSON(){return{name:this.NAME,argument:this.ARGUMENT,...super.toJSON()}}static fromJSON(t,e){if(!(e?.kind&&typeof e.name!="string"||typeof e?.argument!="string"))return super.fromJSON(t,e)?.name(e.name).argument(e.argument)}stringify(){return`${this.CLAUSE}${this.KIND?` ${this.KIND}`:""}${this.NAME?` ${this.autoEsc(this.NAME)}`:""} TO ${this.autoEsc(this.ARGUMENT)}`}static parse(t,e){let[r,i="",s,,n,u,,o]=new RegExp(`^${this.CLAUSE}\\s+(?:(${this.KINDS.map(l=>l).join("|")})\\s+)?(?:(?:(\\w+)|([\`"])((?:\\3\\3|[^\\3])+)\\3)\\s+)?(?:TO|AS)\\s+(?:(\\w+)|([\`"])((?:\\6\\6|[^\\6])+)\\6)$`,"i").exec(e.trim())||[];if(!r)return;let f=new this(t,i.replace(/\s+/g,"_").toUpperCase());return(s||n)&&f.name(s||this.autoUnesc(f,n)),f.argument(u||this.autoUnesc(f,o)),f}static get CLAUSE(){return"RENAME"}static KINDS=["COLUMN","CONSTRAINT","INDEX","KEY"]};var Wt=class extends B{NAME;name(t=void 0){return arguments.length?(this.NAME=t,this):this.NAME}toJSON(){return{name:this.NAME,...super.toJSON()}}static fromJSON(t,e){if(!(!e?.kind&&typeof e?.name!="string"))return super.fromJSON(t,e)?.name(e.name)}stringify(){let t=this.getFlag("RESTRICT")||this.getFlag("CASCADE"),e=this.KIND?.replace(/_/g," "),r=this.NAME&&this.autoEsc(this.NAME);return["PRIMARY_KEY","FOREIGN_KEY","CHECK"].includes(this.KIND)&&(this.params.dialect==="mysql"?this.KIND==="PRIMARY_KEY"&&(r=null):e="CONSTRAINT"),`${this.CLAUSE}${e?` ${e}`:""}${this.hasFlag("IF_EXISTS")?" IF EXISTS":""}${r?` ${r}`:""}${t?` ${t}`:""}`}static parse(t,e){let[r,i="",s,n,,u,o]=new RegExp(`^${this.CLAUSE}(?:\\s+(${this.KINDS.map(l=>l.replace(/_/g,"\\s+")).join("|")}))?(\\s+IF\\s+EXISTS)?(?:\\s+(\\w+)|\\s+([\`"])((?:\\4\\4|[^\\4])+)\\4)?(?:\\s+(RESTRICT|CASCADE))?$`,"i").exec(e.trim())||[];if(!r)return;let f=new this(t,i.replace(/\s+/g,"_").toUpperCase());return(n||u)&&f.name(n||this.autoUnesc(f,u)),s&&f.withFlag("IF_EXISTS"),o&&f.withFlag(o),f}static get CLAUSE(){return"DROP"}static KINDS=["COLUMN","CONSTRAINT","PRIMARY_KEY","FOREIGN_KEY","UNIQUE_KEY","CHECK","INDEX","KEY","IDENTITY","EXPRESSION","DEFAULT","NOT_NULL","NULL","AUTO_INCREMENT","ON_UPDATE"]};var gt=class extends B{ARGUMENT;argument(t=void 0){return arguments.length?(["DATA_TYPE","TYPE"].includes(this.KIND)?this.build("ARGUMENT",[t],k):this.KIND==="SCHEMA"?this.build("ARGUMENT",[t],N):this.ARGUMENT=t,this):this.ARGUMENT}toJSON(){return{argument:this.ARGUMENT?.toJSON?.()||this.ARGUMENT,...super.toJSON()}}static fromJSON(t,e){if(e?.kind)return super.fromJSON(t,e)?.argument(e.argument)}stringify(){return this.KIND==="IDENTITY"?`SET GENERATED ${/^ALWAYS$/i.test(this.ARGUMENT)?"AS ALWAYS":"BY DEFAULT"}`:`${this.CLAUSE} ${this.KIND.replace(/_/g," ")}${this.ARGUMENT?` ${this.ARGUMENT}`:""}`}static parse(t,e,r){let[i,s,n]=new RegExp(`^${this.CLAUSE}\\s+(${this.KINDS.map(f=>f==="IDENTITY"?"GENERATED":f.replace(/_/g,"\\s+")).join("|")})(?:\\s+([\\s\\S]+))?$`,"i").exec(e.trim())||[];if(!i)return;let u=/^GENERATED$/i.test(s),o=new this(t,u?"IDENTITY":s.replace(/\s+/g,"_").toUpperCase());return/^(DATA\s+)?TYPE$/i.test(s)?o.argument(r(o,n,[k])):/^SCHEMA$/i.test(s)?o.argument(r(o,n,[N])):o.argument(u?/^AS\s+ALWAYS$/i.test(n)?"always":!0:n),o}static get CLAUSE(){return"SET"}static KINDS=["SCHEMA","DATA_TYPE","TYPE","IDENTITY","DEFAULT","NOT_NULL","NULL","AUTO_INCREMENT","ON_UPDATE"]};var Ot=class extends B{ARGUMENT;argument(t){return arguments.length?(this.build("ARGUMENT",[t],this.constructor.NODE_TYPES),this):this.ARGUMENT}toJSON(){return{argument:this.ARGUMENT.toJSON(),...super.toJSON()}}static fromJSON(t,e){if(!(!e?.kind||!e.argument))return super.fromJSON(t,e)?.argument(e.argument)}stringify(){return`${this.CLAUSE} ${this.KIND} ${this.ARGUMENT}`}static parse(t,e,r){let[i,s,n]=new RegExp(`^${this.CLAUSE}\\s+(${this.KINDS.map(o=>o).join("|")})\\s+([\\s\\S]+)$`,"i").exec(e.trim())||[];if(!i)return;let u=new this(t,s.toUpperCase());return u.argument(r(u,n,this.NODE_TYPES)),u}static get CLAUSE(){return"MODIFY"}static NODE_TYPES=[Y];static KINDS=["COLUMN"]};var Se=class extends Ot{NAME;name(t=void 0){return arguments.length?(this.NAME=t,this):this.NAME}add(t,e){return this.argument({clause:"ADD",kind:t,argument:e})}drop(t){return this.argument({clause:"DROP",kind:t})}set(t,e){return this.argument({clause:"SET",kind:t,argument:e})}toJSON(){return{name:this.NAME,...super.toJSON()}}static fromJSON(t,e){if(typeof e?.name=="string")return super.fromJSON(t,e)?.name(e.name)}stringify(){return`${this.CLAUSE} ${this.KIND} ${this.autoEsc(this.NAME)} ${this.ARGUMENT}`}static parse(t,e,r){let[i,s,n,,u,o]=new RegExp(`^${this.CLAUSE}\\s+(${this.KINDS.map(l=>l).join("|")})\\s+(?:(\\w+)|([\`"])((?:\\3\\3|[^\\3])+)\\3)?\\s+([\\s\\S]+)$`,"i").exec(e.trim())||[];if(!i)return;let f=new this(t,s.toUpperCase());return f.name(n||this.autoUnesc(f,u)),/^(DATA\+)?TYPE\s+/i.test(o)?f.argument(r(f,`SET ${o}`,[gt])):f.argument(r(f,o,this.NODE_TYPES)),f}static get CLAUSE(){return"ALTER"}static NODE_TYPES=[_t,Wt,gt,pt];static KINDS=["COLUMN","CONSTRAINT","INDEX"]};var Ne=class extends Ot{NAME;name(t=void 0){return arguments.length?(this.NAME=t,this):this.NAME}toJSON(){return{name:this.NAME,...super.toJSON()}}static fromJSON(t,e){if(typeof e?.name=="string")return super.fromJSON(t,e)?.name(e.name)}stringify(){let t=[`${this.CLAUSE} ${this.KIND} ${this.autoEsc(this.NAME)} ${this.ARGUMENT}`];return this.hasFlag("AFTER")?t.push(this.getFlag("AFTER")?.replace(":"," ")):this.hasFlag("FIRST")&&t.push("FIRST"),t.join(" ")}static parse(t,e,r){let[i,s,n,,u,o]=new RegExp(`^${this.CLAUSE}\\s+(${this.KINDS.map(E=>E).join("|")})\\s+(?:(\\w+)|([\`"])((?:\\3\\3|[^\\3])+)\\3)?\\s+([\\s\\S]+)$`,"i").exec(e.trim())||[];if(!i)return;let f=new this(t,s.toUpperCase());f.name(n||this.autoUnesc(f,u));let{tokens:[l,h],matches:p}=m.lex(o,["FIRST","AFTER"],{useRegex:"i"});return f.argument(r(f,l,this.NODE_TYPES)),h?f.withFlag(`AFTER:${h}`):p.length&&f.withFlag("FIRST"),f}static get CLAUSE(){return"CHANGE"}};var V=class extends wt(B){NAME;ACTIONS=[];SUBTREE=[];get length(){return this.ACTIONS.length+this.SUBTREE.length}action(...t){return arguments.length?(this.build("ACTIONS",t,this.constructor.NODE_TYPES),this):this.ACTIONS[this.ACTIONS.length-1]}create(t,e){return this.action({clause:"CREATE",kind:t,argument:e})}rename(t,e,r){return this.action({clause:"RENAME",kind:t,name:e,argument:r})}modify(t,e){return this.action({clause:"MODIFY",kind:t,argument:e})}change(t,e,r){return this.action({clause:"CHANGE",kind:t,name:e,argument:r})}alter(t,e,r){return this.action({clause:"ALTER",kind:t,name:e,argument:r})}add(t,e){return this.action({clause:"ADD",kind:t,argument:e})}drop(t,e){return this.action({clause:"DROP",kind:t,name:e})}set(t,e){return this.action({clause:"SET",kind:t,argument:e})}toJSON(){return{name:this.NAME.toJSON(),actions:this.ACTIONS.map(t=>t.toJSON()),...super.toJSON()}}static fromJSON(t,e){if(!e?.kind||!e.name||!Array.isArray(e.actions))return;let r=super.fromJSON(t,e)?.name(e.name);return r.action(...e.actions),r}stringify(){if(!this.length)return"";let t=f=>{if(f.PREFIX||["SCHEMA","DATABASE"].includes(this.KIND))return f;let l=this.$trace("get:name:database");return f.clone().name([l,f.NAME])},[e,r,i,s]=this.ACTIONS.reduce(([f,l,h,p],E)=>E instanceof bt?E.KIND?[f,l.concat(E),h,p]:[f,l,E,p]:E instanceof gt&&E.KIND==="SCHEMA"?[f,l,h,E]:[f.concat(E),l,h,p],[[],[]]),n=f=>`${this.CLAUSE} ${this.KIND}${this.hasFlag("IF_EXISTS")?" IF EXISTS":""} ${f}`,u=[...this.SUBTREE],o=t(this.name());e.length&&u.push(`${n(o)}
	${e.join(`,
	`)}`);for(let f of r.concat(i||[]))u.push(`${n(o)} ${f}`);return s&&u.push(`${n(i&&t(N.fromJSON(this,i.ARGUMENT))||o)} ${s}`),u.join(`;
`)}static parse(t,e,r){let[i,s,n,u]=new RegExp(`^${this.CLAUSE}\\s+(${this.KINDS.map(h=>h).join("|")})\\s+(?:(IF\\s+EXISTS)\\s+)?([\\s\\S]+)$`,"i").exec(e.trim())||[];if(!i)return;let o=new this(t,s.toUpperCase()),[f,l]=m.split(u,["\\s+"],{useRegex:!0,limit:1});return o.name(r(o,f,[N])),o.action(...m.split(l,[","]).map(h=>r(o,h,this.NODE_TYPES))),n&&o.withFlag("IF_EXISTS"),o}static get CLAUSE(){return"ALTER"}static NODE_TYPES=[bt,Se,Ne,Ot,_t,Wt,gt];static KINDS=["TABLE","SCHEMA","DATABASE"]};var K=class extends wt(B){toJSON(){return{name:this.NAME.toJSON(),...super.toJSON()}}static fromJSON(t,e){if(e.name)return super.fromJSON(t,e)?.name(e.name)}stringify(){let t=this.getFlag("RESTRICT")||this.getFlag("CASCADE"),r=(i=>{if(i.PREFIX||["SCHEMA","DATABASE"].includes(this.KIND))return i;let s=this.$trace("get:name:database");return i.clone().name([s,i.NAME])})(this.name());return`${this.CLAUSE}${this.getFlag("TEMPORARY")?" TEMPORARY":""} ${this.KIND}${this.hasFlag("IF_EXISTS")?" IF EXISTS":""} ${r}${t?` ${t}`:""}`}static parse(t,e,r){let[i,s,n,u,o,f]=new RegExp(`^${this.CLAUSE}\\s+(TEMPORARY\\s+)?(${this.KINDS.map(h=>h).join("|")})\\s+(?:(IF\\s+EXISTS)\\s+)?([\\s\\S]+?)(?:\\s+(RESTRICT|CASCADE|FORCE))?$`,"i").exec(e.trim())||[];if(!i)return;let l=new this(t,n.toUpperCase());return l.name(r(l,o,[N])),s&&l.withFlag("TEMPORARY"),u&&l.withFlag("IF_EXISTS"),f&&l.withFlag(f),l}static get CLAUSE(){return"DROP"}static KINDS=["TABLE","SCHEMA","DATABASE"]};var Ht=class extends Gt{COLUMNS=[];CONSTRAINTS=[];INDEXES=[];NODES=new Set;static get WRITABLE_PROPS(){return["PREFIX"].concat(super.WRITABLE_PROPS)}static get SUBTREE_PROPS(){return["COLUMNS","CONSTRAINTS","INDEXES"]}static CONSTRAINT_TYPES=[Ct,ht,yt,st];$trace(t,...e){return t==="get:schema:table"?this:t==="get:name:table"?this.NAME.NAME:t==="get:name:database"&&this.NAME.PREFIX?this.NAME.PREFIX:(t==="event:connected"&&[Y,M,X].some(r=>e[0]instanceof r)&&this.NODES.add(e[0]),super.$trace(t,...e))}primaryKey(){return[...this.NODES].find(t=>t.TYPE==="PRIMARY_KEY")}foreignKeys(){return[...this.NODES].filter(t=>t.TYPE==="FOREIGN_KEY")}uniqueKeys(){return[...this.NODES].filter(t=>t.TYPE==="UNIQUE_KEY")}checks(){return[...this.NODES].filter(t=>t.TYPE==="CHECK")}column(t){return typeof t=="string"?this.COLUMNS.find(e=>this.isSame(e.name(),t,"ci")):(this.build("COLUMNS",[t],Y),this.COLUMNS[this.COLUMNS.length-1])}constraint(t){return typeof t=="string"?this.CONSTRAINTS.find(e=>this.isSame(e.name(),t,"ci")):(this.build("CONSTRAINTS",[t],this.constructor.CONSTRAINT_TYPES),this.CONSTRAINTS[this.CONSTRAINTS.length-1])}index(t){return typeof t=="string"?this.INDEXES.find(e=>this.isSame(e.name(),t,"ci")):(this.build("INDEXES",[t],X),this.INDEXES[this.INDEXES-1])}diffWith(t){super.diffWith(t);let e=(o,f)=>[...o.NODES].find(l=>l.NAME===f),r=o=>[...o.NODES].reduce(([f,l],h)=>[Y,M,X].some(p=>h instanceof p)?h.NAME?[f.add(h.NAME),l]:[f,l.add(h)]:[f,l],[new Set,new Set]),[i]=r(this),[s,n]=r(t),u=o=>{if(o instanceof M)if(o.CONTEXT instanceof Y){let f=o.CONTEXT.NAME;if(!i.has(f))return;e(this,f).constraint(o.toJSON())}else this.constraint(o.toJSON());else o instanceof X?this.index(o.toJSON()):this.column(o.toJSON())};for(let o of new Set([...i,...s])){let f=e(this,o),l=e(t,o);i.has(o)&&!s.has(o)?f.keep(!1):i.has(o)?f.diffWith(l):u(l)}for(let o of n)u(o);return this}alterWith(t){let e=(r,i=!1)=>{let s=[...this.NODES].find(n=>(r.kind==="COLUMN"?n instanceof Y:r.kind==="CONSTRAINT"?n instanceof M:n.TYPE===r.kind)&&(r.name?this.isSame(n.NAME,r.name,"ci"):r.kind==="PRIMARY_KEY"));if(!s&&!i)throw new Error(`${r.kind}${r.name?` "${r.name}"`:""} does not exist.`);return s};for(let r of t.ACTIONS)if(r.CLAUSE==="RENAME")r.KIND?e({kind:r.KIND,name:r.name()}).name(r.argument()):this.name([this.name().PREFIX,r.argument()]);else if(r.CLAUSE==="ADD")r.argument()instanceof M?r.argument().columns().length===1?e({kind:"COLUMN",name:r.argument().columns()[0]}).constraint(r.argument().toJSON()):this.constraint(r.argument().toJSON()):r.argument()instanceof X?this.index(r.argument().toJSON()):(!r.hasFlag("IF_NOT_EXISTS")||!e({kind:"COLUMN",name:r.argument().name()},!0))&&this.column(r.argument().toJSON());else if(r.CLAUSE==="DROP")e(r.toJSON(),r.hasFlag("IF_EXISTS"))?.keep(!1);else if(r.CLAUSE==="SET")r.KIND==="SCHEMA"&&this.name([r.argument(),this.name().NAME]);else if(["CHANGE","MODIFY"].includes(r.CLAUSE))(r.CLAUSE==="CHANGE"?e({kind:"COLUMN",name:r.name()}):e({kind:"COLUMN",name:r.argument().name()})).diffWith(r.argument());else if(r.CLAUSE==="ALTER"){let i=e({kind:r.KIND,name:r.name()},r.hasFlag("IF_EXISTS"));if(!i)continue;let s=r.argument();if(s.CLAUSE==="ADD"){if(s.argument().TYPE==="EXPRESSION")throw new Error("Cannot add EXPRESSION constraint after column creation.");if(i.constraint(s.argument().TYPE))throw new Error(`Constraint ${s.argument().TYPE} already exists on ${i.name()}.`);i.constraint(s.argument())}else if(s.CLAUSE==="DROP"){let n=i.constraint(s.KIND);if(n)n.keep(!1);else if(["IDENTITY","EXPRESSION"].includes(s.KIND)&&!s.hasFlag("IF_EXISTS"))throw new Error(`Cannot drop ${s.KIND}; does not exist.`)}else if(s.CLAUSE==="SET"){if(s.argument()instanceof k)i.type(s.argument().toJSON());else if(["DEFAULT","ON_UPDATE"].includes(s.KIND))i.constraint(s.KIND,s.argument());else if(["NOT_NULL","NULL","AUTO_INCREMENT"].includes(s.KIND))i.constraint(s.KIND,!0);else if(s.KIND==="IDENTITY"){let n=i.identity();if(!n)throw new Error(`Cannot modify IDENTITY constraint on ${i.name()}; does not exist.`);n.always(/^ALWAYS$/i.test(s.argument()))}}}return this}getAlt(){let t=V.fromJSON(this.CONTEXT,{kind:"TABLE",name:this.NAME.toJSON(),actions:[]});this.$NAME&&this.NAME&&(this.isSame(this.$NAME.NAME,this.NAME.NAME,"ci")||t.rename(null,null,this.$NAME.NAME),this.$NAME.PREFIX&&!this.isSame(this.$NAME.PREFIX,this.NAME.PREFIX,"ci")&&t.set("SCHEMA",this.$NAME.PREFIX));let e=(i,s=!1)=>i.keep()!==!0||["$EXPR","$ALWAYS","$TARGET_TABLE","$TARGET_COLUMNS","$MATCH_RULE","$UPDATE_RULE","$DELETE_RULE"].concat(s?"$NAME":[]).some(n=>n in i&&(Array.isArray(i[n])?i[n].length:![void 0,null].includes(i[n]))&&!this.isSame(i[n.slice(1)],i[n],"ci"));for(let i of this.COLUMNS){if(i.keep()===!1){t.drop("COLUMN",i.NAME);continue}if(i.keep()!==!0){t.add("COLUMN",i.clone());continue}if(i.keep()===!0){if(this.params.dialect==="mysql")if(i.$TYPE&&!this.isSame(i.$TYPE.toJSON(),i.TYPE.toJSON(),"ci")||i.CONSTRAINTS.some(n=>["EXPRESSION","NOT_NULL","NULL","AUTO_INCREMENT","ON_UPDATE"].includes(n.TYPE)&&e(n,!0))){let n=i.clone();n.CONSTRAINTS=n.CONSTRAINTS.filter(u=>!(u instanceof M)),t.modify("COLUMN",n)}else{let n=i.CONSTRAINTS.find(u=>u.TYPE==="DEFAULT"&&e(u,!0));n&&t.alter("COLUMN",i.NAME,u=>{n.keep()===!1?u.drop("DEFAULT"):a.set("DEFAULT",n.expr())}),i.$NAME&&!this.isSame(i.$NAME,i.NAME,"ci")&&t.rename("COLUMN",i.NAME,i.$NAME)}else{i.$TYPE&&!this.isSame(i.$TYPE.toJSON(),i.TYPE.toJSON(),"ci")&&t.alter("COLUMN",i.NAME,{clause:"SET",kind:"DATA_TYPE",argument:k.fromJSON(i,i.$TYPE.toJSON())});let n=i.CONSTRAINTS.filter(u=>!(u instanceof M)&&e(u,!0));for(let u of n)t.alter("COLUMN",i.NAME,(()=>{if(u.keep()===!1)return{clause:"DROP",kind:u.TYPE};if(u.TYPE==="EXPRESSION")throw new Error("EXPRESSION constraints cannot be added or modified after column creation.");if(u.TYPE==="IDENTITY")return u.keep()?{clause:"SET",kind:"IDENTITY",argument:u.always()?"ALWAYS":!0}:{clause:"ADD",argument:u.clone()};if(["DEFAULT"].includes(u.TYPE))return{clause:"SET",kind:u.TYPE,argument:u.expr()};if(["NOT_NULL"].includes(u.TYPE))return{clause:"SET",kind:u.TYPE}})());i.$NAME&&!this.isSame(i.$NAME,i.NAME,"ci")&&t.rename("COLUMN",i.NAME,i.$NAME)}let s=i.CONSTRAINTS.filter(n=>n instanceof M);for(let n of s)if(e(n)){if([!0,!1].includes(n.keep())&&t.drop(n.TYPE,n.NAME),n.keep()!==!1){let u=i.$trace("get:schema:table").altsCascaded?i.name():i.NAME,o=this.constructor.CONSTRAINT_TYPES.find(f=>f.TYPE===n.TYPE).fromJSON(n.CONTEXT,{...n.toJSON(),columns:[u]});t.add(o.TYPE,o)}}else n.keep()===!0&&n.$NAME&&!this.isSame(n.$NAME,n.NAME,"ci")&&t.rename("CONSTRAINT",n.NAME,n.$NAME)}}let r=i=>e(i)||i.$COLUMNS?.length&&!this.isSame(i.$COLUMNS,i.COLUMNS,"ci");for(let i of this.CONSTRAINTS)r(i)?([!0,!1].includes(i.keep())&&t.drop(i.TYPE,i.NAME),i.keep()!==!1&&t.add(i.TYPE,i.clone())):i.keep()===!0&&i.$NAME&&!this.isSame(i.$NAME,i.NAME,"ci")&&t.rename("CONSTRAINT",i.NAME,i.$NAME);return t}cascadeAlt(){this.keep(this.keep(),"auto");let t=r=>r.dropped()?"DOWN":r.$NAME&&!this.isSame(r.$NAME,r.NAME,"ci")?"RENAME":null,e=t(this);for(let r of this.COLUMNS){let i=t(r);if(i)for(let s of this.CONSTRAINTS){if(s instanceof st)continue;let n=s.$COLUMNS.length?s.$COLUMNS:s.COLUMNS,u=n.indexOf(r.NAME);u>-1&&(i==="DOWN"?n.splice(u,1):i==="RENAME"&&(n[u]=r.$NAME))}}return this.altsCascaded=!0,this}updateDatabaseReferences(t,e){for(let r of this.foreignKeys())r.targetTable().PREFIX===t.NAME&&(e==="DOWN"?r.keep(!1):e==="RENAME"&&r.targetTable().name([t.$NAME,r.targetTable().NAME]))}updateTableReferences(t,e){for(let r of this.foreignKeys())r.targetTable().PREFIX&&t.PREFIX&&node.targetTable().prefix()!==t.prefix()||node.targetTable().name()===t.NAME&&(e==="DOWN"?node.keep(!1):e==="RENAME"&&node.targetTable().name(t.$NAME))}updateColumnReferences(t,e){for(let r of this.NODES){if(!(r instanceof dt)||r.targetTable().prefix()&&t.$trace("get:name:database")&&r.targetTable().prefix()!==t.$trace("get:name:database")||r.targetTable().name()!==t.$trace("get:table:name"))continue;let i=cons.$TARGET_COLUMNS.length?cons.$TARGET_COLUMNS:cons.TARGET_COLUMNS,s=i.indexOf(t.NAME);s>-1&&(e==="DOWN"?i.splice(s,1):e==="RENAME"&&(i[s]=t.$NAME))}}toJSON(){return super.toJSON({columns:this.COLUMNS.map(t=>t.toJSON()),constraints:this.CONSTRAINTS.map(t=>t.toJSON()),indexes:this.INDEXES.map(t=>t.toJSON())})}static fromJSON(t,e){if(!(!Array.isArray(e?.columns)||["constraints","indexes"].some(r=>r in e&&!Array.isArray(e[r]))))return super.fromJSON(t,e,()=>{let r=new this(t);for(let i of e.columns)r.column(i);for(let i of e.constraints||[])r.constraint(i);for(let i of e.indexes||[])r.index(i);return r})}stringify(){let t=[this.COLUMNS.map(s=>s.stringify()).join(`,
	`)],e=this.CONSTRAINTS.slice(0),r=this.INDEXES.slice(0);this.params.dialect==="mysql"&&e.push(...this.COLUMNS.reduce((s,n)=>{let u=n.foreignKey();return u?s.concat(ht.fromJSON(this,{...u.toJSON(),columns:[n.name()]})):s},[])),e.length&&t.push(e.map(s=>s.stringify()).join(`,
	`)),r.length&&t.push(r.map(s=>s.stringify()).join(`,
	`));let i=this.name();if(!i.PREFIX){let s=this.$trace("get:name:database");i=i.clone().name([s,i.NAME])}return`${i} (
	${t.join(`,
	`)}
)`}static parse(t,e,r){let[i,s,...n]=m.split(e,[],{limit:2});if(!i||!x(s||"","(",")"))return;let u=new this(t);u.name(r(u,i.trim(),[N]));let o=m.split(w(s,"(",")"),[","]).map(f=>r(u,f.trim(),[Ct,ht,yt,st,X,Y]));for(let f of o)f instanceof Y?u.column(f):f instanceof X?u.index(f):u.constraint(f);return u}};var nt=class extends Gt{TABLES=[];static get SUBTREE_PROPS(){return["TABLES"]}$trace(t,...e){return t==="get:schema:database"?this:t==="get:name:database"?this.NAME.NAME:super.$trace(t,...e)}table(t){return typeof t=="string"?this.TABLES.find(e=>this.isSame(e.name().NAME,t,"ci")):(this.build("TABLES",[t],Ht),this.TABLES[this.TABLES.length-1])}foreignKeys(){return this.TABLES.reduce((t,e)=>t.concat(e.foreignKeys()),[])}diffWith(t){super.diffWith(t);let e=(n,u)=>n.TABLES.find(o=>this.isSame(o.NAME.NAME,u,"ci")),r=n=>new Set(n.TABLES.map(u=>u.NAME.NAME)),i=r(this),s=r(t);for(let n of new Set([...i,...s])){let u=e(this,n),o=e(t,n);i.has(n)&&!s.has(n)?u.keep(!1):i.has(n)?u.diffWith(o):this.table(o.toJSON())}return this}alterWith(t){let e=(r,i=!1)=>{let s=this.TABLES.find(n=>this.isSame(n.NAME.NAME,r,"ci"));if(!s&&!i)throw new Error(`TABLE ${r} does not exist.`);return s};for(let r of t.ACTIONS)if(r.CLAUSE==="RENAME")r.KIND?e(r.name()).name(r.argument()):this.name(r.argument());else if(r.CLAUSE==="DROP")e(r.name(),r.hasFlag("IF_EXISTS"))?.keep(!1);else if(r.CLAUSE==="ADD")(!r.hasFlag("IF_NOT_EXISTS")||!e(r.argument().name().NAME,!0))&&this.table(r.argument().toJSON());else if(r.CLAUSE==="MODIFY"){let i=e(r.argument().name().NAME,r.hasFlag("IF_EXISTS"));if(!i)continue;i.diffWith(r.argument())}return this}getAlt(){let t=V.fromJSON(this.CONTEXT,{kind:"SCHEMA",name:this.NAME.toJSON(),actions:[]});this.$NAME&&!this.isSame(this.$NAME.NAME,this.NAME.NAME,"ci")&&t.rename(null,null,this.$NAME.NAME);for(let e of this.TABLES)if(typeof e.keep()!="boolean")t.SUBTREE.push(G.fromJSON(this,{kind:"TABLE",argument:e.clone()}));else if(e.keep()===!1)t.SUBTREE.push(K.fromJSON(this,{kind:"TABLE",name:e.name().toJSON()}));else{let r=e.getAlt();r.length&&t.SUBTREE.push(r)}return t}toJSON(){return super.toJSON({tables:this.TABLES.map(t=>t.toJSON())})}static fromJSON(t,e){if(!(!e||["tables"].some(r=>r in e&&!Array.isArray(e[r]))))return super.fromJSON(t,e,()=>{let r=new this(t);for(let i of e.tables||[])r.table(i);return r})}stringify(){return this.name()+""}static parse(t,e,r){let i=new this(t);return i.name(r(i,e.trim(),[N])),i}};var G=class extends wt(_t){get NAME(){return this.ARGUMENT?.NAME}stringify(){let t=[super.stringify()];return["SCHEMA","DATABASE"].includes(this.KIND)&&t.push(...this.argument().TABLES.map(e=>this.constructor.fromJSON(this,{kind:"TABLE",argument:e}))),t.join(`;
`)}static get CLAUSE(){return"CREATE"}static NODE_TYPES=[Ht,nt];static KINDS=["TABLE","SCHEMA","DATABASE"]};var Ae=class extends wt(bt){static KINDS=["TABLE","SCHEMA","DATABASE"]};var ir=[G,V,K,Ae,Z,At,lt,H,...I.Types];var Te=class{static grammar=ir;static parse(t,e,r,i={}){if(!e?.length)return;let s=r?.length?r:this.grammar;for(let n of s){let u=this.parseOne(t,e,n,i);if(u)return i.log&&console.log(".................",e,".................>",u.constructor.name),u}if(i.assert!==!1)throw new SyntaxError(e)}static parseOne(t,e,r,i={}){return r.parse(t,e,(s,n,u,o={})=>this.parse(s,n,u,{...i,...o}))}};var ee=class{constructor(t,e,r="backward"){Object.defineProperty(this,"$",{value:{client:t,json:e,direction:r}})}get client(){return this.$.client}get direction(){return this.$.direction}get id(){return this.$.json.id}get databaseTag(){return this.$.json.database_tag}get versionTag(){return this.$.json.version_tag}get versionMax(){return this.$.json.version_max}get cursor(){return this.$.json.$cursor}get description(){return this.$.json.savepoint_description}get savepointDate(){return this.$.json.savepoint_date}get rollbackDate(){return this.$.json.rollback_date}get keep(){return this.$.json.keep}get rollbackEffect(){let t=typeof this.$.json.keep!="boolean"?["DROP","RECREATE"]:this.$.json.keep===!1?["RECREATE","DROP"]:["ALTER"];return this.direction==="forward"?t.reverse()[0]:t[0]}get rollbackQuery(){let t=nt.fromJSON(this.client,this.schema());return this.direction!=="forward"&&(t.reverseAlt(!0),t.keep(t.keep(),"auto")),t.keep()===!1?K.fromJSON(this.client,{kind:"SCHEMA",name:t.name()}).withFlag(this.client.params.dialect==="mysql"?"":"CASCADE"):t.keep()===!0?t.getAlt().with({resultSchema:t}):G.fromJSON(this.client,{kind:"SCHEMA",argument:t})}name(t=!1){return t?this.direction==="forward"&&this.$.json.$name||this.$.json.name:this.direction!=="forward"&&this.$.json.$name||this.$.json.name}schema(){let{name:t,$name:e,tables:r=[],keep:i}=this.$.json;return{name:t,...e?{$name:e}:{},tables:r,keep:i}}toJSON(){let{id:t,database_tag:e,version_tag:r,version_max:i,$cursor:s,savepoint_description:n,savepoint_date:u,rollback_date:o}=this.$.json;return{id:t,name:this.name(),databaseTag:e,versionTag:r,versionMax:i,cursor:s,description:n,savepointDate:u,rollbackDate:o,rollbackEffect:this.rollbackEffect}}async isNextPointInTime(){return(await this.client.database(this.name()).savepoint({direction:this.direction})||{}).id===this.$.json.id}async rollback(){if(!await this.isNextPointInTime())throw new Error("Invalid rollback order.");await this.client.query(this.rollbackQuery,{noCreateSavepoint:!0});let e=await(await this.client.linkedDB()).savepointsTable(),r=await this.client.query(`UPDATE ${e.ident} SET rollback_date = ${this.direction==="forward"?"NULL":"now()"} WHERE id = '${this.$.json.id}' RETURNING rollback_date`);return this.$.json.rollback_date=r[0].rollback_date,!0}};var de=class extends d{DATABASES=[];get[Symbol.iterator](){return this.DATABASES[Symbol.iterator]}get length(){return this.DATABASES.length}$trace(t,...e){return t==="get:node:schemas"?this:super.$trace(t,...e)}database(t){return typeof t=="string"?this.DATABASES.find(e=>e.isSame(e.name().NAME,t,"ci")):(this.build("DATABASES",[t],nt),this.DATABASES[this.DATABASES.length-1])}foreignKeys(){return this.DATABASES.reduce((t,e)=>t.concat(e.foreignKeys()),[])}cascadeAlt(t=[]){this.keep(this.keep(),"auto");let e=t.filter(i=>i.isSame(i.name().NAME,this.name().NAME,"ci")),r=this.dropped()?"DOWN":this.$NAME&&this.$NAME!==this.NAME?"RENAME":null;if(r==="DOWN"&&(t=t.filter(i=>i!==e)),r)for(let i of t.reduce((s,n)=>s.concat(n.TABLES)))i.updateDatabaseReferences(this,r);for(let i of this.TABLES)i.cascadeAlt();return this.altsCascaded=!0,this}toJSON(){return this.DATABASES.map(t=>t.toJSON())}static fromJSON(t,e){if(!Array.isArray(e))return;let r=new this(t);for(let i of e)r.database(i);return r}};var _e=class{static CONST=Object.freeze({LINKED_DB:Object.freeze({name:["linked_db","obj_information_schema"],savepointsTable:["savepoints","database_savepoints"]})});constructor(t={}){Object.defineProperty(this,"$",{value:t})}get params(){return this.$.params||{}}$trace(t,...e){if(t==="get:api:client")return this;if(t==="get:client:kind")return this.constructor.kind}async $init(){this.$.initialised||(this.$.initialised=!0,this.params.nameResolution&&await this.nameResolution(this.params.nameResolution))}async savepoints(t={}){let e=await this.linkedDB(),r=e&&await e.savepointsTable();return r?(await this.query(`
            SELECT id, database_tag, name, ${N.fromJSON(this,"$name")}, keep, version_tag, version_max, CONCAT(rank_for_cursor, '/', total) AS ${N.fromJSON(this,"$cursor")}, savepoint_description, tables, savepoint_date, rollback_date FROM (
                SELECT *,
                ROW_NUMBER() OVER (PARTITION BY database_tag ORDER BY rollback_date IS NOT NULL ${t.direction==="forward"?"DESC":"ASC"}, version_tag ${t.direction==="forward"?"ASC":"DESC"}) AS rank_for_target,
                ROW_NUMBER() OVER (PARTITION BY database_tag ORDER BY version_tag ASC) AS rank_for_cursor,
                MAX(version_tag) OVER (PARTITION BY database_tag) AS version_max,
                COUNT(version_tag) OVER (PARTITION BY database_tag) AS total
                FROM ${r.ident}
            ) AS savepoint WHERE rollback_date IS ${t.direction==="forward"?"NOT NULL":"NULL"} AND rank_for_target = 1${t.name?t.direction==="forward"?` AND name = '${t.name}'`:` AND COALESCE(${N.fromJSON(this,"$name")}, name) = '${t.name}'`:""}
        `)).map(s=>new ee(this,s,t.direction)):[]}async schemas(){return await this.schemasCallback(()=>[])}async databases(){return await this.databasesCallback(()=>[])}database(t,e={}){return new this.constructor.Database(this,...arguments)}async hasDatabase(t){return await this.$init(),(await this.databases()).includes(t)}async createDatabase(t,e={}){if(typeof t=="string")t={name:t};else if(typeof t?.name!="string")throw new Error("createDatabase() called with invalid arguments.");await this.$init();let r=G.fromJSON(this,{kind:"SCHEMA",argument:t});return e.ifNotExists&&r.withFlag("IF_NOT_EXISTS"),await this.query(r,e)}async alterDatabase(t,e,r={}){if(typeof e!="function")throw new Error("alterDatabase() called with invalid arguments.");if(typeof t=="string")t={name:t};else if(typeof t?.name!="string")throw new Error("alterDatabase() called with invalid arguments.");await this.$init();let i=await this.database(t.name).schema(t.tables);if(!i)throw new Error(`Database "${t.name}" does not exist.`);await e(i.keep(!0,!0));let s=i.getAlt().with({resultSchema:i});if(s.length)return await this.query(s,r)}async dropDatabase(t,e={}){if(typeof t!="string")throw new Error(`dropDatabase() called with an invalid name: ${t}.`);await this.$init();let r=K.fromJSON(this,{kind:"SCHEMA",name:t});return e.ifExists&&r.withFlag("IF_EXISTS"),e.cascade&&r.withFlag("CASCADE"),await this.query(r,e)}async createSavepoint(t,e=null){let i=await(await this.linkedDB(!0)).savepointsTable(!0),{name:s,$name:n,...u}=t.toJSON(),o={name:s,$name:n,database_tag:null,...u,version_tag:null,savepoint_description:e,savepoint_date:new Date},f=t.NAME,l=await this.database(f).savepoint({direction:"forward"})||await this.database(f).savepoint();l?(o.database_tag=l.databaseTag,o.version_tag=l.versionMax+1,l.direction==="forward"?await i.delete(p=>p.where(E=>E.equals("database_tag",S=>S.value(l.databaseTag)),E=>E.isNotNull("rollback_date"))):o.version_tag=l.versionTag+1):(o.database_tag=`db:${(0|Math.random()*9e6).toString(36)}`,o.version_tag=1);let h=await i.insert(o,{returning:"*"});return new ee(this,{...h,version_max:o.version_tag,$cursor:null})}async schemasCallback(t,e={}){return await this.$init(),Object.keys(e).length||(e=Object.fromEntries((this.systemDatabases||[]).map(r=>[r,!1]))),de.fromJSON(this,await t(e))}async databasesCallback(t){return await this.$init(),await t()}async queryCallback(t,e,r={}){if(typeof e=="string")e=Te.parse(this,e,null,{log:r.log});else if(!(e instanceof d))throw new Error("query() called with invalid arguments.");await this.$init();let i=e.$trace("get:name:table"),s=e.$trace("get:name:database")||i&&await this.resolveName(i,!0),n=N.fromJSON(this,i?[s,i]:[s]),u={},o=s&&!new RegExp(s,"i").test(this.constructor.CONST.LINKED_DB.name[0])&&!r.noCreateSavepoint;if([G,V,K].some(l=>e instanceof l)&&o){if(["DATABASE","SCHEMA"].includes(e.KIND)){if(e instanceof K){let l=(await e.$schema(s)).keep(!1);e.with({resultSchema:l})}else if(e instanceof V&&!e.resultSchema){let l=e.ACTIONS.map(p=>p.CLAUSE==="MODIFY"?p.ARGUMENT.$trace("get:name:table"):p.CLAUSE==="DROP"?p.name():null).filter(p=>p),h=await e.$schema(s);l.length&&(h.TABLES=h.TABLES.filter(p=>!l.includes(p.name().NAME))),h.keep(!0,!0).alterWith(e),e.with({resultSchema:h})}else e instanceof G&&e.with({resultSchema:e.ARGUMENT});u.savepoint=e.resultSchema}else if(e.KIND==="TABLE"){let l=this.database(s);if(e instanceof K){let h=(await e.$schema(s,i)).keep(!1);e.with({resultSchema:h})}else if(e instanceof V&&!e.resultSchema){let h=(await e.$schema(s,i)).keep(!0,!0).alterWith(e);e.with({resultSchema:h})}else e instanceof G&&e.with({resultSchema:e.ARGUMENT});u.savepoint=nt.fromJSON(this,{name:l.name,tables:[e.resultSchema]}).keep(!0)}}let f=await t(n,e,r);return u.savepoint?(u.savepoint.keep(u.savepoint.keep(),"auto"),await this.createSavepoint(u.savepoint,r.description)):f}async resolveName(t,e=!1){let r=await this.resolutionPath();return await r.reduce(async(i,s)=>await i||await this.database(s).hasTable(t)?s:null,null)||(e?r.find(i=>!i.startsWith("$"))||r[0]:null)}async resolutionPath(t=[]){return arguments.length?(this.$.resolutionPath=[].concat(t),this):this.$.resolutionPath||[]}async linkedDB(t=!1){let e=this.constructor.CONST;if(!e.LINKED_DB.name.exists){let i=(await this.databases()).find(s=>e.LINKED_DB.name.includes(s));if(!i&&!t)return;i?i!==e.LINKED_DB.name[0]&&await this.alterDatabase(i,s=>s.name(e.LINKED_DB.name[0]),{noCreateSavepoint:!0}):await this.createDatabase(e.LINKED_DB.name[0],{noCreateSavepoint:!0}),e.LINKED_DB.name.exists=!0}let r=this.database(e.LINKED_DB.name[0]);return Object.defineProperty(r,"savepointsTable",{value:async(i=!1)=>{if(!e.LINKED_DB.savepointsTable.exists){let s=(await r.tables()).find(n=>e.LINKED_DB.savepointsTable.includes(n));if(!s&&!i)return;s?s!==e.LINKED_DB.savepointsTable[0]&&await r.alterTable(s,n=>n.name(e.LINKED_DB.savepointsTable[0]),{noCreateSavepoint:!0}):await r.createTable({name:e.LINKED_DB.savepointsTable[0],columns:[{name:"id",...this.params.dialect==="mysql"?{type:"char(36)",default:{expr:"uuid()"}}:{type:"uuid",default:{expr:"gen_random_uuid()"}},primaryKey:!0},{name:"name",type:["varchar",255],notNull:!0},{name:"$name",type:["varchar",255]},{name:"tables",type:"json"},{name:"keep",type:this.params.dialect==="mysql"?["bit",1]:"boolean"},{name:"savepoint_description",type:["varchar",255]},{name:"database_tag",type:["varchar",12],notNull:!0},{name:"version_tag",type:"int",notNull:!0},{name:"savepoint_date",type:["timestamp",3],notNull:!0},{name:"rollback_date",type:["timestamp",3]}]},{noCreateSavepoint:!0}),e.LINKED_DB.savepointsTable.exists=!0}return r.table(e.LINKED_DB.savepointsTable[0])}}),r}};var ge=class{constructor(t,e,r={}){Object.defineProperty(this,"$",{value:{client:t,name:e,params:r}})}get client(){return this.$.client}get name(){return this.$.name}get ident(){return N.fromJSON(this,this.name)}get params(){return Object.assign({},this.client.params,this.$.params)}$trace(t,...e){return t==="get:api:database"?this:t==="get:name:database"?this.name:this.client.$trace(t,...e)}async $init(){await this.client.$init()}async savepoint(t={}){return(await this.client.savepoints({...t,name:this.name}))[0]}async schema(t=["*"]){return(await this.client.schemas({[this.name]:t})).database(this.name)}async tables(){return await this.tablesCallback(()=>[])}table(t,e={}){return new this.constructor.Table(this,...arguments)}async hasTable(t){return await this.$init(),(await this.tables()).includes(t)}async createTable(t,e={}){if(await this.$init(),typeof t?.name!="string")throw new Error("createTable() called with invalid arguments.");let r=G.fromJSON(this,{kind:"TABLE",argument:t});return e.ifNotExists&&r.withFlag("IF_NOT_EXISTS"),this.client.query(r,e)}async alterTable(t,e,r={}){if(await this.$init(),typeof e!="function"||typeof t!="string")throw new Error("alterTable() called with invalid arguments.");let i=(await this.table(t).schema())?.keep(!0,!0);if(!i)throw new Error(`Table "${t}" does not exist.`);await e(i);let s=i.getAlt().with({resultSchema:i});if(s.length)return r.ifExists&&s.withFlag("IF_EXISTS"),this.client.query(s,r)}async dropTable(t,e={}){if(await this.$init(),typeof t!="string")throw new Error("dropTable() called with invalid arguments.");let r=K.fromJSON(this,{kind:"TABLE",name:t});return e.ifExists&&r.withFlag("IF_EXISTS"),e.cascade&&r.withFlag("CASCADE"),this.client.query(r,e)}async tablesCallback(t){return await this.$init(),await t()}};var Oe=class{constructor(t,e,r={}){this.$={database:t,name:e,params:r}}get database(){return this.$.database}get name(){return this.$.name}get ident(){return N.fromJSON(this,[this.database.name,this.name])}get params(){return Object.assign({},this.database.params,this.$.params)}$trace(t,...e){return t==="get:api:table"?this:t==="get:table:name"?this.name:this.database.$trace(t,...e)}async $init(){await this.database.$init()}async savepoint(){await this.$init()}async schema(){return await this.$init(),(await this.database.schema([this.name])).table(this.name)}async count(...t){await this.$init();let e=[].concat(Array.isArray(t[0])?t.shift():"*");if(e.length!==1)throw new Error("Count expects exactly one field.");let r=await this.select([i=>i.fn("COUNT",e[0]).as("c")],...t);return Array.isArray(r)?r[0].c:r.c}async select(...t){await this.$init();let e=new H(this.database.client);e.from(this.ident.toJSON());let r=Array.isArray(t[0])?t.shift():["*"];e.select(...r);let i=t.shift()||{};await this.$applyModifiers(e,i);let s=await this.database.client.query(e);return["string","number"].includes(typeof i.where)?s[0]:s}async insert(...t){await this.$init();let e=new Z(this.database.client);e.into(this.ident.toJSON());let{columns:r=[],values:i=[],modifiers:s,singular:n,preHook:u,postHook:o}=await this.$resolveInsert(e,t,"insert");u&&await u(),r.length&&e.columns(...r);for(let l of i)e.values(...l);O(s)&&s.returning?e.returning(...[].concat(s.returning)):J(s)&&s(e);let f=await this.database.client.query(e);return o&&(f=await o(f)),n&&(f=f[0]),f}async upsert(...t){await this.$init();let e=new Z(this.database.client);e.into(this.ident.toJSON());let{columns:r=[],values:i=[],modifiers:s,singular:n,preHook:u,postHook:o}=await this.$resolveInsert(e,t,"upsert");u&&await u(),r.length&&e.columns(...r);for(let l of i)e.values(...l);if(O(s)&&s.returning?e.returning(...[].concat(s.returning)):J(s)&&s(e),e.onConflict({entries:r.map((l,h)=>[l,i[0][h]])}),this.params.dialect==="postgres"){let h=(await e.$schema(this.database.name,this.name)).uniqueKeys().map(S=>S.columns());if(!h.length)throw new Error("Table has no unique keys defined. You may want to perform a direct INSERT operation.");let p=e.columns()?.toJSON().list||[],E=h.find(S=>Xt(S,p).length)||h[0];e.onConflict(S=>S.target(...E))}let f=await this.database.client.query(e);return o&&(f=await o(f)),n&&(f=f[0]),f}async update(t,e){if(await this.$init(),!e)throw new Error('The "modifiers" parameter cannot be ommitted.');let r=["string","number"].includes(typeof e.where)&&e.returning,i=new At(this.database.client);i.table(this.ident.toJSON());let s=Object.keys(t),n=Object.values(t),u,o;s.length&&e.experimentalRecursive?{columns:s,values:n,modifiers:e,preHook:u,postHook:o}=await this.$resolveRelations(i,s,n,e,"update"):n=n.map(l=>Me(l,this.params.autoBindings)),u&&await u(),s.forEach((l,h)=>i.set(l,n[h])),await this.$applyModifiers(i,e);let f=await this.database.client.query(i);return o&&(f=await o(f)),r&&(f=f[0]),f}async delete(t){if(await this.$init(),!t)throw new Error('The "modifiers" parameter cannot be ommitted.');let e=new lt(this.database.client);e.from(this.ident.toJSON()),await this.$applyModifiers(e,t);let r=await this.database.client.query(e);return["string","number"].includes(typeof t.where)&&t.returning&&(r=r[0]),r}async $resolveInsert(t,e,r){let i=[],s=[],n,u;if(Array.isArray(e[0])&&e[0].every(o=>typeof o=="string")&&Array.isArray(e[1])){if(!e[1].every(o=>Array.isArray(o)))throw new TypeError("Invalid payload format.");[i,s,n]=e.splice(0,3)}else{let o=O(e[0]),f=[].concat(e.shift());if(!O(f[0]))throw new TypeError("Invalid payload format.");i=Object.keys(f[0]),s=f.map(l=>Object.values(l)),n=e.shift(),u=o&&n?.returning}return i.length&&n?.experimentalRecursive?{...await this.$resolveRelations(t,i,s,n||{},r),singular:u}:(s=s.map(o=>o.map(f=>Me(f,this.params.autoBindings))),{columns:i,values:s,modifiers:n,singular:u})}async $resolveRelations(t,e,r,i,s){let n=await t.$schema(this.database.name,this.name),u=sr(n),o=i.returning,f=Object.fromEntries(n.columns().map(E=>[E.name(),E])),l={dependencies:new Map,dependents:new Map};r=r.map((E,S)=>E.reduce((T,A,_)=>{let C=e[_];if(f[C]?.foreignKey()&&O(A)){let R=f[C].foreignKey(),g=R.targetTable().stringify(),y=R.targetColumns()[0];return l.dependencies.has(g)||l.dependencies.set(g,new Map),l.dependencies.get(g).set([S,C,y],A),T.concat(void 0)}if(C.includes(":")&&!f[C]&&Array.isArray(A)){let[R,g]=[Vt(C,":"),Ge(C,":")];return l.dependents.has(R)||l.dependents.set(R,new Map),l.dependents.get(R).set([S,u,g],A),T}if(!f[C])throw new Error(`Unknown column name "${C}"`);return T.concat([Me(A,this.params.autoBindings)])},[])),e=e.filter(E=>!(E.includes(":")&&l.dependents.has(Vt(E,":"))));let h=async()=>{for(let[E,S]of l.dependencies){let T=[...S.keys()],A=[...S.values()],_=await this.database.table(E)[s](A,{experimentalRecursive:!0,returning:T[0][2]});T.forEach(([C,R,g],y)=>{r[C][R]=_[y][g]})}},p=async E=>{for(let[S,T]of l.dependents){let A=[...T.keys()],_=[...T.values()],C=[];A.forEach(([g,y,tt],$)=>{if(o){let re=C.length,nr=_[$].length;E[g][`${S}:${tt}`]=ar=>ar.slice(re,re+nr)}_[$].forEach(re=>{re[tt]=E[g][y],C.push(re)})});let R=await this.database.table(S)[s](C,{experimentalRecursive:!0,returning:o&&"*"});o&&E.forEach(g=>Object.keys(g).forEach(y=>{typeof g[y]=="function"&&(g[y]=g[y](R))}))}return o?([].concat(o).includes(u)||(E=E.map(S=>{let{[u]:T,...A}=S;return A})),E):E.length};return l.dependents.size&&![].concat(i.returning||[]).includes(u)&&(i={...i,returning:[].concat(i.returning||[]).concat(u)}),{columns:e,values:r,modifiers:i,preHook:h,postHook:p}}async $applyModifiers(t,e){if(e!==!0)if(O(e)){let r=i=>t.where(...Object.entries(i).map(([s,n])=>n===null?u=>u.isNull(s):u=>u.equals(s,Me(n,this.params.autoBindings))));if(["string","number"].includes(typeof e.where)){let i=await t.$schema(this.database.name,this.name);r({[sr(i)]:e.where})}else O(e.where)?r(e.where):e.where&&e.where!==!0&&t.where(e.where);e.limit&&t.limit(e.limit),e.returning&&t.returning(...[].concat(e.returning))}else J(e)?e(t):/^\d+$/.test(e)&&t.limit(e)}},sr=c=>{let t=c.primaryKey()?.columns()[0];if(!t)throw new Error("Cannot resolve primary key name for implied record.");return t},Me=(c,t)=>c instanceof Date?e=>e.value(c.toISOString().split(".")[0]):t!==!1?e=>e.$bind(0,c):[!0,!1,null].includes(c)?e=>e.sql(c):Array.isArray(c)?e=>e.array(c):O(c)?e=>e.object(c):e=>e.value(c);var Re=class{_pos=0;_eof=!1;_onfinish=[];constructor(t){this._cache=t}get eof(){return!this._cache.length||this._pos===this._cache.length-1}onfinish(t){this._onfinish.push(t)}next(){if(this.eof){this._onfinish.forEach(t=>t()),this._pos=0;return}this._pos++}async fetch(){if(!this.eof)return this._cache[this._pos]}};var Le=class extends Re{constructor(t){super([]),this._store=t,this._storeFetch=new Promise(async e=>{this.cache=await this._store.select(),e()})}async fetch(){return await this._storeFetch,super.fetch()}};var Ie=class extends Oe{getCursor(){return new Le(this)}};var Ce=class extends ge{static Table=Ie;async tables(){return await this.tablesCallback(async()=>{let t=`SELECT table_name FROM information_schema.tables WHERE table_schema = '${this.name}'`,e=await this.client.driver.query(t);return(e.rows||e).map(r=>r.table_name)})}};var ye=class extends _e{constructor(t,e={}){if(typeof t!="object")throw new Error("The options.driver parameter is required and must be an object.");if(typeof t.query!="function")throw new Error("The provided driver must expose a .query() function.");super({driver:t,params:e})}get driver(){return this.$.driver}get systemDatabases(){return this.params.dialect==="mysql"?[]:["information_schema","pg_catalog","pg_toast"]}static kind="sql";static Database=Ce;async schemas(t={}){return await this.schemasCallback(async e=>{let[r,i]=this.$getSchemasPrompt(e),s=await this.driver.query(r),n=await this.driver.query(i);return this.$formatSchemasResult(s.rows||s,n.rows||n,[])},...arguments)}async databases(){return await this.databasesCallback(async()=>{let e=await this.driver.query("SELECT schema_name FROM information_schema.schemata");return(e.rows||e).map(r=>r.schema_name)})}async query(t,e={}){return await this.queryCallback(async(r,i,s)=>{i.expandable&&await i.expand(!0);let n=[Z,At,lt].some(l=>i instanceof l),u;if(n&&this.params.dialect==="mysql"&&i.RETURNING_LIST.length){if(!this.params.mysqlReturningClause)throw new Error('Support for a "RETURNING" clause for mysql has not been enabled via "options.mysqlReturningClause".');[i,u]=await this.$mysqlReturningMagic(r,i)}let o=(i.BINDINGS||[]).concat(s.values||[]).map(l=>Array.isArray(l)||typeof l=="object"&&l?JSON.stringify(l):l),f=await this.driver.query(i.toString(),o);return u&&(f=await u()),i instanceof H||n&&i.RETURNING_LIST.length||u?f.rows||f:"rowCount"in f?f.rowCount:f.affectedRows},...arguments)}async resolutionPath(t=[]){if(arguments.length){t=[].concat(t).map(u=>N.fromJSON(this,u));let n=this.params.dialect==="mysql"?`USE ${t[0]}`:`SET SEARCH_PATH TO ${t.join(",")}`;return await this.driver.query(n)}let e,r;this.params.dialect==="mysql"?(e="SELECT database() AS default_db",r="default_db"):(e="SHOW SEARCH_PATH",r="search_path",e="SELECT current_setting('SEARCH_PATH')",r="current_setting");let i=await this.driver.query(e),s=((i.rows||i)[0]||{})[r];return m.split(s,[","]).map(n=>N.parseIdent(this,n.trim())[0])}async $mysqlReturningMagic(t,e){e=e.clone();let r=e.RETURNING_LIST.splice(0);if(e instanceof lt){let o=await this.driver.query(`SELECT ${r.join(", ")} FROM ${t}${e.WHERE_CLAUSE?` WHERE ${e.WHERE_CLAUSE}`:""}`);return[e,()=>o]}let i="obj_column_for_returning_clause_support",s=N.fromJSON(this,i);(await e.$schema(t.PREFIX,t.NAME)).column(i)||await this.driver.query(`ALTER TABLE ${t} ADD COLUMN ${s} char(36) INVISIBLE`);let u=(0|Math.random()*9e6).toString(36);if(!e.SET_CLAUSE&&e instanceof Z){if(!e.COLUMNS_CLAUSE&&(e.SELECT_CLAUSE||e.VALUES_LIST.length))throw new Error("Support for the RETURNING clause currently requires explicit column list in INSERT statements.");if(e.columns(i),e.SELECT_CLAUSE)e.SELECT_CLAUSE.select(o=>o.value(u));else if(e.VALUES_LIST.length)for(let o of e.VALUES_LIST)o.list(f=>f.value(u));else e.values(u)}else e.set(i,o=>o.value(u));return e instanceof Z&&e.ON_CONFLICT_CLAUSE&&e.ON_CONFLICT_CLAUSE.set(i,o=>o.value(u)),[e,async()=>{let o=await this.driver.query(`SELECT ${r.join(", ")} FROM ${t} WHERE ${s} = '${u}'`);return this.params.mysqlReturningClause==="WITH_AUTO_CLEANUP"&&await this.driver.query(`ALTER TABLE ${t} DROP COLUMN ${s}`),o}]}$getSchemasPrompt(t={}){let e="",r="",i=Object.keys(t),s=Object.values(t),n=(h,p)=>{s.every(T=>T===!1)?e=`${h} NOT IN ('${i.join("', '")}')`:i.length&&(e=`${h} IN ('${i.join("', '")}')`);let E=i.reduce((T,A)=>{let _=[].concat(t[A]);return typeof _[0]!="string"||_[0]==="*"?T:T.concat(`WHEN '${A}' THEN ${p} IN ('${_.join("', '")}')`)},[]);E.length&&(r=`CASE ${h} ${E.join(" ")} END`);let S=r?`${e} AND ${r}`:e;return S?`WHERE ${S}`:""},u=`
        SELECT
            COLUMNS.table_schema,
            COLUMNS.table_name,
            COLUMNS.column_name,
            COLUMNS.ordinal_position,
            COLUMNS.column_default,
            COLUMNS.is_nullable,
            COLUMNS.data_type,
            COLUMNS.character_maximum_length,
            ${this.params.dialect==="mysql"?`
            COLUMNS.extra,
            `:`
            COLUMNS.is_identity,
            COLUMNS.identity_generation,
            COLUMNS.identity_start,
            COLUMNS.identity_increment,
            COLUMNS.identity_maximum,
            COLUMNS.identity_minimum,
            COLUMNS.identity_cycle,
            `}
            COLUMNS.is_generated,
            COLUMNS.generation_expression
        FROM INFORMATION_SCHEMA.COLUMNS AS COLUMNS
        ${n("COLUMNS.TABLE_SCHEMA","COLUMNS.TABLE_NAME")}
        ORDER BY COLUMNS.ordinal_position
        `,o=h=>this.params.dialect==="mysql"?h:`MAX(${h})`,f=(h,p)=>this.params.dialect==="mysql"?`GROUP_CONCAT(${h}${p?` ORDER BY ${p}`:""} SEPARATOR ',')`:`STRING_AGG(${h}, ','${p?` ORDER BY ${p}`:""})`,l=`
        SELECT
            ${o("TABLE_CONSTRAINTS.constraint_schema")} AS table_schema,
            ${o("TABLE_CONSTRAINTS.table_name")} AS table_name,
            ${f("TABLE_CONSTRAINTS_DETAILS.column_name","TABLE_CONSTRAINTS_DETAILS.ordinal_position")} AS column_name,
            TABLE_CONSTRAINTS.constraint_name AS constraint_name,
            ${o("TABLE_CONSTRAINTS.constraint_type")} AS constraint_type,
            ${o("CHECK_CONSTRAINTS_DETAILS.check_clause")} AS check_clause,
            ${this.params.dialect==="mysql"?`
            ${o("CHECK_CONSTRAINTS_DETAILS.level")} AS check_constraint_level,
            ${f("TABLE_CONSTRAINTS_DETAILS.referenced_column_name")} AS referenced_column_name,
            ${o("TABLE_CONSTRAINTS_DETAILS.referenced_table_name")} AS referenced_table_name,
            ${o("TABLE_CONSTRAINTS_DETAILS.referenced_table_schema")} AS referenced_table_schema,
            `:`
            ${f("RELATION_DETAILS.column_name")} AS referenced_column_name,
            ${o("RELATION_DETAILS.table_name")} AS referenced_table_name,
            ${o("RELATION_DETAILS.table_schema")} AS referenced_table_schema,
            `}
            --${f("RELATION.unique_constraint_name")} AS referenced_constraint_name,
            ${o("RELATION.match_option")} AS match_rule,
            ${o("RELATION.update_rule")} AS update_rule,
            ${o("RELATION.delete_rule")} AS delete_rule
        FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS AS TABLE_CONSTRAINTS
        LEFT JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE AS TABLE_CONSTRAINTS_DETAILS
            ON TABLE_CONSTRAINTS_DETAILS.CONSTRAINT_NAME = TABLE_CONSTRAINTS.CONSTRAINT_NAME
            AND TABLE_CONSTRAINTS_DETAILS.TABLE_NAME = TABLE_CONSTRAINTS.TABLE_NAME
            AND TABLE_CONSTRAINTS_DETAILS.CONSTRAINT_SCHEMA = TABLE_CONSTRAINTS.CONSTRAINT_SCHEMA
            AND TABLE_CONSTRAINTS_DETAILS.CONSTRAINT_CATALOG = TABLE_CONSTRAINTS.CONSTRAINT_CATALOG
        LEFT JOIN INFORMATION_SCHEMA.CHECK_CONSTRAINTS AS CHECK_CONSTRAINTS_DETAILS
            ON CHECK_CONSTRAINTS_DETAILS.CONSTRAINT_NAME = TABLE_CONSTRAINTS.CONSTRAINT_NAME
            AND CHECK_CONSTRAINTS_DETAILS.CONSTRAINT_SCHEMA = TABLE_CONSTRAINTS.CONSTRAINT_SCHEMA
            AND CHECK_CONSTRAINTS_DETAILS.CONSTRAINT_CATALOG = TABLE_CONSTRAINTS.CONSTRAINT_CATALOG
        LEFT JOIN INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS AS RELATION
            ON RELATION.CONSTRAINT_NAME = TABLE_CONSTRAINTS.CONSTRAINT_NAME
            AND RELATION.CONSTRAINT_SCHEMA = TABLE_CONSTRAINTS.CONSTRAINT_SCHEMA
            AND RELATION.CONSTRAINT_CATALOG = TABLE_CONSTRAINTS.CONSTRAINT_CATALOG
        ${this.params.dialect==="mysql"?"":`
        LEFT JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE AS RELATION_DETAILS
            ON RELATION_DETAILS.CONSTRAINT_NAME = RELATION.UNIQUE_CONSTRAINT_NAME
            AND RELATION_DETAILS.CONSTRAINT_SCHEMA = RELATION.UNIQUE_CONSTRAINT_SCHEMA
            AND RELATION_DETAILS.CONSTRAINT_CATALOG = RELATION.UNIQUE_CONSTRAINT_CATALOG
            `}
        ${n("TABLE_CONSTRAINTS.CONSTRAINT_SCHEMA","TABLE_CONSTRAINTS.TABLE_NAME")}
        GROUP BY (TABLE_CONSTRAINTS.constraint_name)
        `;return[u,l]}$formatSchemasResult(t,e,r){let i=u=>u==="character varying"?"varchar":u==="integer"?"int":u,s=(u,o=!1)=>({...o?{}:{name:u.constraint_name},targetTable:[u.referenced_table_schema,u.referenced_table_name],targetColumns:u.referenced_column_name.split(",").map(f=>f.trim()),...u.match_rule!=="NONE"?{matchRule:u.match_rule}:{},updateRule:u.update_rule,deleteRule:u.delete_rule});return[...t.reduce((u,o)=>(u.has(o.table_schema)||u.set(o.table_schema,new Map),u.get(o.table_schema).has(o.table_name)?u.get(o.table_schema).get(o.table_name).columns.push(o):u.get(o.table_schema).set(o.table_name,{columns:[o],constraints:e.filter(f=>f.table_schema===o.table_schema&&f.table_name===o.table_name),indexes:r.filter(f=>f.table_schema===o.table_schema&&f.table_name===o.table_name)}),u),new Map).entries()].map(([u,o])=>({name:u,tables:[...o.entries()].map(([l,h])=>{let p=h.columns.map(R=>R.column_name),E=R=>{let g=(R.check_clause.replace(/(["'])(?:(?=(\\?))\2.)*?\1/g,"").match(/\w+/g)||[]).map(y=>y.toLowerCase());return R.columns=Xt(p,g),R},[S,T,A,_]=h.constraints.reduce(([R,g,y,tt],$)=>$.constraint_type==="PRIMARY KEY"?[R.concat($),g,y,tt]:$.constraint_type==="UNIQUE"?[R,g.concat($),y,tt]:$.constraint_type==="FOREIGN KEY"?[R,g,y.concat($),tt]:$.constraint_type==="CHECK"&&!(this.params.dialect==="postgres"&&/^[\d_]+not_null/.test($.constraint_name))?[R,g,y,tt.concat(E($))]:[R,g,y,tt],[[],[],[],[]]),C={name:l,columns:h.columns.reduce((R,g)=>{let y={},tt=g.extra?.split(",").map($=>$.trim())||[];return R.concat({name:g.column_name,type:g.character_maximum_length?[i(g.data_type),g.character_maximum_length]:i(g.data_type),...S.length===1&&S[0].column_name===g.column_name&&(y.pKeys=S.pop())?{primaryKey:{name:y.pKeys.constraint_name}}:{},...(y.uKeys=T.filter($=>$.column_name===g.column_name)).length===1&&(T=T.filter($=>$!==y.uKeys[0]))?{uniqueKey:{name:y.uKeys[0].constraint_name}}:{},...(y.fKeys=A.filter($=>$.column_name===g.column_name)).length===1&&(A=A.filter($=>$!==y.fKeys[0]))?{references:s(y.fKeys[0])}:{},...(y.cKeys=_.filter($=>$.check_constraint_level!=="Table"&&$.columns.length===1&&$.columns[0]===g.column_name)).length===1&&(_=_.filter($=>$!==y.cKeys[0]))?{check:{name:y.cKeys[0].constraint_name,expr:y.cKeys[0].check_clause}}:{},...g.is_identity==="YES"?{identity:{always:g.identity_generation==="ALWAYS"}}:{},...g.is_generated!=="NEVER"?{expression:{always:g.is_generated==="ALWAYS",expr:g.generation_expression}}:{},...tt.includes("auto_increment")?{autoIncrement:!0}:{},...g.is_nullable==="NO"?{notNull:!0}:{},...g.column_default&&g.column_default!=="NULL"?{default:{expr:g.column_default}}:{},...tt.includes("INVISIBLE")?{flags:["INVISIBLE"]}:{}})},[]),constraints:[],indexes:[]};return C.constraints.push(...[...S,...T,...A].map(R=>({name:R.constraint_name,type:R.constraint_type==="UNIQUE"?"UNIQUE_KEY":R.constraint_type.replace(" ","_"),columns:R.column_name.split(",").map(g=>g.trim()),...R.constraint_type==="FOREIGN KEY"?{references:s(R,!0)}:{}}))),C.constraints.push(..._.map(R=>({name:R.constraint_name,type:R.constraint_type,columns:R.columns,expr:R.check_clause}))),C})}))}};self.webqit||(self.webqit={});self.webqit.ObjectiveSQL={SQL:ye};})();
//# sourceMappingURL=main.js.map
