(()=>{function te(f){return f instanceof String||typeof f=="string"&&f!==null}function xt(f){return arguments.length&&(f===void 0||typeof f>"u")}function ge(f){return typeof f=="function"}function X(f){return ge(f)||f&&{}.toString.call(f)==="[object function]"}function $(f){return Array.isArray(f)}function Br(f){return!te(f)&&!xt(f.length)}function Xr(f){return f===null||f===""}function et(f){return Array.isArray(f)||typeof f=="object"&&f||ge(f)}function Hr(f){return Xr(f)||xt(f)||f===!1||f===0||et(f)&&!Object.keys(f).length}function N(f){return!Array.isArray(f)&&typeof f=="object"&&f}function Lt(f,t=!0){return $(f)?f:!t&&N(f)?[f]:f!==!1&&f!==0&&Hr(f)?[]:Br(f)?Array.prototype.slice.call(f):N(f)?Object.values(f):[f]}function ee(f){return f instanceof Number||typeof f=="number"}function Pt(f){return ee(f)||f!==!0&&f!==!1&&f!==null&&f!==""&&!isNaN(f*1)}var ts=function(f,t=1,e=!0){return!Pt(t)||t<=0||(!$(f)&&N(f)&&e&&(f=Object.values(f)),!$(f))?f:f.reduce((r,s)=>$(s)||N(s)&&e?r.concat(ts($(s)?s:Object.values(s),t-1,e)):r.concat(s),[])},qr=ts;function re(f,t=1){var e=0;f.forEach(s=>{e++});var r=f.slice(f.length-e,t);return arguments.length>1?r:r[0]}function mt(f,t=1){return arguments.length>1?re(f.slice().reverse(),t).reverse():re(f.slice().reverse())}function ir(f,...t){return t.forEach(e=>{f.indexOf(e)<0&&f.push(e)}),f}function es(r,t){t=t||Object.prototype,t=t&&!$(t)?[t]:t;for(var e=[],r=r;r&&(!t||t.indexOf(r)<0)&&r.name!=="default";)e.push(r),r=r?Object.getPrototypeOf(r):null;return e}function rs(f,t){var e=[];return es(f,t).forEach(r=>{ir(e,...Object.getOwnPropertyNames(r))}),e}function se(f,t,e=!1,r=!1,s=!1){var i=0,n=f.shift();if((Pt(n)||n===!0||n===!1)&&(i=n,n=f.shift()),!f.length)throw new Error("_merge() requires two or more array/objects.");return f.forEach((o,a)=>{!et(o)&&!X(o)||(e?rs(o):Object.keys(o)).forEach(u=>{if(t(u,n,o,a)){var c=n[u],h=o[u];if(($(c)&&$(h)||N(c)&&N(h))&&(i===!0||i>0))n[u]=$(c)&&$(h)?[]:{},se([Pt(i)?i-1:i,n[u],c,h],t,e,r,s);else if($(n)&&$(o))r?n[u]=h:n.push(h);else try{s?Object.defineProperty(n,u,Object.getOwnPropertyDescriptor(o,u)):n[u]=o[u]}catch{}}})}),n}function nr(...f){return se(f,(t,e,r)=>!0,!1,!1,!1)}function or(f){return N(f)&&Object.getPrototypeOf(f)===Object.prototype}function qe(f){return f===!0||f===!1}function ar(f,t){var e=void 0;return et(f)&&Object.keys(f).forEach((r,s)=>{e!==!1&&(e=t(Pt(r)?parseFloat(r):r,f[r],s))}),e}function ss(f,t,e=!0,r=!0,s=!1,i=!1){if($(f)&&$(t)){var n=[],o=!0;return f.forEach(a=>{if(o){var u=!1;ar(t,(c,h)=>{(!u||r&&et(a))&&(u=e(a,h),($(u)&&!u.length||N(u)&&!Object.keys(u).length)&&(u=!1),et(u)&&r&&(a=u))}),et(u)?n.push(r?u:a):qe(u)?s&&!u||!s&&u?n.push(a):i&&(o=!1):n.push(u)}}),n}if(N(f)&&N(t)){var n={},o=!0;return Object.keys(f).forEach(c=>{if(o){var h=e(f[c],t[c]);($(h)&&!h.length||N(h)&&!Object.keys(h).length)&&(h=!1),et(h)?n[c]=r?h:f[c]:qe(h)?s&&!h||!s&&h?n[c]=f[c]:i&&(o=!1):n[c]=h}}),n}}var Gr=function(f,t,e=!0,r=1){if($(f)&&$(t)&&f.length!==t.length)return!e;if(N(f)&&N(t)){var s=Object.keys(f),i=Object.keys(t);if(!s.length&&!i.length)return or(f)&&or(t)?e:f===t===e;if(!Gr(s,i))return!e}if(r>0&&($(f)&&$(t)||N(f)&&N(t))){var n=ss(f,t,(o,a)=>Gr(o,a,e,r-1),!1,!1,!0);return $(n)?n.length===f.length&&n.length===t.length:N(n)&&N(f)?Object.keys(n).length===Object.keys(f).length&&Object.keys(n).length===Object.keys(t).length:n}return X(e)?e(f,t):ee(f)&&ee(t)&&isNaN(f)&&isNaN(t)?e:f===t===e},is=Gr;function Wr(f,t=[]){return se([{},f],(e,r,s)=>{if(!X(s[e]))return X(t)?t(e):$(t)&&t.length?t.indexOf(e)>-1:!0},!1,!1,!1)}function pt(f,t,e=null){return $(t)?f.filter(r=>e?t.filter(s=>e(r,s)).length:t.indexOf(r)!==-1):[]}var dt=class f{static lex(t,e,r={}){if(!te(t=t+""))throw new Error("Argument1 must be a string!");var s=u=>({delims:u.delims.slice(),options:Wr(u.options),nesting:u.nesting.slice(),maxDepth:u.maxDepth,comments:u.comments.slice(),tokens:u.tokens.slice(),matches:u.matches.slice(),matchesi:Wr(u.matchesi)});if(f.$cache[t]&&r.cache!==!1)for(var i=0;i<f.$cache[t].length;i++){var n=f.$cache[t][i];if(is(n.delims,e))return s(n)}var o=new f(t,r),a=o.lex(e);return r.cache!==!1&&(f.$cache[t]=f.$cache[t]||[],f.$cache[t].push(a)),s(a)}static split(t,e,r){return f.lex(t,e,r).tokens}static match(t,e,r){return f.lex(t,e,r).matches}constructor(t,e){if(!te(t))throw new Error("Lexer requires the first argument to be a string.");this.$str=t,this.$options=e||{},this.$options.blocks||(this.$options.blocks=f.$blocks),this.$options.quotes||(this.$options.quotes=f.$quotes),this.$options.comments||(this.$options.comments=f.$comments)}lex(t,e){for(var r={delims:Lt(t),options:nr(!0,{},this.$options,e||{}),nesting:[],maxDepth:0,comments:[],tokens:[],matches:[],matchesi:{}},s=0;typeof s=="number";)s=this._evalCharsAt(r,s);if(r.nesting.length)throw new Error("Error parsing the string: "+this.$str+". Unterminated blocks: "+qr(r.nesting).join(", "));return r}_evalCharsAt(t,e){if(!(e>=this.$str.length)){var r=1,s={},i={},n={};if(t.openComment||(i=this._testQuotes(t,e)),t.openQuote||(s=this._testComments(t,e)),t.openComment||s.ending)if(!t.nesting.length&&!n.ending){var o=s.starting||s.ending||this.$str[e];r=o.length,this._push(t,o,"comments",s.starting)}else this._push(t,this.$str[e]);else if(t.openQuote||i.ending)this._push(t,this.$str[e]);else{if(t.options.limit&&t.matches.length===t.options.limit)return this._push(t,this.$str[e]),e+1;n=this._testNesting(t,e);var n=this._testNesting(t,e),a=this._testChars(t.options.stopChars||[],t,e);if(!t.nesting.length&&a!==!1){t.options.stopChar=a,t.options.stopCharForward=this.$str.substr(e);return}if(!t.delims.length)t.nesting.length===2&&n.starting?(t.matches.push(null),this._push(t,n.starting),r=n.starting.length):!t.nesting.length&&n.ending?(this._push(t,n.ending),r=n.ending.length,t.matches.push(null)):this._push(t,this.$str[e]);else if(!t.nesting.length&&!n.ending){this._push(t,"");var u=this._testChars(t.delims,t,e);if(u!==!1&&(t.matches.push(u),t.matchesi[e]=u,r=u.length||1,!t.options.preserveDelims)){var c=e+(u.length||1);return c===this.$str.length&&this._push(t,""),c}this._push(t,u||this.$str[e])}else{var o=n.starting||n.ending||this.$str[e];r=o.length,this._push(t,o)}}return e+r}}_testQuotes(t,e){var r={};return(t.options.quotes||[]).forEach(s=>{this.$str.substr(e,1)===s&&(t.openQuote?s===t.openQuote&&(t.openQuote=!1,r.ending=s):(t.openQuote=s,r.starting=s))}),r}_testComments(t,e){var r={};return(t.options.comments||[]).forEach(s=>{if(t.openComment){if(mt(s)===mt(t.openComment)){var n=mt(s);this.$str.substr(e).startsWith(n)&&(t.openComment=!1,r.ending=n)}}else{var i=re(s);this.$str.substr(e).startsWith(i)&&(t.openComment=s,r.starting=i)}}),r}_testNesting(t,e){var r={};return(t.options.blocks||[]).forEach(s=>{let i=re(s),n;if(i instanceof RegExp?[n]=i.exec(this.$str.substr(e))||[]:this.$str.substr(e).startsWith(i)&&(n=i),n)t.nesting=t.nesting.concat([s]),r.starting=n;else if(t.nesting.length&&mt(s)===mt(mt(t.nesting))){var o=mt(s),a;o instanceof RegExp?[a]=o.exec(this.$str.substr(e))||[]:this.$str.substr(e).startsWith(o)&&(a=o),a&&(t.nesting=t.nesting.slice(0,-1),r.ending=a)}}),t.maxDepth=Math.max(t.maxDepth,t.nesting.length),r}_testChars(t,e,r){for(var s=0;s<t.length;s++){let o={useRegex:e.options.useRegex,ci:e.options.ci,...N(t[s])?t[s]:{test:t[s]}};if(X(o.test)){var i=o.test(this.$str.substr(0,r),this.$str.substr(r),e.tokens.slice());if(i!==!1)return i;continue}if(o.useRegex){let u=o.useRegex!==!0?o.useRegex:"";var n=this.$str.substr(r).match(new RegExp("^"+o.test,u));if(n&&(!o.backtest||this.$str.substr(0,r).match(new RegExp(o.backtest,u))))return n[0];continue}let a=(u,c)=>o.ci?u.toLowerCase()===c.toLowerCase():u===c;if(a(this.$str.substr(r,o.test.length),o.test)&&(!o.backtest||a(this.$str.substr(r-o.backtest.length,r),o.backtest)))return o.test}return!1}_push(t,e,r="tokens",s=!1){var i=t.matches.length;if(xt(t.tokens[i])&&(t.tokens[i]=""),r==="comments"){t.tokens[i].comments||(t.tokens[i]=new String(t.tokens[i]),t.tokens[i].comments=[]);var n=t.tokens[i].comments.length-(!t.tokens[i].comments.length||s?0:1);t.tokens[i].comments[n]=(t.tokens[i].comments[n]||"")+e}else{var o=t.tokens[i].comments;t.tokens[i]=t.tokens[i]+e}}split(t,e,r){return this.lex(e,r).tokens}match(t,e,r){return this.lex(e,r).matches}regParse(t,e){return this.lex(t,nr({useRegex:!0},e||{}))}regSplit(t,e){return this.regParse(t,e).tokens}regMatch(t,e){return this.regParse(t,e).matches}};dt.$blocks=[["(",")"],["[","]"],["{","}"]];dt.$quotes=['"',"'","`"];dt.$comments=[["/*","*/"],["//",`
`]];dt.$cache=Object.create(null);var E=class extends dt{static $blocks=[...dt.$blocks,[new RegExp("^CASE ","i"),new RegExp("^ END","i")]]};function fr(f,t,e=!1){if(t=="")return f;var r=e?f.lastIndexOf(t):f.indexOf(t);return r===-1?"":f.substr(r+t.length)}function Qr(f,t,e=!1){if(t=="")return f;var r=e?f.lastIndexOf(t):f.indexOf(t);return r===-1?f:f.substr(0,r)}function Ee(f,t,e=null){return $(t)?f.filter(r=>e?t.filter(s=>e(r,s)).length:t.indexOf(r)===-1):[]}function zr(f,t){return Qr(f,t,!0)}function Ge(f,t){return f===void 0?"":f.split(/(?=[A-Z])/).join(t||" ")}function We(f,t){return typeof f!="string"?f:f.replace(/\w\S*/g,function(e){return e.charAt(0).toUpperCase()+(typeof t!==void 0&&t?e.substr(1).toLowerCase():e.substr(1))})}function ye(f,t){return f=We(f.replace(/-/g," ")).replace(/ /g,""),t?f:f[0].toLowerCase()+f.substr(1)}function V(f,t,e){return zr(fr(f,t),e)}function $t(f,t,e){return f.startsWith(t)&&f.endsWith(e)}var T=class f{#t;#e=[];#r;constructor(t){this.#t=t,this.#r=new Map}static get NODE_NAME(){return Ge(this.name,"_").toUpperCase()}get NODE_NAME(){return this.constructor.NODE_NAME}get baseClient(){return this.#t?.baseClient||this.#t}get params(){return this.#t?.params||{}}get additionalDetails(){return this.#r}get rootNode(){return this.#t?.contextNode||this}get statementNode(){return this.#t?.statementNode}get contextNode(){return this.#t}capture(t){if(arguments.length!==1)throw new Error("capture() expects exactly 1 parameter.");return this.#t?.$capture(t,this)}bubble(t){if(arguments.length!==1)throw new Error("bubble() expects exactly 1 parameter.");return this.#t?.$bubble?.(t,this)}$capture(t,e){if(arguments.length!==2)throw new Error("$capture() expects exactly 2 parameters.");return this.#t?.$capture?.(t,e)}$bubble(t,e){if(arguments.length!==2)throw new Error("$bubble() expects exactly 2 parameters.");this.#t?.$bubble?.(t,e),e===this&&t==="DISCONNECTED"&&(this.#t=null)}$castInputs(t,e,r,s,i=null,n=null){let o=[].concat(e||[]);if(!o.length)throw new Error("At least one node type must be defined.");let a={result:r},u=m=>{let l=o.reduce((_,S)=>_||m instanceof S&&m,null);if(l)return l;let p=["dependencies","dependents"].includes(s)?this.baseClient:this;return o.reduce((_,S)=>_||S.fromJSON(p,m),null)},c=({returnPairs:m=!1,autoThrow:l=!1})=>{let p=(_,...S)=>o.reduce((y,C)=>y||(()=>{if(C.expose){let g=Object.keys(C.expose).find(L=>L.split("|").includes(_)),A=g&&C.expose[g](this,...S);return A&&[A,A]}if(typeof C.prototype[_]=="function"){let g=new C(this);return[g,g[_](...S)]}})(),null);return new Proxy({},{get:(_,S)=>(...y)=>{let C=p(S,...y);if(C)return a.result=h(a.result,C[0]),m?C:C[1];if(l)throw new Error(`[${this.NODE_NAME}::${s}]: The ${S}(${y}) method is undefined in any of ${o.map(g=>g.name).join(", ")}.`)}})},h=(m,l)=>{if(l?.bubble("CONNECTED"),l&&typeof this.params.nodeCallback=="function"&&this.params.nodeCallback(l),Array.isArray(m)&&l){let p=n?.(l);return p?(p.bubble("DISCONNECTED"),m.map(_=>_===p?l:_)):m.concat(l)}return m&&l!==m&&m.bubble("DISCONNECTED"),l};if(t.length===1&&t[0]===void 0){if(Array.isArray(a.result))throw new Error(`[${this.NODE_NAME}::${s}]: Cannot unset array property.`);return h(a.result,void 0)}let d=new Set;if(t.length>1&&!Array.isArray(a.result))for(;t.length;)d.add(t.shift());for(let m=0;m<t.length;m++){let l=t[m];if(typeof l=="function"){i?d.add(l):l(c({returnPairs:!1,autoThrow:!0}));continue}if(a.instance=u(l)){a.result=h(a.result,a.instance);continue}let p={};if(N(l)&&!l.nodeName&&(p.keys=Object.keys(l)).length){let S=c({returnPairs:!0,autoThrow:!i}),y=p.keys.shift(),C,[g,A]=S[y](...[].concat(l[y]))||[];if(g){for(;C=p.keys.shift();){let L=A?.[C];if(typeof L!="function")throw new Error(`[${this.NODE_NAME}::${s}][${m+1}/${t.length}]: The implied chaining: ${A.NODE_NAME}.${y}().${C}() is invalid.`);A=L.call(A,...[].concat(l[C])),y=C}continue}}if(i){d.add(l);continue}let _;if(N(l))try{_=JSON.stringify(l)}catch{_=l.constructor.name}else _=l+"";throw new Error(`[${this.NODE_NAME}::${s}][${m+1}/${t.length}]: Arguments must be of type ${o.map(S=>S.name).join(", ")} or a JSON equivalent. Recieved: ${_}`)}if(d.size){let m;return Array.isArray(a.result)?(m=new o[0](this),a.result=h(a.result,m)):(a.result=a.result||new o[0](this),m=a.result),m[i](...d),a.result}return a.result}static getQuoteChars(t,e=!1){return(e&&t?.params?.inputDialect||t?.params?.dialect)==="mysql"&&!t.params.ansiQuotes?["'",'"']:["'"]}static getEscChar(t,e=!1){return(e&&t?.params?.inputDialect||t?.params?.dialect)==="mysql"&&!t.params.ansiQuotes?"`":'"'}get quoteChars(){return this.constructor.getQuoteChars(this)}get escChar(){return this.constructor.getEscChar(this)}static esc(t,e,r=!1){return r||!/^(\*|[\w]+)$/.test(e)?`${t}${(e||"").replace(new RegExp(t,"g"),t.repeat(2))}${t}`:e}static unesc(t,e,r=!1){return(!r||new RegExp(`^${t}.*${t}$`).test(e)&&(e=e.slice(1,-1)))&&e.replace(new RegExp(t.repeat(2),"g"),t)}static parseIdent(t,e,r=!1,s=!0){let i=this.getEscChar(t,s),n=E.split(e,["."]),o=n.map(a=>new RegExp(`^(?:(\\*|[\\w]+)|(${i})((?:\\2\\2|[^\\2])+)\\2)$`).exec(a.trim())).filter(a=>a);return o.length<n.length?[]:o.map(a=>a?.[1]||this.unesc(i,a?.[3],r))}stringifyIdent(t,e=!1){let r=s=>this.constructor.esc(this.escChar,s,e);return Array.isArray(t)?t.filter(s=>s).map(r).join("."):r(t)}static parseString(t,e,r=!1,s=!0){let i=this.getQuoteChars(t,s),n={};for(;(n.quoteChar=i.pop())&&(n.resultString=this.unesc(n.quoteChar,e,r))!==!1;)return[n.resultString,n.quoteChar];return[]}stringifyString(t,e=!1){return this.constructor.esc(this.quoteChars[0],t,e)}withDetail(t,e){return this.#r.set(t,e),this}hasDetail(t){return this.#r.has(t)}getDetail(t){return this.#r.get(t)}withFlag(...t){return t=new Set(t.filter(e=>e)),this.#e=this.#e.reduce((e,r)=>{let s=r.split(":");for(let i of t){let n=i.split(":");n[0]===s[0]&&(r=[...new Set([...s,...n])].join(":"),t.delete(i))}return e.concat(r)},[]).concat(...t),this}hasFlag(t){return!!this.getFlag(t)}getFlag(t){if(!arguments.length)return this.#e;let e=t.toUpperCase().split(":");return this.#e.find(r=>{let s=r.split(":");return e[0]===s[0]&&e.every(i=>s.includes(i))})}$eq(t,e,r=null){if(Array.isArray(t)&&Array.isArray(e))return t.length===e.length&&(e=e.slice(0).sort())&&t.slice(0).sort().every((s,i)=>this.$eq(s,e[i],r));if(t instanceof f&&(t=t.jsonfy()),e instanceof f&&(e=e.jsonfy()),N(t)&&N(e)){let s={};return(s.keys_a=Object.keys(t)).length===(s.keys_b=Object.keys(e)).length&&s.keys_a.reduce((i,n)=>i&&this.$eq(t[n],e[n],r),!0)}return typeof t=="string"&&typeof e=="string"&&r==="ci"?t.toLowerCase()===e.toLowerCase():t===e}identifiesAs(t){if(typeof t>"u")return!1;if(typeof t?.toJSON=="function")return this.$eq(this.jsonfy(),t.jsonfy(),"ci")}contains(t){return t?this===t.contextNode||this.contains(t.contextNode):!1}static fromJSON(t,e,r=null){if(e instanceof f)throw new Error(`Illegal instance passed as JSON: ${e.NODE_NAME}`);if(N(e)&&"nodeName"in e&&e.nodeName!==this.NODE_NAME)return;let s=new this(t).withFlag(...e?.flags||[]);return typeof r=="function"&&r(s),s}jsonfy(t={},e={}){return{...t.nodeNames!==!1?{nodeName:this.NODE_NAME}:{},...typeof e=="function"?e():e,...this.#e.length?{flags:this.#e.slice(0)}:{}}}static parse(t,e,r=null){}toString(){return this.stringify()}toJSON(t=null,e={}){return this.jsonfy(e)}clone(t={}){let e=this.jsonfy(t);return[this.constructor].concat(this.constructor.DESUGARS_TO||[]).reduce((s,i)=>s||i.fromJSON(this.#t,e),void 0)}deSugar(t={}){return t={...t,deSugar:!0},this.clone(t)}};var w=class extends T{#t;name(t){if(!arguments.length)return this.#t;if(typeof t!="string")throw new TypeError(`Invalid argument as identifier name: ${t}.`);return this.#t=t,this}identifiesAs(t){return typeof t=="string"?this.$eq(this.#t,t,"ci"):super.identifiesAs(t)}static fromJSON(t,e,r=null){if(typeof e=="string")e={name:e};else if(typeof e?.name!="string")return;return super.fromJSON(t,e,s=>{s.name(e.name),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,{name:this.#t,...e})}static parse(t,e){if(/^(TRUE|FALSE|NULL)$/i.test(e))return;let[r]=this.parseIdent(t,e).reverse();if(r)return new this(t).name(r)}stringify(){return this.stringifyIdent(this.#t)}};var I=class extends T{static get EXPECTED_TYPES(){return[]}static get TAGS(){return[]}#t=[];[Symbol.iterator](){return this.#t[Symbol.iterator]()}get length(){return this.#t.length}entries(){return this.#t.slice()}add(...t){return this.#t=this.$castInputs(t,this.constructor.EXPECTED_TYPES,this.#t,"add",this.constructor.ARGS_DELEGATION),this}has(t){return!!this.get(t)}get(t){return typeof t=="number"?this.#t[t]:this.#t.find(e=>e.identifiesAs(t))}static fromJSON(t,e,r=null){if(Array.isArray(e?.entries))return super.fromJSON(t,e,s=>{for(let i of e.entries)s.add(i);r?.(s)})}jsonfy(t={},e={},r=null){return super.jsonfy(t,{entries:this.#t.reduce((s,i,n)=>{if(r){let o=r(i,n);if(!o)return s;if(![i,!0].includes(o)){if(o instanceof T)throw new Error("A JSON object not a node instance expected from reducer");return s.concat(o)}}return s.concat(i.jsonfy(t))},[]),...e})}static parse(t,e,r){if(this.CLAUSE){let[o,a]=e.match(new RegExp(`^${this.CLAUSE}[\\W]([\\s\\S]*)$`,"i"))||[];if(!o)return;e=a.trim()}if(this.TAGS.length){if(!$t(e,...this.TAGS)||E.split(e,[" "]).length>1)return;e=V(e,...this.TAGS)}let s=E.split(e,[","]);if(this.MIN_ENTRIES&&s.length<this.MIN_ENTRIES)return;let i=new this(t),n=s.map(o=>r(i,o.trim(),this.EXPECTED_TYPES)).filter(o=>o);for(let o of n)i.add(o);return i}stringify(){let t=this.#t.join(", ");if(this.constructor.TAGS.length&&(t=this.constructor.TAGS.join(t)),this.constructor.CLAUSE){if(!this.#t.length&&!this.constructor.TAGS.length)return"";t=`
${this.constructor.CLAUSE} ${t}`}return t}};var ur=class extends Error{};var cr=class extends Error{};var ot=class f extends w{static get PREFIX_TYPE(){return[]}#t;#e;#r;get autoPrefixed(){return this.#e}name(t){return arguments.length&&t!==this.name()&&(this.#r=null),super.name(...arguments)}prefix(t){return t===!0&&!this.#t&&(this.prefix("").schema(),this.#e=!0),!arguments.length||typeof t=="boolean"?this.#t:(this.#t=this.$castInputs([t],this.constructor.PREFIX_TYPE,this.#t,"prefix_spec"),this)}identifiesAs(t){return t instanceof f?this.$eq(this.name(),t.name(),"ci")&&(!t.prefix()||!!this.prefix()?.identifiesAs(t.prefix())):super.identifiesAs(t)}schema(t=null){if(this.#r)return t?t(this.#r)&&[this.#r]||[]:this.#r;let e=u=>{if(u)return this.#r=u,this.#r.name()&&!this.name()&&this.name(this.#r.name()),this.#r},r=this.name(),s=this.constructor.KIND,i=s.toLowerCase(),n=[],o=[];if(!(/(TABLE|DATABASE)/.test(s)&&!this.global)||!(o=[].concat(this.contextNode?.capture(`${s}_SCHEMA`)?.clone()||[])).length){if(!t&&!r)return;let u=c=>c?.[i](r);n=/DATABASE$/.test(s)?[this.capture("ROOT_SCHEMA")]:this.prefix(!0).schema(c=>r?u(c):!0),o=n.reduce((c,h)=>c.concat(r?u(h)||[]:h[`${i}s`]()),[])}if(t){let u=o.filter(t);return u.length===1&&e(u[0]),u}if(o.length>1)throw new ur(`[${this.contextNode?.clone({fullyQualified:!0})}]: ${We(i)} ${this.stringifyIdent(r)} is ambiguous. (Is it ${n.map(u=>this.stringifyIdent([u.name(),r])).join(" or ")}?)`);if(!e(o[0]))throw new cr(`[${this.clone({fullyQualified:!0})}]: Unknown ${i}: ${this.stringifyIdent(r)}`);return this.#r}static fromJSON(t,e,r=null){if(typeof e=="string")e={name:e};else if(Array.isArray(e)&&e.some(s=>typeof s=="string")&&(e=e.slice()))e={name:e.pop(),prefix:e.pop()};else if(typeof e?.name!="string")return;return super.fromJSON(t,e,s=>{e.prefix&&s.prefix(e.prefix),r?.(s)})}jsonfy(t={},e={}){let r=((!this.#e||t.deSugar||t.fullyQualified)&&this.#t)?.jsonfy?.(t);return super.jsonfy(t,{...r?.name?{prefix:r}:{},...e})}static parse(t,e,r){if(/^(TRUE|FALSE|NULL)$/i.test(e))return;let[s,...i]=this.parseIdent(t,e).reverse();if(!s)return;let n=new this(t).name(s);return i.length&&n.prefix(i),n}stringify(){return[].concat(!this.#e&&this.#t?.stringify()||[],this.stringifyIdent(this.name())).join(".")}};var vt=class extends T{static get EXPECTED_TYPES(){return[]}#t;#e;#r;expr(t){return arguments.length?(this.#t=this.$castInputs([t],this.constructor.EXPECTED_TYPES,this.#t,"expr"),this):this.#t}alias(t,e=!0){return!arguments.length||typeof t=="boolean"?this.#e||!t?this.#e:typeof this.#t.prettyName=="function"&&this.#t.prettyName()?this.#t.prettyName():typeof this.#t.name=="function"&&this.#t.name()!=="*"?this.#t.name():void 0:(this.#r=e,this.#e=t,this)}as(...t){return this.alias(...t)}identifiesAs(t){return this.#t?.identifiesAs(t)}schema(){let t=this.expr()?.schema?.()?.clone({fullyQualified:!0});return t&&this.#e?t.name(this.#e):t}static fromJSON(t,e,r=null){return super.fromJSON(t,e,s=>{if(e?.expr?(s.expr(e.expr),(e.alias||e.as)&&s.as(e.alias||e.as,e.claused)):e&&s.expr(e),![ot].some(i=>s.expr()instanceof i)&&!s.expr().isPath&&!s.alias()&&this.requireAliasForNoneIdents)throw new Error(`[${this}]: An alias is required for a non-path properties.`);r?.(s)})}jsonfy(t={},e={}){let r=this.#e||t.deSugar&&this.#t.prettyName?.();return super.jsonfy(t,{expr:this.#t?.jsonfy(t),...r?{alias:r,claused:this.#r}:{},...e})}static parse(t,e,r){let s=new this(t),i=!0,[n,o]=E.split(e,["AS\\s+"],{useRegex:"i"}).map(a=>a.trim());if(!o){let a=E.split(e,["\\s+"],{useRegex:"i"});a.length>1&&/[\w"'`\]\)\}]$/.test(a[a.length-2])&&(o=a.pop().trim(),n=a.join(" ")),i=!1}if(s.expr(r(s,n,this.EXPECTED_TYPES)),o)[o]=this.parseIdent(s,o.trim()),s.as(o,i);else if(![ot].some(a=>s.expr()instanceof a)&&!s.expr().isPath&&this.requireAliasForNoneIdents)throw new Error(`[${this}]: An alias is required for a non-path properties.`);return s}stringify(){return[this.#t,this.#r?"AS":"",this.#e?this.stringifyIdent(this.#e):null].filter(t=>t).join(" ")}};var Se=class extends T{#t;#e=[];status(){return this.#t}CDLIgnoreList(){return this.#e.slice()}alterWith(t,e={}){return this.constructor.fromJSON(this,this.renderCDL(t,e))}diffWith(t,e={}){return this.constructor.fromJSON(this,this.generateDiff(t,e))}dirtyCheck(t=!1){return["new","obsolete"].includes(this.#t)?["status"]:[]}generateDiff(t,e){return this.diffMergeJsons({status:this.status()},{status:t.status()},e)}dirtyCheckProperties(t){return t.filter(e=>!this.$eq(this[e](),this[`$${e}`](),"ci"))}diffMergeJsons(t,e,r={}){for(let s of Object.keys(e))if(!["nodeName","flags","CDLIgnoreList"].includes(s)&&!(!this.$isDirty(e[s])||this.$eq(t[s],e[s],"ci")))if(r.diff==="reverse"){if(s==="status"||r.honourCDLIgnoreList&&t.CDLIgnoreList?.includes(s))continue;t={...t,[s]:e[s],[`$${s}`]:t[s]}}else s==="status"?t={...t,status:e[s]}:t={...t,[r.diff===!1?s:`$${s}`]:e[s]};return t}diffMergeTrees(t,e,r,s){Array.isArray(t)&&(t=new Map(t.map(a=>[a.name().toLowerCase(),a])),e=new Map(e.map(a=>[a.name().toLowerCase(),a])));let[i,n,o]=[new Set,new Set,new Set];for(let a of new Set([...t.keys(),...e.keys()]))!e.has(a)&&t.has(a)?i.add(t.get(a)):e.has(a)&&!t.has(a)?o.add(e.get(a)):n.add(t.get(a));return[...t.entries()].reduce((a,[u,c])=>{if(i.has(c))return a.concat({...c.jsonfy(s),status:"obsolete"});if(n.has(c)){let h=r(c,e.get(u));return Object.keys(h).length?a.concat(h):a}return a},[]).concat([...o].map(a=>({...a.jsonfy(s),status:"new"})))}reverseDiff(t={}){return this.constructor.fromJSON(this.contextNode,this.jsonfy({...t,diff:"reverse"}))}#r=!1;$diffTagHydrate(...t){if(!arguments.length)return this.#r;if(this.$isDirty(t[0])){let e=this.#r;this.#r=!0,t[1](t[0]),this.#r=e}return this}$isDirty(t){return Array.isArray(t)?!!t.length:typeof t<"u"}static fromJSON(t,e,r=null){return super.fromJSON(t,e,s=>{s.#t=e.status,Array.isArray(e.CDLIgnoreList)&&s.#e.push(...e.CDLIgnoreList),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,{...e,...this.#t&&t.diff!==!1?{status:t.diff==="reverse"&&["new","obsolete"].includes(this.#t)?this.#t==="new"?"obsolete":"new":this.#t}:{},...this.#e.length&&t.diff!==!1?{CDLIgnoreList:this.#e.slice()}:{}})}};var at=class extends Se{#t;#e;name(t){return arguments.length?(this.$diffTagHydrate()||this.$nameLock()&&this.#t?this.#e=t:this.#t=t,this):this.#t}$name(){return this.#e||this.#t}identifiesAs(t){return typeof t=="string"?this.$eq(this.#t,t,"ci"):super.identifiesAs(t)}dirtyCheck(t=!1){return super.dirtyCheck(t).concat(this.dirtyCheckProperties(["name"]))}generateDiff(t,e){return this.diffMergeJsons({...super.generateDiff(t,e),name:this.$name()},{name:t.$name()},e)}#r=!1;$nameLock(t){if(!arguments.length)return this.#r||!!this.contextNode?.$nameLock?.();if(typeof t=="function"){let e=this.#r;this.#r=!0,t(),this.#r=e}else this.#r=!!t;return this}static fromJSON(t,e,r=null){if(!(e?.name&&typeof e.name!="string")&&!(e?.$name&&typeof e.$name!="string"))return super.fromJSON(t,e,s=>{s.name(e.name),s.$diffTagHydrate(e.$name,i=>s.name(i)),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,this.diffMergeJsons({name:this.#t,...e},{name:this.#e},t))}};var Ne=class f extends at{#t;#e;prefix(t){if(!arguments.length||typeof t=="boolean"){let e=this.#t;if(!e&&t===!0){let r=this.constructor.PREFIX_TYPE[0],s=[];this.contextNode instanceof f&&s.push(this.contextNode.prefix(!0).jsonfy()),this.contextNode instanceof at?(s.push(this.contextNode.name()),e=r?.fromJSON(this,s)):e=r?.fromJSON(this,"")}return e}return this.$diffTagHydrate()?this.#e=this.$castInputs([t],this.constructor.PREFIX_TYPE,this.#e,"$prefix"):this.#t=this.$castInputs([t],this.constructor.PREFIX_TYPE,this.#t,"prefix"),this}$prefix(...t){return this.#e||this.prefix(...t)}identifiesAs(t){return super.identifiesAs(t)&&(!t?.prefix?.()||!!this.prefix()?.identifiesAs(t.prefix()))}dirtyCheck(t=!1){return super.dirtyCheck(t).concat(this.dirtyCheckProperties(["prefix"]))}generateDiff(t,e){return this.diffMergeJsons({...super.generateDiff(t,e),prefix:this.$prefix(!!t.$prefix())?.jsonfy()},{prefix:t.$prefix()?.jsonfy()},e)}static fromJSON(t,e,r=null){return super.fromJSON(t,e,s=>{e.prefix&&s.prefix(e.prefix),s.$diffTagHydrate(e.$prefix,i=>s.prefix(i)),r?.(s)})}jsonfy(t={},e={}){let r=this.#t||t.fullyQualified?(this.#t||this.prefix(!0)).jsonfy(t):{};return super.jsonfy(t,this.diffMergeJsons({...r.name?{prefix:r}:{},...e},{prefix:this.#e?.jsonfy(t)},t))}};var Ot=class extends ot{static get KIND(){return"DATABASE"}prefix(t){}};var U=class extends Ot{static get NODE_NAME(){return Ot.NODE_NAME}get global(){return!0}};var ie=class extends ot{static get PREFIX_TYPE(){return Ot}static get KIND(){return"TABLE"}};var O=class extends ie{static get NODE_NAME(){return ie.NODE_NAME}static get PREFIX_TYPE(){return U}get global(){return!0}};var H=class extends T{#t=[];[Symbol.iterator](){return this.#t[Symbol.iterator]()}get length(){return this.#t.length}actions(){return this.#t}add(...t){if(typeof t[0]=="string"){let e=t.shift(),r=typeof t[t.length-1]=="function"?t.pop():null,s=this.constructor.EXPECTED_TYPES.find(n=>n.CLAUSE===e);if(!s)throw new Error(`Unsupported clause: ${e}`);let i=new s(this,...t);if(this.#t=this.$castInputs([i],this.constructor.EXPECTED_TYPES,this.#t,"actions"),r)r(i);else return i}else this.#t=this.$castInputs(t,this.constructor.EXPECTED_TYPES,this.#t,"actions");return this}static fromJSON(t,e,r=null){if(Array.isArray(e?.actions))return super.fromJSON(t,e,s=>{s.add(...e.actions),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,{actions:this.#t.map(r=>r.jsonfy(t)),...e})}static parse(t,e,r){let s=new this(t);return s.add(...E.split(e,[","]).map(i=>r(s,i.trim(),this.EXPECTED_TYPES)))}stringify(){return this.actions().join(`,
`)}};var D=class extends T{static get CLAUSE(){return this.NODE_NAME}#t;#e;get CLAUSE(){return this.constructor.CLAUSE}get KIND(){return this.#t}get $KIND(){return this.#e||this.KIND}constructor(t,e=null,r=null){super(t),this.#t=e,this.#e=r}static fromJSON(t,e,r=null){if(!(e.clause&&e.clause!==this.CLAUSE))return super.fromJSON(t,e,s=>{s.#t=e.kind,s.#e=e.$kind,r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,{clause:this.CLAUSE,kind:this.#t,...this.#e?{$kind:this.#e}:{},...e})}};var lr=class extends D{#t;value(t){return arguments.length?(this.#t=t,this):this.#t}static fromJSON(t,e,r=null){if(e?.value)return super.fromJSON(t,e,s=>{s.value(e.value),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,{value:this.#t,...e})}static parse(t,e){let[r]=e.match(/DEFERRABLE|NOT\s+DEFERRABLE|INITIALLY\s+DEFERRED|INITIALLY\s+IMMEDIATE|VISIBLE|INVISIBLE/i)||[];if(r)return new this(t).value(r.replace(/\s+/,"_").toUpperCase())}stringify(){return this.#t?.replace(/_/," ")||""}};var _e=class extends H{static get EXPECTED_TYPES(){return[lr]}};var Te=class extends at{static get TYPE(){return this.NODE_NAME.replace(/TABLE_|COLUMN_|_CONSTRAINT|_CLAUSE/ig,"")}get TYPE(){return this.constructor.TYPE}renderCDL(t,e){return this.jsonfy(e)}generateCDL(){return _e.fromJSON(this,{actions:[]})}generateDiff(t,e){return{type:this.TYPE,...super.generateDiff(t,e)}}static fromJSON(t,e,r=null){if(e?.type===this.TYPE)return super.fromJSON(t,e,r)}jsonfy(t={},e={}){return super.jsonfy(t,{type:this.TYPE,...e})}static parse(t,e){let{name:r,expr:s}=this.parseName(t,e,!0);if(!(!s||!new RegExp(`^${this.TYPE==="AUTO_INCREMENT"?this.TYPE:this.TYPE.replace("_","\\s+")}$`,"i").test(s)))return new this(t).name(r)}stringify(){return this.TYPE==="AUTO_INCREMENT"?this.TYPE:`${this.stringifyName()}${this.TYPE.replace("_"," ")}`}static parseName(t,e,r=!1){let s=this.getEscChar(t,r),i=`(?:CONSTRAINT(?:\\s+(\\w+)|\\s+(${s})((?:\\2\\2|[^\\2])+)\\2)\\s+)?`,[,n,,o="",a=""]=e.match(new RegExp(`^${i}([\\s\\S]+)$`,"i"))||[];return{name:n||this.unesc(s,o),expr:a.trim()}}stringifyName(){return this.$name()?`CONSTRAINT ${this.stringifyIdent(this.$name())} `:""}};var k=class extends Te{get constraintLevel(){return 2}get isColumnLevel(){return this.constructor.checkIsColumn(this.contextNode)}static checkIsColumn(t){return t?.constructor?.NODE_NAME==="COLUMN_SCHEMA"}static fromJSON(t,e,r=null){if(e?.type===this.TYPE)return!("name"in e)&&t?.params?.dialect!=="mysql"&&(e={name:`auto_name_${(0|Math.random()*9e6).toString(36)}`,...e}),super.fromJSON(t,e,r)}jsonfy(t={},e={}){let r=super.jsonfy(t,e);return!("name"in r)&&this.params.dialect!=="mysql"&&(r={name:void 0,...r}),r}};var Ut=f=>class extends f{#t=[];#e=[];columns(t){if(this.isColumnLevel){if(arguments.length)throw new Error('The "columns" attributes for column-level constraints is implicit.');return[this.contextNode.name()]}if(!arguments.length)return this.#t;if(!Array.isArray(t)||!t.length)throw new Error("Columns list must be a non-empty array");return this.$diffTagHydrate()?this.#e=t:this.#t=t,this}$columns(){return this.#e.length?this.#e:this.columns()}dirtyCheck(t=!1){return super.dirtyCheck(t).concat(this.dirtyCheckProperties(["columns"]))}generateDiff(t,e){return this.isColumnLevel?super.generateDiff(t,e):this.diffMergeJsons({...super.generateDiff(t,e),columns:this.$columns()},{columns:t.$columns()},e)}resolveColumnReferences(t,e,r=!1){return t.reduce((s,i)=>{let n=e.filter(o=>["DROP","RENAME"].includes(o.CLAUSE)&&o.KIND==="COLUMN"&&o.reference().identifiesAs(i)).reduce((o,a)=>a.CLAUSE==="DROP"?[a].concat(o):o.concat(a),[]);if(!n.length)return s.concat(i);if(n[0].CLAUSE==="DROP"){if(!n[0].hasFlag("CASCADE")&&r)throw new Error(`Cannot drop column ${n[0].reference()} because other objects depend on it.`);return s}if(n[0].CLAUSE==="RENAME")return s.concat(n[0].argument().name())},[])}static fromJSON(t,e,r=null){if(!(!this.checkIsColumn(t)&&!Array.isArray(e.columns)))return super.fromJSON(t,e,s=>{!this.checkIsColumn(t)&&Array.isArray(e.columns)&&s.columns(e.columns),this.checkIsColumn(t)||s.$diffTagHydrate(e.$columns,i=>s.columns(i)),r?.(s)})}jsonfy(t={},e={}){if(this.isColumnLevel&&!t.withColumns)return super.jsonfy(t,e);let r=super.jsonfy(t,this.diffMergeJsons({columns:this.columns().slice(),...e},{columns:this.#e.slice()},t));if(!t.tableCDL)return r;let s=this.resolveColumnReferences(r.columns,t.tableCDL.actions());return s.length!==r.columns.length?t.diff?{...r,status:"obsolete"}:void 0:(pt(s,r.columns).length!==r.columns.length&&(r=this.diffMergeJsons(r,{columns:s},t),t.diff!==!1&&(r.CDLIgnoreList||(r.CDLIgnoreList=[]),r.CDLIgnoreList.push("columns"))),r)}static parseColumns(t,e,r=!0){return E.split(V(e,"(",")"),[","]).map(s=>this.parseIdent(t,s.trim(),!1,r)[0])}stringifyColumns(){return` (${this.$columns().map(t=>this.stringifyIdent(t)).join(", ")})`}};var Mt=class extends Ut(k){static parse(t,e,r){let{name:s,expr:i}=this.parseName(t,e,!0);if(!i||!/^PRIMARY\s+KEY/i.test(i))return;let n=new this(t).name(s);if(this.checkIsColumn(t))return n;let[,o]=E.split(e,[]);return n.columns(this.parseColumns(n,o))}stringify(){return`${this.stringifyName()}PRIMARY KEY${this.isColumnLevel?"":this.stringifyColumns()}`}};var q=f=>class extends f{#t;get REF_TYPES(){return this.constructor.REF_TYPES[this.KIND]}reference(t){return arguments.length?(this.#t=this.$castInputs([t],this.REF_TYPES,this.#t,"reference"),this):this.#t}static fromJSON(t,e,r=null){return super.fromJSON(t,e,s=>{e.reference&&s.reference(e.reference),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,{reference:this.#t?.jsonfy(t),...e})}};var v=f=>class extends f{#t;get EXPECTED_TYPES(){return this.constructor.EXPECTED_TYPES[this.KIND]}argument(t){return arguments.length?(this.#t=this.$castInputs([t],this.EXPECTED_TYPES,this.#t,"argument"),this):this.#t}static fromJSON(t,e,r=null){if(e?.argument)return super.fromJSON(t,e,s=>{s.argument(e.argument),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,{argument:this.#t?.jsonfy(t),...e})}};var Ae=class extends q(v(D)){static parse(t,e,r){let[,s,i,n]=e.match(new RegExp(`^ALTER\\s+(${Object.keys(this.EXPECTED_TYPES).join("|")})\\s+([\\s\\S]+?)\\s+([\\s\\S]+)$`,"i"))||[];if(!i)return;let o=new this(t,s.toUpperCase());return o.reference(r(o,i,this.REF_TYPES[o.KIND])),o.argument(r(o,n,this.EXPECTED_TYPES[o.KIND])),o}};var hr=f=>class extends f{#t=new Set;get statementNode(){return this}get querySugars(){return this.#t}get hasSugars(){return this.isSugar||!!this.#t.size}$bubble(t,e){return["CONNECTED","DISCONNECTED"].includes(t)&&e.isSugar&&(t==="DISCONNECTED"?this.#t.delete(e):this.#t.add(e)),super.$bubble(t,e)}};var rt=f=>class extends f{get isSugar(){return!0}};var j=f=>class extends hr(rt(f)){static get CLAUSE(){return this.NODE_NAME.replace(/_DATABASE|_TABLE/gi,"")}#t;get statementType(){return"DDL"}returning(t){if(!arguments.length)return this.#t;if(!/^SCHEMA|SAVEPOINT$/i.test(t))throw new Error("Unsupported value for a RETURNING clause.");return this.#t=t.toUpperCase(),this}static fromJSON(t,e,r=null){let[s]=this.NODE_NAME.match(/DATABASE|TABLE/);return super.fromJSON(t,{...e,kind:e.kind||(s==="DATABASE"?"SCHEMA":s)},i=>{e.returningClause&&i.returning(e.returningClause),r?.(i)})}jsonfy(t,e){return super.jsonfy(t,()=>({...this.#t&&!t.deSugar?{returningClause:this.#t}:{},...e()}))}static parse(t,e,r){let s;/^CREATE|ALTER|DROP|RENAME/.test(e)&&([e,s]=E.split(e,["RETURNING"],{useRegex:"i"}).map(n=>n.trim()));let i=super.parse(t,e,r);return s&&i?.returning(s),i}stringify(){let t=super.stringify();return this.#t?`${t} RETURNING ${this.#t}`:t}};var Jt=class extends Ut(k){static parse(t,e,r){let{name:s,expr:i}=this.parseName(t,e,!0);if(!i||!/^UNIQUE(\s+KEY)?/i.test(i))return;let n=new this(t).name(s);if(this.checkIsColumn(t))return n;let[,o]=E.split(e,[]);return n.columns(this.parseColumns(n,o))}stringify(){return`${this.stringifyName()}UNIQUE${this.isColumnLevel?"":this.stringifyColumns()}`}};var b=class extends ot{static get PREFIX_TYPE(){return ie}static get KIND(){return"COLUMN"}#t;prettyName(t){if(!arguments.length)return this.#t;if(typeof t!="string")throw new TypeError(`Invalid argument as prettyName: ${t}.`);return this.#t=t,this}identifiesAs(t){return super.identifiesAs(t)||this.$eq(this.#t,t,"ci")}static fromJSON(t,e,r=null){return super.fromJSON(t,e,s=>{typeof e?.prettyName=="string"&&s.prettyName(e.prettyName),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,{...this.#t?{prettyName:this.#t}:{},...e})}};var Ft=class extends T{#t;value(t){return arguments.length?(this.#t=t,this):this.#t}identifiesAs(t){return t===this.#t||super.identifiesAs(t)}static get expose(){return{null:t=>this.fromJSON(t,{value:null}),literal:(t,e)=>this.fromJSON(t,{value:e})}}static fromJSON(t,e,r=null){if(!(typeof e?.value!="string"&&![null].includes(e?.value)||Object.keys(e).filter(s=>!["nodeName","value"].includes(s)).length))return super.fromJSON(t,e,s=>{s.value(e.value),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,{value:this.#t,...e})}static parse(t,e){let r=new this(t);return/^NULL$/i.test(e)?r.value(null):r.value(e)}stringify(){return`${this.#t}`}};var Yt=f=>class extends f{#t;#e;#r=new Set;$bubble(t,e){return["CONNECTED","DISCONNECTED"].includes(t)&&e instanceof b&&(t==="DISCONNECTED"?this.#r.delete(e.name().toLowerCase()):this.#r.add(e.name().toLowerCase())),super.$bubble(t,e)}expr(t){if(!arguments.length||typeof t=="boolean"){let e=this.#t;return!e&&t===!0&&this.TYPE==="DEFAULT"&&(e=Ft.fromJSON(this,{value:null})),e}if(typeof t=="string"){let e=this.parse(t);t=e.NODE_NAME==="PARENS"?e.exprUnwrapped():e}return this.$diffTagHydrate()?this.#e=this.$castInputs([t],x,this.#e,"$expr"):this.#t=this.$castInputs([t],x,this.#t,"expr"),this}$expr(...t){return this.#e??this.expr(...t)}columns(){if(arguments.length)throw new Error('The "columns" attributes for CHECK constraints is implicit.');return[...this.#r]}dirtyCheck(t=!1){return super.dirtyCheck(t).concat(this.dirtyCheckProperties(["expr"]))}generateDiff(t,e){return this.diffMergeJsons({...super.generateDiff(t,e),expr:this.$expr(!!t.$expr())?.jsonfy(e)},{expr:t.$expr()?.jsonfy(e)},e)}static fromJSON(t,e,r=null){if(!(typeof e?.expr>"u"))return super.fromJSON(t,e,s=>{s.expr(e.expr),s.$diffTagHydrate(e.$expr,i=>s.expr(i)),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,this.diffMergeJsons({expr:t.nodeNames===!1?this.#t?.stringify():this.#t?.jsonfy(t),...e},{expr:t.nodeNames===!1?this.#t?.stringify():this.#e?.jsonfy(t)},t))}static parse(t,e,r){let{name:s,expr:i}=this.parseName(t,e,!0);if(!i||!(i=i.match(new RegExp(`^${this.TYPE.replace(/_/g,"\\s+")}\\s+([\\s\\S]+)$`,"i"))?.[1]))return;let n=new this(t);return n.expr(r(n,i)).name(s)}stringify(){return`${super.stringify()} ${this.$expr()}`}};var kt=class extends Yt(k){$columns(){return this.columns()}stringify(){return`${super.stringifyName()}CHECK (${this.$expr()})`}};var K=class extends Te{get constraintLevel(){return 1}};var gt=class extends K{#t;#e;always(t){if(!arguments.length)return this.#t;if(typeof t!="boolean")throw new Error('The "always" directive must be of type boolean');return this.$diffTagHydrate()?this.#e=t:this.#t=t,this}$always(){return this.#e??this.#t}dirtyCheck(t=!1){return super.dirtyCheck(t).concat(this.dirtyCheckProperties(["always"]))}generateDiff(t,e){return this.diffMergeJsons({...super.generateDiff(t,e),always:this.$always()},{always:t.$always()},e)}static fromJSON(t,e,r=null){return super.fromJSON(t,e,s=>{s.always(!!e.always),s.$diffTagHydrate(e.$always,i=>s.always(i)),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,this.diffMergeJsons({always:this.#t,...e},{always:this.#e},t))}static parse(t,e){let{name:r,expr:s}=this.parseName(t,e,!0);if(!(!s||!(s=s.match(new RegExp("^GENERATED\\s+(ALWAYS|BY[ ]+DEFAULT)(?:\\s+AS\\s+IDENTITY)?$","i"))?.[1])))return new this(t).name(r).always(/^ALWAYS$/i.test(s))}stringify(){return this.params.dialect==="mysql"?new Ce(this.CONTEXT).stringify():`GENERATED ${this.$always()?"ALWAYS":"BY DEFAULT"} AS IDENTITY`}};var Ce=class extends K{static get TYPE(){return"AUTO_INCREMENT"}stringify(){return this.params.dialect!=="mysql"?new gt(this.contextNode).stringify():"AUTO_INCREMENT"}};var xe=class extends Yt(K){#t;#e;stored(t){if(!arguments.length)return this.#t;if(typeof t!="boolean")throw new Error('The "stored" directive must be of type boolean');return this.$diffTagHydrate()?this.#e=t:this.#t=t,this}$stored(){return this.#e??this.#t}dirtyCheck(t=!1){return super.dirtyCheck(t).concat(this.dirtyCheckProperties(["stored"]))}generateDiff(t,e){return this.diffMergeJsons({...super.generateDiff(t,e),stored:this.$stored()},{stored:t.$stored()},e)}static fromJSON(t,e,r=null){return super.fromJSON(t,e,s=>{s.stored(!!e.stored),s.$diffTagHydrate(e.$stored,i=>s.stored(i)),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,this.diffMergeJsons({stored:this.#t,...e},{stored:this.#e},t))}static parse(t,e,r){let s,{name:i,expr:n}=this.parseName(t,e,!0);if([,n,s=""]=n.match(new RegExp("^GENERATED\\s+ALWAYS\\s+AS\\s+\\(([\\s\\S]+)\\)(?:\\s+(VIRTUAL|STORED))?$","i"))||[],!n)return;let o=new this(t);return o.expr(r(o,n)).stored(/^STORED$/i.test(s)).name(i)}stringify(){return`GENERATED ALWAYS AS (${this.$expr()})${this.$stored()?" STORED":""}`}};var $e=class extends Yt(K){};var Oe=class extends K{};var mr=class extends Yt(K){};var pr=class extends K{};var dr=class extends v(D){static get EXPECTED_TYPES(){return{CONSTRAINT:[gt]}}get $KIND(){return this.argument()?.TYPE}static parse(t,e,r){let[,s]=e.match(/^ADD\s+([\s\S]+)$/i)||[];if(s){let i=new this(t,"CONSTRAINT");return i.argument(r(i,s,this.EXPECTED_TYPES.CONSTRAINT))}}stringify(){return`ADD ${this.argument()}`}};var gr=class extends D{static get EXPECTED_KINDS(){return{CONSTRAINT:["IDENTITY","EXPRESSION","DEFAULT","NOT_NULL"]}}static parse(t,e){let[,r]=e.match(new RegExp(`^DROP\\s+(${this.EXPECTED_KINDS.CONSTRAINT.map(s=>s.replace(/(?<!AUTO)_/gi,"\\s+")).join("|")})$`,"i"))||[];if(r)return new this(t,"CONSTRAINT",r.replace(/\s+/,"_").toUpperCase())}stringify(){return`DROP ${this.$KIND.replace(/(?<!AUTO)_/gi," ")}`}};var bt=class extends T{#t=[];constructor(t,e){super(t),this.#t=e}name(){return this.#t}static fromJSON(t,e){let r=[].concat(e);if(typeof r[0]!="string")return;let[s,i,n]=fs.call(this,r[0]);return s?new this(t,Zr(s,...i.split(","),...n,...r.slice(1))):new this(t,Zr(...[].concat(e)))}jsonfy(){return this.#t.length===1?this.#t[0]:this.#t}static parse(t,e){let[r,s,i]=fs.call(this,e);if(r)return new this(t,Zr(r,...s.split(","),...i))}stringify(){let[t,e]=this.#t.slice(1).reduce(([r,s],i)=>/^\d+$/.test(i)?[r.concat(i),s]:[r,s.concat(i)],[[],[]]);return`${this.#t[0]}${t.length?`(${t.join(",")})`:""}${e.length?` ${e.join(" ")}`:""}`}static pgFixedTypesRe=/^(bigint|int8|bigserial|serial8|boolean|bool|box|bytea|cidr|circle|date|double\s+precision|float8|inet|integer|int|int4|jsonb|json|line|lseg|macaddr8|macaddr|money|path|pg_lsn|pg_snapshot|point|polygon|real|float4|smallint|int2|smallserial|serial2|serial4|serial|text|timetz|timestamptz|tsquery|tsvector|txid_snapshot|uuid|xml)$/;static pgVariableTypesRe=/^(bit\s+varying|bit|varbit|character\s+varying|character|char|varchar|interval|numeric|timestamp|time)(?:\s+)?(?:\(([\d, ]+)\))?(\s+(?:with|without)\s+time\s+zone)?$/;static myFixedTypesRe=/^(tinyint|smallint|mediumint|enum|set|tinyblob|mediumblob|longblob|geometry|longstring|geometrycollection|multilinestring|multipoint|multipolygon)$/;static myVariableTypesRe=/^(float|decimal|double|tinytext|mediumtext|longtext|binary|varbinary|blob)(?:\s+)?(?:\(([\d, ]+)\))?$/},Zr=(...f)=>f.map(t=>/^\d+$/.test(t)?parseFloat(t):t?.trim().replace(/\s+/," ").toUpperCase()).filter(t=>t);function fs(f){let t,e,r;for(let s of["pgFixedTypesRe","pgVariableTypesRe","myFixedTypesRe","myVariableTypesRe"])if([,t,e="",...r]=f.match(new RegExp(this[s].source,"i"))||[],t)break;return[t,e,r]}var Er=class extends v(D){static get EXPECTED_TYPES(){return{FLAG:[Ft],DATA_TYPE:[bt],CONSTRAINT:[gt,xe,$e,Oe]}}static parse(t,e,r){let[,s,i]=new RegExp("^(SET|TYPE)\\s+([\\s\\S]+)$","i").exec(e)||[];if(!s)return;let n,o,a;if(n=i.match(/^DATA\s+TYPE\s+([\s\S]+)$/i))o="DATA_TYPE",a=n[1];else if(/^TYPE$/i.test(s))o="DATA_TYPE",a=i;else if(n=i.match(/^GENERATED\s+([\s\S]+)$/i))o="IDENTITY",a=`GENERATED ${n[1]} AS IDENTITY`;else if(n=i.match(/^EXPRESSION\s+AS\s+([\s\S]+)$/i))o="EXPRESSION",a=`GENERATED ALWAYS AS ${n[1]} STORED`;else if(n=i.match(/^(DEFAULT|NOT\s+NULL)[\s\S]+$/i))o=n[1].replace(/\s+/g,"_").toUpperCase(),a=i;else{let[,c,h]=i.match(/(\w+)(?:\s+)?(.+)/);return new this(t,"FLAG",c.toUpperCase()).argument(m=>m.literal(h))}let u=new this(t,o==="DATA_TYPE"?o:"CONSTRAINT",o);return u.argument(r(u,a,this.EXPECTED_TYPES[u.KIND]))}stringify(){let t=this.$KIND.replace(/(?<!AUTO)_/gi," "),e=this.argument();return this.KIND==="DATA_TYPE"?e=`${t} ${e}`:this.$KIND==="EXPRESSION"?e=`${t} AS ${this.argument().$expr()}`:this.$KIND==="IDENTITY"&&(e=`GENERATED ${this.argument().$always()?"ALWAYS":"BY DEFAULT"}`),`SET ${e}`}};var be=class extends H{static get EXPECTED_TYPES(){return[dr,gr,Er]}};var G=class extends Ne{static get CONSTRAINT_TYPES(){return[Ce,gt,xe,$e,Oe,pr,mr,Mt,Dt,Jt,kt]}static get PREFIX_TYPE(){return[O]}#t;#e;#r=[];type(t){return arguments.length?(this.$diffTagHydrate()?this.#e=this.$castInputs([t],bt,this.#e,"$type"):this.#t=this.$castInputs([t],bt,this.#t,"type"),this):this.#t}$type(){return this.#e||this.#t}autoIncrement(...t){return this.constraint("AUTO_INCREMENT",...t)}identity(...t){return this.constraint("IDENTITY",...t)}expression(...t){return this.constraint("EXPRESSION",...t)}default(...t){return this.constraint("DEFAULT",...t)}notNull(...t){return this.constraint("NOT_NULL",...t)}null(...t){return this.constraint("NULL",...t)}onUpdate(...t){return this.constraint("ON_UPDATE",...t)}primaryKey(...t){return this.constraint("PRIMARY_KEY",...t)}foreignKey(...t){return this.constraint("FOREIGN_KEY",...t)}uniqueKey(...t){return this.constraint("UNIQUE_KEY",...t)}check(...t){return this.constraint("CHECK",...t)}constraint(t,...e){if(typeof t=="string"){let r=this.#r.find(s=>s.TYPE===t);if(!e.length)return r;if(e[0]===!1)return this.#r=this.#r.filter(s=>s!==r),r?.bubble("DISCONNECTED"),this;t={type:t,...["CHECK","DEFAULT","EXPRESSION","ON_UPDATE"].includes(t)&&!(N(e[0])&&e[0].expr)?{expr:e[0]}:typeof e[0]=="object"?e[0]:{}}}return this.#r=this.$castInputs([t],this.constructor.CONSTRAINT_TYPES,this.#r,"constraint",null,r=>this.#r.find(s=>s.TYPE===r.TYPE)),this}constraints(t=!0,e=0){let r=e?this.#r.filter(s=>s instanceof k==(e===2)):this.#r;return t?r:r.map(s=>s.TYPE)}dirtyCheck(t=!1){let e=super.dirtyCheck(t).concat(this.dirtyCheckProperties(["type"]));return t?e.concat(["constraints"].filter(r=>this[r]().some(s=>s.dirtyCheck(t).length))):e}renderCDL(t,e){let r=this.jsonfy(e);for(let s of t){let i,n;if(["ADD","SET"].includes(s.CLAUSE)&&(i=s.argument().jsonfy(e),n={...i,...e.diff!==!1?{status:"new"}:{}}),s.CLAUSE==="ADD"){if(s.$KIND==="IDENTITY"){if(r.identity)throw new Error("IDENTITY constraint already exists.");r={...r,identity:n}}}else if(s.CLAUSE==="SET")if(s.KIND==="DATA_TYPE")r=this.diffMergeJsons(r,{type:i});else if(s.$KIND==="IDENTITY"){if(!r.identity)throw new Error("IDENTITY constraint not exists.");r={...r,identity:this.diffMergeJsons(r.identity,{always:i.always},e)}}else s.$KIND==="EXPRESSION"?r={...r,expression:r.expression?this.diffMergeJsons(r.expression,{expr:i.expr},e):n}:s.$KIND==="DEFAULT"&&(r={...r,default:r.default?this.diffMergeJsons(r.default,{expr:i.expr},e):n});else if(s.CLAUSE==="DROP"){let o=ye(s.$KIND.toLowerCase().replace("_"," "));if(!r[o])throw new Error(`${s.$KIND} constraint does not exist.`);r=e.diff===!1?r:{...r,[o]:this.diffMergeJsons(r[o],{status:"obsolete"})}}}return r}generateCDL(t={}){let e=be.fromJSON(this,{actions:[]});this.#e&&!this.$eq(this.#e,this.#t,"ci")&&e.add("SET","DATA_TYPE",r=>r.argument(this.#e.jsonfy(t)));for(let r of this.#r)if(r.constraintLevel!==2)if(r.status()==="obsolete")e.add("DROP","CONSTRAINT",r.TYPE);else if(r.status()==="new"&&r.TYPE==="IDENTITY")e.add("ADD","CONSTRAINT",r.TYPE,s=>s.argument(r.jsonfy({...t,diff:!1})));else{if(!r.dirtyCheck().length)continue;e.add("SET","CONSTRAINT",r.TYPE,i=>i.argument(r.jsonfy({...t,diff:!1})))}return e}generateDiff(t,e){let r=this.diffMergeJsons({...super.generateDiff(t,e),type:this.$type()?.jsonfy(e)},{type:t.$type()?.jsonfy(e)},e),s=this.flattenConstraintJsons(this.diffMergeTrees(new Map(this.constraints().map(i=>[i.TYPE,i])),new Map(t.constraints().map(i=>[i.TYPE,i])),(i,n)=>i.generateDiff(n,e)),e);return{...r,...s}}flattenConstraintJsons(t){let e={};for(let r of t){let{type:s,...i}=r,n=ye(s.toLowerCase().replace("_"," "));e={...e,[n]:Object.keys(i).filter(o=>i[o]!==void 0).length?i:!0}}return e}static unflattenConstraintJsons(t){return Object.entries(t).map(([e,r])=>{let s=i=>{throw new Error(`Invalid ${i?`or missing attribute "${i}"`:"format"} for constraint "${e}"`)};if(e=Ge(e+"","_").toUpperCase(),r=r===!0?{}:r===!1?{status:"obsolete"}:r,["CHECK","EXPRESSION","DEFAULT","ON_UPDATE"].includes(e))(!N(r)||!r.expr)&&(r={expr:r});else if(e==="FOREIGN_KEY")O.fromJSON({},r?.targetTable)||s("targetTable"),Array.isArray(r?.targetColumns)||s("targetColumns");else if(["PRIMARY_KEY","UNIQUE_KEY","IDENTITY","NOT_NULL","NULL","AUTO_INCREMENT"].includes(e))N(r)||s();else throw new Error(`Unknown attribute or constraint: ${e}`);return{type:e,...r}})}static fromJSON(t,e,r=null){let{nodeName:s,name:i,$name:n,prefix:o,$prefix:a,type:u,$type:c,status:h,CDLIgnoreList:d,...m}=e;if(bt.fromJSON({},u))return super.fromJSON(t,e,l=>{l.type(u),l.$diffTagHydrate(c,p=>l.type(p));for(let p of this.unflattenConstraintJsons(m))l.constraint(p);r?.(l)})}jsonfy(t={},e={},r=null){let s=this.#r.reduce((i,n,o)=>{if(r){let a=r(n,o);if(!a)return i;if(![n,!0].includes(a)){if(a instanceof T)throw new Error("A JSON object not a node instance expected from reducer");return i.concat(a)}}return i.concat(n.jsonfy(t)||[])},[]);return super.jsonfy(t,{type:this.#t?.jsonfy(t),...this.#e?{$type:this.#e.jsonfy(t)}:{},...this.flattenConstraintJsons(s),...e})}static parse(t,e,r){let[s,i]=E.split(e,["\\s+"],{useRegex:!0,limit:1}),[n]=this.parseIdent(t,s.trim());if(!n)return;let o=new this(t).name(n),a="(CONSTRAINT\\s+.+?\\s+)?",u=[{test:`${a}(PRIMARY[ ]+KEY|NOT[ ]+NULL|GENERATED|REFERENCES|UNIQUE(?:[ ]+KEY)?|CHECK|AUTO_INCREMENT)`},{backtest:"^(?!.*\\s+(NOT|SET)\\s+$)",test:`${a}NULL`},{backtest:"^(?!.*\\s+BY\\s+$)",test:`${a}DEFAULT`},{backtest:"^(?!.*\\s+REFERENCES\\s+)",test:"ON\\s+UPDATE"}],[c,...h]=E.split(i,u,{useRegex:"i",preserveDelims:!0});o.type(r(o,c.trim(),[bt]));for(let d of h){let m=r(o,d,this.CONSTRAINT_TYPES);o.constraint(m)}return o}stringify(){let t=this.#r;return this.params.dialect==="mysql"&&(t=t.filter(e=>e.TYPE!=="FOREIGN_KEY")),`${this.stringifyIdent(this.$name())} ${this.$type()}${t.length?` ${t.join(" ")}`:""}`}};var yr=class extends D{#t;value(t){return arguments.length?(this.#t=t,this):this.#t}static fromJSON(t,e,r=null){if(e?.value)return super.fromJSON(t,e,s=>{s.value(e.value),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,{value:this.#t,...e})}static parse(t,e){let[r]=e.match(/TODO/i)||[];if(r)return new this(t).value(r.replace(/\s+/,"_").toUpperCase())}stringify(){return this.#t?.replace(/_/," ")||""}};var De=class extends H{static get EXPECTED_TYPES(){return[yr]}};var ft=class extends Ut(at){#t;#e;type(t){if(!arguments.length)return this.#t;if(typeof t!="string")throw new Error(`The "type" directive must be of type string. Recieved ${t}`);return this.$diffTagHydrate()?this.#e=t:this.#t=t,this}$type(){return this.#e??this.#t}dirtyCheck(t=!1){return super.dirtyCheck(t).concat(this.dirtyCheckProperties(["type"]))}renderCDL(t,e){return this.jsonfy(e)}generateCDL(){return De.fromJSON(this,{actions:[]})}generateDiff(t,e){return this.diffMergeJsons({...super.generateDiff(t,e),type:this.$type()},{type:t.$type()},e)}static fromJSON(t,e,r=null){if(/^(INDEX|KEY|FULLTEXT)$/i.test(e.type))return super.fromJSON(t,e,s=>{s.type(e.type),s.$diffTagHydrate(e.$type,i=>s.type(i)),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,{type:this.#t,...this.#e?{$type:this.#e}:{},...e})}static checkIsColumn(t){return!1}static parse(t,e){let[r,s,i]=/^((?:(?:FULLTEXT|SPATIAL)(?:\s+INDEX|\s+KEY)?)|(?:INDEX|KEY))([\s\S]+)$/i.exec(e)||[];if(!r)return;let n=new this(t),[o,a]=E.split(i,[]),[u]=this.parseIdent(t,o.trim());return n.type(s.replace(/\s+(INDEX|KEY)/i,"").toUpperCase()).columns(this.parseColumns(n,a)).name(u)}stringify(){return`${this.$type()}${this.$name()?` ${this.stringifyIdent(this.$name())}`:""}${this.stringifyColumns()}`}};var we=class extends v(D){static get EXPECTED_TYPES(){return{COLUMN:[G],CONSTRAINT:[Mt,Dt,Jt,kt],INDEX:[ft]}}static get REF_TYPES(){return{COLUMN:[b],CONSTRAINT:[w],INDEX:[w]}}get $KIND(){return this.KIND==="COLUMN"?this.argument()?.type()?.name():this.argument()?.TYPE}#t;#e;first(t){return arguments.length?(this.#t=!!t,this):this.#t}after(t){return arguments.length?(this.#e=this.$castInputs([t],this.constructor.REF_TYPES[this.KIND],this.#e,"ref"),this):this.#e}static fromJSON(t,e,r=null){return super.fromJSON(t,e,s=>{e.first&&s.first(!0),e.after&&s.after(e.after),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,{...this.#t?{first:!0}:{},...this.#e?{after:this.#e.jsonfy(t)}:{},...e})}static parse(t,e,r,s=null){let i,[,n,o,a,u]=e.match(new RegExp(`^${this.CLAUSE}\\s+(?:(${Object.keys(this.EXPECTED_TYPES).join("|")})\\s+)?([\\s\\S]+?)(?:\\s+AFTER\\s+(.+)|\\s+(FIRST))?$`,"i"))||[];if(n||(/^(PRIMARY|FOREIGN|UNIQUE|CHECK)/i.test(o)?(n="CONSTRAINT",i=!0):/^(FULLTEXT|SPATIAL)/i.test(o)?(n="INDEX",i=!0):o&&(n="COLUMN")),!n)return;let c=new this(t,n.toUpperCase());if(c.CLAUSE==="ADD"){let[,d,m]=o.match(/(IF\s+NOT\s+EXISTS\s+)?([\s\S]+)$/i);d&&c.withFlag("IF_NOT_EXISTS"),o=m}a?c.after(r(c,a,this.REF_TYPES[c.KIND])):u&&c.first();let h=(s||r)(c,c.KIND==="COLUMN"||i?o:`${c.KIND} ${o}`,this.EXPECTED_TYPES[c.KIND]);return c.argument(h)}stringify(){let t=[this.CLAUSE];return this.hasFlag("IF_NOT_EXISTS")&&t.push("IF NOT EXISTS"),t.push(this.argument()),this.#t?t.push("FIRST"):this.#e&&t.push("AFTER",this.#e),t.join(" ")}};var Re=class extends we{};var Sr=class extends q(Re){static parse(t,e,r){return super.parse(t,e,r,(s,i,n)=>{let[o,a]=Lexer.split(i,["\\s+"],{useRegex:!0,limit:1});return s.reference(r(s,o,this.REF_TYPES[s.KIND])),r(s,a,n)})}stringify(){return super.stringify().replace(this.KIND,`${this.KIND} ${this.reference()}`)}};var Nr=class extends q(D){static get EXPECTED_KINDS(){return{COLUMN:["COLUMN"],CONSTRAINT:["PRIMARY_KEY","FOREIGN_KEY","UNIQUE_KEY","CHECK"],INDEX:["INDEX"]}}static get REF_TYPES(){return{COLUMN:[b],CONSTRAINT:[w],INDEX:[w]}}static parse(t,e,r){let s=Object.keys(this.EXPECTED_KINDS),i=t?.params?.dialect==="mysql"?[...new Set(s.reduce((l,p)=>l.concat(p,this.EXPECTED_KINDS[p]),[]))]:s,[n,o="COLUMN",a,u,c]=e.match(new RegExp(`^DROP(?:\\s+(${i.map(l=>l.replace(/_/gi,"\\s+")).join("|")})(\\s+IF\\s+EXISTS)?)?(?:\\s+([\\s\\S]+?)(?:\\s+(RESTRICT|CASCADE|FORCE))?)?$`,"i"))||[];if(!n)return;let h=o.replace(/\s+/g,"_").toUpperCase(),d=s.includes(h)?h:s.find(l=>this.EXPECTED_KINDS[l].includes(h));if(!d)return;let m=new this(t,d,h);return a&&m.withFlag("IF_EXISTS"),c&&m.withFlag(c),u&&m.reference(r(m,u,this.REF_TYPES[d])),m}stringify(){let t=["DROP",this.params.dialect==="mysql"?this.$KIND.replace(/_/g," "):this.KIND];return this.hasFlag("IF_EXISTS")&&t.push("IF EXISTS"),this.reference()&&t.push(this.reference()),this.hasFlag("RESTRICT")?t.push("RESTRICT"):this.hasFlag("CASCADE")?t.push("CASCADE"):this.hasFlag("FORCE")&&t.push("FORCE"),t.join(" ")}};var _r=class extends v(D){static get EXPECTED_TYPES(){return{SCHEMA:[Ot]}}static parse(t,e,r){let[,s,i]=new RegExp(`^SET\\s+(${Object.keys(this.EXPECTED_TYPES).map(o=>o.replace(/_/g,"\\s+")).join("|")})\\s+([\\s\\S]+)$`,"i").exec(e)||[];if(!s)return;let n=new this(t,s.replace(/s+/g,"_").toUpperCase());return n.argument(r(n,i,this.EXPECTED_TYPES[n.KIND]))}stringify(){return`SET ${this.KIND.replace(/_/g," ")} ${this.argument()}`}};var Tr=class extends q(v(D)){static get EXPECTED_TYPES(){return{COLUMN:[be],CONSTRAINT:[_e],INDEX:[De]}}static get REF_TYPES(){return{COLUMN:[b],CONSTRAINT:[w],INDEX:[w]}}static parse(t,e,r){let[,s="COLUMN",i]=e.match(new RegExp(`^ALTER\\s+(?:(${Object.keys(this.EXPECTED_TYPES).join("|")})\\s+)?([\\s\\S]+)$`,"i"))||[],[n,o]=E.split(i,[" "],{limit:1}).map(u=>u.trim());if(!o)return;let a=new this(t,s.toUpperCase());return a.reference(r(a,n,this.REF_TYPES[a.KIND])),a.argument(r(a,o,this.EXPECTED_TYPES[a.KIND])),a}stringify(){return[...this.argument()].map(t=>`ALTER ${this.KIND} ${this.reference()} ${t}`).join(`
`)}};var Ar=class extends q(v(D)){static get REF_TYPES(){return{COLUMN:[b],CONSTRAINT:[w],INDEX:[w]}}static get EXPECTED_TYPES(){return this.REF_TYPES}static get OWN_REF_TYPE(){return O}get EXPECTED_TYPES(){return this.KIND?this.constructor.EXPECTED_TYPES[this.KIND]:this.constructor.OWN_REF_TYPE}static parse(t,e,r){let[,s="COLUMN",i,n]=e.match(new RegExp(`^RENAME\\s+(?:(${Object.keys(this.REF_TYPES).join("|")})\\s+)?(?:([\\s\\S]+?)\\s+)?(?:TO|AS)\\s+([\\s\\S]+)$`,"i"))||[];if(!n)return;let o=new this(t,i&&s.toUpperCase());return i?(o.reference(r(o,i,this.REF_TYPES[o.KIND])),o.argument(r(o,n,this.EXPECTED_TYPES[o.KIND]))):o.argument(r(o,n,[this.OWN_REF_TYPE])),o}stringify(){return["RENAME",this.KIND,this.reference(),"TO",this.argument()].filter(t=>t).join(" ")}};var ne=class extends H{static get EXPECTED_TYPES(){return[we,Re,Sr,Nr,_r,Tr,Ar]}};var Et=class extends j(Ae){static get EXPECTED_TYPES(){return{TABLE:[ne],VIEW:[ne]}}static get REF_TYPES(){return{TABLE:[O],VIEW:[O]}}stringify(){let[t,e,r,s]=this.argument().actions().reduce(([o,a,u,c],h)=>h.CLAUSE==="SET"&&h.KIND==="SCHEMA"?[h,a,u,c]:h.CLAUSE==="RENAME"&&!h.KIND?[o,h,u,c]:h.CLAUSE==="RENAME"?[o,a,u.concat(h),c]:[o,a,u,c.concat(h)],[null,null,[],[]]),i=[],n=`ALTER ${this.KIND}${this.hasFlag("IF_EXISTS")?" IF EXISTS":""}`;s.length&&i.push(`${n} ${this.reference()}
	${s.join(`,
	`)}`);for(let o of r.concat(e||[]))i.push(`${n} ${this.reference()} ${o}`);return t&&i.push(`${n} ${e?.argument()||this.reference()} ${t}`),i.join(`;
`)}};var Ie=class extends v(D){static parse(t,e,r){let[,s,i,n]=e.match(new RegExp(`^${this.CLAUSE}\\s+(${Object.keys(this.EXPECTED_TYPES).join("|")})\\s+(IF\\s+NOT\\s+EXISTS\\s+)?([\\s\\S]+)$`,"i"))||[];if(!s)return;let o=new this(t,s.toUpperCase());i&&o.withFlag("IF_NOT_EXISTS");let a=r(o,n,this.EXPECTED_TYPES[o.KIND]);return o.argument(a)}stringify(){let t=["CREATE",this.KIND];return this.hasFlag("IF_NOT_EXISTS")&&t.push("IF NOT EXISTS"),t.push(this.argument()),t.join(" ")}};var yt=class extends j(Ie){static get EXPECTED_TYPES(){return{TABLE:[wt],VIEW:[wt]}}};var Le=class extends q(D){static parse(t,e,r){let s=Object.keys(this.EXPECTED_KINDS),[,i,n,o,a]=e.match(new RegExp(`^DROP\\s+(?:(${s.map(c=>c.replace(/_/gi,"\\s+")).join("|")})\\s+(IF\\s+EXISTS\\s+)?)?([\\s\\S]+?)(?:\\s+(RESTRICT|CASCADE|FORCE))?$`,"i"))||[];if(!i)return;let u=new this(t,i.replace(/\s+/g,"_").toUpperCase());return n&&u.withFlag("IF_EXISTS"),a&&u.withFlag(a),o&&u.reference(r(u,o,this.REF_TYPES[u.KIND])),u}stringify(){let t=["DROP",this.KIND];return this.hasFlag("IF_EXISTS")&&t.push("IF EXISTS"),this.reference()&&t.push(this.reference()),this.hasFlag("RESTRICT")?t.push("RESTRICT"):this.hasFlag("CASCADE")?t.push("CASCADE"):this.hasFlag("FORCE")&&t.push("FORCE"),t.join(" ")}};var jt=class extends j(Le){static get EXPECTED_KINDS(){return{TABLE:!0,VIEW:!0}}static get REF_TYPES(){return{TABLE:[O],VIEW:[O]}}};var Pe=class extends q(v(D)){static get EXPECTED_TYPES(){return this.REF_TYPES}static parse(t,e,r){let[,s,i,n]=e.match(new RegExp(`^RENAME\\s+(?:(${Object.keys(this.REF_TYPES).join("|")})\\s+)?(?:([\\s\\S]+?)\\s+)?(?:TO|AS)\\s+([\\s\\S]+)$`,"i"))||[];if(!n)return;let o=new this(t,i&&s.toUpperCase());return i?(o.reference(r(o,i,this.REF_TYPES[o.KIND])),o.argument(r(o,n,this.EXPECTED_TYPES[o.KIND]))):o.argument(r(o,n,[this.OWN_REF_TYPE])),o}stringify(){return["RENAME",this.KIND,this.reference(),"TO",this.argument()].filter(t=>t).join(" ")}};var ve=class extends Pe{static get REF_TYPES(){return{TABLE:[O],VIEW:[O]}}static get OWN_REF_TYPE(){return U}get EXPECTED_TYPES(){return this.KIND?this.constructor.EXPECTED_TYPES[this.KIND]:this.constructor.OWN_REF_TYPE}};var Cr=class extends v(D){static get EXPECTED_TYPES(){return{TABLESPACE:[w]}}static parse(t,e,r){let[,s,i]=new RegExp(`^SET\\s+(${Object.keys(this.EXPECTED_TYPES).map(o=>o.replace(/_/g,"\\s+")).join("|")})\\s+([\\s\\S]+)$`,"i").exec(e)||[];if(!s)return;let n=new this(t,s.replace(/s+/g,"_").toUpperCase());return n.argument(r(n,i,this.EXPECTED_TYPES[n.KIND]))}stringify(){return`SET ${this.KIND.replace(/_/g," ")} ${this.argument()}`}};var oe=class extends H{static get EXPECTED_TYPES(){return[Et,yt,jt,ve,Cr]}};var St=class extends j(Ae){static get EXPECTED_TYPES(){return{DATABASE:[oe],SCHEMA:[oe]}}static get REF_TYPES(){return{DATABASE:[U],SCHEMA:[U]}}stringify(){let[t,e,r,s]=this.argument().actions().reduce(([n,o,a,u],c)=>c.CLAUSE==="RENAME"&&!c.KIND?[c,o,a,u]:c.CLAUSE==="RENAME"?[n,o.concat(c),a,u]:c.CLAUSE==="SET"?[n,o,a.concat(c),u]:[n,o,a,u.concat(c)],[null,[],[],[]]),i=[];i.push(...s,...e);for(let n of r)i.push(`ALTER ${this.KIND} ${this.reference()} ${n}`);return t&&i.push(`ALTER ${this.KIND} ${this.reference()} ${t}`),i.join(`;
`)}};var Kt=class extends j(Ie){static get EXPECTED_TYPES(){return{DATABASE:[Q],SCHEMA:[Q]}}stringify(){let t=[super.stringify()];return t.push(...this.argument().tables().map(e=>{let r=yt.fromJSON(this,{argument:e});return this.hasFlag("IF_NOT_EXISTS")&&r.withFlag("IF_NOT_EXISTS"),r})),t.join(`;
`)}};var Bt=class extends j(Le){static get EXPECTED_KINDS(){return{DATABASE:!0,SCHEMA:!0}}static get REF_TYPES(){return{DATABASE:[U],SCHEMA:[U]}}};var Xt=class extends j(Pe){static get REF_TYPES(){return{DATABASE:[U],SCHEMA:[U]}}};var Rt=class extends H{static get EXPECTED_TYPES(){return[St,Kt,Bt,Xt]}};var Dt=class extends Ut(k){#t;#e;#r=[];#s=[];#n;#i;#o;#f;#a;#u;targetTable(t){return arguments.length?(this.$diffTagHydrate()?this.#e=this.$castInputs([t],O,this.#e,"target_table"):this.#t=this.$castInputs([t],O,this.#t,"target_table"),this):this.#t}$targetTable(){return this.#e||this.targetTable()}targetColumns(t){if(!arguments.length)return this.#r;if(!Array.isArray(t)||!t.length)throw new Error("Columns list must be a non-empty array");return this.$diffTagHydrate()?this.#s=t:this.#r=t,this}$targetColumns(){return this.#s.length?this.#s:this.targetColumns()}matchRule(t){return arguments.length?(this.$diffTagHydrate()?this.#i=t:this.#n=t,this):this.#n}$matchRule(){return this.#i||this.matchRule()}updateRule(t){return arguments.length?(this.$diffTagHydrate()?this.#f=t:this.#o=t,this):this.#o}$updateRule(){return this.#f||this.updateRule()}deleteRule(t){return arguments.length?(this.$diffTagHydrate()?this.#u=t:this.#a=t,this):this.#a}$deleteRule(){return this.#u||this.deleteRule()}dirtyCheck(t=!1){return super.dirtyCheck(t).concat(this.dirtyCheckProperties(["targetTable","targetColumns","matchRule","updateRule","deleteRule"]))}generateDiff(t,e){return this.diffMergeJsons({...super.generateDiff(t,e),targetTable:this.$targetTable()?.jsonfy(e),targetColumns:this.$targetColumns().slice(),matchRule:this.$matchRule(),updateRule:this.$updateRule(),deleteRule:this.$deleteRule()},{targetTable:t.$targetTable()?.jsonfy(e),targetColumns:t.$targetColumns().slice(),matchRule:t.$matchRule(),updateRule:t.$updateRule(),deleteRule:t.$deleteRule()},e)}static fromJSON(t,e,r=null){if(Array.isArray(e?.targetColumns))return super.fromJSON(t,e,s=>{s.targetTable(e.targetTable),s.$diffTagHydrate(e.$targetTable,i=>s.targetTable(i)),s.targetColumns(e.targetColumns),s.$diffTagHydrate(e.$targetColumns,i=>s.targetColumns(i)),e.matchRule&&s.matchRule(e.matchRule),s.$diffTagHydrate(e.$matchRule,i=>s.matchRule(i)),e.updateRule&&s.updateRule(e.updateRule),s.$diffTagHydrate(e.$updateRule,i=>s.updateRule(i)),e.deleteRule&&s.deleteRule(e.deleteRule),s.$diffTagHydrate(e.$deleteRule,i=>s.deleteRule(i)),r?.(s)})}jsonfy(t={},e={}){let r=super.jsonfy(t,this.diffMergeJsons({targetTable:this.#t?.jsonfy(t),targetColumns:this.#r.slice(),...this.#n?{matchRule:this.#n}:{},...this.#o?{updateRule:this.#o}:{},...this.#a?{deleteRule:this.#a}:{},...e},{targetTable:this.#e?.jsonfy(t),targetColumns:this.#s.slice(),matchRule:this.#i,updateRule:this.#f,deleteRule:this.#u},t));if(!(t.rootCDL instanceof Rt))return r;if(!r)return;let s={columnMutes:[],dropped:!1},i=l=>{if(l&&!l.hasFlag("CASCADE"))throw new Error(`Cannot drop ${l.KIND} ${l.reference()} because other objects depend on it.`);s.dropped=!0,t.diff&&(r={...r,status:"obsolete"})},n=l=>{let p=l.jsonfy(t);r=this.diffMergeJsons(r,{targetTable:{...r.targetTable,prefix:p}},t),t.diff!==!1&&(r.CDLIgnoreList||(r.CDLIgnoreList=[]),r.CDLIgnoreList.push("targetTable"))},o=l=>{let p=l.jsonfy(t);r=this.diffMergeJsons(r,{targetTable:{...r.targetTable,...p}},t),t.diff!==!1&&(r.CDLIgnoreList||(r.CDLIgnoreList=[]),r.CDLIgnoreList.push("targetTable"))},a=()=>{let l=this.resolveColumnReferences(r.targetColumns,s.columnMutes,!0);l.length!==r.targetColumns.length?i():pt(l,r.targetColumns).length!==r.targetColumns.length&&(r=this.diffMergeJsons(r,{targetColumns:l},t),t.diff!==!1&&(r.CDLIgnoreList||(r.CDLIgnoreList=[]),r.CDLIgnoreList.push("targetColumns")))},u=l=>l?.identifiesAs(this.$targetTable().prefix(!0)),c=l=>l?.identifiesAs(this.$targetTable().name()),h=l=>{for(let p of l)p.CLAUSE==="RENAME"?p.KIND?p.KIND==="COLUMN"&&s.columnMutes.push(p):o(p.argument()):p.CLAUSE==="SET"?p.KIND==="SCHEMA"&&n(p.argument()):p.CLAUSE==="DROP"&&p.KIND==="COLUMN"&&s.columnMutes.push(p)},d=l=>{for(let p of l){if(p.CLAUSE==="RENAME")p.KIND?c(p.reference())&&o(p.argument()):n(p.argument());else if(!c(p.reference?.()))continue;p.CLAUSE==="ALTER"?h(p.argument()):p.CLAUSE==="DROP"&&i(p)}};if((l=>{for(let p of l)u(p.reference?.())&&(p.CLAUSE==="RENAME"?n(p.argument()):p.CLAUSE==="ALTER"?d(p.argument()):p.CLAUSE==="DROP"&&i(p))})(t.rootCDL),a(),!(s.dropped&&!t.diff))return r}static parse(t,e,r){let{name:s,expr:i=""}=this.parseName(t,e,!0),n;if(this.checkIsColumn(t)){if(!(i=i.match(/^REFERENCES\s+([\s\S]+)$/i)?.[1]))return;n=new this(t)}else{if(!/^FOREIGN\s+KEY/i.test(i))return;n=new this(t);let[,m,...l]=E.split(i,[]);n.columns(this.parseColumns(t,m)),i=l.join("").trim().match(/^REFERENCES\s+([\s\S]+)$/i)?.[1]}let[o,a,u=""]=E.split(i,[]),c=r(n,o.trim(),[O]),h=E.split(V(a,"(",")"),[","]).map(m=>this.parseIdent(t,m.trim())[0]),d=(m,l)=>{if(l==="MATCH")return m.match(/MATCH\s+(\w+)/i)?.[1];let p=/(NO\s+ACTION|RESTRICT|CASCADE|(SET\s+NULL|SET\s+DEFAULT)(?:\s+\(([^\)]+)\))?)/,[,_,S,y]=m.match(new RegExp(`ON\\s+${l}\\s+${p.source}`,"i"))||[];return S?y?{rule:S,targetColumns:y.split(",").map(C=>C.trim())}:S:_};return n.name(s).targetTable(c).targetColumns(h).matchRule(d(u,"MATCH")).updateRule(d(u,"UPDATE")).deleteRule(d(u,"DELETE"))}stringify(){let t=this.isColumnLevel?this.stringifyName():`${this.stringifyName()}FOREIGN KEY${this.stringifyColumns()} `;t+=`REFERENCES ${this.$targetTable()} (${this.$targetColumns().map(r=>this.stringifyIdent(r)).join(", ")})`;let e=r=>typeof r=="object"&&r?`${r.rule} (${r.targetColumns.join(", ")})`:r;return this.$matchRule()&&(t+=` MATCH ${this.$matchRule()}`),this.$updateRule()&&(t+=` ON UPDATE ${e(this.$updateRule())}`),this.$deleteRule()&&(t+=` ON DELETE ${e(this.$deleteRule())}`),t}};var wt=class extends Ne{static get CONSTRAINT_TYPES(){return[Mt,Dt,Jt,kt]}static get PREFIX_TYPE(){return[U]}#t=[];#e=[];#r=[];#s=new Set;[Symbol.iterator](){return this.#t[Symbol.iterator]()}get length(){return this.#t.length}$capture(t,e){return["TABLE_SCHEMA"].includes(t)?this:super.$capture(t,e)}$bubble(t,e){return["CONNECTED","DISCONNECTED"].includes(t)&&[G,k,ft].some(r=>e instanceof r&&(e.contextNode===this||e.contextNode instanceof G&&e.contextNode.contextNode===this))&&(t==="DISCONNECTED"?this.#s.delete(e):this.#s.add(e)),super.$bubble(t,e)}column(t,...e){if(typeof t=="string"){let r=this.#t.find(s=>s.identifiesAs(t));if(!e.length)return r;if(e[0]===!1)return this.#t=this.#t.filter(s=>s!==r),r?.bubble("DISCONNECTED"),this;t={name:t,...typeof e[0]=="object"?e[0]:{type:e[0]}}}return this.#t=this.$castInputs([t],G,this.#t,"columns",null,r=>this.#t.find(s=>s.identifiesAs(r.name()))),this}constraint(t,...e){if(typeof t=="string"){let r=[...this.#s].find(s=>s.identifiesAs(t));if(!e.length)return r;if(e[0]===!1)return this.#e.includes(r)?(this.#e=this.#e.filter(s=>s!==r),r?.bubble("DISCONNECTED")):r&&this.column(r.columns()[0]).constraint(r.TYPE,!1),this;t={name:t,...typeof e[0]=="object"?e[0]:{type:e[0],columns:e[1]}}}return this.#e=this.$castInputs([t],this.constructor.CONSTRAINT_TYPES,this.#e,"constraints",null,r=>{let s=this.#e.find(i=>i.identifiesAs(r.name()));return!s&&r.columns().length===1&&this.column(r.columns()[0])?.constraint(r.TYPE,!1),s}),this}index(t,...e){if(typeof t=="string"){let r=this.#r.find(s=>s.identifiesAs(t));if(!e.length)return r;if(e[0]===!1)return this.#r=this.#r.filter(s=>s!==r),r?.bubble("DISCONNECTED"),this;t={name:t,...typeof e[0]=="object"?e[0]:{type:e[0],columns:e[1]}}}return this.#r=this.$castInputs([t],ft,this.#r,"indexes",null,r=>this.#r.find(s=>s.identifiesAs(r.name()))),this}columns(t=!0){let e=this.#t;return t?e:e.map(r=>r.name())}constraints(t=!0,e=!0){let r=e?[...this.#s].filter(s=>s instanceof k):this.#e;return t?r:r.map(s=>s.columns())}indexes(t=!0){let e=this.#r;return t?e:e.map(r=>r.columns())}primaryKey(t=!0,e=!0){let r=(e?[...this.#s]:this.#e).find(s=>s.TYPE==="PRIMARY_KEY");return t?r:r.columns()}foreignKeys(t=!0,e=!0){let r=(e?[...this.#s]:this.#e).filter(s=>s.TYPE==="FOREIGN_KEY");return t?r:r.map(s=>s.columns())}uniqueKeys(t=!0,e=!0){let r=(e?[...this.#s]:this.#e).filter(s=>s.TYPE==="UNIQUE_KEY");return t?r:r.map(s=>s.columns())}checks(t=!0,e=!0){let r=(e?[...this.#s]:this.#e).filter(s=>s.TYPE==="CHECK");return t?r:r.map(s=>s.expr())}dirtyCheck(t=!1){let e=super.dirtyCheck(t);return t?e.concat(["columns","constraints","indexes"].filter(r=>this[r]().some(s=>s.dirtyCheck(t).length))):e}renderCDL(t,e={}){let{rootCDL:r,...s}=e,i=new Map,n=new Map,o=(g,A,L=!0,J=!0)=>{let R=[].concat(g),Ct=R.includes("COLUMN")?G:R.includes("INDEX")?ft:k,Y=[...this.#s].find(sr=>sr instanceof Ct&&(sr.identifiesAs(A)||!A&&this.params.dialect==="mysql"&&R.includes("PRIMARY_KEY")));if((!Y||i.has(Y)&&!i.get(Y))&&L)throw new Error(`${R[0]}${A?` "${A}"`:""} does not exist.`);return J&&i.has(Y)?[Y,Y.constructor.fromJSON(Y.contextNode.clone(),i.get(Y))]:[Y]},a=g=>{let A=`${g.KIND}:LAST`;if(g.after()?[A]=o(g.KIND,g.after().name(),!0,!1):g.first()&&(A=`${g.KIND}:FIRST`),n.has(A)||n.set(A,[]),["MODIFY","CHANGE"].includes(g.CLAUSE)){let[R,Ct]=o(g.KIND,g.CLAUSE==="CHANGE"?g.reference().name():g.argument().name()),Y=(Ct||R).generateDiff(g.argument(),s);n.get(A).unshift(Y);return}let[L]=o(g.KIND,g.argument().name(),!1,!1);if(L){if(i.has(L)&&(!i.get(L)||i.get(L).status==="obsolete")){i.set(L,g.argument().jsonfy(s));return}if(g.hasFlag("IF_NOT_EXISTS"))return;throw new Error(`${g.KIND} ${g.argument()?.name()||g.$KIND} already exists`)}let J=g.argument().jsonfy(s);if(s.diff!==!1&&(J={...J,status:"new"}),g.KIND==="CONSTRAINT"&&g.argument().$columns().length===1){let[R,Ct]=o("COLUMN",g.argument().$columns()[0],!1)||[];if(R){let sr=(Ct||G.fromJSON(this.clone(),R.jsonfy(s))).constraint(J).jsonfy(s);i.set(R,sr)}else n.get(A).unshift(J)}else n.get(A).unshift(J)},u=g=>{let[A,L]=o([g.KIND,g.$KIND],g.reference().name(),!g.hasFlag("IF_EXISTS"),s.diff!==!1);A&&i.set(A,s.diff===!1?void 0:{...(L||A).jsonfy(s),status:"obsolete"})},c=g=>{},h=g=>{let[A,L]=o([g.KIND,g.$KIND],g.reference().name()),J=this.diffMergeJsons((L||A).jsonfy(s),g.argument().jsonfy(s),s);i.set(A,J)},d=g=>{let[A,L]=o(g.KIND,g.reference().name()),J=(L||A).renderCDL(g.argument(),s);i.set(A,J)},m=g=>{let A=R=>{if(!i.get(R))return;let Ct=R.constructor.fromJSON(R.contextNode.clone(),i.get(R));for(let Y of R.constraints())i.has(Y)&&(i.get(Y)?Ct.constraint(i.get(Y)):Ct.constraint(Y.TYPE,!1));return Ct.jsonfy({tableCDL:t,...e})},L=R=>!e.rootCDL||!i.get(R)?i.get(R):R.constructor.fromJSON(R.contextNode.clone(),i.get(R)).jsonfy({tableCDL:t,...e}),J;return i.has(g)?J=g instanceof G?A(g):L(g):g instanceof G?J=g.jsonfy(s,{},R=>i.has(R)?L(R):R.jsonfy({tableCDL:t,...e})):J=g.jsonfy({tableCDL:t,...e}),J},l=(g,A)=>g.reduce((J,R)=>J.concat(m(R)||[],n.get(R)||[]),n.get(`${A}:FIRST`)||[]).concat((n.get(`${A}:LAST`)||[]).reverse()),p=super.jsonfy(s),_=g=>(g.prefix||(g={...g,prefix:this.prefix(!0).jsonfy(s)}),g);for(let g of t)if(["ADD","MODIFY","CHANGE"].includes(g.CLAUSE))a(g);else if(g.CLAUSE==="DROP")u(g);else if(g.CLAUSE==="SET")if(g.KIND==="SCHEMA"){let A=g.argument().jsonfy(s);p=this.diffMergeJsons(_(p),{prefix:A},s)}else c(g);else if(g.CLAUSE==="RENAME")if(g.KIND)h(g);else{let A=g.argument().jsonfy(s);p=this.diffMergeJsons(_(p),A,s)}else if(g.CLAUSE==="ALTER")d(g);else throw new Error(`Unsupported operation: ${g.CLAUSE} ${g.KIND}`);let S=l(this.#t,"COLUMN"),y=l(this.#e,"CONSTRAINT"),C=l(this.#r,"INDEX");return{...p,columns:S,constraints:y,indexes:C}}generateCDL(t={}){let e=ne.fromJSON(this,{actions:[]}),r=this.dirtyCheck();r.includes("name")&&e.add("RENAME",null,s=>s.argument(this.$name())),r.includes("prefix")&&e.add("SET","SCHEMA",s=>s.argument(this.$prefix().jsonfy()));for(let s of this.#s){let i=s instanceof k?"CONSTRAINT":s instanceof ft?"INDEX":"COLUMN",n=i!=="COLUMN"&&s.TYPE,o=Ee(s.dirtyCheck(),s.CDLIgnoreList());if(s.status()==="new")e.add("ADD",i,n,a=>{a.argument(s.jsonfy({withColumns:i!=="COLUMN",diff:!1})),i==="COLUMN"&&t.existsChecks&&a.withFlag("IF_NOT_EXISTS")});else if(s.status()==="obsolete")e.add("DROP",i,n,a=>{a.reference(s.name()),t.cascadeRule&&a.withFlag(t.cascadeRule),t.existsChecks&&a.withFlag("IF_EXISTS")});else{let a=s.generateCDL();i==="COLUMN"&&this.params.dialect==="mysql"&&!(a.length===1&&a.actions()[0].KIND==="DEFAULT")?e.add("MODIFY","COLUMN",u=>u.argument(s.jsonfy(t,{},c=>c.constraintLevel===1?c:!1))):a.length?e.add("ALTER",i,n,u=>{u.reference(s.name()),u.argument(a)}):i!=="COLUMN"&&(o.length>1||o.length===1&&o[0]!=="name")&&(e.add("DROP",i,n,u=>u.reference(s.name())),e.add("ADD",i,n,u=>u.argument(s.jsonfy({withColumns:!0}))),o=o.filter(u=>u!=="name"))}o.includes("name")&&e.add("RENAME",i,n,a=>{a.reference(s.name()),a.argument(s.$name())})}return e}generateDiff(t,e){let r=super.generateDiff(t,e),s=new Map,[i,n]=[new Map,new Map];for(let[c,h,d]of[[this,i,t],[t,n,this]])for(let m of c.constraints(!0,!1)){let l;if(!d.constraint(m.name())&&m.columns().length===1&&(l=c.column(m.columns()[0]))){let p=s.get(l)||l.clone();p.constraint(m.jsonfy(e)),s.set(l,p)}else h.set(m.name().toLowerCase(),m)}let o=this.diffMergeTrees(this.#t,t.columns(),(c,h)=>(s.get(c)||c).generateDiff(s.get(h)||h,e),e),a=this.diffMergeTrees(i,n,(c,h)=>c.generateDiff(h,e),e),u=this.diffMergeTrees(this.#r,t.indexes(),(c,h)=>c.generateDiff(h,e),e);return{...r,columns:o,constraints:a,indexes:u}}static fromJSON(t,e,r=null){if(!(!Array.isArray(e?.columns)||["constraints","indexes"].some(s=>s in e&&!Array.isArray(e[s]))))return super.fromJSON(t,e,s=>{for(let i of e.columns)s.column(i);for(let i of e.constraints||[])s.constraint(i);for(let i of e.indexes||[])s.index(i);r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,{columns:this.#t.map(r=>r.jsonfy(t)),constraints:this.#e.map(r=>r.jsonfy(t)).filter(r=>r),indexes:this.#r.map(r=>r.jsonfy(t)).filter(r=>r),...e})}static parse(t,e,r){let[s,i,...n]=E.split(e,[],{limit:2});if(!s||!$t(i||"","(",")"))return;let o=new this(t),[a,u]=this.parseIdent(o,s.trim()).reverse();o.name(a),u&&o.prefix(u);let c=E.split(V(i,"(",")"),[","]).map(h=>r(o,h.trim(),[...this.CONSTRAINT_TYPES,ft,G]));for(let h of c)h instanceof G?o.column(h):h instanceof ft?o.index(h):o.constraint(h);return o}stringify(){let t=[this.#t.map(s=>s.stringify()).join(`,
	`)],e=this.#e.slice(0),r=this.#r.slice(0);return this.params.dialect==="mysql"&&e.push(...this.#t.reduce((s,i)=>{let n=i.foreignKey();return n?s.concat(Dt.fromJSON(this.clone(),{...n.jsonfy(),columns:[i.name()]})):s},[])),e.length&&t.push(e.map(s=>s.stringify()).join(`,
	`)),r.length&&t.push(r.map(s=>s.stringify()).join(`,
	`)),`${O.fromJSON(this,[this.$prefix(!0),this.$name()])} (
	${t.join(`,
	`)}
)`}};var Q=class extends at{#t;#e=[];[Symbol.iterator](){return this.#e[Symbol.iterator]()}get length(){return this.#e.length}$capture(t,e){return["DATABASE_SCHEMA"].includes(t)?this:super.$capture(t,e)}version(){return this.#t}table(t,...e){if(typeof t=="string"){let r=this.#e.find(s=>s.identifiesAs(t));if(!e.length)return r;if(e[0]===!1)return this.#e=this.#e.filter(s=>s!==r),r?.bubble("DISCONNECTED"),this;t={name:t,...typeof e[0]=="object"?e[0]:{columns:e[0]}}}return this.#e=this.$castInputs([t],wt,this.#e,"tables",null,r=>this.#e.find(s=>s.identifiesAs(r.name()))),this}tables(t=!0){return t?this.#e:this.#e.reduce((e,r)=>e.concat(r.name()),[])}columns(t=!0){return this.#e.reduce((e,r)=>e.concat(t?r.columns():r.columns(!1).map(s=>[r.name(),s])),[])}primaryKeys(t=!0,e=!0){return this.#e.reduce((r,s)=>r.concat(t?s.primaryKey(!0,e):[[s.name(),s.primaryKeys(!1,e)]]),[])}foreignKeys(t=!0,e=!0){return this.#e.reduce((r,s)=>r.concat(t?s.foreignKeys(!0,e):s.foreignKeys(!1,e).map(i=>[s.name(),i])),[])}uniqueKeys(t=!0,e=!0){return this.#e.reduce((r,s)=>r.concat(t?s.uniqueKeys(!0,e):s.uniqueKeys(!1,e).map(i=>[s.name(),i])),[])}checks(t=!0,e=!0){return this.#e.reduce((r,s)=>r.concat(t?s.checks(!0,e):s.checks(!1,e).map(i=>[s.name(),i])),[])}dirtyCheck(t=!1){let e=super.dirtyCheck(t);return t?e.concat(["tables"].filter(r=>this[r]().some(s=>s.dirtyCheck(t).length))):e}renderCDL(t,e){let{rootCDL:r,...s}=e,i=new Set,n=new Map,o=[],a=(y,C=!0,g=!0)=>{let A=this.table(y);if((!A||n.has(A)&&!n.get(A))&&C)throw new Error(`Table "${this.name()}"."${y}" does not exist.`);return g&&n.has(A)?[A,A.constructor.fromJSON(A.contextNode.clone(),n.get(A))]:[A]},u=y=>{let C={...s,rootCDL:!i.has(y)&&r};return i.has(y)||i.add(y),C},c=y=>{if(a(y.argument().name(),!1,!1)[0]){if(y.hasFlag("IF_NOT_EXISTS"))return;throw new Error(`Table "${y.argument()?.name()}" already exists`)}let C=y.argument().jsonfy(s);s.diff&&(C={...C,status:"new"}),o.push(C)},h=y=>{let[C,g]=a(y.reference().name(),!y.hasFlag("IF_EXISTS"),!!s.diff);C&&n.set(C,s.diff?{...(g||C).jsonfy(s),status:"obsolete"}:void 0)},d=y=>{},m=y=>{let[C,g]=a(y.reference().name()),A=this.diffMergeJsons((g||C).jsonfy(u(C)),y.argument().jsonfy(s),s);n.set(C,A)},l=y=>{let[C,g]=a(y.reference().name()),A=(g||C).renderCDL(y.argument(),u(C));n.set(C,A)},p=y=>{let C,g=u(y);if(n.has(y)){if(!n.get(y))return;g.rootCDL?C=y.constructor.fromJSON(this.clone(),n.get(y)).jsonfy(g):C=n.get(y)}else C=y.jsonfy(g);return C},_=y=>y.reduce((C,g)=>C.concat(p(g)||[]),[]).concat(o),S=super.jsonfy(s);for(let y of t)if(y.CLAUSE==="CREATE")c(y);else if(y.CLAUSE==="DROP")h(y);else if(y.CLAUSE==="SET")d(y);else if(y.CLAUSE==="RENAME")if(y.KIND)m(y);else{let C=y.argument().jsonfy(s);S=this.diffMergeJsons(S,C,s)}else if(y.CLAUSE==="ALTER")l(y);else throw new Error(`Unsupported operation: ${y.CLAUSE} ${y.KIND}`);return{...S,tables:_(this.#e)}}generateCDL(t={},e="TABLE"){let r=oe.fromJSON(this,{actions:[]});this.dirtyCheck().includes("name")&&r.add("RENAME",null,i=>i.argument(this.$name()));for(let i of this.#e)if(i.status()==="new")r.add("CREATE",e,n=>{n.argument({prefix:this.name(),...i.jsonfy({...t,diff:!1})}),t.existsChecks&&n.withFlag("IF_NOT_EXISTS")});else if(i.status()==="obsolete")r.add("DROP",e,n=>{n.reference([this.name(),i.name()]),t.cascadeRule&&n.withFlag(t.cascadeRule),t.existsChecks&&n.withFlag("IF_EXISTS")});else{let n=i.generateCDL(t);n.length&&r.add("ALTER",e,o=>{o.reference([this.name(),i.name()]),o.argument(n)})}return r}generateDiff(t,e){let r=super.generateDiff(t,e),s=this.diffMergeTrees(this.#e,t.tables(),(i,n)=>i.generateDiff(n,e),e);return{...r,tables:s}}findPrefix(t){return this.tables().find(e=>e.column(t))?.name()}static fromJSON(t,e,r=null){if(!("tables"in(e||{})&&!Array.isArray(e.tables)))return super.fromJSON(t,e,s=>{for(let i of e.tables||[])s.table(i);typeof e.version=="number"&&(s.#t=e.version),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,{...typeof this.#t=="number"?{version:this.#t}:{},tables:this.#e.map(r=>r.jsonfy(t)),...e})}static parse(t,e,r){let[s]=this.parseIdent(t,e);if(s)return new this(t).name(s)}stringify(){return this.stringifyIdent(this.$name())}};var Nt=class extends T{static get OPERATORS(){return[]}static get LHS_TYPES(){return[]}static get RHS_TYPES(){return[]}#t;#e;#r;operator(t){if(!arguments.length)return this.#t;if(!us(this.constructor.OPERATORS,t))throw new Error(`Invalid operator: ${t}`);return this.#t=t,this}operands(t,e){if(!arguments.length)return[this.#e,this.#r];let r=this.constructor.OPERATORS[0];return this.lhs(t).rhs(e).operator(N(r)?r.operator:r)}lhs(t){return arguments.length?(this.#e=this.$castInputs([t],this.constructor.LHS_TYPES,this.#e,"lhs_expr"),this):this.#e}rhs(t){return arguments.length?(this.#r=this.$castInputs([t],this.constructor.RHS_TYPES,this.#r,"rhs_expr"),this):this.#r}static fromJSON(t,e,r=null){if(!(!e?.operator||!us(this.OPERATORS,e.operator)||!e.lhs||"rhs"in e&&!e.rhs))return super.fromJSON(t,e,s=>{s.operator(e.operator).lhs(e.lhs),e.rhs&&s.rhs(e.rhs),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,{operator:this.#t,lhs:this.#e?.jsonfy(t),...this.#r?{rhs:this.#r.jsonfy(t)}:{},...e})}stringify(){return[this.#e,this.#t].concat(this.#r||[]).join(" ")}},us=(f,t)=>f.some(e=>N(e)?t===e.operator||new RegExp(e.test).test(` ${t} `):t===e);var ae=class extends Nt{static get LHS_TYPES(){return x}static get RHS_TYPES(){return x}static get OPERATORS(){return[{test:"<(?!~)"},{test:"(?<![~\\->#])>",backtest:"^(?!.*[~\\->#]$)"},{test:"(?<!<)(?:\\!)?~(?:\\*)?(?!>)",backtest:"^(?!.*<$)"},{test:"((?:(?:\\s+)?(=|<=|>=|!=|<>)(?:\\s+)?)|(?:\\s+IS\\s+(?:NOT\\s+)?(TRUE|FALSE|NULL|UNKNOWN|DISTINCT\\s+FROM\\s+))|(?:\\s+(?:ANY|ALL|(?:NOT\\s+)?(?:IN|LIKE|EXISTS|SIMILAR\\s+TO|BETWEEN(?:\\s+SYMMETRIC)?))\\s+))"}]}static get expose(){return{"equals|eq":(t,e,r)=>this.fromJSON(t,{operator:"=",lhs:e,rhs:r}),"notEqual|notEq":(t,e,r)=>this.fromJSON(t,{operator:"<>",lhs:e,rhs:r}),"lesserThan|lt":(t,e,r)=>this.fromJSON(t,{operator:"<",lhs:e,rhs:r}),"lessThanOrEqual|ltOrEq":(t,e,r)=>this.fromJSON(t,{operator:"<=",lhs:e,rhs:r}),"greaterThan|gt":(t,e,r)=>this.fromJSON(t,{operator:">",lhs:e,rhs:r}),"greaterThanOrEqual|gtOrEq":(t,e,r)=>this.fromJSON(t,{operator:">=",lhs:e,rhs:r}),any:(t,e,...r)=>this.fromJSON(t,{operator:"ANY",lhs:e,rhs:{row:r}}),all:(t,e,...r)=>this.fromJSON(t,{operator:"ALL",lhs:e,rhs:{row:r}}),in:(t,e,...r)=>this.fromJSON(t,{operator:"IN",lhs:e,rhs:{row:r}}),notIn:(t,e,...r)=>this.fromJSON(t,{operator:"NOT IN",lhs:e,rhs:{row:r}}),exists:(t,e,r)=>this.fromJSON(t,{operator:"EXISTS",lhs:e,rhs:r}),notExists:(t,e,r)=>this.fromJSON(t,{operator:"NOT EXISTS",lhs:e,rhs:r}),like:(t,e,r)=>this.fromJSON(t,{operator:"LIKE",lhs:e,rhs:r}),notLike:(t,e,r)=>this.fromJSON(t,{operator:"NOT LIKE",lhs:e,rhs:r}),similarTo:(t,e,r)=>this.fromJSON(t,{operator:"SIMILAR TO",lhs:e,rhs:r}),notSimilarTo:(t,e,r)=>this.fromJSON(t,{operator:"NOT SIMILAR TO",lhs:e,rhs:r}),matches:(t,e,r)=>this.fromJSON(t,{operator:"~",lhs:e,rhs:r}),matchesi:(t,e,r)=>this.fromJSON(t,{operator:"~*",lhs:e,rhs:r}),notMatches:(t,e,r)=>this.fromJSON(t,{operator:"!~",lhs:e,rhs:r}),notMatchesi:(t,e,r)=>this.fromJSON(t,{operator:"!~*",lhs:e,rhs:r}),between:(t,e,r)=>this.fromJSON(t,{operator:"BETWEEN",lhs:e,rhs:r}),notBetween:(t,e,r)=>this.fromJSON(t,{operator:"NOT BETWEEN",lhs:e,rhs:r}),betweenSymmetric:(t,e,r)=>this.fromJSON(t,{operator:"BETWEEN SYMMETRIC",lhs:e,rhs:r}),notBetweenSymmetric:(t,e,r)=>this.fromJSON(t,{operator:"NOT BETWEEN SYMMETRIC",lhs:e,rhs:r}),isNull:(t,e)=>this.fromJSON(t,{operator:"IS NULL",lhs:e}),isNotNull:(t,e)=>this.fromJSON(t,{operator:"IS NOT NULL",lhs:e}),isTrue:(t,e)=>this.fromJSON(t,{operator:"IS TRUE",lhs:e}),isNotTrue:(t,e)=>this.fromJSON(t,{operator:"IS NOT TRUE",lhs:e}),isFalse:(t,e)=>this.fromJSON(t,{operator:"IS FALSE",lhs:e}),isNotFalse:(t,e)=>this.fromJSON(t,{operator:"IS NOT FALSE",lhs:e}),isUnknow:(t,e)=>this.fromJSON(t,{operator:"IS UNKNOWN",lhs:e}),isNotUnknow:(t,e)=>this.fromJSON(t,{operator:"IS NOT UNKNOWN",lhs:e}),isDistinctFrom:(t,e,r)=>this.fromJSON(t,{operator:"IS DISTINCT FROM",lhs:e,rhs:r}),isNotDistinctFrom:(t,e,r)=>this.fromJSON(t,{operator:"IS NOT DISTINCT FROM",lhs:e,rhs:r})}}static parse(t,e,r){let{tokens:[s,i=""],matches:[n]}=E.lex(e,this.OPERATORS,{useRegex:"i"});if(!n)return;let o=new this(t).operator(n.trim().replace(/\s+/," ").toUpperCase());return o.lhs(r(o,s.trim())),i.trim()&&o.rhs(r(o,i.trim())),o}};var xr=class extends T{#t;#e;expr(t){return arguments.length?(this.#t=this.$castInputs([t],x,this.#t,"order_by_expr"),this):this.#t}direction(t){if(!arguments.length)return this.#e;if(!["ASC","DESC"].includes(t=t.toUpperCase()))throw new Error(`Invalid sort direction: ${t}`);return this.#e=t,this}desc(){return this.direction("DESC")}asc(){return this.direction("ASC")}identifiesAs(t){return this.#t?.identifiesAs(t)||super.identifiesAs(t)}static fromJSON(t,e,r=null){if(!Object.keys(e||{}).filter(s=>!["nodeName","expr","direction"].includes(s)).length)return super.fromJSON(t,e,s=>{e.expr&&s.expr(e.expr),e.direction&&s.direction(e.direction),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,{expr:this.#t?.jsonfy(t),...this.#e?{direction:this.#e}:{},...e})}static parse(t,e,r){let[,s,i]=e.match(new RegExp("^([\\s\\S]+?)(?:\\s+(ASC|DESC))?$","i"))||[],n=new this(t);return n.expr(r(n,s,x)),i&&n.direction(i.toUpperCase()),n}stringify(){return[this.#t.stringify(),this.#e].filter(t=>t).join(" ")}};var W=class extends I{static get EXPECTED_TYPES(){return[xr]}static get REGEX(){return"ORDER\\s+BY"}withRollup(){return this.withFlag("WITH_ROLLUP")}static parse(t,e,r){let[s,i,n]=e.match(new RegExp(`^${this.REGEX}([\\s\\S]*)(\\s+WITH\\s+ROLLUP)?$`,"i"))||[];if(!s)return;let o=super.parse(t,i,r);if(o)return n&&o.withFlag("WITH_ROLLUP"),o}stringify(){return this.entries().length?["ORDER BY",super.stringify()].concat(this.hasFlag("WITH_ROLLUP")?"WITH ROLLUP":[]).join(" "):""}};var st=class extends T{static get CLAUSE(){return"LIMIT"}#t;expr(t){return arguments.length?(this.#t=this.$castInputs([t],x,this.#t,"limit_expr"),this):this.#t}static fromJSON(t,e,r=null){if(!Object.keys(e||{}).filter(s=>!["nodeName","expr"].includes(s)).length)return super.fromJSON(t,e,s=>{e.expr&&s.expr(e.expr),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,{expr:this.#t?.jsonfy(t),...e})}static parse(t,e,r){let[s,i]=e.match(new RegExp(`^${this.CLAUSE}([\\s\\S]*)$`,"i"))||[];if(!s)return;let n=new this(t);return n.expr(r(n,i.trim(),x)),n}stringify(){return`${this.constructor.CLAUSE} ${this.#t}`}};var Ht=class extends I{static get EXPECTED_TYPES(){return x}static get OPERATORS(){return[]}#t;operator(t){if(!arguments.length)return this.#t;if(!this.constructor.OPERATORS.includes(t))throw new Error(`Unknown operator: ${t}.`);return this.#t=t,this}static fromJSON(t,e,r=null){if(this.OPERATORS.includes(e?.operator))return super.fromJSON(t,e,s=>{s.operator(e.operator),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,{operator:this.#t,...e})}static parse(t,e,r){if(this.CLAUSE){let[s,i]=e.match(new RegExp(`^${this.CLAUSE}([\\s\\S]*)$`,"i"))||[];if(!s)return;e=i}for(let s of this.OPERATORS){let i=E.split(e,[/^\w+$/.test(s)?`\\s+${s}\\s+`:s.split("").map(o=>`\\${o}`).join("")],{useRegex:"i"}).filter(o=>o.trim());if(i.length<(this.minEntries||2))continue;let n=new this(t).operator(s);return n.add(...i.map(o=>r(n,o.trim())))}}stringify(){let t=this.entries().join(` ${this.#t} `);if(this.constructor.CLAUSE){if(!this.entries().length)return"";t=`${this.constructor.CLAUSE} ${t}`}else this.contextNode instanceof this.constructor&&(t=`(${t})`);return t}};var _t=class extends Ht{static get OPERATORS(){return["AND","OR"]}static get CLAUSE(){}every(...t){return this.operator("AND").add(...t)}some(...t){return this.operator("OR").add(...t)}static get expose(){return{every:(t,...e)=>e.length>1&&this.fromJSON(t,{operator:"AND",entries:e}),some:(t,...e)=>this.fromJSON(t,{operator:"OR",entries:e})}}};var z=class extends _t{static get CLAUSE(){return"WHERE"}static get minEntries(){return 1}};var M=class extends vt{static get EXPECTED_TYPES(){return[O,Ue]}};var Ve=class extends _t{static get CLAUSE(){return"ON"}static get minEntries(){return 1}};var ut=class extends M{static get REGEX(){return"(INNER\\s+|CROSS\\s+|(?:LEFT|RIGHT|FULL)(?:\\s+OUTER)?\\s+)?JOIN(?!\\w)"}#t;#e;#r;type(t){return arguments.length?(this.#t=t,this):this.#t}expr(...t){return t.length>1?super.expr(t):super.expr(...t)}on(...t){return arguments.length?(this.#r=this.$castInputs(t,Ve,this.#r,"on_clause","every"),this):this.#r}using(t){return arguments.length?(this.#e=this.$castInputs([t],w,this.#e,"using_clause"),this):this.#e}static fromJSON(t,e,r=null){if(!(!e?.type||Object.keys(e).filter(s=>!["nodeName","type","expr","alias","usingClause","onClause","claused"].includes(s)).length))return super.fromJSON(t,e,s=>{s.type(e.type),e.usingClause&&s.using(e.usingClause),e.onClause&&s.on(e.onClause),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,{type:this.#t,...this.#e?{usingClause:this.#e.jsonfy(t)}:{},...this.#r?{onClause:this.#r.jsonfy(t)}:{},...e})}static parse(t,e,r){let[s,i,n]=e.match(new RegExp(`^${this.REGEX}([\\s\\S]*)$`,"i"))||[];if(!s)return;let[o,a]=E.split(n,["\\s+(?:ON|USING)\\s+"],{useRegex:"i",preserveDelims:!0}).map(c=>c.trim()),u=super.parse(t,o,r);return u.type(i.trim().toUpperCase()+"_JOIN"),/^USING/i.test(a)?u.using(r(u,a.replace(/^USING\s+/i,""),[w])):/^ON/i.test(a)&&u.on(r(u,a,[Ve])),u}stringify(){return[this.#t?.replace(/_/," ").toUpperCase()||"JOIN",super.stringify(),this.#e?`USING ${this.#e}`:`${this.#r}`].filter(t=>t).join(" ")}};var Me=class extends rt(Nt){get isPath(){return!0}plot(t=!1){let e=this.schema(),r,s;if(this.lhs()instanceof It){let n=this.lhs().endpoint(),o=n.schema().foreignKey();if(!o)throw new Error(`[${this}]: Column ${n.clone({fullyQualified:!0})} is not a foreign key.`);let a=o.targetTable(),u=this.capture("DATABASE_SCHEMA");for(let h of u.columns())if(h.primaryKey()&&h.prefix(!0).identifiesAs(a)){let d=b.fromJSON(this,[h.contextNode.name(),h.name()]);if(r)throw new Error(`[${this}]: Target primary key for foreign key ${n.clone({fullyQualified:!0})} is ambiguous. (Is it ${r} or ${d}?)`);r=d}if(!r)throw new Error(`Path ${this} could not be resolved against base query.`);let c=this.lhs().lhs();s=c instanceof Je?c.clone({reverse:!0}):c.clone({fullyQualified:t})}else r=this.lhs().clone({fullyQualified:t}),s=b.fromJSON(this,[e.name(),e.primaryKey().columns()[0]]);let i=O.fromJSON(this,[e.prefix(!0).name(),e.name()]);return[r,i,s]}jsonfy(t={},e={}){return!t.deSugar||!this.statementNode?super.jsonfy(t,e):this.statementNode.resolvePath(this,t)}};var Je=class f extends Me{static get OPERATORS(){return["<~"]}static get LHS_TYPES(){return[f,b]}static get RHS_TYPES(){return[b]}static get DESUGARS_TO(){return[F]}$capture(t,e){if(t==="TABLE_SCHEMA"){if(e===this.lhs())return this.schema();if(e===this.rhs()&&this.contextNode instanceof f)return this.contextNode.schema()}return super.$capture(t,e)}static get expose(){return{path:(t,e,r,s)=>this.fromJSON(t,{lhs:e,operator:r,rhs:s}),lpath:(t,e,r)=>this.fromJSON(t,{lhs:e,operator:"<~",rhs:r})}}schema(){let t=this.rhs().schema().foreignKey();if(!t)throw new Error(`[${this}]: Column ${this.rhs().clone({fullyQualified:!0})} is not a foreign key.`);return t.targetTable().schema()}endpoint(){return this.lhs()instanceof f?this.lhs().endpoint():this.lhs()}jsonfy(t={},e={}){return t.reverse?{nodeName:F.NODE_NAME,lhs:this.rhs()?.jsonfy(t),rhs:this.lhs()?.jsonfy(t),operator:"~>"}:super.jsonfy(t,e)}static parse(t,e,r){let s=E.split(e,this.OPERATORS,{useRegex:!0});if(s.length<2)return;let i=this.OPERATORS[0],n=new this(t).operator(i);return n.rhs(r(n,s.pop().trim(),this.RHS_TYPES)),n.lhs(r(n,s.join(i).trim(),this.LHS_TYPES))}};var It=class extends Je{static get RHS_TYPES(){return[O]}$capture(t,e){return t==="TABLE_SCHEMA"?this.rhs().schema():super.$capture(t,e)}schema(){return this.rhs().schema()}};var $r=class extends vt{static get EXPECTED_TYPES(){return x}static get requireAliasForNoneIdents(){return!0}};var it=class extends T{#t="";#e="'";value(t){if(!arguments.length)return this.#t;if(typeof t!="string")throw new Error(`Invalid argument as string: ${t}`);return this.#t=t,this}quote(t=this.#e){if(!arguments.length)return this.#e;if(!['"',"'"].includes(t))throw new Error(`Invalid argument as quote: ${t}`);return this.#e=t,this}identifiesAs(t){return typeof t=="string"?this.$eq(this.#t,t,"ci"):super.identifiesAs(t)}static get expose(){return{"string|str":(t,e,r)=>this.fromJSON(t,{value:e,quote:r}),value:(t,e)=>typeof e=="string"&&this.fromJSON(t,{value:e})}}static fromJSON(t,e,r=null){if(typeof e=="string"&&!e.trim()&&(e={value:e}),!(typeof e?.value!="string"||Object.keys(e).filter(s=>!["nodeName","value","quote"].includes(s)).length||e.quote&&!['"',"'"].includes(e.quote)))return super.fromJSON(t,e,s=>{s.value(e.value).quote(e.quote),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,{quote:this.#e,value:this.#t,...e})}static parse(t,e){let[r,s]=this.parseString(t,e,!0)||[];if(s)return new this(t).value(r).quote(s)}stringify(){return this.stringifyString(this.#t,!0)}};var nt=class extends T{#t;#e=[];name(t){if(!arguments.length)return this.#t;if(typeof t!="string")throw new TypeError("Invalid argument as function name.");return this.#t=t,this}args(...t){return arguments.length?(this.#e=this.$castInputs(t,x,this.#e,"function_args"),this):this.#e}identifiesAs(t){return t===this.#t||super.identifiesAs(t)}static get expose(){return{now:(t,...e)=>this.fromJSON(t,{name:"NOW",args:e}),concat:(t,...e)=>this.fromJSON(t,{name:"CONCAT",args:e}),count:(t,...e)=>this.fromJSON(t,{name:"COUNT",args:e}),fn:(t,e,...r)=>this.fromJSON(t,{name:e,args:r})}}static fromJSON(t,e,r=null){if(!(typeof e?.name!="string"||!Array.isArray(e.args)))return super.fromJSON(t,e,s=>{s.name(e.name);for(let i of e.args)s.args(i);r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,{name:this.#t,args:this.#e.map(r=>r.jsonfy(t)),...e})}static parse(t,e,r){let[,s,i=""]=/^(\w+)(?:\s+)?\(([\s\S]+)?\)$/i.exec(e)||[];if(!s||E.match(e.replace(s,"").trim(),[" "]).length)return;let n=new this(t).name(s),o=E.split(i,[","]).map(a=>r(n,a.trim()));for(let a of o)n.args(a);return n}stringify(){return`${this.#t.toUpperCase()}(${this.#e.join(", ")})`}};var qt=class extends rt(I){static get EXPECTED_TYPES(){return[$r]}static get TAGS(){return["{","}"]}static get DESUGARS_TO(){return[nt]}static get expose(){return{fields:(t,...e)=>this.fromJSON(t,{entries:e})}}jsonfy(t={},e={},r=null){return t.deSugar?{nodeName:nt.NODE_NAME,name:this.params.dialect==="mysql"?"JSON_OBJECT":"JSON_BUILD_OBJECT",args:this.entries().reduce((s,i)=>{let n={nodeName:it.NODE_NAME,value:i.alias(!0)},o=i.expr().jsonfy(t);return s.concat(n,o)},[])}:super.jsonfy(t,e,r)}};var Gt=class extends rt(I){static get EXPECTED_TYPES(){return x}static get TAGS(){return["[","]"]}static get DESUGARS_TO(){return[nt]}static get expose(){return{items:(t,...e)=>this.fromJSON(t,{entries:e})}}jsonfy(t={},e={},r=null){return t.deSugar?{nodeName:nt.NODE_NAME,name:this.params.dialect==="mysql"?"JSON_ARRAY":"JSON_BUILD_ARRAY",args:this.entries().map(s=>s.jsonfy(t)),originalSugar:this.stringify()}:super.jsonfy(t,e,r)}};var P=class extends I{static get EXPECTED_TYPES(){return[F,b]}static get TAGS(){return["(",")"]}static get expose(){return{columns:(t,...e)=>this.fromJSON(t,{entries:e})}}};var B=class extends I{static get EXPECTED_TYPES(){return x}static get MIN_ENTRIES(){return 2}static get TAGS(){return["(",")"]}static get expose(){return{row:(t,...e)=>this.fromJSON(t,{entries:e})}}};var Qe=class extends I{static get EXPECTED_TYPES(){return x}static get REGEX(){return"PARTITION\\s+BY"}static parse(t,e,r){let[s,i]=e.match(new RegExp(`^${this.REGEX}([\\s\\S]*)$`,"i"))||[];if(s)return super.parse(t,i,r)}stringify(){return this.entries().length?["PARTITION BY",super.stringify()].join(" "):""}};var fe=class extends T{#t;#e;#r;#s;name(t){return arguments.length?(this.#t=t,this):this.#t}existing(t){return arguments.length?(this.#e=t,this):this.#e}extends(t){return this.existing(...arguments)}partitionBy(...t){if(!arguments.length)return this.#r;if(this.#e)throw new Error("The PARTITION BY clause is not allowed when inheriting from a base window.");return this.#r=this.$castInputs(t,Qe,this.#r,"partition_by_clause","add"),this}orderBy(...t){return arguments.length?(this.#s=this.$castInputs(t,W,this.#s,"order_by_clause","add"),this):this.#s}static fromJSON(t,e,r=null){if(typeof e=="string")e={windowRef:e};else if(!(typeof e=="object"&&e)||!["name","windowRef","partitionByClause","orderByClause"].some(s=>s in e))return;if(!Object.keys(e||{}).filter(s=>!["nodeName","name","windowRef","partitionByClause","orderByClause"].includes(s)).length)return super.fromJSON(t,e,s=>{e.name&&s.name(e.name),e.windowRef&&s.extends(e.windowRef),e.partitionByClause&&s.partitionBy(e.partitionByClause),e.orderByClause&&s.orderBy(e.orderByClause),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,{...this.#t||!this.#e?{name:this.#t}:{},...this.#e||!this.#t?{windowRef:this.#e}:{},...this.#r?{partitionByClause:this.#r.jsonfy(t)}:{},...this.#s?{orderByClause:this.#s.jsonfy(t)}:{},...e})}static parse(t,e,r){let s=new this(t),i=async a=>{let{tokens:[u,...c],matches:h}=E.lex(V(a.trim(),"(",")"),["PARTITION\\s+BY","ORDER\\s+BY"],{useRegex:"i",preserveDelims:!0});u.trim()&&s.extends(u.trim());for(let d of h){if(/PARTITION\s+BY/i.test(d)){s.partitionBy(r(s,c.shift().trim(),[Qe]));continue}s.orderBy(r(s,c.shift().trim(),[W]))}},n=e.endsWith(")");if(n&&!e.startsWith("(")){let[a,u]=E.split(e,[" AS "],{useRegex:"i"});s.name(a.trim()),i(u)}else n?i(e):s.existing(e);return s}stringify(){let t=[];return!this.#t&&this.#e&&!this.#r&&!this.#s?t.push(this.#e):(this.#t&&t.push(`${this.#t} AS `),t.push(`(${[this.#e,this.#r,this.#s].filter(e=>e).join(" ")})`)),t.join("")}};var ue=class extends nt{#t;#e;over(t){return arguments.length?(t||(t={name:""}),this.#t=this.$castInputs([t],fe,this.#t,"over_clause"),this):this.#t}orderBy(...t){return arguments.length?(this.#e=this.$castInputs(t,W,this.#e,"order_by_clause","add"),this):this.#e}static get expose(){return{fn:(t,e,...r)=>this.names.flat().includes(e?.toUpperCase())&&this.fromJSON(t,{name:e,args:r}),...Object.fromEntries(this.names.flat().map(t=>[ye(t.toLowerCase().replace(/_/g," ")),(e,...r)=>this.fromJSON(e,{name:t,args:r})]))}}static fromJSON(t,e,r=null){if(this.names.flat().includes(e?.name?.toUpperCase?.())&&!Object.keys(e||{}).filter(s=>!["nodeName","name","args","orderByClause","overClause","flags","prettyName"].includes(s)).length)return super.fromJSON(t,e,s=>{e.orderByClause&&s.orderBy(e.orderByClause),e.overClause&&s.over(e.overClause),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,{...this.#e?{orderByClause:this.#e.jsonfy(t)}:{},...this.#t?{overClause:this.#t.jsonfy(t)}:{},...e})}static parse(t,e,r){let[s,i]=E.split(e,["OVER\\s*"],{useRegex:"i"}).map(d=>d.trim()),[,n,o,a=""]=/^(\w+)\((?:\s+)?(?:(ALL|DISTINCT|FILTER)\s+)?([\s\S]+?)?\)$/i.exec(s)||[];if(!this.names.flat().includes(n?.toUpperCase()))return;let[,u,c]=/^([\s\S]+)(?:\s+(ORDER\s+BY\s+.+))$/i.exec(a)||[,a],h=super.parse(t,`${n}(${u})`,r);return o&&h.withFlag(o.toUpperCase()),c?h.orderBy(r(h,c,[W])):i&&h.over(r(h,i.trim(),[fe])),h}stringify(){return`${this.name().toUpperCase()}(${[...this.getFlag(),this.args().join(", "),this.#e].filter(e=>e).join(" ")})`+(this.#t?` OVER ${this.#t}`:"")}static names=[["AVG","BIT_AND","BIT_OR","BIT_XOR","COUNT","JSON_AGG","JSON_ARRAYAGG","JSON_OBJECTAGG","MAX","MIN","STDDEV_POP","STDDEV","STD","STDDEV_SAMP","SUM","VAR_POP","VARIANCE","VAR_SAMP","GROUP_CONCAT","GROUP_CONCAT_WS"],["CUME_DIST","DENSE_RANK","FIRST_VALUE","LAG","LAST_VALUE","LEAD","NTH_VALUE","NTLE","PERCENT_RANK","RANK","ROW_NUMBER"],["ANY_VALUE","COLUMN","COLUMNS","GROUPING"]]};var ct=class extends rt(T){static get DESUGARS_TO(){return[ue]}static get EXPECTED_TYPES(){return x.map(t=>t===B?P:t)}#t;expr(t){return arguments.length?(this.#t=this.$castInputs([t],this.constructor.EXPECTED_TYPES,this.#t,"json_aggr_expr"),this):this.#t}static fromJSON(t,e,r=null){if(e?.expr)return super.fromJSON(t,e,s=>{s.expr(e.expr),r?.(s)})}jsonfy(t={},e={}){return t.deSugar?{nodeName:ue.NODE_NAME,name:this.params.dialect==="mysql"?"JSON_ARRAYAGG":"JSON_AGG",args:[this.#t?.jsonfy(t)],prettyName:this.stringify()}:super.jsonfy(t,{expr:this.#t?.jsonfy(t),...e})}static parse(t,e,r){if((e=e.split(/(?=\[\s*\]$)/)).length!==2)return;let s=new this(t);return s.expr(r(s,e.shift().trim(),this.EXPECTED_TYPES))}stringify(){return`${this.#t}[]`}};var Fe=class extends T{#t;#e;#r=!1;value(t){return arguments.length?(this.#t=this.$castInputs([t],x,this.#t,"type_cast"),this):this.#t}type(t){return arguments.length?(this.#e=t,this):this.#e}compact(t=this.#r){return arguments.length?(this.#r=t,this):this.#r}static get expose(){return{cast:(t,e,r,s)=>this.fromJSON(t,{value:e,type:r,compact:s})}}static fromJSON(t,e,r=null){if(!(!e?.value||!e.type||Object.keys(e).filter(s=>!["nodeName","type","value","compact"].includes(s)).length))return super.fromJSON(t,e,s=>{s.value(e.value).type(e.type).compact(e.compact),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,{value:this.#t?.jsonfy(t),type:this.#e,compact:this.#r,...e})}static parse(t,e,r){let s,i,n=!1;if(/^CAST(?:\s+)?\([\s\S]+\)$/i.test(e)){let[,a]=E.split(e,[]);[s,i]=E.split(a.slice(1,-1),["AS"],{useRegex:"i"})}else{if((t?.params?.inputDialect||t?.params?.dialect)==="mysql"||([s,i]=E.split(e,["::"]),!i))return;n=!0}let o=new this(t).type(i.trim()).compact(n);return o.value(r(o,s.trim()))}stringify(){return this.#r&&this.params.dialect!=="mysql"?`${this.#t}::${this.#e}`:`CAST(${this.#t} AS ${this.#e})`}};var ce=class extends it{static get expose(){return{json:(t,e)=>this.fromJSON(t,{value:Array.isArray(e)||N(e)?JSON.stringify(e):e})}}static fromJSON(t,e,r=null){if(!(!N(e)||Object.keys(e).filter(s=>!["nodeName","value"].includes(s)).length)){try{typeof e?.value=="string"&&JSON.parse(e.value)}catch{return}return super.fromJSON(t,e,s=>{r?.(s)})}}static parse(t,e){let r=[["{","}"],["[","]"]],s={},[i,n]=this.parseString(t,e,!0)||[];if(n&&!(!(s.braces=r.find(o=>$t(e,o[0],o[1])))||E.match(e,[" "]).length)){try{JSON.parse(i)}catch{return}return new this(t,n).value(i)}}};var Ye=class extends T{#t;value(t){if(!arguments.length)return this.#t;if(typeof t!="number")throw new Error(`Cannot use ${typeof t} as number.`);return this.#t=t,this}identifiesAs(t){return t===this.#t||super.identifiesAs(t)}static get expose(){return{"num|int|float":(t,e)=>this.fromJSON(t,{value:parseFloat(e)}),value:(t,e)=>/^-?\d+(\.\d+)?$/.test(e)&&this.fromJSON(t,{value:parseFloat(e)})}}static fromJSON(t,e,r=null){if(typeof e=="number")e={value:e};else if(typeof e?.value!="number"||Object.keys(e).filter(s=>!["nodeName","value"].includes(s)).length)return;return super.fromJSON(t,e,s=>{s.value(e.value),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,{value:this.#t,...e})}static parse(t,e){if(/^-?\d+(\.\d+)?$/.test(e))return new this(t).value(parseFloat(e))}stringify(){return`${this.#t}`}};var ke=class extends Nt{static get OPERATORS(){return["->>","->","#>>","#>"]}static get LHS_TYPES(){return[ce,b]}static get RHS_TYPES(){return[Fe,ce,Ye,it]}static get expose(){return{path:(t,e,r,s)=>this.fromJSON(t,{lhs:e,operator:r,rhs:s})}}static parse(t,e,r){if((t?.params?.inputDialect||t?.params?.dialect)==="mysql")return;let{tokens:[s,i],matches:[n]}=E.lex(e,this.OPERATORS,{limit:1});if(!s||!n||!i)return;let o=new this(t).operator(n);return o.lhs(r(o,s.trim(),this.LHS_TYPES)),o.rhs(r(o,i.trim(),this.RHS_TYPES)),o}};var F=class f extends Me{static get OPERATORS(){return["~>",{test:":(?=\\s*[{([])",operator:":"}]}static get LHS_TYPES(){return[It,b]}static get RHS_TYPES(){return[this,ke,ct,qt,Gt,P,b]}static get DESUGARS_TO(){return this.LHS_TYPES}$capture(t,e){if(t==="TABLE_SCHEMA"){if(e===this.rhs())return this.schema();if(e===this.lhs()&&this.contextNode instanceof f)return this.contextNode.schema()}return super.$capture(t,e)}static get expose(){return{path:(t,e,r,s)=>this.fromJSON(t,{lhs:e,operator:r,rhs:s}),rpath:(t,e,r)=>this.fromJSON(t,{lhs:e,operator:"~>",rhs:r})}}schema(){if(this.lhs()instanceof It)return this.lhs().schema();let t=this.lhs().schema().foreignKey();if(!t)throw new Error(`[${this}]: Column ${this.lhs().clone({fullyQualified:!0})} is not a foreign key.`);return t.targetTable().schema()}endpoint(){return this.rhs()instanceof f?this.rhs().endpoint():this.rhs()}prettyName(){return this.clone({asProperty:!0}).stringify()}jsonfy(t={},e={}){return t.asProperty&&[qt,Gt,ct,P].some(r=>this.rhs()instanceof r)?this.lhs().jsonfy({...t,asProperty:!1},e):super.jsonfy(t)}static parse(t,e,r){let{tokens:[s,i],matches:[n]}=E.lex(e,this.OPERATORS,{limit:1,useRegex:!0});if(!s||!n||!i)return;let o=new this(t).operator(n);return o.lhs(r(o,s.trim(),this.LHS_TYPES)),o.rhs(r(o,i.trim(),this.RHS_TYPES)),o}stringify(){return[ct,qt,Gt,P].some(t=>this.rhs()instanceof t)?`${this.lhs()}: ${this.rhs()}`:super.stringify()}};var je=f=>class extends f{#t=[];#e;#r;#s;joins(...t){return arguments.length?(this.#t=this.$castInputs(t,ut,this.#t,"join_clause"),this):this.#t}join(t){return this.joins(t)}innerJoin(t){return this.join(t),this.#t[this.#t.length-1].type("INNER_JOIN"),this}crossJoin(t){return this.join(t),this.#t[this.#t.length-1].type("CROSS_JOIN"),this}leftJoin(t){return this.join(t),this.#t[this.#t.length-1].type("LEFT_JOIN"),this}rightJoin(t){return this.join(t),this.#t[this.#t.length-1].type("RIGHT_JOIN"),this}fullJoin(t){return this.join(t),this.#t[this.#t.length-1].type("FULL_JOIN"),this}where(...t){return arguments.length?(this.#e=this.$castInputs(t,z,this.#e,"where_clause","every"),this):this.#e}orderBy(...t){return arguments.length?(this.#r=this.$castInputs(t,W,this.#r,"order_by_clause","add"),this.#r):this.#r}limit(t){return arguments.length?(this.#s=this.$castInputs([t],st,this.#s,"limit_clause","value"),this):this.#s}schema({derivationLevel:t=!1}={}){let e=Q.fromJSON(this,{name:"",tables:[]}),r=[];if(t){let s=t==="SELECT_LIST_ONLY";for(let i of this.fields?.()||[]){if(i.expr().name?.()==="*"){s&&r.push(i.expr().prefix()?.name());continue}let n=i.schema();if(!n)continue;let o=n.contextNode.name();if(!e.table(o)){let a=n.contextNode.jsonfy();e.table({...a,columns:[]})}e.table(o).column(n.jsonfy())}if(s&&!r.length)return e}for(let s of[...this.tables(),...this.joins()].map(i=>i.schema())){let i=s.name();if(r.length&&!r.includes(i)&&!r.includes(void 0))continue;let n=s.jsonfy();if(e.table(i))for(let o of n.columns)e.table(i).column(o);else e.table(n)}return e}#n=new Map;$capture(t,e){if(t!=="TABLE_SCHEMA"){if(t==="DATABASE_SCHEMA"){let r=this.orderBy()?.contains(e)?1:0;return this.#n.has(r)||this.#n.set(r,this.schema({derivationLevel:r})),this.#n.get(r)}return super.$capture(t,e)}}#i=new Map;resolvePath(t,e){if(!(t instanceof F))throw new Error(`Can't desugar path: ${t}. Must be instance of PathRight.`);let[r,s,i]=t.plot(!0),n=`$relation::${[r,s,i].join(":")}${t.rhs()instanceof ct?"/g":""}`;if(!this.#i.has(n)){let u=`$key::${(0|Math.random()*9e6).toString(36)}`,c=new ut(this);c.type("LEFT_JOIN").expr(h=>h.select(d=>d.expr(i.jsonfy()).as(u)).from([s.prefix(),s.name()])).as(n).on(h=>h.equals([n,u],r.jsonfy())),t.rhs()instanceof ct&&c.expr().expr().groupBy(u),this.#i.set(n,c)}let o=`$path::${(0|Math.random()*9e6).toString(36)}`,a=u=>u.expr(t.rhs().jsonfy()).as(o);return this.#i.get(n).expr().expr().fields().add(a),{nodeName:b.NODE_NAME,name:o,prefix:n,prettyName:t.prettyName()}}static fromJSON(t,e,r=null){return super.fromJSON(t,e,s=>{e.joinClauses?.length&&s.joins(...e.joinClauses),e.whereClause&&s.where(e.whereClause),e.orderByClause&&s.orderBy(e.orderByClause),e.limitClause&&s.limit(e.limitClause),r?.(s)})}jsonfy(t,e){return super.jsonfy(t,()=>({...this.#t.length?{joinClauses:this.#t.map(r=>r.jsonfy(t))}:{},...this.#e?{whereClause:this.#e.jsonfy(t)}:{},...this.#r?{orderByClause:this.#r.jsonfy(t)}:{},...this.#s?{limitClause:this.#s.jsonfy(t)}:{},...e()}))}finalizeJSON(t,e){if(!this.#i.size)return super.finalizeJSON(t,e);let r=(0|Math.random()*9e6).toString(36);if(this.params.dialect==="postgres"&&this.NODE_NAME==="UPDATE_STATEMENT"){let s=new Map,i=n=>t.tables.reduce((o,a)=>{if(o)return o;let u=a.expr,c=a.alias||a.expr.name,h=n.name;if(n.prefix.name!==c)return;let d=`${c}:${r}`,m=`${h}:${r}`;return s.has(c)||s.set(c,{tblAliasOriginal:c,tblAliasRewrite:d,colRefOriginal:h,colRefRewrite:m,table:{expr:u},alias:d,fields:[]}),s.get(c).fields.push({expr:{name:h},alias:m}),{name:m,prefix:{name:d}}},null)||n;t.joinClauses||(t.joinClauses=[]);for(let[,n]of this.#i){let o=n.jsonfy(e);o.onClause.entries=o.onClause.entries.map(a=>({...a,rhs:i(a.rhs)})),t.joinClauses.push(o)}if(s.size){t.postgresFromList||(t.postgresFromList=[]),t.whereClause||(t.whereClause={nodeName:"WHERE_CLAUSE",entries:[]});for(let[,n]of s)t.postgresFromList.push(M.fromJSON(this,{expr:o=>o.select(...n.fields).from(n.table),alias:n.alias}).jsonfy(e)),t.whereClause.entries.unshift(ae.fromJSON(this,{operator:"=",lhs:[n.tblAliasOriginal,n.colRefOriginal],rhs:[n.tblAliasRewrite,n.colRefRewrite]}))}}else if(this.params.dialect==="postgres"&&this.NODE_NAME==="DELETE_STATEMENT"){let s=t.table.expr,i=t.table.alias||t.table.expr.name,n=`${i}:${r}`,o=t.whereClause,a=this.from().schema().primaryKey().columns()[0];t.table={expr:s,alias:n},t.whereClause=ae.fromJSON(this,{operator:"IN",lhs:{name:a,prefix:{name:n}},rhs:u=>{u.select({name:a}).from({expr:s,alias:i}).where(o).joins(...[...this.#i].map(([,c])=>c.jsonfy(e)))}}).jsonfy(e)}else{t.joinClauses||(t.joinClauses=[]);for(let[,s]of this.#i)t.joinClauses.push(s.jsonfy(e))}return this.#i.clear(),super.finalizeJSON(t,e)}};var Wt=class extends Se{#t=[];[Symbol.iterator](){return this.#t[Symbol.iterator]()}get length(){return this.#t.length}$capture(t,e){return t==="ROOT_SCHEMA"?this:super.$capture(t,e)}database(t,...e){if(typeof t=="string"){let r=this.#t.find(s=>s.identifiesAs(t));if(!e.length)return r;if(e[0]===!1)return this.#t=this.#t.filter(s=>s!==r),r?.bubble("DISCONNECTED"),this;t={name:t,...typeof e[0]=="object"?e[0]:{tables:e[0]}}}return this.#t=this.$castInputs([t],Q,this.#t,"databases",null,r=>this.#t.find(s=>s.identifiesAs(r.name()))),this}databases(t=!0){return t?this.#t:this.#t.map(e=>e.name())}tables(t=!0){return this.#t.reduce((e,r)=>e.concat(t?r.tables():r.tables(!1).map(s=>[r.name(),...s])),[])}columns(t=!0){return this.#t.reduce((e,r)=>e.concat(t?r.columns():r.columns(!1).map(s=>[r.name(),...s])),[])}primaryKeys(t=!0,e=!0){return this.#t.reduce((r,s)=>r.concat(t?s.primaryKeys(!0,e):s.primaryKeys(!1,e).map(i=>[s.name(),...i])),[])}foreignKeys(t=!0,e=!0){return this.#t.reduce((r,s)=>r.concat(t?s.foreignKeys(!0,e):s.foreignKeys(!1,e).map(i=>[s.name(),...i])),[])}uniqueKeys(t=!0,e=!0){return this.#t.reduce((r,s)=>r.concat(t?s.uniqueKeys(!0,e):s.uniqueKeys(!1,e).map(i=>[s.name(),...i])),[])}checks(t=!0,e=!0){return this.#t.reduce((r,s)=>r.concat(t?s.checks(!0,e):s.checks(!1,e).map(i=>[s.name(),...i])),[])}renderCDL(t,e){let r=e,s=new Set,i=new Map,n=[],o=(l,p=!0,_=!0)=>{let S=this.database(l);if((!S||i.has(S)&&!i.get(S))&&p)throw new Error(`Database "${l}" does not exist.`);return _&&i.has(S)?[S,S.constructor.fromJSON(S.contextNode.clone(),i.get(S))]:[S]},a=l=>{let p={...r,rootCDL:!s.has(l)&&t};return s.has(l)||s.add(l),p},u=l=>{if(o(l.argument().name(),!1,!1)[0]){if(l.hasFlag("IF_NOT_EXISTS"))return;throw new Error(`Database "${l.argument()?.name()}" already exists`)}let p=l.argument().jsonfy(r);r.diff!==!1&&(p={...p,status:"new"}),n.push(p)},c=l=>{let[p,_]=o(l.reference().name(),!l.hasFlag("IF_EXISTS"),r.diff!==!1);p&&i.set(p,r.diff===!1?void 0:{...(_||p).jsonfy(r),status:"obsolete"})},h=l=>{let[p,_]=o(l.reference().name()),S=this.diffMergeJsons((_||p).jsonfy(a(p)),l.argument().jsonfy(r),r);i.set(p,S)},d=l=>{let[p,_]=o(l.reference().name()),S=(_||p).renderCDL(l.argument(),a(p));i.set(p,S)},m=l=>{let p,_=a(l);if(i.has(l)){if(!i.get(l))return;_.rootCDL?p=l.constructor.fromJSON(this,i.get(l)).jsonfy(_):p=i.get(l)}else p=l.jsonfy(_);return p};for(let l of t)if(l.CLAUSE==="CREATE")u(l);else if(l.CLAUSE==="DROP")c(l);else if(l.CLAUSE==="RENAME")h(l);else if(l.CLAUSE==="ALTER")d(l);else throw new Error(`Unsupported operation: ${l.CLAUSE} ${l.KIND}`);return this.renderNormalized(this.#t,m).concat(n)}renderNormalized(t,e,r=!1){let s=(o,a)=>this.$eq(o,a?.name||a,"ci"),[i,n]=t.reduce(([o,a],u)=>{let c=e(u);if(c){let h;c={...c,tables:c.tables.reduce((d,m)=>{if(m.prefix)if(s(u.name(),m.prefix))m.$prefix||({prefix:h,...m}=m);else{let l=o.find(p=>s(p.name,m.prefix));return l?(m.$prefix||({prefix:h,...m}=m),l.tables.push(m)):a.push({db:u,tbl:m}),d}return d.concat(m)},[])},a=a.reduce((d,m)=>{let l=m.tbl;return s(u.name(),l.prefix)?(l.$prefix||({prefix:h,...l}=l),c.tables.push(l),d):d.concat(m)},[])}return[o.concat(c||[]),a]},[[],[]]);if(n.length)if(r)for(let{tbl:o}of n){let a=o,u;a.$prefix||({prefix:u,...a}=a);let c=i.find(h=>s(h.name,o.prefix));c?c.tables.push(a):i.push({name:o.prefix.name||o.prefix,tables:[a]})}else throw new Error(`The following tables could not be moved to the implied target database: ${n.map(o=>`"${o.db.name()}"."${o.tbl.name}" -> "${o.tbl.prefix.name||o.tbl.prefix}"."${o.tbl.name}"`).join('", "')}`);return i}generateCDL(t={},e="SCHEMA"){let r=Rt.fromJSON(this,{actions:[]});for(let s of this.#t)if(s.status()==="new")r.add("CREATE",e,i=>{i.argument(s.jsonfy({...t,diff:!1})),t.existsChecks&&i.withFlag("IF_NOT_EXISTS")});else if(s.status()==="obsolete")r.add("DROP",e,i=>{i.reference(s.name()),t.cascadeRule&&i.withFlag(t.cascadeRule),t.existsChecks&&i.withFlag("IF_EXISTS")});else{let i=s.generateCDL(t);i.length&&r.add("ALTER",e,n=>{n.reference(s.name()),n.argument(i)})}return r}generateDiff(t,e){return this.diffMergeTrees(this.#t,t.databases(),(r,s)=>r.generateDiff(s,e),e)}defaultDB(){return this.databases(!1)[0]}findPrefix(t,e=!1){let r=this.tables(!1).find(s=>s[1].toLowerCase()===t.toLowerCase())?.[0];return!r&&e?this.defaultDB():r}static fromJSON(t,e,r=null){if(Array.isArray(e))return super.fromJSON(t,e,s=>{for(let i of e)s.database(i);r?.(s)})}jsonfy(t={},e={}){return this.renderNormalized(this.#t,r=>r.jsonfy(t),t.forceNormalize)}};var Vt=class extends T{#t=0;#e;offset(t){if(!arguments.length)return this.#t;if(typeof t!="number")throw new Error("Offset must be a number");return this.#t=t,this}value(t){return arguments.length?(this.#e=t,this):this.#e}static get expose(){return{binding:(t,e)=>new this(t).value(e)}}static fromJSON(t,e,r=null){if(!(!e?.nodeName&&typeof e?.offset!="number"))return super.fromJSON(t,e,s=>{e.offset&&s.offset(e.offset),e.value!==void 0&&s.value(e.value),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,{offset:this.#t,...this.#e!==void 0?{value:this.#e}:{},...e})}static parse(t,e){let r=(t?.params?.inputDialect||t?.params?.dialect)==="mysql"?"?":"$",[s,i]=new RegExp(`^\\${r}(\\d)$`).exec(e)||[];if(s)return new this(t).offset(parseInt(i))}stringify(){return this.params.dialect==="mysql"?"?":`$${this.#t}`}};var Or=f=>class extends hr(f){#t;#e=new Set;get uuid(){return this.#t||(this.#t=`scope_${(0|Math.random()*9e6).toString(36)}`),this.#t}get queryBindings(){return[...this.#e].sort((t,e)=>e.offset()===0||e.offset()>t.offset()?-1:1)}get hasPaths(){return[...this.querySugars].some(t=>t.isPath)}$bubble(t,e){return["CONNECTED","DISCONNECTED"].includes(t)&&[Vt].some(r=>e instanceof r)&&(t==="DISCONNECTED"?this.#e.delete(e):this.#e.add(e)),super.$bubble(t,e)}$capture(t,e){let r=super.$capture(t,e);return t==="ROOT_SCHEMA"&&!r?Wt.fromJSON(this,[]):r}renderBindings(t){if(!Array.isArray(t))throw new Error("Values must be an array");let e=[...this.#e];for(let r=0;r<t.length;r++){let s=e.filter(i=>i.offset()===r+1);if(!s.length)throw new Error(`No bindings exists at offset #${r}`);s.forEach(i=>i.value(t[r]))}}normalizeBindings(t=!1){let e=[...this.#e];if(!t)return e.forEach((i,n)=>i.offset(n+1)),e;let r=new Map,s=1;for(let i of e)if(i.offset()===0||!r.has(i.offset())){let n=s++;r.set(i.offset(),n),i.offset(n)}else i.offset(r.get(i.offset())).withDetail("redundant",!0);return e.filter(i=>!i.getDetail("redundant"))}static mySubstitutePlaceholders(t,e){return(t?.params?.inputDialect||t?.params?.dialect)!=="mysql"||e.indexOf("?")===-1?e:E.split(e,["?"],{blocks:[]}).reduce((r,s,i)=>r?r+"?"+i+s:s,null)}static fromJSON(t,e,r=null){return super.fromJSON(t,e,s=>{e.uuid&&(s.#t=e.uuid),r?.(s)})}jsonfy(t,e){let r=super.jsonfy(t,e);return this.finalizeJSON(r,t)}finalizeJSON(t,e){return{...this.#t?{uuid:this.#t}:{},...t}}};var ze=class extends st{static get CLAUSE(){return"OFFSET"}};var Ze=class extends I{static get EXPECTED_TYPES(){return x}static get REGEX(){return"GROUP\\s+BY"}withRollup(){return this.withFlag("WITH_ROLLUP")}static parse(t,e,r){let[s,i,n]=e.match(new RegExp(`^${this.REGEX}([\\s\\S]*)(\\s+WITH\\s+ROLLUP)?$`,"i"))||[];if(!s)return;let o=super.parse(t,i,r);if(o)return n&&o.withFlag("WITH_ROLLUP"),o}stringify(){return this.entries().length?["GROUP BY",super.stringify()].concat(this.hasFlag("WITH_ROLLUP")?"WITH ROLLUP":[]).join(" "):""}};var tr=class extends _t{static get CLAUSE(){return"HAVING"}static get minEntries(){return 1}};var er=class extends I{static get EXPECTED_TYPES(){return[fe]}static get CLAUSE(){return"WINDOW"}};var lt=class extends je(Or(T)){static get CLAUSE(){return"SELECT"}#t;#e=[];#r;#s;#n;#i;#o;get statementType(){return"DQL"}fields(...t){return arguments.length?(this.#t=this.$castInputs(t,le,this.#t,"fields_list","add"),this):this.#t}from(...t){return arguments.length?(this.#e=this.$castInputs(t,M,this.#e,"from_clause"),this):this.#e}tables(){return this.#e}groupBy(...t){return arguments.length?(this.#r=this.$castInputs(t,Ze,this.#r,"group_by_clause","add"),this):this.#r}having(...t){return arguments.length?(this.#s=this.$castInputs(t,tr,this.#s,"having_clause","add"),this):this.#s}window(...t){return arguments.length?(this.#n=this.$castInputs(t,er,this.#n,"window_clause","add"),this):this.#n}offset(t){return arguments.length?(this.#i=this.$castInputs([t],ze,this.#i,"offset_clause","value"),this):this.#i}union(...t){return arguments.length?(this.#o=this.$castInputs(t,this.constructor,this.#o,"union_clause","fields"),this):this.#o}static fromJSON(t,e,r=null){if(e?.fieldsSpec)return super.fromJSON(t,e,s=>{if(s.fields(...[].concat(e.fieldsSpec)),e.fromList?.length)for(let i of e.fromList)s.from(i);e.groupByClause&&s.groupBy(e.groupByClause),e.havingClause&&s.having(e.havingClause),e.windowClause&&s.window(e.windowClause),e.offsetClause&&s.offset(e.offsetClause),e.unionClause&&s.union(e.unionClause),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,()=>({fieldsSpec:this.#t?.jsonfy(t),...this.#e.length?{fromList:this.#e.map(r=>r.jsonfy(t))}:{},...this.#r?{groupByClause:this.#r.jsonfy(t)}:{},...this.#s?{havingClause:this.#s.jsonfy(t)}:{},...this.#n?{windowClause:this.#n.jsonfy(t)}:{},...this.#i?{offsetClause:this.#i.jsonfy(t)}:{},...this.#o?{unionClause:this.#o.jsonfy(t)}:{},...e}))}static parse(t,e,r){let[s,i,n]=/^SELECT\s+(ALL|DISTINCT)?([\s\S]+)$/i.exec(e.trim())||[];if(!s)return;let o=new this(t),a=this.mySubstitutePlaceholders(o,n.trim()),u={from:{backtest:"^(?!.*\\s+DISTINCT\\s+$)",test:"FROM"},join:ut,where:z,groupBy:Ze,having:tr,window:er,orderBy:W,limit:st,offset:ze,union:"UNION"},[c,...h]=E.split(a,Object.values(u).map(d=>d.REGEX||d.CLAUSE&&`${d.CLAUSE}(?!\\w)`||d),{useRegex:"i",preserveDelims:!0});o.fields(r(o,c.trim(),[le]));t:for(let d of h){if(/^FROM/i.test(d)){let m=E.split(d.replace(/FROM/i,""),[","]).map(l=>r(o,l.trim(),[M]));for(let l of m)o.from(l);continue}if(/^UNION/i.test(d)){o.union(r(o,d.replace(/UNION/i,"").trim(),[this]));continue}if(/^LIMIT.*,(?:\s+)?\d$/i.test(d)){let[m,l]=d.match(/(\d+)(?:\s+)?,(?:\s+)?(\d+)$/);h.push(`LIMIT ${l}`,`OFFSET ${m}`);continue}for(let m in u){let l=u[m].parse?.(o,d.trim(),r);if(l){o[m](l);continue t}}}return i&&o.withFlag(i),o}stringify(){let t=["SELECT"];return this.getFlag().length&&t.push(this.getFlag().map(e=>e.replace(/_/g," "))),t.push(this.#t),this.#e.length&&t.push("FROM",this.#e.join(", ")),t.push(...this.joins(),this.where(),this.#r,this.#s,this.#n,this.orderBy(),this.limit(),this.#i),this.#o&&t.push(this.#o),t.filter(e=>e).join(" ")}};var Tt=class f extends T{static get EXPECTED_TYPES(){return x}#t;expr(...t){return arguments.length?(this.#t=this.$castInputs(t,this.constructor.EXPECTED_TYPES,this.#t,"parens_expr"),this):this.#t}exprUnwrapped(){return this.#t instanceof f?this.#t.exprUnwrapped():this.#t}static get expose(){return{parens:(t,e)=>this.fromJSON(t,{expr:e})}}static fromJSON(t,e,r=null){if(e?.expr)return super.fromJSON(t,e,s=>{s.expr(e.expr),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,{expr:this.#t?.jsonfy(t),...e})}static parse(t,e,r){if(!$t(e,"(",")")||E.match(e,[" "]).length&&E.split(e,[]).length===2)return;let s=new this(t),i=r(s,V(e,"(",")"),this.constructor.EXPECTED_TYPES);return s.expr(i)}stringify(){return"("+this.#t.stringify()+")"}};var Ue=class extends Tt{static get EXPECTED_TYPES(){return[lt]}select(...t){return this.expr({fieldsSpec:t}).expr()}static get expose(){}schema(){let t=wt.fromJSON(this,{name:"",columns:[]}),e=this.expr().schema({derivationLevel:"SELECT_LIST_ONLY"}).columns()||[];for(let r of e)t.column({...r.jsonfy()});return t}static fromJSON(t,e,r=null){if(!(!e?.expr||!e?.expr?.fieldsSpec))return super.fromJSON(t,e,r)}static parse(t,e,r){if(/\(\s*SELECT\s+/i.test(e))return super.parse(t,e,r)}};var rr=class extends T{#t;#e;when(t){return arguments.length?(this.#t=this.$castInputs([t],x,this.#t,"when_clause"),this):this.#t}then(t){return arguments.length?(this.#e=this.$castInputs([t],x,this.#e,"then_clause"),this):this.#e}static get expose(){return{when:(t,e)=>this.fromJSON(t,{when:e})}}static fromJSON(t,e,r=null){if(e?.when)return super.fromJSON(t,e,s=>{s.when(e.when).then(e.then),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,{when:this.#t?.jsonfy(t),then:this.#e?.jsonfy(t),...e})}static parse(t,e,r){let[s,i]=e.match(new RegExp("^WHEN([\\s\\S]*)$","i"))||[];if(!s)return;let n=E.split(i,["\\s+THEN\\s+"],{useRegex:"i"});if(n.length!==2)return;let o=new this(t),[a,u]=n.map(c=>r(o,c.trim()));return o.when(a).then(u)}stringify(){return`WHEN ${this.#t} THEN ${this.#e}`}};var br=class extends T{#t;#e=[];#r;switchExpr(t){return arguments.length?(this.#t=this.$castInputs([t],x,this.#t,"switchExpr"),this):this.#t}cases(...t){return arguments.length?(this.#e=this.$castInputs(t,rr,this.#e,"cases"),this):this.#e.slice()}default(t){if(!arguments.length)return this.#r;if(!this.#e.length)throw new Error('A "default" expression cannot come before "case" clauses.');return this.#r=this.$castInputs([t],x,this.#r,"defaultExpr"),this}static get expose(){return{switch:(t,e)=>this.fromJSON(t,{switchExpr:e,cases:[]}),cases:(t,...e)=>this.fromJSON(t,{cases:e})}}static fromJSON(t,e,r=null){if(!(!Array.isArray(e?.cases)||Object.keys(e).filter(s=>!["nodeName","switchExpr","cases","defaultExpr"].includes(s)).length))return super.fromJSON(t,e,s=>{e.switchExpr&&s.switchExpr(e.switchExpr),s.cases(...e.cases),e.defaultExpr&&s.default(e.defaultExpr),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,{switchExpr:this.#t?.jsonfy(t),cases:this.#e.map(r=>r.jsonfy(t)),defaultExpr:this.#r?.jsonfy(t),...e})}static parse(t,e,r){let[s,i]=e.match(/^CASE\s+([\s\S]*)\s+END(\s+CASE)?$/i)||[];if(!s)return;let{tokens:[n,...o],matches:a}=E.lex(i,["WHEN","ELSE"],{useRegex:"i",preserveDelims:!0}),u=new this(t);n.trim()&&u.switchExpr(r(u,n.trim()));for(let c of a){let h=o.shift();if(/ELSE/i.test(c))u.default(r(u,h.replace(/ELSE/i,"").trim()));else if(/WHEN/i.test(c))u.cases(r(u,h.trim(),[rr]));else throw new Error(`Can't have multiple "${c}" clauses in a CASE construct.`)}return u}stringify(){let t=[];return this.#t&&t.push(this.#t),t.push(...this.#e),this.#r&&t.push("ELSE",this.#r),`CASE ${t.join(" ")} END${this.params.dialect==="mysql"?" CASE":""}`}};var Dr=class extends I{static get EXPECTED_TYPES(){return x}static get CLAUSE(){return"ARRAY"}static get TAGS(){return["[","]"]}static get expose(){return{array:(t,...e)=>this.fromJSON(t,{entries:e})}}};var wr=class extends Ht{static get OPERATORS(){return["||"]}static get expose(){return{join:(t,...e)=>this.fromJSON(t,{operator:"||",entries:e})}}};var Rr=class extends Ht{static get OPERATORS(){return["+","-","*","/"]}static get expose(){return{sum:(t,...e)=>e.length>1&&this.fromJSON(t,{operator:"+",entries:e}),sub:(t,...e)=>this.fromJSON(t,{operator:"-",entries:e}),"times|tms":(t,...e)=>this.fromJSON(t,{operator:"*",entries:e}),div:(t,...e)=>this.fromJSON(t,{operator:"/",entries:e})}}};var Ir=class extends T{#t;value(t){return arguments.length?(this.#t=t,this):this.#t}identifiesAs(t){return t===this.#t||super.identifiesAs(t)}static get expose(){return{true:t=>this.fromJSON(t,{value:!0}),false:t=>this.fromJSON(t,{value:!1}),value:(t,e)=>/^(TRUE|FALSE)$/i.test(e)&&this.fromJSON(t,{value:/^TRUE$/i.test(e)})}}static fromJSON(t,e,r=null){if(!(![!0,!1].includes(e?.value)||Object.keys(e).filter(s=>!["nodeName","value"].includes(s)).length))return super.fromJSON(t,e,s=>{s.value(e.value),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,{value:this.#t,...e})}static parse(t,e){if(/^TRUE$/i.test(e))return new this(t).value(!0);if(/^FALSE$/i.test(e))return new this(t).value(!1)}stringify(){return`${this.#t}`}};var At=class extends I{static get EXPECTED_TYPES(){return[B,Tt]}static get ARGS_DELEGATION(){return"add"}static get CLAUSE(){return"VALUES"}static get expose(){return{values:(t,...e)=>this.fromJSON(t,{entries:e})}}};var Lr=class extends B{static get MIN_ENTRIES(){return 0}static get CLAUSE(){return"ROW"}stringify(){let t=super.stringify();return this.contextNode instanceof At?`(${t})`:t}};var he=class extends At{static get TAGS(){return["(",")"]}};var me=class extends Vt{#t=[];get resolutionPath(){return this.#t.slice()}get isForeign(){return!0}static get expose(){return{}}resolve(t,e){if(!["INSERT_STATEMENT","UPSERT_STATEMENT","UPDATE_STATEMENT"].includes(t?.NODE_NAME))throw new Error("Source query must be an INSERT, UPSERT, or UPDATE statement");if(this.#t[0]!==t.uuid)return;if(!Array.isArray(e))throw new Error("Input source must be an array");if(!N(e[this.#t[1]]))throw new Error(`Input source does not have an object at: #${this.resolutionPath[1]}`);let r=e[this.#t[1]][this.#t[2]];if(!r)throw new Error(`Input source does not have a value at: [${this.resolutionPath}]`);return this.value(r)}static fromJSON(t,e,r=null){if(!(!Array.isArray(e?.resolutionPath)||e.resolutionPath.length!==3))return super.fromJSON(t,{offset:0,...e},s=>{s.#t=e.resolutionPath.slice(),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,{resolutionPath:this.#t.slice(),...e})}stringify(){return this.value()?super.stringify():this.params.dialect==="mysql"?`$${this.#t.join(".")}`:`$${this.#t.join(".")}`}};var x=[Ue,br,wr,_t,ae,F,ke,Rr,B,Dr,Tt,Lr,he,ct,Fe,ue,nt,Ir,ce,Ye,it,Gt,qt,Vt,me,b,Ft];var Pr=class extends vt{static get EXPECTED_TYPES(){return x}};var le=class extends I{static get EXPECTED_TYPES(){return[Pr]}};var Z=class extends le{static get CLAUSE(){return"RETURNING"}};var Qt=class extends Or(T){#t;get statementType(){return"DML"}returning(...t){return arguments.length?(this.#t=this.$castInputs(t,Z,this.#t,"returning_clause","add"),this):this.#t}static fromJSON(t,e,r=null){return super.fromJSON(t,e,s=>{e.returningClause&&s.returning(e.returningClause),r?.(s)})}jsonfy(t,e){return super.jsonfy(t,()=>({...this.#t?{returningClause:this.#t.jsonfy(t)}:{},...e()}))}};var zt=class extends je(Qt){static get CLAUSE(){return"DELETE"}#t=[];#e;#r=[];delete(...t){return arguments.length?(this.#t=this.$castInputs(t,w,this.#t,"delete_list"),this):this.#t}from(t){return arguments.length?(this.#e=this.$castInputs([t],M,this.#e,"from_clause","expr"),this):this.#e}using(...t){return arguments.length?(this.#r=this.$castInputs(t,M,this.#r,"using_clause","expr"),this):this.#r}tables(){let t=this.#e&&[this.#e]||[];return this.#e&&this.#r.length&&t.push(...this.#r.filter(e=>!e.expr().identifiesAs(this.#e.expr().name())||e.alias()&&this.#e.alias()&&!this.$eq(e.alias(),this.#e.alias(),"ci"))),t}static fromJSON(t,e,r=null){if(e?.table)return super.fromJSON(t,e,s=>{e.mysqlDeleteList?.length&&s.delete(...e.mysqlDeleteList),s.from(e.table),e.postgresUsingList?.length&&s.using(...e.postgresUsingList),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,()=>({...this.#t.length?{mysqlDeleteList:this.#t.map(r=>r.jsonfy(t))}:{},table:this.#e?.jsonfy(t),...this.#r.length?{postgresUsingList:this.#r.map(r=>r.jsonfy(t))}:{},...e}))}static parse(t,e,r){let[s,i,n]=/^DELETE(?:\s+(IGNORE))?([\s\S]+)$/i.exec(e.trim())||[];if(!s)return;let o=new this(t),a=this.mySubstitutePlaceholders(o,n.trim()),u=t?.params?.dialect||"postgres",c={from:{backtest:"^(?!.*\\s+DISTINCT\\s+$)",test:"FROM"},...u==="postgres"?{using:{backtest:"^(?!.*\\s+JOIN\\s+)",test:"USING"}}:{},...u==="mysql"?{join:ut}:{},where:z,...u==="mysql"?{orderBy:W}:{},limit:st,returning:Z},[h="",...d]=E.split(a,Object.values(c).map(m=>m.REGEX||m.CLAUSE&&`${m.CLAUSE}(?!\\w)`||m),{useRegex:"i",preserveDelims:!0});h.trim()&&o.delete(...E.split(h,[","]).map(m=>r(o,m.trim(),[w])));t:for(let m of d){if(/^FROM/i.test(m)){o.from(r(o,m.replace(/FROM/i,"").trim(),[M]));continue}if(/^USING/i.test(m)){o.using(...E.split(m.replace(/USING/i,""),[","]).map(l=>r(o,l.trim(),[M])));continue}for(let l in c){let p=c[l].parse?.(o,m.trim(),r);if(p){o[l](p);continue t}}}return i&&o.withFlag(i),o}stringify(){let t=["DELETE"];return t.push(...this.getFlag().map(e=>e.replace(/_/g," "))),this.params.dialect==="mysql"?(t.push(this.#t.join(", ")),t.push(`FROM ${this.#e}`),t.push(...this.joins(),this.where(),this.orderBy(),this.limit(),this.returning())):(t.push(`FROM ${this.#e}`),this.#r.length&&t.push(`USING ${this.#r.join(", ")}`),t.push(this.where(),this.limit(),this.returning())),t.filter(e=>e).join(" ")}};var Ke=class extends Nt{static get OPERATORS(){return["="]}static get LHS_TYPES(){return[P,F,b]}static get RHS_TYPES(){return[B,...x]}static parse(t,e,r){let[s,i]=E.split(e,this.OPERATORS);if(!i)return;let n=new this(t).operator("=");return n.lhs(r(n,s.trim(),this.LHS_TYPES)),n.rhs(r(n,i.trim(),this.RHS_TYPES)),n}};var ht=class extends I{static get EXPECTED_TYPES(){return[Ke]}static get CLAUSE(){return"SET"}columns(){return this.entries().reduce((t,e)=>e.lhs()instanceof P?t.concat(e.lhs().entries()):t.concat(e.lhs()),[])}values(){return this.entries().reduce((t,e)=>e.rhs()instanceof B?t.concat(e.rhs().entries()):t.concat(e.rhs()),[])}add(...t){return super.add(...t.map(e=>Array.isArray(e)?{operands:e}:e))}jsonfy(t={},e={},r=null){return!t.deSugar||!this.statementNode?super.jsonfy(t,e,r):super.jsonfy(t,e,s=>{if(s.lhs()instanceof F){let[i,n]=this.statementNode.createDimension(s.lhs(),t),o=i.offload(0,s.rhs());return n?{nodeName:Ke.NODE_NAME,lhs:n,rhs:o,operator:"="}:void 0}if(s.lhs()instanceof P){let i={...t,explicitRowOffset:0},[n,[o]]=this.statementNode.filterPayload(s.lhs(),[s.rhs()],i);return n.entries.length?void 0:{nodeName:Ke.NODE_NAME,lhs:n,rhs:o,operator:"="}}return!0})}};var vr=f=>class extends f{#t=[];#e=[];#r;get dependencies(){return this.#t}get dependents(){return this.#e}get localBindings(){return this.queryBindings.filter(t=>!t.isForeign)}get foreignBindings(){return this.queryBindings.filter(t=>t.isForeign)}get isPayloadStatement(){return!0}set(...t){return arguments.length?(this.#r=this.$castInputs(t,ht,this.#r,"set","add"),this):this.#r}renderForeignBindings(t,e){return this.foreignBindings.filter(s=>s.resolve(t,e))}createExecutionPlan(t){return[async()=>{if(this.#t.length)for(let s of this.#t){let i=await t(s);this.renderForeignBindings(s,i)}},async s=>{if(!this.#e.length)return s;if(this.NODE_NAME==="UPDATE_STATEMENT")for(let i of s){this.#e[0].renderForeignBindings(this,[i]);let n=await t(this.#e[0])}else for(let i of this.#e){i.renderForeignBindings(this,s);let n=await t(i)}return s}]}filterPayload(t,e,r={}){let s=new Map,i=t.jsonfy(r,{},(o,a)=>{if(o instanceof F){let[u,c]=this.createDimension(o,r);if(s.set(a,u),c)return c}else return o.jsonfy(r)}),n=e.map((o,a)=>o.jsonfy(r,{},(u,c)=>s.has(c)?s.get(c).offload(r.explicitRowOffset??a,u):u.jsonfy(r)));return s.clear(),[i,n]}#s=new Set;#n=new Set;#i=Z.fromJSON(this,{entries:[]});createDimension(t,e={}){if(![P,b,F].some(m=>t.rhs()instanceof m))throw new Error(`Invalid columns spec: ${t}`);let r={...e,deSugar:!1},[s,i,n]=t.plot(),o=new([].concat(this.constructor.DIMENSIONS_TO))[0](this.baseClient);o.into(i.jsonfy());let a=t.rhs();o.columns(a.jsonfy(r));let u=(m,l=!1)=>{if(m instanceof Tt&&(m=m.exprUnwrapped()),!l&&m instanceof he)throw new Error(`Single-row payload structure expected for column structure: ${t.rhs()}. Recieved ${m.NODE_NAME}.`);return l&&!(m instanceof he)&&(m=[m]),m},c=(m,l=0)=>{let p=(m instanceof B?m.length:1)+l;if(p>o.columns().length)throw new Error("INSERT has more expressions than target columns");if(p<o.columns().length)throw new Error("INSERT has more target columns than expressions");return m};if(t.lhs()instanceof It){o.columns().add(n.name());let m=s.name();!this.returning()?.has(m)&&!this.#i.has(m)&&this.#i.add(m);let p={query:o,offload:(_,S)=>{S=u(S,!0);let y=me.fromJSON(o,{resolutionPath:[this.uuid,_,m]});for(let C of S){let g=c(C,1).jsonfy(e);g.entries.push(y.jsonfy()),o.values(g)}}};return this.#n.add(p),[p]}o.returning("*");let d={query:o,offload:(m,l)=>{let p=u(l,!1);return o.values(c(p).jsonfy(e)),me.fromJSON(this,{resolutionPath:[o.uuid,m,n.name()]}).jsonfy()}};return this.#s.add(d),[d,s.jsonfy()]}static fromJSON(t,e,r=null){return super.fromJSON(t,e,s=>{e.setClause&&s.set(e.setClause),e.dependencies?.length&&(s.#t=s.$castInputs(e.dependencies,this.DIMENSIONS_TO,[],"dependencies")),e.dependents?.length&&(s.#e=s.$castInputs(e.dependents,this.DIMENSIONS_TO,[],"dependents")),e.generatedReturning?.length&&(s.#i=s.$castInputs([e.generatedReturning],Z)),r?.(s)})}jsonfy(t,e){let r=super.jsonfy(t,()=>({...this.#r?{setClause:this.#r?.jsonfy(t)}:{},...e()}));if(this.#i.length)if(t.deSugar){let s=(r.returningClause?.entries||[]).concat(this.#i.jsonfy(t).entries);r={...r,returningClause:{entries:s}}}else r={...r,generatedReturning:this.#i.jsonfy(t)};return r}finalizeJSON(t,e){return(this.#s.size||this.#n.size)&&(t.dependencies=[...this.#s].map(r=>r.query.jsonfy({...e,deSugar:!1})),t.dependents=[...this.#n].map(r=>r.query.jsonfy({...e,deSugar:!1})),this.#s.clear(),this.#n.clear()),super.finalizeJSON(t,e)}};var pe=class extends ht{static get CLAUSE(){}#t;#e;columnsSpec(...t){return arguments.length?(this.#e=this.$castInputs(t,P,this.#e,"columns_spec","add"),this):this.#e}where(...t){return arguments.length?(this.#t=this.$castInputs(t,z,this.#t,"where_clause","every"),this):this.#t}static fromJSON(t,e,r=null){return super.fromJSON(t,e,s=>{e.columnsSpec&&s.columnsSpec(e.columnsSpec),e.whereClause&&s.where(e.whereClause),r?.(s)})}jsonfy(t={},e={},r=null){return super.jsonfy(t,{...this.#e?{columnsSpec:this.#e.jsonfy(t)}:{},...this.#t?{whereClause:this.#t.jsonfy(t)}:{},...e},r)}static get REGEX(){return"ON\\s+(?:DUPLICATE\\s+KEY|CONFLICT(?:\\s+([\\s\\S]+?))?)\\s+(DO\\s+NOTHING|DO\\s+UPDATE\\s+SET\\s+|UPDATE)"}static parse(t,e,r){let[s,i,n,o]=e.match(new RegExp(`^${this.REGEX}([\\s\\S]*)$`,"i"))||[];if(!s)return;if(/DO\s+NOTHING/i.test(n))return new this(t);let[a,u]=E.split(o,["WHERE"],{useRegex:"i",preserveDelims:!0}),c=super.parse(t,a,r);return i&&c.columnsSpec(r(c,i,[P])),u&&c.where(r(c,u.trim(),[z])),c}stringify(){let t=[];return this.params.dialect==="mysql"?t.push("ON DUPLICATE KEY UPDATE"):t.push(`ON CONFLICT ${this.#e?`${this.#e} `:""}${this.entries().length?"DO UPDATE SET":"DO NOTHING"}`),t.push(super.stringify()),this.#t&&t.push(this.#t),t.join(" ")}};var tt=class f extends vr(Qt){static get CLAUSE(){return"INSERT"}static get DIMENSIONS_TO(){return[f]}#t;#e;#r;#s;#n;into(t){return arguments.length?(this.#t=this.$castInputs([t],O,this.#t,"table_spec","expr"),this):this.#t}columns(...t){return arguments.length?(this.#e=this.$castInputs(t,P,this.#e,"columns_spec","add"),this):this.#e}values(...t){return arguments.length?(this.#r=this.$castInputs(t,At,this.#r,"values_clause","add"),this):this.#r}select(...t){return arguments.length?(this.#s=this.$castInputs(t,lt,this.#s,"select_clause","fields"),this):this.#s}onConflict(...t){return arguments.length?(this.#n=this.$castInputs(t,pe,this.#n,"on_conflict_clause","assignment"),this):this.#n}schema(){let t=Q.fromJSON(this,{name:"",tables:[]});return t.table(this.#t.schema().jsonfy({fullyQualified:!0})),t}#i;$capture(t,e){if(t!=="TABLE_SCHEMA")return t==="DATABASE_SCHEMA"?(this.#i||(this.#i=this.schema()),this.#i):super.$capture(t,e)}static fromJSON(t,e,r=null){if(e?.table)return super.fromJSON(t,e,s=>{s.into(e.table),e.columnsSpec&&s.columns(e.columnsSpec),e.valuesClause&&s.values(e.valuesClause),e.selectClause&&s.select(e.selectClause),e.onConflictClause&&s.onConflict(e.onConflictClause),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,()=>{let r,s,i;if(t.deSugar&&this.#e&&this.#r){let[o,a]=this.filterPayload(this.#e,this.#r.entries(),t);r=o,s={nodeName:At.NODE_NAME,entries:a}}else r=this.#e?.jsonfy(t),s=this.#r?.jsonfy(t),i=this.#s?.jsonfy(t);let n=this.#n?.jsonfy(t);return{table:this.#t?.jsonfy(t),...r?{columnsSpec:r}:{},...s?{valuesClause:s}:{},...i?{selectClause:i}:{},...n?{onConflictClause:n}:{},...e}})}static parse(t,e,r){let[s,i,n]=new RegExp(`^${this.CLAUSE}(?:\\s+(IGNORE))?(?:\\s+INTO)?([\\s\\S]+)$`,"i").exec(e.trim())||[];if(!s)return;let o=new this(t),a=this.mySubstitutePlaceholders(o,n.trim()),u=t?.params?.dialect||"postgres",c={values:At,...u==="mysql"?{set:ht}:{},select:lt,onConflict:pe,returning:Z},[h,...d]=E.split(a,Object.values(c).map(p=>p.REGEX||p.CLAUSE&&`${p.CLAUSE}(?!\\w)`||p),{useRegex:"i",preserveDelims:!0}),[m,l=""]=E.split(h,[]);o.into(r(o,m.trim(),[O])),l.trim()&&o.columns(r(o,l.trim(),[P]));t:for(let p of d)for(let _ in c){let S=c[_].parse?.(o,p.trim(),r);if(S){o[_](S);continue t}}return i&&o.withFlag(i),o}stringify(){let t=[this.constructor.CLAUSE];return t.push(...this.getFlag().map(e=>e.replace(/_/g," "))),t.push("INTO",this.#t),this.params.dialect==="mysql"&&this.set()?t.push(this.set()):(t.push(this.#e),this.#r?t.push(this.#r):t.push(this.#s)),t.push(this.#n),t.push(this.returning()),t.filter(e=>e).join(" ")}};var Be=class f{constructor(t,e){Object.defineProperty(this,"$",{value:{client:t,json:e}})}get client(){return this.$.client}id(){return this.$.json.id}masterSavepoint(){return this.$.json.master_savepoint}name(t=!1){return t?this.versionState()==="rollback"&&this.$.json.$name||this.$.json.name:this.versionState()==="commit"&&this.$.json.$name||this.$.json.name}schema(){let{name:t,$name:e,tables:r=[],status:s}=this.$.json;return Q.fromJSON(this.client,{name:t,...e?{$name:e}:{},tables:r,status:s})}cascades(){return this.$._cascades=this.$._cascades||(this.$.json.cascades||[]).map(t=>new f(this.client,t)),this.$._cascades}databaseTag(){return this.$.json.database_tag}versionTag(){return this.$.json.version_tag}versionTags(){return this.$.json.version_tags||[this.$.json.version_tag]}versionUp(){return this.versionTags().reduce((t,e)=>t||(e>this.versionTag()?e:0),0)}versionDown(){return[...this.versionTags()].reverse().reduce((t,e)=>t||(e<this.versionTag()?e:0),0)}versionMax(){return Math.max(...this.versionTags())}versionState(){return this.$.json.version_state}commitDate(){return this.$.json.commit_date}commitDesc(){return this.$.json.commit_desc}commitClientID(){return this.$.json.commit_client_id}commitClientPID(){return this.$.json.commit_client_pid}rollbackDate(){return this.$.json.rollback_date}rollbackDesc(){return this.$.json.rollback_desc}rollbackClientID(){return this.$.json.rollback_client_id}rollbackClientPID(){return this.$.json.rollback_client_pid}restoreEffect(){let t=this.$.json.status==="new"?["DROP","RECREATE"]:this.$.json.status==="obsolete"?["RECREATE","DROP"]:["ALTER"];return this.versionState()==="rollback"?t.reverse()[0]:t[0]}reverseSQL(){return this.versionState()==="rollback"?this.querify(!0):[this.querify(!0),...this.cascades().map(t=>t.reverseSQL())].join(`
`)}static fromJSON(t,e){return new this(t,e)}jsonfy(){return this.$.json}querify(t=!1){let e=Wt.fromJSON(this.client,[this.schema()]),r=this.versionState()==="rollback";return t&&(r=!r),r&&(e=e.reverseDiff({forceNormalize:!0,honourCDLIgnoreList:this.versionState()==="rollback"})),e.generateCDL({cascadeRule:"CASCADE"}).actions()[0]}async isNextRestorePoint(){return(await this.client.database(this.name()).savepoint({lookAhead:this.versionState()==="rollback",withCascades:!1})||{}).id?.()===this.$.json.id}async rollback(t={}){if(this.versionState()==="rollback")throw new Error("Already in rollback state.");return await this.restore(t)}async recommit(t={}){if(this.versionState()==="commit")throw new Error("Already in commit state.");return await this.restore(t)}async restore(t={}){if(this.masterSavepoint()){if(this.versionState()==="commit"){let i=this.querify(!0);i&&await this.client.withMode("restore",()=>this.client.query(i))}}else{if(!await this.isNextRestorePoint())throw new Error("Invalid restore order.");await this.client.withMode("restore",()=>this.client.query(this.querify(!0)))}let e=await this.client.linkedDB(),r=this.versionState()==="rollback"?"commit":"rollback",s=await e.table("savepoints").update({data:{version_state:r,[`${r}_date`]:i=>i.now(),[`${r}_desc`]:t.desc||this[`${r}Desc`](),[`${r}_client_id`]:this.client.params.clientID||this[`${r}ClientID`](),[`${r}_client_pid`]:i=>i.fn(this.client.params.dialect==="mysql"?"connection_id":"pg_backend_pid")},where:i=>i.eq("id",n=>n.value(this.$.json.id)),returning:["*"]});for(let i of this.cascades())await i.restore(t);return this.$.json=s[0],!0}};var Xe=class extends j(ve){};var Zt=class f extends rt(tt){static get CLAUSE(){return"UPSERT"}static get DIMENSIONS_TO(){return[f]}static get DESUGARS_TO(){return[tt]}jsonfy(t={},e={}){if(!t.deSugar)return super.jsonfy(t,e);let{nodeName:r,flags:s,...i}=super.jsonfy(t,e);if(this.onConflict())throw new Error('A redundanct "ON CONFLICT" clause in query.');let n=(this.set()?this.set().columns():this.columns().entries()).map(u=>u.name()),o=this.params.dialect==="mysql"?u=>c=>c.fn("VALUES",u):u=>["EXCLUDED",u],a=pe.fromJSON(this,{entries:[]});for(let u of n)a.add([u,o(u)]);if(this.params.dialect!=="mysql"){let u=this.into().schema(),c=[].concat(u.primaryKey()||[]).concat(u.uniqueKeys()).map(d=>d.columns());if(!c.length)throw new Error(`Table ${this.into().clone({fullyQualified:!0})} has no unique keys defined to process an UPSERT operation. You may want to perform a direct INSERT operation.`);let h=c.find(d=>pt(d,n).length)||c[0];a.columnsSpec(...h)}return{nodeName:tt.NODE_NAME,...i,onConflictClause:a.jsonfy(t),...s?{flags:s}:{}}}};var He=class extends vr(je(Qt)){static get CLAUSE(){return"UPDATE"}static get DIMENSIONS_TO(){return[Zt]}#t=[];#e=[];table(...t){return arguments.length?(this.#t=this.$castInputs(t,M,this.#t,"table_spec","expr"),this):this.#t}from(...t){return arguments.length?(this.#e=this.$castInputs(t,M,this.#e,"from_clause","expr"),this):this.#e}tables(){return this.#t.concat(this.#e)}static fromJSON(t,e,r=null){if(Array.isArray(e?.tables))return super.fromJSON(t,e,s=>{s.table(...e.tables),e.postgresFromList?.length&&s.from(...e.postgresFromList),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,()=>({tables:this.#t.map(r=>r.jsonfy(t)),...this.#e.length?{postgresFromList:this.#e.map(r=>r.jsonfy(t))}:{},...e}))}static parse(t,e,r){let[s,i,n]=/^UPDATE(?:\s+(IGNORE))?([\s\S]+)$/i.exec(e.trim())||[];if(!s)return;let o=new this(t),a=this.mySubstitutePlaceholders(o,n.trim()),u=t?.params?.dialect||"postgres",c={...u==="postgres"?{set:ht,from:{backtest:"^(?!.*\\s+DISTINCT\\s+$)",test:"FROM"}}:{},join:ut,...u==="mysql"?{set:ht}:{},where:z,...u==="mysql"?{limit:st}:{},returning:Z},[h,...d]=E.split(a,Object.values(c).map(m=>m.REGEX||m.CLAUSE&&`${m.CLAUSE}(?!\\w)`||m),{useRegex:"i",preserveDelims:!0});o.table(...E.split(h,[","]).map(m=>r(o,m.trim(),[M])));t:for(let m of d){if(/^FROM/i.test(m)){o.from(...E.split(m.replace(/FROM/i,""),[","]).map(l=>r(o,l.trim(),[M])));continue}for(let l in c){let p=c[l].parse?.(o,m.trim(),r);if(p){o[l](p);continue t}}}return i&&o.withFlag(i),o}stringify(){let t=["UPDATE"];return t.push(...this.getFlag().map(e=>e.replace(/_/g," "))),t.push(this.#t.join(", ")),this.params.dialect==="mysql"?t.push(...this.joins(),this.set(),this.where(),this.limit(),this.returning()):(t.push(this.set()),this.#e.length&&t.push(`FROM ${this.#e.join(", ")}`),t.push(...this.joins(),this.where(),this.returning())),t.filter(e=>e).join(" ")}};var cs=[St,Kt,Bt,Xt,Et,yt,jt,Xe,lt,tt,Zt,He,zt,...x];T.prototype.parse=function(f){return de.parse(this,f)};var de=class{static grammar=cs;static parse(t,e,r,s={}){if(!e?.length)return;t.NODE_NAME||(e=e.trim());let i=r?.length?r:this.grammar;for(let n of i){let o=this.parseOne(t,e,n,s);if(o)return s.inspect&&console.log(".................",e,".................>",o.constructor.name),o}if(s.assert!==!1)throw new SyntaxError(e)}static parseOne(t,e,r,s={}){return r.parse(t,e,(i,n,o,a={})=>this.parse(i,n,o,{...s,...a}))}};var Ur=class{constructor(t={}){Object.defineProperty(this,"$",{value:{params:{schemaCacheInvalidation:1,schemaSelector:["!information_schema","!linked_db%",...t.dialect==="postgres"?["!pg_%"]:[]],...t}}})}get params(){return this.$.params||{}}async withSchema(...t){let e=t.pop();if(t[0]===!1)return e();let r=Array.isArray(t[0])||N(t[0])?t.pop():{depth:2};return await this.schema(r,e)}#t=[];async withMode(t,e){this.#t.unshift(t);let r=await e();return this.#t.shift(),r}async schema(t,e={},...r){let s=typeof r[0]=="boolean"?r.shift():!0,i=typeof r[0]=="function"?r.shift():h=>h,o=N(e)&&e.depth===2&&!(e.selector||[]).length?this.params.schemaCacheInvalidation:2,a,u=this.#n(e,s);if(!u){let h=Promise.resolve(t(N(e)?{...e,selector:(e.selector||[]).length?e.selector:this.params.schemaSelector}:e)).then(d=>(Array.isArray(e)&&(d=d.reduce((m,l)=>{let p=e.find(S=>S.name===l.name),_=[].concat(p?.tables||[]);return _.length&&_[0]!=="*"&&(l={...l,tables:l.tables.filter(S=>_.includes(S.name))}),m.concat(p&&l||[])},[])),Wt.fromJSON(this,d)));u={params:e,schemaPromise:h},this.#s.add(u),h.then(d=>{u.resolvedSchema=d,delete u.schemaPromise,o===1&&this.listen("savepoints",m=>{let l=JSON.parse(m.payload);if(l.action==="DELETE")return;let p=new Be(this,l.body),_=Rt.fromJSON(this,{actions:[p.querify()]});u.resolvedSchema=u.resolvedSchema.alterWith(_,{diff:!1})})}),a=!0}let c=await i(u.resolvedSchema||await u.schemaPromise);return a&&o===2&&this.#s.delete(u),c}async query(...t){let e,r={};return N(t[0])&&!(t[0]instanceof T)?{query:e,...r}=t[0]:(e=t.shift(),Array.isArray(t[0])&&(r.values=t.shift()),N(t[0])&&(r={...r,...t.shift()})),typeof e=="string"&&(e=de.parse(this,e,null,{inspect:r.inspect})),await this.execQuery(e,r)}async createDatabase(t,e={}){typeof t=="string"&&(t={name:t,tables:[]});let r=Kt.fromJSON(this,{kind:e.kind,argument:t});e.ifNotExists&&r.withFlag("IF_NOT_EXISTS"),e.returning&&r.returning(e.returning);let s=await this.execQuery(r,e);return s===!0?this.database(r.argument().name()):s}async renameDatabase(t,e,r={}){let s=Xt.fromJSON(this,{kind:r.kind,reference:t,argument:e});if(!s)throw new Error("renameDatabase() called with invalid arguments.");r.returning&&s.returning(r.returning);let i=await this.execQuery(s,r);return i===!0?this.database(e):i}async alterDatabase(t,e,r={}){if(typeof e!="function")throw new Error("alterDatabase() called with invalid arguments.");return typeof t=="string"&&(t={name:t}),await this.withSchema(async()=>{let s=(await this.schema([{name:t.name,tables:t.tables||["*"]}])).database(t.name);if(!s)throw new Error(`Database "${t.name}" does not exist.`);let i=s.clone();await e(i.$nameLock(!0));let n=s.diffWith(i).generateCDL({cascadeRule:r.cascadeRule,existsChecks:r.existsChecks});if(!n.length)return;let o=St.fromJSON(this,{kind:r.kind,reference:s.name(),argument:n});r.returning&&o.returning(r.returning);let a=await this.execQuery(o,r);return a===!0?this.database(this.extractPostExecName(o)):a})}async dropDatabase(t,e={}){let r=Bt.fromJSON(this,{kind:e.kind,reference:t});if(!r)throw new Error("dropDatabase() called with invalid arguments.");return e.ifExists&&r.withFlag("IF_EXISTS"),e.restrict?r.withFlag("RESTRICT"):e.cascade&&r.withFlag("CASCADE"),e.returning&&r.returning(e.returning),await this.execQuery(r,e)}async hasDatabase(t){return(await this.databases()).includes(t)}async databases(){return(await this.schema()).databases(!1)}database(t,e={}){return new this.constructor.Database(this,...arguments)}async execQuery(t,e={}){if(!(t instanceof T))throw new Error("execQuery() called with invalid arguments.");let r=t.statementType==="DDL"||t.hasPaths||t.isSugar;return await this.withSchema(r,async s=>{if(t.statementType==="DDL")return await this.execDDL(t,s,e);let i={};t.renderBindings?.(e.values||[]),t.hasSugars&&(t=t.deSugar()),t.isPayloadStatement&&([i.preHook,i.postHook]=t.createExecutionPlan(a=>this.execQuery(a,{inspect:e.inspect})),await i.preHook());let o=(t.normalizeBindings?.(!0).map(a=>a.value())||[]).map(a=>Array.isArray(a)||typeof a=="object"&&a?JSON.stringify(a):a);return e.inspect&&console.log({guery:t.stringify(),values:o}),t.statementType==="DML"?i.returnValue=await this.execDML(t,o,e):t.statementType==="DQL"?i.returnValue=await this.execDQL(t,o,e):i.returnValue=await this.execSQL(t,o,e),t.isPayloadStatement&&(i.returnValue=await i.postHook(i.returnValue)),i.returnValue})}async execDDL(t,e,r,s){let i={dbAction:e,mainSavepointData:null,cascadeSavepointsData:[],returning:e.returning(),inNativeMode:["restore","replication","install","uninstall"].includes(this.#t[0])},n=await this.linkedDB();if(!i.inNativeMode&&await n.config("database_role")==="master")throw new Error("Operation rejected! Direct DDL operations on a master database not allowed.");if(!this.params.clientID&&parseInt(await n.config("require_client_ids")))throw new Error('Operation rejected! Your DB requires all client instances to have a "clientID".');if(!i.inNativeMode&&!s.desc&&parseInt(await n.config("require_commit_descs")))throw new Error('Operation rejected! Your DB requires all DDL operations to have a "desc".');if(e.hasSugars&&(e=e.deSugar()),["TABLE","VIEW"].includes(e.KIND)){if(e.CLAUSE==="RENAME"){let[a,u]=[e.reference().jsonfy(),e.argument().jsonfy()];e=Et.fromJSON(this,{kind:e.KIND,reference:a,argument:{actions:[]}}),e.add("RENAME",null,c=>c.argument(u))}else e.CLAUSE==="CREATE"&&!e.argument().prefix()&&e.argument().prefix(r.defaultDB());i.dbAction=St.fromJSON(this,{reference:(e.reference?.()||e.argument()).prefix(!0).name(),argument:{actions:[e]}})}else if(e.CLAUSE==="RENAME"){let[a,u]=[e.reference().jsonfy(),e.argument().jsonfy()];e=St.fromJSON(this,{kind:e.KIND,reference:a,argument:{actions:[]}}),e.add("RENAME",null,c=>c.argument(u)),i.dbAction=e}if(i.rootCDL=Rt.fromJSON(this,{actions:[i.dbAction]}),!i.inNativeMode&&parseInt(await n.config("auto_savepoints"))!==0){let a=r.alterWith(i.rootCDL,{diff:!0});i.dbReference=(i.dbAction.reference?.()||i.dbAction.argument()).name(),[i.mainSavepointData,i.cascadeSavepointsData]=a.databases().reduce(([u,c],h)=>h.identifiesAs(i.dbReference)?[h,c]:[u,c.concat(h.dirtyCheck(!0).length?h:[])],[null,[]])}if(s.inspect&&console.log({guery:e.stringify()}),await t(e,r,s),i.returnValue=!0,i.mainSavepointData){i.savepointInstance=await this.createSavepoint(i.mainSavepointData,{...s,masterSavepoint:null}),i.savepointInstance.$._cascades=[];for(let a of i.cascadeSavepointsData)i.savepointInstance.$._cascades.push(await this.createSavepoint(a,{...s,masterSavepoint:i.savepointInstance.id()}))}let o=this.#n({depth:2});if(o.resolvedSchema=o.resolvedSchema.alterWith(i.rootCDL,{diff:!1}),i.returning==="SCHEMA"){let a=(e.CLAUSE==="DROP"?r:o.resolvedSchema).database(this.extractPostExecName(i.dbAction));return["TABLE","VIEW"].includes(e.KIND)?a.table(this.extractPostExecName(e)):a}return i.returning==="SAVEPOINT"?i.savepointInstance||null:i.returnValue}async createSavepoint(t,e={}){let s=(await this.linkedDB()).table("savepoints"),{name:i,$name:n,version:o,...a}=t.jsonfy({nodeNames:!1}),u={master_savepoint:e.masterSavepoint,name:i,$name:n,database_tag:null,...a,version_tag:null,version_state:"commit",commit_date:m=>m.now(),commit_desc:e.desc,commit_client_id:this.params.clientID,commit_client_pid:m=>m.fn(this.params.dialect==="mysql"?"connection_id":"pg_backend_pid")},c=t.name(),h=await this.database(c).savepoint({lookAhead:!0,withCascades:!1})||await this.database(c).savepoint({withCascades:!1});h?(u.database_tag=h.databaseTag(),u.version_tag=e.masterSavepoint?0:h.versionMax()+1,!e.masterSavepoint&&h.versionState()==="rollback"&&await s.delete(m=>m.where(l=>l.eq("database_tag",p=>p.value(h.databaseTag())),l=>l.eq("version_state",p=>p.value("rollback"))))):(u.database_tag=`db.${Date.now()}`,u.version_tag=e.masterSavepoint?0:1);let d=await s.insert({data:u,returning:"*"});return new Be(this,d)}async getSavepoints(t={}){let r=(await this.linkedDB()).table("savepoints").ident,s=this.createCommonSQLUtils(),i=[`COALESCE(${s.ident("$name")}, name) AS name`,"database_tag","version_tag"],n=["master_savepoint","id","database_tag","name",s.ident("$name"),"status","version_tag","tables","version_state","commit_date","commit_desc","commit_client_id","rollback_date","rollback_desc","rollback_client_id"],o=`(SELECT ${s.jsonAgg("version_tag")} FROM ${r}
            WHERE database_tag = main_savepoint.database_tag
        ) AS version_tags`,a=`(SELECT ${s.jsonAgg("cascade")} FROM (
            SELECT ${s.jsonBuildObject(n.reduce((m,l)=>m.concat(`'${l}'`,l),[]))} AS cascade
            FROM ${r}
            WHERE master_savepoint = main_savepoint.id
        ) AS cascade_tbl_alias_unused_but_for_compat) AS cascades`,u=m=>({...m,version_tags:m.version_tags.filter(l=>l!==0).sort(),cascades:m.cascades||[]});if(t.forHistories)return(await this.query(`
                SELECT ${[...n,o,a].join(", ")} 
                FROM ${r} AS main_savepoint 
                WHERE master_savepoint IS NULL
            `)).map(u);let c=t.lite?[...i,o]:[...n,o,...t.withCascades!==!1?[a]:[]],h=[].concat(t.selector||[]),d=await this.query(`
            SELECT ${c.join(", ")} FROM (
                SELECT *,
                ROW_NUMBER() OVER (PARTITION BY database_tag ORDER BY version_state = ${t.lookAhead?"'rollback'":"'commit'"} DESC, version_tag ${t.lookAhead?"ASC":"DESC"}) AS rank_for_target,
                FROM ${r}
                WHERE master_savepoint IS NULL
            ) AS main_savepoint WHERE ${t.forState?"":`version_state = ${t.lookAhead?"'rollback'":"'commit'"} AND `}rank_for_target = 1${t.selector?t.lookAhead?` AND ${s.matchSelector("name",h)||"TRUE"}`:` AND ${s.matchSelector(`COALESCE(${s.ident("$name")}, name)`,h)||"TRUE"}`:""}
        `);return t.lite?d:d.map(m=>new Be(this,u(m)))}#e;async getPID(t){return this.#e||(this.#e=await t()),this.#e}#r=new Map;listen(t,e,r,s=!1){return this.#r.has(e)||(this.#r.set(e,new Set),t(e,async i=>{let n=await this.getPID();for(let[o,a]of this.#r.get(e))!a&&i.processId&&i.processId===n||o(i)})),this.#r.get(e).add([r,s]),this}#s=new Set;#n(t,e=!1){return[...this.#s].find(r=>{if(N(r.params)&&N(t))return Object.keys(t).every(s=>{if(s==="depth"){let[i,n]=[r.params[s]||0,t[s]||0];return e?i===n:i>=n}return r.params[s]===t[s]});if(Array.isArray(r.params)&&Array.isArray(t))return t.every(s=>r.params.find(i=>s.name===i.name&&((n,o)=>e?pt(n,o).length===n.length:!Ee(n,o).length)(Lt(s.tables),Lt(i.tables))));if(N(r.params)&&r.params.depth&&Array.isArray(t))return t.every(s=>r.resolvedSchema.database(s.name)&&(![].concat(s.tables||[]).length||r.params.depth===2))})}$capture(t,e){if(t==="ROOT_SCHEMA")return this.#n({depth:2})?.resolvedSchema}extractPostExecName(t){return t.CLAUSE==="CREATE"?t.argument().name():t.CLAUSE==="ALTER"&&t.argument().actions().find(e=>e.CLAUSE==="RENAME"&&!e.KIND)?.argument().name()||t.reference().name()}createCommonSQLUtils(){let t={ident:e=>w.fromJSON(this,e),str:e=>it.fromJSON(this,{value:e}),jsonBuildObject:e=>this.params.dialect==="mysql"?`JSON_OBJECT(${e.join(", ")})`:`JSON_BUILD_OBJECT(${e.join(", ")})`,jsonAgg:e=>this.params.dialect==="mysql"?`JSON_ARRAYAGG(${e})`:`JSON_AGG(${e})`,anyValue:e=>this.params.dialect==="mysql"?e:`MAX(${e})`,groupConcat:(e,r)=>this.params.dialect==="mysql"?`GROUP_CONCAT(${e}${r?` ORDER BY ${r}`:""} SEPARATOR ',')`:`STRING_AGG(${e}, ','${r?` ORDER BY ${r}`:""})`,matchSelector:(e,r)=>{let[s,i,n]=r.reduce(([c,h,d],m)=>/^%|^!%|%$/.test(m)?[c,h,d.concat(m)]:/^!/.test(m)?[c,h.concat(m.slice(1)),d]:[c.concat(m),h,d],[[],[],[]]),o=s.length&&!(s.length===1&&s[0]==="*")?`${e} IN (${s.map(t.str).join(", ")})`:null,a=i.length?`${e} NOT IN (${i.map(t.str).join(", ")})`:null,u=n.length?n.map(c=>/^!/.test(c)?`${e} NOT LIKE ${t.str(c.slice(1))}`:`${e} LIKE ${t.str(c)}`).join(" AND "):null;return[o,a,u].filter(c=>c).join(" AND ")}};return t}#i;async linkedDB(){let t=[async a=>{await this.withMode("install",()=>this.createDatabase({name:a,tables:[{name:"savepoints",columns:[{name:"id",...this.params.dialect==="mysql"?{type:"char(36)",default:{expr:u=>u.fn("uuid")}}:{type:"uuid",default:{expr:u=>u.fn("gen_random_uuid")}},primaryKey:!0},{name:"master_savepoint",...this.params.dialect==="mysql"?{type:"char(36)"}:{type:"uuid"},foreignKey:{targetTable:[a,"savepoints"],targetColumns:["id"],deleteRule:"CASCADE"}},{name:"name",type:["varchar",255],notNull:!0},{name:"$name",type:["varchar",255]},{name:"tables",type:"json"},{name:"status",type:["varchar",8],check:{in:["status",{value:null},{value:"new"},{value:"obsolete"}]}},{name:"database_tag",type:["varchar",30],notNull:!0},{name:"version_tag",type:"int",notNull:!0},{name:"version_state",type:["varchar",8],notNull:!0,check:{in:["version_state",{value:"commit"},{value:"rollback"}]}},{name:"commit_date",type:["timestamp",3],notNull:!0},{name:"commit_desc",type:["varchar",255]},{name:"commit_client_id",type:["varchar",255]},{name:"commit_client_pid",type:["varchar",50]},{name:"rollback_date",type:["timestamp",3]},{name:"rollback_desc",type:["varchar",255]},{name:"rollback_client_id",type:["varchar",255]},{name:"rollback_client_pid",type:["varchar",50]}]},{name:"config",columns:[{name:"id",...this.params.dialect==="mysql"?{type:"int",autoIncrement:!0}:{type:"int",identity:!0},primaryKey:!0},{name:"name",type:["varchar",100],notNull:!0,uniqueKey:!0},{name:"value",type:["varchar",255]}]}]})),this.params.dialect==="postgres"&&await this.driver.query(`
                        -- The Function
                        CREATE OR REPLACE FUNCTION fire_linked_db_event1() RETURNS trigger AS $$
                        BEGIN
                            PERFORM pg_notify('savepoints', json_build_object(
                                'action', TG_OP,
                                'body', CASE WHEN TG_OP = 'DELETE' THEN row_to_json(OLD) ELSE row_to_json(NEW) END
                            )::text);
                            RETURN NEW;
                        END;
                        $$ LANGUAGE plpgsql;
                        CREATE OR REPLACE FUNCTION fire_linked_db_event2() RETURNS trigger AS $$
                        BEGIN
                            PERFORM pg_notify('config', json_build_object(
                                'action', TG_OP,
                                'body', CASE WHEN TG_OP = 'DELETE' THEN row_to_json(OLD) ELSE row_to_json(NEW) END
                            )::text);
                            RETURN NEW;
                        END;
                        $$ LANGUAGE plpgsql;
                        -- The triggers
                        DROP TRIGGER IF EXISTS savepoints_event_trigger ON "${a}"."savepoints";
                        CREATE TRIGGER savepoints_event_trigger
                            AFTER INSERT OR UPDATE OR DELETE ON "${a}"."savepoints"
                            FOR EACH ROW EXECUTE FUNCTION fire_linked_db_event1();
                        DROP TRIGGER IF EXISTS config_event_trigger ON "${a}"."config";
                        CREATE TRIGGER config_event_trigger
                            AFTER INSERT OR UPDATE OR DELETE ON "${a}"."config"
                            FOR EACH ROW EXECUTE FUNCTION fire_linked_db_event2();
                    `)}],e=t.length,r=a=>"linked_db"+(a&&`_v${a}`||""),s=this.database(r(e));if(Object.defineProperty(s,"uninstall",{value:async a=>{let u=await this.withMode("uninstall",()=>this.dropDatabase(s.name,{cascade:a}));return this.installed=!1,u}}),Object.defineProperty(s,"config",{value:async(...a)=>{if(a.length>1||N(a[0])){let u=N(a[0])?Object.keys(a[0]).map(h=>({name:h,value:a[0][h]})):{name:a[0],value:a[1]},c=Ee(u.map(h=>h.name),["auto_savepoints","require_client_ids","require_commit_descs","database_role"]);if(c.length)throw new Error(`Invalid configs: ${c.join(", ")}`);if(this.#i)for(let h of[].concat(u))this.#i.set(h.name,h.value);return this.withSchema({depth:2,selector:"linked_db%"},async()=>await s.table("config").upsert({data:u}))}if(!this.#i)try{let u=await s.table("config").select();this.#i=new Map(u.map(c=>[c.name,c.value])),this.listen("config",c=>{let h=JSON.parse(c.payload);h.action==="DELETE"?this.#i.delete(h.body.name):this.#i.set(h.body.name,h.body.value)})}catch{this.#i=new Map}return a.length?Array.isArray(a[0])?Object.fromEntries(a[0].map(u=>[u,this.#i.get(u)])):this.#i.get(a[0]):Object.fromEntries(this.#i)}}),this.installed)return s;this.installed=!0;let n=(await this.schema({depth:1,selector:"linked_db%"})).databases(!1).find(a=>a.startsWith(r())||a==="obj_information_schema"),o=n&&/^.+?([\d]+)$/.exec(n)?.[1]||-1;if(n&&o===-1&&console.warn("Your database has a old version of Linked DB that is no longer supported. Any savepoint record in there will be retained but won't be migrated to the new Linked DB version you have now. You may file an issue on github for any assistance."),e<o)throw new Error(`Your database has a higher version of Linked DB "${o}" than this query client is designed to support "${e}". Consider upgrading this client to latest version.`);for(let a=1;a<=t.length;a++){if(a<=o)continue;let u=r(a-1),c=r(a);try{a>1&&await this.withMode("install",()=>this.alterDatabase(u,h=>h.name(c))),await t[a-1](c)}catch(h){throw console.log(!n&&a===1?`Error installing ${c}.`:`Error upgrading your Linked DB version from ${u} to ${c}. Consider filing an issue on github.`),h}}return s}};var Mr=class{constructor(t,e,r={}){this.$={database:t,name:e,params:r}}get database(){return this.$.database}get name(){return this.$.name}get ident(){return O.fromJSON(this,[this.database.name,this.name])}get params(){return Object.assign({},this.database.params,this.$.params)}async schema(){return(await this.database.schema(this.name))?.table(this.name)}async count(t,e={}){let r=await this.select({...e,shorthands:!1,fields:[{expr:{count:[t]},as:"c"}]});return Array.isArray(r)?r[0].c:r.c}async select(...t){let e=typeof t[0]!="function"&&t.shift()||{},r=typeof t[0]=="function"&&t.shift()||null,s=["string","number"].includes(typeof e.where);return this.database.client.withSchema(async()=>{let{shorthands:i,...n}={fields:"*",from:[[this.database.name,this.name]],...e};e.shorthands&&(n.fields=await this.buildShapePath(n.fields,"fields"));let o=await this.resolveWhereClause(n),a=this.createQuery(o,lt,"table.select()");r?.(a);let u=await this.database.client.execQuery(a);return s?u[0]:u})}async insert(...t){let e,r=!1;typeof t[0]=="boolean"&&(e=t.shift());let s=typeof t[0]!="function"&&{...t.shift()}||{},i=typeof t[0]=="function"&&t.shift()||null;return this.database.client.withSchema(async()=>{s.columns?(s.shorthands&&(s.columns=await this.buildShapePath(s.columns,"columns")),s.values=s.values.map(h=>({row:this.buildValueMatrix(h,s.columns,"value-matrix")}))):s.data&&(r=N(s.data)&&s.returning,[s.columns,s.values]=await this.resolvePayload([].concat(s.data),"payload"));let{data:n,shorthands:o,...a}={...s,into:[[this.database.name,this.name]]},u=this.createQuery(a,e?Zt:tt,`table.${e?"upsert":"insert"}()`);i?.(u);let c=await this.database.client.execQuery(u);return r?c[0]:c})}async upsert(...t){return await this.insert(!0,...t)}async update(...t){let e=typeof t[0]!="function"&&t.shift()||{},r=typeof t[0]=="function"&&t.shift()||null,s=["string","number"].includes(typeof e.where)&&e.returning;return this.database.client.withSchema(async()=>{let i=[e.set||e.data],[n,[{row:o}]]=await this.resolvePayload(i,e.set?"payload-array":"payload"),{data:a,shorthands:u,...c}={...await this.resolveWhereClause(e),table:[[this.database.name,this.name]],set:n.map((m,l)=>[m,o[l]])},h=this.createQuery(c,He,"table.update()");r?.(h);let d=await this.database.client.execQuery(h);return s?d[0]:d})}async delete(...t){if(!t.length)throw new Error('The "clauses" parameter cannot be ommitted.');let e=typeof t[0]!="function"&&{...t.shift()}||{},r=typeof t[0]=="function"&&t.shift()||null,s=["string","number"].includes(typeof e.where)&&e.returning;return this.database.client.withSchema(async()=>{let i={...await this.resolveWhereClause(e),from:[[this.database.name,this.name]]},n=this.createQuery(i,zt,"table.delete()");r?.(n);let o=await this.database.client.execQuery(n);return s?o[0]:o})}createQuery(t,e,r){return e.prototype.$castInputs.call(this.database.client,[t],e,null,r)}async resolveWhereClause(t){if(["string","number"].includes(typeof t.where)){let r=(await this.schema()).primaryKey()?.columns()[0];if(!r)throw new Error("Cannot resolve primary key name for implied record.");return{...t,where:{eq:[r,t.where]}}}return t}async resolvePayload(t,e){if(e==="payload-array"){if(!Array.isArray(t)||!Array.isArray(t[0]))throw new TypeError("Invalid payload format.")}else if(!N(t[0]))throw new TypeError("Invalid payload format.");let r=await this.buildShapePath(t[0],e),s=t.map(i=>({row:this.buildValueMatrix(i,r,e)}));return[r,s]}async buildShapePath(t,e){let r=await this.schema();if(!r)throw new Error(`Table ${this.ident} does not exist.`);let s=e==="fields"?"fields":"columns",i=["payload","payload-array"].includes(e),n=async(u,c,h=null)=>{if(h){if(!(await u.schema())?.column(h)?.foreignKey()?.targetTable().identifiesAs(this.ident))throw new Error(`${u.ident}.${h} isn't a reference to ${this.ident}`);return await u.buildShapePath(c,e)}let d=(await u.schema()).foreignKeys().filter(m=>m.targetTable().identifiesAs(this.ident));if(d.length!==1)throw new Error(`${d.length} correletions found between ${this.ident} and ${u.ident}`);return[d[0].columns()[0],await u.buildShapePath(c,e)]},o=async(u,c)=>{let h=r.column(u),d=h?.foreignKey();if(d&&!i&&typeof c=="string")return{rpath:[u,c]};if(d&&(N(c)||Array.isArray(c))){let m=this.database.client.database(d.targetTable().prefix(!0).name()).table(d.targetTable().name());return{rpath:[u,{[s]:await m.buildShapePath(c,e)}]}}if(!h){if(i){if(!Array.isArray(c))throw new Error(`Unknown column: ${u}`)}else Array.isArray(c)&&(c.some(S=>typeof S=="string")||c.length>1)?c=[c]:N(c)?c=[c]:typeof c=="string"&&(c=[[c]]);let m=this.database.table(u),[l,p]=await n(m,c[0]),_={[s]:p};return{rpath:[{lpath:[l,[this.database.name,u]]},e==="fields"?{expr:_}:_]}}return u},a=[];if(N(t)){for(let u in t)!i&&t[u]===!1||a.push(await o(u,t[u]));return a}for(let u of t)if(e==="payload-array")if(N(u[0])){if(!u[0].lpath)throw new Error(`Invalid key spec: ${JSON.stringify(u[0])}`);let c=[].concat(u[0].lpath[1]),d=(c.length===2?this.database.client.database(c.shift()):this.database).table(c.shift());a.push({rpath:[u[0],{columns:await n(d,u[1][0],u[0].lpath[0])}]})}else a.push(await o(u[0],u[1]));else N(u)?a.push(await o(Object.keys(u)[0],Object.values(u)[0])):a.push(u);return a}buildValueMatrix(t,e,r){let s=(a,u,c)=>r==="payload"?a[u]:r==="payload-array"?a[c][1]:a[c],i=r==="payload";if(i&&!N(t)||!i&&!Array.isArray(t))throw new Error(`Irregular payload structure: expected an object of shape ${JSON.stringify(e)} but got: ${t}`);let n=[],o=e.length;for(let a=0;a<o;a++){let u=e[a];if(u.rpath){let c=u.rpath[0],h=u.rpath[1].columns||[u.rpath[1]];if(c.lpath){let[,[,d]]=c.lpath,m=s(t,d,a);if(!Array.isArray(m))throw new Error(`Irregular payload structure: expected an array of ${d} of shape ${JSON.stringify(h)} but got: ${m}`);n.push({values:m.map(l=>({row:this.buildValueMatrix(l,h,r)}))})}else{let d=s(t,c,a);n.push({row:this.buildValueMatrix(d,h,r)})}}else{let c=s(t,u,a);n.push(Ns(c))}}return n}$capture(t,e){return this.database.$capture(t,e)}},Ns=f=>typeof f=="function"?f:f instanceof Date?t=>t.value(f.toISOString().split(".")[0]):Array.isArray(f)||N(f)?t=>t.json(f):[null,void 0].includes(f)?t=>t.literal(null):t=>t.value(f);var Jr=class{_pos=0;_eof=!1;_onfinish=[];constructor(t){this._cache=t}get eof(){return!this._cache.length||this._pos===this._cache.length-1}onfinish(t){this._onfinish.push(t)}next(){if(this.eof){this._onfinish.forEach(t=>t()),this._pos=0;return}this._pos++}async fetch(){if(!this.eof)return this._cache[this._pos]}};var Fr=class extends Jr{constructor(t){super([]),this._store=t,this._storeFetch=new Promise(async e=>{this.cache=await this._store.select(),e()})}async fetch(){return await this._storeFetch,super.fetch()}};var Yr=class extends Mr{getCursor(){return new Fr(this)}};var kr=class{constructor(t,e,r={}){Object.defineProperty(this,"$",{value:{client:t,name:e,params:r}})}get client(){return this.$.client}get name(){return this.$.name}get ident(){return U.fromJSON(this,this.name)}get params(){return Object.assign({},this.client.params,this.$.params)}async savepoint(t={}){return(await this.client.getSavepoints({...t,forState:!0,selector:this.name}))[0]}async version(){return(await this.savepoint())?.versionTag()||0}async schema(t="*"){return(await this.client.schema([{name:this.name,tables:[].concat(t)}])).database(this.name)}async createTable(t,e={}){typeof t=="string"&&(t={name:t,columns:[]});let r=yt.fromJSON(this,{kind:e.kind,argument:t});r.argument().prefix(this.name),e.ifNotExists&&r.withFlag("IF_NOT_EXISTS"),e.returning&&r.returning(e.returning);let s=await this.client.execQuery(r,e);return s===!0?this.table(r.argument().name()):s}async renameTable(t,e,r={}){let s=Xe.fromJSON(this,{kind:r.kind,reference:t,argument:e});if(!s)throw new Error("renameTable() called with invalid arguments.");s.reference().prefix(this.name),r.returning&&s.returning(r.returning);let i=await this.client.execQuery(s,r);return i===!0?this.table(e):i}async alterTable(t,e,r={}){if(typeof e!="function")throw new Error("alterTable() called with invalid arguments.");return await this.client.withSchema(async()=>{let s=await this.table(t).schema();if(!s)throw new Error(`Table "${t}" does not exist.`);let i=s.clone();await e(i.$nameLock(!0));let n=s.diffWith(i).generateCDL({cascadeRule:r.cascadeRule,existsChecks:r.existsChecks});if(!n.length)return;let o=Et.fromJSON(this,{kind:r.kind,reference:s.name(),argument:n});o.reference().prefix(this.name),r.ifExists&&o.withFlag("IF_EXISTS"),r.returning&&o.returning(r.returning);let a=await this.client.execQuery(o,r);return a===!0?this.table(this.client.extractPostExecName(o)):a})}async dropTable(t,e={}){let r=jt.fromJSON(this,{kind:e.kind,reference:t});if(!r)throw new Error("dropTable() called with invalid arguments.");return r.reference().prefix(this.name),e.ifExists&&r.withFlag("IF_EXISTS"),e.restrict?r.withFlag("RESTRICT"):e.cascade&&r.withFlag("CASCADE"),e.returning&&r.returning(e.returning),this.client.execQuery(r,e)}async hasTable(t){return(await this.tables()).includes(t)}async tables(){return(await this.schema()).tables(!1)}table(t,e={}){return new this.constructor.Table(this,...arguments)}$capture(t,e){return this.client.$capture(t,e)}};var jr=class extends kr{static Table=Yr};var Kr=class extends Ur{constructor(t,e={}){if(typeof t!="object")throw new Error("The options.driver parameter is required and must be an object.");if(typeof t.query!="function")throw new Error("The provided driver must expose a .query() function.");super(e),this.$.driver=t}get driver(){return this.$.driver}static kind="sql";static Database=jr;async schema(t){return super.schema(async e=>{let r=this.#e(e),s=await this.driver.query(r);return this.#r(s.rows||s)},...arguments)}async searchPath(t=[]){if(arguments.length){t=[].concat(t).map(o=>w.fromJSON(this,o));let n=this.params.dialect==="mysql"?`USE ${t[0]}`:`SET SEARCH_PATH TO ${t.join(",")}`;return await this.driver.query(n)}let e,r;this.params.dialect==="mysql"?(e="SELECT database() AS default_db",r="default_db"):(e="SHOW SEARCH_PATH",r="search_path",e="SELECT current_setting('SEARCH_PATH')",r="current_setting");let s=await this.driver.query(e),i=((s.rows||s)[0]||{})[r];return E.split(i,[","]).map(n=>w.parseIdent(this,n.trim())[0])}async execDQL(t,e=[],r={}){return await this.execSQL(t,e,r)}async execDML(t,e=[]){let r={hasReturnList:!!t.returning()};return this.params.dialect==="mysql"&&r.hasReturnList&&([t,r.mysqlPostHook]=await this.#t(t)),r.returnValue=await this.driver.query(t.toString(),e),r.mysqlPostHook&&(r.returnValue=await r.mysqlPostHook(r.returnValue)),r.hasReturnList?r.returnValue.rows||r.returnValue:"rowCount"in r.returnValue?r.returnValue.rowCount:r.returnValue.affectedRows}async execDDL(t,e,r={}){return await super.execDDL(async s=>await this.driver.query(s.toString()),...arguments)}async execSQL(t,e=[]){let r=await this.driver.query(t.toString(),e);return r.rows||r}async getPID(){return super.getPID(async()=>{let t=await this.driver.query(`SELECT ${this.params.dialect==="mysql"?"connection_id()":"pg_backend_pid()"} AS pid`);return(t.rows||t)[0]?.pid})}listen(t,e,r=!1){return super.listen((s,i)=>{this.driver.query(`LISTEN ${s}`),this.driver.on("notification",async n=>{n.channel===s&&i(n)})},...arguments)}async#t(t){if(t.tables().length>1)throw new Error(`The support for a "RETURNING" clause for mysql does'nt yet support muilt-table statements.`);t=t.clone();let e=t.tables()[0].expr().clone(),r=t.returning();if(t.returning(void 0),t instanceof zt){let a=await this.driver.query(`SELECT ${r} FROM ${e}${t.where()||""}`);return[t,()=>a]}let s="obj_column_for_returning_clause_support",i=w.fromJSON(this,s);e.schema().column(s)||await this.driver.query(`ALTER TABLE ${e} ADD COLUMN ${i} char(36) INVISIBLE`);let o=(0|Math.random()*9e6).toString(36);if(t.set())t.set().assignment(s,a=>a.value(o));else if(t instanceof tt){if(!t.columns()&&(t.select()||t.values()?.length))throw new Error('The support for a "RETURNING" clause for mysql currently requires explicit column list in INSERT statements.');if(t.columns().add(s),t.select())t.select().fields().add(a=>a.value(o));else if(t.values()?.length)for(let a of t.values())a.add(u=>u.value(o));else t.values(o)}return t instanceof tt&&t.onConflict()&&t.onConflict().assignment(s,a=>a.value(o)),[t,async()=>{let a=await this.driver.query(`SELECT ${r} FROM ${target} WHERE ${i} = '${o}'`);return this.params.mysqlReturningClause==="WITH_AUTO_CLEANUP"&&await this.driver.query(`ALTER TABLE ${target} DROP COLUMN ${i}`),a}]}#e(t={}){let e=this.createCommonSQLUtils(),r={fields:[],dbWhere:"",tblWhere:"",orderBy:"",depth:0};if(Array.isArray(t)){r.dbWhere=`
WHERE db.schema_name IN ('${t.map(u=>u.name).join("', '")}')`;let a=t.reduce((u,c)=>{let h=[].concat(c.tables||[]);return!h.length||h.includes("*")?u:u.concat(`WHEN '${c.name}' THEN ${e.matchSelector("tbl.table_name",h)}`)},[]);r.tblWhere=a.length?` AND CASE db.schema_name ${a.join(" ")} END`:"",r.depth=2}else{let a=[].concat(t.selector||[]);if(a.length){let u=e.matchSelector("db.schema_name",a);r.dbWhere=u?`
WHERE ${u}`:""}r.orderBy=`
ORDER BY array_position(current_schemas(false), db.schema_name)`,r.depth=t.depth||0}let s=()=>{let a={table_schema:"cols.table_schema",table_name:"cols.table_name",column_name:"cols.column_name",ordinal_position:"cols.ordinal_position",column_default:"cols.column_default",is_nullable:"cols.is_nullable",data_type:"cols.data_type",character_maximum_length:"cols.character_maximum_length",...this.params.dialect==="mysql"?{extra:"cols.extra"}:{is_identity:"cols.is_identity",identity_generation:"cols.identity_generation",identity_start:"cols.identity_start",identity_increment:"cols.identity_increment",identity_maximum:"cols.identity_maximum",identity_minimum:"cols.identity_minimum",identity_cycle:"cols.identity_cycle"},is_generated:"cols.is_generated",generation_expression:"cols.generation_expression"},u=`
                SELECT ${Object.entries(a).map(([c,h])=>`${h} AS ${c}`).join(", ")}
                FROM information_schema.columns AS cols
                WHERE cols.table_schema = tbl.table_schema AND cols.table_name = tbl.table_name
                ORDER BY cols.ordinal_position
            `;return`SELECT ${e.jsonAgg(e.jsonBuildObject(Object.keys(a).reduce((c,h)=>c.concat(`'${h}'`,`cols.${h}`),[])))} FROM (${u}) AS cols`},i=()=>{let a={table_schema:e.anyValue("cons.constraint_schema"),table_name:e.anyValue("cons.table_name"),column_name:e.groupConcat("cons_details.column_name","cons_details.ordinal_position"),constraint_name:"cons.constraint_name",constraint_type:e.anyValue("cons.constraint_type"),check_clause:e.anyValue("check_constraints_details.check_clause"),...this.params.dialect==="mysql"?{check_constraint_level:e.anyValue("check_constraints_details.level"),referenced_column_name:e.groupConcat("cons_details.referenced_column_name"),referenced_table_name:e.anyValue("cons_details.referenced_table_name"),referenced_table_schema:e.anyValue("cons_details.referenced_table_schema")}:{referenced_column_name:e.groupConcat("relation_details.column_name"),referenced_table_name:e.anyValue("relation_details.table_name"),referenced_table_schema:e.anyValue("relation_details.table_schema")},referenced_constraint_name:e.groupConcat("relation.unique_constraint_name"),match_rule:e.anyValue("relation.match_option"),update_rule:e.anyValue("relation.update_rule"),delete_rule:e.anyValue("relation.delete_rule")},u=`
                SELECT ${Object.entries(a).map(([c,h])=>`${h} AS ${c}`).join(", ")}
                FROM information_schema.table_constraints AS cons
                LEFT JOIN information_schema.key_column_usage AS cons_details
                    ON cons_details.constraint_name = cons.constraint_name
                    AND cons_details.table_name = cons.table_name
                    AND cons_details.constraint_schema = cons.constraint_schema
                    AND cons_details.constraint_catalog = cons.constraint_catalog
                LEFT JOIN information_schema.check_constraints AS check_constraints_details
                    ON check_constraints_details.constraint_name = cons.constraint_name
                    AND check_constraints_details.constraint_schema = cons.constraint_schema
                    AND check_constraints_details.constraint_catalog = cons.constraint_catalog
                LEFT JOIN information_schema.referential_constraints AS relation
                    ON relation.constraint_name = cons.constraint_name
                    AND relation.constraint_schema = cons.constraint_schema
                    AND relation.constraint_catalog = cons.constraint_catalog
                ${this.params.dialect==="mysql"?"":`
                LEFT JOIN information_schema.key_column_usage AS relation_details
                    ON relation_details.constraint_name = relation.unique_constraint_name
                    AND relation_details.constraint_schema = relation.unique_constraint_schema
                    AND relation_details.constraint_catalog = relation.unique_constraint_catalog
                    `}
                WHERE cons.table_schema = tbl.table_schema AND cons.table_name = tbl.table_name
                GROUP BY cons.constraint_name
            `;return`SELECT ${e.jsonAgg(e.jsonBuildObject(Object.keys(a).reduce((c,h)=>c.concat(`'${h}'`,`cons.${h}`),[])))} FROM (${u}) AS cons`},n=(a=!1)=>{let u={table_name:"tbl.table_name",table_schema:"tbl.table_schema"},c=`
                SELECT ${Object.entries(u).map(([d,m])=>`${m} AS ${d}`).join(", ")}
                FROM information_schema.tables AS tbl
                WHERE tbl.table_schema = db.schema_name AND tbl.table_type = 'BASE TABLE'${r.tblWhere}
            `,h=a?["'columns'",`(${s()})`,"'constraints'",`(${i()})`]:[];return`SELECT ${e.jsonAgg(e.jsonBuildObject(Object.keys(u).reduce((d,m)=>d.concat(`'${m}'`,`tbl.${m}`),[]).concat(h)))} FROM (${c}) AS tbl`};return r.fields.push("db.schema_name"),r.depth&&r.fields.push(`(${n(r.depth>1)}) AS tables`),`SELECT ${r.fields.join(", ")}
        FROM information_schema.schemata AS db
        ${r.dbWhere}${r.orderBy};`}#r(t){let e=s=>s==="character varying"?"varchar":s==="integer"?"int":s,r=(s,i=!1)=>({...i?{}:{name:s.constraint_name},targetTable:[s.referenced_table_schema,s.referenced_table_name],targetColumns:[...new Set(s.referenced_column_name.split(","))].map(n=>n.trim()),...s.match_rule!=="NONE"?{matchRule:s.match_rule}:{},updateRule:s.update_rule,deleteRule:s.delete_rule});return t.map(s=>({name:s.schema_name,tables:(s.tables||[]).map(n=>{let o=l=>{l.check_clause||(l.check_clause="");let p=new Set,_=de.parse({params:{...this.params,nodeCallback:y=>y.NODE_NAME==="COLUMN_REF"?p.add(y.name().toLowerCase()):null}},l.check_clause,null,{inspect:!1}),S=_.NODE_NAME==="PARENS"?_.exprUnwrapped().jsonfy({nodeNames:!1}):_.jsonfy({nodeNames:!1});return{...l,columns:[...p],json:S}},[a,u,c,h]=(n.constraints||[]).reduce(([l,p,_,S],y)=>y.constraint_type==="PRIMARY KEY"?[l.concat(y),p,_,S]:y.constraint_type==="UNIQUE"?[l,p.concat(y),_,S]:y.constraint_type==="FOREIGN KEY"?[l,p,_.concat(y),S]:y.constraint_type==="CHECK"&&!(this.params.dialect==="postgres"&&/^[\d_]+not_null/.test(y.constraint_name))?[l,p,_,S.concat(o(y))]:[l,p,_,S],[[],[],[],[]]),d={},m={name:n.table_name,columns:(n.columns||[]).reduce((l,p)=>{let _=p.extra?.split(",").map(S=>S.trim())||[];return l.concat({name:p.column_name,type:p.character_maximum_length?[e(p.data_type),p.character_maximum_length]:e(p.data_type),...a.length===1&&a[0].column_name===p.column_name&&(d.pKeys=a.pop())?{primaryKey:{name:d.pKeys.constraint_name}}:{},...(d.uKeys=u.filter(S=>S.column_name===p.column_name)).length===1&&(u=u.filter(S=>S!==d.uKeys[0]))?{uniqueKey:{name:d.uKeys[0].constraint_name}}:{},...(d.fKeys=c.filter(S=>S.column_name.split(",").map(y=>y.trim()).pop()===p.column_name)).length&&(c=c.filter(S=>S!==d.fKeys[0]))?{foreignKey:r(d.fKeys[0])}:{},...(d.cKeys=h.filter(S=>S.check_constraint_level!=="Table"&&S.columns.length===1&&S.columns[0]===p.column_name)).length===1&&(h=h.filter(S=>S!==d.cKeys[0]))?{check:{name:d.cKeys[0].constraint_name,expr:d.cKeys[0].check_clause,exprJson:d.cKeys[0].json}}:{},...p.is_identity==="YES"?{identity:{always:p.identity_generation==="ALWAYS"}}:{},...p.is_generated!=="NEVER"?{expression:{always:p.is_generated==="ALWAYS",expr:p.generation_expression}}:{},..._.includes("auto_increment")?{autoIncrement:!0}:{},...p.is_nullable==="NO"?{notNull:!0}:{},...p.column_default&&p.column_default!=="NULL"?{default:{expr:p.column_default}}:{},..._.includes("INVISIBLE")?{flags:["INVISIBLE"]}:{}})},[]),constraints:[],indexes:[]};return m.constraints.push(...[...a,...u,...c].map(l=>({name:l.constraint_name,type:l.constraint_type==="UNIQUE"?"UNIQUE_KEY":l.constraint_type.replace(" ","_"),columns:[...new Set(l.column_name.split(",").map(p=>p.trim()))],...l.constraint_type==="FOREIGN KEY"?r(l,!0):{}}))),m.constraints.push(...h.map(l=>({name:l.constraint_name,type:l.constraint_type,columns:l.columns,expr:l.check_clause,exprJson:l.json}))),m})}))}};self.linkedDB||(self.linkedDB={});self.linkedDB.LinkedQL={SQLClient:Kr};})();
//# sourceMappingURL=main.js.map
