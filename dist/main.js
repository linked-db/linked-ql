(()=>{function Lt(u){return u instanceof String||typeof u=="string"&&u!==null}function ht(u){return arguments.length&&(u===void 0||typeof u>"u")}function Wt(u){return typeof u=="function"}function W(u){return Wt(u)||u&&{}.toString.call(u)==="[object function]"}function g(u){return Array.isArray(u)}function Le(u){return!Lt(u)&&!ht(u.length)}function Ce(u){return u===null||u===""}function k(u){return Array.isArray(u)||typeof u=="object"&&u||Wt(u)}function ye(u){return Ce(u)||ht(u)||u===!1||u===0||k(u)&&!Object.keys(u).length}function O(u){return!Array.isArray(u)&&typeof u=="object"&&u}function jt(u,t=!0){return g(u)?u:!t&&O(u)?[u]:u!==!1&&u!==0&&ye(u)?[]:Le(u)?Array.prototype.slice.call(u):O(u)?Object.values(u):[u]}function Ct(u){return u instanceof Number||typeof u=="number"}function Nt(u){return Ct(u)||u!==!0&&u!==!1&&u!==null&&u!==""&&!isNaN(u*1)}var He=function(u,t=1,e=!0){return!Nt(t)||t<=0||(!g(u)&&O(u)&&e&&(u=Object.values(u)),!g(u))?u:u.reduce((r,s)=>g(s)||O(s)&&e?r.concat(He(g(s)?s:Object.values(s),t-1,e)):r.concat(s),[])},we=He;function yt(u,t=1){var e=0;u.forEach(s=>{e++});var r=u.slice(u.length-e,t);return arguments.length>1?r:r[0]}function it(u,t=1){return arguments.length>1?yt(u.slice().reverse(),t).reverse():yt(u.slice().reverse())}function Ne(u,...t){return t.forEach(e=>{u.indexOf(e)<0&&u.push(e)}),u}function Ke(r,t){t=t||Object.prototype,t=t&&!g(t)?[t]:t;for(var e=[],r=r;r&&(!t||t.indexOf(r)<0)&&r.name!=="default";)e.push(r),r=r?Object.getPrototypeOf(r):null;return e}function Xe(u,t){var e=[];return Ke(u,t).forEach(r=>{Ne(e,...Object.getOwnPropertyNames(r))}),e}function wt(u,t,e=!1,r=!1,s=!1){var i=0,n=u.shift();if((Nt(n)||n===!0||n===!1)&&(i=n,n=u.shift()),!u.length)throw new Error("_merge() requires two or more array/objects.");return u.forEach((o,a)=>{!k(o)&&!W(o)||(e?Xe(o):Object.keys(o)).forEach(c=>{if(t(c,n,o,a)){var f=n[c],l=o[c];if((g(f)&&g(l)||O(f)&&O(l))&&(i===!0||i>0))n[c]=g(f)&&g(l)?[]:{},wt([Nt(i)?i-1:i,n[c],f,l],t,e,r,s);else if(g(n)&&g(o))r?n[c]=l:n.push(l);else try{s?Object.defineProperty(n,c,Object.getOwnPropertyDescriptor(o,c)):n[c]=o[c]}catch{}}})}),n}function _e(...u){return wt(u,(t,e,r)=>!0,!1,!1,!1)}function Re(u){return O(u)&&Object.getPrototypeOf(u)===Object.prototype}function te(u){return u===!0||u===!1}function ge(u,t){var e=void 0;return k(u)&&Object.keys(u).forEach((r,s)=>{e!==!1&&(e=t(Nt(r)?parseFloat(r):r,u[r],s))}),e}function ke(u,t,e=!0,r=!0,s=!1,i=!1){if(g(u)&&g(t)){var n=[],o=!0;return u.forEach(a=>{if(o){var c=!1;ge(t,(f,l)=>{(!c||r&&k(a))&&(c=e(a,l),(g(c)&&!c.length||O(c)&&!Object.keys(c).length)&&(c=!1),k(c)&&r&&(a=c))}),k(c)?n.push(r?c:a):te(c)?s&&!c||!s&&c?n.push(a):i&&(o=!1):n.push(c)}}),n}if(O(u)&&O(t)){var n={},o=!0;return Object.keys(u).forEach(f=>{if(o){var l=e(u[f],t[f]);(g(l)&&!l.length||O(l)&&!Object.keys(l).length)&&(l=!1),k(l)?n[f]=r?l:u[f]:te(l)?s&&!l||!s&&l?n[f]=u[f]:i&&(o=!1):n[f]=l}}),n}}var $e=function(u,t,e=!0,r=1){if(g(u)&&g(t)&&u.length!==t.length)return!e;if(O(u)&&O(t)){var s=Object.keys(u),i=Object.keys(t);if(!s.length&&!i.length)return Re(u)&&Re(t)?e:u===t===e;if(!$e(s,i))return!e}if(r>0&&(g(u)&&g(t)||O(u)&&O(t))){var n=ke(u,t,(o,a)=>$e(o,a,e,r-1),!1,!1,!0);return g(n)?n.length===u.length&&n.length===t.length:O(n)&&O(u)?Object.keys(n).length===Object.keys(u).length&&Object.keys(n).length===Object.keys(t).length:n}return W(e)?e(u,t):Ct(u)&&Ct(t)&&isNaN(u)&&isNaN(t)?e:u===t===e},qe=$e;function Ue(u,t=[]){return wt([{},u],(e,r,s)=>{if(!W(s[e]))return W(t)?t(e):g(t)&&t.length?t.indexOf(e)>-1:!0},!1,!1,!1)}function Oe(u,t,e=null){return g(t)?u.filter(r=>e?t.filter(s=>e(r,s)).length:t.indexOf(r)!==-1):[]}var nt=class u{static lex(t,e,r={}){if(!Lt(t=t+""))throw new Error("Argument1 must be a string!");var s=c=>({delims:c.delims.slice(),options:Ue(c.options),nesting:c.nesting.slice(),maxDepth:c.maxDepth,comments:c.comments.slice(),tokens:c.tokens.slice(),matches:c.matches.slice(),matchesi:Ue(c.matchesi)});if(u.$cache[t]&&r.cache!==!1)for(var i=0;i<u.$cache[t].length;i++){var n=u.$cache[t][i];if(qe(n.delims,e))return s(n)}var o=new u(t,r),a=o.lex(e);return r.cache!==!1&&(u.$cache[t]=u.$cache[t]||[],u.$cache[t].push(a)),s(a)}static split(t,e,r){return u.lex(t,e,r).tokens}static match(t,e,r){return u.lex(t,e,r).matches}constructor(t,e){if(!Lt(t))throw new Error("Lexer requires the first argument to be a string.");this.$str=t,this.$options=e||{},this.$options.blocks||(this.$options.blocks=u.$blocks),this.$options.quotes||(this.$options.quotes=u.$quotes),this.$options.comments||(this.$options.comments=u.$comments)}lex(t,e){for(var r={delims:jt(t),options:_e(!0,{},this.$options,e||{}),nesting:[],maxDepth:0,comments:[],tokens:[],matches:[],matchesi:{}},s=0;typeof s=="number";)s=this._evalCharsAt(r,s);if(r.nesting.length)throw new Error("Error parsing the string: "+this.$str+". Unterminated blocks: "+we(r.nesting).join(", "));return r}_evalCharsAt(t,e){if(!(e>=this.$str.length)){var r=1,s={},i={},n={};if(t.openComment||(i=this._testQuotes(t,e)),t.openQuote||(s=this._testComments(t,e)),t.openComment||s.ending)if(!t.nesting.length&&!n.ending){var o=s.starting||s.ending||this.$str[e];r=o.length,this._push(t,o,"comments",s.starting)}else this._push(t,this.$str[e]);else if(t.openQuote||i.ending)this._push(t,this.$str[e]);else{if(t.options.limit&&t.matches.length===t.options.limit)return this._push(t,this.$str[e]),e+1;n=this._testNesting(t,e);var n=this._testNesting(t,e),a=this._testChars(t.options.stopChars||[],t,e);if(!t.nesting.length&&a!==!1){t.options.stopChar=a,t.options.stopCharForward=this.$str.substr(e);return}if(!t.delims.length)t.nesting.length===2&&n.starting?(t.matches.push(null),this._push(t,n.starting),r=n.starting.length):!t.nesting.length&&n.ending?(this._push(t,n.ending),r=n.ending.length,t.matches.push(null)):this._push(t,this.$str[e]);else if(!t.nesting.length&&!n.ending){this._push(t,"");var c=this._testChars(t.delims,t,e);if(c!==!1&&(t.matches.push(c),t.matchesi[e]=c,r=c.length||1,!t.options.preserveDelims)){var f=e+(c.length||1);return f===this.$str.length&&this._push(t,""),f}this._push(t,c||this.$str[e])}else{var o=n.starting||n.ending||this.$str[e];r=o.length,this._push(t,o)}}return e+r}}_testQuotes(t,e){var r={};return(t.options.quotes||[]).forEach(s=>{this.$str.substr(e,1)===s&&(t.openQuote?s===t.openQuote&&(t.openQuote=!1,r.ending=s):(t.openQuote=s,r.starting=s))}),r}_testComments(t,e){var r={};return(t.options.comments||[]).forEach(s=>{if(t.openComment){if(it(s)===it(t.openComment)){var n=it(s);this.$str.substr(e).startsWith(n)&&(t.openComment=!1,r.ending=n)}}else{var i=yt(s);this.$str.substr(e).startsWith(i)&&(t.openComment=s,r.starting=i)}}),r}_testNesting(t,e){var r={};return(t.options.blocks||[]).forEach(s=>{let i=yt(s),n;if(i instanceof RegExp?[n]=i.exec(this.$str.substr(e))||[]:this.$str.substr(e).startsWith(i)&&(n=i),n)t.nesting=t.nesting.concat([s]),r.starting=n;else if(t.nesting.length&&it(s)===it(it(t.nesting))){var o=it(s),a;o instanceof RegExp?[a]=o.exec(this.$str.substr(e))||[]:this.$str.substr(e).startsWith(o)&&(a=o),a&&(t.nesting=t.nesting.slice(0,-1),r.ending=a)}}),t.maxDepth=Math.max(t.maxDepth,t.nesting.length),r}_testChars(t,e,r){for(var s=0;s<t.length;s++){let o={useRegex:e.options.useRegex,ci:e.options.ci,...O(t[s])?t[s]:{test:t[s]}};if(W(o.test)){var i=o.test(this.$str.substr(0,r),this.$str.substr(r),e.tokens.slice());if(i!==!1)return i;continue}if(o.useRegex){let c=o.useRegex!==!0?o.useRegex:"";var n=this.$str.substr(r).match(new RegExp("^"+o.test,c));if(n&&(!o.backtest||this.$str.substr(0,r).match(new RegExp(o.backtest,c))))return n[0];continue}let a=(c,f)=>o.ci?c.toLowerCase()===f.toLowerCase():c===f;if(a(this.$str.substr(r,o.test.length),o.test)&&(!o.backtest||a(this.$str.substr(r-o.backtest.length,r),o.backtest)))return o.test}return!1}_push(t,e,r="tokens",s=!1){var i=t.matches.length;if(ht(t.tokens[i])&&(t.tokens[i]=""),r==="comments"){t.tokens[i].comments||(t.tokens[i]=new String(t.tokens[i]),t.tokens[i].comments=[]);var n=t.tokens[i].comments.length-(!t.tokens[i].comments.length||s?0:1);t.tokens[i].comments[n]=(t.tokens[i].comments[n]||"")+e}else{var o=t.tokens[i].comments;t.tokens[i]=t.tokens[i]+e}}split(t,e,r){return this.lex(e,r).tokens}match(t,e,r){return this.lex(e,r).matches}regParse(t,e){return this.lex(t,_e({useRegex:!0},e||{}))}regSplit(t,e){return this.regParse(t,e).tokens}regMatch(t,e){return this.regParse(t,e).matches}};nt.$blocks=[["(",")"],["[","]"],["{","}"]];nt.$quotes=['"',"'","`"];nt.$comments=[["/*","*/"],["//",`
`]];nt.$cache=Object.create(null);var h=class extends nt{static $blocks=[...nt.$blocks,[new RegExp("^CASE ","i"),new RegExp("^ END","i")]]};var T=class u{CONTEXT;FLAGS=[];constructor(t){this.CONTEXT=t;let e=this.statementNode;e===this&&(e=e.CONTEXT?.statementNode),e?.connectedNodeCallback?.(this)}get params(){return this.CONTEXT?.params||{}}get rootNode(){return this.CONTEXT instanceof u?this.CONTEXT.rootNode:this}get statementNode(){return this.CONTEXT instanceof u?this.CONTEXT.statementNode:null}get quoteChars(){return this.constructor.getQuoteChars(this)}static getQuoteChars(t,e=!1){return(e&&t?.params?.inputDialect||t?.params?.dialect)==="mysql"&&!t.params.ansiQuotes?["'",'"']:["'"]}get escChar(){return this.constructor.getEscChar(this)}autoEsc(t){let e=(Array.isArray(t)?t:[t]).map(r=>r&&!/^(\*|[\w]+)$/.test(r)?`${this.escChar}${r.replace(new RegExp(this.escChar,"g"),this.escChar.repeat(2))}${this.escChar}`:r);return Array.isArray(t)?e:e[0]}static autoUnesc(t,e,r=!1){let s=this.getEscChar(t,r);return(e||"").replace(new RegExp(s+s,"g"),s)}static getEscChar(t,e=!1){return(e&&t?.params?.inputDialect||t?.params?.dialect)==="mysql"&&!t.params.ansiQuotes?"`":'"'}static parseIdent(t,e,r=!1){let s=this.getEscChar(t,r),i=h.split(e,["."]),n=i.map(a=>new RegExp(`^(?:(\\*|[\\w]+)|(${s})((?:\\2\\2|[^\\2])+)\\2)$`).exec(a.trim())).filter(a=>a);if(n.length!==i.length)return;let o=a=>a?.[1]||this.autoUnesc(t,a?.[3]);return[o(n.pop()),o(n.pop())]}with(t){for(let e in t)this[e]=t[e];return this}withFlag(...t){return t=new Set(t.filter(e=>e)),this.FLAGS=this.FLAGS.reduce((e,r)=>{let s=r.split(":");for(let i of t){let n=i.split(":");n[0]===s[0]&&(r=[...new Set([...s,...n])].join(":"),t.delete(i))}return e.concat(r)},[]).concat(...t),this}getFlag(t){let e=t.toUpperCase().split(":");return this.FLAGS.find(r=>{let s=r.split(":");return e[0]===s[0]&&e.every(i=>s.includes(i))})}hasFlag(t){return!!this.getFlag(t)}build(t,e,r,s){let i=Array.isArray(r)?r:r?[r]:[];if(!i.length)throw new Error("At least one node type must be defined.");let n=a=>i.reduce((c,f)=>c||(a instanceof f?a:f.fromJson(this,a)),null),o=(...a)=>{for(let c of a)Array.isArray(this[t])?this[t].push(c):this[t]=c};if(e.length===1&&typeof e[0]!="function"){let a=n(e[0]);if(a)return o(a)}if(s){if(i.length!==1)throw new Error("To support argument delegation, number of node types must be 1.");let a=this[t]&&!Array.isArray(this[t])?this[t]:new i[0](this);return o(a),a[s](...e)}for(let a of e){if(typeof a=="function"){if(this[t]&&!Array.isArray(this[t])){a(this[t]);continue}if(i.length===1){let l=new i[0](this);o(l),a(l);continue}let f=l=>(...m)=>{let p=i.reduce((E,A)=>E||(A.factoryMethods?typeof A.factoryMethods[l]=="function"&&A.factoryMethods[l](this,...m):typeof A.prototype[l]=="function"&&new A(this)),null);if(!p)throw new Error(`Unknow method: ${l}()`);if(o(p),p[l])return p[l](...m);for(let E of m)E(p)};a(new Proxy({},{get:(l,m)=>f(m)}));continue}let c=n(a);if(c){o(c);continue}throw new Error(`Arguments must be of type ${i.map(f=>f.name).join(", ")} or a JSON equivalent. Recieved: ${typeof a=="object"&&a?a.constructor.name:typeof a}`)}}clone(){return this.constructor.fromJson(this.CONTEXT,this.toJson())}static parse(t,e,r=null){}toString(){return this.stringify()}static fromJson(t,e){}toJson(){return{}}};var _=class extends T{BASENAME;NAME;name(t){let e=Array.isArray(t)?[...t]:[t];if(this.NAME=e.pop(),this.BASENAME=e.pop(),e.length)throw new Error(`Idents can be maximum of two parts. Recieved: ${e.reverse().join(".")}.${this.BASENAME}.${this.NAME}`);return this}toJson(){let t=this.BASENAME?[this.BASENAME,this.NAME]:this.NAME;return this.FLAGS.length?{name:t,flags:this.FLAGS}:t}static fromJson(t,e){if(typeof e=="string"||Array.isArray(e)&&e.every(s=>typeof s=="string"))e={name:e};else if(typeof e?.name!="string"&&!Array.isArray(e?.name))return;let r=new this(t).withFlag(...e?.flags||[]);return r.name(e.name),r}stringify(){return this.autoEsc([this.BASENAME,this.NAME].filter(t=>t)).join(".")+""}static parse(t,e){let[r,s]=this.parseIdent(t,e,!0)||[];if(!r)return;let i=new this(t);return i.name(s?[s,r]:r),i}};function Ie(u,t,e=!1){if(t=="")return u;var r=e?u.lastIndexOf(t):u.indexOf(t);return r===-1?"":u.substr(r+t.length)}function be(u,t,e=!1){if(t=="")return u;var r=e?u.lastIndexOf(t):u.indexOf(t);return r===-1?u:u.substr(0,r)}function Me(u,t){return be(u,t,!0)}function ee(u,t){return u===void 0?"":u.split(/(?=[A-Z])/).join(t||" ")}function xe(u,t){return typeof u!="string"?u:u.replace(/\w\S*/g,function(e){return e.charAt(0).toUpperCase()+(typeof t!==void 0&&t?e.substr(1).toLowerCase():e.substr(1))})}function Pe(u,t){return u=xe(u.replace(/-/g," ")).replace(/ /g,""),t?u:u[0].toLowerCase()+u.substr(1)}function w(u,t,e){return Me(Ie(u,t),e)}function B(u,t,e){return u.startsWith(t)&&u.endsWith(e)}var Y=class extends T{NAME;PRECISION;TZ;constructor(t,e,r,s){super(t),this.NAME=e,this.PRECISION=r,this.TZ=s}toJson(){return this.PRECISION?{name:this.NAME,precision:this.PRECISION,...this.TZ?{tz:this.TZ}:{}}:this.NAME}static fromJson(t,e){if(typeof e=="string"&&(e={name:e}),!(typeof e=="object"&&e)||typeof e.name!="string")return;let r=e.name+(e.precision?`(${e.precision})`:""),[s,i]=Qe(r);if(s)return new this(t,s,i)}stringify(){return`${this.NAME}${this.PRECISION?`(${this.PRECISION})`:""}${this.TZ?` ${this.TZ}`:""}`}static parse(t,e){let[r,s,i=""]=Qe(e);if(r)return new this(t,r.toUpperCase(),s,i.trim().replace(/\s+/," ").toUpperCase())}static pgFixedTypesRe=/(bigint|int8|bigserial|serial8|boolean|bool|box|bytea|cidr|circle|date|double\s+precision|float8|inet|integer|int|int4|jsonb|json|line|lseg|macaddr8|macaddr|money|path|pg_lsn|pg_snapshot|point|polygon|real|float4|smallint|int2|smallserial|serial2|serial4|serial|text|timetz|timestamptz|tsquery|tsvector|txid_snapshot|uuid|xml)/;static pgVariableTypesRe=/(bit\s+varying|bit|varbit|character\s+varying|character|char|varchar|interval|numeric|timestamp|time)(?:\s+)?(?:\(([\d, ]+)\))?(\s+(?:with|without)\s+time\s+zone)?/;static myFixedTypesRe=/(tinyint|smallint|mediumint|enum|set|tinyblob|mediumblob|longblob|geometry|longstring|geometrycollection|multilinestring|multipoint|multipolygon)/;static myVariableTypesRe=/(float|decimal|double|tinytext|mediumtext|longtext|binary|varbinary|blob)(?:\s+)?(?:\(([\d, ]+)\))?/},Qe=u=>{let t,e,r;for(let s of["pgFixedTypesRe","pgVariableTypesRe","myFixedTypesRe","myVariableTypesRe"])if([,t,e,r]=u.match(new RegExp(Y[s].source,"i"))||[],t)break;return[t,e,r]};var tt=class extends T{NAME;$NAME;KEEP;static get TYPE(){return ee(this.name.replace(/\d/g,""),"_").toUpperCase()}get TYPE(){return this.constructor.TYPE}static get WRITABLE_PROPS(){return["NAME"]}static get SUBTREE_PROPS(){return[]}get WRITABLE_PROPS(){return this.constructor.WRITABLE_PROPS}get SUBTREE_PROPS(){return this.constructor.SUBTREE_PROPS}name(t){return arguments.length?(this[this.smartKey("NAME",!0)]=t,this):this[this.smartKey("NAME")]}smartKey(t,e=!1){if(this.keep()===!0)return e||De(this[`$${t}`])?`$${t}`:t;if(this.keep()===!1){let r=this.TYPE instanceof T?this.constructor.TYPE:this.TYPE;if(e)throw new Error(`Cannot alter ${r} after having been dropped.`);return t}return t}hardSet(...t){let e=t.pop();if(t.length){let i=t[0],n=()=>{if(this.keep()===!1){let o=this.TYPE instanceof T?this.constructor.TYPE:this.TYPE;throw new Error(`Diffing cannot be done on a node ${o} after having been dropped.`)}else typeof this.keep()!="boolean"&&this.keep(!0);return e(i)};return typeof this.CONTEXT?.hardSet=="function"?this.CONTEXT.hardSet(i,n):De(i)?n():void 0}let r=this.KEEP;this.KEEP=null;let s=e();return this.KEEP=r,s}keep(t,e=!1){if(!arguments.length)return this.KEEP;if(![void 0,!0,!1].includes(t))throw new Error(`Status can only be true, false, or undefined. Received: ${t}`);if(this.KEEP=t,e)for(let r of this.SUBTREE_PROPS.reduce((s,i)=>[...s,...this[i]],[]))t!==!0?r.keep(void 0,!0):r.keep(e==="auto"?r.keep():!0,e);return this}drop(){return this.keep(!1)}dropped(){return this.keep()===!1||this.CONTEXT?.dropped?.()}reverseAlt(t=!1){if(this.keep()===!0){for(let e of this.WRITABLE_PROPS)if(De(this[`$${e}`])){let r=this[e];this[e]=this[`$${e}`],this[`$${e}`]=r}}else this.keep()===!1?this.keep(void 0):typeof this.keep()!="boolean"&&this.keep(!1);if(t)for(let e of this.SUBTREE_PROPS.reduce((r,s)=>[...r,...this[s]],[]))e.reverseAlt(t)}toJson(){return{...this.NAME?{name:this.NAME}:{},...this.$NAME?{$name:this.$NAME}:{},...typeof this.KEEP=="boolean"?{keep:this.KEEP}:{},...this.FLAGS.length?{flags:[...this.FLAGS]}:{}}}static fromJson(t,e,r=null){if(e?.name&&typeof e.name!="string"||e.$name&&typeof e.$name!="string")return;let s=r?r():new this(t);return s.hardSet(()=>s.name(e.name)),s.hardSet(e.$name,i=>s.name(i)),typeof e.keep=="boolean"&&s.keep(e.keep),e.flags&&s.withFlag(...e.flags),s}},De=u=>Array.isArray(u)?u.length:typeof u=="object"&&u?Object.keys(u).length:![void 0,null,""].includes(u);var b=class extends tt{static get WRITABLE_PROPS(){return["TYPE"].concat(super.WRITABLE_PROPS)}toJson(){let t={type:this.TYPE,...super.toJson()};return!("name"in t)&&["PRIMARY_KEY","FOREIGN_KEY","UNIQUE_KEY","CHECK"].includes(t.type)&&(t={...t,name:void 0}),t}static fromJson(t,e,r=null){if(e?.type===this.TYPE)return!("name"in e)&&["PRIMARY_KEY","FOREIGN_KEY","UNIQUE_KEY","CHECK"].includes(e.type)&&(e={...e,name:`auto_name_${(0|Math.random()*9e6).toString(36)}`}),super.fromJson(t,e,r)}stringify(){return this.TYPE==="AUTO_INCREMENT"?this.TYPE:`${this.stringifyName()}${this.TYPE.replace("_"," ")}`}static parse(t,e){let{name:r,expr:s}=this.parseName(t,e,!0);if(!(!s||!new RegExp(`^${this.TYPE==="AUTO_INCREMENT"?this.TYPE:this.TYPE.replace("_","\\s+")}$`,"i").test(s)))return new this(t).name(r)}stringifyName(){return this.name()?`CONSTRAINT ${this.autoEsc(this.name())} `:""}static parseName(t,e,r=!1){let i=`(?:CONSTRAINT(?:\\s+(\\w+)|\\s+(${this.getEscChar(t,r)})((?:\\2\\2|[^\\2])+)\\2)\\s+)?`,[,n,,o,a=""]=e.match(new RegExp(`^${i}([\\s\\S]+)$`,"i"))||[];return{name:n||this.autoUnesc(t,o),expr:a.trim()}}static parseColumns(t,e,r=!1){return h.split(w(e,"(",")"),[","]).map(s=>this.parseIdent(t,s.trim(),r)[0])}};var $t=class extends b{ALWAYS;$ALWAYS;static get WRITABLE_PROPS(){return["ALWAYS"].concat(super.WRITABLE_PROPS)}always(t){return arguments.length?(this[this.smartKey("ALWAYS",!0)]=!!t,this):this[this.smartKey("ALWAYS")]}toJson(){return{always:!!this.ALWAYS,...typeof this.$ALWAYS=="boolean"?{$always:this.$ALWAYS}:{},...super.toJson()}}static fromJson(t,e){return super.fromJson(t,e,()=>{let r=new this(t).always(e.always);return r.hardSet(e.$always,s=>r.always(s)),r})}stringify(){return this.params.dialect==="mysql"?new Ut(this.CONTEXT).stringify():`GENERATED ${this.always()?"ALWAYS":"BY DEFAULT"} AS IDENTITY`}static parse(t,e){let{name:r,expr:s}=this.parseName(t,e,!0);if(!(!s||!(s=s.match(new RegExp("^GENERATED\\s+(ALWAYS|BY[ ]+DEFAULT)(?:\\s+AS\\s+IDENTITY)?$","i"))?.[1])))return new this(t).name(r).always(/^ALWAYS$/i.test(s))}};var Ut=class extends b{static get TYPE(){return"AUTO_INCREMENT"}stringify(){return this.params.dialect!=="mysql"?new $t(this.CONTEXT).stringify():"AUTO_INCREMENT"}};var mt=class extends b{EXPR;$EXPR;static get WRITABLE_PROPS(){return["EXPR"].concat(super.WRITABLE_PROPS)}expr(t){return arguments.length?(this[this.smartKey("EXPR",!0)]=t,this):this[this.smartKey("EXPR")]}toJson(){return{expr:this.EXPR,...[void 0,null].includes(this.$EXPR)?{}:{$expr:this.$EXPR},...super.toJson()}}static fromJson(t,e){if(![void 0,null].includes(e?.expr))return super.fromJson(t,e,()=>{let r=new this(t).expr(e.expr);return r.hardSet(e.$expr,s=>r.expr(s)),r})}stringify(){return`${super.stringify()} (${this.expr()})`}static parse(t,e){let{name:r,expr:s}=this.parseName(t,e,!0);return!s||!(s=s.match(new RegExp(`^${this.TYPE}\\s+([\\s\\S]+)$`,"i"))?.[1])?void 0:new this(t).expr(B(s.trim(),"(",")")?w(s.trim(),"(",")"):s).name(r)}};var re=class extends mt{stringify(){return`GENERATED ALWAYS AS (${this.expr()})${this.params.dialect!=="mysql"?" STORED":""}`}static parse(t,e){let{name:r,expr:s}=this.parseName(t,e,!0);if(!(!s||!(s=s.match(new RegExp("^GENERATED\\s+ALWAYS\\s+AS\\s+\\(([\\s\\S]+)\\)(?:\\s+STORED)?$","i"))?.[1])))return new this(t).name(r).expr(s)}};var se=class extends mt{};var ie=class extends b{};var bt=class extends b{};var et=class extends b{TARGET_TABLE;$TARGET_TABLE;TARGET_COLUMNS=[];$TARGET_COLUMNS=[];MATCH_RULE;$MATCH_RULE;UPDATE_RULE;$UPDATE_RULE;DELETE_RULE;$DELETE_RULE;static get WRITABLE_PROPS(){return["TARGET_TABLE","TARGET_COLUMNS","MATCH_RULE","UPDATE_RULE","DELETE_RULE"].concat(super.WRITABLE_PROPS)}targetTable(t){return arguments.length?(this.build(this.smartKey("TARGET_TABLE",!0),[t],_,"name"),this):this[this.smartKey("TARGET_TABLE")]}targetColumns(t){return arguments.length?(this[this.smartKey("TARGET_COLUMNS",!0)]=[].concat(t),this):this[this.smartKey("TARGET_COLUMNS")]}matchRule(t){return arguments.length?(this[this.smartKey("MATCH_RULE",!0)]=t,this):this[this.smartKey("MATCH_RULE")]}updateRule(t){return arguments.length?(this[this.smartKey("UPDATE_RULE",!0)]=t,this):this[this.smartKey("UPDATE_RULE")]}deleteRule(t){return arguments.length?(this[this.smartKey("DELETE_RULE",!0)]=t,this):this[this.smartKey("DELETE_RULE")]}toJson(){return{targetTable:this.TARGET_TABLE.toJson(),...this.$TARGET_TABLE?{$targetTable:this.$TARGET_TABLE.toJson()}:{},targetColumns:this.TARGET_COLUMNS,...this.$TARGET_COLUMNS.length?{$targetColumns:this.$TARGET_COLUMNS}:{},...this.MATCH_RULE?{matchRule:this.MATCH_RULE}:{},...this.$MATCH_RULE?{$matchRule:this.$MATCH_RULE}:{},...this.UPDATE_RULE?{updateRule:this.UPDATE_RULE}:{},...this.$UPDATE_RULE?{$updateRule:this.$UPDATE_RULE}:{},...this.DELETE_RULE?{deleteRule:this.DELETE_RULE}:{},...this.$DELETE_RULE?{$deleteRule:this.$DELETE_RULE}:{},...super.toJson()}}static fromJson(t,e,r=null){if(!(!e?.targetTable||!e.targetColumns?.length))return super.fromJson(t,e,()=>{let s=r?r():new this(t);return s.hardSet(()=>s.targetTable(e.targetTable)),s.hardSet(()=>s.targetColumns(e.targetColumns)),s.hardSet(()=>s.matchRule(e.matchRule)),s.hardSet(()=>s.updateRule(e.updateRule)),s.hardSet(()=>s.deleteRule(e.deleteRule)),s.hardSet(e.$targetTable,i=>s.targetTable(i)),s.hardSet(e.$targetColumns,i=>s.targetColumns(i)),s.hardSet(e.$matchRule,i=>s.matchRule(i)),s.hardSet(e.$updateRule,i=>s.updateRule(i)),s.hardSet(e.$deleteRule,i=>s.deleteRule(i)),s})}stringify(){let t=this.targetTable();if(!t.BASENAME){let s=this.statementNode.basename()||(this.statementNode.CONTEXT instanceof T?this.statementNode.CONTEXT.name():this.statementNode.CONTEXT?.name);t=t.clone().name([s,t.NAME])}let e=`${this.stringifyName()}REFERENCES ${t} (${this.autoEsc(this.targetColumns()).join(", ")})`,r=s=>typeof s=="object"&&s?`${s.rule} (${s.columns.join(", ")})`:s;return this.matchRule()&&(e+=` MATCH ${this.matchRule()}`),this.updateRule()&&(e+=` ON UPDATE ${r(this.updateRule())}`),this.deleteRule()&&(e+=` ON DELETE ${r(this.deleteRule())}`),e}static parse(t,e){let{name:r,expr:s}=this.parseName(t,e,!0);if(!s||!(s=s.match(/^REFERENCES\s+([\s\S]+)$/i)?.[1]))return;let[i,n,o=""]=h.split(s,[]),[a,c]=this.parseIdent(t,i.trim(),!0),f=h.split(w(n,"(",")"),[","]).map(m=>this.parseIdent(t,m.trim(),!0)[0]),l=(m,p)=>{if(p==="MATCH")return m.match(/MATCH\s+(\w+)/i)?.[1];let E=/(NO\s+ACTION|RESTRICT|CASCADE|(SET\s+NULL|SET\s+DEFAULT)(?:\s+\(([^\)]+)\))?)/,[,A,d,N]=m.match(new RegExp(`ON\\s+${p}\\s+${E.source}`,"i"))||[];return d?N?{rule:d,columns:N.split(",").map(S=>S.trim())}:d:A};return new this(t).name(r).targetTable(c?[c,a]:a).targetColumns(f).matchRule(l(o,"MATCH")).updateRule(l(o,"UPDATE")).deleteRule(l(o,"DELETE"))}};var Mt=class extends b{stringify(){return`${this.stringifyName()}UNIQUE`}static parse(t,e){let{name:r,expr:s}=this.parseName(t,e,!0);if(!(!s||!/^UNIQUE(\s+KEY)?$/i.test(s)))return new this(t).name(r)}};var Et=class extends mt{};var $=class extends tt{TYPE;$TYPE;CONSTRAINTS=[];static get WRITABLE_PROPS(){return["TYPE"].concat(super.WRITABLE_PROPS)}static get SUBTREE_PROPS(){return["CONSTRAINTS"]}static CONSTRAINT_TYPES=[Ut,$t,re,se,ie,bt,et,Mt,Et];type(t){return arguments.length?(this.build(this.smartKey("TYPE",!0),[t],Y),this):this[this.smartKey("TYPE")]}autoIncrement(t=null){return this.constraint("AUTO_INCREMENT",...arguments)}identity(t=null){return this.constraint("IDENTITY",...arguments)}expression(t=null){return this.constraint("EXPRESSION",...arguments)}default(t=null){return this.constraint("DEFAULT",...arguments)}notNull(t=null){return this.constraint("NOT_NULL",...arguments)}primaryKey(t=null){return this.constraint("PRIMARY_KEY",...arguments)}foreignKey(t=null){return this.constraint("FOREIGN_KEY",...arguments)}uniqueKey(t=null){return this.constraint("UNIQUE_KEY",...arguments)}check(t=null){return this.constraint("CHECK",...arguments)}constraint(t,e=null){let r=this.CONSTRAINTS.find(s=>s.TYPE===t);if(arguments.length===1)return r;if(e){if(r){if(e===!0||!Object.keys(e).length)return;throw new Error(`${t} already exists in column. Granular modification of a constraint must be done on an instance of the contraint itself.`)}return this.build("CONSTRAINTS",[{type:t,...typeof e=="object"?e:typeof e=="string"?{expr:e}:{}}],this.constructor.CONSTRAINT_TYPES),this.constraint(t)}return r&&r.drop(),this}toJson(){let t={type:this.TYPE.toJson(),...this.$TYPE?{$type:this.$TYPE.toJson()}:{}};for(let e of this.CONSTRAINTS){let{type:r,...s}=e.toJson(),i=r==="FOREIGN_KEY"?"references":Pe(r.toLowerCase().replace("_"," ")),n=Object.keys(s),o=n.length===1?s[n[0]]:null,a=n.length?o===!1&&n[0]==="keep"?!1:n.length===1&&n[0]==="expr"?o:s:!0;t={...t,[i]:a}}return{...t,...super.toJson()}}static fromJson(t,e){let{type:r,$type:s,name:i,$name:n,keep:o,...a}=e;if(Y.fromJson({},r))return super.fromJson(t,e,()=>{let c=new this(t);c.type(Y.fromJson(c,r)),c.hardSet(s,l=>c.type(Y.fromJson(c,l)));let f=Object.entries(a).reduce((l,[m,p])=>{if([void 0,null].includes(p))return l;if(!["boolean","number","string"].includes(typeof p)&&!(typeof p=="object"&&p))throw new Error(`Invalid value for constraint "${m}": ${p}`);let E={...p===!1?{keep:!1}:p===!0?{}:["number","string"].includes(typeof p)?{expr:p}:p};return m.startsWith("$")&&(E=Object.fromEntries(Object.entries(E).map(([A,d])=>[`$${A}`,d])),m=m.slice(1)),m==="references"&&(m="foreignKey"),m in l?Object.assign(l[m],E):l[m]=E,l},{});for(let l in f)c.constraint(ee(l,"_").toUpperCase(),f[l]);return c})}stringify(){let t=this.CONSTRAINTS;return this.params.dialect==="mysql"&&(t=t.filter(e=>e.TYPE!=="FOREIGN_KEY")),`${this.autoEsc(this.name())} ${this.type()}${t.length?` ${t.join(" ")}`:""}`}static parse(t,e,r){let[s,i]=h.split(e,["\\s+"],{useRegex:!0,limit:1}),[n]=this.parseIdent(t,s.trim(),!0)||[];if(!n)return;let o=new this(t).name(n),a="(CONSTRAINT\\s+.+?\\s+)?",c=[{test:`${a}(PRIMARY[ ]+KEY|NOT[ ]+NULL|GENERATED|REFERENCES|UNIQUE(?:[ ]+KEY)?|CHECK|AUTO_INCREMENT)`},{backtest:"^(?!.*\\s+(NOT|SET)\\s+$)",test:`${a}NULL`},{backtest:"^(?!.*\\s+BY\\s+$)",test:`${a}DEFAULT`}],[f,...l]=h.split(i,c,{useRegex:"i",preserveDelims:!0});o.type(r(o,f.trim(),[Y]));for(let m of l){let p=r(o,m,this.CONSTRAINT_TYPES);o.build("CONSTRAINTS",[p],this.CONSTRAINT_TYPES)}return o}};var K=class extends tt{TYPE;$TYPE;COLUMNS=[];$COLUMNS=[];static get WRITABLE_PROPS(){return["TYPE","COLUMNS"].concat(super.WRITABLE_PROPS)}type(t){return arguments.length?(this[this.smartKey("TYPE",!0)]=t,this):this[this.smartKey("TYPE")]}columns(t){return arguments.length?(this[this.smartKey("COLUMNS",!0)]=[].concat(t),this):this[this.smartKey("COLUMNS")]}toJson(){return{type:this.TYPE,...this.$TYPE?{$type:this.$TYPE}:{},columns:this.COLUMNS,...this.$COLUMNS.length?{$columns:this.$COLUMNS}:{},...super.toJson()}}static fromJson(t,e){if(!(typeof e?.type!="string"||!/^(INDEX|KEY|FULLTEXT)$/i.test(e.type)||!e.columns?.length))return super.fromJson(t,e,()=>{let r=new this(t).columns(e.columns).type(e.type);return r.hardSet(e.$columns,s=>r.columns(s)),r.hardSet(e.$type,s=>r.type(s)),r})}stringify(){return`${this.type()}${this.name()?` ${this.name()}`:""} (${this.columns().join(", ")})`}static parse(t,e){let[r,s,i]=/^((?:(?:FULLTEXT|SPATIAL)(?:\s+INDEX|\s+KEY)?)|(?:INDEX|KEY))([\s\S]+)$/i.exec(e)||[];if(!r)return;let[n,o]=h.split(i,[]),[a]=this.parseIdent(t,n.trim(),!0),c=h.split(w(o,"(",")"),[","]).map(f=>this.parseIdent(t,f.trim(),!0)[0]);return new this(t).type(s.replace(/\s+(INDEX|KEY)/i,"").toUpperCase()).columns(c).name(a)}};var H=class u extends T{TYPE="";REFERENCE=null;ARGUMENT=null;rename(t){return this.TYPE="RENAME",this.ARGUMENT=t,this}move(t){return this.TYPE="MOVE",this.ARGUMENT=t,this}drop(t){return this.TYPE="DROP",this.ARGUMENT=t,this}new(t){return this.TYPE="NEW",this.ARGUMENT=t,this}set(t){return this.TYPE="SET",this.ARGUMENT=t,this}alter(t,e){return this.TYPE="ALTER",this.REFERENCE=t,this.build("ARGUMENT",[e],u),this}change(t,e){return this.TYPE="CHANGE",this.REFERENCE=t,this.ARGUMENT=e,this}owner(t){return this.TYPE="OWNER",this.ARGUMENT=t,this}toJson(){return{type:this.TYPE,...this.REFERENCE?{reference:this.REFERENCE}:{},argument:typeof this.ARGUMENT?.toJson=="function"?this.ARGUMENT.toJson():this.ARGUMENT,...this.FLAGS.length?{flags:this.FLAGS}:{}}}static fromJson(t,e){if(typeof e?.type!="string"||!e.argument)return;let r=new this(t).withFlag(...e.flags||[]);if(["RENAME","MOVE"].includes(e.type))return r[e.type==="RENAME"?"rename":"move"](e.argument),r;if(["DROP","NEW","SET"].includes(e.type)){let s=[];["NEW","SET"].includes(e.type)&&(s=[...$.CONSTRAINT_TYPES,Y]),e.type==="NEW"&&(s=[...M.CONSTRAINT_TYPES.concat(s),K,$]);let i=s.reduce((n,o)=>n||o.fromJson(t,e.argument),null)||e.argument;return r[e.type.toLowerCase()](i),r}if(e.type==="ALTER"){let{reference:s,argument:i}=e;return r.alter(s,this.fromJson(r,i)),r}if(e.type==="CHANGE"){let{reference:s,argument:i}=e;return r.change(s,$.fromJson(r,i)),r}}};var F=class extends T{constructor(t){super(t),this._BINDINGS=[]}get type(){return this.constructor.name.toUpperCase()}get statementNode(){return this}get BINDINGS(){return this._BINDINGS}connectedNodeCallback(t){}clone(){let t=super.clone();return this._BINDINGS.length&&(t._BINDINGS=this._BINDINGS.slice(0)),t}static mySubstitutePlaceholders(t,e){return(t?.params?.inputDialect||t?.params?.dialect)!=="mysql"||e.indexOf("?")===-1?e:h.split(e,["?"],{blocks:[]}).reduce((r,s,i)=>r?r+"?"+i+s:s,null)}get expandable(){return!1}async expand(t=!1){return t?this:this.clone()}};var xt=class extends F{static Node=T;NAME;BASENAME;ACTIONS=[];name(t){return arguments.length?(this.NAME=t,this):this.NAME}basename(t){return arguments.length?(this.BASENAME=t,this):this.BASENAME}addRename(t){return this.build("ACTIONS",[t],H,"rename")}addMove(t){return this.build("ACTIONS",[t],H,"move")}addDrop(t){return this.build("ACTIONS",[t],H,"drop")}addNew(t){return this.build("ACTIONS",[t],H,"new")}addAlt(t,e){return this.build("ACTIONS",[t,e],H,"alter")}toJson(){return{name:this.NAME,...this.BASENAME?{basename:this.BASENAME}:{},actions:this.ACTIONS.map(t=>t.toJson()),...this.FLAGS.length?{flags:this.FLAGS}:{}}}static fromJson(t,e){if(typeof e?.name!="string"||!Array.isArray(e.actions))return;let r=new this(t).name(e.name).basename(e.basename).withFlag(...e.flags||[]);for(let s of e.actions)r.ACTIONS.push(H.fromJson(r,s));return r}};var ot=class extends xt{addChange(t,e){return this.build("ACTIONS",[t,e],H,"change")}stringify(){if(!this.ACTIONS.length)return"";let t=[],e,r;for(let o of this.ACTIONS){if(o.TYPE==="RENAME"){e=`RENAME TO ${this.autoEsc(o.ARGUMENT)}`;continue}if(o.TYPE==="MOVE"){r=`SET SCHEMA ${this.autoEsc(o.ARGUMENT)}`;continue}if(o.TYPE==="DROP"){let a=o.hasFlag("IF_EXISTS"),c=o.getFlag("RESTRICT")||o.getFlag("CASCADE");this.params.dialect==="mysql"&&["PRIMARY_KEY","FOREIGN_KEY"].includes(o.ARGUMENT.kind)?o.ARGUMENT.kind==="PRIMARY_KEY"?t.push("DROP PRIMARY KEY"):t.push(`DROP FOREIGN KEY ${this.autoEsc(o.ARGUMENT.name)}`):t.push(`DROP ${o.ARGUMENT.kind==="COLUMN"?"COLUMN":"CONSTRAINT"}${a?" IF EXISTS":""} ${this.autoEsc(o.ARGUMENT.name)}${c?` ${c}`:""}`);continue}if(o.TYPE==="NEW"){let a=o.hasFlag("IF_NOT_EXISTS"),c=o.hasFlag("FIRST"),f=o.getFlag("AFTER")?.replace("AFTER:","");if(t.push(`ADD ${o.ARGUMENT instanceof $?"COLUMN ":""}${a?"IF NOT EXISTS ":""}${o.ARGUMENT}${c?" FIRST":f?` AFTER ${this.autoEsc([f])}`:""}`),this.params.dialect==="mysql"&&o.ARGUMENT instanceof $){let l=o.ARGUMENT.foreignKey();l&&t.push(`ADD ${ForeignKey2.fromJson(instance,l.toJson()).columns([o.ARGUMENT.name()])}`)}continue}if(o.TYPE==="CHANGE"){let a=o.hasFlag("FIRST"),c=o.getFlag("AFTER")?.replace("AFTER:","");t.push(`CHANGE COLUMN ${this.autoEsc(o.REFERENCE.name)} ${o.ARGUMENT}${a?" FIRST":c?` AFTER ${this.autoEsc([c])}`:""}`);continue}if(o.TYPE==="ALTER"){let{REFERENCE:a,ARGUMENT:c}=o;if(c.TYPE==="RENAME"){t.push(`RENAME ${a.kind} ${this.autoEsc(a.name)} TO ${this.autoEsc(c.ARGUMENT)}`);continue}if(c.TYPE==="SET"&&c.ARGUMENT instanceof Y)t.push(`ALTER COLUMN ${this.autoEsc(a.name)} SET DATA TYPE ${c.ARGUMENT}`);else if(c.TYPE==="DROP"){let f=["IDENTITY","EXPRESSION"].includes(c.ARGUMENT)&&o.hasFlag("IF_EXISTS");t.push(`ALTER COLUMN ${this.autoEsc(a.name)} DROP ${c.ARGUMENT.replace(/_/," ")}${f?" IF EXISTS":""}`)}else if(a.kind==="COLUMN"){let f=c.ARGUMENT.TYPE==="IDENTITY"?"ADD":"SET";t.push(`ALTER COLUMN ${this.autoEsc(a.name)} ${f} ${c.ARGUMENT}`)}["CONSTRAINT","INDEX"].includes(a.kind)&&t.push(`ALTER ${a.kind} ${this.autoEsc(a.name)} ${c.ARGUMENT}`)}}let s=[];this.params.dialect!=="mysql"&&([t,s]=t.reduce(([o,a],c)=>c.startsWith("RENAME")?[o,a.concat(c)]:[o.concat(c),a],[[],[]]));let i=[],n=this.BASENAME||(this.CONTEXT instanceof this.constructor.Node?this.CONTEXT.NAME:this.CONTEXT?.name);t.length&&i.push(`ALTER TABLE${this.hasFlag("IF_EXISTS")?" IF EXISTS":""} ${this.autoEsc([n,this.NAME].filter(o=>o)).join(".")}
	${t.join(`,
	`)}`);for(let o of s)i.push(`ALTER TABLE${this.hasFlag("IF_EXISTS")?" IF EXISTS":""} ${this.autoEsc([n,this.NAME].filter(a=>a)).join(".")}
	${o}`);return e&&i.push(`ALTER TABLE${this.hasFlag("IF_EXISTS")?" IF EXISTS":""} ${this.autoEsc([n,this.NAME].filter(o=>o)).join(".")}
	${e}`),r&&i.push(`ALTER TABLE${this.hasFlag("IF_EXISTS")?" IF EXISTS":""} ${this.autoEsc([n,e?this.ACTIONS.find(o=>o.TYPE==="RENAME").ARGUMENT:this.NAME].filter(o=>o)).join(".")}
	${r}`),i.join(`;
`)}static parse(t,e,r){let[s,i,n]=/^ALTER\s+TABLE\s+(IF\s+EXISTS\s+)?([\s\S]+)$/i.exec(e.trim())||[];if(!s)return;let[o,a]=h.split(n,["\\s+"],{useRegex:!0,limit:1}),[c,f]=this.parseIdent(t,o.trim(),!0)||[];if(!c)return;let l=new this(t).name(c).basename(f);i&&l.withFlag("IF_EXISTS");let m=E=>new RegExp(`${this[E].source}`,"i"),p=h.split(a,[","]).map(E=>E.trim());for(let E of p){let[A,d,N,,S,R,,C]=m("renameRe").exec(E)||[];if(A){let Z=N||this.autoUnesc(l,S),z=R||this.autoUnesc(l,C);if(Z){let j={kind:/KEY|INDEX/i.test(d)?"INDEX":d.toUpperCase(),name:Z};l.addAlt(j,It=>It.rename(z))}else l.addRename(z);continue}let[U,Q,,tr]=m("moveRe").exec(E)||[];if(U){l.addMove(Q||this.autoUnesc(l,tr));continue}let[er,Je="COLUMN",rr,sr,,ir,nr]=m("dropRe").exec(E)||[];if(er){let Z=sr||this.autoUnesc(l,ir)||Je.trim().replace(/\s+KEY/i,"").toUpperCase(),z=[rr,nr].filter(J=>J).map(J=>J.trim().replace(/\s+/g,"_").toUpperCase());l.addDrop({kind:Je.trim().replace(/\s+/g,"_").toUpperCase(),name:Z}).withFlag(...z);continue}let[or,ar,Be,Ye]=m("addRe").exec(E)||[];if(or){let[,Z,z,J]=Ye.match(/([\s\S]+)\s+(?:(FIRST)|AFTER\s+(.+))$/i)||[,Ye],j=r(l,Z.trim(),ar?[$]:[...M.CONSTRAINT_TYPES,K,$]),It=[Be,z].filter(St=>St).map(St=>St.trim().replace(/\s+/g,"_").toUpperCase()).concat(J?`AFTER:${J}`:[]);l.addNew(j).withFlag(...It);continue}let[ur,cr,fr,,lr,ve]=m("changeRe").exec(E)||[];if(ur){let Z=fr||this.autoUnesc(l,lr),[,z,J,j]=ve.match(/([\s\S]+)\s+(?:(FIRST)|AFTER\s+(.+))$/i)||[,ve],It=r(l,/MODIFY/i.test(cr)?`${Z} ${z}`:z,[$]),St=[Be,J].filter(zt=>zt).map(zt=>zt.trim().replace(/\s+/g,"_").toUpperCase()).concat(j?`AFTER:${j}`:[]);l.addChange({kind:"COLUMN",name:Z},It).withFlag(...St);continue}let[hr,Ge,mr,,Er,We="",Se="",pr,Tr]=m("alterRe").exec(E)||[];if(hr){let Z=mr||this.autoUnesc(l,Er),z=/CONSTRAINT|CHECK/i.test(Ge)?"CONSTRAINT":/INDEX|KEY/i.test(Ge)?"INDEX":"COLUMN",J,j=We.toUpperCase()||"SET",It=pr?["IF_EXISTS"]:[],St={};j==="DROP"?J=Se:j.endsWith("TYPE")?(J=r(l,Se,[Y]),j="SET"):(St.argument=r(l,Se,$.CONSTRAINT_TYPES,{assert:!1}))?J=St.argument:We?J=Se:J=Tr;let zt={kind:z,name:Z};l.addAlt(zt,Ar=>Ar[j.toLowerCase()](J)).withFlag(...It);continue}throw new SyntaxError(E)}return l}static renameRe=/^RENAME\s+(?:(?:(COLUMN|CONSTRAINT|INDEX|KEY)\s+)?(?:(\w+)|([`"])((?:\3\3|[^\3])+)\3)\s+)?(?:TO|AS)\s+(?:(\w+)|([`"])((?:\6\6|[^\6])+)\6)$/;static moveRe=/^SET\s+SCHEMA\s+(?:(\w+)|([`"])((?:\2\2|[^\2])+)\2)$/;static dropRe=/^DROP\s+(COLUMN\s+|CONSTRAINT\s+|PRIMARY\s+KEY|FOREIGN\s+KEY\s+|CHECK\s+|INDEX\s+|KEY\s+)?(IF\s+EXISTS\s+)?(?:(\w+)|([`"])((?:\4\4|[^\3])+)\4)?(?:\s+(RESTRICT|CASCADE))?$/;static addRe=/^ADD\s+(COLUMN\s+)?(IF\s+NOT\s+EXISTS\s+)?([\s\S]+)$/;static changeRe=/^(CHANGE|MODIFY)\s+COLUMN\s+(?:(\w+)|([`"])((?:\3\3|[^\3])+?)\3)\s+([\s\S]+)$/;static alterRe=/^ALTER\s+(?:(COLUMN|CONSTRAINT|CHECK|INDEX|KEY)\s+)?(?:(\w+)|([`"])((?:\3\3|[^\3])+?)\3)\s+(?:(ADD|DROP|(?:SET\s+DATA\s+)?TYPE|SET)\s+(.+)(IF\s+EXISTS)?$|(VISIBLE|(?:NOT\s+)?INVISIBLE|NOT\s+ENFORCED|ENFORCED|DEFERRABLE|NOT\s+DEFERRABLE|INITIALLY\s+DEFERRED|INITIALLY\s+IMMEDIATE))/};var Pt=class extends tt{static Node=T;BASENAME;$BASENAME;get statementNode(){return this}connectedNodeCallback(t){}basename(t){return arguments.length?(this[this.smartKey("BASENAME",!0)]=t,this):this[this.smartKey("BASENAME")]}toJson(){return{...this.BASENAME?{basename:this.BASENAME}:{},...this.$BASENAME?{$basename:this.$BASENAME}:{},...super.toJson()}}static fromJson(t,e,r=null){if(!(e?.basename&&typeof e.basename!="string"||e.$basename&&typeof e.$basename!="string"))return super.fromJson(t,e,()=>{let s=r?r():new this(t);return s.hardSet(()=>s.basename(e.basename)),s.hardSet(e.$basename,i=>s.basename(i)),s})}};var Ht=class extends bt{COLUMNS=[];$COLUMNS=[];static get WRITABLE_PROPS(){return["COLUMNS"].concat(super.WRITABLE_PROPS)}columns(t){return arguments.length?(this[this.smartKey("COLUMNS",!0)]=[].concat(t),this):this[this.smartKey("COLUMNS")]}toJson(){return{columns:this.COLUMNS,...this.$COLUMNS.length?{$columns:this.$COLUMNS}:{},...super.toJson()}}static fromJson(t,e){if(e?.columns?.length)return super.fromJson(t,e,()=>{let r=new this(t).columns(e.columns);return r.hardSet(e.$columns,s=>r.columns(s)),r})}stringify(){return`${super.stringify()} (${this.autoEsc(this.columns()).join(", ")})`}static parse(t,e,r){let[s,i]=h.split(e,[]),n=super.parse(t,s.trim(),r);if(n)return n.columns(this.parseColumns(t,i))}};var Dt=class extends et{COLUMNS=[];$COLUMNS=[];static get WRITABLE_PROPS(){return["COLUMNS"].concat(super.WRITABLE_PROPS)}columns(t){return arguments.length?(this[this.smartKey("COLUMNS",!0)]=[].concat(t),this):this[this.smartKey("COLUMNS")]}toJson(){return{columns:this.COLUMNS,...this.$COLUMNS.length?{$columns:this.$COLUMNS}:{},...super.toJson()}}static fromJson(t,e){if(e?.columns?.length)return super.fromJson(t,e,()=>{let r=new this(t).columns(e.columns);return r.hardSet(e.$columns,s=>r.columns(s)),r})}stringify(){let t=this.stringifyName(),e=this.NAME,r=this.$NAME;this.NAME=null,this.$NAME=null;let s=`${t}FOREIGN KEY (${this.autoEsc(this.columns()).join(", ")}) ${super.stringify()}`;return this.NAME=e,this.$NAME=r,s}static parse(t,e,r){let{name:s="",expr:i}=this.parseName(t,e,!0);if(!i||!/^FOREIGN\s+KEY/i.test(i))return;let[,n,...o]=h.split(i,[]);return super.parse(t,o.join("").trim(),r).name(s).columns(this.parseColumns(t,n))}};var Kt=class extends Mt{COLUMNS=[];$COLUMNS=[];static get WRITABLE_PROPS(){return["COLUMNS"].concat(super.WRITABLE_PROPS)}columns(t){return arguments.length?(this[this.smartKey("COLUMNS",!0)]=[].concat(t),this):this[this.smartKey("COLUMNS")]}toJson(){return{columns:this.COLUMNS,...this.$COLUMNS.length?{$columns:this.$COLUMNS}:{},...super.toJson()}}static fromJson(t,e){if(e?.columns?.length)return super.fromJson(t,e,()=>{let r=new this(t).columns(e.columns);return r.hardSet(e.$columns,s=>r.columns(s)),r})}stringify(){return`${super.stringify()} (${this.autoEsc(this.columns()).join(", ")})`}static parse(t,e,r){let[s,i]=h.split(e,[]),n=super.parse(t,s.trim(),r);if(n)return n.columns(this.parseColumns(t,i))}};var M=class u extends Pt{COLUMNS=[];CONSTRAINTS=[];INDEXES=[];NODES=new Set;static get WRITABLE_PROPS(){return["BASENAME"].concat(super.WRITABLE_PROPS)}static get SUBTREE_PROPS(){return["COLUMNS","CONSTRAINTS","INDEXES"]}static CONSTRAINT_TYPES=[Ht,Dt,Kt,Et];connectedNodeCallback(t){[$,b,K].some(e=>t instanceof e)&&this.NODES.add(t)}primaryKey(){return this.CONSTRAINTS.find(t=>t.TYPE==="PRIMARY_KEY")||this.COLUMNS.reduce((t,e)=>t||e.primaryKey(),null)}column(t){return typeof t=="string"?this.COLUMNS.find(e=>e.name()===t):(this.build("COLUMNS",[t],$),this)}constraint(t){return typeof t=="string"?this.CONSTRAINTS.find(e=>e.name()===t):(this.build("CONSTRAINTS",[t],this.constructor.CONSTRAINT_TYPES),this)}index(t){return typeof t=="string"?this.INDEXES.find(e=>e.name()===t):(this.build("INDEXES",[t],K),this)}alterWith(t){let e=(r,s=!1)=>{let i=this.NODES.find(n=>(r.kind==="COLUMN"?n instanceof $:r.kind==="CONSTRAINT"?n instanceof b:n.TYPE===r.kind)&&(r.name?n.NAME===r.name:r.kind==="PRIMARY_KEY"));if(!i&&!s)throw new Error(`${r.kind}${r.name?` "${r.name}"`:""} does not exist.`);return i};for(let r of t.ACTIONS)if(r.TYPE==="RENAME")this.name(r.ARGUMENT);else if(r.TYPE==="MOVE")this.basename(r.ARGUMENT);else if(r.TYPE==="DROP")e(r.ARGUMENT,r.hasFlag("IF_EXISTS"))?.drop();else if(r.TYPE==="NEW")r.ARGUMENT instanceof b?r.ARGUMENT.COLUMNS.length===1?e({kind:"COLUMN",name:r.ARGUMENT.COLUMNS[0]}).constraint(r.ARGUMENT.TYPE,r.ARGUMENT.toJson()):this.constraint(r.ARGUMENT.toJson()):r.ARGUMENT instanceof K?this.index(r.ARGUMENT.toJson()):(!r.hasFlag("IF_NOT_EXISTS")||!e({kind:"COLUMN",name:r.ARGUMENT.NAME},!0))&&this.column(r.ARGUMENT.toJson());else if(r.TYPE==="CHANGE"){let s=e(r.REFERENCE);r.ARGUMENT.name()!==s.name()&&s.hardSet(r.ARGUMENT.name(),i=>s.name(i)),s.hardSet(r.ARGUMENT.type().toJson(),i=>s.type(i));for(let i of r.ARGUMENT.CONSTRAINTS.filter(n=>!["PRIMARY_KEY","FOREIGN_KEY","UNIQUE_KEY","CHECK"].includes(n.TYPE))){let n=s.constraint(i.TYPE);n?n.detail(i.DETAIL):s.constraint(i.toJson())}}else if(r.TYPE==="ALTER"){let{REFERENCE:s,ARGUMENT:i}=r,n=e(s,r.hasFlag("IF_EXISTS"));if(!n)continue;if(i.TYPE==="RENAME")n.name(i.ARGUMENT);else if(i.TYPE==="SET"&&i.ARGUMENT instanceof DataType)n.type(i.ARGUMENT.toJson());else if($.CONSTRAINT_TYPES.some(o=>i.ARGUMENT instanceof o)){let o=n.constraint(i.ARGUMENT.TYPE);if(i.ARGUMENT.TYPE==="IDENTITY"){if(i.TYPE==="SET"&&!o)throw new Error(`IDENTITY constraint has not been created in ${n.NAME}`);if(i.TYPE==="NEW"&&o)throw new Error(`IDENTITY constraint already exists in ${n.NAME}`)}else if(i.ARGUMENT.TYPE==="EXPRESSION"&&i.TYPE!=="DROP")throw new Error("Cannot add EXPRESSION constraint after column creation");o?o.detail(i.ARGUMENT.DETAIL):n.constraint(i.ARGUMENT.toJson())}else if(i.TYPE==="DROP"&&["IDENTITY","EXPRESSION","DEFAULT","NOT_NULL"].includes(i.ARGUMENT)){let o=n.constraint(i.ARGUMENT);if(o)o.drop();else if(!r.hasFlag("IF_EXISTS"))throw new Error(`Cannot drop ${i.ARGUMENT}; does not exist.`)}else["CONSTRAINT","INDEX"].includes(s.kind)}}getAlt(){let t=new ot(this.CONTEXT).name(this.NAME).basename(this.BASENAME);this.$NAME&&this.NAME&&this.$NAME!==this.NAME&&t.addRename(this.$NAME),this.$BASENAME&&this.BASENAME&&this.$BASENAME!==this.BASENAME&&t.addMove(this.$BASENAME);let e=(s,i=!1)=>s.keep()!==!0||["$EXPR","$ALWAYS","$TARGET_TABLE","$TARGET_COLUMNS","$MATCH_RULE","$UPDATE_RULE","$DELETE_RULE"].concat(i?"$NAME":[]).some(n=>n in s&&(Array.isArray(s[n])?s[n].length:![void 0,null].includes(s[n]))&&!Xt(s[n.slice(1)],s[n]));for(let s of this.COLUMNS){let i={kind:"COLUMN",name:s.NAME};if(s.keep()===!0){if(this.params.dialect==="mysql")if(s.$TYPE&&!Xt(s.$TYPE.toJson(),s.TYPE.toJson())||s.CONSTRAINTS.some(o=>["AUTO_INCREMENT","EXPRESSION","NOT_NULL"].includes(o.TYPE)&&e(o,!0))){let o=s.clone();o.CONSTRAINTS=o.CONSTRAINTS.filter(a=>["AUTO_INCREMENT","EXPRESSION","NOT_NULL","DEFAULT"].includes(a.TYPE)),t.addChange(i,o)}else{let o=s.CONSTRAINTS.find(a=>a.TYPE==="DEFAULT"&&e(a,!0));o&&t.addAlt(i,a=>o.keep()===!1?a.drop(o.TYPE):a.set(o)),s.$NAME&&s.$NAME!==s.NAME&&t.addAlt({kind:"COLUMN",name:s.NAME},a=>a.rename(s.$NAME))}else{s.$TYPE&&!Xt(s.$TYPE.toJson(),s.TYPE.toJson())&&t.addAlt(i,a=>a.set(s.$TYPE));let o=s.CONSTRAINTS.filter(a=>["IDENTITY","EXPRESSION","NOT_NULL","DEFAULT"].includes(a.TYPE)&&e(a,!0));for(let a of o){if(a.keep()===!0&&a.TYPE==="IDENTITY"&&t.addAlt(i,c=>c.drop("IDENTITY")),a.keep()!==!1&&a.TYPE==="EXPRESSION")throw new Error("EXPRESSION constraints cannot be added or modified after column creation.");t.addAlt(i,c=>a.keep()===!1?c.drop(a.TYPE):c[a.TYPE==="IDENTITY"?"new":"set"](a))}s.$NAME&&s.$NAME!==s.NAME&&t.addAlt({kind:"COLUMN",name:s.NAME},a=>a.rename(s.$NAME))}let n=s.CONSTRAINTS.filter(o=>["PRIMARY_KEY","FOREIGN_KEY","UNIQUE_KEY","CHECK"].includes(o.TYPE));for(let o of n)e(o)?([!0,!1].includes(o.keep())&&t.addDrop({kind:o.TYPE,name:o.NAME}),o.keep()!==!1&&t.addNew(u.CONSTRAINT_TYPES.find(a=>a.TYPE===o.TYPE).fromJson(t,{...o.toJson(),columns:[s.statementNode.altsCascaded?s.name():s.NAME]}))):o.keep()===!0&&o.$NAME&&o.$NAME!==o.NAME&&t.addAlt({kind:"CONSTRAINT",name:o.NAME},a=>a.rename(o.$NAME));continue}if(s.keep()===!1){t.addDrop(i);continue}t.addNew($.fromJson(t,s.toJson()))}let r=s=>e(s)||s.$COLUMNS?.length&&!Xt(s.$COLUMNS,s.COLUMNS);for(let s of this.CONSTRAINTS)r(s)?([!0,!1].includes(s.keep())&&t.addDrop({kind:s.TYPE,name:s.NAME}),s.keep()!==!1&&t.addNew(u.CONSTRAINT_TYPES.find(i=>i.TYPE===s.TYPE).fromJson(t,s.toJson()))):s.keep()===!0&&s.$NAME&&s.$NAME!==s.NAME&&t.addAlt({kind:"CONSTRAINT",name:s.NAME},i=>i.rename(s.$NAME));return t}cascadeAlt(){this.keep(this.keep(),"auto");let t=r=>r.dropped()?"DOWN":r.$NAME&&r.$NAME!==r.NAME?"RENAME":null,e=t(this);for(let r of this.COLUMNS){let s=t(r);if(s)for(let i of this.CONSTRAINTS){if(i instanceof Et)continue;let n=i.$COLUMNS.length?i.$COLUMNS:i.COLUMNS,o=n.indexOf(r.NAME);o>-1&&(s==="DOWN"?n.splice(o,1):s==="RENAME"&&(n[o]=r.$NAME))}}return this.altsCascaded=!0,this}updateDatabaseReferences(t,e){for(let r of this.NODES)r instanceof et&&r.targetTable().basename()===t.NAME&&(e==="DOWN"?r.drop():e==="RENAME"&&r.targetTable().basename(t.$NAME))}updateTableReferences(t,e){for(let r of this.NODES)r instanceof et&&(r.targetTable().basename()&&t.basename()&&r.targetTable().basename()!==t.basename()||r.targetTable().name()===t.NAME&&(e==="DOWN"?r.drop():e==="RENAME"&&r.targetTable().name(t.$NAME)))}updateColumnReferences(t,e){for(let r of this.NODES){if(!(r instanceof et)||r.targetTable().basename()&&t.statementNode.basename()&&r.targetTable().basename()!==t.statementNode.basename()||r.targetTable().name()!==t.statementNode.name())continue;let s=cons.$TARGET_COLUMNS.length?cons.$TARGET_COLUMNS:cons.TARGET_COLUMNS,i=s.indexOf(t.NAME);i>-1&&(e==="DOWN"?s.splice(i,1):e==="RENAME"&&(s[i]=t.$NAME))}}toJson(){return{columns:this.COLUMNS.map(t=>t.toJson()),constraints:this.CONSTRAINTS.map(t=>t.toJson()),indexes:this.INDEXES.map(t=>t.toJson()),...super.toJson()}}static fromJson(t,e){if(!(!Array.isArray(e?.columns)||["constraints","indexes"].some(r=>r in e&&!Array.isArray(e[r]))))return super.fromJson(t,e,()=>{let r=new this(t);for(let s of e.columns)r.column(s);for(let s of e.constraints||[])r.constraint(s);for(let s of e.indexes||[])r.index(s);return r})}stringify(){let t=[this.COLUMNS.map(i=>i.stringify()).join(`,
	`)],e=this.CONSTRAINTS.slice(0),r=this.INDEXES.slice(0);this.params.dialect==="mysql"&&e.push(...this.COLUMNS.reduce((i,n)=>{let o=n.foreignKey();return o?i.concat(Dt.fromJson(this,o.toJson()).columns([n.name()])):i},[])),e.length&&t.push(e.map(i=>i.stringify()).join(`,
	`)),r.length&&t.push(r.map(i=>i.stringify()).join(`,
	`));let s=this.basename()||(this.CONTEXT instanceof this.constructor.Node?this.CONTEXT.NAME:this.CONTEXT?.name);return`CREATE TABLE${this.hasFlag("IF_NOT_EXISTS")?" IF NOT EXISTS":""} ${this.autoEsc([s,this.name()].filter(i=>i)).join(".")} (
	${t.join(`,
	`)}
)`}static parse(t,e,r){let[s,i,n]=/^CREATE\s+TABLE\s+(IF\s+NOT\s+EXISTS\s+)?([\s\S]+)$/i.exec(e.trim())||[];if(!s)return;let[o,a]=h.split(n,[],{limit:2}),[c,f]=this.parseIdent(t,o.trim(),!0)||[];if(!c)return;let l=new this(t).name(c).basename(f);i&&l.withFlag("IF_NOT_EXISTS");let m=h.split(w(a,"(",")"),[","]).map(p=>r(l,p.trim(),[Ht,Dt,Kt,Et,K,$]));for(let p of m)p instanceof $?l.column(p):p instanceof K?l.index(p):l.constraint(p);return l}};function Xt(u,t){if(u===t)return!0;if(Array.isArray(u)&&Array.isArray(t)&&u.length===t.length){let r=t.slice(0).sort();return u.slice(0).sort().every((s,i)=>Xt(s,r[i]))}let e={};return typeof u=="object"&&u&&typeof t=="object"&&t&&(e.keys_a=Object.keys(u)).length===(e.keys_b=Object.keys(t)).length?e.keys_a.reduce((r,s)=>r&&Xt(u[s],t[s]),!0):!1}var at=class extends xt{addOwner(t){return this.build("ACTIONS",[t],H,"owner")}stringify(){if(!this.ACTIONS.length)return"";let t=[],e,r;for(let i of this.ACTIONS){if(i.TYPE==="RENAME"){e=`RENAME TO ${this.autoEsc(i.ARGUMENT)}`;continue}if(i.TYPE==="MOVE"){r=`SET TABLESPACE ${this.autoEsc(i.ARGUMENT)}`;continue}if(i.TYPE==="DROP"){let n=i.hasFlag("IF_EXISTS"),o=i.getFlag("RESTRICT")||i.getFlag("CASCADE");t.push(`DROP TABLE${n?" IF EXISTS":""} ${this.autoEsc([].concat(i.ARGUMENT.name)).join(".")}${o?` ${o}`:""}`);continue}if(i.TYPE==="NEW"){t.push(i.ARGUMENT+"");continue}if(i.TYPE==="ALTER"){let{REFERENCE:n,ARGUMENT:o}=i;t.push(o.ARGUMENT+"")}}let s=[...t];return e&&s.push(`ALTER SCHEMA ${this.autoEsc(this.NAME)}
	${e}`),r&&s.push(`ALTER SCHEMA ${this.autoEsc(e?this.ACTIONS.find(i=>i.TYPE==="RENAME").ARGUMENT:this.NAME)}
	${r}`),s.join(`;
`)}static parse(t,e){let[r,s]=/^ALTER\s+DATABASE\s+([\s\S]+)$/i.exec(e.trim())||[];if(!r)return;let[i,n]=h.split(s,["\\s+"],{useRegex:!0,limit:1}),[o]=this.parseIdent(t,i.trim(),!0)||[];if(!o)return;let a=new this(t).name(o),c=R=>new RegExp(`${this[R].source}`,"i"),[f,l,,m]=c("renameRe").exec(n)||[];if(f){let R=l||this.autoUnesc(a,m);return a.addRename(R),a}let[p,E,,A]=c("moveRe").exec(n)||[];if(p)return a.addMove(E||this.autoUnesc(a,A)),a;let[d,N,,S]=c("ownerRe").exec(n)||[];return d&&a.addOwner(N||this.autoUnesc(a,S)),a}static renameRe=/^RENAME\s+TO\s+(?:(\w+)|([`"])((?:\2\2|[^\2])+)\2)$/;static moveRe=/^SET\s+TABLESPACE\s+(?:(\w+)|([`"])((?:\2\2|[^\2])+)\2)$/;static ownerRe=/^OWNER\s+TO\s+(?:(\w+)|([`"])((?:\2\2|[^\2])+)\2)$/};var v=class extends Pt{TABLES=[];static get SUBTREE_PROPS(){return["TABLES"]}table(t){return typeof t=="string"?this.TABLES.find(e=>e.name()===t):(this.build("TABLES",[t],M),this)}alterWith(t){let e=(r,s=!1)=>{let i=this.table(r);if(!i&&!s)throw new Error(`TABLE ${r} does not exist.`);return i};for(let r of t.ACTIONS)if(r.TYPE==="RENAME")this.name(r.ARGUMENT);else if(r.TYPE==="MOVE")this.basename(r.ARGUMENT);else if(r.TYPE==="DROP")e(r.ARGUMENT,r.hasFlag("IF_EXISTS"))?.drop();else if(r.TYPE==="NEW")(!r.hasFlag("IF_NOT_EXISTS")||!e(r.ARGUMENT.name(),!0))&&this.table(r.ARGUMENT.toJson());else if(r.TYPE==="ALTER"){let s=e(r.REFERENCE,r.hasFlag("IF_EXISTS"));if(!s)continue;s.alter(r.ARGUMENT)}}getAlt(){let t=new at(this.CONTEXT).name(this.NAME).basename(this.BASENAME);this.$NAME&&this.NAME&&this.$NAME!==this.NAME&&t.addRename(this.$NAME),this.$BASENAME&&this.BASENAME&&this.$BASENAME!==this.BASENAME&&t.addMove(this.$BASENAME);for(let e of this.TABLES)if(e.keep()===!0){let r=e.getAlt();r.ACTIONS.length&&t.addAlt({name:e.NAME,kind:"TABLE"},s=>s.set(r))}else e.keep()===!1?t.addDrop({name:[e.BASENAME||this.NAME,e.NAME],kind:"TABLE"}):t.addNew(e.clone());return t}cascadeAlt(){this.keep(this.keep(),"auto");let t=this.dropped()?"DOWN":this.$NAME&&this.$NAME!==this.NAME?"RENAME":null;for(let e of this.TABLES)e.cascadeAlt();return this.altsCascaded=!0,this}toJson(){return{...super.toJson(),tables:this.TABLES.map(t=>t.toJson())}}static fromJson(t,e){if(!["tables"].some(r=>r in e&&!Array.isArray(e[r])))return super.fromJson(t,e,()=>{let r=new this(t);for(let s of e.tables||[])r.table(s);return r})}stringify(){return[...[`CREATE SCHEMA${this.hasFlag("IF_NOT_EXISTS")?" IF NOT EXISTS":""} ${this.autoEsc(this.name())}`],...this.TABLES].join(`;
`)}static parse(t,e,r){let[s,i,n]=/^CREATE\s+DATABASE\s+(IF\s+NOT\s+EXISTS\s+)?(.+)$/i.exec(e.trim())||[];if(!s)return;let[o]=this.parseIdent(t,n.trim(),!0)||[];if(!o)return;let a=new this(t).name(o);return i&&a.withFlag("IF_NOT_EXISTS"),a}};var ut=class extends F{NAME;BASENAME;name(t){return arguments.length?(this.NAME=t,this):this.NAME}basename(t){return arguments.length?(this.BASENAME=t,this):this.BASENAME}toJson(){return{name:this.NAME,basename:this.BASENAME,flags:this.FLAGS}}static fromJson(t,e){if(typeof e?.name=="string")return new this(t).name(e.name).basename(e.basename).withFlag(...e.flags||[])}stringify(){return`DROP TABLE${this.hasFlag("IF_EXISTS")?" IF EXISTS":""} ${this.autoEsc([this.BASENAME,this.NAME].filter(t=>t)).join(".")}${this.hasFlag("CASCADE")?" CASCADE":""}`}static parse(t,e){let[r,s,i,n,o]=/^DROP\s+TABLE\s+(IF\s+EXISTS\s+)?(?:(.+)\s+(CASCADE)$|(.+)$)/i.exec(e.trim())||[];if(!r)return;let[a,c]=this.parseIdent(t,(i||o).trim(),!0)||[];if(!a)return;let f=new this(t).name(a).basename(c);return s&&f.withFlag("IF_EXISTS"),n&&f.withFlag("CASCADE"),f}};var pt=class extends F{NAME;name(t){return arguments.length?(this.NAME=t,this):this.NAME}toJson(){return{name:this.NAME,flags:this.FLAGS}}static fromJson(t,e){if(typeof e?.name=="string")return new this(t).name(e.name).withFlag(...e.flags||[])}stringify(){return`DROP SCHEMA${this.hasFlag("IF_EXISTS")?" IF EXISTS":""} ${this.autoEsc(this.NAME)}${this.hasFlag("CASCADE")?" CASCADE":""}`}static parse(t,e){let[r,s,i,n,o]=/^DROP\s+DATABASE\s+(IF\s+EXISTS\s+)?(?:(.+)\s+(CASCADE)$|(.+)$)/i.exec(e.trim())||[];if(!r)return;let[a]=this.parseIdent(t,(i||o).trim(),!0)||[];if(!a)return;let c=new this(t).name(a);return s&&c.withFlag("IF_EXISTS"),n&&c.withFlag("CASCADE"),c}};var kt=class extends T{CONDITION=null;CONSEQUENCE=null;condition(t){return this.build("CONDITION",[t],I.Types),this}then_(t){return this.build("CONSEQUENCE",[t],I.Types)}toJson(){return{condition:this.CONDITION?.toJson(),consequence:this.CONSEQUENCE?.toJson()}}static fromJson(t,e){if(!(typeof e=="object"&&e&&"condition"in e))return;let r=new this(t);return r.condition(e.condition),r.then_(e.consequence),r}stringify(){return`${this.CONDITION} THEN ${this.CONSEQUENCE}`}static parse(t,e,r){let s=h.split(e,["\\s+THEN\\s+"],{useRegex:"i"});if(s.length!==2)return;let i=new this(t),[n,o]=s.map(a=>r(i,a.trim()));return i.condition(n).then_(o),i}};var Ft=class extends T{BASE_VALUE;WHEN_CLAUSES=[];ELSE_CLAUSE;compare(t){if(this.WHEN_CLAUSES.length||this.ELSE_CLAUSE)throw new Error('A "case" clause must come before any "when" or "else" clauses.');return this.build("BASE_VALUE",[t],I.Types)}when(t){if(this.ELSE_CLAUSE)throw new Error('A "when" clause cannot come after an "else" clause.');return this.build("WHEN_CLAUSES",[t],kt,"condition"),this.WHEN_CLAUSES[this.WHEN_CLAUSES.length-1]}else(t){if(!this.WHEN_CLAUSES.length)throw new Error('An "else" clause cannot come before "when" clauses.');return this.build("ELSE_CLAUSE",[t],I.Types)}toJson(){return{base_value:this.BASE_VALUE?.toJson(),when_clauses:this.WHEN_CLAUSES.map(t=>t.toJson()),else_clause:this.ELSE_CLAUSE?.toJson(),flags:this.FLAGS}}static fromJson(t,e){if(!Array.isArray(e?.when_clauses))return;let r=new this(t).withFlag(...e.flags||[]);e.base_value&&r.compare(e.base_value);for(let s of e.when_clauses)r.when(s);return e.else_clause&&r.else(e.else_clause),r}stringify(){let t=[];return this.BASE_VALUE&&t.push(this.BASE_VALUE),t.push(`WHEN ${this.WHEN_CLAUSES.join(" WHEN ")}`),this.ELSE_CLAUSE&&t.push("ELSE",this.ELSE_CLAUSE),`CASE ${t.join(" ")} END${this.params.dialect==="mysql"?" CASE":""}`}static parse(t,e,r){let[s,i]=e.match(/^CASE\s+([\s\S]*)\s+END(\s+CASE)?$/i)||[];if(!s)return;let{tokens:[n,...o],matches:a}=h.lex(i,["WHEN","ELSE"],{useRegex:"i"}),c=new this(t);n.trim()&&c.compare(r(c,n.trim()));for(let f of a){let l=o.shift();if(/ELSE/i.test(f))c.else(r(c,l.trim()));else if(/WHEN/i.test(f))c.when(r(c,l.trim(),[kt]));else throw new Error(`Can't have multiple "${f}" clauses in a CASE construct.`)}return c}static factoryMethods={case:t=>new this(t)}};var ne=class extends T{OPERAND=null;TYPE="";SYNTAX2=!1;cast(t,e,r=!1){return this.TYPE=e,this.SYNTAX2=r,this.build("OPERAND",[t],I.Types)}toJson(){return{operand:this.OPERAND?.toJson(),type:this.TYPE,syntax2:this.SYNTAX2,flags:this.FLAGS}}static fromJson(t,e){if(!e?.operand||!e?.type)return;let r=new this(t).withFlag(...e.flags||[]);return r.cast(e.operand,e.type,e.syntax2),r}stringify(){return this.SYNTAX2?`${this.OPERAND}::${this.TYPE}`:`CAST(${this.OPERAND} AS ${this.TYPE})`}static parse(t,e,r){let s,i,n=!1;if(/^CAST(?:\s+)?\([\s\S]+\)$/i.test(e)){let[,a]=h.split(e,[]);[s,i]=h.split(a.slice(1,-1),["AS"],{useRegex:"i"})}else{if((t?.params?.inputDialect||t?.params?.dialect)==="mysql"||([s,i]=h.split(e,["::"]),!i))return;n=!0}let o=new this(t);return o.cast(r(o,s.trim()),i.trim(),n),o}};var Jt=class extends T{OFFSET;constructor(t,e){super(t),this.OFFSET=parseInt(e)}$var(t){this.OFFSET=t}$bind(t,e){this.OFFSET=t,this.statementNode.BINDINGS.push(e),this.OFFSET===0&&(this.OFFSET=this.statementNode.BINDINGS.length)}toJson(){return{offset:this.OFFSET}}static fromJson(t,e){if(typeof e?.offset=="number")return new this(t,e.offset)}stringify(){return this.params.dialect==="mysql"?"?":"$"+this.OFFSET}static parse(t,e){let r=(t?.params?.inputDialect||t?.params?.dialect)==="mysql"?"?":"$",[s,i]=new RegExp(`^\\${r}(\\d)$`).exec(e)||[];if(s)return new this(t,parseInt(i))}};var ct=class extends T{VALUE="";QUOTE="";constructor(t,e,r="'"){super(t),this.VALUE=e,this.QUOTE=r}value(t){this.VALUE=t}stringify(){let t=this.QUOTE||this.quoteChars[0];return`${t}${(this.VALUE+"").replace(new RegExp(t,"g"),t.repeat(2))}${t}`}toJson(){return{value:this.VALUE}}static fromJson(t,e){if(typeof e?.value=="string")return new this(t,e.value,e.quote)}static parse(t,e){let[r,s]=this.parseText(t,e,!0)||[];if(s)return new this(t,r,s)}static parseText(t,e,r=!1){let s=this.getQuoteChars(t,r),i={};if(!(!(i.quote=s.find(n=>B(e,n,n)))||h.match(e,[" "]).length))return[w(e,i.quote,i.quote).replace(new RegExp(i.quote+i.quote,"g"),i.quote),i.quote]}};var ft=class extends ct{TYPE;constructor(t,e,r,s){super(t,e,s),this.TYPE=r}array(t){this.VALUE=Array.isArray(t)?JSON.stringify(t):t,this.TYPE="ARRAY"}object(t){this.VALUE=O(t)?JSON.stringify(t):t,this.TYPE="OBJECT"}toJson(){return{type:this.TYPE,...super.toJson()}}static fromJson(t,e){if(typeof e?.type!="string"||!/OBJECT|ARRAY/i.test(e.type)||!e.value)return;let r=new this(t);return r[e.type.toLowerCase()](e.value),r}stringify(){return`${super.stringify()}`}static parse(t,e){let r=[["{","}"],["[","]"]],s={},[i,n]=this.parseText(t,e)||[];if(n&&!(!(s.braces=r.find(o=>B(e,o[0],o[1])))||h.match(e,[" "]).length))return new this(t,i,s.braces[0]==="{"?"OBJECT":"ARRAY",n)}static factoryMethods={array:(t,e)=>Array.isArray(e)&&new this(t),object:(t,e)=>O(e)&&new this(t)}};var _t=class extends T{VALUE=0;constructor(t,e){super(t),this.VALUE=e}value(t){this.VALUE=t}toJson(){return{value:this.VALUE,flags:this.FLAGS}}static fromJson(t,e){if(typeof e=="number"||typeof e=="string"&&/^[.\d]+$/.test(e)&&(e=parseFloat(e)))e={value:e};else if(typeof e?.value!="number")return;return new this(t,e.value).withFlag(...e.flags||[])}stringify(){return`${this.VALUE}`}static parse(t,e){if(/^\d+$/.test(e))return new this(t,parseFloat(e))}static factoryMethods={value:(t,e)=>/^\d+$/.test(e)&&new this(t)}};var rt=class extends T{static OPERATORS=["->","->>","#>","#>>"];OPERATOR="";LHS=null;RHS=null;path(t,e,r){if(!this.constructor.OPERATORS.includes(e))throw new Error(`Unknown operator: "${e}".`);this.build("LHS",[t],[ft,_]),this.build("RHS",[r],[ft,_t,ct]),this.OPERATOR=e}toJson(){return{lhs:this.LHS?.toJson(),rhs:this.RHS?.toJson(),operator:this.OPERATOR,flags:this.FLAGS}}static fromJson(t,e){if(!this.OPERATORS.includes(e?.operator))return;let r=new this(t).withFlag(...e.flags||[]);return r.path(e.lhs,e.operator,e.rhs),r}stringify(){return`${this.LHS} ${this.OPERATOR} ${this.RHS}`}static parse(t,e,r){if((t?.params?.inputDialect||t?.params?.dialect)==="mysql")return;let{tokens:s,matches:i}=h.lex(e,this.OPERATORS,{limit:1});if(!i.length)return;let n=new this(t),o=r(n,s[0],[ft,_]),a=r(n,s[1].trim(),[ft,_t,ct]);return n.path(o,i[0],a),n}static factoryMethods={path:(t,e,r,s)=>this.OPERATORS.includes(r)&&new this(t)}};var q=class u extends T{static ARR_RIGHT="~>";static ARR_LEFT="<~";OPERATOR="";LHS=null;RHS=null;UUID=null;get isOutgoing(){return this.OPERATOR===this.constructor.ARR_RIGHT}get isIncoming(){return this.OPERATOR===this.constructor.ARR_LEFT}get uuid(){return this.UUID||(this.UUID=`$path:${(0|Math.random()*9e6).toString(36)}`),this.UUID}path(t,e,r){let s=this.constructor;if(![s.ARR_LEFT,s.ARR_RIGHT].includes(e))throw new Error(`Unknown operator: "${e}".`);this.build("LHS",[t],_),this.build("RHS",[r],[s,rt,_]),this.OPERATOR=e}async eval(){let t=m=>m.columns.find(p=>p.primaryKey)?.name||m.constraints.find(p=>p.type==="PRIMARY_KEY")?.targetColumns[0],e=(m,p)=>m.columns.find(E=>E.name===p.NAME)?.references||m.constraints.find(E=>E.type==="FOREIGN_KEY"&&E.targetColumns.includes(p.NAME)),r=async(m,p)=>{let E=this.rootNode.CONTEXT,A=p||await E.basenameGet(m),d=E.database(A);if(await d.hasTable(m))return await d.describeTable(m)};if(!this.rootNode.CONTEXT)throw new Error("No client API in context.");if(this.isIncoming){if(!(this.RHS instanceof u))throw new Error(`Unterminated path: ${this.RHS}`);let m,p,E,A;if(this.RHS.isIncoming){if(!(this.RHS.RHS instanceof u))throw new Error(`Unterminated path: ${this.RHS.RHS}`);({LHS:m,RHS:A}=this),E=(await A.eval()).lhs.schema,p=_.fromJson(this,E)}else if({LHS:m,RHS:{LHS:p,RHS:A}}=this,E=await r(p.NAME,p.BASENAME),!E)throw new Error(`[${this}]: The implied table ${p} does not exist.`);let d=e(E,m);if(!d)throw new Error(`[${this}]: Table ${p} does not define the implied foreign key: ${m}.`);let N=_.fromJson(this,d.basename?[d.basename,d.targetTable]:d.targetTable),S=await r(N.NAME,N.BASENAME);if(!S)throw new Error(`[${this}]: The implied table ${N} does not exist.`);let R=t(S);if(!R)throw new Error(`[${this}]: Table ${S.name} does not define a primary key.`);return{lhs:{schema:S,primaryKey:R},rhs:{schema:E,foreignKey:m,path:A}}}let s=this.statementNode.TABLES[0]?.EXPR;if(!s)throw new Error("No tables in query.");if(!(s instanceof _))throw new Error(`[${this}]: Base query must not be derived.`);let i=await r(s.NAME,s.BASENAME);if(!i)throw new Error(`[${this}]: The implied table ${s} does not exist.`);let{LHS:n,RHS:o}=this,a=e(i,n);if(!a)throw new Error(`[${this}]: Table ${s} does not define the implied foreign key: ${n}.`);let c=_.fromJson(this,a.basename?[a.basename,a.targetTable]:a.targetTable),f=await r(c.NAME,c.BASENAME||s.BASENAME);if(!f)throw new Error(`[${this}]: The implied table ${c} does not exist.`);let l=t(f);if(!l)throw new Error(`[${this}]: Table ${c} does not define a primary key.`);return{lhs:{schema:i,foreignKey:n},rhs:{schema:f,primaryKey:l,path:o}}}async plot(){if(this.JOINT)return;let t=this.statementNode,e=t.TABLES[0];if(!e)throw new Error("No tables in query.");if(!(e.EXPR instanceof _))throw new Error(`[${this}]: Base query must not be derived.`);let{lhs:r,rhs:s}=await this.eval(),i=r.foreignKey||r.primaryKey,n=s.primaryKey||s.foreignKey;if(r.primaryKey&&r.schema.name.toLowerCase()!==e.EXPR.NAME.toLowerCase())throw new Error(`[${this}]: Cannot resolve incoming path to base table ${e.EXPR}.`);let o=`$view:${[i,s.schema.basename,s.schema.name,n].join(":")}`,a=()=>this.JOINT=t.JOIN_LIST.find(c=>c.ALIAS.NAME===o);if(!a()){let c=["ALIAS","EXPR"].reduce((l,m)=>l||e[m]?.NAME,null),f=`${n}:${(0|Math.random()*9e6).toString(36)}`;t.leftJoin(l=>l.query(m=>m.select(p=>p.name(n).as(f)),m=>m.from([s.schema.basename,s.schema.name].filter(p=>p)))).with({IS_SMART_JOIN:!0}).as(o).on(l=>l.equals([o,f],[c,i])),a()}this.JOINT.EXPR.select(c=>c.expr(s.path.toJson()).as(this.uuid))}toJson(){return{lhs:this.LHS?.toJson(),rhs:this.RHS?.toJson(),operator:this.OPERATOR,flags:this.FLAGS}}static fromJson(t,e){if(![this.ARR_LEFT,this.ARR_RIGHT].includes(e?.operator))return;let r=new this(t).withFlag(...e.flags||[]);return r.path(e.lhs,e.operator,e.rhs),r}stringify(){return this.JOINT?this.autoEsc([this.JOINT.ALIAS.NAME,this.uuid]).join("."):`${this.LHS} ${this.OPERATOR} ${this.RHS}`}static parse(t,e,r){let{tokens:s,matches:i}=h.lex(e,[this.ARR_LEFT,this.ARR_RIGHT],{limit:1});if(!i.length)return;let n=new this(t),o=r(n,s[0],[_]),a=r(n,s[1],i[0]===this.ARR_LEFT?[this]:[this,rt,_]);return n.path(o,i[0],a),n}static factoryMethods={path:(t,e,r,s)=>[this.ARR_LEFT,this.ARR_RIGHT].includes(r)&&new this(t)}};var Bt=class extends T{CRITERIA=[];criterion(...t){return this.build("CRITERIA",t,I.Types)}stringify(){return this.CRITERIA.map(t=>t.stringify()).join(",")}toJson(){return{criteria:this.CRITERIA.map(t=>t.toJson()),flags:this.FLAGS}}static fromJson(t,e){if(!Array.isArray(e?.criteria))return;let r=new this(t).withFlag(...e.flags||[]);return r.criterion(...e.criteria),r}static parse(t,e,r){let[s,i]=e.match(new RegExp(`^${this.regex}([\\s\\S]*)$`,"i"))||[];if(!s)return;let n=new this(t);for(let o of h.split(i.trim(),[","]))n.criterion(r(n,o));return n}static regex="GROUP\\s+BY"};var qt=class extends Bt{withRollup(){return this.withFlag("WITH_ROLLUP")}stringify(){return["GROUP BY",super.stringify(),...this.FLAGS.map(t=>t.replace(/_/g," "))].join(" ")}static parse(t,e,r){let{tokens:[s],matches:i}=h.lex(e,["\\s+WITH\\s+ROLLUP$"],{useRegex:"i"}),n=super.parse(t,s,r);if(n)return i.length&&n.withFlag("WITH_ROLLUP"),n}};var oe=class extends T{CRITERIA=[];criterion(...t){return this.build("CRITERIA",t,I.Types)}toJson(){return{criteria:this.CRITERIA.map(t=>t.toJson()),flags:this.FLAGS}}static fromJson(t,e){if(!Array.isArray(e?.criteria))return;let r=new this(t).withFlag(...e.flags||[]);return r.criterion(...e.criteria),r}stringify(){return this.CRITERIA.map(t=>[t,...t.FLAGS].join(" ")).join(",")}static parse(t,e,r){let[s,i]=e.match(new RegExp(`^${this.regex}([\\s\\S]*)$`,"i"))||[];if(!s)return;let n=new this(t);for(let o of h.split(i.trim(),[","])){let[,a,c]=/([\s\S]+)\s+(ASC|DESC)$/i.exec(o)||[,o];n.criterion(r(n,a).withFlag(c))}return n}static regex="ORDER\\s+BY"};var P=class extends oe{withRollup(){return this.withFlag("WITH_ROLLUP")}stringify(){return["ORDER BY",super.stringify(),...this.FLAGS.map(t=>t.replace(/_/g," "))].join(" ")}static parse(t,e,r){let{tokens:[s],matches:i}=h.lex(e,["\\s+WITH\\s+ROLLUP$"],{useRegex:"i"}),n=super.parse(t,s.trim(),r);if(n)return i.length&&n.withFlag("WITH_ROLLUP"),n}};var Vt=class extends Bt{stringify(){return["PARTITION BY",super.stringify()].join(" ")}static regex="PARTITION\\s+BY"};var Rt=class extends T{NAME;WINDOW_REF;PARTITION_BY_CLAUSE;ORDER_BY_CLAUSE;name(t){return this.NAME=t,this}existing(t){return this.WINDOW_REF=t,this}extends(t){return this.WINDOW_REF=t,this}partitionBy(...t){if(this.WINDOW_REF)throw new Error("The PARTITION BY clause is not allowed when inheriting from a base window.");return this.build("PARTITION_BY_CLAUSE",t,Vt,"criterion")}orderBy(...t){return this.build("ORDER_BY_CLAUSE",t,P,"criterion")}toJson(){return{name:this.NAME,window_ref:this.WINDOW_REF,partition_by_clause:this.PARTITION_BY_CLAUSE?.toJson(),order_by_clause:this.ORDER_BY_CLAUSE?.toJson()}}static fromJson(t,e){if(typeof e=="string")e={window_ref:e};else if(!(typeof e=="object"&&e)||!["name","window_ref","partition_by_clause","order_by_clause"].some(s=>s in e))return;let r=new this(t);return e.name&&r.name(e.name),e.window_ref&&r.extends(e.window_ref),e.partition_by_clause&&r.partitionBy(e.partition_by_clause),e.order_by_clause&&r.orderBy(e.order_by_clause),r}stringify(){let t=[];return!this.NAME&&this.WINDOW_REF&&!this.PARTITION_BY_CLAUSE&&!this.ORDER_BY_CLAUSE?t.push(this.WINDOW_REF):(this.NAME&&t.push(`${this.NAME} AS `),t.push(`(${[this.WINDOW_REF,this.PARTITION_BY_CLAUSE,this.ORDER_BY_CLAUSE].filter(e=>e).join(" ")})`)),t.join("")}static parse(t,e,r){let s=new this(t),i=async a=>{let{tokens:[c,...f],matches:l}=h.lex(w(a.trim(),"(",")"),["PARTITION\\s+BY","ORDER\\s+BY"],{useRegex:"i",preserveDelims:!0});c.trim()&&s.extends(c.trim());for(let m of l){if(/PARTITION\s+BY/i.test(m)){s.partitionBy(r(s,f.shift().trim(),[Vt]));continue}s.orderBy(r(s,f.shift().trim(),[P]))}},n=e.endsWith(")");if(n&&!e.startsWith("(")){let[a,c]=spec.split(new RegExp(" AS ","i"));s.name(a.trim()),i(c)}else n?i(e):s.existing(e);return s}static regex="WINDOW|OVER"};var Qt=class extends T{WINDOWS_LIST=[];define(...t){return this.build("WINDOWS_LIST",t,Rt)}toJson(){return{window_list:this.WINDOWS_LIST.map(t=>t.toJson())}}static fromJson(t,e){if(!Array.isArray(e?.window_list))return;let r=new this(t);return r.define(...e.window_list),r}stringify(){return`WINDOW ${this.WINDOWS_LIST.join(",")}`}static parse(t,e,r){let[s,i]=e.match(new RegExp(`^${this.regex}([\\s\\S]*)$`,"i"))||[];if(!s)return;let n=new this(t);for(let o of h.split(i,[","]))n.define(r(n,o.trim(),[Window]));return n}static regex="WINDOW"};var Yt=class extends T{$EXPR;ALIAS;CLAUSED;get NAME(){return this.$EXPR?.NAME}get BASENAME(){return this.$EXPR?.BASENAME}get EXPR(){return this.$EXPR?.EXPR||this.$EXPR}name(t){return this.build("$EXPR",[t],_,"name"),this}query(...t){return this.build("$EXPR",t,V,"query"),this}expr(t){return this.build("$EXPR",[t],this.constructor.exprTypes),this}as(t,e=!0){return this.build("ALIAS",[t],_),this.CLAUSED=e,this}toJson(){return{expr:this.$EXPR?.toJson(),alias:this.ALIAS?.toJson(),claused:this.CLAUSED,flags:this.FLAGS}}static fromJson(t,e){let r=new this(t).withFlag(...e.flags||[]);return e?.expr?(r.expr(e.expr),e.alias&&r.as(e.alias,e.claused)):e&&r.expr(e),r}stringify(){let t=this.ALIAS||this.$EXPR instanceof q&&this.$EXPR.JOINT&&this.autoEsc(this.$EXPR.clone().stringify());return[this.$EXPR,this.CLAUSED?"AS":"",t].filter(e=>e).join(" ")}static parse(t,e,r){let s=new this(t),i=this.getEscChar(t,!0),[,n,o,a,,c]=new RegExp(`^([\\s\\S]+?)(?:(\\s+AS\\s+|(?<!(?:~>|<~))\\s+)(?:([\\w]+)|(${i})((?:\\4\\4|[^\\4])+)\\4))?$`,"i").exec(e.trim())||[],f,l=a||c;if(l&&!o?.trim()&&!n.trim().endsWith(")")){try{f=r(s,n,this.exprTypes)}catch{}f||(l=a=c=null,n=e)}if(f||(f=r(s,n,this.exprTypes)),s.expr(f),l){let m=a||this.autoUnesc(s,c),p=!!o?.trim();s.as(m,p)}return s}static get exprTypes(){return I.Types}};var Tt=class extends T{NAME="";ARGS=[];fn(t,...e){return this.NAME=t,this.build("ARGS",e,I.Types)}toJson(){return{name:this.NAME,args:this.ARGS.map(t=>t.toJson()),flags:this.FLAGS}}static fromJson(t,e){if(typeof e?.name!="string"||!Array.isArray(e.args))return;let r=new this(t).withFlag(...e.flags||[]);return r.fn(e.name,...e.args),r}stringify(){return`${this.NAME.toUpperCase()}(${this.ARGS.join(", ")})`}static parse(t,e,r){if(!e.endsWith(")")||h.match(e,[" "]).length)return;let[,s,i=""]=/^(\w+)\(([\s\S]+)?\)$/i.exec(e),n=new this(t);return n.fn(s,...h.split(i,[","]).map(o=>r(n,o.trim()))),n}};var lt=class extends Tt{ORDER_BY_CLAUSE;OVER_CLAUSE;fn(...t){return super.fn(...t),this}orderBy(...t){return this.build("ORDER_BY_CLAUSE",t,P,"criterion"),this}over(t){return t||(t={name:""}),this.build("OVER_CLAUSE",[t],Rt),this.OVER_CLAUSE}toJson(){return{...super.toJson(),order_by_clause:this.ORDER_BY_CLAUSE?.toJson(),over_clause:this.OVER_CLAUSE?.toJson()}}static fromJson(t,e){let r=super.fromJson(t,e);if(r)return this.names.flat().includes(r.NAME.toUpperCase())&&(e.order_by_clause&&r.orderBy(e.order_by_clause),e.over_clause&&r.over(e.over_clause)),r}stringify(){return`${this.NAME.toUpperCase()}(${[...this.FLAGS,this.ARGS.join(","),this.ORDER_BY_CLAUSE].filter(e=>e).join(" ")})`+(this.OVER_CLAUSE?` OVER ${this.OVER_CLAUSE}`:"")}static parse(t,e,r){let[s,i]=h.split(e,["OVER\\s+"],{useRegex:"i"}).map(m=>m.trim());if(!s.endsWith(")")||h.match(s,[" "]).length)return;let[,n,o,a=""]=/^(\w+)\((?:\s+)?(?:(ALL|DISTINCT)\s+)?([\s\S]+)?\)$/i.exec(s);if(!this.names.flat().includes(n.toUpperCase()))return;let[,c,f]=/^([\s\S]+)(?:\s+(ORDER\s+BY\s+.+))$/i.exec(a)||[,a],l=super.parse(t,`${n}(${c})`,r);return o&&l.withFlag(o),f?l.orderBy(r(l,f,[P])):i&&l.over(r(l,i,[Rt])),l}static factoryMethods={fn:(t,e,...r)=>this.names.flat().includes(e?.toUpperCase())&&new this(t)};static names=[["AVG","BIT_AND","BIT_OR","BIT_XOR","COUNT","JSON_ARRAYAGG","JSON_OBJECTAGG","MAX","MIN","STDDEV_POP","STDDEV","STD","STDDEV_SAMP","SUM","VAR_POP","VARIANCE","VAR_SAMP","GROUP_CONCAT","GROUP_CONCAT_WS"],["CUME_DIST","DENSE_RANK","FIRST_VALUE","LAG","LAST_VALUE","LEAD","NTH_VALUE","NTLE","PERCENT_RANK","RANK","ROW_NUMBER"],["ANY_VALUE","COLUMN","COLUMNS","GROUPING"]]};var G=class extends Yt{path(t,e,r){return this.build("$EXPR",[t,e,r],rt.OPERATORS.includes(e)?rt:q,"path"),this}fn(t,...e){return this.build("$EXPR",[t,...e],lt.names.flat().includes(t.toUpperCase())?lt:Tt,"fn"),this}case(...t){return this.build("$EXPR",t,Ft),this}};var x=class extends Yt{static get exprTypes(){return[V,_]}};var X=class u extends F{SELECT_LIST=[];FROM_LIST=[];JOIN_LIST=[];WHERE_CLAUSE=null;GROUP_BY_CLAUSE=null;HAVING_CLAUSE=null;WINDOW_CLAUSE=null;ORDER_BY_CLAUSE=null;OFFSET_CLAUSE=null;LIMIT_CLAUSE=null;get TABLES(){return this.FROM_LIST}AGGRS=[];PATHS=[];VARS=[];SUBQUERIES=[];select(...t){return this.build("SELECT_LIST",t,G)}from(...t){return this.build("FROM_LIST",t,x),this.FROM_LIST[this.FROM_LIST.length-1]}join(t){return this.build("JOIN_LIST",[t],y,"full")}leftJoin(t){return this.build("JOIN_LIST",[t],y,"left")}rightJoin(t){return this.build("JOIN_LIST",[t],y,"right")}innerJoin(t){return this.build("JOIN_LIST",[t],y,"inner")}crossJoin(t){return this.build("JOIN_LIST",[t],y,"cross")}where(...t){return this.build("WHERE_CLAUSE",t,L,"and")}groupBy(...t){return this.build("GROUP_BY_CLAUSE",t,qt,"criterion"),this.GROUP_BY_CLAUSE}having(...t){return this.build("HAVING_CLAUSE",t,L,"and")}window(...t){return this.build("WINDOW_CLAUSE",t,Qt,"define")}orderBy(...t){return this.build("ORDER_BY_CLAUSE",t,P,"criterion"),this.ORDER_BY_CLAUSE}offset(t){if(typeof t!="number")throw new Error("Offsets must be of type number.");this.OFFSET_CLAUSE=t}limit(...t){if(!t.every(e=>typeof e=="number"))throw new Error("Limits must be of type number.");this.LIMIT_CLAUSE=t}connectedNodeCallback(t){t instanceof lt&&this.AGGRS.push(t),t instanceof q&&!(t.CONTEXT instanceof q)&&this.PATHS.push(t),t instanceof Jt&&this.VARS.push(t),t instanceof u&&this.SUBQUERIES.push(t)}get expandable(){return this.PATHS.length>0||this.SUBQUERIES.some(t=>t.expandable)}async expand(t=!1){let e=t?this:this.clone();if(!e.expandable)return e;for(let r of e.PATHS)await r.plot();for(let r of e.SUBQUERIES)await r.expand(!0);return e}toJson(){return{select_list:this.SELECT_LIST.map(t=>t.toJson()),from_list:this.FROM_LIST.map(t=>t.toJson()),join_list:this.JOIN_LIST.map(t=>t.toJson()),where_clause:this.WHERE_CLAUSE?.toJson(),group_by_clause:this.GROUP_BY_CLAUSE?.toJson(),having_clause:this.HAVING_CLAUSE?.toJson(),window_clause:this.WINDOW_CLAUSE?.toJson(),order_by_clause:this.ORDER_BY_CLAUSE?.toJson(),offset_clause:this.OFFSET_CLAUSE,limit_clause:this.LIMIT_CLAUSE,flags:this.FLAGS}}static fromJson(t,e){if(!Array.isArray(e?.select_list))return;let r=new this(t).withFlag(...e.flags||[]);return r.select(...e.select_list),e.from_list?.length&&r.from(...e.from_list),e.join_list?.length&&r.join(...e.join_list),e.where_clause&&r.where(e.where_clause),e.group_by_clause&&r.groupBy(e.group_by_clause),e.having_clause&&r.having(e.having_clause),e.window_clause&&r.window(e.window_clause),e.order_by_clause&&r.orderBy(e.order_by_clause),e.offset_clause&&r.offset(e.offset_clause),e.limit_clause&&r.limit(e.limit_clause),r}stringify(t={}){let e=["SELECT"];return this.FLAGS.length&&e.push(this.FLAGS.map(r=>r.replace(/_/g," "))),e.push(this.SELECT_LIST.join(", ")),this.FROM_LIST.length&&e.push("FROM",this.FROM_LIST.join(", ")),this.JOIN_LIST.length&&e.push(...this.JOIN_LIST),this.WHERE_CLAUSE&&e.push("WHERE",this.WHERE_CLAUSE),this.GROUP_BY_CLAUSE&&e.push(this.GROUP_BY_CLAUSE),this.HAVING_CLAUSE&&e.push("HAVING",this.HAVING_CLAUSE),this.WINDOW_CLAUSE&&e.push(this.WINDOW_CLAUSE),this.ORDER_BY_CLAUSE&&e.push(this.ORDER_BY_CLAUSE),this.OFFSET_CLAUSE&&e.push("OFFSET",this.OFFSET_CLAUSE),this.LIMIT_CLAUSE&&e.push("LIMIT",(Array.isArray(this.LIMIT_CLAUSE)?this.LIMIT_CLAUSE:[this.LIMIT_CLAUSE]).join(",")),e.join(" ")}static parse(t,e,r){let[s,i,n,o]=/^SELECT\s+(?:(WITH\s+UAC)\s+)?(ALL|DISTINCT)?([\s\S]+)$/i.exec(e.trim())||[];if(!s)return;let a=new this(t);i&&a.withFlag("WITH_UAC"),n&&a.withFlag(n);let c=this.mySubstitutePlaceholders(a,o.trim()),f={from:{backtest:"^(?!.*\\s+DISTINCT\\s+$)",test:"FROM"},join:y,where:"WHERE",groupBy:qt,having:"HAVING",window:Qt,orderBy:P,offset:"OFFSET",limit:"LIMIT"},{tokens:[l,...m],matches:p}=h.lex(c,Object.values(f).map(E=>typeof E=="string"||E.test?E:E.regex),{useRegex:"i"});for(let E of h.split(l,[","])){let A=r(a,E.trim(),[G]);a.select(A)}for(let E of p){let A=E.replace(/\s+/g,""),d=Object.keys(f).find(N=>new RegExp(N,"i").test(A));if(d==="from")for(let N of h.split(m.shift(),[","])){let S=r(a,N.trim(),[x]);a.from(S)}else if(["where","having"].includes(d)){let N=r(a,m.shift().trim(),[L,D]);a[d](N)}else if(["offset","limit"].includes(d)){let N=m.shift().split(",").map(S=>parseInt(S.trim()));a[d](...N)}else{let N=r(a,`${E} ${m.shift().trim()}`,[f[d]]);a[d](N)}}return a}};var V=class extends T{$EXPR;constructor(t,e){super(t),this.$EXPR=e}get NAME(){return this.$EXPR?.NAME}get BASENAME(){return this.$EXPR?.BASENAME}get EXPR(){return this.$EXPR?.EXPR||this.$EXPR}query(...t){return this.build("$EXPR",t,X),this.$EXPR}expr(...t){return this.build("$EXPR",t,[X,...I.Types]),this.$EXPR}toJson(){return{expr:this.$EXPR?.toJson(),flags:this.FLAGS}}static fromJson(t,e){if(!e?.expr||Object.keys(e).length!==(e.flags?2:1))return;let r=new this(t).withFlag(...e.flags||[]);return r.expr(e.expr),r}stringify(){return"("+this.$EXPR.stringify()+")"}static parse(t,e,r){if(!(!B(e,"(",")")||h.match(e,[" "]).length&&h.split(e,[]).length===2))return new this(t,r(t,w(e,"(",")"),[X,...I.Types]))}};var ae=class extends T{OPERATOR="";OPERANDS=[];constructor(t,e,...r){super(t),this.OPERATOR=e,this.OPERANDS=r}calc(t,...e){return this.OPERATOR&&this.OPERATOR!==t?new this.constructor(this).calc(t,this,...e):(this.OPERATOR=t,this.build("OPERANDS",e,I.Types),this)}sum(...t){return this.calc("+",...t)}sub(...t){return this.calc("-",...t)}div(...t){return this.calc("/",...t)}times(...t){return this.calc("*",...t)}toJson(){return{operator:this.OPERATOR,operands:this.OPERANDS.map(t=>t.toJson()),flags:this.FLAGS}}static fromJson(t,e){if(typeof e?.operator!="string"||!/\+|\-|\*|\//.test(e.operator)||!Array.isArray(e.operands))return;let r=new this(t).withFlag(...e.flags||[]);return r.calc(e.operator,...e.operands),r}stringify(){return this.OPERANDS.join(` ${this.OPERATOR} `)}static parse(t,e,r){for(let s of["\\*","\\/","\\+","\\-"]){let{tokens:i,matches:n}=h.lex(e,[`(\\s+)?${s}(\\s+)?`],{useRegex:"i"});if(!(i.filter(o=>o.trim()).length<2))return new this(t,n.pop().trim(),...i.map(o=>r(t,o.trim())))}}};var ue=class extends T{STRINGS=[];join(...t){return this.build("STRINGS",t,I.Types)}toJson(){return{strings:this.STRINGS.map(t=>t.toJson()),flags:this.FLAGS}}static fromJson(t,e){if(!Array.isArray(e?.strings))return;let r=new this(t).withFlag(...e.flags||[]);return r.join(...e.strings),r}stringify(){return this.STRINGS.join(" || ")}static parse(t,e,r){if((t?.params?.inputDialect||t?.params?.dialect)==="mysql")return;let s=h.split(e,["||"]);if(s.length<2)return;let i=new this(t);return i.join(...s.map(n=>r(i,n.trim()))),i}};var ce=class extends T{VALUE;constructor(t,e){super(t),this.VALUE=e}literal(t){this.VALUE=t}true(){this.VALUE=!0}false(){this.VALUE=!1}null(){this.VALUE=null}toJson(){return this.VALUE}static fromJson(t,e){if([!0,!1,null].includes(e))return new this(t,e)}stringify(){return`${this.VALUE}`}static parse(t,e){if(/^(TRUE|FALSE|NULL)$/i.test(e))return new this(t,JSON.parse(e.toLowerCase()))}};var I=class{static cast(t,e,r=this.Types){if(typeof e=="function"){if(r.length===1){let n=new r[0](t);return e(n),n}let s,i=n=>(...o)=>{let a=r.reduce((c,f)=>c||(f.factoryMethods?typeof f.factoryMethods[n]=="function"&&f.factoryMethods[n](t,...o):typeof f.prototype[n]=="function"&&new f(t)),null);if(!a)throw new Error(`Unknown method: ${n}()`);if(s=a,a[n])return a[n](...o);for(let c of o)c(a)};return e(new Proxy({},{get:(n,o)=>i(o)})),s}return this.fromJson(t,e,r)}static fromJson(t,e,r=this.Types){let s=r.reduce((i,n)=>i||(e instanceof n?e:n.fromJson(t,e)),null);if(!s)throw new Error("");return s}static parse(t,e,r){return r(t,e,this.Types)}static get Types(){return[V,Ft,ue,L,q,rt,D,ae,ne,lt,Tt,ft,_t,ct,ce,Jt,_]}};var D=class extends T{OPERATOR="";OPERANDS=[];constructor(t,e,...r){super(t),this.OPERATOR=e,this.OPERANDS=r}assert(t,...e){return this.OPERATOR&&this.OPERANDS.splice(0),this.OPERATOR=t,this.build("OPERANDS",e,I.Types),this}equals(...t){return this.assert("=",...t)}eq(...t){return this.equal(...t)}notEqual(...t){return this.assert("<>",...t)}notEq(...t){return this.notEqual(...t)}lesserThan(...t){return this.assert("<",...t)}lt(...t){return this.lesserThan(...t)}lessThanOrEqual(...t){return this.assert("<=",...t)}ltOrEq(...t){return this.lessThanOrEqual(...t)}greaterThan(...t){return this.assert(">",...t)}gt(...t){return this.greaterThan(...t)}greaterThanOrEqual(...t){return this.assert(">=",...t)}gtOrEq(...t){return this.greaterThanOrEqual(...t)}in(...t){return this.assert("IN",...t)}any(...t){return this.assert("ANY",...t)}like(...t){return this.assert("LIKE",...t)}isNull(...t){return this.assert("IS NULL",...t)}isNotNull(...t){return this.assert("IS NOT NULL",...t)}isTrue(...t){return this.assert("IS TRUE",...t)}isNotTrue(...t){return this.assert("IS NOT TRUE",...t)}isFalse(...t){return this.assert("IS FALSE",...t)}isNotFalse(...t){return this.assert("IS NOT FALSE",...t)}isUnknow(...t){return this.assert("IS UNKNOWN",...t)}isNotUnknow(...t){return this.assert("IS NOT UNKNOWN",...t)}isDistinctFrom(...t){return this.assert("IS DISTINCT FROM",...t)}isNotDistinctFrom(...t){return this.assert("IS NOT DISTINCT FROM",...t)}isBetween(...t){return this.assert("IS BETWEEN",...t)}isNotBetween(...t){return this.assert("IS NOT BETWEEN",...t)}isBetweenSymmetric(...t){return this.assert("IS BETWEEN SYMMETRIC",...t)}isNotBetweenSymmetric(...t){return this.assert("IS NOT BETWEEN SYMMETRIC",...t)}and(...t){return new L(this,"AND").and(this,...t)}or(...t){return new L(this,"OR").or(this,...t)}toJson(){return{operator:this.OPERATOR,operands:this.OPERANDS.map(t=>t.toJson()),flags:this.FLAGS}}static fromJson(t,e){if(!Array.isArray(e?.operands)||typeof e?.operator!="string"||!this.regexes.some(s=>new RegExp(s.regex||s.test||s).test(` ${e.operator} `)))return;let r=new this(t).withFlag(...e.flags||[]);return r.assert(e.operator,...e.operands),r}stringify(){let t=this.OPERANDS.slice(0),e=[t.shift(),this.OPERATOR.toUpperCase()],r=t;return this.OPERATOR==="IN"?e.push(`(${r.join(",")})`):/BETWEEN/i.test(this.OPERATOR)?e.push(`(${r.join(" AND ")})`):e.push(`${r.join(" ")}`),e.filter(s=>s).join(" ")}static parse(t,e,r){let{tokens:[s,i=""],matches:[n]}=h.lex(e,this.regexes,{useRegex:"i"});if(!n)return;let o=n.trim().toUpperCase(),a=[s];return o==="IN"?a.push(...h.split(w(i.trim(),"(",")"),[","])):/BETWEEN/.test(o)?a.push(...h.split(i,[" AND "])):i&&a.push(i),new this(t,o,...a.map(c=>r(t,c.trim())))}static regexes=[{test:"<(?!~)"},{backtest:"^(?!.*~$)",test:">",regex:"(?<!~)>"},"((\\s+(?:NOT\\s+)?IS\\s+(?:NOT\\s+)?(TRUE|FALSE|NULL|UNKNOWN|DISTINCT\\s+FROM\\s+))|\\s+(ISNULL|NOTNULL|IN|ANY|LIKE|(?:NOT\\s+)?BETWEEN(?:\\s+SYMMETRIC)?)\\s+|(?:\\s+)?(=|<=|>=|!=|<>)(?:\\s+)?)"]};var L=class u extends T{LOGIC="";ASSERTIONS=[];constructor(t,e){super(t),this.LOGIC=e}and(...t){return this.LOGIC==="OR"?new this.constructor(this).and(this,...t):(this.LOGIC="AND",this.build("ASSERTIONS",t,[u,D,V]),this)}or(...t){return this.LOGIC==="AND"?new this.constructor(this).or(this,...t):(this.LOGIC="OR",this.build("ASSERTIONS",t,[u,D,V]),this)}toJson(){return{logic:this.LOGIC,assertions:this.ASSERTIONS.map(t=>t.toJson()),flags:this.FLAGS}}static fromJson(t,e){if(typeof e?.logic!="string"||!/AND|OR/i.test(e.logic)||!Array.isArray(e.assertions))return;let r=new this(t).withFlag(...e.flags||[]);return r[e.logic.toLowerCase()](...e.assertions),r}stringify(){return this.ASSERTIONS.map(t=>t instanceof u?`(${t.stringify()})`:t.stringify()).join(" "+this.LOGIC+" ")}static parse(t,e,r){for(let s of["AND","OR"]){let i=h.split(e,[`\\s+${s}\\s+`],{useRegex:"i"});if(i.length>1){let n=new this(t,s);for(let o of i)n[s.toLowerCase()](r(n,o));return n}}}};var y=class extends x{TYPE="";CORRELATION=null;full(t){return this.TYPE="JOIN",this.expr(t),this}left(t){return this.TYPE="LEFT_JOIN",this.expr(t),this}right(t){return this.TYPE="RIGHT_JOIN",this.expr(t),this}inner(t){return this.TYPE="INNER_JOIN",this.expr(t),this}cross(t){return this.TYPE="CROSS_JOIN",this.expr(t),this}on(...t){return this.build("CORRELATION",t,L,"and")}using(t){return this.build("CORRELATION",[t],_)}toJson(){return{type:this.TYPE,correlation:this.CORRELATION?.toJson(),...super.toJson()}}static fromJson(t,e){let r=super.fromJson(t,e);if(!(!r||!e.type))return e?.expr&&e.type&&(r.TYPE=e.type),e?.expr&&e.correlation&&r.build("CORRELATION",[e.correlation],[_,L]),r}stringify(){return[this.TYPE?.replace(/_/," ").toUpperCase()||"JOIN",super.stringify(),this.CORRELATION instanceof _?`USING ${this.CORRELATION}`:`ON ${this.CORRELATION}`].filter(t=>t).join(" ")}static parse(t,e,r){let[s,i,n]=e.match(new RegExp(`^${this.regex}([\\s\\S]*)$`,"i"))||[];if(!s)return;let{tokens:[o,a],matches:c}=h.lex(n,["\\s+(?:ON|USING)\\s+"],{useRegex:"i"}),f=super.parse(t,o.trim(),r);return f.TYPE=i.trim().toUpperCase()+"_JOIN",/USING/i.test(c[0])?f.using(r(f,a.trim(),[_])):/ON/i.test(c[0])&&f.on(r(f,a.trim(),[L,D])),f}static regex="(INNER\\s+|CROSS\\s+|(?:LEFT|RIGHT)(?:\\s+OUTER)?\\s+)?JOIN"};var vt=class extends F{DELETE_LIST=[];FROM_LIST=[];USING_LIST=[];JOIN_LIST=[];WHERE_CLAUSE=null;ORDER_BY_CLAUSE=null;LIMIT_CLAUSE=null;RETURNING_LIST=[];get TABLES(){return this.USING_LIST.length?this.USING_LIST:this.FROM_LIST}delete(...t){return this.build("DELETE_LIST",t,_)}from(...t){return this.build("FROM_LIST",t,[_,x])}using(...t){return this.build("USING_LIST",t,x)}join(t){return this.build("JOIN_LIST",[t],y,"full")}leftJoin(t){return this.build("JOIN_LIST",[t],y,"left")}rightJoin(t){return this.build("JOIN_LIST",[t],y,"right")}innerJoin(t){return this.build("JOIN_LIST",[t],y,"inner")}crossJoin(t){return this.build("JOIN_LIST",[t],y,"cross")}where(...t){return this.build("WHERE_CLAUSE",t,L,"and")}orderBy(...t){return this.build("ORDER_BY_CLAUSE",t,P,"criterion"),this.ORDER_BY_CLAUSE}limit(...t){if(!t.every(e=>typeof e=="number"))throw new Error("Limits must be of type number.");this.LIMIT_CLAUSE=t}returning(...t){return this.build("RETURNING_LIST",t,G)}toJson(){return{delete_list:this.DELETE_LIST.map(t=>t.toJson()),from_list:this.FROM_LIST.map(t=>t.toJson()),using_list:this.USING_LIST.map(t=>t.toJson()),join_list:this.JOIN_LIST.map(t=>t.toJson()),where_clause:this.WHERE_CLAUSE?.toJson(),order_by_clause:this.ORDER_BY_CLAUSE?.toJson(),limit_clause:this.LIMIT_CLAUSE,returning_list:this.RETURNING_LIST,flags:this.FLAGS}}static fromJson(t,e){if(!Array.isArray(e?.from_list))return;let r=new this(t).withFlag(...e.flags||[]);return e.delete_list?.length&&r.delete(...e.delete_list),r.from(...e.from_list),e.using_list?.length&&r.using(...e.using_list),e.join_list?.length&&r.join(...e.join_list),e.where_clause&&r.where(e.where_clause),e.order_by_clause&&r.orderBy(e.order_by_clause),e.limit_clause&&r.limit(e.limit_clause),e.returning_list&&r.returning(...e.returning_list),r}stringify(){let t=["DELETE"];return this.FLAGS.length&&t.push(this.FLAGS.map(e=>e.replace(/_/g," "))),this.DELETE_LIST.length&&t.push(this.DELETE_LIST.join(", ")),t.push("FROM",this.FROM_LIST.join(", ")),this.USING_LIST.length&&t.push("USING",this.USING_LIST.join(", ")),this.JOIN_LIST.length&&t.push(...this.JOIN_LIST),this.WHERE_CLAUSE&&t.push("WHERE",this.WHERE_CLAUSE),this.ORDER_BY_CLAUSE&&t.push(this.ORDER_BY_CLAUSE),this.LIMIT_CLAUSE&&t.push("LIMIT",this.LIMIT_CLAUSE),this.RETURNING_LIST.length&&t.push("RETURNING",this.RETURNING_LIST.join(", ")),t.join(" ")}static parse(t,e,r){let[s,i,n,o]=/^DELETE(\s+WITH\s+UAC)?(?:\s+(IGNORE))?([\s\S]+)$/i.exec(e.trim())||[];if(!s)return;let a=new this(t);i&&a.withFlag("WITH_UAC"),n&&a.withFlag(n);let c=this.mySubstitutePlaceholders(a,o.trim()),f={from:{backtest:"^(?!.*\\s+DISTINCT\\s+$)",test:"FROM"},using:{backtest:"^(?!.*\\s+JOIN\\s+)",test:"USING"},join:y,where:"WHERE",orderBy:P,limit:"LIMIT",returning:"RETURNING"},{tokens:[l,...m],matches:p}=h.lex(c,Object.values(f).map(E=>typeof E=="string"||E.test?E:E.regex),{useRegex:"i"});for(let E of h.split(l,[","])){let A=r(a,E.trim(),[_]);a.delete(A)}for(let E of p){let A=E.replace(/\s+/g,""),d=Object.keys(f).find(N=>new RegExp(N,"i").test(A));if(["from","using"].includes(d))for(let N of h.split(m.shift(),[","])){let S=d==="from"&&p.some(C=>C.toLowerCase()==="using")?_:x,R=r(a,N.trim(),[S]);a[d](R)}else if(d==="where"){let N=r(a,m.shift().trim(),[L,D]);a.where(N)}else if(d==="limit")a.limit(parseInt(m.shift().trim()));else if(d==="returning")a.returning(...h.split(m.shift(),[","]).map(N=>r(a,N.trim(),[G])));else{let N=r(a,`${E} ${m.shift().trim()}`,[f[d]]);a[d](N)}}return a}};var At=class extends T{LIST=[];list(...t){return this.build("LIST",t,_)}toJson(){return{list:this.LIST.slice(0)}}static fromJson(t,e){if(Array.isArray(e?.list))return new this(t).col(...e.list)}stringify(){return`(${this.LIST.join(", ")})`}static parse(t,e,r){if(!B(e,"(",")"))return;let s=new this(t);return s.list(...h.split(w(e,"(",")"),[","]).map(i=>r(s,i.trim(),[_]))),s}};var dt=class extends T{LIST=[];list(...t){return this.build("LIST",t,I.Types)}toJson(){return{list:this.LIST.slice(0)}}static fromJson(t,e){if(Array.isArray(e?.list))return new this(t).list(...e.list)}stringify(){return`(${this.LIST.join(", ")})`}static parse(t,e,r){if(!B(e,"(",")"))return;let s=new this(t);return s.list(...h.split(w(e,"(",")"),[","]).map(i=>r(s,i.trim(),I.Types))),s}};var st=class extends T{ENTRIES=[];set(t,e){return Array.isArray(t)?(t=At.fromJson(this,t),Array.isArray(e)?e=dt.fromJson(this,e):e=I.cast(this,e)):t instanceof T||(t=_.fromJson(this,t),e=I.cast(this,e)),this.ENTRIES.push([t,e]),this}toJson(){return{entries:this.ENTRIES.map(([t,e])=>[t.toJson(),e.toJson()])}}static fromJson(t,e){if(!Array.isArray(e?.entries))return;let r=new this(t);for(let[s,i]of e.entries)r.set(s,i);return r}stringify(){return`
	${this.ENTRIES.map(([t,e])=>`${t} = ${e}`).join(`,
	`)}`}static parse(t,e,r){let s=new this(t);for(let i of h.split(e,[","])){let[n,o]=h.split(i,["="]).map(a=>a.trim()).filter(a=>a);if(!o)return;if(B(n,"(",")")){let a=r(s,o.trim(),[At]);if(!B(o,"(",")"))return;let c=/^\((\s+)?SELECT\s+/i.test(o)?r(s,o.trim()):r(s,o.trim(),[dt]);s.set(a,c)}else{let a=r(s,n),c=r(s,o);s.set(a,c)}}return s}};var Zt=class extends st{WHERE_CLAUSE=null;where(...t){return this.build("WHERE_CLAUSE",t,L,"and")}toJson(){return{...super.toJson(),where_clause:this.WHERE_CLAUSE?.toJson()}}static fromJson(t,e){let r=super.fromJson(t,e);if(r)return e.where_clause&&r.where(e.where_clause),r}stringify(){let t=[];return this.params.dialect==="mysql"?t.push("ON DUPLICATE KEY UPDATE"):t.push(`ON CONFLICT ${this.ENTRIES.length?"DO UPDATE SET":"DO NOTHING"}`),t.push(super.stringify()),this.WHERE_CLAUSE&&t.push("WHERE",this.WHERE_CLAUSE),t.join(" ")}static parse(t,e,r){let[s,i,n,o]=e.match(new RegExp(`^${this.regex}([\\s\\S]*)$`,"i"))||[];if(!s)return;if(/DO\s+NOTHING/i.test(n))return new this(t);let[a,c]=h.split(o,["WHERE"],{ci:!0}),f=super.parse(t,a,r);return c&&f.where(r(f,c.trim(),[L,D])),f}static regex="ON\\s+(?:DUPLICATE\\s+KEY|CONFLICT(?:\\s+([\\s\\S]+))?)\\s+(UPDATE|DO\\s+NOTHING|DO\\s+UPDATE\\s+SET\\s+)"};var gt=class extends F{TABLE=null;COLUMNS_LIST=[];VALUES_LIST=[];SET_CLAUSE=null;SELECT_CLAUSE=null;ON_CONFLICT_CLAUSE=null;RETURNING_LIST=[];get TABLES(){return this.TABLE?[this.TABLE]:[]}into(t){return this.build("TABLE",[t],x)}columns(...t){return this.build("COLUMNS_LIST",t,At,"list")}values(...t){return this.build("VALUES_LIST",t,dt,"list")}set(...t){return this.build("SET_CLAUSE",t,st,"set")}select(t){return this.build("SELECT_CLAUSE",[t],X)}onConflict(...t){return this.build("ON_CONFLICT_CLAUSE",t,Zt)}returning(...t){return this.build("RETURNING_LIST",t,G)}toJson(){return{table:this.TABLE.toJson(),columns_list:this.COLUMNS_LIST.toJson(),values_list:this.VALUES_LIST.toJson(),set_clause:this.SET_CLAUSE?.toJson(),select_clause:this.SELECT_CLAUSE?.toJson(),on_conflict_clause:this.ON_CONFLICT_CLAUSE?.toJson(),returning_list:this.RETURNING_LIST,flags:this.FLAGS}}static fromJson(t,e){if(!e?.table)return;let r=new this(t).withFlag(...e.flags||[]);return r.into(e.table),e.columns_list?.length&&r.columns(...e.columns_list),e.values_list?.length&&r.values(...e.values_list),e.set_clause&&r.set(e.set_clause),e.select_clause&&r.select(e.select_clause),e.on_conflict_clause&&r.onConflict(e.on_conflict_clause),e.returning_list?.length&&r.returning(...e.returning_list),r}stringify(){let t=["INSERT"];return this.FLAGS.length&&t.push(this.FLAGS.map(e=>e.replace(/_/g," "))),t.push("INTO",this.TABLE),this.SET_CLAUSE?t.push("SET",this.SET_CLAUSE):(this.COLUMNS_LIST&&t.push(this.COLUMNS_LIST),this.SELECT_CLAUSE?t.push(this.SELECT_CLAUSE):t.push("VALUES",this.VALUES_LIST)),this.ON_CONFLICT_CLAUSE&&t.push(this.ON_CONFLICT_CLAUSE),this.RETURNING_LIST.length&&t.push("RETURNING",this.RETURNING_LIST.join(", ")),t.join(" ")}static parse(t,e,r){let[s,i,n,o]=/^INSERT(\s+WITH\s+UAC)?(?:\s+(IGNORE))?(?:\s+INTO)?([\s\S]+)$/i.exec(e.trim())||[];if(!s)return;let a=this.mySubstitutePlaceholders(t,o.trim()),{tokens:[c,f,l,m],matches:[p,E]}=h.lex(a,["(VALUES|VALUE|SET|SELECT)","ON\\s+(DUPLICATE\\s+KEY|CONFLICT)","RETURNING"],{useRegex:"i"}),A=new this(t);if(i&&A.withFlag("WITH_UAC"),n&&A.withFlag(n),/^SET$/i.test(p))A.into(r(A,c,[x])),A.set(r(A,f.trim(),[st]));else{let d=h.split(c,[]);if(A.into(r(A,d.shift().trim(),[x])),d.length&&A.columns(r(A,d.shift().trim(),[At])),/^SELECT$/i.test(p))A.select(r(A,`SELECT ${f}`));else for(let N of h.split(f,[","]))A.values(r(A,N.trim(),[dt]))}return E&&A.onConflict(r(A,`${E} ${l}`,[Zt])),m&&A.returning(...h.split(m,[","]).map(d=>r(A,d.trim(),[G]))),A}};var Gt=class extends F{TABLE_LIST=[];JOIN_LIST=[];SET_CLAUSE=null;WHERE_CLAUSE=null;ORDER_BY_CLAUSE=null;LIMIT_CLAUSE=null;RETURNING_LIST=[];get TABLES(){return this.TABLE_LIST}table(...t){return this.build("TABLE_LIST",t,x)}join(t){return this.build("JOIN_LIST",[t],y,"full")}leftJoin(t){return this.build("JOIN_LIST",[t],y,"left")}rightJoin(t){return this.build("JOIN_LIST",[t],y,"right")}innerJoin(t){return this.build("JOIN_LIST",[t],y,"inner")}crossJoin(t){return this.build("JOIN_LIST",[t],y,"cross")}set(...t){return this.build("SET_CLAUSE",t,st,"set")}where(...t){return this.build("WHERE_CLAUSE",t,L,"and")}orderBy(...t){return this.build("ORDER_BY_CLAUSE",t,P,"criterion"),this.ORDER_BY_CLAUSE}limit(...t){if(!t.every(e=>typeof e=="number"))throw new Error("Limits must be of type number.");this.LIMIT_CLAUSE=t}returning(...t){return this.build("RETURNING_LIST",t,G)}toJson(){return{table_list:this.TABLE_LIST.map(t=>t.toJson()),join_list:this.JOIN_LIST.map(t=>t.toJson()),set_clause:this.SET_CLAUSE?.toJson(),where_clause:this.WHERE_CLAUSE?.toJson(),order_by_clause:this.ORDER_BY_CLAUSE?.toJson(),limit_clause:this.LIMIT_CLAUSE,returning_list:this.RETURNING_LIST,flags:this.FLAGS}}static fromJson(t,e){if(!Array.isArray(e?.table_list))return;let r=new this(t).withFlag(...e.flags||[]);return r.table(...e.table_list),e.join_list?.length&&r.join(...e.join_list),e.set_clause&&r.set(e.set_clause),e.where_clause&&r.where(e.where_clause),e.order_by_clause&&r.orderBy(e.order_by_clause),e.limit_clause&&r.limit(e.limit_clause),e.returning_list?.length&&r.returning(...e.returning_list),r}stringify(){let t=["UPDATE"];return this.FLAGS.length&&t.push(this.FLAGS.map(e=>e.replace(/_/g," "))),t.push(this.TABLE_LIST.join(", ")),this.JOIN_LIST.length&&t.push(...this.JOIN_LIST),t.push("SET",this.SET_CLAUSE),this.WHERE_CLAUSE&&t.push("WHERE",this.WHERE_CLAUSE),this.ORDER_BY_CLAUSE&&t.push(this.ORDER_BY_CLAUSE),this.LIMIT_CLAUSE&&t.push("LIMIT",this.LIMIT_CLAUSE),this.RETURNING_LIST.length&&t.push("RETURNING",this.RETURNING_LIST.join(", ")),t.join(" ")}static parse(t,e,r){let[s,i,n,o]=/^UPDATE(\s+WITH\s+UAC)?(?:\s+(IGNORE))?([\s\S]+)$/i.exec(e.trim())||[];if(!s)return;let a=new this(t);i&&a.withFlag("WITH_UAC"),n&&a.withFlag(n);let c=this.mySubstitutePlaceholders(a,o.trim()),f={join:y,set:"SET",where:"WHERE",orderBy:P,limit:"LIMIT",returning:"RETURNING"},{tokens:[l,...m],matches:p}=h.lex(c,Object.values(f).map(E=>typeof E=="string"||E.test?E:E.regex),{useRegex:"i"});for(let E of h.split(l,[","])){let A=r(a,E.trim(),[x]);a.table(A)}for(let E of p){let A=E.replace(/\s+/g,""),d=Object.keys(f).find(N=>new RegExp(N,"i").test(A));if(d==="set"){let N=r(a,m.shift().trim(),[st]);a.set(N)}else if(d==="where"){let N=r(a,m.shift().trim(),[L,D]);a.where(N)}else if(d==="limit")a.limit(parseInt(m.shift().trim()));else if(d==="returning")a.returning(...h.split(m.shift(),[","]).map(N=>r(a,N.trim(),[G])));else{let N=r(a,`${E} ${m.shift().trim()}`,[f[d]]);a[d](N)}}return a}};var Ze=[v,at,pt,M,ot,ut,gt,Gt,vt,X,...I.Types];var fe=class{static grammar=Ze;static parse(t,e,r,s={}){if(!e?.length)return;let i=r?.length?r:this.grammar;for(let n of i){let o=this.parseOne(t,e,n,s);if(o)return s.log&&console.log(".................",e,".................>",o.constructor.name),o}if(s.assert!==!1)throw new SyntaxError(e)}static parseOne(t,e,r,s={}){return r.parse(t,e,(i,n,o,a={})=>this.parse(i,n,o,{...s,...a}))}};var Ot=class{constructor(t,e,r="backward"){Object.defineProperty(this,"$",{value:{client:t,json:e,direction:r}})}get client(){return this.$.client}get direction(){return this.$.direction}get id(){return this.$.json.id}get databaseTag(){return this.$.json.database_tag}get versionTag(){return this.$.json.version_tag}get versionMax(){return this.$.json.version_max}get cursor(){return this.$.json.cursor}get description(){return this.$.json.savepoint_description}get savepointDate(){return this.$.json.savepoint_date}get rollbackDate(){return this.$.json.rollback_date}get rollbackOutcome(){let t=typeof this.$.json.keep!="boolean"?["DROPPED","CREATED"]:this.$.json.keep===!1?["CREATED","DROPPED"]:["ALTERED"];return this.direction==="forward"?t.reverse()[0]:t[0]}name(t=!1){return t?this.direction==="forward"&&this.$.json.$name||this.$.json.name:this.direction!=="forward"&&this.$.json.$name||this.$.json.name}schema(){let{name:t,$name:e,tables:r=[],keep:s}=this.$.json;return{name:t,...e?{$name:e}:{},tables:r,keep:s}}toJson(){let{id:t,database_tag:e,version_tag:r,version_max:s,cursor:i,savepoint_description:n,savepoint_date:o,rollback_date:a}=this.$.json;return{id:t,name:this.name(),database_tag:e,version_tag:r,version_max:s,cursor:i,description:n,savepoint_date:o,rollback_date:a}}async canRollback(){return(await this.client.database(this.name()).savepoint({direction:this.direction})||{}).id===this.$.json.id}async rollback(){if(!await this.canRollback())throw new Error("Invalid rollback order.");let t=v.fromJson(this.client,this.schema());if(this.direction!=="forward"&&(t.reverseAlt(!0),t.keep(t.keep(),"auto")),t.keep()===!1)this.client.dropDatabase(t.name(),{cascade:!0,noCreateSavepoint:!0});else if(t.keep()===!0){let r=t.getAlt().with({resultSchema:t});this.client.query(r,{noCreateSavepoint:!0})}else this.client.query(t,{noCreateSavepoint:!0});let e=[this.client.constructor.OBJ_INFOSCHEMA_DB,"database_savepoints"].join(".");return await this.client.query(`UPDATE ${e} SET rollback_date = ${this.direction==="forward"?"NULL":"now()"} WHERE id = '${this.$.json.id}'`),this.$.json.rollback_date=this.direction==="forward"?null:Date.now(),!0}};var le=class{static get OBJ_INFOSCHEMA_DB(){return"obj_information_schema"}constructor(t,e={}){Object.defineProperty(this,"$",{value:{driver:t,params:e}})}get driver(){return this.$.driver}get params(){return this.$.params}database(t,e={}){return new this.constructor.Database(this,...arguments)}async databases(){return[]}async hasDatabase(t){return(await this.databases()).includes(t)}async describeDatabase(t,e=["*"],r={}){return{name:t,tables:await this.database(t).describeTable(e,r)}}async createDatabase(t,e={}){if(typeof t=="string")t={name:t};else if(typeof t?.name!="string")throw new Error("createDatabase() called with invalid arguments.");let r=v.fromJson(this,t);return e.ifNotExists&&r.withFlag("IF_NOT_EXISTS"),await this.query(r,e)}async alterDatabase(t,e,r={}){if(typeof e!="function")throw new Error("alterDatabase() called with invalid arguments.");if(typeof t=="string")t={name:t};else if(typeof t?.name!="string")throw new Error("alterDatabase() called with invalid arguments.");let s=await this.describeDatabase(t.name,t.tables),i=v.fromJson(this,s).keep(!0,!0);await e(i);let n=i.getAlt().with({resultSchema:i});if(n.ACTIONS.length)return await this.query(n,r)}async dropDatabase(t,e={}){if(typeof t!="string")throw new Error(`dropDatabase() called with an invalid name: ${t}.`);let r=pt.fromJson(this,{name:t});return e.ifExists&&r.withFlag("IF_EXISTS"),e.cascade&&r.withFlag("CASCADE"),await this.query(r,e)}async queryCallback(t,e,r={}){if(typeof e=="string")e=fe.parse(this,e,null,{log:r.log});else if(!(e instanceof T))throw new Error("query() called with invalid arguments.");let s=(a,c)=>c.some(f=>a instanceof f),i={},n=a=>a&&!new RegExp(a,"i").test(this.constructor.OBJ_INFOSCHEMA_DB)&&(!r.noCreateSavepoint||r.$resultSchema==="always");if(s(e,[v,at,pt])&&n(e.name())){if(e instanceof pt){let a=v.fromJson(this,await this.describeDatabase(e.name(),"*")).drop();e.with({resultSchema:a})}else if(e instanceof at&&!e.resultSchema){let a=e.ACTIONS.filter(f=>["ALTER","DROP"].includes(f.TYPE)).map(f=>f.NAME),c=v.fromJson(this,await this.describeDatabase(e.name(),a)).keep(!0,!0).alterWith(e);e.with({resultSchema:c})}else e instanceof v&&e.with({resultSchema:e});i.savepoint=e.resultSchema}else if(s(e,[M,ot,ut])){let a=e.basename()||await this.basenameGet(e.name(),!0);if(n(a)){let c=this.database(a);if(e instanceof ut&&a){let f=M.fromJson(c,await c.describeTable(e.name())).drop();e.with({resultSchema:f})}else if(e instanceof ot&&!e.resultSchema&&a){let f=M.fromJson(c,await c.describeTable(e.name())).keep(!0,!0).alterWith(e);e.with({resultSchema:f})}else e instanceof M&&a&&e.with({resultSchema:e});!r.noCreateSavepoint&&a&&(i.savepoint=v.fromJson(this,{name:c.name,tables:[e.resultSchema]}).keep(!0))}}let o=await t(e,r);return!r.noCreateSavepoint&&i.savepoint?(i.savepoint.keep(i.savepoint.keep(),"auto"),await this.createSavepoint(i.savepoint,r.savepointDesc)):o}async basenameResolution(t=[]){return arguments.length?(this.$.resolutionPath=[].concat(t),this):new BasenameResolutor(this.$.basenameResolution)}async basenameGet(t,e=!1){let r=await this.basenameResolution();return await r.reduce(async(s,i)=>await s||await this.database(i).hasTable(t)?i:null,null)||(e?r.find(s=>!s.startsWith("$"))||r[0]:null)}async getSavepoints(t={}){let e=this.constructor.OBJ_INFOSCHEMA_DB;if(!await this.hasDatabase(e))return[];let r=[e,"database_savepoints"].join(".");return(await this.query(`
            SELECT id, database_tag, name, "$name", keep, version_tag, version_max, rank_for_cursor || '/' || total AS cursor, savepoint_description, tables, savepoint_date, rollback_date FROM (
                SELECT
                ROW_NUMBER() OVER (PARTITION BY database_tag ORDER BY rollback_date IS NOT NULL ${t.direction==="forward"?"DESC":"ASC"}, version_tag ${t.direction==="forward"?"ASC":"DESC"}) AS rank_for_target,
                ROW_NUMBER() OVER (PARTITION BY database_tag ORDER BY version_tag ASC) AS rank_for_cursor,
                MAX(version_tag) OVER (PARTITION BY database_tag) AS version_max,
                COUNT(version_tag) OVER (PARTITION BY database_tag) AS total,
                * FROM ${r}${t.name?t.direction==="forward"?`WHERE name = '${t.name}'`:`WHERE COALESCE("$name", name) = '${t.name}'`:""}
            ) AS savepoint WHERE rollback_date IS ${t.direction==="forward"?"NOT NULL":"NULL"} AND rank_for_target = 1
        `)).map(i=>new Ot(this,i,t.direction))}async createSavepoint(t,e=null){let r=this.constructor.OBJ_INFOSCHEMA_DB;await this.hasDatabase(r)||await this.createDatabase({name:r,tables:[{name:"database_savepoints",columns:[{name:"id",type:"uuid",primaryKey:!0,default:{expr:"gen_random_uuid()"}},{name:"name",type:"varchar",notNull:!0},{name:"$name",type:"varchar"},{name:"tables",type:"json"},{name:"keep",type:"boolean"},{name:"savepoint_description",type:"varchar"},{name:"database_tag",type:"varchar",notNull:!0},{name:"version_tag",type:"int",notNull:!0},{name:"savepoint_date",type:"timestamp",notNull:!0},{name:"rollback_date",type:"timestamp"}]}]},{noCreateSavepoint:!0});let s={database_tag:null,...t.toJson(),savepoint_description:e,version_tag:null,savepoint_date:new Date},i=await this.database(t.name()).savepoint({direction:"forward"})||await this.database(t.name()).savepoint();if(i){let o=[r,"database_savepoints"].join(".");s.database_tag=i.databaseTag,i.direction==="forward"?(s.version_tag=(await this.query(`SELECT max(version_tag) AS version_max FROM ${o} WHERE database_tag = '${i.databaseTag}'`))[0].version_max+1,await this.query(`DELETE FROM ${o} WHERE database_tag = '${i.databaseTag}' AND rollback_date IS NOT NULL`)):s.version_tag=i.versionTag+1}else s.database_tag=`db:${(0|Math.random()*9e6).toString(36)}`,s.version_tag=1;let n=await this.database(r).table("database_savepoints").insert(s);return new Ot(this,{...n[0],version_max:n[0].version_tag,cursor:null})}};var he=class{constructor(t,e,r={}){Object.defineProperty(this,"$",{value:{client:t,name:e,params:r}})}get client(){return this.$.client}get name(){return this.$.name}get params(){return this.$.params}table(t,e={}){return new this.constructor.Table(this,...arguments)}async tables(){return[]}async hasTable(t){return(await this.tables()).includes(t)}async describeTable(t,e={}){let r=[].concat(t),s=!Array.isArray(t)&&t!=="*",i=r.length===1&&r[0]==="*";return s?null:[]}async createTable(t,e={}){if(typeof t?.name!="string")throw new Error("createTable() called with invalid arguments.");let r=M.fromJson(this,t);return e.ifNotExists&&r.withFlag("IF_NOT_EXISTS"),this.client.query(r,e)}async alterTable(t,e,r={}){if(typeof e!="function"||typeof t!="string")throw new Error("alterTable() called with invalid arguments.");let s=await this.describeTable(t),i=M.fromJson(this,s).keep(!0,!0);await e(i);let n=i.getAlt().with({resultSchema:i});if(n.ACTIONS.length)return r.ifExists&&n.withFlag("IF_EXISTS"),this.client.query(n,r)}async dropTable(t,e={}){if(typeof t!="string")throw new Error("dropTable() called with invalid arguments.");let r=ut.fromJson(this,{name:t});return e.ifExists&&r.withFlag("IF_EXISTS"),e.cascade&&r.withFlag("CASCADE"),this.client.query(r,e)}async savepoint(t={}){return(await this.client.getSavepoints({...t,name:this.name}))[0]}async _savepoint(t={}){let e=this.client.constructor.OBJ_INFOSCHEMA_DB;if(!await this.client.hasDatabase(e))return;let r=[e,"database_savepoints"].join("."),s=t.direction==="forward"?await this.client.query(`
                SELECT savepoint.*, preceding.id AS id_preceding FROM ${r} AS savepoint
                LEFT JOIN ${r} AS preceding ON preceding.database_tag = savepoint.database_tag AND COALESCE(preceding."$name", preceding.name) = savepoint.name AND preceding.version_tag < savepoint.version_tag
                WHERE COALESCE(savepoint.name, savepoint."$name") = '${this.name}' AND savepoint.rollback_date IS NOT NULL AND (preceding.id IS NULL OR preceding.rollback_date IS NULL)
                ORDER BY savepoint.version_tag ASC LIMIT 1
            `):await this.client.query(`
                SELECT savepoint.*, following.id AS id_following FROM ${r} AS savepoint
                LEFT JOIN ${r} AS following ON following.database_tag = savepoint.database_tag AND following.name = COALESCE(savepoint."$name", savepoint.name) AND following.version_tag > savepoint.version_tag
                WHERE COALESCE(savepoint."$name", savepoint.name) = '${this.name}' AND savepoint.rollback_date IS NULL AND (following.id IS NULL OR following.rollback_date IS NOT NULL)
                ORDER BY savepoint.version_tag DESC LIMIT 1
            `);return s[0]&&new Ot(this.client,s[0],t.direction)}};var me=class{constructor(t,e,r={}){this.$={database:t,name:e,params:r}}get database(){return this.$.database}get name(){return this.$.name}get params(){return this.$.params}async count(t="*"){let e=await this.select([r=>r.fn("COUNT",r).as("c")]);return(e.rows||e)[0].c}async select(...t){let e=new X(this.database.client);return/^\d+$/.test(t[0])||O(t[0])?await this.resolveWhere(e,t[0]):(e.select(...t[0]||["*"]),await this.resolveWhere(e,t[1])),e.from([this.database.name,this.name]),await this.database.client.query(e)}async insert(...t){let e=new gt(this.database.client),[r=[],s=[],i="*"]=await this.resolvePayload(...t);r.length&&e.columns(...r);for(let n of s)e.values(...n);return e.into([this.database.name,this.name]),i&&e.returning(i),await this.database.client.query(e)}async upsert(...t){let e=new gt(this.database.client),[r=[],s=[],i="*"]=await this.resolvePayload(...t);r.length&&e.columns(...r);for(let n of s)e.values(...n);return e.onConflict({entries:r.map((n,o)=>[n,s[o]])}),i&&e.returning(i),e.into([this.database.name,this.name]),await this.database.client.query(e)}async update(...t){if(t.length<2)throw new Error('A "where" match cannot be ommitted.');let e=new Gt(this.database.client);e.table([this.database.name,this.name]);let{where:r,payload:s,returnList:i="*"}=t;await this.resolveWhere(e,r);for(let[n,o]of Object.entries(s))e.set(n,o);return i&&e.returning(i),await this.database.client.query(e)}async delete(t,e="*"){if(args.length<1)throw new Error('A "where" match cannot be ommitted.');let r=new vt(this.database.client);return r.from([this.database.name,this.name]),await this.resolveWhere(r,t),e&&r.returning(e),await this.database.client.query(r)}async resolveWhere(t,e){if(e!==!0){if(/^\d+$/.test(e)){let r=await this.database.describeTable(this.name),s=r.columns?.find(i=>i.primaryKey)?.name||r.constraints.find(i=>i.type==="PRIMARY_KEY")?.targetColumns[0];if(!s)throw new Error("Cannot resolve primary key name for implied record.");e={[s]:e}}O(e)?t.where(...Object.entries(e).map(([r,s])=>i=>i.equals(r,s))):e&&t.where(e)}}async resolvePayload(...t){let e=[],r=[],s;if(Array.isArray(t[0])&&t[0].every(i=>typeof i=="string")&&Array.isArray(t[1])){if(!t[1].every(i=>Array.isArray(i)))throw new TypeError("Invalid payload format.");[e,r,s]=t.splice(0,3)}else{let i=[].concat(t.shift());if(!O(i[0]))throw new TypeError("Invalid payload format.");e=Object.keys(i[0]),r=i.map(n=>Object.values(n)),s=t.shift()}return r=r.map(i=>i.map(n=>this.params.bindings!==!1?o=>o.$bind(0,n):[!0,!1,null].includes(n)?o=>o.literal(n):n instanceof Date?o=>o.value(n.toISOString().split(".")[0]):Array.isArray(n)?o=>o.array(n):O(n)?o=>o.object(n):o=>o.value(n))),[e,r,s]}};var Ee=class{_pos=0;_eof=!1;_onfinish=[];constructor(t){this._cache=t}get eof(){return!this._cache.length||this._pos===this._cache.length-1}onfinish(t){this._onfinish.push(t)}next(){if(this.eof){this._onfinish.forEach(t=>t()),this._pos=0;return}this._pos++}async fetch(){if(!this.eof)return this._cache[this._pos]}};var pe=class extends Ee{constructor(t){super([]),this._store=t,this._storeFetch=new Promise(async e=>{this.cache=await this._store.getAll(),e()})}async fetch(){return await this._storeFetch,super.fetch()}};var Te=class extends me{getCursor(){return new pe(this)}};var Ae=class extends he{static Table=Te;async tables(){let t=`SELECT table_name FROM information_schema.tables WHERE table_schema = '${this.name}'`,e=await this.client.driver.query(t);return(e.rows||e).map(r=>r.table_name)}async describeTable(t,e={}){let r=!Array.isArray(t)&&t!=="*",s=[].concat(t),[i,n]=this.getDescribeTableSql(s),o=await this.client.driver.query(i),a=await this.client.driver.query(n),c=this.formatDescribeTableResult(s,o.rows||o,a.rows||a,[]);return r?c[0]:c}getDescribeTableSql(t){let e=`
        SELECT
            COLUMNS.column_name,
            COLUMNS.table_name,
            COLUMNS.ordinal_position,
            COLUMNS.column_default,
            COLUMNS.is_nullable,
            COLUMNS.data_type,
            COLUMNS.character_maximum_length,
            ${this.client.params.dialect==="mysql"?"":`
            COLUMNS.is_identity,
            COLUMNS.identity_generation,
            COLUMNS.identity_start,
            COLUMNS.identity_increment,
            COLUMNS.identity_maximum,
            COLUMNS.identity_minimum,
            COLUMNS.identity_cycle,
            `}
            COLUMNS.is_generated,
            COLUMNS.generation_expression

        FROM INFORMATION_SCHEMA.COLUMNS AS COLUMNS

        WHERE COLUMNS.TABLE_SCHEMA='${this.name}'
            ${t.length&&t[0]!=="*"?`AND COLUMNS.TABLE_NAME IN ('${t.join("','")}')`:""}
        ORDER BY COLUMNS.ordinal_position
        `,r=n=>this.client.params.dialect==="mysql"?n:`ANY_VALUE(${n})`,s=(n,o)=>this.client.params.dialect==="mysql"?`GROUP_CONCAT(${n}${o?` ORDER BY ${o}`:""} SEPARATOR ',')`:`STRING_AGG(${n}, ','${o?` ORDER BY ${o}`:""})`,i=`
        SELECT
            ${r("TABLE_CONSTRAINTS.table_name")} AS table_name,
            ${s("TABLE_CONSTRAINTS_DETAILS.column_name","TABLE_CONSTRAINTS_DETAILS.ordinal_position")} AS column_name,
            TABLE_CONSTRAINTS.constraint_name AS constraint_name,
            ${r("TABLE_CONSTRAINTS.constraint_type")} AS constraint_type,
            ${r("CHECK_CONSTRAINTS_DETAILS.check_clause")} AS check_clause,
                
            ${this.client.params.dialect==="mysql"?`
            ${r("CHECK_CONSTRAINTS_DETAILS.level")} AS check_constraint_level,
            ${s("TABLE_CONSTRAINTS_DETAILS.referenced_column_name")} AS referenced_column_name,
            ${r("TABLE_CONSTRAINTS_DETAILS.referenced_table_name")} AS referenced_table_name,
            ${r("TABLE_CONSTRAINTS_DETAILS.referenced_table_schema")} AS referenced_table_schema,
            `:`
            ${s("RELATION_DETAILS.column_name")} AS referenced_column_name,
            ${r("RELATION_DETAILS.table_name")} AS referenced_table_name,
            ${r("RELATION_DETAILS.table_schema")} AS referenced_table_schema,
            `}
            --${s("RELATION.unique_constraint_name")} AS referenced_constraint_name,
            ${r("RELATION.match_option")} AS match_rule,
            ${r("RELATION.update_rule")} AS update_rule,
            ${r("RELATION.delete_rule")} AS delete_rule

        FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS AS TABLE_CONSTRAINTS

        LEFT JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE AS TABLE_CONSTRAINTS_DETAILS
            ON TABLE_CONSTRAINTS_DETAILS.CONSTRAINT_NAME = TABLE_CONSTRAINTS.CONSTRAINT_NAME
            AND TABLE_CONSTRAINTS_DETAILS.TABLE_NAME = TABLE_CONSTRAINTS.TABLE_NAME
            AND TABLE_CONSTRAINTS_DETAILS.CONSTRAINT_SCHEMA = TABLE_CONSTRAINTS.CONSTRAINT_SCHEMA
            AND TABLE_CONSTRAINTS_DETAILS.CONSTRAINT_CATALOG = TABLE_CONSTRAINTS.CONSTRAINT_CATALOG
        LEFT JOIN INFORMATION_SCHEMA.CHECK_CONSTRAINTS AS CHECK_CONSTRAINTS_DETAILS
            ON CHECK_CONSTRAINTS_DETAILS.CONSTRAINT_NAME = TABLE_CONSTRAINTS.CONSTRAINT_NAME
            AND CHECK_CONSTRAINTS_DETAILS.CONSTRAINT_SCHEMA = TABLE_CONSTRAINTS.CONSTRAINT_SCHEMA
            AND CHECK_CONSTRAINTS_DETAILS.CONSTRAINT_CATALOG = TABLE_CONSTRAINTS.CONSTRAINT_CATALOG

        LEFT JOIN INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS AS RELATION
            ON RELATION.CONSTRAINT_NAME = TABLE_CONSTRAINTS.CONSTRAINT_NAME
            AND RELATION.CONSTRAINT_SCHEMA = TABLE_CONSTRAINTS.CONSTRAINT_SCHEMA
            AND RELATION.CONSTRAINT_CATALOG = TABLE_CONSTRAINTS.CONSTRAINT_CATALOG
        ${this.client.params.dialect==="mysql"?"":`
        LEFT JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE AS RELATION_DETAILS
            ON RELATION_DETAILS.CONSTRAINT_NAME = RELATION.UNIQUE_CONSTRAINT_NAME
            AND RELATION_DETAILS.CONSTRAINT_SCHEMA = RELATION.UNIQUE_CONSTRAINT_SCHEMA
            AND RELATION_DETAILS.CONSTRAINT_CATALOG = RELATION.UNIQUE_CONSTRAINT_CATALOG
            `}

        WHERE TABLE_CONSTRAINTS.CONSTRAINT_SCHEMA = '${this.name}'
            ${t.length&&t[0]!=="*"?`AND TABLE_CONSTRAINTS.TABLE_NAME IN ('${t.join("','")}')`:""}
        GROUP BY (TABLE_CONSTRAINTS.constraint_name)
        `;return[e,i]}formatDescribeTableResult(t,e,r,s){let i=o=>o==="character varying"?"varchar":o==="integer"?"int":o,n=(o,a=!1)=>({...a?{}:{name:o.constraint_name},targetTable:[o.referenced_table_schema,o.referenced_table_name],targetColumns:o.referenced_column_name.split(",").map(c=>c.trim()),...o.match_rule!=="NONE"?{matchRule:o.match_rule}:{},updateRule:o.update_rule,deleteRule:o.delete_rule});return(t.length&&t[0]!=="*"?t:[...new Set(e.map(o=>o.table_name))]).map(o=>{let a=e.filter(S=>S.table_name===o),c=r.filter(S=>S.table_name===o),f=s.filter(S=>S.table_name===o),l=a.map(S=>S.column_name),m=S=>{let R=(S.check_clause.replace(/(["'])(?:(?=(\\?))\2.)*?\1/g,"").match(/\w+/g)||[]).map(C=>C.toLowerCase());return S.columns=Oe(l,R),S},[p,E,A,d]=c.reduce(([S,R,C,U],Q)=>Q.constraint_type==="PRIMARY KEY"?[S.concat(Q),R,C,U]:Q.constraint_type==="UNIQUE"?[S,R.concat(Q),C,U]:Q.constraint_type==="FOREIGN KEY"?[S,R,C.concat(Q),U]:Q.constraint_type==="CHECK"&&!(this.client.params.dialect==="postgres"&&/^[\d_]+not_null/.test(Q.constraint_name))?[S,R,C,U.concat(m(Q))]:[S,R,C,U],[[],[],[],[]]),N={name:o,columns:a.reduce((S,R)=>{let C={};return S.concat({name:R.column_name,type:R.character_maximum_length?{name:i(R.data_type),maxLen:R.character_maximum_length}:i(R.data_type),...p.length===1&&p[0].column_name===R.column_name&&(C.pKeys=p.pop())?{primaryKey:{name:C.pKeys.constraint_name}}:{},...(C.uKeys=E.filter(U=>U.column_name===R.column_name)).length===1&&(E=E.filter(U=>U!==C.uKeys[0]))?{uniqueKey:{name:C.uKeys[0].constraint_name}}:{},...(C.fKeys=A.filter(U=>U.column_name===R.column_name)).length===1&&(A=A.filter(U=>U!==C.fKeys[0]))?{references:n(C.fKeys[0])}:{},...(C.cKeys=d.filter(U=>U.check_constraint_level!=="Table"&&U.columns.length===1&&U.columns[0]===R.column_name)).length===1&&(d=d.filter(U=>U!==C.cKeys[0]))?{check:{name:C.cKeys[0].constraint_name,expr:C.cKeys[0].check_clause}}:{},...R.is_identity!=="NO"?{identity:{always:R.identity_generation==="ALWAYS"}}:{},...R.is_generated!=="NEVER"?{generated:{always:R.is_generated==="ALWAYS",expr:R.generation_expression}}:{},...R.is_nullable==="NO"?{notNull:!0}:{},...R.column_default?{default:{expr:R.column_default}}:{}})},[]),constraints:[],indexes:[]};return N.constraints.push(...[...p,...E,...A].map(S=>({name:S.constraint_name,type:S.constraint_type==="UNIQUE"?"UNIQUE_KEY":S.constraint_type,columns:S.column_name.split(",").map(R=>R.trim()),...S.constraint_type==="FOREIGN KEY"?{references:n(S,!0)}:{}}))),N.constraints.push(...d.map(S=>({name:S.constraint_name,type:S.constraint_type,columns:S.columns,expr:S.check_clause}))),N})}};var de=class extends le{constructor(t,e={}){if(typeof t!="object")throw new Error("The options.driver parameter is required and must be an object.");if(typeof t.query!="function")throw new Error("The provided driver must expose a .query() function.");super(t,e)}static kind="sql";static Database=Ae;async databases(){let e=await this.driver.query("SELECT schema_name FROM information_schema.schemata");return(e.rows||e).map(r=>r.schema_name)}async query(t,e={}){return await this.queryCallback(async(r,s)=>{r.expandable&&await r.expand(!0);let i;this.params.dialect==="mysql"&&r.RETURNING_LIST?.length&&(r=r.clone(),i=r.RETURNING_LIST.splice(0));let n=(r.BINDINGS||[]).concat(s.params||[]).map(a=>Array.isArray(a)||typeof a=="object"&&a?JSON.stringify(a):a),o=await this.driver.query(r.toString(),n);return o.rows||o},...arguments)}async basenameResolution(t=[]){if(arguments.length){t=[].concat(t).map(o=>_.fromJson(this,o));let n=this.params.dialect==="mysql"?`USE ${t[0]}`:`SET SEARCH_PATH TO ${t.join(",")}`;return await this.driver.query(n)}let e,r;this.params.dialect==="mysql"?(e="SELECT database() AS default_db",r="default_db"):(e="SHOW SEARCH_PATH",r="search_path",e="SELECT current_setting('SEARCH_PATH')",r="current_setting");let s=await this.driver.query(e),i=((s.rows||s)[0]||{})[r];return h.split(i,[","]).map(n=>_.parseIdent(this,n.trim())[0])}};self.webqit||(self.webqit={});self.webqit.ObjectiveSQL={SQL:de};})();
//# sourceMappingURL=main.js.map
