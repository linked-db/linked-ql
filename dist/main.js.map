{
  "version": 3,
  "sources": ["../src/lang/cte/index.js", "../node_modules/@webqit/util/js/isObject.js", "../src/lang/abstracts/util.js", "../src/lang/toktypes.js", "../src/lang/TokenStream.js", "../src/lang/registry.js", "../src/lang/abstracts/AbstractNode.js", "../src/lang/cte/constructs/PGCycleClause.js", "../src/lang/cte/constructs/PGSearchClause.js", "../src/lang/abstracts/ResultSchemaMixin.js", "../src/lang/abstracts/OriginSchemasMixin.js", "../src/lang/abstracts/AbstractStmt.js", "../src/lang/abstracts/AbstractNonDDLStmt.js", "../src/lang/Transformer.js", "../src/lang/cte/CTE.js", "../src/lang/cte/CTEItem.js", "../src/lang/expr/ref/Identifier.js", "../src/lang/cte/CTEItemAlias.js", "../src/lang/ddl/index.js", "../src/lang/abstracts/AbstractNodeList.js", "../src/lang/abstracts/AbstractDiff.js", "../src/lang/ddl/column/ColumnDiff.js", "../src/lang/abstracts/AbstractSchema.js", "../src/lang/ddl/column/ColumnSchema.js", "../src/lang/ddl/constraint/constructs/FKMatchRule.js", "../src/lang/ddl/constraint/constructs/FKDeleteRule.js", "../src/lang/ddl/constraint/constructs/FKUpdateRule.js", "../src/lang/ddl/constraint/constructs/PGIndexParameters.js", "../src/lang/ddl/constraint/constructs/PGIndexParamInclude.js", "../src/lang/ddl/constraint/constructs/PGIndexParamUsing.js", "../src/lang/ddl/constraint/constructs/PGIndexParamWith.js", "../src/lang/ddl/constraint/ConstraintSchema.js", "../src/lang/ddl/constraint/constructs/PGTableEXConstraintItem.js", "../src/lang/ddl/constraint/constructs/ReferentialAction.js", "../src/lang/ddl/constraint/CheckConstraint.js", "../src/lang/ddl/constraint/ColumnDefaultConstraint.js", "../src/lang/ddl/constraint/ColumnExpressionConstraint.js", "../src/lang/ddl/constraint/ColumnFKConstraint.js", "../src/lang/ddl/constraint/MYColumnAutoIncrementModifier.js", "../src/lang/ddl/constraint/ColumnIdentityConstraint.js", "../src/lang/ddl/constraint/ColumnNullConstraint.js", "../src/lang/ddl/constraint/ColumnPKConstraint.js", "../src/lang/ddl/constraint/ColumnUKConstraint.js", "../src/lang/ddl/constraint/MYColumnCommentModifier.js", "../src/lang/ddl/constraint/MYColumnOnUpdateModifier.js", "../src/lang/ddl/constraint/MYColumnVisibilityModifier.js", "../src/lang/ddl/constraint/PGTableEXConstraint.js", "../src/lang/ddl/constraint/TableFKConstraint.js", "../src/lang/ddl/constraint/TablePKConstraint.js", "../src/lang/ddl/constraint/TableUKConstraint.js", "../src/lang/abstracts/PathMixin.js", "../src/lang/expr/index.js", "../src/lang/abstracts/TypeSysMixin.js", "../src/lang/expr/AbstractClassicExpr.js", "../src/lang/expr/abstraction/ParenExpr.js", "../src/lang/expr/abstraction/RowConstructor.js", "../src/lang/dql/TA/DerivedQuery.js", "../src/lang/expr/abstraction/ScalarSubquery.js", "../src/lang/expr/abstraction/TypedRowConstructor.js", "../src/lang/expr/call/constructs/PGFilterClause.js", "../src/lang/expr/call/constructs/PGWithinGroupClause.js", "../src/lang/expr/call/CallExpr.js", "../src/lang/expr/call/AggrCallExpr.js", "../src/lang/expr/case/CaseExpr.js", "../src/lang/expr/case/CaseBranch.js", "../src/lang/expr/etc/CastExpr.js", "../src/lang/expr/op/BinaryExpr.js", "../src/lang/expr/etc/ExtractExpr.js", "../src/lang/expr/etc/PredicateExpr.js", "../src/lang/expr/etc/QuantitativeExpr.js", "../src/lang/expr/literals/AbstractLiteral.js", "../src/lang/expr/literals/BitLiteral.js", "../src/lang/expr/literals/BoolLiteral.js", "../src/lang/expr/literals/DefaultLiteral.js", "../src/lang/expr/literals/HexLiteral.js", "../src/lang/expr/literals/NullLiteral.js", "../src/lang/expr/literals/NumberLiteral.js", "../src/lang/expr/literals/StringLiteral.js", "../src/lang/expr/literals/TypedLiteral.js", "../src/lang/expr/literals/TypedDateLiteral.js", "../src/lang/expr/literals/TypedIntervalLiteral.js", "../src/lang/expr/literals/TypedTimeLiteral.js", "../src/lang/expr/literals/TypedTimestampLiteral.js", "../src/lang/expr/literals/TypedTimeZoneLiteral.js", "../src/lang/expr/literals/UnknownLiteral.js", "../src/lang/abstracts/SugarMixin.js", "../src/lang/expr/literals/AbstractLQJsonLiteral.js", "../src/lang/expr/literals/LQArrayLiteral.js", "../src/lang/expr/literals/LQObjectLiteral.js", "../src/lang/expr/literals/LQObjectProperty.js", "../src/lang/expr/literals/PGTypedArrayLiteral.js", "../src/lang/expr/op/AtTimeZoneExpr.js", "../src/lang/expr/op/BetweenExpr.js", "../src/lang/expr/op/DistinctFromExpr.js", "../src/lang/expr/op/InExpr.js", "../src/lang/expr/op/PGCastExpr2.js", "../src/lang/expr/op/UnaryExpr.js", "../src/lang/expr/ref/abstracts/ErrorRefUnknown.js", "../src/lang/expr/ref/abstracts/ErrorRefAmbiguous.js", "../src/lang/expr/ref/abstracts/AbstractClassicRef.js", "../src/lang/expr/ref/ColumnRef1.js", "../src/lang/expr/ref/ColumnRef0.js", "../src/lang/expr/ref/abstracts/ErrorFKInvalid.js", "../src/lang/expr/ref/abstracts/AbstractMagicRef.js", "../src/lang/expr/ref/ColumnRef2.js", "../src/lang/expr/ref/LQBackBackRef.js", "../src/lang/expr/ref/LQBackRef.js", "../src/lang/expr/ref/LQBackRefAbstraction.js", "../src/lang/expr/ref/LQBackRefEndpoint.js", "../src/lang/expr/ref/LQDeepDeepRef1.js", "../src/lang/expr/ref/LQDeepDeepRef2.js", "../src/lang/expr/ref/LQDeepRef1.js", "../src/lang/expr/ref/LQDeepRef2.js", "../src/lang/expr/ref/SchemaRef.js", "../src/lang/expr/ref/TableRef1.js", "../src/lang/expr/ref/TableRef0.js", "../src/lang/expr/ref/TableRef2.js", "../src/lang/expr/ref/WindowRef.js", "../src/lang/expr/var/BindVar.js", "../src/lang/expr/var/SystemVar.js", "../src/lang/expr/var/UserVar.js", "../src/lang/expr/Expr.js", "../src/lang/ddl/ident/ColumnIdent.js", "../src/lang/ddl/ident/SchemaIdent.js", "../src/lang/ddl/ident/TableIdent.js", "../src/lang/ddl/index/IndexDiff.js", "../src/lang/ddl/index/IndexSchema.js", "../src/lang/ddl/schema/SchemaDiff.js", "../src/lang/ddl/schema/SchemaSchema.js", "../src/lang/ddl/table/TableDiff.js", "../src/lang/ddl/table/TableSchema.js", "../src/lang/ddl/DDLStmt.js", "../src/lang/ddl/CreateSchemaStmt.js", "../src/lang/ddl/DropSchemaStmt.js", "../src/lang/ddl/CreateTableStmt.js", "../src/lang/ddl/DropTableStmt.js", "../src/lang/dml/index.js", "../src/lang/dml/clauses/MYOnDuplicateKeyUpdateClause.js", "../src/lang/dml/clauses/MYPartitionClause.js", "../src/lang/dml/clauses/PGConflictTarget.js", "../src/lang/dml/clauses/PGConflictTargetIndexSpec.js", "../src/lang/dml/clauses/PGDefaultValuesClause.js", "../src/lang/dml/clauses/PGOnConflictClause.js", "../src/lang/dql/clauses/SelectList.js", "../src/lang/dml/clauses/ReturningClause.js", "../src/lang/dml/clauses/PGWhereCurrentClause.js", "../src/lang/dml/clauses/SetClause.js", "../src/lang/dml/clauses/UsingFromClause.js", "../src/lang/dml/constructors/ColumnsConstructor.js", "../src/lang/dml/constructors/ValuesConstructor.js", "../src/lang/dml/expr/AssignmentExpr.js", "../src/lang/dml/expr/ConfigAssignmentExpr.js", "../src/lang/dml/expr/ConfigAssignmentExprAlt1.js", "../src/lang/dml/expr/ConfigAssignmentExprAlt2.js", "../src/lang/dml/expr/MYVarAssignmentExpr.js", "../src/lang/dml/TA/TableAbstraction2.js", "../src/lang/dml/TA/TableAbstraction1.js", "../src/lang/abstracts/SelectorStmtMixin.js", "../src/lang/dml/DMLStmt.js", "../src/lang/dml/DeleteStmt.js", "../src/lang/abstracts/PayloadStmtMixin.js", "../src/lang/dml/InsertStmt.js", "../src/lang/dml/MYSetStmt.js", "../src/lang/dml/UpdateStmt.js", "../src/lang/dml/UpsertStmt.js", "../src/lang/dql/index.js", "../src/lang/dql/clauses/DistinctClause.js", "../src/lang/dql/clauses/ForClause.js", "../src/lang/dql/clauses/FromClause.js", "../src/lang/dql/clauses/GroupByClause.js", "../src/lang/dql/clauses/GroupingElement.js", "../src/lang/dql/clauses/HavingClause.js", "../src/lang/dql/TA/FromItem.js", "../src/lang/dql/clauses/JoinClause.js", "../src/lang/dql/clauses/LimitClause.js", "../src/lang/dql/clauses/OffsetClause.js", "../src/lang/dql/clauses/OnClause.js", "../src/lang/dql/clauses/OrderByClause.js", "../src/lang/dql/clauses/OrderElement.js", "../src/lang/dql/clauses/PartitionByClause.js", "../src/lang/dql/clauses/PGFetchClause.js", "../src/lang/dql/clauses/PGOrderOperator.js", "../src/lang/dql/clauses/UsingClause.js", "../src/lang/dql/clauses/WhereClause.js", "../src/lang/dql/clauses/WindowClause.js", "../src/lang/dql/clauses/WindowDeclaration.js", "../src/lang/dql/clauses/WindowFrameSpec.js", "../src/lang/dql/clauses/WindowFrameBound.js", "../src/lang/dql/clauses/WindowSpec.js", "../src/lang/dql/TA/FromItemAlias.js", "../src/lang/dql/TA/SelectItem.js", "../src/lang/dql/TA/SelectItemAlias.js", "../src/lang/dql/TA/SRFExpr1.js", "../src/lang/dql/TA/SRFExpr2.js", "../src/lang/dql/TA/SRFExpr3.js", "../src/lang/dql/TA/SRFExpr4.js", "../src/lang/dql/TA/SRFExprDDL1.js", "../src/lang/dql/TA/SRFExprDDL2.js", "../src/lang/dql/TA/ValuesTableLiteral.js", "../src/lang/dql/SelectStmt.js", "../src/lang/dql/BasicSelectStmt.js", "../src/lang/dql/CompleteSelectStmt.js", "../src/lang/dql/CompositeSelectStmt.js", "../src/lang/dql/TableStmt.js", "../src/lang/qualif/index.js", "../src/lang/qualif/AggrNotation.js", "../src/lang/qualif/LQVersionSpec.js", "../src/lang/type/index.js", "../src/lang/type/DataType.js", "../src/lang/abstracts/JSONSchema.js", "../src/lang/Script.js", "../src/lang/index.js"],
  "sourcesContent": ["export * from './constructs/index.js';\nexport { CTE } from './CTE.js';\nexport { CTEItem } from './CTEItem.js';\nexport { CTEItemAlias } from './CTEItemAlias.js';\n", "\n/**\n * Tells if val is pure object.\n *\n * @param object\t \tval\n *\n * @return bool\n */\nexport default function(val) {\n\treturn !Array.isArray(val) && typeof val === 'object' && val;\n};\n", "import { _isObject } from '@webqit/util/js/index.js';\n\nexport function _eq(a, b, cs = false, ignoreList = null) {\n    if (Array.isArray(a) && Array.isArray(b)) {\n        return a.length === b.length && (b = b.slice(0).sort())\n            && a.slice(0).sort().every((x, i) => _eq(x, b[i], cs, ignoreList));\n    }\n    if (typeof a?.jsonfy === 'function') a = a.jsonfy();\n    if (typeof b?.jsonfy === 'function') b = b.jsonfy();\n    if (_isObject(a) && _isObject(b)) {\n        const temp = {\n            indexs_a: Object.keys(a),\n            indexs_b: Object.keys(b),\n        };\n        if (ignoreList?.length) {\n            const $ignoreList = [].concat(ignoreList);\n            temp.indexs_a = temp.indexs_a.filter((k) => !$ignoreList.includes(k));\n            temp.indexs_b = temp.indexs_b.filter((k) => !$ignoreList.includes(k));\n        }\n        return temp.indexs_a.length === temp.indexs_b.length\n            && temp.indexs_a.reduce((prev, k) => prev && _eq(a[k], b[k], cs, ignoreList), true);\n    }\n    if (typeof a === 'string' && typeof b === 'string' && cs === false) {\n        return a.toLowerCase() === b.toLowerCase();\n    }\n    return a === b;\n}\n\nexport function _toCapsSnake(str) {\n    // Handle cases like \"myVariableName\" -> \"my_Variable_Name\"\n    // This regex looks for a lowercase letter or digit followed by an uppercase letter.\n    // It inserts an underscore between them.\n    let result = str.replace(/([a-z0-9])([A-Z])/g, '$1_$2');\n\n    // Handle cases like \"HTMLParser\" -> \"HTML_Parser\" or \"APICall\" -> \"API_Call\"\n    // This regex looks for an uppercase letter followed by another uppercase letter\n    // which is then followed by a lowercase letter. This targets the transition\n    // from an acronym to a new word.\n    // Example: In \"HTMLParser\", it matches 'L' and then 'P' (uppercase) followed by 'a' (lowercase).\n    // It inserts an underscore between the first uppercase letter and the second.\n    result = result.replace(/([A-Z])([A-Z][a-z])/g, '$1_$2');\n\n    // Convert the entire string to uppercase.\n    return result.toUpperCase();\n}", "/**\n * Token types:\n * Noted that some delims and modifiers are dialect-dependent, and those are correctly handle by the tokenizer.\n  * Note too that emitted tokens may have a \"spaceBefore\" field when options.spaces === true.\n  * Lastly, \"line\" and \"column\" fields are guaranteed to be emitted by the tokenizer.\n */\nexport const TOK_TYPES = {\n  // Data type names\n  // e.g. VARCHAR, INT, \"custom_type\"\n  data_type: {\n    type: 'data_type',\n    value: undefined,\n    resolve() { return this; }\n  },\n  // Identifiers, optionally delimited\n  // e.g. user_id, \"UserName\", `table$1`\n  identifier: {\n    type: 'identifier',\n    value: undefined,\n    delim: [undefined],\n    resolve({ dialect, mysqlAnsiQuotes } = {}) {\n      return {\n        ...this,\n        delim: this.delim.concat(\n          dialect === 'mysql' ? (mysqlAnsiQuotes ? ['\"', '`'] : ['`']) : ['\"']\n        ),\n      };\n    }\n  },\n  // Any of the predefined keywords\n  // e.g. 'SELECT', 'FROM', 'WHERE'\n  keyword: {\n    type: 'keyword',\n    value: undefined,\n    resolve() { return this; }\n  },\n  // Operators, with precedence and associativity\n  // e.g. '+', '-', '||', 'AND', '::'\n  operator: {\n    type: 'operator',\n    value: undefined,\n    prec: undefined, // number\n    assoc: undefined, // string\n    resultType: undefined, // string\n    resolve() { return this; }\n  },\n  // Punctuation (., ,, :, ;, etc.)\n  // e.g. '.', ',', ':', ';', '(', ')'\n  punctuation: {\n    type: 'punctuation',\n    value: undefined,\n    resolve() { return this; }\n  },\n  // String literals, with required delim and optional modifier (e.g. E for Postgres, N for mysql)\n  // e.g. 'Hello', \"World\", $$foo$$, $tag$bar$tag$\n  string_literal: {\n    type: 'string_literal',\n    value: undefined,\n    delim: [\"'\"],\n    modifier: [undefined],\n    resolve({ dialect, mysqlAnsiQuotes } = {}) {\n      return {\n        ...this,\n        delim: this.delim.concat(\n          dialect === 'mysql' ? (!mysqlAnsiQuotes ? ['\"'] : []) : [/^(\\$\\$|\\$[a-zA-Z_][a-zA-Z0-9_]*\\$)$/]\n        ),\n        modifier: this.modifier.concat(\n          dialect === 'mysql' ? ['N'] : ['E']\n        ),\n      };\n    }\n  },\n  // Numbers (integer, float, exponential, etc.)\n  // e.g. 42, -3.14, 2e10, .004\n  number_literal: {\n    type: 'number_literal',\n    value: undefined,\n    match({ value }) {\n      // Match type \"number_literal\": 42, 3.14, .5, 5., 1e9, -2.7E-3, +0.001e+2\n      if (!/^[+-]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:[eE][+-]?\\d+)?$/.test(value)) return false;\n      return true;\n    }\n  },\n  // NULL Literal: NULL\n  null_literal: {\n    type: 'null_literal',\n    value: undefined,\n    resolve() { return this; }\n  },\n  // UNKNOWN Literal: NULL\n  unknown_literal: {\n    type: 'unknown_literal',\n    value: undefined,\n    resolve() { return this; }\n  },\n  // Bool Literals: TRUE | FALSE\n  bool_literal: {\n    type: 'bool_literal',\n    value: undefined,\n    resolve() { return this; }\n  },\n  // HEX Literals: 0xFF | X'FF'\n  hex_literal: {\n    type: 'hex_literal',\n    value: undefined,\n    resolve() { return this; }\n  },\n  // BIT Literals: 0b0101 | B'0101'\n  bit_literal: {\n    type: 'bit_literal',\n    value: undefined,\n    resolve() { return this; }\n  },\n  // Bindings (e.g. $1, ?, etc.), with required delim\n  // e.g. $1, $user, ?\n  bind_var: {\n    type: 'bind_var',\n    value: undefined,\n    delim: [],\n    resolve({ dialect } = {}) {\n      return {\n        ...this,\n        delim: this.delim.concat(dialect === 'mysql' ? ['?'] : ['$'])\n      };\n    }\n  },\n  // Version tags\n  // e.g. my_db@1_3, my_db@^2_1, my_db@~7_6, my_db @=3_4, my_db@<3, my_db@>4, my_db@<=3, my_db@>=4\n  version_spec: {\n    type: 'version_spec',\n    value: undefined,\n    delim: [undefined, \"'\"],\n    resolve() { return this; }\n  },\n  // User variables, with optional delim\n  // e.g. :foo, @bar, @'user var'\n  user_var: {\n    type: 'user_var',\n    value: undefined,\n    delim: [undefined],\n    resolve({ dialect } = {}) {\n      return {\n        ...this,\n        delim: this.delim.concat(dialect === 'mysql' ? [\"'\"] : [])\n      };\n    }\n  },\n  // MySQL system variables, with required notation\n  // e.g. @@baz\n  system_var: {\n    type: 'system_var',\n    value: undefined,\n    resolve() { return this; }\n  },\n  // Nest token type: \"brace\"\n  brace_block: {\n    type: 'brace_block',\n    value: undefined, // TokenStream\n    resolve() { return this; }\n  },\n  // Nest token type: \"bracket\"\n  bracket_block: {\n    type: 'bracket_block',\n    value: undefined, // TokenStream\n    resolve() { return this; }\n  },\n  // Nest token type: \"paren\"\n  parent_block: {\n    type: 'paren_block',\n    value: undefined, // TokenStream\n    resolve() { return this; }\n  },\n  // Block comments\n  // e.g. /* This is a comment */\n  block_comment: {\n    type: 'block_comment',\n    value: undefined,\n    resolve() { return this; }\n  },\n  // Line comments, with required delim (e.g. /*, --, #)\n  // e.g. -- This is a comment\n  line_comment: {\n    type: 'line_comment',\n    value: undefined,\n    delim: ['--'],\n    resolve({ dialect } = {}) {\n      return {\n        ...this,\n        delim: this.delim.concat(dialect === 'mysql' ? ['#'] : [])\n      };\n    }\n  },\n};\n\n// Lookup registries, organized by: statements, clauses, operators, keywords, dataTypes\n// Each registry is split into: common (standard/shared), postgres, mysql\n\nexport const statements = {\n  common: [\n    // DDL\n    'ALTER',\n    'CREATE',\n    'DROP',\n    // DML\n    'SELECT',\n    'INSERT',\n    'UPSERT',\n    'UPDATE',\n    'MERGE',\n    'DELETE',\n    // Transactions\n    'BEGIN',\n    'COMMIT',\n    'ROLLBACK',\n    'RELEASE',\n    // Utility\n    'DESCRIBE',\n    'EXPLAIN',\n    'USE'\n  ],\n  postgres: [\n    'ANALYZE',\n    'CLUSTER',\n    'COMMENT ON',\n    'REFRESH',\n    'REINDEX',\n    'VACUUM'\n  ],\n  mysql: [\n    'ANALYZE',\n    'FLUSH',\n    'LOCK',\n    'OPTIMIZE',\n    'RENAME',\n    'REPAIR',\n    'RESET',\n    'SET',\n    'SHOW',\n    'TRUNCATE',\n    'UNLOCK'\n  ]\n};\n\nexport const keywords = {\n  common: [\n    'ALL', 'ON', 'NO', 'KEY', 'ANY', 'AS', 'BY', 'ASC', 'CASE', 'CAST',\n    'DEFAULT', 'DESC', 'DO', 'DISTINCT', 'ELSE', 'END', 'ESCAPE', 'EXISTS',\n    'FIRST', 'LAST', 'FOLLOWING', 'FOR', 'HAVING', 'FILTER', 'SHARE', 'UNIQUE',\n    'JOIN', 'SEPARATOR', 'SKIP', 'LOCKED', 'NOWAIT', 'OF', 'RECURSIVE',\n    'LIMIT', 'LOAD', 'NEXT', 'NOTHING', 'NULLS', 'OFFSET', 'ONLY', 'TIES',\n    'OVER', 'PARTITION', 'PRECEDING', 'RANGE', 'RETURNING', 'ROW', 'ROWS', 'INCLUDE', 'EXCLUDE',\n    'SET', 'SOME', 'THEN', 'USING', 'MATERIALIZED', 'MODE', 'TEMPORARY', 'MATCH', 'PARTIAL', 'SIMPLE',\n    'WITHIN', 'BOTH', 'CHECK', 'PRIMARY', 'FOREIGN', 'CONSTRAINT', 'REFERENCES', 'INHERITS',\n    'DATABASE', 'TABLE', 'COLUMN', 'INDEX', 'SEQUENCE', 'TRIGGER', 'VIEW', 'SAVEPOINT',\n    'VALUES', 'WHEN', 'WHERE', 'WINDOW', 'WITH', 'WITHOUT', 'TO', 'TABLESPACE', 'INTO',\n    'FROM', 'GROUP', 'ORDER', 'PARTITION', 'BREADTH', 'DEPTH', 'GENERATED', 'ALWAYS',\n    'INNER', 'LEFT', 'RIGHT', 'OUTER', 'FULL', 'CROSS', 'NATURAL', 'NO OTHERS', 'NO INHERIT',\n    'ROLLUP', 'UNBOUNDED', 'CURRENT ROW', 'GROUPS', 'IGNORE', 'RESPECT', 'CHARACTER SET',\n    'NO ACTION', 'SET NULL', 'SET DEFAULT', 'RESTRICT', 'CASCADE', 'STORED', 'GIST',\n    'SCHEMA'\n  ],\n  postgres: [\n    'ARRAY', 'GROUPING SETS', 'CUBE', 'TABLESAMPLE', 'REPEATABLE', 'SEARCH',\n    'LATERAL', 'ORDINALITY', 'OVERLAPS', 'SIMILAR', 'BERNOULLI', 'SYSTEM',\n    'UNLOGGED', 'PERFORM', 'CURRENT OF', 'TYPE', 'EXTENSION',\n    'IMMUTABLE', 'STABLE', 'VOLATILE', 'CYCLE', 'CONFLICT', 'TEMP',\n    'TIME ZONE', 'FETCH', 'LOCAL', 'IDENTITY', 'DEFERRABLE', 'INITIALLY', 'DEFERRED', 'IMMEDIATE',\n    'AUTHORIZATION', 'CURRENT_ROLE', 'CURRENT_USER', 'SESSION_USER'\n  ],\n  mysql: [\n    'LOCK', 'RENAME', 'REPLACE', 'SHOW', 'UNLOCK', 'VIRTUAL', 'VISIBLE', 'INVISIBLE',\n    'HIGH_PRIORITY', 'CACHE', 'SQL_CACHE', 'SQL_NO_CACHE', 'STRAIGHT_JOIN', 'COMMENT',\n    'DATABASES', 'TABLES', 'COLUMNS', 'PROCEDURE', 'FUNCTION',\n    'AUTO_INCREMENT', 'CHARACTER SET', 'ENGINE', 'VALUE', 'DUPLICATE',\n  ]\n};\n\nexport const functionNames = {\n  common: [\n    'NOW', 'CURRENT_DATE', 'CURRENT_TIME', 'CURRENT_TIMESTAMP',\n    'IF', 'NULLIF', 'IFNULL',\n    'COALESCE', 'GREATEST', 'LEAST', 'CONCAT', 'GROUPING',\n    'CONCAT_WS', 'FORMAT', 'UNNEST',\n    'MD5', 'SHA1',\n    'ST_ASTEXT', 'ST_ASGEOJSON', 'ST_GEOMFROMTEXT',\n    'ST_WITHIN', 'ST_CONTAINS', 'ST_INTERSECTS', 'ST_DISTANCE', 'ST_BUFFER'\n  ],\n  postgres: [\n    'MAKE_DATE', 'MAKE_TIME', 'MAKE_TIMESTAMP',\n    'TO_JSON', 'TO_JSONB', 'JSON_TYPEOF', 'JSONB_TYPEOF',\n    'JSON_BUILD_ARRAY', 'JSONB_BUILD_ARRAY', 'JSON_BUILD_OBJECT', 'JSONB_BUILD_OBJECT',\n    'JSON_POPULATE_RECORD', 'JSONB_POPULATE_RECORD', 'JSON_PATH_QUERY', 'JSON_PATH_EXISTS'\n  ],\n  mysql: [\n    'CURDATE', 'CURTIME', 'SYSDATE', 'STR_TO_DATE', 'MAKEDATE', 'MAKETIME',\n    'JSON_ARRAY', 'JSON_OBJECT', 'JSON_EXTRACT', 'JSON_UNQUOTE',\n    'JSON_SET', 'JSON_INSERT', 'JSON_REPLACE', 'JSON_REMOVE',\n    'JSON_SEARCH', 'JSON_CONTAINS', 'JSON_CONTAINS_PATH',\n    'JSON_KEYS', 'JSON_ARRAY_APPEND', 'JSON_ARRAY_INSERT',\n    'JSON_DEPTH', 'JSON_LENGTH', 'JSON_MERGE_PRESERVE',\n    'JSON_MERGE_PATCH', 'JSON_PRETTY', 'JSON_STORAGE_FREE'\n  ]\n};\n\nexport const aggrFunctionNames = {\n  common: [\n    'COUNT', 'SUM', 'AVG', 'MIN', 'MAX',\n    'COVAR_POP', 'COVAR_SAMP', 'CORR',\n    'ROW_NUMBER',\n    'BIT_AND', 'BIT_OR',\n    'STDDEV_POP', 'STDDEV_SAMP', 'VAR_POP', 'VAR_SAMP', 'VARIANCE', 'STD',\n    'LEAD', 'LAG', 'NTILE', 'FIRST_VALUE', 'LAST_VALUE',\n  ],\n  postgres: [\n    'ARRAY_AGG', 'STRING_AGG', 'REGR_SLOPE',\n    'PERCENTILE_CONT', 'PERCENTILE_DISC', 'MODE',\n    'RANK', 'DENSE_RANK',\n    'EVERY', 'BOOL_AND', 'BOOL_OR',\n    'JSON_AGG',\n    'JSON_OBJECT_AGG', 'JSONB_OBJECT_AGG',\n    'XMLAGG',\n  ],\n  mysql: [\n    'GROUP_CONCAT',\n    'BIT_XOR',\n    'JSON_ARRAYAGG',\n    'JSON_OBJECTAGG',\n  ]\n};\n\nexport const dataTypes = {\n  common: [\n    'SMALLINT', 'INTEGER', 'INT', 'BIGINT',\n    'DECIMAL', 'DEC', 'NUMERIC', 'REAL', 'FLOAT',\n    'DATE', 'TIME', 'TIMESTAMP', 'INTERVAL',\n    'CHAR', 'CHARACTER', 'VARCHAR', 'TEXT',\n    'BINARY', 'VARBINARY', 'BOOLEAN', 'JSON',\n    'GEOMETRY', 'POINT', 'LINESTRING', 'POLYGON',\n    'DOUBLE PRECISION', 'CHARACTER VARYING', 'BYTEA',\n    'ENUM',\n  ],\n  postgres: [\n    'SERIAL', 'BIGSERIAL', 'MONEY', 'BIT',\n    'CIDR', 'INET', 'MACADDR', 'MACADDR8', 'TIMESTAMPTZ', 'TIMETZ',\n    'TSVECTOR', 'TSQUERY', 'UUID', 'XML',\n    'INT4RANGE', 'INT8RANGE', 'NUMRANGE',\n    'TSRANGE', 'TSTZRANGE', 'DATERANGE',\n    'BOX', 'PATH', 'CIRCLE', 'LINE', 'LSEG', 'POLYGON',\n    'OID', 'BIT VARYING', 'JSONB'/*, TODO'NAME'*/, 'REGCLASS',\n  ],\n  mysql: [\n    'TINYINT', 'MEDIUMINT', 'BIT', 'YEAR', 'DATETIME',\n    'TINYTEXT', 'QUERY', 'MEDIUMTEXT', 'LONGTEXT',\n    'TINYBLOB', 'BLOB', 'MEDIUMBLOB', 'LONGBLOB',\n    'GEOMETRYCOLLECTION', 'MULTIPOINT', 'MULTILINESTRING', 'MULTIPOLYGON',\n    'BOOL'\n  ]\n};\n\nexport const operators = {\n  common: [\n    // Custom/graph-style\n    ['<~', { prec: 90, assoc: 'left', resultType: ':right' }],\n    ['~>', { prec: 90, assoc: 'right', resultType: ':right' }],\n    ['BETWEEN', { prec: 85, assoc: 'left', resultType: 'boolean' }],\n    ['NOT', { prec: 80, assoc: 'right', resultType: 'boolean' }],\n    // Arithmetic\n    ['*', { prec: 70, assoc: 'left', resultType: 'number' }],\n    ['/', { prec: 70, assoc: 'left', resultType: 'number' }],\n    ['%', { prec: 70, assoc: 'left', resultType: 'number' }],\n    ['+', { prec: 60, assoc: 'left', resultType: 'number' }],\n    ['-', { prec: 60, assoc: 'left', resultType: 'number' }],\n    // Bitwise\n    ['&', { prec: 60, assoc: 'left', resultType: 'number' }],\n    ['|', { prec: 60, assoc: 'left', resultType: 'number' }],\n    ['<<', { prec: 60, assoc: 'left', resultType: 'number' }],\n    ['>>', { prec: 60, assoc: 'left', resultType: 'number' }],\n    // Comparison\n    ['=', { prec: 50, assoc: 'left', resultType: 'boolean' }],\n    ['!=', { prec: 50, assoc: 'left', resultType: 'boolean' }],\n    ['<>', { prec: 50, assoc: 'left', resultType: 'boolean' }],\n    ['<', { prec: 50, assoc: 'left', resultType: 'boolean' }],\n    ['<=', { prec: 50, assoc: 'left', resultType: 'boolean' }],\n    ['>', { prec: 50, assoc: 'left', resultType: 'boolean' }],\n    ['>=', { prec: 50, assoc: 'left', resultType: 'boolean' }],\n    ['IS', { prec: 50, assoc: 'left', resultType: 'boolean' }],\n    ['IS NOT', { prec: 50, assoc: 'left', resultType: 'boolean' }],\n    ['DISTINCT FROM', { prec: 50, assoc: 'left', resultType: 'boolean' }],\n    // Pattern / membership\n    ['IN', { prec: 50, assoc: 'left', resultType: 'boolean' }],\n    ['LIKE', { prec: 50, assoc: 'left', resultType: 'boolean' }],\n    // Logical\n    ['AND', { prec: 40, assoc: 'left', resultType: 'boolean' }],\n    ['OR', { prec: 30, assoc: 'left', resultType: 'boolean' }],\n    // Set operators\n    ['INTERSECT', { prec: 20, assoc: 'left', resultType: 'set' }],\n    ['UNION', { prec: 10, assoc: 'left', resultType: 'set' }],\n    ['EXCEPT', { prec: 10, assoc: 'left', resultType: 'set' }]\n  ],\n  postgres: [\n    ['COLLATE', { prec: 83, assoc: 'left', resultType: 'string' }],\n    ['||', { prec: 60, assoc: 'left', resultType: 'string' }],\n    ['::', { prec: 100, assoc: 'left', resultType: 'casted' }],\n    ['AT', { prec: 95, assoc: 'left', resultType: 'timestamptz' }],\n    ['^', { prec: 90, assoc: 'left', resultType: 'number' }],\n    ['#', { prec: 60, assoc: 'left', resultType: 'number' }],\n    // JSON/JSONB\n    ['->', { prec: 80, assoc: 'left', resultType: 'json' }],\n    ['->>', { prec: 80, assoc: 'left', resultType: 'text' }],\n    ['#>', { prec: 80, assoc: 'left', resultType: 'json' }],\n    ['#>>', { prec: 80, assoc: 'left', resultType: 'text' }],\n    ['@>', { prec: 80, assoc: 'left', resultType: 'boolean' }],\n    ['<@', { prec: 80, assoc: 'left', resultType: 'boolean' }],\n    ['?', { prec: 80, assoc: 'left', resultType: 'boolean' }],\n    ['?|', { prec: 80, assoc: 'left', resultType: 'boolean' }],\n    ['?&', { prec: 80, assoc: 'left', resultType: 'boolean' }],\n    ['-@', { prec: 80, assoc: 'left', resultType: 'boolean' }],\n    ['#-', { prec: 80, assoc: 'left', resultType: 'json' }],\n    ['@?', { prec: 80, assoc: 'left', resultType: 'boolean' }],\n    ['@@', { prec: 80, assoc: 'left', resultType: 'boolean' }],\n    ['ILIKE', { prec: 50, assoc: 'left', resultType: 'boolean' }],\n    ['~', { prec: 50, assoc: 'left', resultType: 'boolean' }],\n    ['!~', { prec: 50, assoc: 'left', resultType: 'boolean' }],\n    ['~*', { prec: 50, assoc: 'left', resultType: 'boolean' }],\n    ['!~*', { prec: 50, assoc: 'left', resultType: 'boolean' }],\n    ['SIMILAR TO', { prec: 50, assoc: 'left', resultType: 'boolean' }],\n    // GIS/PostGIS\n    ['&&', { prec: 60, assoc: 'left', resultType: 'boolean' }],\n    ['<->', { prec: 60, assoc: 'left', resultType: 'number' }],\n    ['@', { prec: 60, assoc: 'left', resultType: 'geometry' }],\n    ['&<', { prec: 60, assoc: 'left', resultType: 'boolean' }],\n    ['&>', { prec: 60, assoc: 'left', resultType: 'boolean' }],\n    ['|-', { prec: 60, assoc: 'left', resultType: 'boolean' }],\n    ['-|', { prec: 60, assoc: 'left', resultType: 'boolean' }],\n    ['<<', { prec: 60, assoc: 'left', resultType: 'boolean' }],\n    ['>>', { prec: 60, assoc: 'left', resultType: 'boolean' }],\n    ['<<|', { prec: 60, assoc: 'left', resultType: 'boolean' }],\n    ['|>>', { prec: 60, assoc: 'left', resultType: 'boolean' }],\n    ['&<|', { prec: 60, assoc: 'left', resultType: 'boolean' }],\n    ['|&>', { prec: 60, assoc: 'left', resultType: 'boolean' }],\n    ['~=', { prec: 50, assoc: 'left', resultType: 'boolean' }],\n    ['?#', { prec: 60, assoc: 'left', resultType: 'boolean' }],\n    ['?-', { prec: 60, assoc: 'left', resultType: 'boolean' }],\n    ['?-|', { prec: 60, assoc: 'left', resultType: 'boolean' }],\n    ['?|', { prec: 60, assoc: 'left', resultType: 'boolean' }],\n    ['?||', { prec: 60, assoc: 'left', resultType: 'boolean' }],\n    ['#', { prec: 60, assoc: 'left', resultType: 'number' }],\n    ['##', { prec: 60, assoc: 'left', resultType: 'geometry' }],\n    ['@-@', { prec: 60, assoc: 'left', resultType: 'number' }]\n  ],\n  mysql: [\n    ['DIV', { prec: 70, assoc: 'left', resultType: 'number' }],\n    ['MOD', { prec: 70, assoc: 'left', resultType: 'number' }],\n    ['BINARY', { prec: 90, assoc: 'right', resultType: 'binary' }],\n    ['^', { prec: 80, assoc: 'left', resultType: 'number' }],\n    ['~', { prec: 85, assoc: 'right', resultType: 'number' }],\n    ['<=>', { prec: 50, assoc: 'left', resultType: 'boolean' }],\n    ['REGEXP', { prec: 50, assoc: 'left', resultType: 'boolean' }],\n    ['RLIKE', { prec: 50, assoc: 'left', resultType: 'boolean' }],\n    ['!', { prec: 80, assoc: 'right', resultType: 'boolean' }],\n    ['XOR', { prec: 40, assoc: 'left', resultType: 'boolean' }],\n    ['&&', { prec: 40, assoc: 'left', resultType: 'boolean' }],\n    ['||', { prec: 30, assoc: 'left', resultType: 'boolean' }],\n    [':=', { prec: 10, assoc: 'right', resultType: ':right' }],\n    ['SOUNDS LIKE', { prec: 50, assoc: 'left', resultType: 'boolean' }]\n  ]\n};\n", "import * as toktypes from './toktypes.js';\n\nclass TokenStreamState {\n    buffer = '';\n    cursor = 0;\n    line = 1;\n    column = 1;\n    mysqlBindingIndex = 0;\n    nestingContext = [];\n    nextTokenEscape = 0;\n    next(by = 1, isLf = false) {\n        if (isLf) {\n            this.line++;\n            this.column = 0; // To immediately become 1 below\n        }\n        this.column += by;\n        this.cursor += by;\n        if (this.nextTokenEscape === 1) {\n            this.nextTokenEscape = 2;\n        } else if (this.nextTokenEscape === 2) {\n            this.nextTokenEscape = 0;\n        }\n    }\n}\n\nexport class TokenStream {\n\n    #iterator;\n    #options;\n    #locked = false;\n    #started = false;\n    #done = false;\n\n    #rootSavepoint = null;\n    #history = [];\n    #current;\n    #peeks = [];\n\n    constructor(iterator, { state: _, ...options } = {}) {\n        this.#iterator = iterator;\n        this.#options = options;\n    }\n\n    [Symbol.asyncIterator]() {\n        return this; // Make it an async iterator\n    }\n\n    get options() { return this.#options; }\n\n    get locked() { return this.#locked; }\n\n    get started() { return this.#started; }\n\n    get done() { return this.#done && !this.#peeks.length; }\n\n    previous() {\n        return this.#history[this.#history.length - 1];\n    }\n\n    current() {\n        return this.#current;\n    }\n\n    async next() {\n        this.#assertNotLocked('next()');\n        this.#started = true;\n        let value, done = false;\n        if (this.#peeks.length) {\n            this.#historyPush(this.#current);\n            this.#current = this.#peeksShift();\n            value = this.#current;\n        } else {\n            ({ value, done } = await this.#iterator.next());\n            this.#historyPush(this.#current);\n            this.#current = value;\n            this.#done = done;\n        }\n        if (this.#rootSavepoint !== null && value?.type.endsWith('_block')) {\n            value.value.savepoint();\n        }\n        return { value, done };\n    }\n\n    async match($type, $value = undefined) {\n        const [peek, type, value] = typeof arguments[0] === 'number'\n            ? arguments\n            : [0, $type, $value];\n        const match = (tok) => {\n            return tok && (\n                (Array.isArray(type) ? type.includes(tok.type) : type === tok.type) && (\n                    value === undefined || (Array.isArray(value) ? (value.includes(tok.value) || value.includes(undefined)) : value === tok.value)\n                )\n            ) && tok || undefined;\n        };\n        if (peek === Infinity) {\n            // Match progressively\n            let i = 0, tok;\n            while (tok = await this.peek(i++)) {\n                if (match(tok)) return tok;\n            }\n            return;\n        }\n        return match(\n            peek ? await this.peek(peek) : this.current()\n        );\n    }\n\n    async peek(length = 1) {\n        if (length === 0) return this.#current;\n        let $length = length - this.#peeks.length;\n        while ($length) {\n            const next = await this.#iterator.next();\n            if (next.done) break;\n            this.#peeksPush(next.value);\n            $length--;\n        }\n        const tok = this.#peeks[length - 1];\n        return tok;\n    }\n\n    async eat(type = undefined, value = undefined) {\n        const tok = !type ? this.current() : await this.match(type, value);\n        if (tok) (await this.next())?.value; // advance\n        return tok;\n    }\n\n    async expect(type, value = undefined) {\n        const tok = await this.eat(type, value);\n        if (!tok) throw new Error(`Expected token: ${type}${value ? ` (${value})` : ''}`);\n        return tok;\n    }\n\n    // Normal token flow\n\n    #historyPush(tok) {\n        // this.#history.push() <-- tok (this.#current)\n        if (tok?.type.endsWith('_block')) {\n            //tok.value.#locked = true;\n        }\n        if (this.#rootSavepoint !== null) {\n            this.#history.push(tok);\n        } else {\n            this.#history = [tok];\n        }\n    }\n\n    #peeksShift() {\n        // tok (this.#current) <-- this.#peeks.shift()\n        const tok = this.#peeks.shift();\n        if (tok?.type.endsWith('_block')) {\n            tok.value.#locked = false;\n        }\n        return tok;\n    }\n\n    // Reverse token flow\n\n    #historyPop() {\n        // this.#history.pop() --> tok (this.#current)\n        const tok = this.#history.pop();\n        if (tok?.type.endsWith('_block')) {\n            //tok.value.#locked = false;\n            tok.value.restore(tok.value.#rootSavepoint);\n        }\n        return tok;\n    }\n\n    #peeksUnshift(tok) {\n        // tok (this.#current) --> this.#peeks.unshift()\n        if (tok?.type.endsWith('_block')) {\n            tok.value.restore(tok.value.#rootSavepoint);\n            tok.value.#locked = true;\n        }\n        this.#peeks.unshift(tok);\n    }\n\n    // Peeking token flow\n\n    #peeksPush(tok) {\n        if (tok?.type.endsWith('_block')) {\n            tok.value.#locked = true;\n        }\n        this.#peeks.push(tok);\n    }\n\n    #assertNotLocked(method) {\n        if (this.#locked) {\n            throw new Error(`Can't execute ${method}; TokenStream is locked`);\n        }\n    }\n\n    savepoint() {\n        this.#assertNotLocked('savepoint()');\n        const point = this.#history.length;\n        if (this.#rootSavepoint === null) {\n            this.#rootSavepoint = point;\n        }\n        return point;\n    }\n\n    savepointStatus() {\n        return this.#rootSavepoint !== null\n            ? this.#history.length\n            : null;\n    }\n\n    restore(toIndex) {\n        this.#assertNotLocked('restore()');\n        if (this.#rootSavepoint === null || typeof toIndex !== 'number' || toIndex > this.#history.length) {\n            throw new Error(`Invalid restore point ${toIndex}${this.#rootSavepoint === null ? '. Not in savepoint mode' : ''}`);\n        }\n        while (toIndex < this.#history.length) {\n            if (this.#current) {\n                this.#peeksUnshift(this.#current);\n            }\n            this.#current = this.#historyPop();\n        }\n    }\n\n    commit(toIndex) {\n        this.#assertNotLocked('commit()');\n        if (toIndex !== this.#rootSavepoint) return;\n        let tok;\n        while (toIndex < this.#history.length && (tok = this.#historyPop())) {\n            if (tok.type.endsWith('_block')) {\n                tok.value.commit(tok.value.#rootSavepoint);\n            }\n        }\n        this.#rootSavepoint = null;\n    }\n\n    // Returns ToeknStream\n    static async create(input, { dialect = 'postgres', state = new TokenStreamState, ...options } = {}) {\n        if (Array.isArray(input) && input.every((s) => typeof s === 'object' && s?.type) && (input = input.slice())) {\n            return new this(\n                input[Symbol.iterator](),\n                { dialect, ...options },\n            );\n        }\n        // Normalize options. Consumers of the instance (i.e. parsers) might benefit from it\n        if (!options.normalized) {\n            options = normalizeOptions({ dialect, ...options, normalized: true });\n        }\n        return new this(\n            await this.createIterator(input, { dialect, state, ...options, extendedAPI: true }),\n            { dialect, ...options },\n        );\n    }\n\n    // Factory input -> to stream\n    static toIterator(input) {\n        if (typeof input[Symbol.asyncIterator] === 'function') {\n            return typeof input.next === 'function' ? input : input[Symbol.asyncIterator]();\n        }\n        if (typeof input[Symbol.iterator] === 'function' && typeof input !== 'string' && !(input instanceof String)) {\n            return typeof input.next === 'function' ? input : input[Symbol.iterator]();\n        }\n        return (function* () { yield input + ''; })();\n    }\n\n    // Returns Iterator\n    static async * createIterator(input, { dialect = 'postgres', state = new TokenStreamState, ...options } = {}) {\n\n        // Normalize input to stream\n        const stream = this.toIterator(input);\n        // Validate \"dialect\" and \"state\" input\n        if (!['postgres', 'mysql'].includes(dialect)) {\n            throw new Error(`Unknown dialect: ${dialect}`);\n        }\n        if (!(state instanceof TokenStreamState)) {\n            throw new Error('options.state must be an instance of TokenStreamState');\n        }\n        // Normalize options. Should it not have come from this.create()\n        if (!options.normalized) {\n            options = normalizeOptions({ dialect, ...options, normalized: true });\n        } else {\n            options = { dialect, ...options };\n        }\n        // Local state\n        const localState = {\n            token: null,\n            prevEmittedToken: null,\n            nextTokenSpaceBefore: '',\n            multiwordBuffer: [],\n        };\n        // Route token normalization\n        const $finalizeToken = (token, forceYield = false) => {\n            if (!token) return [];\n            const result = finalizeToken(token, { options, state, localState }, forceYield);\n            return result;\n        };\n\n        // Iterate over the input stream chunk by chunk\n        let chunk = { value: '' };\n        do {\n            state.buffer += chunk.value || ''/*when done*/;\n            let char;\n            while (char = state.buffer[state.cursor]) {\n\n                const possiblyChunked = state.buffer[state.cursor + 1] === undefined && !chunk.done;\n                const charIsWhitespace = whitespace.has(char);\n                const $throw = () => {\n                    throw new SyntaxError(`Unexpected token: ${char} at line ${state.line}, column ${state.column}`);\n                }\n\n                /**\n                 * ----------\n                 * PART A:\n                 * Feed or terminate sequences\n                 */\n\n                // ----------\n                // Feed (with validation) or terminate special literals.\n                // !ORDER: Note that because we're handling the ending of non-delimited \"literals\" here, (by whitespace)\n                // this block must run before the generic whitespace-handling block below\n                // Meanhwile, we're also using the opportunity to handle delimited ones's ending\n                if (localState.token?.type === 'hex_literal' || localState.token?.type === 'bit_literal') {\n                    const isEndTag = localState.token.delim ? char === localState.token.delim : charIsWhitespace;\n                    if (isEndTag) {\n                        yield* $finalizeToken(localState.token);\n                        localState.token = null;\n                        if (charIsWhitespace && options.spaces) {\n                            localState.nextTokenSpaceBefore += char;\n                        }\n                    } else {\n                        const type = localState.token?.type;\n                        if (type === 'hex_literal') {\n                            if (!/[0-9A-Fa-f]/.test(char)) $throw();\n                        } else {\n                            if (!/[01]/.test(char)) $throw();\n                        }\n                        localState.token.value += char;\n                    }\n                    state.next();\n                    continue;\n                }\n\n                // ----------\n                // Feed (with validation) or terminate \"version_specs\".\n                // !ORDER: Note that because we're handling the ending of non-delimited \"version_specs\" here, (by whitespace or dot)\n                // this block must run before the generic whitespace-handling block below\n                // Meanhwile, we're also using the opportunity to handle delimited ones's ending\n                if (localState.token?.type === 'version_spec') {\n                    const isEndQuote = localState.token.delim && char === localState.token.delim;\n                    const isEndTag = isEndQuote || (charIsWhitespace || char === '.' || char === ',' || char === ';' || char === ')');\n                    if (isEndTag) {\n                        yield* $finalizeToken(localState.token);\n                        localState.token = null;\n                    } else if (localState.token.value) {\n                        if (char === '=') {\n                            // \"=\" only allowed as @=2_4, @<=4, @>=2\n                            if (!['<', '>'].includes(localState.token.value)) $throw();\n                        } else if (char === '_') {\n                            // \"_\" only allowed as digits separator\n                            if (!/\\d$/.test(localState.token.value)) $throw();\n                        } else if (!/\\d/.test(char)) $throw();\n                        localState.token.value += char;\n                    } else {\n                        localState.token.value += char;\n                    }\n                    if (!isEndTag || isEndQuote) {\n                        state.next();\n                        continue;\n                    }\n                }\n\n                // ----------\n                // Whitespace and Linebreaks end sequences\n                // but:\n                // - whitespace is contigious with strings, delimited idents, and comments\n                // - line breaks end single-line comments\n                // !ORDER: Handle this early, but after the \"literals\" block above.\n                if (charIsWhitespace) {\n                    const isString = localState.token?.type === 'string_literal';\n                    const isDelimitedIdent = localState.token?.type === 'identifier' && localState.token.delim;\n                    const isBlockComment = localState.token?.type === 'block_comment';\n                    const isLineComment = localState.token?.type === 'line_comment';\n                    if (isString || isDelimitedIdent || isBlockComment || isLineComment && !(\n                        char === '\\r' || char === '\\n')\n                    ) {\n                        // Not a single-line comment ending. Treat as contigious!\n                        localState.token.value += char;\n                    } else {\n                        // Whitespace starting...? End current token!\n                        const prevChar = state.buffer[state.cursor - 1];\n                        if (!whitespace.has(prevChar) && localState.token) {\n                            yield* $finalizeToken(localState.token);\n                            localState.token = null;\n                        }\n                        if (options.spaces) {\n                            localState.nextTokenSpaceBefore += char;\n                        }\n                    }\n                    if (char === '\\n' || char === '\\r') {\n                        state.next(1, true);\n                    } else {\n                        state.next();\n                    }\n                    continue;\n                }\n\n                // ----------\n                // Handle backslahes in strings when in backslah-escaping mode\n                // - or when in nested context and is a Double Colon-escaping position\n                // !ORDER: Handle backslashes early.\n                if (char === '\\\\') {\n                    if (possiblyChunked) break; // We need to look ahead to know if this is comment ending\n                    let nextChar = state.buffer[state.cursor + 1];\n                    // String char escaping...\n                    const strings_inBackslashEscapeMode = localState.token?.type === 'string_literal' && (options.dialect === 'mysql' ? !options.mysqlNoBackslashEscapes : localState.token.modifier === 'E');\n                    const strings_atEscapePosition = nextChar === localState.token?.delim || nextChar === '\\\\' || nextChar === '0' || nextChar === 'b' || nextChar === 'f' || nextChar === 'n' || nextChar === 'r' || nextChar === 't' || nextChar === 'v' || nextChar === 'Z';\n                    if (strings_inBackslashEscapeMode && strings_atEscapePosition) {\n                        nextChar = {\n                            '\\\\': '\\\\', // to backslash char itself, here for completeness\n                            '0': '\\0', // to NUL byte (ASCII 0)\n                            'b': '\\b', // to backspace (ASCII 8)\n                            'f': '\\f', // to form feed\n                            'n': '\\n', // to newline\n                            'r': '\\r', // to carriage return\n                            't': '\\t', // to tab\n                            'v': '\\v', // to vertical tab\n                            'Z': '\\x1A', // to ASCII 26 (SUB / Control+Z) - represented as \\x1A in JS\n                        }[nextChar] || nextChar;\n                        localState.token.value += nextChar;\n                        state.next(2);\n                        continue;\n                    }\n                    state.nextTokenEscape = 1;\n                    state.next();\n                    continue;\n                }\n\n                // ----------\n                // Feed or terminate:\n                // - block_comment\n                // - string_literal\n                // - delimited identifier\n                // - delimited user_var\n                if (localState.token?.type === 'block_comment'\n                    || localState.token?.type === 'line_comment' // For feeding\n                    || localState.token?.type === 'string_literal'\n                    || (localState.token?.type === 'identifier' && localState.token.delim)\n                    || (localState.token?.type === 'user_var' && localState.token.delim)/*MySQL @'user-var'*/) {\n                    let tokenEndSteps;\n                    if (localState.token.type === 'block_comment') {\n                        if (char === '*') {\n                            if (possiblyChunked) break; // We need to look ahead to know if this is comment ending\n                            const nextChar = state.buffer[state.cursor + 1];\n                            tokenEndSteps = nextChar === '/' ? 2 : 0; // 2 chars for end tag, 0 otherwise: not a comment end\n                        }\n                    } else if (char === localState.token.delim) {\n                        // Two contiqious delims is escape when is identifier\n                        const twoContiqiousDelimsIsEscape = localState.token.type === 'identifier'\n                            // Or for strings, when not using backslash as escape\n                            || localState.token.type === 'string_literal' && (options.dialect === 'mysql' ? options.mysqlNoBackslashEscapes : localState.token.modifier !== 'E');\n                        // Do escaping if so\n                        if (twoContiqiousDelimsIsEscape) {\n                            if (possiblyChunked) break; // We need to look ahead to know if this is an quote escape quote\n                            const nextChar = state.buffer[state.cursor + 1];\n                            if (nextChar === char) {\n                                localState.token.value += char; // Pick one of the two quotes\n                                state.next(2); // and eat the other\n                                continue;\n                            }\n                        }\n                        // End token otherwise: char === localState.token.delim\n                        tokenEndSteps = 1;\n                    } else if (localState.token.type === 'string_literal' && localState.token.delim.startsWith('$')/*postgres*/ && char === '$') {\n                        // Specially catch Postgres' dollar-delims\n                        const cursor = state.cursor + 1;\n                        if (state.buffer.slice(cursor - localState.token.delim.length, cursor) === localState.token.delim) {\n                            localState.token.value = localState.token.value.slice(0, - localState.token.delim.length + 1);\n                            tokenEndSteps = 1;\n                        }\n                    }\n                    if (tokenEndSteps) {\n                        yield* $finalizeToken(localState.token);\n                        localState.token = null;\n                        state.next(tokenEndSteps);\n                        continue;\n                    }\n                    // Feed ongoing sequence\n                    localState.token.value += char;\n                    state.next();\n                    continue;\n                }\n\n                // ----------\n                // Handle closing nesting delims:\n                // - }\n                // - ]\n                // - )\n                if (state.nestingContext.length && char === { '{': '}', '[': ']', '(': ')' }[state.nestingContext[0]]) {\n                    yield* $finalizeToken(localState.token, true);\n                    state.nestingContext.shift();\n                    if (options.structured) {\n                        state.next(); // Eat the end tag\n                        localState.nestingEndTagSeen = true;\n                        return;\n                    }\n                    localState.token = null;\n                }\n\n                /**\n                 * ----------\n                 * PART B:\n                 * Start or restart sequences\n                 */\n\n                // ----------\n                // Start\n                // - comments\n                // - strings\n                // - identifiers\n                let tokenStart, tokenStartBacksteps = 0, tokenStartForwardsteps = 0;\n\n                if (options.dialect === 'postgres') {\n                    // Postgres' dollars :)\n                    if (localState.token?.type === 'pg_possible_dollar_delim' || char === '$') {\n                        // Catch the beginning of Postgres' dollar-delims\n                        if (localState.token?.type === 'pg_possible_dollar_delim') {\n                            if (char === '$') {\n                                const { type: _, value, delim: __, ...restTok } = localState.token;\n                                localState.token = { type: 'string_literal', value: '', delim: `$${value}$`, ...restTok };\n                            } else {\n                                localState.token.value += char;\n                            }\n                            state.next();\n                            continue;\n                        }\n                        if (possiblyChunked) break; // We need to look ahead to know if this is bind_var or...\n                        const nextChar = state.buffer[state.cursor + 1];\n                        if (/[0-9]/.test(nextChar)) {\n                            tokenStart = { type: 'bind_var' };\n                        } else {\n                            // ...possible dollar-delimited string\n                            tokenStart = { type: 'pg_possible_dollar_delim', delim: char };\n                        }\n                    }\n                } else if (options.dialect === 'mysql') {\n                    // MySQL's questions :)\n                    if (char === '?') {\n                        tokenStart = { type: 'bind_var' };\n                    }\n                    // MySQL's hash comments :)\n                    if (char === '#') {\n                        tokenStart = { type: 'line_comment', delim: char };\n                    }\n                    // MySQL's backflips :)\n                    if (char === '`') {\n                        tokenStart = { type: 'identifier', delim: char };\n                    }\n                }\n\n                // Strings and ansi-delimited identifers\n                if (char === \"'\") {\n                    const modifierPattern = new RegExp(`(@)$|^\\\\W?(${options.dialect === 'postgres' ? 'E|X|B' : 'N|X'})$`, 'i');\n                    const modifierMatch = state.buffer.slice(Math.max(state.cursor - 2, 0), state.cursor).match(modifierPattern);\n                    const modifier = modifierMatch?.[1] || modifierMatch?.[2];\n                    // First try to match LinkedQL version tag\n                    if (modifier === '@' && localState.prevEmittedToken?.type === 'identifier') {\n                        if (possiblyChunked) break; // We need to look ahead to properly determine if variable\n                        const nextChar = state.buffer[state.cursor + 1];\n                        if (/[\\^~=\\d<>!]/.test(nextChar)) {\n                            // Resolve to @'1_1_tags'\n                            tokenStart = { type: 'version_spec', delim: char };\n                            tokenStartBacksteps = 1;\n                        }\n                    }\n                    // Otherwise, resolve to:\n                    // E'new\\\\nline' (postgres)\n                    // N'unicode' (mysql)\n                    // X'FF' (mysql && postgres)\n                    // B'0101' (postgres)\n                    // @'mysql-user-var' (mysql)\n                    if (!tokenStart) {\n                        if (modifier && (modifier !== '@' || options.dialect === 'mysql')) {\n                            const type = /^(E|N)/i.test(modifier) ? 'string_literal' : (\n                                modifier === '@' ? 'user_var' : (modifier === 'X' ? 'hex_' : 'bit_') + 'literal'\n                            );\n                            tokenStart = { type, ...(type === 'string_literal' ? { modifier: modifier.toUpperCase() } : {}), delim: char };\n                            tokenStartBacksteps = modifier === '@' ? 1 : modifier.length;\n                        } else {\n                            tokenStart = { type: 'string_literal', delim: char };\n                        }\n                    }\n                } else if (char === '\"') {\n                    const type = options.dialect !== 'mysql' || options.mysqlAnsiQuotes ? 'identifier' : 'string_literal';\n                    tokenStart = { type, delim: char };\n                }\n\n                if (char === '@') {\n                    // LinkedQL version tag or MySQL user/system variable?\n                    if (possiblyChunked) break; // We need to look ahead to properly determine if variable\n                    const nextChar = state.buffer[state.cursor + 1];\n                    if ((localState.token || localState.prevEmittedToken)?.type === 'identifier' && /[\\^~=\\d<>!]/.test(nextChar)) {\n                        // LinkedQL @1_1_tags\n                        tokenStart = { type: 'version_spec' };\n                    } else if (options.dialect === 'mysql') {\n                        // MySQL's varieties :)\n                        if (nextChar === '@') {\n                            // MySQL system variables\n                            tokenStart = { type: 'system_var' };\n                            tokenStartForwardsteps = 1;\n                        } else if (/[a-zA-Z_$]/.test(nextChar)) {\n                            // MySQL user-defined variables\n                            tokenStart = { type: 'user_var' };\n                        }\n                    }\n                }\n\n                // Comments\n                if (char === '/' || char === '-') {\n                    if (possiblyChunked) break; // We need to look ahead to know if this is comment starting\n                    const nextChar = state.buffer[state.cursor + 1];\n                    if (char === '/' && nextChar === '*') {\n                        tokenStart = { type: 'block_comment' };\n                        tokenStartForwardsteps = 1;\n                    } else if (char === '-' && nextChar === '-') {\n                        tokenStart = { type: 'line_comment', delim: char + nextChar };\n                        tokenStartForwardsteps = 1;\n                    }\n                }\n\n                // Start token\n                if (tokenStart) {\n                    if (localState.token && !tokenStartBacksteps) {\n                        yield* $finalizeToken(localState.token);\n                    }\n                    localState.token = { type: tokenStart.type, value: '', ...tokenStart, line: state.line, column: tokenStartBacksteps ? state.column - tokenStartBacksteps : state.column };\n                    state.next(1 + tokenStartForwardsteps);\n                    continue;\n                }\n\n                // ----------\n                // Start nesting:\n                // - {\n                // - [\n                // - (\n                if (char === '{' || char === '[' || char === '(') {\n                    // When we encounter an opening nesting delim, we enter sub-tokenization\n                    yield* $finalizeToken(localState.token);\n                    localState.token = null;\n                    state.nestingContext.unshift(char);\n                    if (options.structured) {\n                        state.next();\n                        const groupToken = {\n                            type: { '{': 'brace_block', '[': 'bracket_block', '(': 'paren_block' }[char],\n                            value: await this[options.extendedAPI ? 'create' : 'createIterator'](stream, { state, ...options }),\n                            line: state.line,\n                            column: state.column,\n                        };\n                        yield* $finalizeToken(groupToken);\n                        if (options.extendedAPI) {\n                            await groupToken.value.peek(Infinity);\n                        } else {\n                            while (!(await groupToken.value.next()).done);\n                        }\n                        continue;\n                    }\n                }\n\n                /**\n                 * ----------\n                 * PART C:\n                 * Handle more nuanced sequences\n                 */\n\n                if (/[0-9]/.test(char)) {\n                    // A number \"literal\" or MySQL's HEX \"literal\" or Postgres' BIN \"literal\"\n                    // Passed along if this is part of an \"identifier\", \"bind_var\", \"version_spec\", \"*_literal\", or  \"*_var\" sequence\n                    if (localState.token?.type !== 'identifier' && localState.token?.type !== 'bind_var' && localState.token?.type !== 'version_spec' && !localState.token?.type.endsWith('_literal') && !localState.token?.type.endsWith('_var')) {\n                        yield* $finalizeToken(localState.token);\n                        if (/*HEX: 0xFF*/char === '0') {\n                            if (possiblyChunked) break; // We need to look ahead to know if this is an X\n                            const $type = state.buffer[state.cursor + 1]?.toUpperCase();\n                            if (($type === 'X' || $type === 'B') && options.dialect === 'mysql') {\n                                localState.token = { type: ($type === 'X' ? 'hex_' : 'bit_') + 'literal', value: '', line: state.line, column: state.column };\n                                state.next(2);\n                                continue;\n                            }\n                        }\n                        localState.token = { type: 'number_literal', value: char, line: state.line, column: state.column };\n                        state.next();\n                        continue;\n                    }\n                } else if (/[a-zA-Z_]/.test(char)) {\n                    // Alphanumeric sequences that start as \"identifier\" but could translate to \"keywords\", \"identifiers\", or even \"operators\"\n                    // Passed along if this is part of a \"identifier\" or \"*_var\" sequence or is the \"E\" in Scientific number notations\n                    if (localState.token?.type !== 'identifier' && !localState.token?.type.endsWith('_var') && !(localState.token?.type === 'number_literal'\n                        && /*EXP: 30e2*/(/\\d$/.test(localState.token.value) && /E/i.test(char)))) {\n                        // Throw if in mid-number sequence\n                        if (localState.token?.type === 'number_literal') $throw();\n                        yield* $finalizeToken(localState.token);\n                        // Start identifier\n                        localState.token = { type: 'identifier', value: char, line: state.line, column: state.column };\n                        state.next();\n                        continue;\n                    }\n                } else {\n                    // Handle punctuations and operators\n                    let type = 'operator';\n                    if (char === ';'\n                        || char === ','\n                        || char === ':'\n                        || char === '{'\n                        || char === '}'\n                        || char === '['\n                        || char === ']'\n                        || char === '('\n                        || char === ')') {\n                        if (char === ':' && (state.nestingContext[0] !== '{' || state.nextTokenEscape)) {\n                            type = 'operator'; // Postgres' colon is an operator, not a punctuation\n                        } else {\n                            type = 'punctuation';\n                        }\n                        if (options.dialect === 'postgres' && char === ':' && type === 'operator' && localState.token?.type !== 'operator') {\n                            const previousChar = state.buffer[state.cursor - 1];\n                            if (possiblyChunked) break; // We need to look ahead to know if this is number starting\n                            const nextChar = state.buffer[state.cursor + 1];\n                            if (previousChar !== ':' && /[a-zA-Z_]/.test(nextChar) && options.PL_SQL !== false) {\n                                type = 'user_var'; // PL/SQL variable\n                                char = '';\n                            }\n                        }\n                    } else if (char === '.') {\n                        if (localState.token?.type === 'number_literal') {\n                            // Mid-number punctuation; floats\n                            if (localState.token.value.includes('.')) $throw();\n                            type = 'number_literal'; // e.g. 2.4\n                        } else {\n                            // Pre-number punctuation? Same floats?\n                            if (possiblyChunked) break; // We need to look ahead to know if this is number starting or a punctuation\n                            const nextChar = state.buffer[state.cursor + 1];\n                            if (/\\d/.test(nextChar)) {\n                                type = 'number_literal'; // e.g. \".004\"\n                            } else {\n                                // Other punctuation. Standalone token:\n                                // e.g. tbl.col, tbl.*, db@<3_2.\"000-u\".id\n                                type = 'punctuation'; // e.g. \"tbl.col\", \"tbl . col\"\n                                // Or maybe MySQL special var punctuation?\n                                if (localState.token?.type === 'system_var') {\n                                    type = 'system_var'; // e.g. \"@@session. autocommit\"\n                                }\n                            }\n                        }\n                    } else if (char === '+' || char === '-') {\n                        if (localState.token?.type === 'number_literal' && /E$/i.test(localState.token.value)) {\n                            // Scientific number notation; EXP: 30e-2\n                            if (/\\+|\\-/.test(localState.token.value)) $throw();\n                            type = 'number_literal';\n                        }\n                    }\n\n                    // Feed an ongoing sequence or terminate that and start a new one?\n                    if (localState.token?.type !== type || type === 'punctuation' || (\n                        type === 'operator' && !options.operators.classic.has(`${localState.token.value}${char}`) /*not a valid operator afterall? e.g. \"=-\"*/\n                    )) {\n                        yield* $finalizeToken(localState.token);\n                        localState.token = { type, value: char, line: state.line, column: state.column };\n                        state.next();\n                        continue;\n                    }\n\n                    // Passed thru to feed an ongoing sequence\n                }\n\n                localState.token.value += char;\n                state.next();\n            }\n\n            if (chunk.done) break;\n            // Update buffer to handle overflow and continue from next chunk\n            state.buffer = state.buffer.slice(state.cursor);\n            state.cursor = 0;\n        } while (chunk = await stream.next());\n\n        if (localState.token) {\n            if (\n                (localState.token.type === 'operator' && localState.token.value !== '*')\n                || localState.token.type === 'number_literal' && /E$/i.test(localState.token.value)\n                || localState.token.type === 'block_comment'\n                || localState.token.type === 'pg_possible_dollar_delim'\n                || (\n                    ['string_literal', 'hex_literal', 'bit_literal', 'identifier', 'version_spec', 'user_var'].includes(localState.token.type)\n                    && localState.token.delim\n                )) {\n                throw new SyntaxError(`Unterminated ${localState.token.type} at line ${state.line}, column ${state.column}`);\n            }\n            yield* $finalizeToken(localState.token, true);\n        }\n        if (state.nestingContext.length && !localState.nestingEndTagSeen) {\n            throw new SyntaxError(`Unterminated nesting \"${state.nestingContext[0]}\" at line ${state.line}, column ${state.column}`);\n        }\n    }\n}\n\n// Lookups\nconst whitespace = new Set([' ', '\\f', '\\n', '\\r', '\\t', '\\v',]);\n\n// Normalize options\nfunction normalizeOptions(options) {\n    // Build the following list into our formats\n    const addMultiWord = (targetMap, prefix, tok, token) => {\n        tok.split(' ').reduce((_tok, chunk) => {\n            _tok = _tok ? `${_tok} ${chunk}` : chunk;\n            targetMap.set(_tok, token);\n            return _tok;\n        }, prefix);\n    };\n    for (const tokenCategory of ['statements', 'functionNames', 'aggrFunctionNames', 'keywords', 'operators', 'dataTypes']) {\n        const $tokenCategory = ['statements', 'functionNames', 'aggrFunctionNames'].includes(tokenCategory) ? 'keywords' : tokenCategory;\n        const tokenRegistry = options[$tokenCategory] || { classic: new Map, compound: new Map };\n        for (const tokenDialectBranch of ['common', options.dialect === 'mysql' ? 'mysql' : 'postgres']) {\n            const entries = toktypes[tokenCategory][tokenDialectBranch];\n            for (const entry of entries) {\n                const [value, token] = Array.isArray(entry) ? [entry[0], { ...entry[1], value: entry[0] }] : [entry, { value: entry }];\n                if (value.includes(' ')) {\n                    addMultiWord(tokenRegistry.compound, '', value, token);\n                } else {\n                    tokenRegistry.classic.set(value, token);\n                }\n            }\n        }\n        options = { ...options, [$tokenCategory]: tokenRegistry };\n    }\n    return options;\n}\n\n// Finalize tokens\nfunction finalizeToken(token, { options, state, localState }, forceYield = false) {\n    if (localState.nextTokenSpaceBefore) {\n        const { type, ...tok } = token;\n        token = { type, spaceBefore: localState.nextTokenSpaceBefore, ...tok };\n        localState.nextTokenSpaceBefore = '';\n    }\n    if (token.type === 'block_comment' || token.type === 'line_comment') {\n        return finalizeComment(token, { options });\n    }\n    let finalToken, identResolution = false;\n    if (options.dialect === 'mysql' && token.type === 'bind_var') {\n        finalToken = [{ ...token, value: `${++state.mysqlBindingIndex}` }];\n    } else if (token.type === 'operator') {\n        // Add operator definition details\n        const { line, column, ...restTok } = token;\n        finalToken = [{\n            ...restTok,\n            ...(options.operators.classic.get(token.value) || {}),\n            line,\n            column,\n        }];\n    } else if (token.type === 'identifier' && !token.delim) {\n        finalToken = finalizeIdentifier(token, { options, state, localState }, forceYield);\n        identResolution = true;\n    }\n    if (!finalToken/*Without asking length*/) {\n        finalToken = [token];\n    }\n    // -----\n    if (finalToken?.length) {\n        localState.prevEmittedToken = finalToken[0];\n    } else {\n        localState.prevEmittedToken = token;\n    }\n    // -----\n    if (!identResolution && finalToken.length && localState.multiwordBuffer.length) {\n        return localState.multiwordBuffer.splice(0).concat(finalToken);\n    }\n    return finalToken;\n}\n\n// Finalize comment tokens\nfunction finalizeComment(token, { options }) {\n    if (!options.comments) return [];\n    if (token.type === 'block_comment') {\n        token = { ...token, value: token.value.split('\\n').map((s) => s.replace(/^[ ]+\\*[ ]+?/, '').trim()).join('\\n') };\n    } else {\n        token = { ...token, value: token.value.trim() };\n    }\n    return [token];\n}\n\n// Finalize \"literal\" tokens\nfunction finalizeIdentifier(token, { options, state, localState }, forceYield = false) {\n    let finalToken,\n        multiwordBufferLength = localState.multiwordBuffer.length;\n    // Yield or build multiword operators\n    const wordSoFar = (\n        multiwordBufferLength ? localState.multiwordBuffer.map((tok) => tok.value).concat(token.value).join(' ') : token.value\n    ).toUpperCase();\n\n    const findInBranch = (branch) => {\n        for (const tokenCategory of ['keywords', 'operators', 'dataTypes']) {\n            const matchResult = options[tokenCategory][branch].get(wordSoFar);\n            if (matchResult) return [tokenCategory, matchResult];\n        }\n        return [];\n    };\n\n    const resolveTok = (matchResult) => {\n        let { type: _, spaceBefore, line, column, ...restTok } = token;\n        if (multiwordBufferLength) {\n            spaceBefore = localState.multiwordBuffer[0].spaceBefore;\n            line = localState.multiwordBuffer[0].line;\n            column = localState.multiwordBuffer[0].column;\n        }\n        const tok = {\n            type: tokenCategory === 'dataTypes' ? 'data_type' : tokenCategory.replace(/s$/, ''),\n            ...(spaceBefore ? { spaceBefore } : {}),\n            ...restTok,\n            ...matchResult, // Final value in here and overriding restTok.value\n            value: wordSoFar,\n            line, // \"line\" and \"column\" coming last now\n            column\n        };\n        return tok;\n    };\n\n    const processExactMatch = (matchResult) => {\n        const tok = resolveTok(matchResult);\n        if (multiwordBufferLength) {\n            finalToken = [tok];\n            localState.multiwordBuffer.splice(0);\n            multiwordBufferLength = 0;\n        } else {\n            finalToken = [tok];\n        }\n    };\n    const processPartialMatch = (matchResult) => {\n        const tok = resolveTok(matchResult);\n        localState.multiwordBuffer.push(tok);\n        finalToken = [];\n    };\n\n    let multiwordMatched = false;\n    let [tokenCategory, matchResult] = findInBranch('compound');\n    if (matchResult?.value === wordSoFar) {\n        processExactMatch(matchResult);\n        multiwordMatched = true;\n    } else if (matchResult) {\n        // first (e.g. DISTINCT kw vs DISTINCT FROM op)\n        const [tokenCategory2, matchResult2] = findInBranch('classic');\n        if (matchResult2 && tokenCategory2 !== tokenCategory) {\n            [tokenCategory, matchResult] = [tokenCategory2, matchResult2];\n        }\n        if (forceYield) {\n            processExactMatch(matchResult);\n        } else {\n            processPartialMatch(matchResult);\n        }\n        multiwordMatched = true;\n    } else {\n        [tokenCategory, matchResult] = findInBranch('classic');\n        if (matchResult) {\n            processExactMatch(matchResult);\n            multiwordMatched = true;\n        }\n    }\n    if (!multiwordMatched && multiwordBufferLength) {\n        const existing = localState.multiwordBuffer.splice(0);\n        const current = finalizeToken(token, { options, state, localState });\n        return [...existing, ...current];\n    }\n    // Treat as identifier\n    if (!finalToken && /^(TRUE|FALSE|NULL|UNKNOWN)$/i.test(token.value)) {\n        const { type: _, ...tok } = token;\n        finalToken = [{\n            type: /UNKNOWN/.test(token.value) ? 'unknown_literal' : (/NULL/i.test(token.value) ? 'null_literal' : 'bool_literal'),\n            ...tok,\n            value: token.value.toUpperCase(),\n        }];\n    }\n    return finalToken;\n}\n", "export const registry = Object.create(null);\n", "import { _isObject } from '@webqit/util/js/index.js';\r\nimport { _eq, _toCapsSnake } from './util.js';\r\nimport { TokenStream } from '../TokenStream.js';\r\nimport { TOK_TYPES } from '../toktypes.js';\r\nimport { registry } from '../registry.js';\r\n\r\n/**\r\n * parse(str, { ... })|fromJSON(json, {\r\n *   dialect,\r\n * \t mysqlAnsiQuotes\r\n *   mysqlNoBackslashEscapes,\r\n *   assert\r\n * })\r\n * \r\n * stringify({\r\n *   prettyPrint,\r\n * \t startingIndentLevel,\r\n *   autoLineBreakThreshold,\r\n *   pruneOptionalParens,\r\n *   tabSpaces\r\n * })\r\n * \r\n * jsonfy({\r\n *   nodeNames,\r\n *   toDialect,\r\n *   deSugar,\r\n *   reverseRef,\r\n *   memoizeDimensionalInsertSelect,\r\n * })\r\n */\r\n\r\nexport class AbstractNode {\r\n\r\n\tstatic get NODE_NAME() { return _toCapsSnake(this.name); }\r\n\tget NODE_NAME() { return this.constructor.NODE_NAME; }\r\n\r\n\t#ast;\r\n\tget _ast() { return this.#ast; }\r\n\r\n\t#options;\r\n\tget options() {\r\n\t\tconst options = this.#options || this.#parentNode?.options || { dialect: 'postgres' };\r\n\t\treturn options;\r\n\t}\r\n\r\n\t#parentNode;\r\n\tget parentNode() { return this.#parentNode; }\r\n\r\n\tget statementNode() { return this.#parentNode?.statementNode; }\r\n\r\n\tget rootNode() { return this.#parentNode?.rootNode || this; }\r\n\r\n\tconstructor(ast = {}, options = {}) {\r\n\t\tthis.#ast = ast;\r\n\t\tthis.#options = options;\r\n\t\tfor (const node_s of Object.values(this.#ast)) {\r\n\t\t\tthis._adoptNodes(...[].concat(node_s));\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * -----------\r\n\t * AST API\r\n\t * -----------\r\n\t */\r\n\r\n\t_keys() { return Object.keys(this.#ast).filter((k) => this.#ast[k] !== undefined); }\r\n\r\n\t_has(fieldName, index = undefined, cs = undefined) {\r\n\t\tif (!(fieldName in this.#ast)) return false;\r\n\t\tif (typeof index === 'number') {\r\n\t\t\treturn typeof this.#ast[fieldName][index] !== 'undefined';\r\n\t\t}\r\n\t\tif (index) {\r\n\t\t\treturn this.#ast[fieldName].some((n) => n.identifiesAs?.(index, cs));\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\t_get(fieldName, index = undefined, cs = undefined) {\r\n\t\tif (!(fieldName in this.#ast)) return;\r\n\t\tif (typeof index !== 'undefined' && !Array.isArray(this.#ast[fieldName])) {\r\n\t\t\tthrow new Error(`Can't use index in field \"${fieldName}\"; not an array.`)\r\n\t\t}\r\n\t\tlet value = this.#ast[fieldName];\r\n\t\tif (typeof index === 'number') {\r\n\t\t\tvalue = value[index];\r\n\t\t} else if (index) {\r\n\t\t\tvalue = value.find((n) => n.identifiesAs?.(index, cs));\r\n\t\t}\r\n\t\treturn value;\r\n\t}\r\n\r\n\t_set(fieldName, indexOrValue, valueOnIndex = undefined, cs = undefined) {\r\n\t\tconst index = arguments.length > 2 ? indexOrValue : undefined;\r\n\t\tconst value = arguments.length > 2 ? valueOnIndex : indexOrValue;\r\n\t\tconst existing = typeof index !== 'undefined' ? this._get(fieldName, index, cs) : undefined;\r\n\t\tif (existing) {\r\n\t\t\tthis._unadoptNodes(...[].concat(existing));\r\n\t\t}\r\n\t\tif (typeof index !== 'undefined') {\r\n\t\t\tthis.#ast[fieldName] = !existing\r\n\t\t\t\t? this.#ast[fieldName].concat(value)\r\n\t\t\t\t: this.#ast[fieldName].reduce((all, n) => {\r\n\t\t\t\t\tif (n === existing) return all.concat(value);\r\n\t\t\t\t\treturn all.concat(n);\r\n\t\t\t\t}, []);\r\n\t\t} else {\r\n\t\t\tthis.#ast[fieldName] = value;\r\n\t\t}\r\n\t\tthis._adoptNodes(...[].concat(value));\r\n\t\treturn true;\r\n\t}\r\n\r\n\t_delete(fieldName, index = undefined, cs = undefined) {\r\n\t\tif (!(fieldName in this.#ast)) return false;\r\n\t\tif (typeof index !== 'undefined' && !Array.isArray(this.#ast[fieldName])) {\r\n\t\t\tthrow new Error(`Can't use index in field \"${fieldName}\"; not an array.`)\r\n\t\t}\r\n\t\tif (typeof index !== 'undefined') {\r\n\t\t\tthis.#ast[fieldName] = this.#ast[fieldName].reduce((all, n, i) => {\r\n\t\t\t\tconst matches = typeof index === 'number' ? i === index : n.identifiesAs?.(index, cs);\r\n\t\t\t\tif (matches) {\r\n\t\t\t\t\tthis._unadoptNodes(n);\r\n\t\t\t\t\treturn all;\r\n\t\t\t\t}\r\n\t\t\t\treturn all.concat(n);\r\n\t\t\t}, []);\r\n\t\t} else {\r\n\t\t\tthis._unadoptNodes(...[].concat(this.#ast[fieldName]));\r\n\t\t\tthis.#ast[fieldName] = Array.isArray(this.#ast[fieldName]) ? [] : undefined;\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\t_add(fieldName, ...args) {\r\n\t\tif (!Array.isArray(this.#ast[fieldName])) {\r\n\t\t\tthrow new Error(`Can't add on field \"${fieldName}\"; not an array.`)\r\n\t\t}\r\n\t\tthis._adoptNodes(...args);\r\n\t\tthis.#ast[fieldName] = this.#ast[fieldName].concat(args);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t_adoptNodes(...nodes) {\r\n\t\tfor (const node of nodes) {\r\n\t\t\tif (!(node instanceof AbstractNode)) continue;\r\n\t\t\tif (node.#parentNode && node.#parentNode !== this) {\r\n\t\t\t\tconst activeTrailStr = `${this.NODE_NAME}`;\r\n\t\t\t\tthrow new Error(`[${activeTrailStr}] Illegal node operation`);\r\n\t\t\t}\r\n\t\t\tnode.#parentNode = this;\r\n\t\t}\r\n\t}\r\n\r\n\t_unadoptNodes(...nodes) {\r\n\t\tfor (const node of nodes) {\r\n\t\t\tif (!(node instanceof AbstractNode)) continue;\r\n\t\t\tif (node.#parentNode !== this) {\r\n\t\t\t\tconst activeTrailStr = `${this.NODE_NAME}`;\r\n\t\t\t\tthrow new Error(`[${activeTrailStr}] Illegal node operation`);\r\n\t\t\t}\r\n\t\t\tnode.#parentNode = null;\r\n\t\t}\r\n\t}\r\n\r\n\tclimbTree(visitor) {\r\n\t\tif (!this.#parentNode) return;\r\n\t\treturn visitor(this.#parentNode, () => {\r\n\t\t\treturn this.#parentNode.climbTree(visitor);\r\n\t\t});\r\n\t}\r\n\r\n\twalkTree(visitor) {\r\n\t\tconst visit = (value, key) => {\r\n\t\t\tif (!(value instanceof AbstractNode)\r\n\t\t\t\t&& !Array.isArray(value)) return;\r\n\r\n\t\t\tconst result = visitor(value, key);\r\n\t\t\tif (result !== value) return;\r\n\r\n\t\t\tif (Array.isArray(value)) {\r\n\t\t\t\tvalue.map(visit);\r\n\t\t\t} else if (value.statementNode !== value) {\r\n\t\t\t\tvalue.walkTree(visitor);\r\n\t\t\t}\r\n\t\t};\r\n\t\tfor (const [key, value] of Object.entries(this.#ast)) {\r\n\t\t\tvisit(value, key);\r\n\t\t}\r\n\t}\r\n\r\n\tcontainsNode(possibleChild) {\r\n\t\tif (!possibleChild) return false;\r\n\t\treturn this === possibleChild.parentNode || this.containsNode(possibleChild.parentNode);\r\n\t}\r\n\r\n\tidentifiesAs(value, cs = false) {\r\n\t\tif (typeof value === 'undefined') return false;\r\n\t\tif (typeof value?.jsonfy === 'function') {\r\n\t\t\treturn _eq(this.jsonfy({ nodeNames: false }), value.jsonfy({ nodeNames: false }), cs);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * -----------\r\n\t * TRANSFORMATION API\r\n\t * -----------\r\n\t */\r\n\r\n\tstatic morphsTo() { return this; }\r\n\r\n\tclone(options = {}, transformer = null, schemaInference = null) {\r\n\t\tconst resultJson = this.jsonfy(options, transformer, schemaInference);\r\n\t\tconst Classes = [this.constructor].concat(this.constructor.morphsTo());\r\n\t\tconst instance = Classes.reduce((prev, C) => prev || C.fromJSON(resultJson, { dialect: options.toDialect || this.options.dialect }), undefined);\r\n\t\treturn instance;\r\n\t}\r\n\r\n\tdeSugar(transformSpec, options = {}, transformer = null, schemaInference = null) {\r\n\t\toptions = { ...options, deSugar: transformSpec/* overrridingly */ };\r\n\t\treturn this.clone(options, transformer, schemaInference);\r\n\t}\r\n\r\n\ttoDialect(dialect, options = {}, transformer = null, schemaInference = null) {\r\n\t\toptions = { ...options, toDialect: dialect/* overrridingly */ };\r\n\t\treturn this.clone(options, transformer, schemaInference);\r\n\t}\r\n\r\n\t/**\r\n\t * -----------\r\n\t * JSON API\r\n\t * -----------\r\n\t */\r\n\r\n\tstatic get syntaxRules() { return []; }\r\n\r\n\tstatic compileASTSchemaFromSyntaxRules({ dialect = 'postgres' } = {}) {\r\n\t\tif (!this._astSchemaCompileCache) {\r\n\t\t\tthis._astSchemaCompileCache = new Map;\r\n\t\t}\r\n\t\tconst cacheKey = `${this.NODE_NAME}:${dialect}`;\r\n\t\tif (!this._astSchemaCompileCache.has(cacheKey)) {\r\n\t\t\tlet result, syntaxRules = this.syntaxRules, rulesArray = [].concat(syntaxRules);\r\n\t\t\tif (rulesArray.length === 1 && Array.isArray(rulesArray[0].type) && !rulesArray[0].as) {\r\n\t\t\t\tresult = rulesArray[0];\r\n\t\t\t} else {\r\n\t\t\t\tresult = this._compileASTSchemaFromSyntaxRules(syntaxRules, dialect, { trail: [this.NODE_NAME] });\r\n\t\t\t}\r\n\t\t\tthis._astSchemaCompileCache.set(cacheKey, result);\r\n\t\t}\r\n\t\treturn this._astSchemaCompileCache.get(cacheKey);\r\n\t}\r\n\r\n\tstatic _compileASTSchemaFromSyntaxRules(syntaxRules, dialect = 'postgres', { trail = [], schemaSet = new Set([new Map]), assertionTrail = { dependencies: new Set, optional: false, assert: false } } = {}) {\r\n\t\tconst rulesArray = Array.isArray(syntaxRules) ? syntaxRules : [syntaxRules];\r\n\t\tconst newDependencyTrail = new Set(assertionTrail.dependencies);\r\n\t\tconst cloneSchemaSet = (schemaSet) => new Set([...schemaSet].map((sch) => new Map(sch)));\r\n\t\tfor (const [i, rule] of rulesArray.entries()) {\r\n\t\t\tif (rule.dialect && rule.dialect !== dialect) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tconst {\r\n\t\t\t\ttype,\r\n\t\t\t\tas: exposure,\r\n\t\t\t\tif: inference = assertionTrail.inference,\r\n\t\t\t\tvalue,\r\n\t\t\t\tarity,\r\n\t\t\t\tsingletons,\r\n\t\t\t\tmodifier,\r\n\t\t\t\tbooleanfy,\r\n\t\t\t\toptional = assertionTrail.optional,\r\n\t\t\t\tassert = assertionTrail.assert,\r\n\t\t\t\tsyntax,\r\n\t\t\t\tsyntaxes,\r\n\t\t\t\t...rest\r\n\t\t\t} = rule;\r\n\t\t\tconst activeTrail = trail.concat(`${Array.isArray(syntaxRules) ? i : ''}${exposure ? `<${exposure}>` : ''}` || []);\r\n\t\t\tconst activeTrailStr = activeTrail.join('.');\r\n\t\t\tconst unsupportedAttrs = _getUnsupportedRuleAttrs(rest);\r\n\t\t\tif (unsupportedAttrs.length) {\r\n\t\t\t\tthrow new SyntaxError(`[${activeTrailStr}] Unsupported attributes in rule: \"${unsupportedAttrs.join('\", \"')}\".`);\r\n\t\t\t}\r\n\t\t\tconst isTokenRule = typeof type === 'string' && type[0] === type[0].toLowerCase();\r\n\t\t\tif (exposure) {\r\n\t\t\t\t// 1. Validate rule\r\n\t\t\t\tif (!type) throw new SyntaxError(`[${activeTrailStr}] Field rules must have a \"type\" attribute of type string.`);\r\n\t\t\t\tif (syntax || syntaxes) throw new SyntaxError(`[${activeTrailStr}] Field rules (\"${exposure}\") can not have a \"syntax\" or \"syntaxes\" attribute.`);\r\n\t\t\t\tif (exposure === '.') {\r\n\t\t\t\t\tif (!isTokenRule) throw new SyntaxError(`[${activeTrailStr}] Terminal Node rules must be token-typed rules.`);\r\n\t\t\t\t\tif (optional) throw new SyntaxError(`[${activeTrailStr}] Terminal Node rules can not be optional.`);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (modifier) throw new SyntaxError(`[${activeTrailStr}] Only Terminal Node rules can have a \"modifier\" attribute.`);\r\n\t\t\t\t}\r\n\t\t\t\tif (isTokenRule) {\r\n\t\t\t\t\tif (![undefined, null].includes(arity)) throw new SyntaxError(`[${activeTrailStr}] Token rules can not be item-based.`);\r\n\t\t\t\t\tif (!TOK_TYPES[type]) throw new SyntaxError(`[${activeTrailStr}] Unknown token type \"${type}\".`);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (value) throw new SyntaxError(`[${activeTrailStr}] Only token rules can have a \"value\" attribute.`);\r\n\t\t\t\t\tfor (const t of [].concat(type)) {\r\n\t\t\t\t\t\tif (!registry[t]) throw new SyntaxError(`[${activeTrailStr}] Unknown node type \"${t}\".`);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (![undefined, null].includes(arity)) {\r\n\t\t\t\t\t\tif (_isObject(arity)) {\r\n\t\t\t\t\t\t\tconst keys = Object.keys(arity);\r\n\t\t\t\t\t\t\tif (keys.some((k) => !['min', 'max', 'eager'].includes(k) || (typeof arity[k] !== (k === 'eager' ? 'boolean' : 'number')))) {\r\n\t\t\t\t\t\t\t\tthrow new SyntaxError(`Invalid arity object \"{ ${keys.join(', ')} }\" for field \"${exposure}\". Only \"min: <number>\", \"max: <number>\" and \"eager: <bool>\" expected.`);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else if ([].concat(arity).some((a) => typeof a !== 'number')) {\r\n\t\t\t\t\t\t\tthrow new SyntaxError(`[${activeTrailStr}] Invalid arity value \"${[].concat(arity).join(', ')}\" for field \"${exposure}\". Number(s) expected.`);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// 2. Compose schema\r\n\t\t\t\tconst fieldSchema = { rulePath: activeTrailStr, type };\r\n\t\t\t\tif (value) fieldSchema.value = value;\r\n\t\t\t\tif (modifier) fieldSchema.modifier = modifier;\r\n\t\t\t\tif (booleanfy) fieldSchema.booleanfy = booleanfy;\r\n\t\t\t\tif (![undefined, null].includes(arity)) fieldSchema.arity = arity;\r\n\t\t\t\tif (singletons) fieldSchema.singletons = singletons;\r\n\t\t\t\tif (optional) fieldSchema.optional = true;\r\n\t\t\t\tif (assert) fieldSchema.assert = assert;\r\n\t\t\t\tif (inference) fieldSchema.if = inference;\r\n\t\t\t\tif (optional && assertionTrail.dependencies.size) {\r\n\t\t\t\t\tfieldSchema.dependencies = Array.from(assertionTrail.dependencies);\r\n\t\t\t\t}\r\n\t\t\t\t// 3. Expose\r\n\t\t\t\t// Earlier rules have populated schemas\r\n\t\t\t\tfor (const schema of schemaSet) {\r\n\t\t\t\t\tschema.set(exposure, fieldSchema);\r\n\t\t\t\t}\r\n\t\t\t\tif (exposure !== '.' && optional && !rule.optional) {\r\n\t\t\t\t\t// Optional context but rule NOT optional within context\r\n\t\t\t\t\tnewDependencyTrail.add(exposure);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (syntax || syntaxes) {\r\n\t\t\t\tconst newAssertionTrail = {\r\n\t\t\t\t\tdependencies: newDependencyTrail,\r\n\t\t\t\t\toptional,\r\n\t\t\t\t\tassert,\r\n\t\t\t\t\tinference,\r\n\t\t\t\t};\r\n\t\t\t\tif (syntax) {\r\n\t\t\t\t\tschemaSet = this._compileASTSchemaFromSyntaxRules(syntax, dialect, { trail: activeTrail.concat('syntax'), schemaSet, assertionTrail: newAssertionTrail });\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tconst newSchemaSet = new Set;\r\n\t\t\t\tfor (const [j, syntax] of syntaxes.entries()) {\r\n\t\t\t\t\tconst schemaSetClone = cloneSchemaSet(schemaSet);\r\n\t\t\t\t\tconst schemaSetCloneResult = this._compileASTSchemaFromSyntaxRules(syntax, dialect, { trail: activeTrail.concat('syntaxes', j), schemaSet: schemaSetClone, assertionTrail: newAssertionTrail });\r\n\t\t\t\t\tfor (const resultSchema of schemaSetCloneResult) {\r\n\t\t\t\t\t\tnewSchemaSet.add(resultSchema);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tschemaSet = newSchemaSet;\r\n\t\t\t}\r\n\t\t}\r\n\t\tconst schemasArray = Array.from(schemaSet);\r\n\t\tfor (let i = 0; i < schemasArray.length; i++) {\r\n\t\t\tconst schemaA = schemasArray[i];\r\n\t\t\tconst schemaAObj = Object.fromEntries(schemaA);\r\n\t\t\tif (!schemaA.size) {\r\n\t\t\t\tschemaSet.delete(schemaA);\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tfor (let j = i + 1; j < schemasArray.length; j++) {\r\n\t\t\t\tconst schemaB = schemasArray[j];\r\n\t\t\t\tconst schemaBObj = Object.fromEntries(schemaB);\r\n\t\t\t\tif (_eq(schemaAObj, schemaBObj, 'cs', 'rulePath')) {\r\n\t\t\t\t\tschemaSet.delete(schemaB);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn schemaSet;\r\n\t}\r\n\r\n\tstatic fromJSON(inputJson, options = {}, callback = null) {\r\n\r\n\t\t// This runs first: giving \"Expr\" - a polymorphic interface to run\r\n\t\tconst astSchema = this.compileASTSchemaFromSyntaxRules(options);\r\n\t\t// 1. Handle polymorphic interfaces\r\n\t\tif (Array.isArray(astSchema.type)) {\r\n\t\t\tfor (const type of astSchema.type) {\r\n\t\t\t\tconst NodeClass = registry[type];\r\n\t\t\t\tconst result = NodeClass.fromJSON(inputJson, options, callback);\r\n\t\t\t\tif (result) return result;\r\n\t\t\t}\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t// ----------\r\n\t\t// Pre compilation...\r\n\t\t// ----------\r\n\t\t// 1. Handle pre-formed nodes\r\n\t\tif (inputJson instanceof AbstractNode) {\r\n\t\t\tif (inputJson instanceof this) return inputJson;\r\n\t\t\tinputJson = inputJson.jsonfy();\r\n\t\t}\r\n\t\t// 2. Handle typed JSON objects\r\n\t\tif (!_isObject(inputJson)) return;\r\n\t\tlet hardCodedNodeName = null;\r\n\t\tif ('nodeName' in inputJson) {\r\n\t\t\tif (inputJson.nodeName && inputJson.nodeName !== this.NODE_NAME) {\r\n\t\t\t\treturn; // API mismatch\r\n\t\t\t}\r\n\t\t\t({ nodeName: hardCodedNodeName, ...inputJson } = inputJson);\r\n\t\t}\r\n\t\t// ----------\r\n\t\t// Compilation...\r\n\t\t// ----------\r\n\t\t// ...defs first\r\n\t\tlet lastAssertion;\r\n\t\tconst $decideThrow = (message, rulePath = null, assertsGrep = false) => {\r\n\t\t\tif (!hardCodedNodeName && options.assert !== true && !(options.assert instanceof RegExp && options.assert.test(activeTrailStr))) return;\r\n\t\t\tif (rulePath) {\r\n\t\t\t\tmessage = `[${rulePath}] ${message}`;\r\n\t\t\t}\r\n\t\t\tif (assertsGrep) {\r\n\t\t\t\tlastAssertion = message;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tthrow new Error(message);\r\n\t\t};\r\n\t\tconst matchTokenRule = (fieldSchema, fieldJson) => {\r\n\t\t\t// Match any predefined value list\r\n\t\t\tif (fieldSchema.value !== undefined) {\r\n\t\t\t\tconst expectedValue = fieldSchema.booleanfy ? [true, false] : fieldSchema.value;\r\n\t\t\t\treturn [].concat(expectedValue).includes(fieldJson.value);\r\n\t\t\t}\r\n\t\t\t// Match standard\r\n\t\t\treturn TOK_TYPES[fieldSchema.type].match?.(fieldJson, options) !== false;\r\n\t\t}\r\n\t\tconst resolveField = (fieldSchema, fieldValue) => {\r\n\t\t\tfor (const type of [].concat(fieldSchema.type)) {\r\n\t\t\t\tconst isTokenRule = typeof type === 'string' && type[0] === type[0].toLowerCase();\r\n\t\t\t\tif (isTokenRule) {\r\n\t\t\t\t\tif (matchTokenRule(fieldSchema, { value: fieldValue }) === true) return fieldValue;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tconst node = registry[type].fromJSON(fieldValue, { ...options, assert: false });\r\n\t\t\t\t\tif (node) return node;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\tconst acquireField = (resultAST, fieldName, fieldSchema, assertsGrep = false) => {\r\n\t\t\t// 1. Validate dependencies\r\n\t\t\tif (fieldSchema.dependencies?.length) {\r\n\t\t\t\tfor (const depField of fieldSchema.dependencies) {\r\n\t\t\t\t\tif (!(depField in resultAST)) {\r\n\t\t\t\t\t\t$decideThrow(`Missing dependency field \"${depField}\" required by \"${fieldName}\"`, fieldSchema.rulePath, assertsGrep);\r\n\t\t\t\t\t\treturn false; // API mismatch\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (fieldSchema.if && !_inferenceMatch(fieldSchema.if, resultAST, fieldSchema.rulePath)) {\r\n\t\t\t\treturn true; // Much like optional\r\n\t\t\t}\r\n\t\t\t// 2. Acquire entries\r\n\t\t\tif (![undefined, null].includes(fieldSchema.arity)) {\r\n\t\t\t\tif (inputJson[fieldName] === undefined) {\r\n\t\t\t\t\t// Undefined at all or empty\r\n\t\t\t\t\tif (fieldSchema.optional) {\r\n\t\t\t\t\t\tresultAST[fieldName] = undefined; // Show up\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t$decideThrow(`Missing required field \"${fieldName}\"`, fieldSchema.rulePath, assertsGrep);\r\n\t\t\t\t\treturn false; // API mismatch\r\n\t\t\t\t}\r\n\t\t\t\tif (!Array.isArray(inputJson[fieldName])) {\r\n\t\t\t\t\t$decideThrow(`Field \"${fieldName}\" must be an array`, fieldSchema.rulePath, assertsGrep);\r\n\t\t\t\t\treturn false; // Defined but API mismatch\r\n\t\t\t\t}\r\n\t\t\t\tif (fieldSchema.arity !== Infinity) {\r\n\t\t\t\t\tconst count = inputJson[fieldName].length;\r\n\t\t\t\t\tif (_isObject(fieldSchema.arity)) {\r\n\t\t\t\t\t\tif ('min' in fieldSchema.arity && count < fieldSchema.arity.min) {\r\n\t\t\t\t\t\t\t$decideThrow(`A minimum of ${fieldSchema.arity.min} argument(s) expected but got ${count}`, fieldSchema.rulePath, assertsGrep);\r\n\t\t\t\t\t\t\treturn false; // API mismatch\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif ('max' in fieldSchema.arity && count > fieldSchema.arity.max) {\r\n\t\t\t\t\t\t\t$decideThrow(`A maximum of ${fieldSchema.arity.max} argument(s) expected but got ${count}`, fieldSchema.rulePath, assertsGrep);\r\n\t\t\t\t\t\t\treturn false; // API mismatch\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if (![].concat(fieldSchema.arity).includes(count)) {\r\n\t\t\t\t\t\t$decideThrow(`Exactly ${[].concat(fieldSchema.arity).join(' or ')} argument(s) expected but got ${count}`, fieldSchema.rulePath, assertsGrep);\r\n\t\t\t\t\t\treturn false; // API mismatch\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tconst resultArray = inputJson[fieldName].map((entry) => resolveField(fieldSchema, entry)).filter((n) => n !== undefined);\r\n\t\t\t\tconst resultLenth = resultArray.length;\r\n\t\t\t\t// Some items resolved and some didn't?: Raise integrity error\r\n\t\t\t\tif (inputJson[fieldName].length > resultLenth) {\r\n\t\t\t\t\t// If resolution failed for all items...\r\n\t\t\t\t\tif (!resultLenth) {\r\n\t\t\t\t\t\t$decideThrow(`Failed to resolve any argument for \"${fieldName}\"`, fieldSchema.rulePath, assertsGrep);\r\n\t\t\t\t\t\treturn false; // API mismatch\r\n\t\t\t\t\t}\r\n\t\t\t\t\t$decideThrow(`Failed to resolve some arguments for \"${fieldName}\"`, fieldSchema.rulePath, assertsGrep);\r\n\t\t\t\t\treturn false; // API mismatch\r\n\t\t\t\t}\r\n\t\t\t\tif (fieldSchema.singletons) {\r\n\t\t\t\t\tconst havingDuplicate = resultArray.find((e, i) => {\r\n\t\t\t\t\t\treturn resultArray.slice(i + 1).some((_e) => {\r\n\t\t\t\t\t\t\treturn fieldSchema.singletons === 'BY_KEY'\r\n\t\t\t\t\t\t\t\t? _e.identifiesAs?.(e)\r\n\t\t\t\t\t\t\t\t: _e instanceof e.constructor;\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t});\r\n\t\t\t\t\tif (havingDuplicate) {\r\n\t\t\t\t\t\t$decideThrow(`Duplicate entry of type \"${havingDuplicate.constructor.name}\"`, fieldSchema.rulePath, assertsGrep);\r\n\t\t\t\t\t\treturn false; // API mismatch\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tresultAST[fieldName] = resultArray;\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\t// 3. Acquire classic field\r\n\t\t\tif (inputJson[fieldName] === undefined) {\r\n\t\t\t\tif (fieldSchema.optional) {\r\n\t\t\t\t\tresultAST[fieldName] = fieldSchema.booleanfy ? false : undefined; // Optional undefined\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t\t$decideThrow(`Missing required field \"${fieldName}\"`, fieldSchema.rulePath, assertsGrep);\r\n\t\t\t\treturn false; // API mismatch\r\n\t\t\t}\r\n\t\t\tconst result = resolveField(fieldSchema, inputJson[fieldName]);\r\n\t\t\tif (result === undefined) {\r\n\t\t\t\t$decideThrow(`Failed to resolve field \"${fieldName}\"`, fieldSchema.rulePath, assertsGrep);\r\n\t\t\t\treturn false; // API mismatch\r\n\t\t\t}\r\n\t\t\tresultAST[fieldName] = result;\r\n\t\t\treturn true;\r\n\t\t};\r\n\t\t// On to the AST composition based on first match\r\n\t\tpaths_loop: for (const $astSchema of (astSchema instanceof Map ? [astSchema] : astSchema)) {\r\n\t\t\tconst resultAST = Object.create(null);\r\n\t\t\tconst astSchema = new Map($astSchema);\r\n\t\t\tlet $inputJson = inputJson;\r\n\t\t\t// Acquire root AST fields\r\n\t\t\tif (astSchema.has('.')) {\r\n\t\t\t\tconst rootRule = astSchema.get('.');\r\n\t\t\t\tconst tokSchema = TOK_TYPES[rootRule.type];\r\n\t\t\t\t// Transfer relevant attributes from \"inputJson\" to \"resultAST\"\r\n\t\t\t\t// This effectively removes root-token-level attributes from \"inputJson\" before the next step below\r\n\t\t\t\tif ([undefined, null].includes($inputJson.value)) {\r\n\t\t\t\t\tcontinue paths_loop;\r\n\t\t\t\t}\r\n\t\t\t\t({ value: resultAST.value, ...$inputJson } = $inputJson);\r\n\t\t\t\tfor (const attr of Object.keys(tokSchema)) {\r\n\t\t\t\t\tif (typeof tokSchema[attr] === 'function') continue;\r\n\t\t\t\t\tif (attr in $inputJson) {\r\n\t\t\t\t\t\t({ [attr]: resultAST[attr], ...$inputJson } = $inputJson);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (matchTokenRule(rootRule, resultAST) === false) {\r\n\t\t\t\t\tcontinue paths_loop;\r\n\t\t\t\t}\r\n\t\t\t\tastSchema.delete('.');\r\n\t\t\t}\r\n\t\t\t// Acquire other AST fields\r\n\t\t\tfor (const fieldName of new Set(Object.keys($inputJson).concat(...astSchema.keys()))) {\r\n\t\t\t\t// Handle early mismatch\r\n\t\t\t\tif (!astSchema.has(fieldName)) {\r\n\t\t\t\t\tif (inputJson[fieldName] === undefined) {\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcontinue paths_loop; // To next schema; API mismatch\r\n\t\t\t\t}\r\n\t\t\t\tconst fieldSchema = astSchema.get(fieldName);\r\n\t\t\t\tif (acquireField(resultAST, fieldName, fieldSchema, true) === false) {\r\n\t\t\t\t\tcontinue paths_loop; // To next schema; API mismatch\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// Done here. First match!!!\r\n\t\t\tif (typeof callback === 'function') {\r\n\t\t\t\treturn callback(resultAST, options);\r\n\t\t\t}\r\n\t\t\treturn new this(resultAST, options);\r\n\t\t}\r\n\t\t$decideThrow(`Failed to match any schema${lastAssertion ? `. ${lastAssertion}` : ''}`, this.NODE_NAME);\r\n\t}\r\n\r\n\t// -----------\r\n\r\n\ttoJSON() { return this.jsonfy(); }\r\n\r\n\tjsonfy(options = {}, transformer = null, schemaInference = null) {\r\n\r\n\t\tconst jsonfy = (key, value, relevantTransformer) => {\r\n\r\n\t\t\tconst defaultTransform = (options1 = options, childTransformer = relevantTransformer) => {\r\n\t\t\t\tif (Array.isArray(value)) {\r\n\t\t\t\t\treturn value.reduce((entries, value, i) => {\r\n\t\t\t\t\t\tconst result = jsonfy(i, value, childTransformer);\r\n\t\t\t\t\t\tif (result === undefined) return entries;\r\n\t\t\t\t\t\treturn entries.concat(result);\r\n\t\t\t\t\t}, []);\r\n\t\t\t\t}\r\n\t\t\t\tif (value instanceof AbstractNode) {\r\n\t\t\t\t\treturn value.jsonfy(options1, childTransformer, schemaInference);\r\n\t\t\t\t}\r\n\t\t\t\treturn value;\r\n\t\t\t};\r\n\r\n\t\t\tif (value === undefined) return;\r\n\t\t\t\r\n\t\t\tconst result = relevantTransformer\r\n\t\t\t\t? relevantTransformer.transform(value, defaultTransform, key, options)\r\n\t\t\t\t: defaultTransform();\r\n\r\n\t\t\tif (result instanceof AbstractNode) {\r\n\t\t\t\tthrow new Error(`\"jsonfy\" transforms must return plain JSON objects.`);\r\n\t\t\t}\r\n\r\n\t\t\treturn result;\r\n\t\t};\r\n\r\n\t\treturn {\r\n\t\t\t...(options.nodeNames !== false ? { nodeName: this.NODE_NAME } : {}),\r\n\t\t\t...Object.fromEntries(Object.entries(this.#ast).reduce((resultEntries, [fieldName, value]) => {\r\n\r\n\t\t\t\tconst result = jsonfy(fieldName, value, transformer);\r\n\t\t\t\tif (result === undefined) return resultEntries;\r\n\r\n\t\t\t\treturn [...resultEntries, [fieldName, result]];\r\n\t\t\t}, [])),\r\n\t\t};\r\n\t}\r\n\r\n\t/**\r\n\t * -----------\r\n\t * PARSER API\r\n\t * -----------\r\n\t */\r\n\r\n\tstatic async toStream(input, options = {}) {\r\n\t\tconst tokenStream = !(input instanceof TokenStream)\r\n\t\t\t? await TokenStream.create(input, { structured: true, spaces: true, ...options })\r\n\t\t\t: input;\r\n\t\tif (!tokenStream.current() && !tokenStream.done) {\r\n\t\t\tawait tokenStream.next();\r\n\t\t}\r\n\t\treturn tokenStream;\r\n\t}\r\n\r\n\tstatic async parse(input, { left = undefined, minPrecedence = 0, trail = [], ...options } = {}) {\r\n\t\tconst tokenStream = await this.toStream(input, options);\r\n\t\tconst savepoint = tokenStream.savepoint();\r\n\t\tconst syntaxRules = this.syntaxRules;\r\n\t\t// 1. Resolve polymorphic interfaces\r\n\t\tlet result, rulesArray;\r\n\t\tif ((rulesArray = [].concat(syntaxRules)).length === 1 && Array.isArray(rulesArray[0].type) && !rulesArray[0].as) {\r\n\t\t\tif (rulesArray[0].expression) {\r\n\t\t\t\tresult = await this._parseAsExpression(tokenStream, rulesArray[0].type, { left, minPrecedence, trail: trail.concat(this.NODE_NAME), ...options });\r\n\t\t\t} else {\r\n\t\t\t\tresult = await this._parseFromTypes(tokenStream, rulesArray[0].type, { left, minPrecedence, trail: trail.concat(this.NODE_NAME), ...options });\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t// 2. Resolve full syntax rules\r\n\t\t\tconst resultAST = await this._parseFromRules(tokenStream, syntaxRules, { left, minPrecedence, trail: trail.concat(this.NODE_NAME), ...options });\r\n\t\t\tif (resultAST) {\r\n\t\t\t\tresult = new this(resultAST, { ...options, dialect: tokenStream.options.dialect });\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (!result) tokenStream.restore(savepoint);\r\n\t\treturn result;\r\n\t}\r\n\r\n\tstatic async _parseAsExpression(tokenStream, types, { left = undefined, minPrecedence, trail, ...options }) {\r\n\t\tif (left) throw new Error(`TODO`);\r\n\t\tleft = await this._parseFromTypes(tokenStream, types, { minPrecedence, trail, ...options });\r\n\t\twhile (left) {\r\n\t\t\t// Compose binary expressions (e.g., col + 2)\r\n\t\t\tconst operator = await tokenStream.match('operator');\r\n\t\t\tif (!operator || operator.prec < minPrecedence) break;\r\n\t\t\tconst newLeft = await this._parseFromTypes(tokenStream, types, {\r\n\t\t\t\tleft,\r\n\t\t\t\tminPrecedence,\r\n\t\t\t\ttrail,\r\n\t\t\t\t...options\r\n\t\t\t});\r\n\t\t\tif (!newLeft) return left;\r\n\t\t\tleft = newLeft;\r\n\t\t}\r\n\t\treturn left;\r\n\t}\r\n\r\n\tstatic async _parseFromRules(tokenStream, syntaxRules, { left, minPrecedence, trail, ...options }, resultAST = {}) {\r\n\t\tconst rulesArray = Array.isArray(syntaxRules) ? syntaxRules : [syntaxRules];\r\n\t\tlet numSkippedRules_dialectWise = 0;\r\n\t\tlet newMinPrecedence = minPrecedence; // Default being 0\r\n\r\n\t\tfor (const [i, rule] of rulesArray.entries()) {\r\n\t\t\tif (rule.dialect && rule.dialect !== tokenStream.options.dialect) {\r\n\t\t\t\tnumSkippedRules_dialectWise++;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\t// -----\r\n\t\t\t// Rule destructuring...\r\n\t\t\t// -----\r\n\r\n\t\t\tconst {\r\n\t\t\t\trequiredSpacing,\r\n\t\t\t\tpeek,\r\n\t\t\t\ttype, // Usable in combination with \"syntax\", \"syntaxes\" for type === \"*_block\"\r\n\t\t\t\tvalue, // Token value matching\r\n\t\t\t\tsyntax, // Mutually-exclusive with \"syntaxes\" and \"type\" - except for type === \"*_block\"\r\n\t\t\t\tsyntaxes, // Mutually-exclusive with \"syntax\" and \"type\" - except for type === \"*_block\"\r\n\t\t\t\tas: exposure,\r\n\t\t\t\tif: inference,\r\n\t\t\t\tarity,\r\n\t\t\t\toptionalParens,\r\n\t\t\t\tsingletons,\r\n\t\t\t\titemSeparator,\r\n\t\t\t\toptional = false,\r\n\t\t\t\tassert = false,\r\n\t\t\t\tbooleanfy,\r\n\t\t\t\t...rest\r\n\t\t\t} = rule;\r\n\r\n\t\t\tconst activeTrail = trail.concat(`${Array.isArray(syntaxRules) ? i : ''}${exposure ? `<${exposure}>` : ''}` || []);\r\n\t\t\tconst activeTrailStr = activeTrail.join('.');\r\n\t\t\tconst unsupportedAttrs = _getUnsupportedRuleAttrs(rest);\r\n\t\t\tif (unsupportedAttrs.length) {\r\n\t\t\t\tthrow new SyntaxError(`[${activeTrailStr}] Unsupported attributes in rule: \"${unsupportedAttrs.join('\", \"')}\".`);\r\n\t\t\t}\r\n\t\t\tconst isTokenRule = typeof type === 'string' && type[0] === type[0].toLowerCase();\r\n\t\t\tconst supportsLeft = exposure && !isTokenRule && rulesArray[i + 1]?.type === 'operator' || (rulesArray[i + 1]?.type === 'punctuation' && rulesArray[i + 1]?.value === '.');\r\n\t\t\t// -----\r\n\t\t\t// Definitions...\r\n\t\t\t// -----\r\n\t\t\tconst acquireLeft = async () => {\r\n\t\t\t\tif (Array.isArray(peek) && !await peekToken(-1)) return;\r\n\t\t\t\tfor (const name of [].concat(type)) {\r\n\t\t\t\t\tif (left instanceof registry[name]) {\r\n\t\t\t\t\t\tresultAST[exposure] = left;\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn false;\r\n\t\t\t};\r\n\t\t\tconst matchSpacing = () => {\r\n\t\t\t\tconst current = tokenStream.current();\r\n\t\t\t\treturn (\r\n\t\t\t\t\t(requiredSpacing === false && !current?.spaceBefore) ||\r\n\t\t\t\t\t(requiredSpacing === true && current?.spaceBefore) ||\r\n\t\t\t\t\t(requiredSpacing === '\\n' && /\\n/.test(current?.spaceBefore))\r\n\t\t\t\t);\r\n\t\t\t};\r\n\t\t\tconst peekToken = async (adjustBy = 0) => {\r\n\t\t\t\tif (adjustBy) return await tokenStream.match(...[peek[0] + adjustBy, ...peek.slice(1)]);\r\n\t\t\t\treturn await tokenStream.match/*NOTE: not peek()*/(...peek);\r\n\t\t\t};\r\n\t\t\tconst eatToken = async () => {\r\n\t\t\t\tlet op;\r\n\t\t\t\tif ((op = await tokenStream.match('operator')) && op.prec < minPrecedence) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tconst tok = await tokenStream.eat(type, type.endsWith('_block') ? undefined : value);\r\n\t\t\t\tif (tok?.type === 'operator') {\r\n\t\t\t\t\tnewMinPrecedence = tok.prec + (tok.assoc === 'right' ? 0 : 1);\r\n\t\t\t\t}\r\n\t\t\t\treturn tok;\r\n\t\t\t};\r\n\t\t\tconst parseNode = async (activeTokenStream, newMinPrecedence) => {\r\n\t\t\t\tif (Array.isArray(type)) {\r\n\t\t\t\t\treturn await this._parseFromTypes(activeTokenStream, type, { minPrecedence: newMinPrecedence, trail: activeTrail, ...options });\r\n\t\t\t\t}\r\n\t\t\t\tconst NodeClass = registry[type];\r\n\t\t\t\tif (!NodeClass) throw new SyntaxError(`[${activeTrailStr}] Unknown node type <${type}>.`);\r\n\t\t\t\treturn await NodeClass.parse(activeTokenStream, { minPrecedence: newMinPrecedence, trail: activeTrail, ...options });\r\n\t\t\t};\r\n\t\t\tconst $decideThrow = (activeTokenStream, message, tokenStreamPosition = false, forceThrow = false) => {\r\n\t\t\t\tif (!assert && !forceThrow && options.assert !== true && !(options.assert instanceof RegExp && options.assert.test(activeTrailStr))) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tif (tokenStreamPosition) {\r\n\t\t\t\t\tconst current = activeTokenStream.current() || activeTokenStream.previous();\r\n\t\t\t\t\tconst proximityTerm = activeTokenStream.current() ? (tokenStreamPosition === 1 ? ':' : ' near') : ' by';\r\n\t\t\t\t\tmessage += !current ? `${proximityTerm} end of stream` : `${proximityTerm}${typeof current.value === 'string' ? ` \"${current.value}\"` : ''} (${current.type}) at <line ${current.line}, column ${current.column}>`;\r\n\t\t\t\t}\r\n\t\t\t\tthrow new SyntaxError(`[${activeTrailStr}] ${message}.`);\r\n\t\t\t};\r\n\r\n\t\t\t// -----\r\n\t\t\t// Validation...\r\n\t\t\t// -----\r\n\r\n\t\t\tif (type) {\r\n\t\t\t\tif (left) {\r\n\t\t\t\t\tif (!supportsLeft) return;\r\n\t\t\t\t\t// left === false is typically passed from PathMixin()\r\n\t\t\t\t\tif (!await acquireLeft()) return;\r\n\t\t\t\t\tleft = null;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t} else if (left === false && supportsLeft) {\r\n\t\t\t\t\tif (optional) {\r\n\t\t\t\t\t\tleft = null;\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// 2. Exit on any of the following...\r\n\t\t\t// Exit if a certain prop isn't in AST\r\n\t\t\tif (inference && !_inferenceMatch(inference, resultAST, activeTrailStr)) {\r\n\t\t\t\tcontinue; // Much like optional\r\n\t\t\t}\r\n\t\t\t// Exit if spacing doesn't match\r\n\t\t\tif (requiredSpacing !== undefined && !matchSpacing()) {\r\n\t\t\t\t$decideThrow(tokenStream, 'Required spacing mismatch', true);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\t// Exit if look-ahead fails\r\n\t\t\tif (Array.isArray(peek) && !await peekToken()) {\r\n\t\t\t\t$decideThrow(tokenStream, 'Peek failure', true);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// -----\r\n\t\t\t// Parsing...\r\n\t\t\t// -----\r\n\r\n\t\t\t// 1. Terminal node rules...\r\n\t\t\tif (exposure === '.') {\r\n\t\t\t\tif (!type || !isTokenRule) throw new SyntaxError(`[${activeTrailStr}] Terminal node rules must be token-typed rules.`);\r\n\t\t\t\tconst tok = await eatToken();\r\n\t\t\t\tif (!tok) {\r\n\t\t\t\t\t$decideThrow(tokenStream, `Token of type \"${type}\"${value ? ` and value \"${value}\"` : ''} expected but got \"${tokenStream.current()?.type}\"`, true);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tlet _type, line, column, spaceBefore, prec, assoc, resultType, rest;\r\n\t\t\t\t({ type: _type, line, column, spaceBefore, prec, assoc, resultType, ...rest } = tok);\r\n\t\t\t\tObject.assign(resultAST, rest);\r\n\t\t\t\tcontinue; // To next rule\r\n\t\t\t}\r\n\r\n\t\t\t// 2. Block rules... Unwrapped for the next set of evaluation...\r\n\t\t\tlet activeTokenStream = tokenStream;\r\n\t\t\tif (typeof type === 'string' && type.endsWith('_block')) {\r\n\t\t\t\tif (!(activeTokenStream = (await eatToken())?.value)) {\r\n\t\t\t\t\tif (optional) {\r\n\t\t\t\t\t\tcontinue; // To next rule\r\n\t\t\t\t\t}\r\n\t\t\t\t\t$decideThrow(tokenStream, `Token of type \"${type}\" expected but got \"${tokenStream.current()?.type}\"`, true);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tnewMinPrecedence = 0; // IMPORTANT: minPrecedence don't apply to blocks\r\n\t\t\t\tif (!activeTokenStream.current() && !activeTokenStream.done) {\r\n\t\t\t\t\tawait activeTokenStream.next();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// 3. Variadic field rules...\r\n\t\t\tif (![undefined, null].includes(arity)) {\r\n\t\t\t\tif (!exposure) throw new SyntaxError(`[${activeTrailStr}] Multi-argument field rules must have a \"as\" attribute.`);\r\n\t\t\t\tif (!type) throw new SyntaxError(`[${activeTrailStr}] Multi-argument field rules must have a \"type\" attribute.`);\r\n\t\t\t\tif (isTokenRule) throw new SyntaxError(`[${activeTrailStr}] Multi-argument field rules must be node-typed rules.`);\r\n\r\n\t\t\t\tlet entry, entries = [], itemMinPrecedence = newMinPrecedence;\r\n\t\t\t\tif (itemSeparator?.type === 'operator') {\r\n\t\t\t\t\t// Use the binding power of the itemSeparator\r\n\t\t\t\t\tconst relevantOperatorDef = itemSeparator.value && (\r\n\t\t\t\t\t\tactiveTokenStream.options.operators?.classic.get(itemSeparator.value) || activeTokenStream.options.operators?.compound.get(itemSeparator.value)\r\n\t\t\t\t\t);\r\n\t\t\t\t\tif (relevantOperatorDef?.prec) {\r\n\t\t\t\t\t\titemMinPrecedence = relevantOperatorDef?.prec + 1;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\twhile ((entry = await parseNode(activeTokenStream, itemMinPrecedence))) {\r\n\t\t\t\t\tif (singletons) {\r\n\t\t\t\t\t\tconst isDuplicate = singletons === 'BY_KEY'\r\n\t\t\t\t\t\t\t? entries.some((e) => e.identifiesAs?.(entry))\r\n\t\t\t\t\t\t\t: entries.some((e) => e instanceof entry.constructor);\r\n\t\t\t\t\t\tif (isDuplicate) {\r\n\t\t\t\t\t\t\t$decideThrow(activeTokenStream, `Duplicate entry of type \"${entry.constructor.name}\"`, true, true);\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tentries.push(entry);\r\n\t\t\t\t\tif (_isObject(arity) && arity.eager === false && entries.length === arity.max) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (itemSeparator && !await activeTokenStream.eat(\r\n\t\t\t\t\t\titemSeparator.type,\r\n\t\t\t\t\t\titemSeparator.value\r\n\t\t\t\t\t)) break;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (arity !== Infinity) {\r\n\t\t\t\t\tconst count = entries.length;\r\n\t\t\t\t\tif (!count && optional) {\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tconst current = activeTokenStream.current();\r\n\t\t\t\t\tconst currentAsUnexpected = current ? `. Unexpected ${current.type}${typeof current.value === 'string' ? ` \"${current.value}\"` : ''}` : '';\r\n\t\t\t\t\tif (_isObject(arity)) {\r\n\t\t\t\t\t\tif ('min' in arity && count < arity.min) {\r\n\t\t\t\t\t\t\t$decideThrow(activeTokenStream, `A minimum of ${arity.min} argument(s) expected but got ${count}${currentAsUnexpected}`, true);\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif ('max' in arity && count > arity.max) {\r\n\t\t\t\t\t\t\t$decideThrow(activeTokenStream, `A maximum of ${arity.max} argument(s) expected but got ${count}${currentAsUnexpected}`, true);\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if (![].concat(arity).includes(count)) {\r\n\t\t\t\t\t\t$decideThrow(activeTokenStream, `Exactly ${[].concat(arity).join(' or ')} argument(s) expected but got ${count}${currentAsUnexpected}`, true);\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tresultAST[exposure] = entries;\r\n\t\t\t\tcontinue; // To next rule\r\n\t\t\t}\r\n\r\n\t\t\t// 4. Classic rules...\r\n\t\t\tlet result;\r\n\t\t\tif (syntax) {\r\n\t\t\t\tconst savepoint = activeTokenStream.savepoint();\r\n\t\t\t\tresult = await this._parseFromRules(activeTokenStream, syntax, { left, minPrecedence: newMinPrecedence, trail: activeTrail.concat('syntax'), ...options });\r\n\t\t\t\tif (result === undefined) {\r\n\t\t\t\t\tactiveTokenStream.restore(savepoint);\r\n\t\t\t\t} else if (left) {\r\n\t\t\t\t\tleft = null;\r\n\t\t\t\t}\r\n\t\t\t} else if (syntaxes) {\r\n\t\t\t\tfor (const [j, syntax] of syntaxes.entries()) {\r\n\t\t\t\t\tconst savepoint = activeTokenStream.savepoint();\r\n\t\t\t\t\tresult = await this._parseFromRules(activeTokenStream, syntax, { left, minPrecedence: newMinPrecedence, trail: activeTrail.concat('syntaxes', j), ...options });\r\n\t\t\t\t\tif (result === undefined) {\r\n\t\t\t\t\t\tactiveTokenStream.restore(savepoint);\r\n\t\t\t\t\t} else break;\r\n\t\t\t\t}\r\n\t\t\t\tif (result !== undefined && left) {\r\n\t\t\t\t\tleft = null;\r\n\t\t\t\t}\r\n\t\t\t} else if (!(typeof type === 'string' && type.endsWith('_block'))) {\r\n\t\t\t\tresult = isTokenRule\r\n\t\t\t\t\t? (await eatToken())?.value\r\n\t\t\t\t\t: await parseNode(activeTokenStream, newMinPrecedence);\r\n\t\t\t} else if (!type) {\r\n\t\t\t\tthrow new SyntaxError(`[${activeTrailStr}] Rules must have a \"type\", \"syntax\" or \"syntaxes\" attribute.`);\r\n\t\t\t}\r\n\r\n\t\t\tif (result === undefined && !optional) {\r\n\t\t\t\t$decideThrow(activeTokenStream, type ? 'Unexpected token' : null, 1);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif (typeof type === 'string' && type.endsWith('_block')\r\n\t\t\t\t&& !activeTokenStream.done\r\n\t\t\t\t&& activeTokenStream.current()) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif (exposure) {\r\n\t\t\t\tif (booleanfy) {\r\n\t\t\t\t\tresult = result !== undefined;\r\n\t\t\t\t}\r\n\t\t\t\tresultAST[exposure] = result;\r\n\t\t\t} else if (syntax || syntaxes) {\r\n\t\t\t\tObject.assign(resultAST, result);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (numSkippedRules_dialectWise === rulesArray.length) {\r\n\t\t\t// IMPORTANT: Hard-exit to prevent returning a false positive, empty, resultAST\r\n\t\t\treturn;\r\n\t\t}\r\n\t\treturn resultAST;\r\n\t}\r\n\r\n\tstatic async _parseFromTypes(tokenStream, types, { left, minPrecedence, trail, ...options }) {\r\n\t\tfor (const type of types) {\r\n\t\t\tconst isTokenRule = typeof type === 'string' && type[0] === type[0].toLowerCase();\r\n\r\n\t\t\tif (isTokenRule) {\r\n\t\t\t\tif (await tokenStream.match(type)) {\r\n\t\t\t\t\treturn await tokenStream.eat();\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tconst NodeClass = registry[type];\r\n\t\t\t\tif (!NodeClass) throw new SyntaxError(`[${this.NODE_NAME}] Unknown node type \"${type}\".`);\r\n\t\t\t\tconst result = await NodeClass.parse(tokenStream, { left, minPrecedence, trail, ...options });\r\n\t\t\t\tif (result !== undefined) return result;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// -----------\r\n\r\n\ttoString() { return this.stringify(); }\r\n\r\n\tstringify(options = {}) {\r\n\t\t// Main\r\n\t\tconst rendering = this._stringifyFromRules(this.constructor.syntaxRules, { trail: [this.NODE_NAME], ...options });\r\n\t\treturn rendering;\r\n\t}\r\n\r\n\t_stringifyFromRules(syntaxRules, { trail = [], startingIndentLevel = 0, autoLineBreakThreshold = 60, ...options }, renderingStats = null) {\r\n\t\t// Formatters\r\n\t\tconst $space = () => ' ';\r\n\t\tconst $lineBreak = (indentLevel) => {\r\n\t\t\treturn `\\n${(\r\n\t\t\t\toptions.tabSpaces === 4 ? '\\t' : ' '.repeat(options.tabSpaces || 2)\r\n\t\t\t).repeat(indentLevel)}`;\r\n\t\t};\r\n\r\n\t\tconst resultTokens = [];\r\n\t\tconst rulesArray = [].concat(syntaxRules);\r\n\t\tlet numSkippedRules_optionalWise = 0;\r\n\r\n\t\tfor (const [i, rule] of rulesArray.entries()) {\r\n\t\t\tif (rule.dialect && rule.dialect !== this.options.dialect) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\t// -----\r\n\t\t\t// Rule destructuring...\r\n\t\t\t// -----\r\n\r\n\t\t\tconst {\r\n\t\t\t\trequiredSpacing,\r\n\t\t\t\ttype,\r\n\t\t\t\tvalue,\r\n\t\t\t\tbooleanfy,\r\n\t\t\t\tsyntax,\r\n\t\t\t\tsyntaxes,\r\n\t\t\t\tas: exposure,\r\n\t\t\t\tif: inference,\r\n\t\t\t\tarity,\r\n\t\t\t\titemSeparator,\r\n\t\t\t\toptional = false,\r\n\t\t\t\tautoSpacing = requiredSpacing,\r\n\t\t\t\toptionalParens,\r\n\t\t\t\tautoIndent = false,\r\n\t\t\t\tautoIndentAdjust = 0,\r\n\t\t\t} = rule;\r\n\r\n\t\t\tconst activeTrail = trail.concat(`${Array.isArray(syntaxRules) ? i : ''}${exposure ? `<${exposure}>` : ''}` || []);\r\n\t\t\tconst activeTrailStr = activeTrail.join('.');\r\n\t\t\tlet $autoIndent = autoIndent;\r\n\r\n\t\t\tif (inference && !_inferenceMatch(inference, this.#ast, this.NODE_NAME)) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tconst activeOptions = {\r\n\t\t\t\tstartingIndentLevel: startingIndentLevel + (autoIndent ? 1 : 0) + autoIndentAdjust,\r\n\t\t\t\tautoLineBreakThreshold,\r\n\t\t\t\t...options\r\n\t\t\t};\r\n\r\n\t\t\tlet rendering;\r\n\t\t\tif (![undefined, null].includes(arity)) {\r\n\t\t\t\tlet shouldRender = false; // Until we match items to syntax's arity\r\n\r\n\t\t\t\tconst entries = this._get(exposure);\r\n\t\t\t\tconst count = entries?.length || 0;\r\n\r\n\t\t\t\tif (typeof autoIndent === 'number' && count < autoIndent) {\r\n\t\t\t\t\tactiveOptions.startingIndentLevel -= 1;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (entries) {\r\n\t\t\t\t\tif (!(shouldRender = arity === Infinity)) {\r\n\t\t\t\t\t\tif (_isObject(arity)) {\r\n\t\t\t\t\t\t\tshouldRender = (!('min' in arity) || count >= arity.min)\r\n\t\t\t\t\t\t\t\t&& (!('max' in arity) || count <= arity.max);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tshouldRender = [].concat(arity).includes(count)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (shouldRender) {\r\n\t\t\t\t\tconst itemsRendering = entries.map((entry) => entry.stringify(activeOptions));\r\n\t\t\t\t\t$autoIndent = autoIndent === true\r\n\t\t\t\t\t\t|| (typeof autoIndent === 'number' && entries.length >= autoIndent)\r\n\t\t\t\t\t\t|| autoSpacing === '\\n';\r\n\t\t\t\t\t// Determine item spacing...\r\n\t\t\t\t\tconst renderingsStr = itemsRendering.join(' ');\r\n\t\t\t\t\tconst $autoItemSpacing = activeOptions.prettyPrint && $autoIndent && (renderingsStr.length > autoLineBreakThreshold || renderingsStr.includes('\\n'))\r\n\t\t\t\t\t\t? $lineBreak(activeOptions.startingIndentLevel)\r\n\t\t\t\t\t\t: $space();\r\n\t\t\t\t\t// Compose separator\r\n\t\t\t\t\tlet $itemSeparator = itemSeparator ? this._stringifyTerminal(itemSeparator, activeOptions) : '';\r\n\t\t\t\t\tif (/^\\w+$/.test($itemSeparator)) {\r\n\t\t\t\t\t\t$itemSeparator = `${$autoItemSpacing}${$itemSeparator}${$autoItemSpacing}`;\r\n\t\t\t\t\t} else if ($itemSeparator === ';' && activeOptions.prettyPrint) {\r\n\t\t\t\t\t\t$itemSeparator = `${$itemSeparator}\\n${$autoItemSpacing}`;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t$itemSeparator = `${$itemSeparator}${$autoItemSpacing}`;\r\n\t\t\t\t\t}\r\n\t\t\t\t\trendering = itemsRendering.join($itemSeparator);\r\n\t\t\t\t}\r\n\t\t\t} else if (syntax) {\r\n\t\t\t\trendering = this._stringifyFromRules(syntax, { trail: activeTrail.concat('syntax'), ...activeOptions }, renderingStats);\r\n\t\t\t} else if (syntaxes) {\r\n\r\n\t\t\t\tlet highestRenderingScore = -1;\r\n\r\n\t\t\t\tfor (const [j, syntax] of syntaxes.entries()) {\r\n\t\t\t\t\tconst newRenderingStats = { score: 0 };\r\n\t\t\t\t\tconst $rendering = this._stringifyFromRules(syntax, { trail: activeTrail.concat('syntaxes', j), ...activeOptions }, newRenderingStats);\r\n\t\t\t\t\tif (typeof $rendering === 'string' && newRenderingStats.score > highestRenderingScore) {\r\n\t\t\t\t\t\trendering = $rendering;\r\n\t\t\t\t\t\thighestRenderingScore = newRenderingStats.score;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (renderingStats) { renderingStats.score += highestRenderingScore; }\r\n\t\t\t} else {\r\n\t\t\t\tif (exposure) {\r\n\t\t\t\t\tlet fieldValue = this._get(exposure === '.' ? 'value' : exposure);\r\n\t\t\t\t\tconst hasExpectedValue = value !== undefined && value !== null;\r\n\t\t\t\t\tif (hasExpectedValue && booleanfy) {\r\n\t\t\t\t\t\tif (fieldValue === true) {\r\n\t\t\t\t\t\t\tfieldValue = value;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (hasExpectedValue) {\r\n\t\t\t\t\t\tif ([].concat(value).includes(fieldValue)) {\r\n\t\t\t\t\t\t\tif (renderingStats) {\r\n\t\t\t\t\t\t\t\trenderingStats.score++;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tfieldValue = undefined;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (fieldValue !== undefined) {\r\n\t\t\t\t\t\tif (fieldValue instanceof AbstractNode) {\r\n\t\t\t\t\t\t\tfieldValue = fieldValue.stringify(activeOptions);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tconst $rule = exposure === '.'\r\n\t\t\t\t\t\t\t? { ...rule, ...this.#ast }\r\n\t\t\t\t\t\t\t: { ...rule, value: fieldValue };\r\n\t\t\t\t\t\trendering = this._stringifyTerminal($rule, activeOptions);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\t\t\t\t\trendering = this._stringifyTerminal(rule, activeOptions);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// -----\r\n\r\n\t\t\tif (type === 'paren_block' && optionalParens) {\r\n\t\t\t\tif (!rendering?.trim()) {\r\n\t\t\t\t\tif (optionalParens === true || options.pruneOptionalParens) {\r\n\t\t\t\t\t\tif (renderingStats) {\r\n\t\t\t\t\t\t\trenderingStats.score++;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tnumSkippedRules_optionalWise++;\r\n\t\t\t\t\t\tcontinue; // Skip this rule\r\n\t\t\t\t\t}\r\n\t\t\t\t\trendering = '';\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (rendering === undefined) {\r\n\t\t\t\tif (optional) {\r\n\t\t\t\t\tnumSkippedRules_optionalWise++;\r\n\t\t\t\t\tcontinue; // Skip this rule\r\n\t\t\t\t}\r\n\t\t\t\treturn; // Exit whole rule sequence\r\n\t\t\t}\r\n\t\t\tif (exposure && renderingStats) {\r\n\t\t\t\trenderingStats.score++;\r\n\t\t\t}\r\n\r\n\t\t\t// Add \"block\" tags?\r\n\t\t\tlet autoSpaceIgnore = false;\r\n\t\t\tconst hitsAutoLineBreakThreshold = rendering.length > autoLineBreakThreshold || /**/rendering.includes('\\n');\r\n\t\t\tif (typeof type === 'string' && type.endsWith('_block')) {\r\n\t\t\t\tconst blockAutoLineBreakMode = activeOptions.prettyPrint && autoIndent && hitsAutoLineBreakThreshold;\r\n\t\t\t\tconst delims = { brace_block: '{}', bracket_block: '[]', paren_block: '()' }[type];\r\n\r\n\t\t\t\trendering = [\r\n\t\t\t\t\tdelims[0],\r\n\t\t\t\t\tblockAutoLineBreakMode && !/^\\s/.test(rendering) ? $lineBreak(startingIndentLevel + 1) : (delims[0] === '{' ? $space() : ''),\r\n\t\t\t\t\trendering,\r\n\t\t\t\t\tblockAutoLineBreakMode || /^\\s/.test(rendering) ? $lineBreak(startingIndentLevel) : (delims[1] === '}' ? $space() : ''),\r\n\t\t\t\t\tdelims[1],\r\n\t\t\t\t].join('');\r\n\t\t\t} else if (activeOptions.prettyPrint && $autoIndent && (resultTokens.length || hitsAutoLineBreakThreshold) && rendering !== '') {\r\n\r\n\t\t\t\trendering = [\r\n\t\t\t\t\t$lineBreak(startingIndentLevel + (autoSpacing === '\\n' ? 0 : 1)),\r\n\t\t\t\t\trendering,\r\n\t\t\t\t].join('');\r\n\r\n\t\t\t\tautoSpaceIgnore = true;\r\n\t\t\t}\r\n\t\t\t// Space this chunk?\r\n\t\t\tconst precedingTok = resultTokens[resultTokens.length - 1];\r\n\t\t\tif (rendering !== ''\r\n\t\t\t\t&& !autoSpaceIgnore\r\n\t\t\t\t&& resultTokens.length\r\n\t\t\t\t// \"Do\" autoSpacing didnt already end with a space character\r\n\t\t\t\t&& !/\\s$/.test(precedingTok)\r\n\t\t\t\t// \"Force\" autoSpacing if previous token ends as alphanumeric and new token (rendering) starts as alphanumeric\r\n\t\t\t\t&& (Array.isArray(autoSpacing) ? autoSpacing.includes(precedingTok) : autoSpacing !== false)) {\r\n\t\t\t\tif (autoSpacing === '\\n' && activeOptions.prettyPrint) {\r\n\t\t\t\t\tresultTokens.push($lineBreak(startingIndentLevel));\r\n\t\t\t\t} else {\r\n\t\t\t\t\tresultTokens.push($space());\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tresultTokens.push(rendering);\r\n\t\t}\r\n\t\tif (resultTokens.length || numSkippedRules_optionalWise === rulesArray.length) {\r\n\t\t\treturn resultTokens.join('');\r\n\t\t}\r\n\t}\r\n\r\n\t_stringifyTerminal(tok, options = {}) {\r\n\t\tswitch (tok.type) {\r\n\t\t\tcase 'data_type': return this._stringifyDataType(tok, options);\r\n\t\t\tcase 'identifier': return this._stringifyIdentifier(tok, options);\r\n\t\t\tcase 'keyword': return this._stringifyKeyword(tok, options);\r\n\t\t\tcase 'operator': return this._stringifyOperator(tok, options);\r\n\t\t\tcase 'punctuation': return this._stringifyPunctuation(tok, options);\r\n\t\t\tcase 'bind_var': return this._stringifyBindVar(tok, options);\r\n\t\t\tcase 'version_spec': return `@${tok.value}`;\r\n\t\t}\r\n\t\tif (!Array.isArray(tok.type)) {\r\n\t\t\tif (tok.type.endsWith('_literal')) {\r\n\t\t\t\treturn this._stringifyLiteral(tok, options);\r\n\t\t\t}\r\n\t\t\tif (tok.type.endsWith('_var')) {\r\n\t\t\t\treturn this._stringifyVariable(tok, options);\r\n\t\t\t}\r\n\t\t\tif (tok.type.endsWith('_comment')) {\r\n\t\t\t\treturn this._stringifyComment(tok, options);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn String(tok.value);\r\n\t}\r\n\r\n\t_stringifyIdentifier(tok) {\r\n\t\tconst { value } = tok;\r\n\t\tconst delimChars = ['\"'];\r\n\t\t// ------------\r\n\t\t// Resolve from mysqlAnsiQuotes if mysql...\r\n\t\tif (this.options.dialect === 'mysql') {\r\n\t\t\tif (this.options.mysqlAnsiQuotes) {\r\n\t\t\t\tdelimChars.push('`'); // Backticks is ALSO identifier delim\r\n\t\t\t} else {\r\n\t\t\t\tdelimChars.fill('`'); // Backticks is ONLY identifier delim\r\n\t\t\t}\r\n\t\t}\r\n\t\t// Use tok-specified delim if valid\r\n\t\tconst delimChar = delimChars.includes(tok.delim)\r\n\t\t\t? tok.delim // Choose this one\r\n\t\t\t: delimChars[0];\r\n\t\t// ------------\r\n\t\tconst shouldQuote = tok.delim\r\n\t\t\t|| /^\\d/.test(value)\r\n\t\t\t|| !/^(\\*|[\\w]+)$/.test(value);\r\n\t\treturn shouldQuote\r\n\t\t\t? `${delimChar}${String(value || '').replace(new RegExp(delimChar, 'g'), delimChar.repeat(2))}${delimChar}`\r\n\t\t\t: value;\r\n\t}\r\n\r\n\t_stringifyKeyword(tok) { return String(tok.value); }\r\n\r\n\t_stringifyOperator(tok) {\r\n\t\tif (tok.value === ':' && this.#parentNode?.isProperty) {\r\n\t\t\treturn '\\\\:';\r\n\t\t}\r\n\t\treturn String(tok.value);\r\n\t}\r\n\r\n\t_stringifyPunctuation(tok) { return String(tok.value); }\r\n\r\n\t_stringifyDataType(tok) { return String(tok.value); }\r\n\r\n\t_stringifyLiteral(tok, options) {\r\n\t\tconst { value } = tok;\r\n\t\t// ------------\r\n\t\tswitch (tok.type) {\r\n\t\t\tcase 'bit_literal': return this._stringifyBitLiteral(tok, options);\r\n\t\t\tcase 'hex_literal': return this._stringifyHexLiteral(tok, options);\r\n\t\t\tcase 'number_literal': return this._stringifyNumberLiteral(tok, options);\r\n\t\t\tcase 'string_literal': return this._stringifyStringLiteral(tok, options);\r\n\t\t\tcase 'bool_literal': return /^true$/i.test(value + '') ? 'TRUE' : 'FALSE';\r\n\t\t\tcase 'null_literal': return 'NULL';\r\n\t\t}\r\n\t\treturn String(value);\r\n\t}\r\n\r\n\t_stringifyBindVar(tok) {\r\n\t\tconst { value } = tok;\r\n\t\t// ------------\r\n\t\tif (this.options.dialect === 'mysql') {\r\n\t\t\treturn `?`;\r\n\t\t}\r\n\t\treturn `$${value}`;\r\n\t}\r\n\r\n\t_stringifyBitLiteral(tok) {\r\n\t\tconst { value } = tok;\r\n\t\t// ------------\r\n\t\tif (this.options.dialect === 'mysql') {\r\n\t\t\treturn `0b${value}`;\r\n\t\t}\r\n\t\treturn `B'${value}'`;\r\n\t}\r\n\r\n\t_stringifyHexLiteral(tok) {\r\n\t\tconst { value } = tok;\r\n\t\t// ------------\r\n\t\tif (this.options.dialect === 'mysql') {\r\n\t\t\treturn `0x${value}`;\r\n\t\t}\r\n\t\treturn `X'${value}'`;\r\n\t}\r\n\r\n\t_stringifyNumberLiteral(tok) {\r\n\t\tconst { value } = tok;\r\n\t\t// ------------\r\n\t\treturn String(value);\r\n\t}\r\n\r\n\t_stringifyStringLiteral(tok) {\r\n\t\tlet { value } = tok;\r\n\t\tconst delimChars = [\"'\"];\r\n\t\tlet escChar = null;\r\n\t\t// ------------\r\n\t\t// Resolve from dialect...\r\n\t\tif (this.options.dialect === 'postgres' && tok.delim?.startsWith('$')) {\r\n\t\t\tdelimChars.fill(tok.delim); // OVERRIDE\r\n\t\t} else if (this.options.dialect === 'mysql' && !this.options.mysqlAnsiQuotes) {\r\n\t\t\tdelimChars.push('\"'); // Double quotes is ALSO string delim\r\n\t\t}\r\n\t\t// Use tok-specified delim if valid\r\n\t\tconst delimChar = delimChars.includes(tok.delim)\r\n\t\t\t? tok.delim // Choose this one\r\n\t\t\t: delimChars[0];\r\n\t\t// Using backslash escaping?\r\n\t\tif (this.options.dialect === 'mysql' && !this.options.mysqlNoBackslashEscapes\r\n\t\t\t|| this.options.dialect === 'postgres' && tok.modifier === 'E') {\r\n\t\t\tescChar = '\\\\'; // In which case: the delim plus [\\\\\\0\\b\\r\\n\\t\\x1A] are backslashed/encoded\r\n\t\t}\r\n\t\t// ------------\r\n\t\t// Is Postgres dollar-quoted string?\r\n\t\tif (delimChar.length > 1) { // e.g. for $$string$$\r\n\t\t\treturn `${delimChar}${value}${delimChar}`;\r\n\t\t}\r\n\t\tif (!escChar) {\r\n\t\t\tescChar = delimChar;\r\n\t\t} else if (escChar === '\\\\') {\r\n\t\t\tconst defs = {\r\n\t\t\t\t'\\\\': '\\\\\\\\', // from backslash char itself\r\n\t\t\t\t'\\0': '\\\\0', // from NUL byte (ASCII 0)\r\n\t\t\t\t'\\b': '\\\\b', // from backspace (ASCII 8)\r\n\t\t\t\t'\\f': '\\\\f', // from form feed\r\n\t\t\t\t'\\n': '\\\\n', // from newline\r\n\t\t\t\t'\\r': '\\\\r', // from carriage return\r\n\t\t\t\t'\\t': '\\\\t', // from tab\r\n\t\t\t\t'\\v': '\\\\v', // from vertical tab\r\n\t\t\t\t'\\x1A': '\\\\Z' // from ASCII 26 (SUB / Control+Z) - as represented in JS\r\n\t\t\t};\r\n\t\t\tvalue = value.replace(/[\\\\\\0\\b\\r\\n\\t\\x1A]/g, (match) => defs[match]);\r\n\t\t}\r\n\t\tvalue = `${delimChar}${(value || '').replace(new RegExp(delimChar, 'g'), `${escChar}${delimChar}`)}${delimChar}`;\r\n\t\treturn tok.modifier\r\n\t\t\t? `${tok.modifier}${value}`\r\n\t\t\t: value;\r\n\t}\r\n\r\n\t_stringifyVariable(tok) {\r\n\t\tconst { type, value } = tok;\r\n\t\t// ------------\r\n\t\tif (this.options.dialect === 'mysql') {\r\n\t\t\treturn `${type === 'system_var' ? '@@' : '@'}${value}`;\r\n\t\t}\r\n\t\treturn `${this.#parentNode?.isProperty ? '\\\\:' : ':'}${value}`;\r\n\t}\r\n\r\n\t_stringifyComment(tok, options = {}) {\r\n\t\tconst { value } = tok;\r\n\t\t// ------------\r\n\t\tif (tok.type === 'block_comment') {\r\n\t\t\tconst indent = '  '.repeat(options.startingIndentLevel || 0);\r\n\t\t\tconst lines = value.trim().split('\\n').map((line) => line.trim());\r\n\t\t\tconst formatted = [\r\n\t\t\t\t`${indent}/**`,\r\n\t\t\t\t...lines.map((line) => `${indent} * ${line}`),\r\n\t\t\t\t`${indent} */`\r\n\t\t\t];\r\n\t\t\treturn formatted.join('\\n');\r\n\t\t}\r\n\t\t// ------------\r\n\t\tconst delimChars = ['--'];\r\n\t\tif (this.options.dialect === 'mysql') {\r\n\t\t\tdelimChars.push('#');\r\n\t\t}\r\n\t\tconst delimChar = delimChars.includes(tok.delim)\r\n\t\t\t? tok.delim\r\n\t\t\t: delimChars[0];\r\n\t\treturn `${delimChar} ${value}`;\r\n\t}\r\n}\r\n\r\nconst _getUnsupportedRuleAttrs = (rule) => {\r\n\treturn Object.keys(rule).filter((k) => !supportedRuleAttrs.has(k));\r\n};\r\nconst supportedRuleAttrs = new Set([\r\n\t'dialect',\r\n\t// 1. Pretty-printing\r\n\t'autoSpacing',\r\n\t'optionalParens',\r\n\t'autoIndent',\r\n\t'autoIndentAdjust',\r\n\t// 2. Type system: token and node\r\n\t'type',\r\n\t// 2.1 Token matching\r\n\t'value',\r\n\t'delim',\r\n\t'modifier',\r\n\t// 2.2 Compound matching\r\n\t'syntax',\r\n\t'syntaxes',\r\n\t// 3. AST fields\r\n\t'as',\r\n\t'booleanfy',\r\n\t'if',\r\n\t// 4. Variadic fields\r\n\t'arity',\r\n\t'itemSeparator',\r\n\t'singletons',\r\n\t'keyed',\r\n\t// 5. Other attributes\r\n\t'requiredSpacing',\r\n\t'peek',\r\n\t'optional',\r\n\t'assert',\r\n]);\r\n\r\nconst _inferenceMatch = (inference, resultAST, activeTrailStr) => {\r\n\treturn [].concat(inference).some((criteria) => {\r\n\t\tif (_isObject(criteria)) {\r\n\t\t\treturn Object.entries(criteria).every(([key, value]) => {\r\n\t\t\t\tlet exp = true;\r\n\t\t\t\tif (key.startsWith('!')) {\r\n\t\t\t\t\tkey = key.slice(1);\r\n\t\t\t\t\texp = false;\r\n\t\t\t\t}\r\n\t\t\t\treturn (\r\n\t\t\t\t\tArray.isArray(value) ? value.includes(resultAST[key]) : resultAST[key] === value\r\n\t\t\t\t) === exp;\r\n\t\t\t});\r\n\t\t}\r\n\t\tif (typeof criteria !== 'string') throw new SyntaxError(`[${activeTrailStr}] A specifier of type string or object expected in inferenceMatch but got ${criteria === null ? 'null' : `type ${typeof criteria}`}`);\r\n\t\tlet exp = true;\r\n\t\tif (criteria.startsWith('!')) {\r\n\t\t\tcriteria = criteria.slice(1);\r\n\t\t\texp = false;\r\n\t\t}\r\n\t\treturn (![undefined, null, false].includes(resultAST[criteria])) === exp;\r\n\t});\r\n};", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class PGCycleClause extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return {\n            dialect: 'postgres',\n            syntax: [\n                { type: 'keyword', value: 'CYCLE' },\n                {\n                    assert: true,\n                    syntax: [\n                        { type: 'ColumnRef1', as: 'column_names', arity: { min: 1 }, itemSeparator, assert: true, autoIndent: 2 },\n                        { type: 'keyword', value: 'SET' },\n                        { type: 'ColumnRef1', as: 'mark_col_name' },\n                        {\n                            optional: true,\n                            syntax: [\n                                { type: 'keyword', value: 'TO' },\n                                { type: 'Expr', as: 'mark_value' },\n                                { type: 'keyword', value: 'DEFAULT' },\n                                { type: 'Expr', as: 'mark_default' },\n                            ]\n                        },\n                        { type: 'keyword', value: 'USING' },\n                        { type: 'ColumnRef1', as: 'path_col_name' },\n                    ]\n                },\n            ]\n        };\n    }\n\n    /* AST API */\n\n    breadthOrDepthFirst() { return this._get('breadth_or_depth_first'); }\n\n    columnNames() { return this._get('column_names'); }\n\n    markColName() { return this._get('mark_col_name'); }\n\n    markValue() { return this._get('mark_value'); }\n\n    markDefault() { return this._get('mark_default'); }\n\n    pathColName() { return this._get('path_col_name'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class PGSearchClause extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return {\n            dialect: 'postgres',\n            syntax: [\n                { type: 'keyword', value: 'SEARCH' },\n                {\n                    assert: true,\n                    syntax: [\n                        { type: 'keyword', as: 'breadth_or_depth_first', value: ['BREADTH', 'DEPTH'] },\n                        { type: 'keyword', value: 'FIRST' },\n                        { type: 'keyword', value: 'BY' },\n                        { type: 'ColumnRef1', as: 'column_names', arity: { min: 1 }, itemSeparator, assert: true, autoIndent: 2 },\n                        { type: 'keyword', value: 'SET' },\n                        { type: 'ColumnRef1', as: 'seq_col_name' },\n                    ]\n                }\n            ]\n        };\n    }\n\n    /* AST API */\n\n    breadthOrDepthFirst() { return this._get('breadth_or_depth_first'); }\n\n    columnNames() { return this._get('column_names'); }\n\n    seqColName() { return this._get('seq_col_name'); }\n}", "import { AbstractNode } from './AbstractNode.js';\n\nexport const ResultSchemaMixin = (Class) => class extends Class {\n\n\t#result_schema;\n\n\tresultSchema() { return this.#result_schema; }\n\n\tstatic fromJSON(inputJson, options = {}, callback = null) {\n\t\tif (!inputJson || inputJson instanceof AbstractNode) {\n\t\t\treturn super.fromJSON(inputJson, options, callback);\n\t\t}\n\t\tconst { result_schema, ...restJson } = inputJson;\n\t\tconst instance = super.fromJSON(restJson, options, callback);\n\t\tif (instance && result_schema) {\n\t\t\tif (!(result_schema instanceof AbstractNode)) {\n\t\t\t\tthrow new Error(`Invalid Schema object passed at inputJson.result_schema`);\n\t\t\t}\n\t\t\tinstance.#result_schema = result_schema;\n\t\t}\n\t\treturn instance;\n\t}\n\n\tjsonfy(options = {}, transformer = null, schemaInference = null) {\n\t\tlet resultJson = super.jsonfy(options, transformer, schemaInference);\n\t\tif (this.#result_schema && options.resultSchemas !== false) {\n\t\t\tresultJson = {\n\t\t\t\t...resultJson,\n\t\t\t\tresult_schema: this.#result_schema,\n\t\t\t};\n\t\t}\n\t\treturn resultJson;\n\t}\n}", "import { AbstractNode } from './AbstractNode.js';\nimport { registry } from '../registry.js';\n\nexport const OriginSchemasMixin = (Class) => class extends Class {\n\n\t#origin_schemas;\n\n\toriginSchemas() { return this.#origin_schemas; }\n\n\tstatic fromJSON(inputJson, options = {}, callback = null) {\n\t\tif (!inputJson || inputJson instanceof AbstractNode) {\n\t\t\treturn super.fromJSON(inputJson, options, callback);\n\t\t}\n\t\tconst { origin_schemas, ...restJson } = inputJson;\n\t\tconst instance = super.fromJSON(restJson, options, callback);\n\t\tif (instance && origin_schemas) {\n\t\t\tif (!Array.isArray(origin_schemas)) {\n\t\t\t\tthrow new Error(`Invalid list passed at inputJson.origin_schemas`);\n\t\t\t}\n\t\t\tinstance.#origin_schemas = origin_schemas;\n\t\t}\n\t\treturn instance;\n\t}\n\n\tjsonfy(options = {}, transformer = null, schemaInference = null) {\n\t\tlet resultJson = super.jsonfy(options, transformer, schemaInference);\n\t\tif (this.#origin_schemas && options.originSchemas !== false) {\n\t\t\tresultJson = {\n\t\t\t\t...resultJson,\n\t\t\t\torigin_schemas: this.#origin_schemas,\n\t\t\t};\n\t\t}\n\t\treturn resultJson;\n\t}\n\n\tgetOriginSchemas(transformer) {\n\t\tconst originSchemas = [];\n\t\tlet foundJSONSchema = false;\n\t\tfor (const { resultSchema } of transformer.statementContext.artifacts.get('tableSchemas')) {\n\t\t\tif (resultSchema instanceof registry.JSONSchema) {\n\t\t\t\tif (foundJSONSchema) {\n\t\t\t\t\t// Not expect; not valid SQL; but however\n\t\t\t\t\tthrow new Error(`Multiple anonymous origin schemas detected`);\n\t\t\t\t}\n\t\t\t\tfoundJSONSchema = true;\n\t\t\t}\n\t\t\toriginSchemas.push(resultSchema);\n\t\t}\n\t\treturn originSchemas;\n\t}\n}", "import { AbstractNode } from './AbstractNode.js';\n\nexport class AbstractStmt extends AbstractNode {\n    \n    get statementNode() { return this; }\n\n    /* JSON API */\n\n\t#uuid;\n\n    get uuid() {\n        if (!this.#uuid) {\n            this.#uuid = `$query${(0 | Math.random() * 9e6).toString(36)}`;\n        }\n        return this.#uuid;\n    }\n\n\tstatic fromJSON(inputJson, options = {}, callback = null) {\n\t\tif (inputJson instanceof AbstractNode) {\n\t\t\treturn super.fromJSON(inputJson, options, callback);\n\t\t}\n\t\tconst { uuid, ...restJson } = inputJson;\n\t\tconst instance = super.fromJSON(restJson, options, callback);\n\t\tif (instance) {\n\t\t\tinstance.#uuid = uuid;\n\t\t}\n\t\treturn instance;\n\t}\n\n\tjsonfy(options = {}, transformer = null, schemaInference = null) {\n\t\tlet resultJson = super.jsonfy(options, transformer, schemaInference);\n\t\tif (this.#uuid) {\n\t\t\tresultJson = {\n\t\t\t\tuuid: this.#uuid,\n\t\t\t\t...resultJson,\n\t\t\t};\n\t\t}\n\t\treturn resultJson;\n\t}\n}", "import { ResultSchemaMixin } from './ResultSchemaMixin.js';\r\nimport { OriginSchemasMixin } from '../abstracts/OriginSchemasMixin.js';\r\nimport { AbstractStmt } from './AbstractStmt.js';\r\n\r\nexport class AbstractNonDDLStmt extends ResultSchemaMixin(OriginSchemasMixin(AbstractStmt)) {\r\n\r\n\trenderBindings(values) {\r\n\t\tif (!Array.isArray(values)) throw new Error(`Values must be an array`);\r\n\t\tconst queryBindings = [...this.queryBindings()];\r\n\t\tfor (let i = 0; i < values.length; i++) {\r\n\t\t\tconst bindings = queryBindings.filter(b => b.offset() === i+1);\r\n\t\t\tif (!bindings.length) throw new Error(`No bindings exists at offset #${i}`);\r\n\t\t\tbindings.forEach(b => b.value(values[i]));\r\n\t\t}\r\n\t}\r\n\r\n\tnormalizeBindings(dedupe = false) {\r\n\t\tconst queryBindings = [...this.queryBindings()];\r\n\t\tif (!dedupe) {\r\n\t\t\tqueryBindings.forEach((b, i) => b.offset(i+1));\r\n\t\t\treturn queryBindings;\r\n\t\t}\r\n\t\tlet redundants = new Map, $offset = 1;\r\n\t\tfor (const b of queryBindings) {\r\n\t\t\tif (b.offset() === 0 || !redundants.has(b.offset())) {\r\n\t\t\t\tconst newOffset = $offset++;\r\n\t\t\t\tredundants.set(b.offset(), newOffset);\r\n\t\t\t\tb.offset(newOffset);\r\n\t\t\t} else b.offset(redundants.get(b.offset())).withDetail('redundant', true);\r\n\t\t}\r\n\t\treturn queryBindings.filter(b => !b.getDetail('redundant'));\r\n\t}\r\n}\r\n", "import { registry } from './registry.js';\n\nexport class Transformer {\n\n    #callback;\n    get cb() { return this.#callback; }\n\n    #rands = new Map;\n    #hashes = new Map;\n\n    #parentTransformer;\n    get parentTransformer() { return this.#parentTransformer; }\n\n    #statementNode;\n    get statementNode() { return this.#statementNode; }\n\n    get statementContext() {\n        if (this.#isStatementContext) return this;\n        return this.#parentTransformer.statementContext;\n    }\n\n    get rootContext() {\n        return this.#parentTransformer?.rootContext || this;\n    }\n\n    #isStatementContext;\n    get isStatementContext() { return this.#isStatementContext; }\n\n    #artifacts = new Map([\n        ['outputSchemas', new Set],\n        ['tableSchemas', new Set],\n        ['selectorDimensions', new Map],\n        ['payloadDimensions', new Set],\n    ]);\n    get artifacts() { return this.#artifacts; }\n\n    constructor(callback, parentTransformer = null, statementNode = null) {\n        this.#callback = callback;\n        this.#parentTransformer = parentTransformer;\n        this.#statementNode = statementNode;\n        this.#isStatementContext = !parentTransformer\n            || statementNode !== parentTransformer.statementNode;\n    }\n\n    rand(type, { asSalt = false, rands = this.#rands } = {}) {\n        rands.set(type, !rands.has(type) ? 0 : rands.get(type) + 1);\n        return `${asSalt ? '~' : '$'}${type}~${rands.get(type)}`;\n    }\n\n    hash(value, type, { hashes = this.#hashes } = {}) {\n        if (!hashes.has(value)) {\n            hashes.set(value, this.rand(type));\n        }\n        return hashes.get(value);\n    }\n\n    transform(node, defaultTransform, key, options0, originatingContext = this) {\n\n        const $defaultTransform = (options1 = options0, childTransformer = originatingContext) => {\n\n            // From parentTransformer:\n            // implicitly inherit current instance for sub-transforms\n            if (typeof options1 === 'function') {\n                childTransformer = new Transformer(options1, childTransformer, this.#statementNode);\n                options1 = options0;\n            }\n\n            // If this.transform() was called from a subquery scope identified by originatingContext\n            if (originatingContext.statementNode !== this.#statementNode) {\n                // don't call handlers in this scope\n                return defaultTransform(options1, childTransformer);\n            }\n\n            return this.#callback(node, (options2 = options1) => {\n\n                // From callback:\n                // implicitly inherit current instance for sub-transforms\n                if (typeof options2 === 'function') {\n                    childTransformer = new Transformer(options2, childTransformer, this.#statementNode);\n                    options2 = options1;\n                }\n\n                return defaultTransform(options2, childTransformer);\n            }, key, options1);\n        };\n\n        if (this.#parentTransformer) {\n            // Call parentTransformer and pass originating scope\n            return this.#parentTransformer.transform(node, $defaultTransform, key, options0, originatingContext);\n        }\n\n        return $defaultTransform();\n    }\n}", "import { AbstractNonDDLStmt } from '../abstracts/AbstractNonDDLStmt.js';\nimport { Transformer } from '../Transformer.js';\nimport { registry } from '../registry.js';\n\nexport class CTE extends AbstractNonDDLStmt {\n\n    /* SYNTAX RULES */\n\n    static get _bodyTypes() {\n        return [\n            'SelectStmt',\n            'TableStmt',\n            'InsertStmt',\n            'UpsertStmt',\n            'UpdateStmt',\n            'DeleteStmt',\n            'ValuesConstructor',\n        ];\n    }\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'keyword', value: 'WITH' },\n            { type: 'keyword', as: 'recursive', value: 'RECURSIVE', booleanfy: true, optional: true },\n            { type: 'CTEItem', as: 'declarations', arity: { min: 1 }, itemSeparator, assert: true, autoIndent: 2 },\n            { type: this._bodyTypes, as: 'body', assert: true, autoSpacing: '\\n' },\n        ];\n    }\n\n    /* AST API */\n\n    recursive() { return this._get('recursive'); }\n\n    declarations() { return this._get('declarations'); }\n\n    body() { return this._get('body'); }\n\n    /* JSON API */\n\n    jsonfy(options = {}, transformer = null, schemaInference = null) {\n        if (!options.deSugar) return super.jsonfy(options, transformer, schemaInference);\n\n        let outerResultSchema;\n\n        transformer = new Transformer((node, defaultTransform, keyHint) => {\n            // Process body nodes\n            if (keyHint === 'body' && node.parentNode === this) {\n                const bodyResultJson = defaultTransform();\n\n                outerResultSchema = bodyResultJson.result_schema;\n\n                return bodyResultJson;\n            }\n\n            return defaultTransform();\n        }, transformer, this);\n\n        // Run transform\n        const resultJson = super.jsonfy(options, transformer, schemaInference);\n        return {\n            ...resultJson,\n            result_schema: outerResultSchema,\n        };\n    }\n}", "import { AbstractNonDDLStmt } from '../abstracts/AbstractNonDDLStmt.js';\nimport { Transformer } from '../Transformer.js';\nimport { registry } from '../registry.js';\n\nexport class CTEItem extends AbstractNonDDLStmt {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'CTEItemAlias', as: 'alias', assert: true },\n            { type: 'keyword', value: 'AS' },\n            {\n                optional: true,\n                dialect: 'postgres',\n                syntaxes: [\n                    [\n                        { type: 'operator', as: 'not_materialized_kw', value: 'NOT', booleanfy: true },\n                        { type: 'keyword', value: 'MATERIALIZED', assert: true },\n                    ],\n                    { type: 'keyword', as: 'materialized', value: 'MATERIALIZED', booleanfy: true },\n                ],\n            },\n            {\n                type: 'paren_block',\n                syntax: { type: ['SelectStmt', 'InsertStmt', 'UpsertStmt', 'UpdateStmt', 'DeleteStmt', 'TableStmt', 'ValuesConstructor'], as: 'expr', autoIndent: true },\n            },\n            { type: 'PGSearchClause', as: 'search_clause', optional: true },\n            { type: 'PGCycleClause', as: 'cycle_clause', optional: true },\n        ];\n    }\n\n    /* AST API */\n\n    alias() { return this._get('alias'); }\n\n    notMaterializedKW() { return this._get('not_materialized_kw'); }\n\n    materialized() { return this._get('materialized'); }\n\n    expr() { return this._get('expr'); }\n\n    searchClause() { return this._get('search_clause'); }\n\n    cycleClause() { return this._get('cycle_clause'); }\n\n    /* JSON API */\n\n    jsonfy(options = {}, transformer = null, schemaInference = null) {\n        let resultJson = super.jsonfy(options, transformer, schemaInference);\n        if (options.deSugar) {\n\n            const schemaIdent = {\n                nodeName: registry.Identifier.NODE_NAME,\n                value: resultJson.alias.value,\n                delim: resultJson.alias.delim,\n            };\n\n            let resultSchema = resultJson.expr.result_schema;\n\n            if (resultSchema instanceof registry.TableSchema) {\n                resultSchema = resultSchema.clone({ renameTo: schemaIdent });\n            } else {\n                resultSchema = registry.TableSchema.fromJSON({\n                    name: schemaIdent,\n                    entries: resultSchema?.entries().map((s) => s.jsonfy()) || [],\n                });\n            }\n\n            if (resultJson.alias.columns?.length) {\n                if (resultJson.alias.columns.length !== resultSchema.length) {\n                    throw new SyntaxError(`[${this}] Number of column aliases must match number of result columns.`);\n                }\n                resultSchema = resultSchema.clone({}, new Transformer((node, defaultTransform, key) => {\n                    if (typeof key === 'number' && node.parentNode === resultSchema) {\n                        if (node instanceof registry.ColumnSchema) {\n                            return node.jsonfy({ renameTo: resultJson.alias.columns[key] });\n                        }\n                        return {\n                            ...node.jsonfy(),\n                            nodeName: registry.ColumnSchema.NODE_NAME,\n                            name: resultJson.alias.columns[key],\n                        };\n                    }\n                    return defaultTransform();\n                }));\n            }\n\n            transformer.statementContext.artifacts.get('tableSchemas').add({ type: 'CTEItem', resultSchema });\n\n            resultJson = {\n                ...resultJson,\n                result_schema: resultSchema,\n            };\n        }\n\n        return resultJson;\n    }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\nimport { _eq } from '../../abstracts/util.js';\n\nexport class Identifier extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() { return { type: 'identifier', as: '.' }; }\n\n    static get syntaxPriority() { return -1; }\n\n    /* AST API */\n\n    value() { return this._get('value'); }\n\n    /* API */\n\n    identifiesAs(ident, cs = undefined) {\n        if (ident instanceof Identifier) {\n\t\t\treturn _eq(this.value(), ident.value(), cs === undefined ? (this._has('delim') || ident._has('delim')) : cs);\n\t\t}\n        if (typeof ident === 'string') {\n            return _eq(this._get('value'), ident, cs === undefined ? this._has('delim') : cs);\n        }\n        return super.identifiesAs(ident, cs);\n    }\n}", "import { Identifier } from '../expr/ref/Identifier.js';\n\nexport class CTEItemAlias extends Identifier {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { ...[].concat(super.syntaxRules)[0] },\n            {\n                type: 'paren_block',\n                syntax: { type: 'Identifier', as: 'columns', arity: { min: 1 }, itemSeparator, assert: true },\n                if: 'value',\n                optional: true,\n                optionalParens: true,\n            }\n        ];\n    }\n\n    /* AST API */\n\n    columns() { return this._get('columns'); }\n}", "export * from './column/index.js';\nexport * from './constraint/index.js';\nexport * from './ident/index.js';\nexport * from './index/index.js';\nexport * from './schema/index.js';\nexport * from './table/index.js';\nexport { CreateSchemaStmt } from './CreateSchemaStmt.js';\nexport { DropSchemaStmt } from './DropSchemaStmt.js';\nexport { CreateTableStmt } from './CreateTableStmt.js';\nexport { DropTableStmt } from './DropTableStmt.js';\nexport { DDLStmt } from './DDLStmt.js'\n", "import { AbstractNode } from './AbstractNode.js';\n\nexport class AbstractNodeList extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() { return []; }\n\n    // API\n\n    get length() { return (this._get('entries') || []).length; }\n\n    [Symbol.iterator]() { return (this._get('entries') || [])[Symbol.iterator](); }\n\n    ['entries']() { return (this._get('entries') || []).slice(0); }\n\n    delete(index) { return this._delete('entries', index); }\n\n    get(index) { return this._get('entries', index); }\n\n    set(index, value) { return this._set('entries', index, value); }\n\n    has(index) { return this._has('entries', index); }\n\n    add(...args) { return this._add('entries', ...args); }\n}", "import { AbstractNodeList } from './AbstractNodeList.js';\n\nexport class AbstractDiff extends AbstractNodeList {\n\n    /* AST API */\n}", "import { AbstractDiff } from '../../abstracts/AbstractDiff.js';\n\nexport class ColumnDiff extends AbstractDiff {}", "import { AbstractNodeList } from './AbstractNodeList.js';\nimport { AbstractNode } from './AbstractNode.js';\nimport { registry } from '../registry.js';\n\nexport class AbstractSchema extends AbstractNodeList {\n\n    /* AST API */\n\n    name() { return this._get('name'); }\n\n    /* API */\n\n    identifiesAs(value, ...args) {\n        return this.name()?.identifiesAs(\n            value instanceof AbstractSchema ? value.name() : value,\n            ...args\n        );\n    }\n\n    /* JSON API */\n\n    static fromJSON(inputJson, options = {}, callback = null) {\n        if (inputJson instanceof AbstractNode) {\n            return super.fromJSON(inputJson, options, callback);\n        }\n        const { ddl_name, ...restJson } = inputJson;\n        const node = super.fromJSON(restJson, options, callback);\n        if (ddl_name && node) {\n            const iddlNameIdent = [registry.SchemaIdent, registry.TableIdent, registry.ColumnIdent].reduce((prev, Class) => prev || Class.fromJSON(ddl_name), null);\n            node._set('ddl_name', iddlNameIdent);\n        }\n        return node;\n    }\n\n    jsonfy({ renameTo, ...options } = {}, transformer = null, schemaInference = null) {\n        let resultJson = super.jsonfy(options, transformer, schemaInference);\n        if (renameTo) {\n            if (renameTo instanceof AbstractNode) {\n                throw new Error(`options.renameTo must be a JSON value.`);\n            }\n            if (resultJson.name?.value && !resultJson.ddl_name) {\n                resultJson = { ...resultJson, ddl_name: resultJson.name };\n            }\n            return { ...resultJson, name: renameTo };\n        }\n        return resultJson;\n    }\n}", "import { AbstractSchema } from '../../abstracts/AbstractSchema.js';\nimport { registry } from '../../registry.js';\n\nexport class ColumnSchema extends AbstractSchema {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const type = [\n            'CheckConstraint',\n            'ColumnDefaultConstraint',\n            'ColumnExpressionConstraint',\n            'ColumnFKConstraint',\n            'ColumnIdentityConstraint',\n            'ColumnNullConstraint',\n            'ColumnPKConstraint',\n            'ColumnUKConstraint',\n            'MYColumnAutoIncrementModifier',\n            'MYColumnCommentModifier',\n            'MYColumnOnUpdateModifier',\n            'MYColumnVisibilityModifier',\n        ];\n        return [\n            { type: ['ColumnIdent', 'Identifier'/* to support mock names */], as: 'name' },\n            { type: 'DataType', as: 'data_type'/*, assert: true (SRFExprDDL1 needs to be able to check out)*/ },\n            { type, as: 'entries', arity: Infinity, singletons: true, optional: true },\n\n        ];\n    }\n\n    /* AST API */\n\n    dataType() { return this._get('data_type'); }\n\n    /* API */\n\n    defaultConstraint() {\n        for (const cons of this) {\n            if (cons instanceof registry.ColumnDefaultConstraint) return cons;\n        }\n    }\n\n    expressionConstraint() {\n        for (const cons of this) {\n            if (cons instanceof registry.ColumnExpressionConstraint) return cons;\n        }\n    }\n\n    identityConstraint() {\n        for (const cons of this) {\n            if (cons instanceof registry.ColumnIdentityConstraint) return cons;\n        }\n    }\n\n    autoIncrementConstraint() {\n        for (const cons of this) {\n            if (cons instanceof registry.MYColumnAutoIncrementModifier) return cons;\n        }\n    }\n\n    nullConstraint() {\n        for (const cons of this) {\n            if (cons instanceof registry.ColumnNullConstraint) return cons;\n        }\n    }\n\n    pkConstraint(normalized = false) {\n        for (const cons of this) {\n            if (cons instanceof registry.ColumnPKConstraint) return cons;\n        }\n        if (normalized && this.parentNode instanceof registry.TableSchema) {\n            const pkConstraint = this.parentNode.pkConstraint(false);\n            const pkColumns = pkConstraint?.columns() || [];\n            if (pkColumns.length === 1 && pkColumns[0].identifiesAs(this.name())) {\n                const { nodeName, columns, ...cJson } = pkConstraint.jsonfy();\n                const instance = registry.ColumnPKConstraint.fromJSON(cJson);\n                this._adoptNodes(instance);\n                return instance;\n            }\n        }\n    }\n\n    fkConstraint(normalized = false) {\n        for (const cons of this) {\n            if (cons instanceof registry.ColumnFKConstraint) return cons;\n        }\n        if (normalized && this.parentNode instanceof registry.TableSchema) {\n            const { nodeName, columns, ...cJson } = this.parentNode.fkConstraints(false).find((c) => {\n                const columns = c.columns();\n                return columns.length === 1 && columns[0].identifiesAs(this.name());\n            })?.jsonfy() || {};\n            if (nodeName) {\n                const instance = registry.ColumnFKConstraint.fromJSON(cJson);\n                this._adoptNodes(instance);\n                return instance;\n            }\n        }\n    }\n\n    ukConstraint(normalized = false) {\n        for (const cons of this) {\n            if (cons instanceof registry.ColumnUKConstraint) return cons;\n        }\n        if (normalized && this.parentNode instanceof registry.TableSchema) {\n            const { nodeName, columns, ...cJson } = this.parentNode.ukConstraints(false).find((c) => {\n                const columns = c.columns();\n                return columns.length === 1 && columns[0].identifiesAs(this.name());\n            })?.jsonfy() || {};\n            if (nodeName) {\n                const instance = registry.ColumnUKConstraint.fromJSON(cJson);\n                this._adoptNodes(instance);\n                return instance;\n            }\n        }\n    }\n\n    ckConstraint(normalized = false) {\n        for (const cons of this) {\n            if (cons instanceof registry.CheckConstraint) return cons;\n        }\n        if (normalized && this.parentNode instanceof registry.TableSchema) {\n            let instance = this.parentNode.ckConstraints(false).find((c) => {\n                const columns = c.columns();\n                return columns.length === 1 && columns[0].identifiesAs(this.name());\n            });\n            if (instance = instance?.clone()) {\n                this._adoptNodes(instance);\n                return instance;\n            }\n        }\n    }\n\n    jsonfy({ normalized = false, ...options } = {}, transformer = null, schemaInference = null) {\n        let resultJson = super.jsonfy(options, transformer, schemaInference);\n        if (normalized) {\n            let tableLevelConstraints = [];\n            for (const x of ['pk', 'fk', 'uk', 'ck']) {\n                const method = `${x}Constraint`;\n                if (!this[method]()) {\n                    tableLevelConstraints.push(this[method](true)?.jsonfy());\n                }\n            }\n            if ((tableLevelConstraints = tableLevelConstraints.filter((s) => s)).length) {\n                return {\n                    ...resultJson,\n                    entries: resultJson.entries.concat(tableLevelConstraints)\n                }\n            }\n        }\n        return resultJson;\n    }\n}\n", "import { AbstractNode } from '../../../abstracts/AbstractNode.js';\n\nexport class FKMatchRule extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', value: 'MATCH' },\n            { type: 'keyword', as: 'value', value: ['FULL', 'PARTIAL', 'SIMPLE'], assert: true },\n        ];\n    }\n\n    /*. AST API */\n\n    value() { return this._get('value'); }\n}", "import { AbstractNode } from '../../../abstracts/AbstractNode.js';\n\nexport class FKDeleteRule extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', value: 'ON' },\n            { type: 'keyword', value: 'DELETE' },\n            { type: 'ReferentialAction', as: 'action', assert: true },\n        ];\n    }\n\n    /*. AST API */\n\n    action() { return this._get('action'); }\n}", "import { AbstractNode } from '../../../abstracts/AbstractNode.js';\n\nexport class FKUpdateRule extends AbstractNode {\n    \n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', value: 'ON' },\n            { type: 'keyword', value: 'UPDATE' },\n            { type: 'ReferentialAction', as: 'action', assert: true },\n        ];\n    }\n\n    /*. AST API */\n\n    action() { return this._get('action'); }\n}", "import { AbstractNodeList } from '../../../abstracts/AbstractNodeList.js';\n\nexport class PGIndexParameters extends AbstractNodeList {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: ['PGIndexParamInclude', 'PGIndexParamUsing', 'PGIndexParamWith'], as: 'entries', arity: Infinity, singletons: true },\n        ];\n    }\n}", "import { AbstractNodeList } from '../../../abstracts/AbstractNodeList.js';\n\nexport class PGIndexParamInclude extends AbstractNodeList {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'keyword', value: 'INCLUDE' },\n            {\n                type: 'paren_block',\n                syntax: { type: 'ColumnRef2', as: 'entries', arity: { min: 1 }, itemSeparator },\n            }\n        ];\n    }\n}", "import { AbstractNode } from '../../../abstracts/AbstractNode.js';\n\nexport class PGIndexParamUsing extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', value: 'USING' },\n            { type: 'keyword', value: 'INDEX' },\n            { type: 'keyword', value: 'TABLESPACE' },\n            { type: 'identifier', as: '.' },\n        ];\n    }\n}", "import { AbstractNodeList } from '../../../abstracts/AbstractNodeList.js';\n\nexport class PGIndexParamWith extends AbstractNodeList {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'keyword', value: 'WITH' },\n            {\n                type: 'paren_block',\n                syntax: { type: 'ConfigAssignmentExprAlt2', as: 'entries', arity: { min: 1 }, itemSeparator },\n            }\n        ];\n    }\n}", "import { AbstractSchema } from '../../abstracts/AbstractSchema.js';\nimport { registry } from '../../registry.js';\n\nexport class ConstraintSchema extends AbstractSchema {\n\n    /* SYNTAX RULES */\n\n    static buildSyntaxRules(rules) {\n        return [\n            {\n                optional: true,\n                syntax: [\n                    { type: 'keyword', value: 'CONSTRAINT' },\n                    { type: 'Identifier', as: 'name', assert: true },\n                ]\n            },\n            ...\n            rules,\n            {\n                optional: true,\n                dialect: 'postgres',\n                syntaxes: [\n                    [\n                        { type: 'operator', as: 'pg_deferrable', value: 'NOT' },\n                        { type: 'keyword', value: 'DEFERRABLE' },\n                    ],\n                    { type: 'keyword', as: 'pg_deferrable', value: 'DEFERRABLE' },\n                ],\n            },\n            {\n                optional: true,\n                dialect: 'postgres',\n                syntax: [\n                    { type: 'keyword', value: 'INITIALLY' },\n                    { type: 'keyword', as: 'pg_deferred', value: ['DEFERRED', 'IMMEDIATE'] },\n                ],\n            },\n        ];\n    }\n\n    static get syntaxRules() {\n        return {\n            type: [\n                // Table-only constraints must match first\n                'TableFKConstraint',\n                'TablePKConstraint',\n                'TableUKConstraint',\n                // then, non-table-only constraints\n                'CheckConstraint',\n                'ColumnDefaultConstraint',\n                'ColumnExpressionConstraint',\n                'ColumnFKConstraint',\n                'ColumnIdentityConstraint',\n                'ColumnNullConstraint',\n                'ColumnPKConstraint',\n                'ColumnUKConstraint',\n            ],\n        };\n    }\n\n    get isColumnLevel() { return this.parentNode instanceof registry.ColumnSchema; }\n\n    /* AST API */\n\n    pgDeferrable() { return this._get('pg_deferrable'); }\n\n    pgDeferred() { return this._get('pg_deferred'); }\n}", "import { ConstraintSchema } from '../ConstraintSchema.js';\n\nexport class PGTableEXConstraintItem extends ConstraintSchema {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            {\n                syntaxes: [\n                    { type: 'ColumnRef2', as: 'expr' },\n                    { type: 'ParenExpr', as: 'expr' },\n                ],\n            },\n            {\n                optional: true,\n                syntax: [\n                    { type: 'operator', value: 'COLLATE' },\n                    { type: 'string_literal', as: 'collation', assert: true },\n                ],\n            },\n            {\n                optional: true,\n                syntax: [\n                    { type: 'Identifier', as: 'opclass' },\n                    {\n                        optional: true,\n                        type: 'paren_block',\n                        syntax: { type: 'ConfigAssignmentExpr', as: 'opclass_parameters', arity: { min: 1 }, itemSeparator, assert: true },\n                    },\n                ],\n            },\n            { type: 'keyword', value: ['ASC', 'DESC'], as: 'dir', optional: true },\n            {\n                optional: true,\n                syntax: [\n                    { type: 'keyword', value: 'NULLS' },\n                    { type: 'keyword', as: 'nulls_spec', value: ['FIRST', 'LAST'], assert: true },\n                ]\n            },\n            { type: 'keyword', value: 'WITH' },\n            { type: 'operator', as: 'operator' },\n        ];\n    }\n\n    /* AST API */\n\n    expr() { return this._get('expr'); }\n\n    collation() { return this._get('collation'); }\n\n    opclass() { return this._get('opclass'); }\n\n    opclassParameters() { return this._get('opclass_parameters'); }\n\n    dir() { return this._get('dir'); }\n\n    nullsSpec() { return this._get('nulls_spec'); }\n\n    operator() { return this._get('operator'); }\n}", "import { AbstractNode } from '../../../abstracts/AbstractNode.js';\n\nexport class ReferentialAction extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return {\n            syntaxes: [\n                { type: 'keyword', as: 'value', value: ['NO ACTION', 'RESTRICT', 'CASCADE'] },\n                [\n                    { type: 'keyword', as: 'value', value: ['SET NULL', 'SET DEFAULT'] },\n                    {\n                        optional: true,\n                        dialect: 'postgres',\n                        type: 'paren_block',\n                        syntax: { type: 'Identifier', as: 'columns', arity: { min: 1 }, itemSeparator },\n                    }\n                ],\n            ],\n        };\n    }\n\n    /*. AST API */\n\n    value() { return this._get('value'); }\n\n    columns() { return this._get('columns'); }\n}", "import { registry } from '../../registry.js';\nimport { ConstraintSchema } from './ConstraintSchema.js';\n\nexport class CheckConstraint extends ConstraintSchema {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return this.buildSyntaxRules([\n            { type: 'keyword', value: 'CHECK' },\n            {\n                type: 'paren_block',\n                syntax: { type: 'Expr', as: 'expr', assert: true },\n                assert: true,\n            },\n            { type: 'keyword', as: 'no_inherit_kw', value: 'NO INHERIT', optional: true }\n        ]);\n    }\n\n    /* AST API */\n\n    expr() { return this._get('expr'); }\n\n    noInheritKW() { return this._get('no_inherit_kw'); }\n\n    /* API */\n\n    columns() {\n        const columns = [];\n        this.expr()?.walkTree((node) => {\n            if (node instanceof registry.ColumnRef1) {\n                columns.push(registry.ColumnRef2.fromJSON({ value: node.value() }))\n            } else return node;\n        });\n        return columns;\n    }\n}", "import { ConstraintSchema } from './ConstraintSchema.js';\n\nexport class ColumnDefaultConstraint extends ConstraintSchema {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return this.buildSyntaxRules([\n            { type: 'keyword', value: 'DEFAULT' },\n            { type: 'Expr', as: 'expr', assert: true, dialect: 'postgres' },\n            { type: ['NumberLiteral', 'StringLiteral', 'NullLiteral', 'BoolLiteral', 'CallExpr', 'RowConstructor'], as: 'expr', assert: true, dialect: 'mysql' },\n        ]);\n    }\n\n    /* AST API */\n\n    expr() { return this._get('expr'); }\n}", "import { ConstraintSchema } from './ConstraintSchema.js';\n\nexport class ColumnExpressionConstraint extends ConstraintSchema {\n\n\t/* SYNTAX RULES */\n\n\tstatic get syntaxRules() {\n\t\treturn this.buildSyntaxRules([\n\t\t\t{\n\t\t\t\tdialect: 'postgres',\n\t\t\t\tsyntax: [\n\t\t\t\t\t{ type: 'keyword', value: 'GENERATED' },\n\t\t\t\t\t{ type: 'keyword', value: 'ALWAYS' },\n\t\t\t\t\t{ type: 'keyword', value: 'AS' },\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: 'paren_block',\n\t\t\t\t\t\tsyntax: { type: 'Expr', as: 'expr', assert: true },\n\t\t\t\t\t},\n\t\t\t\t\t{ type: 'keyword', as: 'stored', value: 'STORED', assert: true },\n\t\t\t\t],\n\t\t\t},\n\t\t\t{\n\t\t\t\tdialect: 'mysql',\n\t\t\t\tsyntax: [\n\t\t\t\t\t{\n\t\t\t\t\t\toptional: true,\n\t\t\t\t\t\tsyntax: [\n\t\t\t\t\t\t\t{ type: 'keyword', as: 'my_generated_kw', value: 'GENERATED', booleanfy: true },\n\t\t\t\t\t\t\t{ type: 'keyword', value: 'ALWAYS' },\n\t\t\t\t\t\t],\n\t\t\t\t\t},\n\t\t\t\t\t{ type: 'keyword', value: 'AS' },\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: 'paren_block',\n\t\t\t\t\t\tsyntax: { type: 'Expr', as: 'expr', assert: true },\n\t\t\t\t\t},\n\t\t\t\t\t{ type: 'keyword', as: 'stored', value: ['STORED', 'VIRTUAL'], optional: true },\n\t\t\t\t],\n\t\t\t},\n\t\t]);\n\t}\n\n\t/* AST API */\n\n\tmyGeneratedKW() { return this._get('my_generated_kw'); }\n\n\texpr() { return this._get('expr'); }\n\n\tstored() { return this._get('stored'); }\n}", "import { ConstraintSchema } from './ConstraintSchema.js';\nimport { registry } from '../../registry.js';\n\nconst {\n    ColumnSchema,\n    ColumnRef2,\n} = registry;\n\nexport class ColumnFKConstraint extends ConstraintSchema {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return this.buildSyntaxRules([\n            { type: 'keyword', value: 'REFERENCES' },\n            { type: 'TableRef2', as: 'target_table', assert: true },\n            {\n                dialect: 'postgres',\n                optional: true,\n                type: 'paren_block',\n                syntax: { type: 'Identifier', as: 'target_columns', arity: 1, itemSeparator, singletons: 'BY_KEY', assert: true },\n            },\n            {\n                dialect: 'mysql',\n                type: 'paren_block',\n                syntax: { type: 'Identifier', as: 'target_columns', arity: 1, itemSeparator, singletons: 'BY_KEY', assert: true },\n            },\n            { type: ['FKMatchRule', 'FKDeleteRule', 'FKUpdateRule'], as: 'referential_rules', arity: Infinity, singletons: true },\n\n        ]);\n    }\n\n    /* AST API */\n\n    targetTable() { return this._get('target_table'); }\n\n    targetColumns() { return this._get('target_columns'); }\n\n    referentialRules() { return this._get('referential_rules'); }\n\n    /* API */\n\n    columns() {\n        return this.parentNode instanceof ColumnSchema\n            ? [ColumnRef2.fromJSON({ value: this.parentNode.name().value() })]\n            : [];\n    }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\nimport { ColumnIdentityConstraint } from './ColumnIdentityConstraint.js';\n\nexport class MYColumnAutoIncrementModifier extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            dialect: 'mysql',\n            syntax: { type: 'keyword', as: '.', value: 'AUTO_INCREMENT' },\n        };\n    }\n\n    /* JSON RULES */\n\n    jsonfy(options = {}, transformer = null, schemaInference = null) {\n        return (options.toDialect || this.options.dialect) === 'postgres'\n            ? (new ColumnIdentityConstraint).jsonfy(options, transformer, schemaInference)\n            : super.jsonfy(options, transformer, schemaInference);\n    }\n}", "import { MYColumnAutoIncrementModifier } from './MYColumnAutoIncrementModifier.js';\nimport { ConstraintSchema } from './ConstraintSchema.js';\n\nexport class ColumnIdentityConstraint extends ConstraintSchema {\n\n\t/* SYNTAX RULES */\n\n\tstatic get syntaxRules() {\n\t\treturn this.buildSyntaxRules([\n\t\t\t{ type: 'keyword', value: 'GENERATED' },\n\t\t\t{\n\t\t\t\tsyntaxes: [\n\t\t\t\t\t{ type: 'keyword', as: 'always_kw', value: 'ALWAYS', booleanfy: true },\n\t\t\t\t\t{\n\t\t\t\t\t\tsyntax: [\n\t\t\t\t\t\t\t{ type: 'keyword', as: 'by_default_kw', value: 'BY', booleanfy: true },\n\t\t\t\t\t\t\t{ type: 'keyword', value: 'DEFAULT', assert: true },\n\t\t\t\t\t\t],\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t},\n\t\t\t{\n\t\t\t\toptional: true,\n\t\t\t\tsyntax: [\n\t\t\t\t\t{ type: 'keyword', as: 'as_identity_kw', value: 'AS', booleanfy: true },\n\t\t\t\t\t{ type: 'keyword', value: 'IDENTITY', assert: true },\n\t\t\t\t]\n\t\t\t}\n\t\t]);\n\t}\n\n\t/* AST API */\n\n\talwaysKW() { return this._get('always_kw'); }\n\n\tbyDefaultKW() { return this._get('by_default_kw'); }\n\n\tasIdentityKW() { return this._get('as_identity_kw'); }\n\n\t/* JSON API */\n\n\tjsonfy(options = {}, transformer = null, schemaInference = null) {\n\t\treturn (options.toDialect || this.options.dialect) === 'mysql'\n\t\t\t? (new MYColumnAutoIncrementModifier).jsonfy(options, transformer, schemaInference)\n\t\t\t: super.jsonfy(options, transformer, schemaInference);\n\t}\n}", "import { ConstraintSchema } from './ConstraintSchema.js';\n\nexport class ColumnNullConstraint extends ConstraintSchema {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return this.buildSyntaxRules([\n            {\n                syntaxes: [\n                    [\n                        { type: 'operator', as: '.', value: 'NOT' },\n                        { type: 'null_literal', value: 'NULL' },\n                    ],\n                    { type: 'null_literal', as: '.', value: 'NULL' },\n                ]\n            }\n        ]);\n    }\n\n    /* AST API */\n\n    value() { return this._get('value'); }\n}", "import { ConstraintSchema } from './ConstraintSchema.js';\nimport { registry } from '../../registry.js';\n\nexport class ColumnPKConstraint extends ConstraintSchema {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return this.buildSyntaxRules([\n            { type: 'keyword', value: 'PRIMARY' },\n            { type: 'keyword', as: '.', value: 'KEY', assert: true },\n            { type: 'PGIndexParameters', as: 'pg_index_parameters', optional: true, dialect: 'postgres' },\n        ]);\n    }\n\n    /* AST API */\n\n    primaryKW() { return this._get('primary_kw'); }\n\n    pgIndexParameters() { return this._get('pg_index_parameters'); }\n\n    /* API */\n\n    columns() {\n        return this.parentNode instanceof registry.ColumnSchema\n            ? [registry.ColumnRef2.fromJSON({ value: this.parentNode.name().value() })]\n            : [];\n    }\n}", "import { ConstraintSchema } from './ConstraintSchema.js';\nimport { registry } from '../../registry.js';\n\nexport class ColumnUKConstraint extends ConstraintSchema {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return this.buildSyntaxRules([\n            { type: 'keyword', value: 'UNIQUE' },\n            { type: 'keyword', as: 'my_key_kw', value: ['KEY', 'INDEX'], optional: true, dialect: 'mysql' },\n            {\n                optional: true,\n                dialect: 'postgres',\n                syntaxes: [\n                    [\n                        { type: 'keyword', value: 'NULLS' },\n                        { type: 'operator', as: 'pg_nulls_distinct', value: 'NOT' },\n                        { type: 'keyword', value: 'DISTINCT', assert: true },\n                    ],\n                    [\n                        { type: 'keyword', value: 'NULLS' },\n                        { type: 'keyword', as: 'pg_nulls_distinct', value: 'DISTINCT', assert: true },\n                    ],\n                ]\n            },\n            { type: 'PGIndexParameters', as: 'pg_index_parameters', optional: true, dialect: 'postgres' }\n        ]);\n    }\n\n    /* AST API */\n\n    myKeyKW() { return this._get('my_key_kw'); }\n\n    pgNullsDistinct() { return this._get('pg_nulls_distinct'); }\n\n    pgIndexParameters() { return this._get('pg_index_parameters'); }\n\n    /* API */\n\n    columns() {\n        const {\n            ColumnSchema,\n            ColumnRef2,\n        } = registry;\n        return this.parentNode instanceof ColumnSchema\n            ? [ColumnRef2.fromJSON({ value: this.parentNode.name().value() })]\n            : [];\n    }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class MYColumnCommentModifier extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            dialect: 'mysql',\n            syntax: [\n                { type: 'keyword', value: 'COMMENT' },\n                { type: 'string_literal', as: '.' },\n            ],\n        };\n    }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class MYColumnOnUpdateModifier extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            dialect: 'mysql',\n            syntax: [\n                { type: 'keyword', value: 'ON' },\n                { type: 'keyword', value: 'UPDATE' },\n                { type: 'keyword', as: '.' },\n            ],\n        };\n    }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class MYColumnVisibilityModifier extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            dialect: 'mysql',\n            syntaxes: [\n                { type: 'keyword', as: '.', value: 'VISIBLE' },\n                { type: 'keyword', as: '.', value: 'INVISIBLE' },\n            ],\n        };\n    }\n}", "import { ConstraintSchema } from './ConstraintSchema.js';\n\nexport class PGTableEXConstraint extends ConstraintSchema {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return {\n            dialect: 'postgres',\n            syntax: this.buildSyntaxRules([\n                { type: 'keyword', value: 'EXCLUDE' },\n                {\n                    optional: true,\n                    syntax: [\n                        { type: 'keyword', value: 'USING' },\n                        { type: 'keyword', as: 'index_method', assert: true },\n                    ],\n                },\n                {\n                    type: 'paren_block',\n                    syntax: { type: 'PGTableEXConstraintItem', as: 'entries', arity: { min: 1 }, itemSeparator, assert: true },\n                    assert: true,\n                },\n                { type: 'PGIndexParameters', as: 'pg_index_parameters', optional: true },\n                {\n                    optional: true,\n                    syntax: [\n                        { type: 'keyword', value: 'WHERE' },\n                        {\n                            type: 'paren_block',\n                            syntax: { type: 'Expr', as: 'where_predicate', assert: true },\n                            assert: true,\n                        }\n                    ],\n                }\n            ])\n        };\n    }\n\n    /* AST API */\n\n    indexMethod() { return this._get('index_method'); }\n\n    entries() { return this._get('entries'); }\n\n    pgIndexParameters() { return this._get('pg_index_parameters'); }\n\n    wherePredicate() { return this._get('where_predicate'); }\n}", "import { ConstraintSchema } from './ConstraintSchema.js';\n\nexport class TableFKConstraint extends ConstraintSchema {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return this.buildSyntaxRules([\n            { type: 'keyword', value: 'FOREIGN' },\n            { type: 'keyword', value: 'KEY', assert: true },\n            {\n                type: 'paren_block',\n                syntax: { type: 'ColumnRef2', as: 'columns', arity: { min: 1 }, itemSeparator, assert: true, singletons: 'BY_KEY' },\n            },\n            { type: 'keyword', value: 'REFERENCES' },\n            { type: 'TableRef2', as: 'target_table', assert: true },\n            {\n                dialect: 'postgres',\n                optional: true,\n                type: 'paren_block',\n                syntax: { type: 'Identifier', as: 'target_columns', arity: { min: 1 }, itemSeparator, singletons: 'BY_KEY', assert: true },\n            },\n            {\n                dialect: 'mysql',\n                type: 'paren_block',\n                syntax: { type: 'Identifier', as: 'target_columns', arity: { min: 1 }, itemSeparator, singletons: 'BY_KEY', assert: true },\n            },\n            { type: ['FKMatchRule', 'FKDeleteRule', 'FKUpdateRule'], as: 'referential_rules', arity: Infinity, assert: true, singletons: true },\n        ]);\n    }\n\n    /* AST API */\n\n    columns() { return this._get('columns'); }\n\n    targetTable() { return this._get('target_table'); }\n\n    targetColumns() { return this._get('target_columns'); }\n\n    referentialRules() { return this._get('referential_rules'); }\n}\n", "import { ConstraintSchema } from './ConstraintSchema.js';\n\nexport class TablePKConstraint extends ConstraintSchema {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return this.buildSyntaxRules([\n            { type: 'keyword', value: 'PRIMARY' },\n            { type: 'keyword', as: '.', value: 'KEY', assert: true },\n            {\n                type: 'paren_block',\n                syntax: { type: 'ColumnRef2', as: 'columns', arity: { min: 1 }, itemSeparator, singletons: 'BY_KEY', assert: true },\n                assert: true,\n            },\n            { type: 'PGIndexParameters', as: 'pg_index_parameters', optional: true, dialect: 'postgres' },\n        ]);\n    }\n\n    /* AST API */\n\n    columns() { return this._get('columns'); }\n    \n    pgIndexParameters() { return this._get('pg_index_parameters'); }\n}", "import { ConstraintSchema } from './ConstraintSchema.js';\n\nexport class TableUKConstraint extends ConstraintSchema {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return this.buildSyntaxRules([\n            { type: 'keyword', value: 'UNIQUE' },\n            { type: 'keyword', as: 'my_key_kw', value: ['KEY', 'INDEX'], optional: true, dialect: 'mysql' },\n            {\n                optional: true,\n                dialect: 'postgres',\n                syntaxes: [\n                    [\n                        { type: 'keyword', value: 'NULLS' },\n                        { type: 'operator', as: 'pg_nulls_distinct', value: 'NOT' },\n                        { type: 'keyword', value: 'DISTINCT', assert: true },\n                    ],\n                    [\n                        { type: 'keyword', value: 'NULLS' },\n                        { type: 'keyword', as: 'pg_nulls_distinct', value: 'DISTINCT', assert: true },\n                    ],\n                ]\n            },\n            {\n                type: 'paren_block',\n                syntax: { type: 'ColumnRef2', as: 'columns', arity: { min: 1 }, itemSeparator, singletons: 'BY_KEY', assert: true },\n                assert: true,\n            },\n            { type: 'PGIndexParameters', as: 'pg_index_parameters', optional: true, dialect: 'postgres' }\n        ]);\n    }\n\n    /* AST API */\n\n    myKeyKW() { return this._get('my_key_kw'); }\n\n    pgNullsDistinct() { return this._get('pg_nulls_distinct'); }\n\n    columns() { return this._get('columns'); }\n\n    pgIndexParameters() { return this._get('pg_index_parameters'); }\n}", "export const PathMixin = (Class) => class extends Class {\n\n\t/* SYNTAX RULES */\n\n\tstatic get _qualifierType() { return 'Identifier'; }\n\n\tstatic buildSyntaxRules(baseRule = null) {\n\t\treturn [\n\t\t\t{\n\t\t\t\toptional: true,\n\t\t\t\tsyntax: [\n\t\t\t\t\t{ type: this._qualifierType, as: 'qualifier' },\n\t\t\t\t\t{ type: 'punctuation', value: '.', autoSpacing: false },\n\t\t\t\t],\n\t\t\t},\n\t\t\tbaseRule ||\n\t\t\t{ ...[].concat(super.syntaxRules)[0], autoSpacing: false },\n\t\t];\n\t}\n\n\tstatic get syntaxRules() { return this.buildSyntaxRules(); }\n\n\tstatic get syntaxPriority() { return -1; }\n\n\t/* AST API */\n\n\tqualifier() { return this._get('qualifier'); }\n\n\t/* API */\n\n\tidentifiesAs(ident, cs = undefined) {\n\t\tconst result = super.identifiesAs(ident, cs);\n\t\tif (result && this.qualifier() && ident.qualifier?.()) {\n\t\t\treturn this.qualifier().identifiesAs(ident.qualifier(), cs);\n\t\t}\n\t\treturn result;\n\t}\n\n\tstatic async _parseFromRules(tokenStream, syntaxRules, { left = undefined, minPrecedence = 0, trail, ...options }, resultAST = {}) {\n\t\tif (left) return super._parseFromRules(tokenStream, syntaxRules, { left, minPrecedence, trail, ...options }, resultAST);\n\t\tconst qualifierTokens = [];\n\n\t\twhile (true) {\n\t\t\tif (await tokenStream.match(1, 'punctuation', '.')) {\n\t\t\t\tqualifierTokens.push(await tokenStream.eat());\n\t\t\t} else if (await tokenStream.match(1, 'version_spec') && await tokenStream.match(2, 'punctuation', '.')) {\n\t\t\t\tqualifierTokens.push(await tokenStream.eat());\n\t\t\t\tqualifierTokens.push(await tokenStream.eat());\n\t\t\t} else break;\n\t\t\t// Determine whether to eat the punctuation ahead of another loop\n\t\t\tif (await tokenStream.match(2, 'punctuation', '.') || (await tokenStream.match(2, 'version_spec') && await tokenStream.match(3, 'punctuation', '.'))) {\n\t\t\t\tqualifierTokens.push(await tokenStream.eat());\n\t\t\t}\n\t\t}\n\n\t\tconst qualifierExposure = 'qualifier';\n\t\tif (qualifierTokens.length) {\n\t\t\tconst qualifierTypes = [].concat(this._qualifierType);\n\t\t\tconst qualifierStream = await this.toStream(qualifierTokens, options);\n\t\t\tconst qualifierOptions = { minPrecedence, trail: trail.concat(this.NODE_NAME, `<${qualifierExposure}>`), ...options };\n\t\t\tleft = await this._parseFromTypes(qualifierStream, qualifierTypes, qualifierOptions);\n\t\t} else {\n\t\t\tleft = false; // Explicitly set to false to prevent super.parse() trying parsing the qualifier rule\n\t\t}\n\n\t\treturn await super._parseFromRules(tokenStream, syntaxRules, { left, minPrecedence, trail, ...options }, resultAST);\n\t}\n}", "export * from './abstraction/index.js';\nexport * from './call/index.js';\nexport * from './case/index.js';\nexport * from './etc/index.js';\nexport * from './literals/index.js';\nexport * from './op/index.js';\nexport * from './ref/index.js';\nexport * from './abstraction/index.js';\nexport * from './var/index.js';\nexport { LQBackRefAbstraction } from './ref/LQBackRefAbstraction.js';\nexport { RowConstructor } from './abstraction/RowConstructor.js';\nexport { ScalarSubquery } from './abstraction/ScalarSubquery.js';\nexport { TypedRowConstructor } from './abstraction/TypedRowConstructor.js';\nexport { Expr } from './Expr.js';                                                              \n", "import { registry } from '../registry.js';\n\nexport const TypeSysMixin = (Class) => class extends Class {\n\n\tdataType() { return registry.DataType.fromJSON({ value: 'TEXT' }); };\n}", "import { TypeSysMixin } from '../abstracts/TypeSysMixin.js';\nimport { AbstractNode } from '../abstracts/AbstractNode.js';\n\nexport class AbstractClassicExpr extends TypeSysMixin(AbstractNode) {}", "import { AbstractClassicExpr } from '../AbstractClassicExpr.js';\n\nexport class ParenExpr extends AbstractClassicExpr {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            type: 'paren_block',\n            syntax: { type: 'Expr', as: 'expr' },\n            autoIndent: true,\n        };\n    }\n\n    static get syntaxPriority() { return -1; }\n\n    /* AST API */\n\n    expr() { return this._get('expr'); }\n\n    exprUnwrapped() {\n        const expr = this._get('expr');\n        if (expr instanceof ParenExpr) {\n            return expr.exprUnwrapped();\n        }\n        return expr;\n    }\n\n    /* TYPESYS */\n\n    dataType() { return this.expr()?.dataType(); }\n}", "import { TypeSysMixin } from '../../abstracts/TypeSysMixin.js';\nimport { ResultSchemaMixin } from '../../abstracts/ResultSchemaMixin.js';\nimport { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\nimport { registry } from '../../registry.js';\n\nexport class RowConstructor extends ResultSchemaMixin(TypeSysMixin(AbstractNodeList)) {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return {\n            syntax: [\n                {\n                    type: 'paren_block',\n                    syntax: {\n                        type: [\n                            'DerivedQuery'/* to support dimensional RHS in DML, and should appear before Expr.RowConstructor */,\n                            'ValuesTableLiteral',\n                            'Expr',\n                        ], as: 'entries', arity: Infinity, itemSeparator, autoIndent: 10\n                    },\n                },\n            ],\n        };\n    }\n\n    static get syntaxPriority() { return 49; } // Below all () shapes like LQBackRefAbstraction but above DerivedQuery \n\n    /* API */\n\n    exprUnwrapped() {\n        if (this._get('entries')?.length === 1 && this._get('entries')[0] instanceof RowConstructor) {\n            return this._get('entries')[0].exprUnwrapped();\n        }\n        return this;\n    }\n\n    /* TYPESYS */\n\n    dataType() { return registry.DataType.fromJSON({ value: 'SET' }); }\n\n    /* JSON API */\n\n    jsonfy(options = {}, transformer = null, schemaInference = null) {\n        let resultJson = super.jsonfy(options, transformer, schemaInference);\n        if (options.deSugar?.rowConstructorSchemas || options.forceDeSugar) {\n\n            const entriesNode = this.entries() || [];\n            const entriesJson = resultJson.entries || [];\n\n            const resultSchemas = entriesJson.map((entry, i) => {\n                const ident = { nodeName: registry.Identifier.NODE_NAME, value: i };\n                if (entry.result_schema instanceof registry.ColumnSchema) {\n                    return entry.result_schema.clone({ renameTo: ident });\n                }\n                return registry.ColumnSchema.fromJSON({\n                    name: ident,\n                    data_type: entriesNode[i].dataType().jsonfy(),\n                });\n            });\n\n            resultJson = {\n                ...resultJson,\n                result_schema: registry.JSONSchema.fromJSON({ entries: resultSchemas }, { assert: true }),\n            };\n        }\n\n        return resultJson;\n    }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\nimport { ResultSchemaMixin } from '../../abstracts/ResultSchemaMixin.js';\nimport { ParenExpr } from '../../expr/abstraction/ParenExpr.js';\n\nexport class DerivedQuery extends ResultSchemaMixin(ParenExpr) {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            type: 'paren_block',\n            syntax: { type: ['SelectStmt', 'TableStmt', 'CTE'], as: 'expr', autoIndent: true },\n\n        };\n    }\n\n    static get syntaxPriority() { return -1; }\n\n    /* TYPESYS API */\n\n    dataType() { return this.expr()?.dataType(); }\n\n    #is_correlated = false;\n\n    isCorrelated() { return this.#is_correlated; }\n\n    /* JSON API */\n\n    static fromJSON(inputJson, options = {}, callback = null) {\n        if (!inputJson || inputJson instanceof AbstractNode) {\n            return super.fromJSON(inputJson, options, callback);\n        }\n        const { is_correlated, ...restJson } = inputJson;\n        const instance = super.fromJSON(restJson, options, callback);\n        if (instance && is_correlated) {\n            if (typeof is_correlated !== 'boolean') {\n                throw new Error(`Invalid value passed at inputJson.is_correlated`);\n            }\n            instance.#is_correlated = is_correlated;\n        }\n        return instance;\n    }\n\n    jsonfy(options = {}, transformer = null, schemaInference = null) {\n        const statementContextArtifacts = transformer?.statementContext?.artifacts || new Map;\n        statementContextArtifacts.set('derivedQueryCorrelationFlag', null);\n\n        let resultJson = super.jsonfy(options, transformer, schemaInference);\n\n        const correlationFlag = statementContextArtifacts.get('derivedQueryCorrelationFlag');\n        statementContextArtifacts.delete('derivedQueryCorrelationFlag');\n\n        if (options.deSugar) {\n            const resultSchema = resultJson.expr?.result_schema;\n            resultJson = {\n                ...resultJson,\n                is_correlated: !!correlationFlag,\n                result_schema: resultSchema,\n            };\n        } else {\n            resultJson = {\n                ...resultJson,\n                is_correlated: this.#is_correlated,\n            };\n        }\n\n        return resultJson;\n    }\n}", "import { DerivedQuery } from '../../dql/TA/DerivedQuery.js';\nimport { registry } from '../../registry.js';\n\nexport class ScalarSubquery extends DerivedQuery {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            type: 'paren_block',\n            syntax: { type: ['SelectStmt', 'CTE'], as: 'expr' },\n            autoIndent: true,\n        };\n    }\n\n    static get syntaxPriority() { return 48; } // Below RowConstructor\n\n    /* TYPESYS API */\n\n    dataType() {\n        if (this.resultSchema()) {\n            return this.resultSchema().dataType();\n        }\n        return registry.DataType.fromJSON({ value: 'TEXT' });\n    }\n\n    /* JSON API */\n\n    jsonfy(options = {}, transformer = null, schemaInference = null) {\n        let resultJson = super.jsonfy(options, transformer, schemaInference);\n        if (options.deSugar) {\n            let resultSchema = resultJson.expr?.result_schema;\n            if (resultSchema?.length !== 1) {\n                throw new Error(`Scalar subqueries must return a scalar value.`);\n            }\n            resultSchema = resultSchema.entries()[0];\n            resultJson = {\n                ...resultJson,\n                result_schema: resultSchema,\n            };\n        }\n        return resultJson;\n    }\n}", "import { RowConstructor } from './RowConstructor.js';\n\nexport class TypedRowConstructor extends RowConstructor {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', value: 'ROW' },\n            ...[].concat(super.syntaxRules)\n        ];\n    }\n\n    static get syntaxPriority() { return 52; } // Above CallExpr\n}", "import { AbstractNode } from '../../../abstracts/AbstractNode.js';\n\nexport class PGFilterClause extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            dialect: 'postgres',\n            syntax: [\n                { type: 'keyword', value: 'FILTER' },\n                {\n                    type: 'paren_block',\n                    syntax: { type: 'WhereClause', as: 'where_clause' },\n                    assert: true,\n                    autoIndent: true\n                }\n            ]\n        };\n    }\n\n    static get syntaxPriority() { return -1; }\n\n    /* AST API */\n\n    whereClause() { return this._get('where_clause'); }\n}", "import { AbstractNode } from '../../../abstracts/AbstractNode.js';\n\nexport class PGWithinGroupClause extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            dialect: 'postgres',\n            syntax: [\n                { type: 'keyword', value: 'WITHIN' },\n                { type: 'keyword', value: 'GROUP' },\n                {\n                    type: 'paren_block',\n                    syntax: { type: 'OrderByClause', as: 'order_by_clause' },\n                    assert: true,\n                    autoIndent: true,\n                },\n            ]\n        };\n    }\n\n    static get syntaxPriority() { return -1; }\n\n    /* AST API */\n\n    orderByClause() { return this._get('order_by_clause'); }\n}", "import { ResultSchemaMixin } from '../../abstracts/ResultSchemaMixin.js';\nimport { AbstractClassicExpr } from '../AbstractClassicExpr.js';\n\nexport class CallExpr extends ResultSchemaMixin(AbstractClassicExpr) {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n\n        return {\n            syntaxes: [\n                {\n                    peek: [0, 'keyword', [\n                        'NOW', 'CURRENT_DATE', 'CURRENT_TIME', 'CURRENT_TIMESTAMP',\n                        'IF', 'NULLIF', 'IFNULL',\n                        'COALESCE', 'GREATEST', 'LEAST', 'CONCAT',\n                        'CONCAT_WS', 'FORMAT',\n                        'MD5', 'SHA1',\n                        'TO_JSON', 'TO_JSONB', 'JSON_TYPEOF', 'JSONB_TYPEOF',\n                        'JSON_BUILD_ARRAY', 'JSONB_BUILD_ARRAY', 'JSON_BUILD_OBJECT', 'JSONB_BUILD_OBJECT',\n                        'JSON_POPULATE_RECORD', 'JSONB_POPULATE_RECORD', 'JSON_PATH_QUERY', 'JSON_PATH_EXISTS',\n                        'JSON_ARRAY', 'JSON_OBJECT', 'JSON_EXTRACT', 'JSON_UNQUOTE',\n                        'JSON_SET', 'JSON_INSERT', 'JSON_REPLACE', 'JSON_REMOVE',\n                        'JSON_SEARCH', 'JSON_CONTAINS', 'JSON_CONTAINS_PATH',\n                        'JSON_KEYS', 'JSON_ARRAY_APPEND', 'JSON_ARRAY_INSERT',\n                        'JSON_DEPTH', 'JSON_LENGTH', 'JSON_MERGE_PRESERVE',\n                        'JSON_MERGE_PATCH', 'JSON_PRETTY', 'JSON_STORAGE_FREE',\n                        'ST_ASTEXT', 'ST_ASGEOJSON', 'ST_GEOMFROMTEXT',\n                        'ST_WITHIN', 'ST_CONTAINS', 'ST_INTERSECTS', 'ST_DISTANCE', 'ST_BUFFER',\n                        'MAKE_DATE', 'MAKE_TIME', 'MAKE_TIMESTAMP', 'ARRAY',\n                        'CURDATE', 'CURTIME', 'SYSDATE', 'STR_TO_DATE', 'MAKEDATE', 'MAKETIME',\n                    ]],\n                    syntaxes: [\n\n                        // ---------- \uD83E\uDDEE Cross-dialect scalar functions (fixed arity)\n\n                        [\n                            { type: 'keyword', as: 'name', value: ['CURRENT_DATE', 'CURRENT_TIME', 'CURRENT_TIMESTAMP'] },\n                            {\n                                type: 'paren_block',\n                                syntax: { type: 'Expr', as: 'arguments', arity: 0, itemSeparator, assert: true },\n                                optional: true,\n                                optionalParens: true,\n                                autoSpacing: false\n                            }\n                        ],\n                        [\n                            { type: 'keyword', as: 'name', value: ['NOW'] },\n                            {\n                                type: 'paren_block',\n                                syntax: { type: 'Expr', as: 'arguments', arity: 0, itemSeparator, assert: true },\n                                optional: true,\n                                autoSpacing: false\n                            }\n                        ],\n                        [\n                            { type: 'keyword', as: 'name', value: ['IF', 'NULLIF', 'IFNULL'] },\n                            {\n                                type: 'paren_block',\n                                syntax: { type: 'Expr', as: 'arguments', arity: { min: 2, max: 3 }, itemSeparator, assert: true },\n                                autoSpacing: false\n                            }\n                        ],\n\n                        // ---------- \uD83D\uDCD0 Cross-dialect scalar functions (variadic)\n\n                        [\n                            { type: 'keyword', as: 'name', value: ['COALESCE', 'GREATEST', 'LEAST', 'CONCAT'] },\n                            {\n                                type: 'paren_block',\n                                syntax: { type: 'Expr', as: 'arguments', arity: { min: 1 }, itemSeparator, assert: true },\n                                autoSpacing: false\n                            }\n                        ],\n                        [\n                            { type: 'keyword', as: 'name', value: ['CONCAT_WS', 'FORMAT'] },\n                            {\n                                type: 'paren_block',\n                                syntax: { type: 'Expr', as: 'arguments', arity: { min: 2 }, itemSeparator, assert: true },\n                                autoSpacing: false\n                            }\n                        ],\n                        [\n                            { type: 'keyword', as: 'name', value: ['MD5', 'SHA1'] },\n                            {\n                                type: 'paren_block',\n                                syntax: { type: 'Expr', as: 'arguments', arity: 1, itemSeparator, assert: true },\n                                autoSpacing: false\n                            }\n                        ],\n\n                        // ---------- \uD83D\uDFE9 Spatial functions (PostgreSQL & MySQL)\n\n                        [\n                            { type: 'keyword', as: 'name', value: ['ST_ASTEXT', 'ST_ASGEOJSON', 'ST_GEOMFROMTEXT'] },\n                            {\n                                type: 'paren_block',\n                                syntax: { type: 'Expr', as: 'arguments', arity: 1, itemSeparator, assert: true },\n                                autoSpacing: false\n                            }\n                        ],\n                        [\n                            { type: 'keyword', as: 'name', value: ['ST_WITHIN', 'ST_CONTAINS', 'ST_INTERSECTS', 'ST_DISTANCE', 'ST_BUFFER'] },\n                            {\n                                type: 'paren_block',\n                                syntax: { type: 'Expr', as: 'arguments', arity: 2, itemSeparator, assert: true },\n                                autoSpacing: false\n                            }\n                        ],\n\n                        // ---------- \uD83D\uDFEB PostgreSQL JSON functions\n\n                        {\n                            dialect: 'postgres',\n                            syntax: [\n                                { type: 'keyword', as: 'name', value: ['TO_JSON', 'TO_JSONB', 'JSON_TYPEOF', 'JSONB_TYPEOF'] },\n                                {\n                                    type: 'paren_block',\n                                    syntax: { type: 'Expr', as: 'arguments', arity: 1, itemSeparator, assert: true },\n                                    autoSpacing: false\n                                }\n                            ]\n                        },\n                        {\n                            dialect: 'postgres',\n                            syntax: [\n                                { type: 'keyword', as: 'name', value: ['JSON_BUILD_ARRAY', 'JSONB_BUILD_ARRAY', 'JSON_BUILD_OBJECT', 'JSONB_BUILD_OBJECT'] },\n                                {\n                                    type: 'paren_block',\n                                    syntax: { type: 'Expr', as: 'arguments', arity: { min: 0 }, itemSeparator, assert: true },\n                                    autoSpacing: false\n                                }\n                            ]\n                        },\n                        {\n                            dialect: 'postgres',\n                            syntax: [\n                                { type: 'keyword', as: 'name', value: ['JSON_POPULATE_RECORD', 'JSONB_POPULATE_RECORD', 'JSON_PATH_QUERY', 'JSON_PATH_EXISTS'] },\n                                {\n                                    type: 'paren_block',\n                                    syntax: { type: 'Expr', as: 'arguments', arity: 2, itemSeparator, assert: true },\n                                    autoSpacing: false\n                                }\n                            ]\n                        },\n                        {\n                            dialect: 'postgres',\n                            syntax: [\n                                { type: 'keyword', as: 'name', value: ['ARRAY'] },\n                                {\n                                    type: 'paren_block',\n                                    syntax: { type: 'SelectStmt', as: 'arguments', arity: 1, itemSeparator, assert: true },\n                                    autoIndent: true,\n                                    autoSpacing: true\n                                }\n                            ]\n                        },\n\n                        // ---------- \uD83D\uDFEB PostgreSQL Date functions\n\n                        {\n                            dialect: 'postgres',\n                            syntax: [\n                                { type: 'keyword', as: 'name', value: ['MAKE_DATE', 'MAKE_TIME', 'MAKE_TIMESTAMP'] },\n                                {\n                                    type: 'paren_block',\n                                    syntax: { type: 'Expr', as: 'arguments', arity: Infinity, itemSeparator, assert: true },\n                                    autoSpacing: false\n                                }\n                            ]\n                        },\n\n                        // ---------- \uD83D\uDFE7 MySQL JSON functions\n\n                        {\n                            dialect: 'mysql',\n                            syntax: [\n                                {\n                                    type: 'keyword', as: 'name', value: [\n                                        'JSON_ARRAY', 'JSON_OBJECT', 'JSON_EXTRACT', 'JSON_UNQUOTE',\n                                        'JSON_SET', 'JSON_INSERT', 'JSON_REPLACE', 'JSON_REMOVE',\n                                        'JSON_SEARCH', 'JSON_CONTAINS', 'JSON_CONTAINS_PATH',\n                                        'JSON_KEYS', 'JSON_ARRAY_APPEND', 'JSON_ARRAY_INSERT',\n                                        'JSON_DEPTH', 'JSON_LENGTH', 'JSON_MERGE_PRESERVE',\n                                        'JSON_MERGE_PATCH', 'JSON_PRETTY', 'JSON_STORAGE_FREE'\n                                    ]\n                                },\n                                {\n                                    type: 'paren_block',\n                                    syntax: { type: 'Expr', as: 'arguments', arity: { min: 1 }, itemSeparator, assert: true },\n                                    autoSpacing: false\n                                }\n                            ]\n                        },\n\n                        // ---------- \uD83D\uDFE7 MySQL Date functions\n\n                        {\n                            dialect: 'mysql',\n                            syntax: [\n                                { type: 'keyword', as: 'name', value: ['CURDATE', 'CURTIME', 'SYSDATE'] },\n                                {\n                                    type: 'paren_block',\n                                    syntax: { type: 'Expr', as: 'arguments', arity: 0, itemSeparator, optional: true, assert: true },\n                                    autoSpacing: false\n                                }\n                            ]\n                        },\n                        {\n                            dialect: 'mysql',\n                            syntax: [\n                                { type: 'keyword', as: 'name', value: 'STR_TO_DATE' },\n                                {\n                                    type: 'paren_block',\n                                    syntax: { type: 'Expr', as: 'arguments', arity: 2, itemSeparator, assert: true },\n                                    autoSpacing: false\n                                }\n                            ]\n                        },\n                        {\n                            dialect: 'mysql',\n                            syntax: [\n                                { type: 'keyword', as: 'name', value: ['MAKEDATE', 'MAKETIME'] },\n                                {\n                                    type: 'paren_block',\n                                    syntax: { type: 'Expr', as: 'arguments', arity: 2, itemSeparator, assert: true },\n                                    autoSpacing: false\n                                }\n                            ]\n                        }\n                    ]\n                },\n\n                // ---------- \uD83E\uDDE0 Fallback: general call syntax\n\n                [\n                    { type: 'keyword', as: 'name' },\n                    {\n                        type: 'paren_block',\n                        syntax: { type: 'Expr', as: 'arguments', arity: Infinity, itemSeparator },\n                        autoSpacing: false\n                    }\n                ],\n                [\n                    { type: 'identifier', as: 'name' },\n                    {\n                        type: 'paren_block',\n                        syntax: { type: 'Expr', as: 'arguments', arity: Infinity, itemSeparator },\n                        autoSpacing: false\n                    }\n                ]\n            ]\n        };\n    }\n\n    static get syntaxPriority() { return 51; }\n\n    /* AST API */\n\n    name() { return this._get('name'); }\n\n    arguments() { return this._get('arguments'); }\n}\n", "import { CallExpr } from './CallExpr.js';\n\nexport class AggrCallExpr extends CallExpr {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n\n        // Optional modifiers and clauses\n        const optional_distinct_modifier = { type: 'keyword', as: 'distinct', value: 'DISTINCT', booleanfy: true, optional: true };\n        const optional_separator_arg = {\n            optional: true,\n            syntax: [\n                { type: 'keyword', value: 'SEPARATOR' },\n                { type: 'Expr', as: 'separator', assert: true }\n            ]\n        };\n        const optional_order_by_clause = { type: 'OrderByClause', as: 'order_by_clause', optional: true };\n        const optional_filter_clause_postgres = { type: 'PGFilterClause', as: 'pg_filter_clause', optional: true, dialect: 'postgres' };\n        const optional_within_group_clause_postgres = { type: 'PGWithinGroupClause', as: 'pg_within_group_clause', optional: true, dialect: 'postgres' };\n        const optional_null_handling_directive = {\n            optional: true,\n            syntax: [\n                { type: 'keyword', as: 'null_handling', value: ['IGNORE', 'RESPECT'] },\n                { type: 'keyword', value: 'NULLS', assert: true }\n            ]\n        };\n        const optional_over_clause = {\n            optional: true,\n            syntax: [\n                { type: 'keyword', value: 'OVER' },\n                { type: ['WindowRef', 'WindowSpec'], as: 'over_clause', assert: true }\n            ]\n        };\n\n        // The syntax compositions\n        return {\n            peek: [0, 'keyword', [\n                'COUNT', 'SUM', 'AVG', 'MIN', 'MAX',\n                'ARRAY_AGG', 'STRING_AGG', 'GROUP_CONCAT',\n                'REGR_SLOPE', 'COVAR_POP', 'COVAR_SAMP', 'CORR',\n                'PERCENTILE_CONT', 'PERCENTILE_DISC', 'MODE',\n                'RANK', 'DENSE_RANK', 'ROW_NUMBER',\n                'EVERY', 'BOOL_AND', 'BOOL_OR',\n                'BIT_AND', 'BIT_OR', 'BIT_XOR',\n                'JSON_AGG', 'JSON_ARRAYAGG', 'JSON_OBJECT_AGG', 'JSONB_OBJECT_AGG', 'JSON_OBJECTAGG',\n                'STDDEV_POP', 'STDDEV_SAMP', 'VAR_POP', 'VAR_SAMP', 'VARIANCE', 'STD',\n                'XMLAGG', 'LEAD', 'LAG', 'NTILE', 'FIRST_VALUE', 'LAST_VALUE'\n            ]],\n            syntaxes: [\n\n                // ---------- \uD83D\uDD22 Basic aggregates\n\n                [ // COUNT(), COUNT(*)\n                    { type: 'keyword', as: 'name', value: 'COUNT' },\n                    {\n                        type: 'paren_block',\n                        syntax: [\n                            { dialect: 'postgres', type: 'ColumnRef0', as: 'arguments', arity: 1, assert: false/* note: to give syntax2 a chance */, itemSeparator },\n                            { dialect: 'mysql', type: 'ColumnRef0', as: 'arguments', arity: Infinity, assert: false/* note: to give syntax2 a chance */, itemSeparator, optional: true }\n                        ],\n                        autoSpacing: false,\n                    },\n                    { ...optional_filter_clause_postgres },\n                    { ...optional_over_clause },\n                ],\n                [ // COUNT|SUM|AVG|MIN|MAX([DISTINCT] expr) [FILTER (...)] [OVER (...)]\n                    { type: 'keyword', as: 'name', value: ['COUNT', 'SUM', 'AVG', 'MIN', 'MAX'] },\n                    {\n                        type: 'paren_block',\n                        syntax: [\n                            { ...optional_distinct_modifier },\n                            { type: 'Expr', as: 'arguments', arity: 1, itemSeparator, assert: true }\n                        ],\n                        autoSpacing: false,\n                    },\n                    { ...optional_filter_clause_postgres },\n                    { ...optional_over_clause },\n                ],\n\n                // ---------- \uD83E\uDDF5 List / string aggregates\n\n                {\n                    dialect: 'postgres',\n                    syntax: [ // ARRAY_AGG()\n                        { type: 'keyword', as: 'name', value: 'ARRAY_AGG' },\n                        {\n                            type: 'paren_block',\n                            syntax: [\n                                { ...optional_distinct_modifier },\n                                { type: 'Expr', as: 'arguments', arity: { min: 1 }, itemSeparator, assert: true },\n                                { ...optional_order_by_clause },\n                            ],\n                            autoSpacing: false,\n                        },\n                        { ...optional_filter_clause_postgres },\n                        { ...optional_over_clause },\n                    ]\n                },\n                {\n                    dialect: 'postgres',\n                    syntax: [ // STRING_AGG()\n                        { type: 'keyword', as: 'name', value: 'STRING_AGG' },\n                        {\n                            type: 'paren_block',\n                            syntax: [\n                                { ...optional_distinct_modifier },\n                                { type: 'Expr', as: 'arguments', arity: 2, itemSeparator, assert: true },\n                                { ...optional_order_by_clause },\n                                { ...optional_separator_arg },\n                            ],\n                            autoSpacing: false,\n                        },\n                        { ...optional_filter_clause_postgres },\n                        { ...optional_over_clause },\n                    ]\n                },\n                {\n                    dialect: 'mysql',\n                    syntax: [ // GROUP_CONCAT()\n                        { type: 'keyword', as: 'name', value: 'GROUP_CONCAT' },\n                        {\n                            type: 'paren_block',\n                            syntax: [\n                                { ...optional_distinct_modifier },\n                                { type: 'Expr', as: 'arguments', arity: { min: 1 }, itemSeparator, assert: true },\n                                { ...optional_order_by_clause },\n                                { ...optional_separator_arg },\n                            ],\n                            autoSpacing: false,\n                        },\n                        { ...optional_over_clause },\n                    ]\n                },\n\n                // ---------- \uD83D\uDCC8 Statistical aggregates\n\n                {\n                    dialect: 'postgres',\n                    syntax: [ // REGR_SLOPE() [FILTER (...)] [OVER (...)]\n                        { type: 'keyword', as: 'name', value: 'REGR_SLOPE' },\n                        {\n                            type: 'paren_block',\n                            syntax: { type: 'Expr', as: 'arguments', arity: 2, itemSeparator, assert: true },\n                            autoSpacing: false,\n                        },\n                        { ...optional_filter_clause_postgres },\n                        { ...optional_over_clause },\n                    ]\n                },\n                [ // COVAR_POP|COVAR_SAMP|CORR() [FILTER (...)] [OVER (...)]\n                    { type: 'keyword', as: 'name', value: ['COVAR_POP', 'COVAR_SAMP', 'CORR'] },\n                    {\n                        type: 'paren_block',\n                        syntax: { type: 'Expr', as: 'arguments', arity: 2, itemSeparator, assert: true },\n                        autoSpacing: false,\n                    },\n                    { ...optional_filter_clause_postgres },\n                    { ...optional_over_clause },\n                ],\n\n                // ---------- \uD83D\uDCD0 Ordered-set aggregates (PostgreSQL only)\n\n                {\n                    dialect: 'postgres',\n                    syntax: [ // PERCENTILE_CONT|PERCENTILE_DISC(expr) [FILTER (...)] [WITHIN GROUP (...)]\n                        { type: 'keyword', as: 'name', value: ['PERCENTILE_CONT', 'PERCENTILE_DISC'] },\n                        {\n                            type: 'paren_block',\n                            syntax: { type: 'Expr', as: 'arguments', arity: 1, itemSeparator, assert: true },\n                            autoSpacing: false,\n                        },\n                        { ...optional_filter_clause_postgres },\n                        { ...optional_within_group_clause_postgres, optional: false/* OVERRIDE for \"required\" */ },\n                    ]\n                },\n                {\n                    dialect: 'postgres',\n                    syntax: [ // MODE() [FILTER (...)] [WITHIN GROUP (...)]\n                        { type: 'keyword', as: 'name', value: 'MODE' },\n                        {\n                            type: 'paren_block',\n                            syntax: { type: 'Expr', as: 'arguments', arity: 0, itemSeparator, assert: true },\n                            autoSpacing: false,\n                        },\n                        { ...optional_filter_clause_postgres },\n                        { ...optional_within_group_clause_postgres, optional: false/* OVERRIDE for \"required\" */ },\n                    ]\n                },\n                {\n                    dialect: 'postgres',\n                    syntax: [ // RANK|DENSE_RANK() [FILTER (...)] [OVER (...)]\n                        { type: 'keyword', as: 'name', value: ['RANK', 'DENSE_RANK'] },\n                        {\n                            type: 'paren_block',\n                            syntax: { type: 'Expr', as: 'arguments', arity: 0, itemSeparator, assert: true },\n                            autoSpacing: false,\n                        },\n                        { ...optional_filter_clause_postgres },\n                        { ...optional_over_clause, optional: false },\n                    ]\n                },\n                [ // ROW_NUMBER() [OVER (...)]\n                    { type: 'keyword', as: 'name', value: 'ROW_NUMBER' },\n                    {\n                        type: 'paren_block',\n                        syntax: { type: 'Expr', as: 'arguments', arity: 0, itemSeparator, assert: true },\n                        autoSpacing: false,\n                    },\n                    { ...optional_over_clause, optional: false },\n                ],\n\n                // ---------- \uD83E\uDDE0 Boolean aggregates\n\n                {\n                    dialect: 'postgres',\n                    syntax: [ // EVERY|BOOL_AND|BOOL_OR([DISTINCT] expr) [FILTER (...)] [OVER (...)]\n                        { type: 'keyword', as: 'name', value: ['EVERY', 'BOOL_AND', 'BOOL_OR'] },\n                        {\n                            type: 'paren_block',\n                            syntax: [\n                                { ...optional_distinct_modifier },\n                                { type: 'Expr', as: 'arguments', arity: 1, itemSeparator, assert: true }\n                            ],\n                            autoSpacing: false,\n                        },\n                        { ...optional_filter_clause_postgres },\n                        { ...optional_over_clause },\n                    ]\n                },\n\n                // ---------- \uD83D\uDCE6 JSON aggregates\n\n                {\n                    dialect: 'postgres',\n                    syntax: [ // JSON_AGG([DISTINCT] expr) [FILTER (...)] [OVER (...)]\n                        { type: 'keyword', as: 'name', value: 'JSON_AGG' },\n                        {\n                            type: 'paren_block',\n                            syntax: [\n                                { ...optional_distinct_modifier },\n                                { type: 'Expr', as: 'arguments', arity: { min: 1 }, itemSeparator, assert: true }\n                            ],\n                            autoSpacing: false,\n                        },\n                        { ...optional_filter_clause_postgres },\n                        { ...optional_over_clause },\n                    ]\n                },\n                {\n                    dialect: 'mysql',\n                    syntax: [ // JSON_ARRAYAGG([DISTINCT] expr) [OVER (...)]\n                        { type: 'keyword', as: 'name', value: 'JSON_ARRAYAGG' },\n                        {\n                            type: 'paren_block',\n                            syntax: [\n                                { ...optional_distinct_modifier },\n                                { type: 'Expr', as: 'arguments', arity: { min: 1 }, itemSeparator, assert: true }\n                            ],\n                            autoSpacing: false,\n                        },\n                        { ...optional_over_clause },\n                    ]\n                },\n\n                // ---------- \uD83D\uDCE6 Others 1\n\n                {\n                    dialect: 'mysql',\n                    syntax: [ // BIT_XOR (MySQL only)\n                        { type: 'keyword', as: 'name', value: 'BIT_XOR' },\n                        {\n                            type: 'paren_block',\n                            syntax: [\n                                { ...optional_distinct_modifier },\n                                { type: 'Expr', as: 'arguments', arity: 1, itemSeparator, assert: true }\n                            ],\n                            autoSpacing: false,\n                        },\n                        { ...optional_over_clause },\n                    ]\n                },\n                [ // BIT_AND, BIT_OR (PostgreSQL + MySQL)\n                    { type: 'keyword', as: 'name', value: ['BIT_AND', 'BIT_OR'] },\n                    {\n                        type: 'paren_block',\n                        syntax: [\n                            { ...optional_distinct_modifier },\n                            { type: 'Expr', as: 'arguments', arity: 1, itemSeparator, assert: true }\n                        ],\n                        autoSpacing: false,\n                    },\n                    { ...optional_filter_clause_postgres },\n                    { ...optional_over_clause },\n                ],\n\n                // ---------- \uD83D\uDCE6 Others 2\n\n                {\n                    dialect: 'postgres',\n                    syntax: [\n                        { type: 'keyword', as: 'name', value: ['JSON_OBJECT_AGG', 'JSONB_OBJECT_AGG'] },\n                        {\n                            type: 'paren_block',\n                            syntax: [\n                                { ...optional_distinct_modifier },\n                                { type: 'Expr', as: 'arguments', arity: 2, itemSeparator, assert: true } // key, value\n                            ],\n                            autoSpacing: false,\n                        },\n                        { ...optional_filter_clause_postgres },\n                        { ...optional_over_clause },\n                    ]\n                },\n                {\n                    dialect: 'mysql',\n                    syntax: [\n                        { type: 'keyword', as: 'name', value: 'JSON_OBJECTAGG' },\n                        {\n                            type: 'paren_block',\n                            syntax: [\n                                { ...optional_distinct_modifier },\n                                { type: 'Expr', as: 'arguments', arity: 2, itemSeparator, assert: true } // key, value\n                            ],\n                            autoSpacing: false,\n                        },\n                        { ...optional_over_clause },\n                    ]\n                },\n\n                // ---------- \uD83D\uDCE6 Others 3\n\n                [\n                    { type: 'keyword', as: 'name', value: ['STDDEV_POP', 'STDDEV_SAMP', 'VAR_POP', 'VAR_SAMP', 'VARIANCE', 'STD'] },\n                    {\n                        type: 'paren_block',\n                        syntax: [\n                            { ...optional_distinct_modifier },\n                            { type: 'Expr', as: 'arguments', arity: 1, itemSeparator, assert: true }\n                        ],\n                        autoSpacing: false,\n                    },\n                    { ...optional_filter_clause_postgres },\n                    { ...optional_over_clause },\n                ],\n\n                // ---------- \uD83D\uDCE6 Others 4\n\n                {\n                    dialect: 'postgres',\n                    syntax: [\n                        { type: 'keyword', as: 'name', value: 'XMLAGG' },\n                        {\n                            type: 'paren_block',\n                            syntax: [\n                                { type: 'Expr', as: 'arguments', arity: 1, itemSeparator, assert: true },\n                                { ...optional_order_by_clause }\n                            ],\n                            autoSpacing: false,\n                        },\n                        { ...optional_filter_clause_postgres },\n                        { ...optional_over_clause },\n                    ]\n                },\n\n                // ---------- \uD83D\uDCE6 Others 5\n\n                [\n                    { type: 'keyword', as: 'name', value: ['LEAD', 'LAG'] },\n                    {\n                        type: 'paren_block',\n                        syntax: { type: 'Expr', as: 'arguments', arity: { max: 3 }, itemSeparator, optional: true, assert: true },\n                        autoSpacing: false,\n                    },\n                    { ...optional_null_handling_directive },\n                    { ...optional_over_clause },\n                ],\n                [\n                    { type: 'keyword', as: 'name', value: ['NTILE', 'FIRST_VALUE', 'LAST_VALUE'] },\n                    {\n                        type: 'paren_block',\n                        syntax: { type: 'Expr', as: 'arguments', arity: 1, itemSeparator, assert: true },\n                        autoSpacing: false,\n                    },\n                    { ...optional_over_clause, optional: false },\n                ],\n            ]\n        };\n    }\n\n    /* AST API */\n\n    distinct() { return this._get('distinct'); }\n\n    orderByClause() { return this._get('order_by_clause'); }\n\n    separator() { return this._get('separator'); }\n\n    overClause() { return this._get('over_clause'); }\n\n    // -- Postgres\n\n    pgFilterClause() { return this._get('pg_filter_clause'); }\n\n    pgWithinGroupClause() { return this._get('pg_within_group_clause'); }\n}", "import { TypeSysMixin } from '../../abstracts/TypeSysMixin.js';\nimport { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\n\nexport class CaseExpr extends TypeSysMixin(AbstractNodeList) {\n\n    /* DEFS */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', value: 'CASE' },\n            { type: 'Expr', as: 'subject', optional: true },\n            { type: 'CaseBranch', as: 'entries', arity: { min: 1 }, assert: true, autoIndent: 2 },\n            {\n                optional: true,\n                syntax: [\n                    { type: 'keyword', value: 'ELSE' },\n                    { type: 'Expr', as: 'alternate', autoIndent: true },\n                ],\n                autoSpacing: '\\n',\n            },\n            { type: 'keyword', value: 'END', autoSpacing: '\\n' },\n        ];\n    }\n\n    /* AST API */\n\n    subject() { return this._get('subject'); }\n    \n    branches() { return this.entries(); }\n\n    alternate() { return this._get('alternate'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class CaseBranch extends AbstractNode {\n\n    /* DEFS */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', value: 'WHEN' },\n            { type: 'Expr', as: 'condition' },\n            { type: 'keyword', value: 'THEN' },\n            { type: 'Expr', as: 'consequent' }\n        ];\n    }\n\n    static get syntaxPriority() { return -1; }\n\n    /* AST API */\n\n    condition() { return this._get('condition'); }\n\n    consequent() { return this._get('consequent'); }\n}", "import { AbstractClassicExpr } from '../AbstractClassicExpr.js';\n\nexport class CastExpr extends AbstractClassicExpr {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', value: 'CAST' },\n            {\n                type: 'paren_block',\n                syntax: [\n                    { type: 'Expr', as: 'expr' },\n                    { type: 'keyword', value: 'AS' },\n                    { type: 'DataType', as: 'data_type', assert: true },\n                ],\n                assert: true,\n                autoSpacing: false,\n            }\n        ];\n    }\n\n    /* AST API */\n\n    expr() { return this._get('expr'); }\n\n    dataType() { return this._get('data_type'); }\n}", "import { AbstractClassicExpr } from '../AbstractClassicExpr.js';\nimport { operators } from '../../toktypes.js';\nimport { registry } from '../../registry.js';\n\nexport class BinaryExpr extends AbstractClassicExpr {\n\n    /* DEFS */\n\n    static get syntaxRules() {\n        return [\n            { type: 'Expr', as: 'left', peek: [1, 'operator', ['NOT', undefined/* IMPORTANT */]] },\n            { type: 'operator', as: 'negation', value: 'NOT', booleanfy: true, optional: true },\n            { type: 'operator', as: 'operator' },\n            { type: 'Expr', as: 'right' },\n        ];\n    }\n\n    static get syntaxPriority() { return 0; }\n\n    /* AST API */\n\n    left() { return this._get('left'); }\n\n    negation() { return this._get('negation'); }\n\n    operator() { return this._get('operator'); }\n\n    right() { return this._get('right'); }\n\n    /* TYPESYS API */\n\n    dataType() {\n        const operator = this.operator();\n        if (!operator) return this.left()?.dataType();\n\n        const toDialect = this.options.dialect;\n        const operatorMap = new Map(operators.common.concat(operators[toDialect]));\n        const resultType = operatorMap.get(operator)?.resultType;\n        if (!resultType) return;\n\n        if (resultType === ':right') {\n            return this.right()?.dataType();\n        }\n        if (resultType === ':left') {\n            return this.left()?.dataType();\n        }\n        return registry.DataType.fromJSON({ value: resultType.toUpperCase() });\n    }\n}", "import { BinaryExpr } from '../op/BinaryExpr.js';\n\nexport class ExtractExpr extends BinaryExpr {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', value: 'EXTRACT' },\n            {\n                type: 'paren_block',\n                syntax: [\n                    { type: 'Expr', as: 'left' },\n                    { type: 'keyword', value: 'FROM' },\n                    { type: 'Expr', as: 'right', assert: true },\n                ],\n                autoSpacing: false\n            }\n        ];\n    }\n    \n    /* AST API */\n\n    left() { return this._get('left'); }\n\n    right() { return this._get('right'); }\n}", "import { registry } from '../../registry.js';\nimport { AbstractClassicExpr } from '../AbstractClassicExpr.js';\n\nexport class PredicateExpr extends AbstractClassicExpr {\n\n    /* DEFS */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', as: 'predicate', value: ['EXISTS'] },\n            { type: 'ScalarSubquery', as: 'expr' },\n        ];\n    }\n\n    /* AST API */\n\n    predicate() { return this._get('predicate'); }\n\n    expr() { return this._get('expr'); }\n\n    /* TYPESYS API */\n\n    dataType() { return registry.DataType.fromJSON({ value: 'BOOLEAN' }); }\n}\n", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class QuantitativeExpr extends AbstractNode {\n\n    /* DEFS */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', as: 'quantifier', value: ['ALL', 'ANY', 'SOME'] },\n            {\n                syntaxes: [\n                    { type: 'DerivedQuery', as: 'expr' },\n                    { type: 'paren_block', syntax: { type: 'Expr', as: 'expr' } }\n                ],\n            }\n        ];\n    }\n\n    /* AST API */\n\n    quantifier() { return this._get('quantifier'); }\n\n    expr() { return this._get('expr'); }\n}\n", "import { AbstractClassicExpr } from '../AbstractClassicExpr.js';\n\nexport class AbstractLiteral extends AbstractClassicExpr {\n\n    /* SYNTAX RULES */\n\n    static get syntaxPriority() { return 49; }\n    \n    /* AST API */\n\n    value() { return this._get('value'); }\n}", "import { AbstractLiteral } from './AbstractLiteral.js';\nimport { registry } from '../../registry.js';\n\nexport class BitLiteral extends AbstractLiteral {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() { return { type: 'bit_literal', as: '.' }; }\n\n    /* TYPESYS API */\n\n    dataType() { return registry.DataType.fromJSON({ value: 'BINARY' }); }\n}", "import { AbstractLiteral } from './AbstractLiteral.js';\nimport { registry } from '../../registry.js';\n\nexport class BoolLiteral extends AbstractLiteral {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() { return { type: 'bool_literal', as: '.' }; }\n\n    /* TYPESYS API */\n\n    dataType() { return registry.DataType.fromJSON({ value: 'BOOLEAN' }); }\n}", "import { AbstractLiteral } from './AbstractLiteral.js';\n\nexport class DefaultLiteral extends AbstractLiteral {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() { return { type: 'keyword', as: '.', value: 'DEFAULT' }; }\n}", "import { AbstractLiteral } from './AbstractLiteral.js';\nimport { registry } from '../../registry.js';\n\nexport class HexLiteral extends AbstractLiteral {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() { return { type: 'hex_literal', as: '.' }; }\n\n    /* TYPESYS API */\n\n    dataType() { return registry.DataType.fromJSON({ value: 'BINARY' }); }\n}", "import { AbstractLiteral } from './AbstractLiteral.js';\n\nexport class NullLiteral extends AbstractLiteral {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() { return { type: 'null_literal', as: '.' }; }\n}", "import { AbstractLiteral } from './AbstractLiteral.js';\nimport { registry } from '../../registry.js';\n\nexport class NumberLiteral extends AbstractLiteral {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() { return { type: 'number_literal', as: '.' }; }\n\n    /* TYPESYS API */\n\n    dataType() { return registry.DataType.fromJSON({ value: 'INT' }); }\n}", "import { AbstractLiteral } from './AbstractLiteral.js';\nimport { registry } from '../../registry.js';\n\nexport class StringLiteral extends AbstractLiteral {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() { return { type: 'string_literal', as: '.' }; }\n    \n    /* AST API */\n\n    qualifier() { return this._get('qualifier'); }\n\n    /* TYPESYS API */\n\n    dataType() { return registry.DataType.fromJSON({ value: 'TEXT' }); }\n}", "import { AbstractClassicExpr } from '../AbstractClassicExpr.js';\nimport { registry } from '../../registry.js';\n\nexport class TypedLiteral extends AbstractClassicExpr {\n\n\t/* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'data_type', as: 'data_type' },\n            { type: 'string_literal', as: 'value' },\n        ];\n    }\n\n    static get syntaxPriority() { return 50; }\n\n    /* AST API */\n\n    dataType() { return registry.DataType.fromJSON({ value: this._get('data_type') }); }\n\n    value() { return this._get('value'); }\n}", "import { TypedLiteral } from './TypedLiteral.js';\n\nexport class TypedDateLiteral extends TypedLiteral {\n\n\t/* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'data_type', as: 'data_type', value: 'DATE' },\n            { type: 'string_literal', as: 'value' },\n        ];\n    }\n}", "import { TypedLiteral } from './TypedLiteral.js';\n\nexport class TypedIntervalLiteral extends TypedLiteral {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'data_type', as: 'data_type', value: 'INTERVAL' },\n            {\n                syntaxes: [\n                    { type: 'string_literal', as: 'value' },\n                    { type: 'number_literal', as: 'value', dialect: 'mysql' },\n                ]\n            },\n            {\n                optional: true,\n                syntax: [\n                    { type: 'keyword', as: 'unit', value: ['YEAR', 'MONTH', 'DAY', 'HOUR', 'MINUTE', 'SECOND'] },\n                    {\n                        optional: true,\n                        syntax: [\n                            { type: 'keyword', value: 'TO' },\n                            { type: 'keyword', as: 'to_unit', value: ['YEAR', 'MONTH', 'DAY', 'HOUR', 'MINUTE', 'SECOND'], assert: true },\n                        ]\n                    },\n                ]\n            },\n        ];\n    }\n\n    /* AST API */\n\n    unit() { return this._get('unit'); }\n\n    toUnit() { return this._get('to_unit'); }\n\n    /**\n     * Parse a Postgres/MySQL-style INTERVAL literal into component parts.\n     * Returns an object like { years, months, days, hours, minutes, seconds }\n     */\n    parseInterval() {\n        const val = this._get('value');\n        if (!val) return {};\n\n        let str = '';\n        if (val.type === 'string_literal') {\n            str = val.value.toString().trim();\n        } else if (val.type === 'number_literal') {\n            // MySQL form: INTERVAL 3 HOUR\n            const num = val.value;\n            const unit = (this.unit() || '').toUpperCase();\n            return this.#unitToParts(num, unit);\n        }\n\n        const sign = str.startsWith('-') ? -1 : 1;\n        if (sign === -1) str = str.slice(1).trim();\n\n        const parts = { years: 0, months: 0, days: 0, hours: 0, minutes: 0, seconds: 0 };\n\n        const unit = this.unit() ? this.unit().toUpperCase() : null;\n        const toUnit = this.toUnit() ? this.toUnit().toUpperCase() : null;\n\n        // ----- Handle ranges -----\n        if (unit && toUnit) {\n            const range = `${unit} TO ${toUnit}`;\n\n            switch (range) {\n                case 'YEAR TO MONTH': {\n                    const [y, m] = str.split('-').map(Number);\n                    parts.years = y;\n                    parts.months = m;\n                    return this.#applySign(parts, sign);\n                }\n                case 'DAY TO HOUR': {\n                    const [d, h] = str.split(/\\s+/);\n                    parts.days = Number(d);\n                    parts.hours = Number(h);\n                    return this.#applySign(parts, sign);\n                }\n                case 'DAY TO MINUTE': {\n                    const [d, hm] = str.split(/\\s+/);\n                    parts.days = Number(d);\n                    const [h, m] = hm.split(':').map(Number);\n                    parts.hours = h;\n                    parts.minutes = m;\n                    return this.#applySign(parts, sign);\n                }\n                case 'DAY TO SECOND': {\n                    const [d, hms] = str.split(/\\s+/);\n                    parts.days = Number(d);\n                    const [h, m, s] = hms.split(':').map(Number);\n                    parts.hours = h;\n                    parts.minutes = m;\n                    parts.seconds = s;\n                    return this.#applySign(parts, sign);\n                }\n                case 'HOUR TO MINUTE': {\n                    const [h, m] = str.split(':').map(Number);\n                    parts.hours = h;\n                    parts.minutes = m;\n                    return this.#applySign(parts, sign);\n                }\n                case 'HOUR TO SECOND': {\n                    const [h, m, s] = str.split(':').map(Number);\n                    parts.hours = h;\n                    parts.minutes = m;\n                    parts.seconds = s;\n                    return this.#applySign(parts, sign);\n                }\n                case 'MINUTE TO SECOND': {\n                    const [m, s] = str.split(':').map(Number);\n                    parts.minutes = m;\n                    parts.seconds = s;\n                    return this.#applySign(parts, sign);\n                }\n            }\n        }\n\n        // ----- Fallback: general composite parsing -----\n        const tokens = str.split(/\\s+/);\n\n        for (let i = 0; i < tokens.length; i++) {\n            const token = tokens[i];\n\n            // Time literal HH:MM:SS(.FFF)\n            if (/^\\d{1,2}:\\d{1,2}(:\\d{1,2}(\\.\\d+)?)?$/.test(token)) {\n                const [h, m, s] = token.split(':').map(Number);\n                if (!isNaN(h)) parts.hours += h;\n                if (!isNaN(m)) parts.minutes += m;\n                if (!isNaN(s)) parts.seconds += s;\n                continue;\n            }\n\n            const num = parseFloat(token);\n            if (!isNaN(num)) {\n                const u = (tokens[i + 1] || '').toUpperCase();\n                if (u) {\n                    const mapped = this.#unitToParts(num, u);\n                    for (const [k, v] of Object.entries(mapped)) parts[k] += v;\n                    i++;\n                }\n            }\n        }\n\n        return this.#applySign(parts, sign);\n    }\n\n    #unitToParts(num, unit) {\n        const parts = {};\n        switch (unit) {\n            case 'YEAR': parts.years = num; break;\n            case 'MONTH': parts.months = num; break;\n            case 'DAY': parts.days = num; break;\n            case 'HOUR': parts.hours = num; break;\n            case 'MINUTE': parts.minutes = num; break;\n            case 'SECOND': parts.seconds = num; break;\n            default: break;\n        }\n        return parts;\n    }\n\n    #applySign(parts, sign) {\n        for (const k of Object.keys(parts)) {\n            parts[k] *= sign;\n        }\n        return parts;\n    }\n\n    /**\n     * Apply interval to a base date.\n     */\n    applyToDate(baseDate, dir = 'FOLLOWING') {\n        const parts = this.parseInterval();\n        const d = new Date(baseDate);\n        const sign = dir === 'FOLLOWING' ? 1 : -1;\n\n        if (parts.years) d.setFullYear(d.getFullYear() + sign * parts.years);\n        if (parts.months) d.setMonth(d.getMonth() + sign * parts.months);\n        if (parts.days) d.setDate(d.getDate() + sign * parts.days);\n        if (parts.hours) d.setHours(d.getHours() + sign * parts.hours);\n        if (parts.minutes) d.setMinutes(d.getMinutes() + sign * parts.minutes);\n        if (parts.seconds) d.setSeconds(d.getSeconds() + sign * parts.seconds);\n\n        return d.getTime();\n    }\n}", "import { TypedLiteral } from './TypedLiteral.js';\n\nexport class TypedTimeLiteral extends TypedLiteral {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'data_type', as: 'data_type', value: 'TIME' },\n            { type: 'string_literal', as: 'value' },\n            {\n                optional: true,\n                dialect: 'postgres',\n                syntax: [\n                    { type: 'keyword', as: 'pg_with_tz', value: ['WITH', 'WITHOUT'] },\n                    { type: 'keyword', value: 'TIME ZONE', assert: true },\n                ]\n            },\n        ];\n    }\n\n    /* AST API */\n\n    pgWithTZ() { return this._get('pg_with_tz'); }\n}", "import { TypedLiteral } from './TypedLiteral.js';\n\nexport class TypedTimestampLiteral extends TypedLiteral {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'data_type', as: 'data_type', value: 'TIMESTAMP', dialect: 'postgres' },\n            { type: 'data_type', as: 'data_type', value: ['TIMESTAMP', 'DATETIME'], dialect: 'mysql' },\n            { type: 'string_literal', as: 'value' },\n            {\n                optional: true,\n                dialect: 'postgres',\n                syntax: [\n                    { type: 'keyword', as: 'pg_with_tz', value: ['WITH', 'WITHOUT'] },\n                    { type: 'keyword', value: 'TIME ZONE', assert: true },\n                ]\n            }\n        ];\n    }\n\n    /* AST API */\n\n    pgWithTZ() { return this._get('pg_with_tz'); }\n}", "import { TypedLiteral } from './TypedLiteral.js';\nimport { registry } from '../../registry.js';\n\nexport class TypedTimeZoneLiteral extends TypedLiteral {\n\n\t/* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', value: 'TIME ZONE' },\n            { type: 'Expr', as: 'value' },\n        ];\n    }\n}", "import { AbstractLiteral } from './AbstractLiteral.js';\n\nexport class UnknownLiteral extends AbstractLiteral {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() { return { type: 'unknown_literal', as: '.' }; }\n }", "export const SugarMixin = Class => class extends Class {\n    get isSugar() { return true; }\n}", "import { SugarMixin } from '../../abstracts/SugarMixin.js';\nimport { TypeSysMixin } from '../../abstracts/TypeSysMixin.js';\nimport { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\nimport { registry } from '../../registry.js';\n\nexport class AbstractLQJsonLiteral extends SugarMixin(TypeSysMixin(AbstractNodeList)) {\n\n    dataType() { return registry.DataType.fromJSON({ value: 'JSON' }); }\n}", "import { AbstractLQJsonLiteral } from './AbstractLQJsonLiteral.js';\nimport { registry } from '../../registry.js';\n\nexport class LQArrayLiteral extends AbstractLQJsonLiteral {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return {\n            syntax: [\n                {\n                    type: 'bracket_block',\n                    syntax: { type: 'Expr', as: 'entries', arity: Infinity, itemSeparator, autoIndent: 2 },\n                },\n            ],\n        };\n    }\n\n    static morphsTo() { return registry.CallExpr; }\n\n    /* JSON API */\n\n    jsonfy(options = {}, transformer = null, schemaInference = null) {\n        let resultJson = super.jsonfy(options, transformer, schemaInference);\n        if (options.deSugar) {\n            const resultSchemas = [];\n\n            resultJson = {\n                nodeName: registry.CallExpr.NODE_NAME,\n                name: (options.toDialect || this.options.dialect) === 'mysql' ? 'JSON_ARRAY' : 'JSON_BUILD_ARRAY',\n                arguments: resultJson.entries.map((e, i) => {\n\n                    let resultSchema = e.result_schema;\n                    const schemaIdent = { value: i, nodeName: registry.Identifier.NODE_NAME };\n\n                    if (resultSchema instanceof registry.ColumnSchema) {\n                        resultSchema = resultSchema.clone({ renameTo: schemaIdent });\n                    } else {\n                        resultSchema = registry.ColumnSchema.fromJSON({\n                            name: schemaIdent,\n                            data_type: this.entries()[i].dataType().jsonfy(),\n                        });\n                    }\n                    resultSchemas.push(resultSchema);\n\n                    return e;\n                }),\n                result_schema: registry.JSONSchema.fromJSON({ entries: resultSchemas }, { assert: true })\n            };\n        }\n\n        return resultJson;\n    }\n}", "import { AbstractLQJsonLiteral } from './AbstractLQJsonLiteral.js';\nimport { registry } from '../../registry.js';\nimport { _eq } from '../../abstracts/util.js';\n\nexport class LQObjectLiteral extends AbstractLQJsonLiteral {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return {\n            syntax: [\n                {\n                    type: 'brace_block',\n                    syntax: { type: 'LQObjectProperty', as: 'entries', arity: Infinity, itemSeparator, autoIndent: 3 },\n                },\n            ],\n        };\n    }\n\n    static morphsTo() { return registry.CallExpr; }\n\n    /* JSON API */\n\n    jsonfy(options = {}, transformer = null, schemaInference = null) {\n        let resultJson = super.jsonfy(options, transformer, schemaInference);\n        if (options.deSugar) {\n\n            const entries = resultJson.entries.reduce((result, propertyJson) => {\n                if (propertyJson.star_ref) {\n                    for (const ref of propertyJson.star_ref.result_schema) {\n                        const newPropertyJson = {\n                            key: { value: ref.value(), delim: ref._get('delim') },\n                            value: ref.jsonfy(),\n                        };\n                        result = result.reduce((result, existing) => {\n                            if (_eq(newPropertyJson.key.value, existing.key.value, newPropertyJson.key.delim || existing.key.delim)) {\n                                return result;\n                            }\n                            return result.concat(existing);\n                        }, []);\n                        result = result.concat(newPropertyJson);\n                    }\n                    return result;\n                }\n                return result.concat(propertyJson);\n            }, []);\n\n            const resultSchemas = [];\n\n            resultJson = {\n                nodeName: registry.CallExpr.NODE_NAME,\n                name: (options.toDialect || this.options.dialect) === 'mysql' ? 'JSON_OBJECT' : 'JSON_BUILD_OBJECT',\n                arguments: entries.reduce((args, propertyJson, i) => {\n\n                    let resultSchema = propertyJson.value.result_schema;\n                    const schemaIdent = { ...propertyJson.key, nodeName: registry.Identifier.NODE_NAME };\n\n                    if (resultSchema instanceof registry.ColumnSchema) {\n                        resultSchema = resultSchema.clone({ renameTo: schemaIdent });\n                    } else {\n                        resultSchema = registry.ColumnSchema.fromJSON({\n                            name: schemaIdent,\n                            data_type: this.entries()[i].value()?.dataType().jsonfy() || { nodeName: registry.DataType.NODE_NAME, value: 'TEXT' },\n                        });\n                    }\n                    \n                    resultSchemas.push(resultSchema);\n\n                    return args.concat(\n                        { ...propertyJson.key, nodeName: registry.StringLiteral.NODE_NAME },\n                        { ...propertyJson.value }\n                    );\n\n                }, []),\n                result_schema: registry.JSONSchema.fromJSON({ entries: resultSchemas }, { assert: true })\n            };\n        }\n\n        return resultJson;\n    }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\nimport { registry } from '../../registry.js';\n\nexport class LQObjectProperty extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            syntaxes: [\n                { type: 'ColumnRef0', as: 'star_ref' },\n                [\n                    { type: 'SelectItemAlias', as: 'key' },\n                    {\n                        optional: true,\n                        syntax: [\n                            { type: 'punctuation', value: ':' },\n                            { type: 'Expr', as: 'value', assert: true },\n                        ],\n                        autoSpacing: false,\n                    },\n                ]\n            ]\n        };\n    }\n\n    static get syntaxPriority() { return -1; }\n\n    get isProperty() { return true; }\n\n    /* AST API */\n\n    starRef() { return this._get('star_ref'); }\n\n    key() { return this._get('key'); }\n\n    value() { return this._get('value'); }\n\n    /* DESUGARING API */\n\n    jsonfy(options = {}, transformer = null, schemaInference = null) {\n        if (options.deSugar && !this.starRef()) {\n\n            const keyNode = this.key();\n            let asAggr, keyJson = transformer\n                ? transformer.transform(keyNode, ($options = options) => keyNode.jsonfy($options), 'key', options)\n                : keyNode.jsonfy(options);\n            if (keyJson.is_aggr) ({ is_aggr: asAggr, ...keyJson } = keyJson);\n\n            let valueNode = this.value();\n            if (!valueNode) {\n                valueNode = registry.ColumnRef1.fromJSON({ ...keyJson, nodeName: undefined });\n                this._adoptNodes(valueNode);\n            }\n\n            let defaultTransform;\n\n            if (asAggr && !(valueNode instanceof registry.LQDeepRef1)) {\n                // Note the below where we wrap value in an aggr call\n                defaultTransform = ($options = options, childTransformer = transformer) => ({\n                    nodeName: registry.AggrCallExpr.NODE_NAME,\n                    name: (options.toDialect || this.options.dialect) === 'mysql' ? 'JSON_ARRAYAGG' : 'JSON_AGG',\n                    arguments: [valueNode.jsonfy($options, childTransformer, schemaInference)],\n                });\n            } else {\n                // Note the below where we derive value, if not specified, from key\n                defaultTransform = ($options = options, childTransformer = transformer) => {\n                    return valueNode.jsonfy($options, childTransformer, schemaInference);\n                };\n            }\n\n            const valueJson = transformer\n                ? transformer.transform(valueNode, defaultTransform, 'value', { ...options, asAggr })\n                : defaultTransform();\n\n            // plus, we'll drop the is_aggr flag\n            return {\n                nodeName: LQObjectProperty.NODE_NAME,\n                key: keyJson,\n                value: valueJson\n            };\n        }\n        return super.jsonfy(options, transformer, schemaInference);\n    }\n}", "import { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\nimport { registry } from '../../registry.js';\n\nexport class PGTypedArrayLiteral extends AbstractNodeList {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return {\n            dialect: 'postgres',\n            syntax: [\n                { type: 'keyword', value: 'ARRAY' },\n                {\n                    type: 'bracket_block',\n                    syntax: { type: 'Expr', as: 'entries', arity: Infinity, itemSeparator, autoIndent: 2 },\n                    autoSpacing: false,\n                },\n            ],\n        };\n    }\n\n    static morphsTo() { return registry.CallExpr; }\n\n    /* TYPESYS API */\n\n    dataType() { return registry.DataType.fromJSON({ value: 'JSON' }); }\n\n    /* JSON API */\n\n    jsonfy(options = {}, transformer = null, schemaInference = null) {\n        let resultJson = super.jsonfy(options, transformer, schemaInference);\n        if ((options.toDialect || this.options.dialect) === 'mysql') {\n            resultJson = {\n                nodeName: registry.CallExpr.NODE_NAME,\n                name: 'JSON_ARRAY',\n                arguments: resultJson.entries,\n            };\n        }\n        return resultJson;\n    }\n}", "import { BinaryExpr } from './BinaryExpr.js';\nimport { registry } from '../../registry.js';\n\nexport class AtTimeZoneExpr extends BinaryExpr {\n\n    /* DEFS */\n\n    static get syntaxRules() {\n        return [\n            { type: 'Expr', as: 'left', peek: [1, 'operator', 'AT'] },\n            { type: 'operator', as: 'operator', value: 'AT' },\n            {\n                syntaxes: [\n                    { type: 'TypedTimeZoneLiteral', as: 'right' },\n                    { type: 'keyword', as: 'right', value: 'LOCAL' }\n                ]\n            }\n        ];\n    }\n\n    static get syntaxPriority() { return 0; }\n\n    /* AST API */\n\n    left() { return this._get('left'); }\n\n    right() { return this._get('right'); }\n\n    /* TYPESYS API */\n\n    dataType() { return registry.DataType.fromJSON({ value: 'TIME ZONE' }); }\n}", "import { BinaryExpr } from './BinaryExpr.js';\n\nexport class BetweenExpr extends BinaryExpr {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'operator', value: 'AND' };\n        return [\n            { type: 'Expr', as: 'left', peek: [1, 'operator', ['NOT', 'BETWEEN']] },\n            { type: 'operator', as: 'negation', value: 'NOT', booleanfy: true, optional: true },\n            { type: 'operator', as: 'operator', value: 'BETWEEN' },\n            { type: 'Expr', as: 'right', arity: { min: 2, max: 2, eager: false }, itemSeparator, assert: true },\n        ];\n    }\n}", "import { BinaryExpr } from './BinaryExpr.js';\n\nexport class DistinctFromExpr extends BinaryExpr {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'Expr', as: 'left', peek: [1, 'operator', ['IS', 'IS NOT']] },\n            { type: 'operator', as: 'logic', value: ['IS', 'IS NOT'] },\n            { type: 'operator', as: 'operator', value: 'DISTINCT FROM' },\n            { type: 'Expr', as: 'right', assert: true },\n        ];\n    }\n\n    /* AST API */\n\n    logic() { return this._get('logic'); }\n}", "import { BinaryExpr } from './BinaryExpr.js';\n\nexport class InExpr extends BinaryExpr {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'Expr', as: 'left', peek: [1, 'operator', ['NOT', 'IN']] },\n            { type: 'operator', as: 'negation', value: 'NOT', booleanfy: true, optional: true },\n            { type: 'operator', as: 'operator', value: 'IN' },\n            { type: ['DerivedQuery', 'RowConstructor', 'TypedRowConstructor'], as: 'right', assert: true },\n        ];\n    }\n}", "import { BinaryExpr } from './BinaryExpr.js';\n\nexport class PGCastExpr2 extends BinaryExpr {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            dialect: 'postgres',\n            syntax: [\n                { type: 'Expr', as: 'left', peek: [1, 'operator', '::'] },\n                { type: 'operator', as: 'operator', value: '::', autoSpacing: false },\n                { type: 'DataType', as: 'right', assert: true, autoSpacing: false },\n            ]\n        };\n    }\n\n    /* TYPESYS API */\n\n    expr() { return this.left(); }\n\n    dataType() { return this.right(); }\n}", "import { AbstractClassicExpr } from '../AbstractClassicExpr.js';\nimport { registry } from '../../registry.js';\n\nexport class UnaryExpr extends AbstractClassicExpr {\n\n    /* DEFS */\n\n    static get syntaxRules() {\n        return [\n            { type: 'operator', as: 'operator', value: ['-', '+', 'NOT'] },\n            { type: 'Expr', as: 'operand', autoSpacing: ['NOT'] },\n        ];\n    }\n\n    static get syntaxPriority() { return 1;/* higher than BinaryExpr */ }\n\n    /* AST API */\n\n    operator() { return this._get('operator'); }\n\n    operand() { return this._get('operand'); }\n\n    /* TYPESYS API */\n\n    dataType() {\n        const operator = this.operator();\n        if (!operator) return super.dataType();\n        return registry.DataType.fromJSON({ value: operator === 'NOT' ? 'BOOLEAN' : 'NUMBER' });\n    }\n}", "export class ErrorRefUnknown extends Error {}", "export class ErrorRefAmbiguous extends Error {}", "import { ErrorRefUnknown } from './ErrorRefUnknown.js';\nimport { ErrorRefAmbiguous } from './ErrorRefAmbiguous.js';\nimport { AbstractNode } from '../../../abstracts/AbstractNode.js';\nimport { ResultSchemaMixin } from '../../../abstracts/ResultSchemaMixin.js';\nimport { TypeSysMixin } from '../../../abstracts/TypeSysMixin.js';\nimport { Identifier } from '../Identifier.js';\n\nexport class AbstractClassicRef extends ResultSchemaMixin(TypeSysMixin(Identifier)) {\n\n    #resolution;\n\n    resolution() { return this.#resolution; }\n\n    lookup(transformer, schemaInference) { return []; }\n\n    resolve(transformer, schemaInference) {\n        const resultSet = this.lookup(null, transformer, schemaInference) || [];\n        const objectType = this.constructor.name.match(/schema/i) ? 'Schema' : (this.constructor.name.match(/table/i) ? 'Table' : 'Column');\n        if (resultSet.length > 1) {\n            throw new ErrorRefAmbiguous(`[${this.parentNode?.parentNode || this.parentNode || this}] ${objectType} ${this} is ambiguous. (Is it ${resultSet.join(' or ')}?)`);\n        } else if (!resultSet.length) {\n            throw new ErrorRefUnknown(`[${this.parentNode?.parentNode || this.parentNode || this}] ${objectType} ${this} does not exist.`);\n        }\n        return resultSet[0];\n    }\n\n\tstatic fromJSON(inputJson, options = {}, callback = null) {\n\t\tif (!inputJson || inputJson instanceof AbstractNode) {\n\t\t\treturn super.fromJSON(inputJson, options, callback);\n\t\t}\n\t\tconst { resolution, ...restJson } = inputJson;\n\t\tconst instance = super.fromJSON(restJson, options, callback);\n\t\tif (instance && resolution) {\n\t\t\tif (typeof resolution !== 'string') {\n\t\t\t\tthrow new Error(`Invalid \"resolution\" hint passed at inputJson.resolution`);\n\t\t\t}\n\t\t\tinstance.#resolution = resolution;\n\t\t}\n\t\treturn instance;\n\t}\n\n\tjsonfy(options = {}, transformer = null, schemaInference = null) {\n\t\tlet resultJson = super.jsonfy(options, transformer, schemaInference);\n\t\tif (this.#resolution) {\n\t\t\tresultJson = {\n\t\t\t\t...resultJson,\n\t\t\t\tresolution: this.#resolution,\n\t\t\t};\n\t\t}\n\t\treturn resultJson;\n\t}\n}", "import { AbstractClassicRef } from './abstracts/AbstractClassicRef.js';\nimport { AbstractNode } from '../../abstracts/AbstractNode.js';\nimport { PathMixin } from '../../abstracts/PathMixin.js';\nimport { registry } from '../../registry.js';\n\nexport class ColumnRef1 extends PathMixin(AbstractClassicRef) {\n\n    /* SYNTAX RULES */\n\n    static get _qualifierType() {\n        return [\n            'TableRef1'/* must come first being primary */,\n            'LQBackRefAbstraction'\n        ];\n    }\n\n    static get syntaxRules() {\n        return this.buildSyntaxRules({ type: 'identifier', as: '.', autoSpacing: false });\n    }\n\n    static get syntaxPriority() { return 51; } // above LQBackRefAbstraction\n\n    static morphsTo() { return registry.ColumnRef2; }\n\n    /* API */\n\n    dataType() { return this.resultSchema()?.dataType() || super.dataType(); }\n\n    // ----------------\n\n    canReferenceOutputColumns() {\n        return this.climbTree((parentNode, up) => {\n            if (parentNode instanceof registry.SelectStmt) return false;\n            if (parentNode instanceof registry.GroupByClause) return parentNode;\n            if (parentNode instanceof registry.HavingClause) return parentNode;\n            if (parentNode instanceof registry.OrderByClause) return parentNode;\n            return up();\n        });\n    }\n\n    lookup(deepMatchCallback = null, transformer = null, schemaInference = null) {\n        if (!transformer && !schemaInference) return [];\n\n        const name = this._get('value');\n        const inGrepMode = (!name || name === '*') && !deepMatchCallback;\n        let resultSet = [];\n\n        const resolve = (columnSchema, qualifierJson = undefined, resolution = 'default') => {\n\n            if (!(columnSchema instanceof registry.ColumnSchema)) return false;\n            if (name && name !== '*' && !columnSchema.identifiesAs(this)) return false;\n\n            let result;\n            if (deepMatchCallback && !(result = deepMatchCallback(columnSchema, qualifierJson, resolution))) return false;\n            if (result instanceof AbstractNode || Array.isArray(result)) return result;\n\n            const resultSchema = columnSchema.clone({ normalized: true });\n            columnSchema.parentNode?._adoptNodes(resultSchema);\n\n            const resolvedColumnRef1 = ColumnRef1.fromJSON({\n                ...columnSchema.name().jsonfy({ nodeNames: false }),\n                resolution,\n                qualifier: qualifierJson,\n                result_schema: resultSchema,\n            });\n            this.parentNode._adoptNodes(resolvedColumnRef1);\n\n            return resolvedColumnRef1;\n        };\n\n        // 1. Resolve system refs statically\n        const systemColumns = (this.options.dialect || 'postgres') === 'postgres'\n            ? ['CTID', 'OID', 'XMIN', 'XMAX', 'TABLEOID']\n            : [];\n        if (systemColumns.includes(name?.toUpperCase())) {\n            const columnSchema = registry.ColumnSchema.fromJSON({\n                name: { nodeName: registry.Identifier.NODE_NAME, value: name },\n                data_type: { nodeName: registry.DataType.NODE_NAME, value: 'INT' },\n            }, { assert: true });\n            return [].concat(resolve(columnSchema, undefined, 'system') || []);\n        }\n\n        // 2. Resolve from outputSchemas first?\n        if (this.canReferenceOutputColumns() && transformer) {\n            // Resolve from outputSchemas first\n            let statementContext = transformer.statementContext\n            for (const columnSchema of statementContext.artifacts.get('outputSchemas')) {\n                resultSet = resultSet.concat(resolve(columnSchema, undefined, 'scope') || []);\n                if (!inGrepMode && resultSet.length) break; // Matching current instance only\n            }\n        }\n\n        // 3. Resolve normally\n        if (inGrepMode || !resultSet.length) {\n            // Resolve normally\n            const tempTableRef = new registry.TableRef1(this.qualifier()?.jsonfy() || {});\n            this._adoptNodes(tempTableRef);\n            resultSet = resultSet.concat(tempTableRef.lookup(\n                (tableSchema, qualifierJson = undefined, resolution = undefined) => {\n\n                    return tableSchema._get('entries').reduce((prev, columnSchema) => {\n                        if (tableSchema instanceof registry.JSONSchema) {\n                            // An unaliased derived query\n                            return prev.concat(resolve(columnSchema) || []);\n                        }\n                        const newQualifierJson = {\n                            ...tableSchema.name().jsonfy({ nodeNames: false }),\n                            resolution,\n                            qualifier: qualifierJson,\n                            result_schema: tableSchema,\n                        };\n                        return prev.concat(resolve(columnSchema, newQualifierJson) || []);\n                    }, []);\n\n                },\n                transformer,\n                schemaInference,\n            ));\n        }\n\n        if (name === '*') {\n            const compositeResult = registry.ColumnRef0.fromJSON({\n                value: this.value(),\n                result_schema: registry.JSONSchema.fromJSON({ entries: resultSet.map((s) => s.clone()) }, { assert: true }),\n            });\n            this.parentNode._adoptNodes(compositeResult);\n            resultSet = [compositeResult];\n        }\n\n        return resultSet;\n    }\n\n    jsonfy({ toKind = 1, ...options } = {}, transformer = null, schemaInference = null) {\n        let resultJson;\n        if (options.deSugar && (\n            ((options.deSugar === true || options.deSugar.columnQualifiers) && !this.qualifier())\n            || !this.resultSchema()\n        ) && (transformer || schemaInference)) {\n            // Column qualification or schema resolution...\n            const resolved = this.resolve(transformer, schemaInference);\n            if (resolved.value?.() !== this.value()) {\n                // Resolved from scope\n                return resolved.jsonfy();\n            }\n            resultJson = resolved.jsonfy(/* IMPORTANT */);\n            // Case normalization...\n            if ((options.deSugar === true || options.deSugar.normalizeCasing) && !resultJson.delim) {\n                resultJson = { ...resultJson, value: resultJson.resolution === 'system' ? resultJson.value.toUpperCase() : resultJson.value.toLowerCase() };\n            }\n            // Drop qualifier...\n            if (!(options.deSugar === true || options.deSugar.columnQualifiers) && !this.qualifier()) {\n                resultJson = { ...resultJson, qualifier: undefined };\n            }\n        } else {\n            resultJson = super.jsonfy(options, transformer, schemaInference);\n            if (toKind === 2) {\n                resultJson = {\n                    ...resultJson,\n                    nodeName: registry.ColumnRef2.NODE_NAME,\n                };\n                delete resultJson.qualifier;\n            }\n        }\n        return resultJson;\n    }\n}", "import { ColumnRef1 } from './ColumnRef1.js';\nimport { registry } from '../../registry.js';\n\nexport class ColumnRef0 extends ColumnRef1 {\n\n    /* SYNTAX RULES */\n\n    static get _qualifierType() { return ['TableRef1']; }\n\n    static get syntaxRules() {\n        return this.buildSyntaxRules({ type: 'operator', as: '.', value: '*', autoSpacing: false });\n    }\n\n    static get syntaxPriority() { return -1; }\n\n    /* API */\n\n    dataType() { return registry.DataType.fromJSON({ value: 'SET' }); }\n}", "export class ErrorFKInvalid extends Error {\n\n    constructor(message) {\n        super(message);\n        this.name = 'ErrorFKInvalid';\n    }\n\n}", "import { ErrorFKInvalid } from './ErrorFKInvalid.js';\nimport { SugarMixin } from '../../../abstracts/SugarMixin.js';\nimport { BinaryExpr } from '../../op/BinaryExpr.js';\n\nexport class AbstractMagicRef extends SugarMixin(BinaryExpr) {\n\n    rhsTable(transformer, schemaInference) {\n        const resolveOperand = this.operand()?.resolve(transformer, schemaInference);\n        const fk = resolveOperand.resultSchema()/* ColumnSchema */?.fkConstraint(true);\n        if (!fk) {\n            throw new ErrorFKInvalid(`[${this.parentNode || this}] Column ${this.operand()} is not a foreign key.`);\n        }\n        return fk.targetTable()?.resolve(null/*transformer*/, schemaInference);\n    }\n\n\trhsSchema(transformer, schemaInference) { return this.rhsTable(transformer, schemaInference)?.resultSchema(); }\n}", "import { AbstractClassicRef } from './abstracts/AbstractClassicRef.js';\nimport { AbstractMagicRef } from './abstracts/AbstractMagicRef.js';\nimport { AbstractNode } from '../../abstracts/AbstractNode.js';\nimport { registry } from '../../registry.js';\n\nexport class ColumnRef2 extends AbstractClassicRef {\n\n    /* SYNTAX RULES */\n\n    static get syntaxPriority() { return -1; }\n\n    static morphsTo() { return registry.ColumnRef1; }\n\n    /* SCHEMA API */\n\n    dataType() { return this.resultSchema()?.dataType() || super.dataType(); }\n\n    lookup(deepMatchCallback, transformer = null, schemaInference = null) {\n        if (!transformer && !schemaInference) return [];\n\n        const name = this._get('value');\n        const inGrepMode = !name && !deepMatchCallback;\n        let resultSet = [];\n\n        const resolve = (columnSchema) => {\n            if (!(columnSchema instanceof registry.ColumnSchema)) return false;\n            if (name && !columnSchema.identifiesAs(this)) return false;\n            let result;\n            if (deepMatchCallback && !(result = deepMatchCallback(columnSchema))) return false;\n            if (result instanceof AbstractNode || Array.isArray(result)) return result;\n\n            const resultSchema = columnSchema.clone({ normalized: true });\n            columnSchema.parentNode._adoptNodes(resultSchema);\n\n            const resolvedColumnRef2 = ColumnRef2.fromJSON({\n                ...columnSchema.name().jsonfy({ nodeNames: false }),\n                result_schema: resultSchema\n            });\n            this.parentNode._adoptNodes(resolvedColumnRef2);\n\n            return resolvedColumnRef2;\n        };\n\n        let tableSchemasInScope;\n        if (this.parentNode instanceof AbstractMagicRef) {\n            if (this === this.parentNode.operand()) {\n                tableSchemasInScope = [this.parentNode.parentNode.rhsSchema(transformer, schemaInference)];\n            } else {\n                tableSchemasInScope = [this.parentNode.rhsSchema(transformer, schemaInference)];\n            }\n        } else {\n            tableSchemasInScope = this.climbTree((superParentNode, up) => {\n                if (superParentNode instanceof registry.InsertStmt || superParentNode instanceof registry.UpdateStmt) {\n                    let tableSchemas = [...transformer.statementContext.artifacts.get('tableSchemas')].map((t) => t.resultSchema);\n                    // For UPDATEs, and of cos INSERTs, postgres target columns are resolved from just the target table\n                    if (this.options.dialect !== 'mysql') {\n                        tableSchemas = tableSchemas.slice(0, 1);\n                    }\n                    return tableSchemas;\n                }\n                if (superParentNode instanceof registry.TableSchema) {\n                    return [superParentNode];\n                }\n                return up();\n            });\n        }\n\n        outer: for (const tableSchema of tableSchemasInScope || []) {\n            for (const columnSchema of tableSchema) {\n                resultSet = resultSet.concat(resolve(columnSchema) || []);\n                if (!inGrepMode && resultSet.length) break outer; // Matching current instance only\n            }\n        }\n\n        return resultSet;\n    }\n\n    jsonfy({ toKind = 2, ...options } = {}, transformer = null, schemaInference = null) {\n        if (options.deSugar\n            && !this.resultSchema()\n            && (transformer || schemaInference)) {\n            return this.resolve(transformer, schemaInference).jsonfy(/* IMPORTANT */);\n        }\n        let resultJson = super.jsonfy(options, transformer, schemaInference);\n        if (toKind === 1) {\n            resultJson = {\n                ...resultJson,\n                nodeName: registry.ColumnRef1.NODE_NAME,\n            };\n            delete resultJson.qualifier; // by LQ_BACK_REF_ENDPOINT\n        }\n        return resultJson;\n    }\n}", "import { AbstractMagicRef } from './abstracts/AbstractMagicRef.js';\nimport { registry } from '../../registry.js';\n\nexport class LQBackBackRef extends AbstractMagicRef {\n\n\t/* SYNTAX RULES */\n\n\tstatic get _leftType() {\n\t\treturn [\n\t\t\t'LQBackRefEndpoint'/* must come first to prevent left-recursion */,\n\t\t\t'LQBackBackRef'\n\t\t];\n\t} // for inheritance\n\n\tstatic get syntaxRules() {\n\t\treturn [\n\t\t\t{ type: this._leftType, as: 'left', peek: [1, 'operator', '<~'] },\n\t\t\t{ type: 'operator', value: '<~' },\n\t\t\t{ type: 'ColumnRef2', as: 'right', peek: [1, 'operator', '<~'] },\n\t\t];\n\t}\n\n\tstatic get syntaxPriority() { return 1; }\n\n\tstatic morphsTo() { return [registry.LQDeepRef1, registry.LQDeepRef2, registry.LQDeepDeepRef1, registry.LQDeepDeepRef2]; }\n\n\t/* API */\n\n\toperand() { return this.right(); }\n\n\tendpoint() { return this.left() instanceof LQBackBackRef ? this.left().endpoint() : this.left(); }\n\n\t/* JSON API */\n\n\tjsonfy({ reverseRef = false, toKind = 1, ...options } = {}, transformer = null, schemaInference = null) {\n\t\tif (reverseRef) {\n\t\t\treturn {\n\t\t\t\tnodeName: toKind === 2 \n\t\t\t\t\t? (reverseRef === Infinity ? registry.LQDeepDeepRef2.NODE_NAME : registry.LQDeepRef2.NODE_NAME)\n\t\t\t\t\t: (reverseRef === Infinity ? registry.LQDeepDeepRef1.NODE_NAME : registry.LQDeepRef1.NODE_NAME),\n\t\t\t\tleft: this.right().jsonfy({ toKind: reverseRef !== Infinity ? 1 : 2, ...options }),\n\t\t\t\tright: this.left() instanceof registry.LQBackRefEndpoint\n\t\t\t\t\t? { nodeName: registry.ColumnRef2.NODE_NAME, value: this.left().value(), delim: this.left()._get('delim') }\n\t\t\t\t\t: this.left().jsonfy({ reverseRef: Infinity, toKind, ...options }),\n\t\t\t};\n\t\t}\n\t\treturn super.jsonfy(options, transformer, schemaInference);\n\t}\n}", "import { LQBackBackRef } from './LQBackBackRef.js';\nimport { ErrorFKInvalid } from './abstracts/ErrorFKInvalid.js';\nimport { ErrorRefAmbiguous } from './abstracts/ErrorRefAmbiguous.js';\nimport { ErrorRefUnknown } from './abstracts/ErrorRefUnknown.js';\nimport { registry } from '../../registry.js';\n\nexport class LQBackRef extends LQBackBackRef {\n\n\t/* SYNTAX RULES */\n\n\tstatic get syntaxRules() {\n\t\treturn [\n\t\t\t{ type: this._leftType, as: 'left', peek: [1, 'operator', '<~'] },\n\t\t\t{ type: 'operator', value: '<~' },\n\t\t\t{ type: 'TableRef2', as: 'right' }\n\t\t];\n\t}\n\n\tstatic get syntaxPriority() { return 0; }\n\n\t/* SCHEMA API */\n\n\trhsTable(transformer, schemaInference) {\n\t\tif (!schemaInference) return;\n\t\tconst tableRefs = this.right()?.lookup(null, null/*transformer*/, schemaInference) || [];\n\t\tif (!tableRefs.length) {\n\t\t\tthrow new ErrorRefUnknown(`[${this.parentNode || this}] Implied RHS table ${this.right()} does not exist.`);\n\t\t}\n\t\treturn tableRefs[0];\n\t}\n\n\tresolve(transformer, schemaInference, toKind = 1) {\n\t\tif (!transformer || !schemaInference) return;\n\t\tconst left = this.left();\n\n\t\tconst qualifiedLeftEndpoint = left instanceof LQBackBackRef\n\t\t\t? left.endpoint()\n\t\t\t: left;\n\t\tconst leftEndpointQualifier = qualifiedLeftEndpoint.qualifier();\n\n\t\tconst unqualifiedLeftEndpoint = registry.ColumnRef2.fromJSON({\n\t\t\t...qualifiedLeftEndpoint.jsonfy({ nodeNames: false }),\n\t\t\tqualifier: undefined\n\t\t});\n\n\t\tconst resolvedLeftEndpoint = qualifiedLeftEndpoint/* original */.resolve(transformer, schemaInference);\n\n\t\tconst leftFk = resolvedLeftEndpoint.resultSchema()/* ColumnSchema */.fkConstraint(true);\n\t\tif (!leftFk) throw new ErrorFKInvalid(`[${this.parentNode || this}] Endpoint column ${unqualifiedLeftEndpoint} is not a foreign key.`);\n\t\tconst leftEndpointTable = leftFk.targetTable();\n\n\t\tlet qualifiedLeftOperand;\n\t\tconst resolve = (ddlName, tableSchema) => {\n\t\t\tconst pkColumnRef2 = tableSchema.pkConstraint(true)?.columns()[0]?.resolve(transformer, schemaInference);\n\t\t\tif (!pkColumnRef2) throw new ErrorFKInvalid(`[${this.parentNode || this}] The referenced LHS table ${ddlName} does not have a primary key.`);\n\n\t\t\tconst $qualifiedLeftOperand = registry.ColumnRef1.fromJSON({\n\t\t\t\tqualifier: { ...tableSchema.name().jsonfy({ nodeNames: false }), result_schema: tableSchema },\n\t\t\t\tvalue: pkColumnRef2.value(),\n\t\t\t\tdelim: pkColumnRef2._get('delim'),\n\t\t\t\tresult_schema: pkColumnRef2.resultSchema()\n\t\t\t});\n\n\t\t\tif (qualifiedLeftOperand) throw new ErrorRefAmbiguous(`[${this.parentNode || this}]: The referenced endpoint for foreign key ${unqualifiedLeftEndpoint} is ambiguous. (Is it ${qualifiedLeftOperand} or ${$qualifiedLeftOperand}?)`);\n\t\t\tqualifiedLeftOperand = $qualifiedLeftOperand;\n\t\t};\n\n\t\tlet statementContext = transformer.statementContext\n\t\touter: do {\n\t\t\tfor (const { type, resultSchema: tableSchema } of statementContext.artifacts.get('tableSchemas')) {\n\t\t\t\tif (type === 'CTEItem') continue;\n\t\t\t\tconst ddlName = tableSchema._get('ddl_name') || tableSchema.name(); // Must match leftEndpointTable\n\t\t\t\tif (leftEndpointQualifier) {\n\t\t\t\t\tif (!tableSchema.identifiesAs(leftEndpointQualifier)) continue;\n\t\t\t\t\tif (!leftEndpointTable.identifiesAs(ddlName)) {\n\t\t\t\t\t\tthrow new ErrorFKInvalid(`[${this.parentNode || this}] The endpoint table implied by ${leftEndpointQualifier} (${ddlName}) is not the actual target (${leftEndpointTable}) of the foreign key column ${unqualifiedLeftEndpoint}.`);\n\t\t\t\t\t}\n\t\t\t\t\tresolve(ddlName, tableSchema);\n\t\t\t\t\tbreak outer;\n\t\t\t\t} else if (leftEndpointTable.identifiesAs(ddlName)) {\n\t\t\t\t\tresolve(ddlName, tableSchema);\n\t\t\t\t}\n\t\t\t}\n\t\t} while (!qualifiedLeftOperand && (statementContext = statementContext.parentTransformer?.statementContext))\n\n\t\tif (!qualifiedLeftOperand) {\n\t\t\tthrow new ErrorRefUnknown(`[${this.parentNode || this}] Ref does not correlate with current query.`);\n\t\t}\n\n\t\tconst qualifiedRightTable = this.rhsTable(transformer, schemaInference);\n\t\tconst unqualifiedRightOperand = left instanceof LQBackBackRef\n\t\t\t? left.clone({ reverseRef: true, toKind })\n\t\t\t: unqualifiedLeftEndpoint.constructor.fromJSON({\n\t\t\t\t...unqualifiedLeftEndpoint.jsonfy(),\n\t\t\t\tresult_schema: qualifiedRightTable.resultSchema()._get('entries', unqualifiedLeftEndpoint)\n\t\t\t});\n\n\t\treturn {\n\t\t\tlhsOperand: qualifiedLeftOperand, // ColumnRef1\n\t\t\trhsOperand: unqualifiedRightOperand.clone({ toKind }), // ColumnRef2\n\t\t\trhsTable: qualifiedRightTable, // TableRef2\n\t\t};\n\t}\n}\n", "import { ParenExpr } from '../abstraction/ParenExpr.js';\n\nexport class LQBackRefAbstraction extends ParenExpr {\n\n\t/* SYNTAX RULES */\n\n\tstatic get syntaxRules() {\n\t\treturn {\n\t\t\ttype: 'paren_block',\n\t\t\tsyntaxes: [\n\t\t\t\t{ type: 'Expr', as: 'expr', peek: [1, 'operator', '<~'] }, // (fk <~ fk2 <~ tbl)\n\t\t\t\t{ type: 'Expr', as: 'expr', peek: [2, 'operator', '<~'] }, // ((alias) fk <~ fk2 <~ tbl)\n\t\t\t],\n\t\t};\n\t}\n\n\tstatic get syntaxPriority() { return 51; } // Above RowConstructor\n\n\t/* AST API */\n\n\texpr() { return this._get('expr'); }\n}", "import { ColumnRef2 } from './ColumnRef2.js';\n\nexport class LQBackRefEndpoint extends ColumnRef2 {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n\t\t\t{\n\t\t\t\toptional: true,\n                type: 'paren_block',\n\t\t\t\tsyntax: { type: 'Identifier', as: 'qualifier' },\n\t\t\t},\n\t\t\t{ ...[].concat(super.syntaxRules)[0], peek: [1, 'operator', '<~'] },\n\t\t];\n    }\n\n    static get syntaxPriority() { return 52; } // Above ColumnRef1\n\n    static morphsTo() { return ColumnRef2; }\n    \n    /* API */\n\n    qualifier() { return this._get('qualifier'); }\n}", "import { AbstractMagicRef } from './abstracts/AbstractMagicRef.js';\nimport { registry } from '../../registry.js';\n\nexport class LQDeepDeepRef1 extends AbstractMagicRef {\n\n\t/* SYNTAX RULES */\n\n\tstatic get _rightType() { return ['LQDeepDeepRef1', 'LQObjectLiteral', 'LQArrayLiteral', 'RowConstructor', 'ColumnRef2']; } // for inheritance\n\n\tstatic get syntaxRules() {\n\t\treturn [\n\t\t\t{ type: ['ColumnRef2', 'LQBackRefAbstraction'], as: 'left', peek: [1, 'operator', '~>'] },\n\t\t\t{ type: 'operator', value: '~>' },\n\t\t\t{ type: this._rightType, as: 'right' },\n\t\t];\n\t}\n\n\tstatic get syntaxPriority() { return -1; }\n\n\tstatic morphsTo() { return [registry.LQDeepRef1, registry.LQDeepRef2, registry.LQDeepDeepRef1, registry.LQDeepDeepRef2]; }\n\n\t/* API */\n\n\toperand() { return this.left(); }\n\n\tendpoint() { return this.right() instanceof LQDeepDeepRef1 ? this.right().endpoint() : this.right(); }\n\n\t/* JSON API */\n\n\tjsonfy({ toDeepRef = false, toKind = 1, ...options } = {}, transformer = null, schemaInference = null) {\n\t\tif (toDeepRef || toKind === 1 || toKind === 2) {\n\t\t\tconst altsMap = [\n\t\t\t\tregistry.LQDeepRef1.NODE_NAME, registry.LQDeepRef2.NODE_NAME,\n\t\t\t\tregistry.LQDeepDeepRef1.NODE_NAME, registry.LQDeepDeepRef2.NODE_NAME\n\t\t\t];\n\n\t\t\tlet currentIndex = altsMap.indexOf(this.NODE_NAME);\n\t\t\tif (toDeepRef && currentIndex > 1) {\n\t\t\t\tcurrentIndex -= 2;\n\t\t\t}\n\n\t\t\tconst NODE_NAME = altsMap[(currentIndex + 1) % 2 === toKind % 2\n\t\t\t\t? currentIndex\n\t\t\t\t: (toKind % 2 // its 1 or 3\n\t\t\t\t\t? currentIndex - 1\n\t\t\t\t\t: currentIndex + 1)];\n\n\t\t\treturn {\n\t\t\t\tnodeName: NODE_NAME,\n\t\t\t\tleft: this.left().jsonfy({ toKind: currentIndex > 1 ? 2 : 1 }), // Left is always ColumnRef1 for DeepRef, but ColumnRef2 for DeepDeepRef\n\t\t\t\tright: this.right().jsonfy({ toKind: this.right() instanceof LQDeepDeepRef1 ? toKind : undefined }),\n\t\t\t};\n\t\t}\n\n\t\treturn super.jsonfy(options, transformer, schemaInference);\n\t}\n}", "import { LQDeepDeepRef1 } from './LQDeepDeepRef1.js';\nimport { registry } from '../../registry.js';\n\nexport class LQDeepDeepRef2 extends LQDeepDeepRef1 {\n\n\t/* SYNTAX RULES */\n\n\tstatic get _rightType() { return ['LQDeepDeepRef2', 'ColumnRef2', 'ColumnsConstructor']; } // for inheritance\n\n\t/* JSON API */\n\n\tjsonfy({ toDeepRef = false, toKind = 2, ...options } = {}, transformer = null, schemaInference = null) {\n\t\treturn super.jsonfy({ toDeepRef, toKind, ...options }, transformer = null, schemaInference);\n\t}\n}", "import { LQDeepDeepRef1 } from './LQDeepDeepRef1.js';\nimport { registry } from '../../registry.js';\n\nexport class LQDeepRef1 extends LQDeepDeepRef1 {\n\n\t/* SYNTAX RULES */\n\n\tstatic get syntaxRules() {\n\t\treturn [\n\t\t\t{\n\t\t\t\tsyntaxes: [\n\t\t\t\t\t[\n\t\t\t\t\t\t{ type: ['ColumnRef1', 'LQBackRefAbstraction'], as: 'left', peek: [1, 'operator', '~>'] }, // fk ~> col | (fk2 <~ fk1 <~ tbl) ~> col\n\t\t\t\t\t\t{ type: 'operator', value: '~>' },\n\t\t\t\t\t],\n\t\t\t\t\t[\n\t\t\t\t\t\t{ type: 'ColumnRef1', as: 'left', peek: [3, 'operator', '~>'] }, // tbl.fk ~> col | (fk2 <~ fk1 <~ tbl).fk ~> col\n\t\t\t\t\t\t{ type: 'operator', value: '~>' },\n\t\t\t\t\t]\n\t\t\t\t]\n\t\t\t},\n\t\t\t{ type: this._rightType, as: 'right' },\n\t\t];\n\t}\n\n\tstatic get syntaxPriority() { return 1; }\n\n\t/* API */\n\n\trhsTable(transformer, schemaInference) {\n\t\tif (this.left()?.qualifier?.() instanceof registry.LQBackRefAbstraction) {\n\t\t\treturn this._normalize().rhsTable(transformer, schemaInference);\n\t\t}\n\t\tif (this.left() instanceof registry.LQBackRefAbstraction) {\n\t\t\treturn this.left().expr()/* LQBackRef */.rhsTable(transformer, schemaInference);\n\t\t}\n\t\treturn super.rhsTable(transformer, schemaInference);\n\t}\n\n\t_normalize() {\n\t\tconst left = this.left();\n\t\tconst right = this.right();\n\t\tconst lhsOperandJson = left.qualifier().jsonfy();\n\t\tconst rhsOperandJson = { ...left.jsonfy(), qualifier: undefined, nodeName: registry.ColumnRef2.NODE_NAME };\n\t\tconst deepRef = LQDeepRef1.fromJSON({\n\t\t\tleft: lhsOperandJson,\n\t\t\tright: { nodeName: LQDeepDeepRef1.NODE_NAME, left: rhsOperandJson, right: right.jsonfy() }\n\t\t});\n\t\tthis._adoptNodes(deepRef);\n\t\treturn deepRef;\n\t}\n\n\tresolve(transformer, schemaInference, toKind = 1) {\n\t\tif (!transformer || !schemaInference) return;\n\t\tif (this.left()?.qualifier?.() instanceof registry.LQBackRefAbstraction) {\n\t\t\treturn this._normalize().resolve(transformer, schemaInference, toKind);\n\t\t}\n\n\t\tlet detail;\n\t\tif (this.right() instanceof registry.ColumnRef2) {\n\t\t\tdetail = this.right().clone({ toKind });\n\t\t} else if (this.right() instanceof registry.LQDeepDeepRef1) {\n\t\t\tdetail = this.right().clone({ toDeepRef: true, toKind });\n\t\t} else {\n\t\t\tdetail = this.right();\n\t\t}\n\n\t\tif (this.left() instanceof registry.LQBackRefAbstraction) {\n\t\t\tconst resolution = this.left().expr().resolve(transformer, schemaInference, toKind);\n\t\t\treturn { ...resolution, detail };\n\t\t}\n\n\t\tconst qualifiedLeftOperand = this.left().resolve(transformer, schemaInference);\n\n\t\tconst qualifiedRightTable = this.rhsTable(transformer, schemaInference);\n\n\t\tconst unqualifiedRightOperand = qualifiedRightTable.resultSchema().pkConstraint(true)?.columns()[0]?.resolve(transformer, schemaInference);\n\t\tif (!unqualifiedRightOperand) throw new Error(`[${this.parentNode || this}] The referenced RHS table ${qualifiedRightTable} does not have a primary key.`);\n\n\t\treturn {\n\t\t\tlhsOperand: qualifiedLeftOperand, // ColumnRef1\n\t\t\trhsOperand: unqualifiedRightOperand.clone({ toKind }), // ColumnRef2\n\t\t\trhsTable: qualifiedRightTable, // TableRef2\n\t\t\tdetail,\n\t\t};\n\t}\n}", "import { LQDeepRef1 } from './LQDeepRef1.js';\n\nexport class LQDeepRef2 extends LQDeepRef1 {\n\n\t/* SYNTAX RULES */\n\t\n\tstatic get _rightType() { return ['LQDeepDeepRef2', 'ColumnRef2', 'ColumnsConstructor']; } // for inheritance\n\n\tstatic get syntaxPriority() { return -1; }\n\n\t/* JSON API */\n\n\tresolve(transformer, schemaInference, toKind = 2) {\n\t\treturn super.resolve(transformer, schemaInference, toKind);\n\t}\n\n\tjsonfy({ toDeepRef = false, toKind = 2, ...options } = {}, transformer = null, schemaInference = null) {\n\t\treturn super.jsonfy({ toDeepRef, toKind, ...options }, transformer, schemaInference);\n\t}\n}", "import { AbstractClassicRef } from './abstracts/AbstractClassicRef.js';\nimport { AbstractNode } from '../../abstracts/AbstractNode.js';\nimport { registry } from '../../registry.js';\n\nexport class SchemaRef extends AbstractClassicRef {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'identifier', as: '.' },\n            { type: 'LQVersionSpec', as: 'version_spec', optional: true, autoSpacing: false }\n        ];\n    }\n\n    static get syntaxPriority() { return -1; }\n\n    /* AST API */\n\n    versionSpec() { return this._get('version_spec'); }\n\n    /* API */\n\n    lookup(deepMatchCallback = null, transformer = null, schemaInference = null) {\n        if (!schemaInference) return [];\n\n        const name = this._get('value');\n        const inGrepMode = !name && !deepMatchCallback;\n        let resultSet = [];\n\n        const resolve = (schemaSchema) => {\n            if (!(schemaSchema instanceof registry.SchemaSchema)) return false;\n            if (name && !schemaSchema.identifiesAs(this)) return false;\n            let result;\n            if (deepMatchCallback && !(result = deepMatchCallback(schemaSchema))) return false;\n            if (result instanceof AbstractNode || Array.isArray(result)) return result;\n\n            const resolvedSchemaRef1 = ColumnRef2.fromJSON({\n                ...schemaSchema.name().jsonfy({ nodeNames: false }),\n                ddl_schema: schemaSchema\n            });\n            this.parentNode._adoptNodes(resolvedSchemaRef1);\n\n            return resolvedSchemaRef1;\n        };\n\n        for (const schemaSchema of schemaInference.catalog) {\n            resultSet = resultSet.concat(resolve(schemaSchema) || []);\n            if (!inGrepMode && resultSet.length) break; // Matching current instance only\n        }\n\n        return resultSet;\n    }\n\n    jsonfy(options = {}, transformer = null, schemaInference = null) {\n        let resultJson;\n        if (options.deSugar\n            && !this.resultSchema()\n            && schemaInference) {\n            // Schema resolution...\n            resultJson = this.resolve(transformer, schemaInference).jsonfy(/* IMPORTANT */);\n        } else {\n            resultJson = super.jsonfy(options, transformer, schemaInference);\n        }\n        // Case normalization...\n        if ((options.deSugar === true || options.deSugar?.normalizeCasing) && !resultJson.delim) {\n            resultJson = { ...resultJson, value: resultJson.value.toLowerCase() };\n        }\n        // Drop version specs...\n        if ((options.deSugar === true || options.deSugar?.dropVersionSpecs) && resultJson.version_spec) {\n            resultJson = { ...resultJson, version_spec: undefined };\n        }\n        return resultJson;\n    }\n}\n", "import { AbstractClassicRef } from './abstracts/AbstractClassicRef.js';\nimport { AbstractNode } from '../../abstracts/AbstractNode.js';\nimport { PathMixin } from '../../abstracts/PathMixin.js';\nimport { registry } from '../../registry.js';\n\nexport class TableRef1 extends PathMixin(AbstractClassicRef) {\n\n\t/* SYNTAX RULES */\n\n\tstatic get _qualifierType() { return 'SchemaRef'; }\n\n\tstatic get syntaxRules() {\n\t\treturn this.buildSyntaxRules({\n\t\t\tsyntax: [\n\t\t\t\t{ type: 'identifier', as: '.' },\n\t\t\t\t{ type: 'LQVersionSpec', as: 'version_spec', optional: true, autoSpacing: false }\n\t\t\t],\n\t\t\tautoSpacing: false,\n\t\t});\n\t}\n\n\t/* AST API */\n\n\tversionSpec() { return this._get('version_spec'); }\n\n\t/* API */\n\n\tdataType() { return registry.DataType.fromJSON({ value: 'SET' }); }\n\n\t// ----------------\n\n\tcanReferenceInlineTables() { return true; }\n\n\tlookup(deepMatchCallback = null, transformer = null, schemaInference = null) {\n\t\tif (!transformer && !schemaInference) return [];\n\n\t\tconst name = this._get('value');\n\t\tconst inGrepMode = (!name || name === '*') && (!deepMatchCallback || this.parentNode?.value?.() === '*');\n\n\t\tconst isFromItemRef = this.parentNode instanceof registry.FromItem;\n\t\tconst enclosingDerivedQuery = this.statementNode?.parentNode instanceof registry.DerivedQuery\n\t\t\t? this.statementNode?.parentNode\n\t\t\t: null;\n\t\tconst canTraverseUp = isFromItemRef // Can reference CTE\n\t\t\t|| !enclosingDerivedQuery \n\t\t\t|| !(enclosingDerivedQuery.parentNode instanceof registry.FromItem)\n\t\t\t|| !(enclosingDerivedQuery.parentNode/* FromItem */.parentNode/* FromClause */?.parentNode/* SelectStmt */ instanceof registry.SelectStmt)\n\t\t\t|| enclosingDerivedQuery.parentNode.lateralKW();\n\n\t\tlet resultSet = [];\n\n\t\tconst resolve = (tableSchema, qualifierJson = undefined, resolution = 'default') => {\n\t\t\tif (tableSchema instanceof registry.JSONSchema && (!name || name === '*') && deepMatchCallback) {\n\t\t\t\t// We're trying to resolve a column,\n\t\t\t\t// and this is an \"unaliased\" derived query coming from statementContext.artifacts.get('tableSchemas')\n\t\t\t\treturn deepMatchCallback(tableSchema, qualifierJson, resolution);\n\t\t\t}\n\t\t\tif (!(tableSchema instanceof registry.TableSchema)) return false;\n\t\t\tif (name && name !== '*' && !tableSchema.identifiesAs(this)) return false;\n\n\t\t\tlet result;\n\t\t\tif (deepMatchCallback && !(result = deepMatchCallback(tableSchema, qualifierJson, resolution))) return false;\n\t\t\tif (result instanceof AbstractNode || Array.isArray(result)) return result;\n\n\t\t\tconst resolvedTableRef = this.constructor.fromJSON({\n\t\t\t\t...tableSchema.name().jsonfy({ nodeNames: false }),\n\t\t\t\tresolution,\n\t\t\t\tqualifier: qualifierJson,\n\t\t\t\tresult_schema: tableSchema,\n\t\t\t});\n\t\t\tthis.parentNode?._adoptNodes(resolvedTableRef);\n\n\t\t\treturn resolvedTableRef;\n\t\t};\n\n\t\t// 1. Resolve system refs statically\n\t\tconst systemTableRefs = (this.options.dialect || 'postgres') === 'postgres'\n\t\t\t? ['EXCLUDED']\n\t\t\t: [];\n\t\tif (systemTableRefs.includes(name?.toUpperCase()) && transformer) {\n\t\t\tconst tableSchema = [...transformer.statementContext.artifacts.get('tableSchemas')][0].resultSchema.clone({\n\t\t\t\trenameTo: { nodeName: registry.Identifier.NODE_NAME, value: name },\n\t\t\t});\n\t\t\treturn [].concat(resolve(tableSchema, undefined, 'system') || []);\n\t\t}\n\n\t\t// 2. Resolve from InlineTables first?\n\t\tif (this.canReferenceInlineTables() && transformer) {\n\t\t\tlet statementContext = transformer.statementContext;\n\t\t\tlet originalType, inSuperScopeNow, queryScopes = new Set;\n\t\t\tdo {\n\t\t\t\tinSuperScopeNow = statementContext !== transformer.statementContext;\n\t\t\t\tif (!isFromItemRef) {\n\t\t\t\t\tqueryScopes.add(statementContext);\n\t\t\t\t}\n\t\t\t\tfor (const { type, resultSchema: tableSchema } of statementContext.artifacts.get('tableSchemas')) {\n\t\t\t\t\tif (isFromItemRef) {\n\t\t\t\t\t\tif (type !== 'CTEItem') continue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (type === 'CTEItem') continue;\n\t\t\t\t\t\tif (originalType && originalType !== 'dml' && type === 'dml') {\n\t\t\t\t\t\t\t// The nested SELECT in an \"INSERT ... SELECT\" shouldn't see the INSERT\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!originalType) {\n\t\t\t\t\t\t\toriginalType = type;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tresultSet = resultSet.concat(resolve(\n\t\t\t\t\t\ttableSchema,\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\ttype === 'CTEItem'\n\t\t\t\t\t\t\t? 'cte'\n\t\t\t\t\t\t\t: (inSuperScopeNow ? 'scope' : 'default')\n\t\t\t\t\t) || []);\n\t\t\t\t\tif (resultSet.length && !inGrepMode) {\n\t\t\t\t\t\tfor (const queryScope of queryScopes) {\n\t\t\t\t\t\t\tif (!queryScope.artifacts.has('derivedQueryCorrelationFlag')) continue;\n\t\t\t\t\t\t\tqueryScope.artifacts.set('derivedQueryCorrelationFlag', true);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} while (canTraverseUp && (inGrepMode || !resultSet.length) && (statementContext = statementContext.parentTransformer?.statementContext))\n\t\t}\n\n\t\t// 3. Resolve normally\n\t\tif (!deepMatchCallback/* we're not trying to qualify a column */ && (inGrepMode || !resultSet.length)) {\n\t\t\tconst tempSchemaRef = new registry.SchemaRef(this.qualifier()?.jsonfy() || {});\n            this._adoptNodes(tempSchemaRef);\n\t\t\tresultSet = resultSet.concat(tempSchemaRef.lookup(\n\t\t\t\t(schemaSchema) => {\n\n\t\t\t\t\treturn schemaSchema._get('entries').reduce((prev, tableSchema) => {\n\t\t\t\t\t\t//if (prev.length && !inGrepMode) return prev;\n\t\t\t\t\t\tconst newQualifierJson = {\n\t\t\t\t\t\t\t...schemaSchema.name().jsonfy({ nodeNames: false }),\n\t\t\t\t\t\t\tresult_schema: schemaSchema\n\t\t\t\t\t\t};\n\t\t\t\t\t\treturn prev.concat(resolve(tableSchema, newQualifierJson) || []);\n\t\t\t\t\t}, []);\n\n\t\t\t\t},\n\t\t\t\ttransformer,\n\t\t\t\tschemaInference,\n\t\t\t));\n\t\t}\n\n\t\tif (name === '*') {\n\t\t\tconst compositeResult = registry.TableRef0.fromJSON({\n\t\t\t\tvalue: this.value(),\n\t\t\t\tresult_schema: registry.JSONSchema.fromJSON({ entries: resultSet.map((s) => s.clone()) }, { assert: true }),\n\t\t\t});\n\t\t\tthis.parentNode._adoptNodes(compositeResult);\n\t\t\tresultSet = [compositeResult];\n\t\t}\n\n\t\treturn resultSet;\n\t}\n\n\tjsonfy(options = {}, transformer = null, schemaInference = null) {\n\t\tlet resultJson;\n\t\tif (options.deSugar && (\n\t\t\t((options.deSugar === true || options.deSugar.tableQualifiers) && !this.qualifier())\n\t\t\t|| !this.resultSchema()\n\t\t) && (transformer || schemaInference)) {\n\t\t\t// Table qualification or schema resolution...\n\t\t\tresultJson = this.resolve(transformer, schemaInference).jsonfy(/* IMPORTANT */);\n\t\t\t// Case normalization...\n\t\t\tif ((options.deSugar === true || options.deSugar.normalizeCasing) && !resultJson.delim) {\n\t\t\t\tresultJson = { ...resultJson, value: resultJson.resolution === 'system' ? resultJson.value.toUpperCase() : resultJson.value.toLowerCase() };\n\t\t\t}\n\t\t\t// Drop qualifier...\n\t\t\tif (!(options.deSugar === true || options.deSugar.tableQualifiers) && !this.qualifier()) {\n\t\t\t\tresultJson = { ...resultJson, qualifier: undefined };\n\t\t\t}\n\t\t} else {\n\t\t\tresultJson = super.jsonfy(options, transformer, schemaInference);\n\t\t}\n\t\t// Drop version specs...\n\t\tif ((options.deSugar === true || options.deSugar?.dropVersionSpecs) && resultJson.version_spec) {\n\t\t\tresultJson = { ...resultJson, version_spec: undefined };\n\t\t}\n\t\treturn resultJson;\n\t}\n}", "import { TableRef1 } from './TableRef1.js';\nimport { registry } from '../../registry.js';\n\nexport class TableRef0 extends TableRef1 {\n\n    /* SYNTAX RULES */\n\n    static get _qualifierType() { return ['SchemaRef']; }\n\n    static get syntaxRules() {\n        return this.buildSyntaxRules({ type: 'operator', as: '.', value: '*', autoSpacing: false });\n    }\n\n    static get syntaxPriority() { return -1; }\n\n    /* API */\n\n    dataType() { return registry.DataType.fromJSON({ value: 'SET' }); }\n}", "import { TableRef1 } from './TableRef1.js';\n\nexport class TableRef2 extends TableRef1 {\n\n    canReferenceInlineTables() { return false; }\n}", "import { Identifier } from './Identifier.js';\n\nexport class WindowRef extends Identifier {\n    \n    /* SYNTAX RULES */\n\n    static get syntaxPriority() { return -1; }\n}", "import { AbstractClassicExpr } from '../AbstractClassicExpr.js';\n\nexport class BindVar extends AbstractClassicExpr {\n\n\t/* SYNTAX RULES */\n\n    static get syntaxRules() { return { type: 'bind_var', as: '.' }; }\n\n    /* AST API */\n\n    value() { return this._get('value'); }\n}", "import { AbstractClassicExpr } from '../AbstractClassicExpr.js';\n\nexport class SystemVar extends AbstractClassicExpr {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() { return { type: 'system_var', as: '.' }; }\n\n    /* AST API */\n\n    value() { return this._get('value'); }\n}", "import { AbstractClassicExpr } from '../AbstractClassicExpr.js';\n\nexport class UserVar extends AbstractClassicExpr {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() { return { type: 'user_var', as: '.' }; }\n\n    /* AST API */\n\n    value() { return this._get('value'); }\n}", "import { AbstractClassicExpr } from './AbstractClassicExpr.js';\nimport * as exprs from './index.js';\n\nexport class Expr extends AbstractClassicExpr {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return { type: ExprNamesInOrder, expression: true };\n    }\n\n    /* API */\n\n    static [Symbol.hasInstance](instance) {\n        return instance instanceof AbstractClassicExpr || instance.constructor.name in exprs;\n    }\n}\n\nconst ExprNames = Object.keys(exprs);\nconst ExprNamesInOrder = ExprNames.filter((k) => {\n    return exprs[k] !== Expr && exprs[k].syntaxPriority !== -1;\n}).sort((a, b) => {\n    const comp = (exprs[b].syntaxPriority ?? 100) - (exprs[a].syntaxPriority ?? 100);\n    if (comp === 0) return exprs[b].prototype.isPrototypeOf(exprs[a].prototype) ? -1 : 1;\n    return comp;\n});\n", "import { PathMixin } from '../../abstracts/PathMixin.js';\nimport { Identifier } from '../../expr/index.js';\n\nexport class ColumnIdent extends PathMixin(Identifier) {\n\n    /* SYNTAX RULES */\n\n    static get _qualifierType() { return 'TableRef2'; }\n}", "import { Identifier } from '../../expr/ref/Identifier.js';\n\nexport class SchemaIdent extends Identifier {}\n", "import { PathMixin } from '../../abstracts/PathMixin.js';\nimport { Identifier } from '../../expr/index.js';\n\nexport class TableIdent extends PathMixin(Identifier) {\n\n\t/* SYNTAX RULES */\n\t\n\tstatic get _qualifierType() { return 'SchemaRef'; }\n}", "import { AbstractDiff } from '../../abstracts/AbstractDiff.js';\n\nexport class IndexDiff extends AbstractDiff {}", "import { AbstractSchema } from '../../abstracts/AbstractSchema.js';\n\nexport class IndexSchema extends AbstractSchema {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'Identifier', as: 'name', assert: true },\n        ];\n    }\n}", "import { AbstractDiff } from '../../abstracts/AbstractDiff.js';\n\nexport class SchemaDiff extends AbstractDiff {}", "import { AbstractSchema } from '../../abstracts/AbstractSchema.js';\nimport { registry } from '../../registry.js';\n\nexport class SchemaSchema extends AbstractSchema {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'SchemaIdent', as: 'name', assert: true },\n            {\n                type: 'paren_block',\n                syntax: { type: 'TableSchema', as: 'entries', arity: Infinity, itemSeparator, singletons: 'BY_KEY', autoIndent: true },\n            },\n        ];\n    }\n\n    /* API */\n\n    tables() {\n        const result = [];\n        for (const entry of this) {\n            if (!(entry instanceof registry.TableSchema)) continue;\n            result.push(entry);\n        }\n        return result;\n    }\n}", "import { AbstractDiff } from '../../abstracts/AbstractDiff.js';\n\nexport class TableDiff extends AbstractDiff {}", "import { AbstractSchema } from '../../abstracts/AbstractSchema.js';\nimport { Transformer } from '../../Transformer.js';\nimport { registry } from '../../registry.js';\n\nexport class TableSchema extends AbstractSchema {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        const type = ['TablePKConstraint', 'TableFKConstraint', 'TableUKConstraint', 'PGTableEXConstraint', 'CheckConstraint', 'ColumnSchema'/* must come last */, 'IndexSchema'];\n        return [\n            { type: ['TableIdent', 'Identifier'/* to support mock names */], as: 'name' },\n            {\n                type: 'paren_block',\n                syntaxes: [\n                    { type, as: 'entries', arity: Infinity, itemSeparator, singletons: 'BY_KEY', optional: true, dialect: 'postgres', autoIndent: true },\n                    { type, as: 'entries', arity: { min: 1 }, itemSeparator, singletons: 'BY_KEY', dialect: 'mysql', autoIndent: true },\n                ],\n            },\n        ];\n    }\n\n    /* API */\n\n    columns() {\n        const result = [];\n        for (const entry of this) {\n            if (!(entry instanceof registry.ColumnSchema)) continue;\n            result.push(entry);\n        }\n        return result;\n    }\n\n    pkConstraint(normalized = false) {\n        for (const entry of this) {\n            if (entry instanceof registry.TablePKConstraint) return entry;\n            let pk;\n            if (normalized\n                && entry instanceof registry.ColumnSchema\n                && (pk = entry.pkConstraint())) {\n                const instance = registry.TablePKConstraint.fromJSON({\n                    ...pk.jsonfy(),\n                    nodeName: undefined,\n                    columns: [registry.ColumnRef2.fromJSON({ value: entry.name().value() })]\n                });\n                this._adoptNodes(instance);\n                return instance;\n            }\n        }\n    }\n\n    fkConstraints(normalized = false) {\n        const result = [];\n        for (const entry of this) {\n            if (entry instanceof registry.TableFKConstraint) {\n                result.push(entry);\n            }\n            let fk;\n            if (normalized\n                && entry instanceof registry.ColumnSchema\n                && (fk = entry.fkConstraint())) {\n                const instance = registry.TableFKConstraint.fromJSON({\n                    ...fk.jsonfy(),\n                    nodeName: undefined,\n                    columns: [registry.ColumnRef2.fromJSON({ value: entry.name().value() })]\n                });\n                this._adoptNodes(instance);\n                result.push(instance);\n            }\n        }\n        return result;\n    }\n\n    ukConstraints(normalized = false) {\n        const result = [];\n        for (const entry of this) {\n            if (entry instanceof registry.TableUKConstraint) {\n                result.push(entry);\n            }\n            let uk;\n            if (normalized\n                && entry instanceof registry.ColumnSchema\n                && (uk = entry.ukConstraint())) {\n                const instance = registry.TableUKConstraint.fromJSON({\n                    ...uk.jsonfy(),\n                    nodeName: undefined,\n                    columns: [registry.ColumnRef2.fromJSON({ value: entry.name().value() })]\n                });\n                this._adoptNodes(instance);\n                result.push(instance);\n            }\n        }\n        return result;\n    }\n\n    ckConstraints(normalized = false) {\n        const result = [];\n        for (const entry of this) {\n            if (entry instanceof registry.CheckConstraint) {\n                result.push(entry);\n            }\n            let ck;\n            if (normalized\n                && entry instanceof registry.ColumnSchema\n                && (ck = entry.ckConstraint()?.clone())) {\n                this._adoptNodes(ck);\n                result.push(ck);\n            }\n        }\n        return result;\n    }\n\n    jsonfy({ normalized = false, ...options } = {}, transformer = null, schemaInference = null) {\n        const columnLockedConstraints = [];\n\n        const consMap = {\n            [registry.ColumnPKConstraint.NODE_NAME]: registry.TablePKConstraint.NODE_NAME,\n            [registry.ColumnFKConstraint.NODE_NAME]: registry.TableFKConstraint.NODE_NAME,\n            [registry.ColumnUKConstraint.NODE_NAME]: registry.TableUKConstraint.NODE_NAME,\n            [registry.CheckConstraint.NODE_NAME]: registry.CheckConstraint.NODE_NAME,\n        };\n\n        if (normalized) {\n            transformer = new Transformer((node, defaultTransform) => {\n                if (node?.NODE_NAME in consMap && node.parentNode instanceof registry.ColumnSchema) {\n                    columnLockedConstraints.push({\n                        ...node.jsonfy(),\n                        nodeName: consMap[node.NODE_NAME],\n                        ...(!(node instanceof registry.CheckConstraint) ? { columns: [registry.ColumnRef2.fromJSON({ value: node.parentNode.name().value() })] } : {})\n                    });\n                    return; // Exclude from original column\n                }\n                return defaultTransform();\n            }, transformer);\n        }\n\n        let resultJson = super.jsonfy(options, transformer, schemaInference);\n\n        if (normalized) {\n            resultJson = {\n                ...resultJson,\n                entries: resultJson.entries.concat(columnLockedConstraints)\n            }\n        }\n\n        return resultJson;\n    }\n}", "import { AbstractStmt } from '../abstracts/AbstractStmt.js';\r\n\r\nexport class DDLStmt extends AbstractStmt {\r\n    \r\n\r\n    /* SYNTAX RULES */\r\n\r\n    static get syntaxRules() { return { type: ['CreateSchemaStmt', 'DropSchemaStmt', 'CreateTableStmt', 'DropTableStmt'] }; }\r\n}\r\n", "import { DDLStmt } from './DDLStmt.js';\n\nexport class CreateSchemaStmt extends DDLStmt {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const mameRule = { type: ['SchemaIdent', 'Identifier'/* to support mock names */], as: 'name' };\n        const pgAuthorizationRule = {\n            syntax: [\n                { type: 'keyword', value: 'AUTHORIZATION' },\n                {\n                    syntaxes: [\n                        { type: 'keyword', as: 'pg_authorization', value: ['CURRENT_ROLE', 'CURRENT_USER', 'SESSION_USER'] },\n                        { type: 'Identifier', as: 'pg_authorization' },\n                    ]\n                }\n            ]\n        };\n        const pgOptionalEntiresRule = { type: ['CreateTableStmt'], as: 'pg_entries', arity: Infinity, optional: true, dialect: 'postgres' };\n        return [\n            { type: 'keyword', value: 'CREATE' },\n            { type: 'keyword', value: 'SCHEMA', dialect: 'postgres' },\n            { type: 'keyword', value: ['SCHEMA', 'DATABASE'], dialect: 'mysql' },\n            {\n                dialect: 'postgres',\n                syntaxes: [\n                    [\n                        { type: 'keyword', as: 'if_not_exists', value: 'IF', booleanfy: true },\n                        { type: 'operator', value: 'NOT' },\n                        { type: 'keyword', value: 'EXISTS' },\n                        {\n                            syntaxes: [\n                                [\n                                    { ...mameRule },\n                                    { ...pgAuthorizationRule, optional: true },\n                                ],\n                                { ...pgAuthorizationRule },\n                            ]\n                        }\n                    ],\n                    [\n                        { ...mameRule },\n                        { ...pgAuthorizationRule, optional: true },\n                        { ...pgOptionalEntiresRule }\n                    ],\n                    [\n                        { ...pgAuthorizationRule },\n                        { ...pgOptionalEntiresRule }\n                    ]\n                ]\n            },\n            {\n                dialect: 'mysql',\n                syntax: [\n                    {\n                        optional: true,\n                        syntax: [\n                            { type: 'keyword', as: 'if_not_exists', value: 'IF', booleanfy: true },\n                            { type: 'operator', value: 'NOT' },\n                            { type: 'keyword', value: 'EXISTS' },\n                        ]\n                    },\n                    { ...mameRule },\n                    // TODO: mysql create options (like DEFAULT CHARACTER SET utf8)\n                ]\n            },\n        ];\n    }\n\n    /* AST API */\n\n    ifNotExists() { return this._get('if_not_exists'); }\n\n    name() { return this._get('name'); }\n\n    pgAuthorization() { return this._get('pg_authorization'); }\n\n    pgEntries() { return this._get('pg_entries'); }\n}", "import { DDLStmt } from './DDLStmt.js';\n\nexport class DropSchemaStmt extends DDLStmt {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'keyword', value: 'DROP' },\n            { type: 'keyword', value: 'SCHEMA', dialect: 'postgres' },\n            { type: 'keyword', value: ['SCHEMA', 'DATABASE'], dialect: 'mysql' },\n            {\n                optional: true,\n                syntax: [\n                    { type: 'keyword', as: 'if_exists', value: 'IF', booleanfy: true },\n                    { type: 'keyword', value: 'EXISTS' },\n                ]\n            },\n            { type: ['SchemaIdent', 'Identifier'/* to support mock names */], as: 'pg_names', arity: { min: 1 }, itemSeparator, dialect: 'postgres' },\n            { type: ['SchemaIdent', 'Identifier'/* to support mock names */], as: 'my_name', dialect: 'mysql' },\n            { type: 'keyword', as: 'pg_cascade_rule', value: ['CASCADE', 'RESTRICT'], optional: true, dialect: 'postgres' },\n        ];\n    }\n\n    /* AST API */\n\n    ifExists() { return this._get('if_exists'); }\n\n    pgNames() { return this._get('pg_names'); }\n\n    myName() { return this._get('my_name'); }\n\n    pgCascadeRule() { return this._get('pg_cascade_rule'); }\n}", "import { DDLStmt } from './DDLStmt.js';\n\nexport class CreateTableStmt extends DDLStmt {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', value: 'CREATE' },\n            {\n                optional: true,\n                syntaxes: [\n                    { type: 'keyword', as: 'temporary_kw', value: 'TEMPORARY', booleanfy: true },\n                    { type: 'keyword', as: 'temporary_kw', value: 'TEMP', booleanfy: true, dialect: 'postgres' },\n                ],\n            },\n            { type: 'keyword', value: 'TABLE' },\n            {\n                optional: true,\n                syntax: [\n                    { type: 'keyword', as: 'if_not_exists', value: 'IF', booleanfy: true },\n                    { type: 'operator', value: 'NOT' },\n                    { type: 'keyword', value: 'EXISTS' },\n                ],\n            },\n            { type: 'TableSchema', as: 'argument' },\n            { type: ['ConfigAssignmentExprAlt1', 'ConfigAssignmentExprAlt2'], as: 'my_create_options', arity: Infinity, dialect: 'mysql' }\n        ];\n    }\n\n    /* AST API */\n\n    temporaryKW() { return this._get('temporary_kw'); }\n\n    ifNotExists() { return this._get('if_not_exists'); }\n\n    argument() { return this._get('argument'); }\n\n    myCreateOptions() { return this._get('my_create_options'); }\n}", "import { DDLStmt } from './DDLStmt.js';\n\nexport class DropTableStmt extends DDLStmt {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'keyword', value: 'DROP' },\n            { type: 'keyword', as: 'my_temporary_kw', value: 'TEMPORARY', booleanfy: true, optional: true, dialect: 'mysql' },\n            { type: 'keyword', value: 'TABLE' },\n            {\n                optional: true,\n                syntax: [\n                    { type: 'keyword', as: 'if_exists', value: 'IF', booleanfy: true },\n                    { type: 'keyword', value: 'EXISTS' },\n                ]\n            },\n            { type: ['TableIdent', 'Identifier'/* to support mock names */], as: 'names', arity: { min: 1 }, itemSeparator },\n            { type: 'keyword', as: 'cascade_rule', value: ['CASCADE', 'RESTRICT'], optional: true },\n        ];\n    }\n\n    /* AST API */\n\n    myTemporaryKW() { return this._get('my_temporary_kw'); }\n\n    ifExists() { return this._get('if_exists'); }\n\n    names() { return this._get('names'); }\n\n    cascadeRule() { return this._get('cascade_rule'); }\n}", "export * from './clauses/index.js';\nexport * from './constructors/index.js';\nexport * from './expr/index.js';\nexport * from './TA/index.js';\nexport { DeleteStmt } from './DeleteStmt.js';\nexport { InsertStmt } from './InsertStmt.js';\nexport { MYSetStmt } from './MYSetStmt.js';\nexport { UpdateStmt } from './UpdateStmt.js';\nexport { UpsertStmt } from './UpsertStmt.js';\n", "import { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\n\nexport class MYOnDuplicateKeyUpdateClause extends AbstractNodeList {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return {\n            dialect: 'mysql',\n            syntax: [\n                { type: 'keyword', value: 'ON' },\n                { type: 'keyword', value: 'DUPLICATE' },\n                { type: 'keyword', value: 'KEY' },\n                { type: 'keyword', value: 'UPDATE' },\n                { type: 'AssignmentExpr', as: 'entries', arity: { min: 1 }, itemSeparator, assert: true, autoIndent: true },\n            ]\n        };\n    }\n}", "import { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\n\nexport class MYPartitionClause extends AbstractNodeList {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return {\n            dialect: 'mysql',\n            syntax: [\n                { type: 'keyword', value: 'PARTITION' },\n                { type: 'Identifier', as: 'entries', arity: { min: 1 }, itemSeparator, assert: true }\n            ],\n        };\n    }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class PGConflictTarget extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return {\n            syntaxes: [\n                [\n                    { type: 'keyword', value: 'ON' },\n                    { type: 'keyword', value: 'CONSTRAINT' },\n                    { type: 'Identifier', as: 'constraint_name', assert: true }\n                ],\n                [\n                    {\n                        type: 'paren_block',\n                        syntax: { type: 'PGConflictTargetIndexSpec', as: 'index_list', arity: { min: 1 }, itemSeparator, assert: true },\n                        autoIndent: true,\n                    },\n                    { type: 'WhereClause', as: 'where_clause', optional: true, autoIndent: true },\n                ],\n            ],\n        };\n    }\n\n    /* AST API */\n\n    constraintName() { return this._get('constraint_name'); }\n\n    indexList() { return this._get('index_list'); }\n\n    whereClause() { return this._get('where_clause'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class PGConflictTargetIndexSpec extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            {\n                syntaxes: [\n                    { type: 'ColumnRef2', as: 'column_name' },\n                    { type: 'paren_block', syntax: { type: 'Expr', as: 'expr', assert: true }, autoIndent: true },\n                    { type: 'CallExpr', as: 'expr' }, // Must come after the parens option\n                ],\n            },\n            {\n                optional: true,\n                syntax: [\n                    { type: 'operator', value: 'COLLATE' },\n                    { type: 'string_literal', as: 'collation', assert: true },\n                ],\n            },\n            { type: 'Identifier', as: 'opclass', optional: true },\n        ];\n    }\n\n    /* AST API */\n\n    columnName() { return this._get('column_name'); }\n\n    expr() { return this._get('expr'); }\n\n    collation() { return this._get('collation'); }\n\n    opclass() { return this._get('opclass'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class PGDefaultValuesClause extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            dialect: 'postgres',\n            syntax: [\n                { type: 'keyword', as: '.', value: 'DEFAULT' },\n                { type: 'keyword', value: 'VALUES' },\n            ]\n        };\n    }\n}", "import { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\n\nexport class PGOnConflictClause extends AbstractNodeList {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return {\n            dialect: 'postgres',\n            syntax: [\n                { type: 'keyword', value: 'ON' },\n                { type: 'keyword', value: 'CONFLICT' },\n                {\n                    syntaxes: [\n                        [\n                            { type: 'PGConflictTarget', as: 'conflict_target', optional: true },\n                            { type: 'keyword', as: 'do_nothing_kw', value: 'DO', booleanfy: true },\n                            { type: 'keyword', value: 'NOTHING' },\n                        ],\n                        [\n                            { type: 'PGConflictTarget', as: 'conflict_target' },\n                            { type: 'keyword', value: 'DO' },\n                            { type: 'keyword', value: 'UPDATE' },\n                            { type: 'keyword', value: 'SET' },\n                            { type: 'AssignmentExpr', as: 'entries', arity: { min: 1 }, itemSeparator, assert: true, autoIndent: true },\n                            { type: 'WhereClause', as: 'where_clause', optional: true, autoIndent: true },\n                        ],\n                    ],\n                }\n            ],\n        };\n    }\n\n    /* AST API */\n\n    conflictTarget() { return this._get('conflict_target'); }\n\n    doNothingKW() { return this._get('do_nothing_kw'); }\n\n    whereClause() { return this._get('where_clause'); }\n}", "import { ResultSchemaMixin } from '../../abstracts/ResultSchemaMixin.js';\nimport { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\nimport { registry } from '../../registry.js';\nimport { _eq } from '../../abstracts/util.js';\n\nexport class SelectList extends ResultSchemaMixin(AbstractNodeList) {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return { type: 'SelectItem', as: 'entries', arity: { min: 1 }, itemSeparator, assert: true, autoIndent: 2 };\n    }\n\n    /* JSON API */\n\n    jsonfy(options = {}, transformer = null, schemaInference = null) {\n        let resultJson = super.jsonfy(options, transformer, schemaInference);\n        if (!options.deSugar) return resultJson;\n\n        let resolvedOutputList = [];\n\n        const shouldFlattenUnaliasedRootObjects = (options.deSugar === true || options.deSugar?.flattenUnaliasedRootObjects);\n        const shouldDedupe = false;\n\n        const addOutputItem = (itemJson) => {\n            if (shouldDedupe) {\n                resolvedOutputList = resolvedOutputList.reduce((result, existing) => {\n                    if (itemJson.alias && existing.alias && _eq(itemJson.alias.value, existing.alias.value, itemJson.alias.delim || existing.alias.delim)) {\n                        return result;\n                    }\n                    return result.concat(existing);\n                }, []);\n            }\n            resolvedOutputList = resolvedOutputList.concat(itemJson);\n        };\n\n        for (const [i, selectItemJson] of resultJson.entries.entries()) {\n\n            if (selectItemJson.expr.value === '*') {\n                for (const columnRef of selectItemJson.result_schema) {\n                    const exprJson = columnRef.jsonfy();\n                    const aliasJson = { nodeName: registry.SelectItemAlias.NODE_NAME, as_kw: true, value: exprJson.value, delim: exprJson.delim };\n                    addOutputItem({\n                        nodeName: registry.SelectItem.NODE_NAME,\n                        expr: exprJson,\n                        alias: aliasJson,\n                        result_schema: exprJson.result_schema.clone(),\n                        _originalStarJson: selectItemJson\n                    });\n                }\n            } else if (shouldFlattenUnaliasedRootObjects\n                && this.entries()[i]/* original */.expr() instanceof registry.LQObjectLiteral\n                && !this.entries()[i]/* original */.alias()) {\n                // Start by making pairs of arguments\n                const [argPairs] = selectItemJson.expr.arguments.reduce(([argPairs, key], value) => {\n                    if (!key) return [argPairs, value];\n                    return [[...argPairs, [key, value]]];\n                }, [[]]);\n\n                const resultSchemas = selectItemJson.expr.result_schema.entries();\n\n                for (let i = 0; i < argPairs.length; i++) {\n                    addOutputItem({\n                        nodeName: registry.SelectItem.NODE_NAME,\n                        expr: argPairs[i][1],\n                        alias: { ...argPairs[i][0], nodeName: registry.SelectItemAlias.NODE_NAME, as_kw: true },\n                        result_schema: resultSchemas[i],\n                    });\n                }\n            } else {\n                addOutputItem(selectItemJson);\n            }\n        }\n\n        return {\n            ...resultJson,\n            entries: resolvedOutputList,\n        };\n    }\n\n    finalizeJSON(resultJson, transformer, schemaInference, options) {\n        const shouldDeSugarStars = (options.deSugar === true || options.deSugar?.expandStarRefs);\n        let starsFound;\n\n        const [\n            selectItems,\n            outputSchemas\n        ] = resultJson.entries.reduce(([a, b], { _originalStarJson, ...fieldJson }) => {\n\n            if (_originalStarJson) {\n                starsFound = true;\n            }\n\n            if (_originalStarJson && !shouldDeSugarStars) {\n                if (!_originalStarJson.result_schema) {\n                    _originalStarJson.result_schema = registry.JSONSchema.fromJSON({ entries: [] }, { assert: true });\n                }\n                _originalStarJson.result_schema._add('entries', fieldJson.result_schema);\n                return [\n                    a.concat(_originalStarJson),\n                    b.concat(fieldJson.result_schema.clone())\n                ];\n            }\n\n            if (!fieldJson.result_schema) {\n                const fieldNode = registry.SelectItem.fromJSON(fieldJson, this.options);\n                this._adoptNodes(fieldNode);\n                fieldJson = fieldNode.jsonfy(options, transformer, schemaInference);\n            }\n\n            return [\n                a.concat(fieldJson),\n                b.concat(fieldJson.result_schema.clone())\n            ];\n        }, [[], []]);\n\n        // Apply now\n        resultJson = {\n            ...resultJson,\n            entries: starsFound && !shouldDeSugarStars ? [...new Set(selectItems)] : selectItems,\n            result_schema: registry.JSONSchema.fromJSON({ entries: outputSchemas }, { assert: true }),\n        };\n        transformer.statementContext.artifacts.set('outputSchemas', new Set(outputSchemas));\n\n        return resultJson;\n    }\n}", "import { SelectList } from '../../dql/clauses/SelectList.js';\n\nexport class ReturningClause extends SelectList {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', value: 'RETURNING' },\n            ...[].concat(super.syntaxRules),\n        ];\n    }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class PGWhereCurrentClause extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            dialect: 'postgres',\n            syntax: [\n                { type: 'keyword', value: 'WHERE' },\n                { type: 'keyword', value: 'CURRENT OF' },\n                { type: 'identifier', as: 'cursor_name', assert: true }\n            ]\n        };\n    }\n\n    /* AST API */\n\n    cursorName() { return this._get('cursor_name'); }\n}", "import { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\n\nexport class SetClause extends AbstractNodeList {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'keyword', value: 'SET' },\n            { type: 'AssignmentExpr', as: 'entries', arity: { min: 1 }, itemSeparator, assert: true, autoIndent: 2 },\n        ];\n    }\n}", "import { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\n\nexport class UsingFromClause extends AbstractNodeList {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'keyword', value: 'USING' },\n            { type: 'FromItem', as: 'entries', arity: { min: 1 }, itemSeparator, assert: true }\n        ];\n    }\n}", "import { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\n\nexport class ColumnsConstructor extends AbstractNodeList {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return {\n            syntax: [\n                {\n                    type: 'paren_block',\n                    syntax: { type: ['LQDeepRef2', 'ColumnRef2'], as: 'entries', arity: Infinity, itemSeparator, autoIndent: 10 },\n                },\n            ],\n        };\n    }\n\n    static get syntaxPriority() { return -1; }\n}", "import { ResultSchemaMixin } from '../../abstracts/ResultSchemaMixin.js';\nimport { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\n\nexport class ValuesConstructor extends ResultSchemaMixin(AbstractNodeList) {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return {\n            syntaxes: [\n                [\n                    { type: 'keyword', value: 'VALUES' },\n                    { type: ['TypedRowConstructor', 'RowConstructor'], as: 'entries', arity: { min: 1 }, itemSeparator, assert: true, autoIndent: 2 }\n                ],\n                {\n                    dialect: 'mysql',\n                    syntax: [\n                        { type: 'keyword', value: ['VALUES', 'VALUE'] },\n                        { type: ['TypedRowConstructor', 'RowConstructor'], as: 'entries', arity: { min: 1 }, itemSeparator, assert: true, autoIndent: 2 }\n                    ]\n                },\n            ],\n        };\n    }\n\n    static get syntaxPriority() { return -1; }\n\n    /* JSON API */\n\n    jsonfy(options = {}, transformer = null, schemaInference = null) {\n        let resultJson = super.jsonfy({ ...options, forceDeSugar: options.deSugar }, transformer, schemaInference);\n        if (options.deSugar) {\n            const row1_resultSchema = resultJson.entries?.[0]?.result_schema;\n            resultJson = {\n                ...resultJson,\n                result_schema: row1_resultSchema?.clone()\n            };\n        }\n        return resultJson;\n    }\n}", "import { BinaryExpr } from '../../expr/op/BinaryExpr.js';\n\nexport class AssignmentExpr extends BinaryExpr {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: ['LQDeepRef2', 'ColumnsConstructor', 'ColumnRef2'], as: 'left', dialect: 'postgres' },\n            { type: ['LQDeepRef2', 'ColumnRef1'], as: 'left', dialect: 'mysql' },\n            { type: 'operator', as: 'operator', value: '=' },\n            { type: ['ValuesTableLiteral'/* For deep dimensional inserts */, 'DerivedQuery', 'Expr'], as: 'right' },\n        ];\n    }\n}", "import { BinaryExpr } from '../../expr/op/BinaryExpr.js';\n\nexport class ConfigAssignmentExpr extends BinaryExpr {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', as: 'my_default_kw', value: 'DEFAULT', booleanfy: true, dialect: 'mysql', optional: true },\n            {\n                syntaxes: [\n                    { type: 'keyword', as: 'left' },\n                    { type: 'identifier', as: 'left' },\n                ],\n            },\n            { type: 'operator', as: 'operator', value: '=' },\n            {\n                syntaxes: [\n                    { type: 'Expr', as: 'right' },\n                    { type: 'keyword', as: 'right' },\n                ],\n            }\n        ];\n    }\n\n    /* API */\n\n    myDefaultKW() { return this._get('my_default_kw'); }\n}", "import { BinaryExpr } from '../../expr/op/BinaryExpr.js';\n\nexport class ConfigAssignmentExprAlt1 extends BinaryExpr {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', as: 'my_default_kw', value: 'DEFAULT', booleanfy: true, dialect: 'mysql', optional: true },\n            {\n                syntaxes: [\n                    { type: 'keyword', as: 'left' },\n                    { type: 'identifier', as: 'left' },\n                ],\n            },\n            { type: 'operator', as: 'operator', value: '=', optional: true },\n            {\n                syntaxes: [\n                    { type: 'Expr', as: 'right' },\n                    { type: 'keyword', as: 'right' },\n                ],\n            }\n        ];\n    }\n\n    /* API */\n\n    myDefaultKW() { return this._get('my_default_kw'); }\n}", "import { BinaryExpr } from '../../expr/op/BinaryExpr.js';\n\nexport class ConfigAssignmentExprAlt2 extends BinaryExpr {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', as: 'default_kw', value: 'DEFAULT', booleanfy: true, optional: true },\n            {\n                syntaxes: [\n                    { type: 'keyword', as: 'left' },\n                    { type: 'identifier', as: 'left' },\n                ],\n            },\n            {\n                optional: true,\n                syntax: [\n                    { type: 'operator', as: 'operator', value: '=' },\n                    {\n                        syntaxes: [\n                            { type: 'Expr', as: 'right' },\n                            { type: 'keyword', as: 'right' },\n                        ],\n                    },\n                ],\n            }\n        ];\n    }\n\n    /* API */\n\n    myDefaultKW() { return this._get('my_default_kw'); }\n}", "import { BinaryExpr } from '../../expr/op/BinaryExpr.js';\n\nexport class MYVarAssignmentExpr extends BinaryExpr {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            dialect: 'mysql',\n            syntax: [\n                { type: ['UserVar', 'SystemVar'], as: 'left' },\n                { type: 'operator', as: 'operator', value: ['=', ':='] },\n                { type: 'Expr', as: 'right' },\n            ],\n        };\n    }\n}", "import { ResultSchemaMixin } from '../../abstracts/ResultSchemaMixin.js';\nimport { AbstractNode } from '../../abstracts/AbstractNode.js';\nimport { registry } from '../../registry.js';\n\nexport class TableAbstraction2 extends ResultSchemaMixin(AbstractNode) {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', as: 'pg_only_kw', value: 'ONLY', optional: true, dialect: 'postgres' },\n            { type: 'TableRef1', as: 'table_ref', assert: true },\n            { type: 'operator', as: 'pg_star_ref', value: '*', booleanfy: true, optional: true, dialect: 'postgres' },\n            { type: 'SelectItemAlias', as: 'alias', optional: true },\n        ];\n    }\n\n    /* AST API */\n\n    tableRef() { return this._get('table_ref'); }\n\n    alias() { return this._get('alias'); }\n\n    // -- Postgres\n\n    pgOnlyKW() { return this._get('pg_only_kw'); }\n\n    pgStarRef() { return this._get('pg_star_ref'); }\n\n    /* SCHEMA API */\n\n    deriveAlias() {\n        let derivedAlias;\n        if (this.alias()) {\n            derivedAlias = this.alias();\n        } else {\n            derivedAlias = registry.SelectItemAlias.fromJSON({\n                as_kw: true,\n                value: this.tableRef().value(),\n                delim: this.tableRef()._get('delim'),\n            });\n        }\n        return derivedAlias;\n    }\n\n    jsonfy(options = {}, transformer = null, schemaInference = null) {\n        let resultJson = super.jsonfy(options, transformer, schemaInference);\n        if (options.deSugar) {\n\n            const derivedAliasJson = resultJson.alias || this.deriveAlias().jsonfy();\n\n            const schemaIdent = {\n                nodeName: registry.Identifier.NODE_NAME,\n                value: derivedAliasJson.value,\n                delim: derivedAliasJson.delim,\n            };\n\n            let resultSchema = resultJson.table_ref.result_schema.clone({ renameTo: schemaIdent });\n            if (resultJson.alias) {\n                resultSchema = resultSchema.clone({ renameTo: { nodeName: registry.Identifier.NODE_NAME, value: resultJson.alias.value, delim: resultJson.alias.delim } });\n            }\n\n            transformer.statementContext.artifacts.get('tableSchemas').add({ resultSchema });\n\n            const applicableAliasJson = (options.deSugar === true || options.deSugar?.tableAliases)\n                && derivedAliasJson\n                || resultJson.alias;\n            resultJson = {\n                ...resultJson,\n                alias: applicableAliasJson,\n                result_schema: resultSchema,\n            };\n        }\n\n        return resultJson;\n    }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\nimport { ResultSchemaMixin } from '../../abstracts/ResultSchemaMixin.js';\nimport { registry } from '../../registry.js';\n\nexport class TableAbstraction1 extends ResultSchemaMixin(AbstractNode) {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'TableRef1', as: 'table_ref' },\n            {\n                optional: true,\n                dialect: 'mysql',\n                syntax: [\n                    { type: 'punctuation', value: '.', autoSpacing: false },\n                    { type: 'operator', as: 'my_star_ref', value: '*', booleanfy: true, autoSpacing: false },\n                ],\n            },\n            { type: 'SelectItemAlias', as: 'alias', optional: true },\n        ];\n    }\n\n    /* AST API */\n\n    tableRef() { return this._get('table_ref'); }\n\n    myStarRef() { return this._get('my_star_ref'); }\n\n    alias() { return this._get('alias'); }\n\n    /* SCHEMA API */\n\n    deriveAlias() {\n        let derivedAlias;\n        if (this.alias()) {\n            derivedAlias = this.alias();\n        } else {\n            derivedAlias = registry.SelectItemAlias.fromJSON({\n                as_kw: true,\n                value: this.tableRef().value(),\n                delim: this.tableRef()._get('delim'),\n            });\n        }\n        return derivedAlias;\n    }\n\n    jsonfy(options = {}, transformer = null, schemaInference = null) {\n        let resultJson = super.jsonfy(options, transformer, schemaInference);\n        if (options.deSugar) {\n\n            const derivedAliasJson = resultJson.alias || this.deriveAlias().jsonfy();\n\n            const schemaIdent = {\n                nodeName: registry.Identifier.NODE_NAME,\n                value: derivedAliasJson.value,\n                delim: derivedAliasJson.delim,\n            };\n\n            let resultSchema = resultJson.table_ref.result_schema.clone({ renameTo: schemaIdent });\n            if (resultJson.alias) {\n                resultSchema = resultSchema.clone({ renameTo: { nodeName: registry.Identifier.NODE_NAME, value: resultJson.alias.value, delim: resultJson.alias.delim } });\n            }\n\n            transformer.statementContext.artifacts.get('tableSchemas').add({ resultSchema });\n\n            const applicableAliasJson = (options.deSugar === true || options.deSugar?.tableAliases)\n                && derivedAliasJson\n                || resultJson.alias;\n            resultJson = {\n                ...resultJson,\n                alias: applicableAliasJson,\n                result_schema: resultSchema,\n            };\n        }\n\n        return resultJson;\n    }\n}", "import { Transformer } from '../Transformer.js';\nimport { registry } from '../registry.js';\nimport { _eq } from './util.js';\n\nexport const SelectorStmtMixin = (Class) => class extends Class {\n\n    get isSelectorStmt() { return true; }\n\n    /* DESUGARING API */\n\n    jsonfy(options = {}, transformer = null, schemaInference = null) {\n        if (!options.deSugar) return super.jsonfy(options, transformer, schemaInference);\n\n        const {\n            ColumnRef1,\n            ColumnRef2,\n            AggrCallExpr,\n            LQBackRefAbstraction,\n            LQDeepRef1,\n            LQBackRef,\n        } = registry;\n\n        transformer = new Transformer((node, defaultTransform, keyHint, { deSugar/* EXCLUSION */, asAggr/* EXCLUSION */, ...$options }) => {\n\n            const isSpecialColumnRef1 = (node) => {\n                return node instanceof ColumnRef1\n                    && node.qualifier() instanceof LQBackRefAbstraction;\n            };\n\n            const specialColumnRef1ToDeepRef = (columnRef) => {\n                const lhsOperandJson = columnRef.qualifier().jsonfy();\n                const rhsOperandJson = { ...columnRef.jsonfy(), qualifier: undefined, nodeName: ColumnRef2.NODE_NAME };\n                const deepRef = LQDeepRef1.fromJSON({\n                    left: lhsOperandJson,\n                    right: rhsOperandJson\n                });\n                columnRef.parentNode._adoptNodes(deepRef);\n                return deepRef;\n            };\n\n            const toAggr = (nodeJson) => {\n                return {\n                    nodeName: AggrCallExpr.NODE_NAME,\n                    name: ($options.toDialect || this.options.dialect) === 'mysql' ? 'JSON_ARRAYAGG' : 'JSON_AGG',\n                    arguments: [nodeJson],\n                };\n            };\n\n            // 1. DeSugar special column refs \"(fk <~ tbl).col\" to deep refs\n            if (isSpecialColumnRef1(node)) {\n                node = specialColumnRef1ToDeepRef(node);\n            }\n\n            // 2. DeSugar deep refs to bare column refs\n            if (node instanceof LQDeepRef1) {\n                let { select, detail } = this.createSelectorDimension(node, transformer, schemaInference, { ...$options, asAggr });\n                const detailJson = asAggr\n                    ? toAggr(detail.jsonfy())\n                    : detail.jsonfy();\n                return select(detailJson);\n            }\n\n            // ...and for when we still hit back refs \"fk <~ tbl\"\n            if (node instanceof LQBackRef || node instanceof LQBackRefAbstraction) {\n                if (node instanceof LQBackRefAbstraction) {\n                    node = node.expr();\n                }\n                const { alias } = this.createSelectorDimension(node, transformer, schemaInference, $options);\n                return alias();\n            }\n\n            // Other\n            return defaultTransform();\n        }, transformer, this/* IMPORTANT */);\n\n        return super.jsonfy(options, transformer, schemaInference);\n    }\n\n    createSelectorDimension(LQRef, transformer, schemaInference, { asAggr = false, ...$options } = {}) {\n        const { lhsOperand, rhsOperand, rhsTable, detail } = LQRef.resolve(transformer, schemaInference);\n        const selectorDimensions = transformer.statementContext.artifacts.get('selectorDimensions');\n\n        const {\n            CompleteSelectStmt,\n            DerivedQuery,\n            FromClause,\n            JoinClause,\n            OnClause,\n            GroupByClause,\n            GroupingElement,\n            FromItem,\n            SelectList,\n            SelectItem,\n            FromItemAlias,\n            SelectItemAlias,\n            TableRef1,\n            ColumnRef1,\n            BinaryExpr,\n        } = registry;\n\n        const $dimensionID = `dimension${asAggr ? '/g' : ''}|${[lhsOperand, rhsOperand, rhsTable].join('|')}`;\n        const dimensionID = transformer.statementContext.hash($dimensionID, 'join');\n\n        if (selectorDimensions?.has(dimensionID)) {\n            return { ...selectorDimensions.get(dimensionID), detail };\n        }\n\n        const rands = new Map;\n\n        // Mask \"rhsOperand\"\n        const rhsOperandMask = transformer.rand('key', rands);\n        const rhsOperandJson = rhsOperand.jsonfy();\n        const fieldSpec = {\n            nodeName: SelectItem.NODE_NAME,\n            expr: rhsOperandJson,\n            alias: { nodeName: SelectItemAlias.NODE_NAME, as_kw: true, value: rhsOperandMask },\n        };\n\n        // Compose:\n        // - LEFT JOIN ( SELECT [fieldSpec] FROM <rhsTable> [GROUP BY]? )\n        // - AS <dimensionID>\n        // - ON <dimensionID>.<rhsOperandMask> = <lhsOperand>\n        const joinJson = {\n            nodeName: JoinClause.NODE_NAME,\n            join_type: 'LEFT',\n            expr: {\n                nodeName: DerivedQuery.NODE_NAME,\n                // SELECT <fieldSpec>\n                expr: {\n                    nodeName: CompleteSelectStmt.NODE_NAME,\n                    select_list: { nodeName: SelectList.NODE_NAME, entries: [fieldSpec] },\n                    // FROM <rhsTable>\n                    from_clause: {\n                        nodeName: FromClause.NODE_NAME,\n                        entries: [{ nodeName: FromItem.NODE_NAME, expr: rhsTable.jsonfy({ ...$options, deSugar: null }) }]\n                    },\n                    // GROUP BY <rhsOperandMask>\n                    group_by_clause: asAggr ? {\n                        nodeName: GroupByClause.NODE_NAME,\n                        entries: [{ nodeName: GroupingElement.NODE_NAME, expr: { nodeName: ColumnRef1.NODE_NAME, value: rhsOperandMask } }]\n                    } : undefined,\n                }\n            },\n            // AS <dimensionID>\n            alias: { nodeName: FromItemAlias.NODE_NAME, as_kw: true, value: dimensionID },\n            // ON <dimensionID>.<rhsOperandMask> = <lhsOperand>\n            condition_clause: {\n                nodeName: OnClause.NODE_NAME,\n                expr: {\n                    nodeName: BinaryExpr.NODE_NAME,\n                    operator: '=',\n                    left: lhsOperand.jsonfy({ ...$options, deSugar: null }, transformer, schemaInference),\n                    right: {\n                        nodeName: ColumnRef1.NODE_NAME,\n                        qualifier: { nodeName: TableRef1.NODE_NAME, value: dimensionID },\n                        value: rhsOperandMask\n                    },\n                }\n            },\n        };\n\n        // Join ALias as Table ref...\n        const alias = () => ({ nodeName: TableRef1.NODE_NAME, value: dimensionID });\n\n        // Add entry...\n        const select = (detail) => {\n            const selectAlias = transformer.rand('ref', rands);\n\n            // Compose:\n            // - [...detail] AS <selectAlias>\n            joinJson.expr.expr.select_list.entries.push({\n                nodeName: SelectItem.NODE_NAME,\n                expr: detail,\n                alias: { nodeName: SelectItemAlias.NODE_NAME, as_kw: true, value: selectAlias },\n            });\n\n            return {\n                nodeName: ColumnRef1.NODE_NAME,\n                qualifier: { nodeName: TableRef1.NODE_NAME, value: dimensionID },\n                value: selectAlias,\n            };\n        };\n\n        const selectorDimension = { id: dimensionID, type: 'join', query: joinJson, alias, select, detail };\n\n        selectorDimensions.set(dimensionID, selectorDimension);\n\n        return selectorDimension;\n    }\n\n    finalizeSelectorJSON(resultJson, transformer, schemaInference, options) {\n        let rewrittenJoinEntries;\n        [\n            resultJson,\n            rewrittenJoinEntries,\n        ] = this.preprocessSelectorDimensions(resultJson, transformer, schemaInference, options);\n        \n        resultJson = {\n            ...resultJson,\n            join_clauses: resultJson.join_clauses?.slice(0) || [],\n        };\n\n        for (const joinJson of rewrittenJoinEntries) {\n            const joinNode = registry.JoinClause.fromJSON(joinJson, this.options);\n            this._adoptNodes(joinNode);\n\n            const joinJson2 = transformer.transform(joinNode, ($options = options, childTransformer = transformer) => {\n                return joinNode.jsonfy($options, childTransformer, schemaInference);\n            }, null, options);\n\n            resultJson.join_clauses.push(joinJson2);\n        }\n\n        return resultJson;\n    }\n\n    preprocessSelectorDimensions(resultJson, transformer, schemaInference, options) {\n\n        const selectorDimensions = transformer.statementContext.artifacts.get('selectorDimensions');\n        if (!selectorDimensions.size) {\n            return [resultJson, []];\n        }\n        \n        if (this.options.dialect === 'postgres' && (this instanceof registry.DeleteStmt || this instanceof registry.UpdateStmt)) {\n            if (resultJson.where_clause?.cursor_name) {\n                throw new Error(`Deep/Back Refs are currently not supported with a \"WHERE CURRENT OF...\" statement`);\n            }\n\n            const {\n                DerivedQuery,\n                CompleteSelectStmt,\n                SelectList,\n                SelectItem,\n                FromItemAlias,\n                FromClause,\n                WhereClause,\n                TableRef1,\n                BinaryExpr,\n                FromItem,\n            } = registry;\n\n            const rand = transformer.rand('join');\n\n            // Each table involved in a Deep/BackRef should have a corresponding entry\n            // in the \"FROM\" list where we have the chance to establish our JOIN\n            // with a corresponding extra \"WHERE\" clause that correlates the generated table with the original table\n\n            const tableExpr = resultJson.table_expr;\n\n            const tblAliasOriginal = tableExpr.alias.value;\n            const tblAliasOriginal_delim = tableExpr.alias.delim;\n            const tblAliasRewrite = `${rand}:${tblAliasOriginal}`;\n\n            const pkConstraint = tableExpr.result_schema.pkConstraint(true);\n            const pkColumnRef = pkConstraint?.columns()[0].jsonfy({ toKind: 1 });\n\n            let pgGeneratedFromItem;\n            let pgGeneratedWhereClause\n\n            const createCorrelationExpr = (columnRef) => {\n                return {\n                    nodeName: BinaryExpr.NODE_NAME,\n                    left: {\n                        ...columnRef, qualifier: {\n                            nodeName: TableRef1.NODE_NAME,\n                            value: tblAliasOriginal,\n                            delim: tblAliasOriginal_delim\n                        },\n                    },\n                    operator: '=',\n                    right: {\n                        ...columnRef, qualifier: {\n                            nodeName: TableRef1.NODE_NAME,\n                            value: tblAliasRewrite\n                        },\n                    },\n                };\n            };\n\n            let selectItems;\n            const createOrPatchAFromEntry = (columnRef) => {\n                if (!_eq(columnRef.qualifier.value, tblAliasOriginal, columnRef.qualifier.delim || tblAliasOriginal_delim)) {\n                    return columnRef;\n                }\n\n                if (!pgGeneratedFromItem) {\n                    // Compose:\n                    // - ( SELECT [] FROM <tblRefOriginal> )\n                    // - AS <tblAliasRewrite>\n                    const fromItem = {\n                        nodeName: FromItem.NODE_NAME,\n                        expr: {\n                            nodeName: DerivedQuery.NODE_NAME,\n                            expr: {\n                                // SELECT <...>\n                                nodeName: CompleteSelectStmt.NODE_NAME,\n                                select_list: { nodeName: SelectList.NODE_NAME, entries: [] },\n                                from_clause: {\n                                    // FROM <tblRefOriginal>\n                                    nodeName: FromClause.NODE_NAME,\n                                    entries: [{\n                                        nodeName: FromItem.NODE_NAME,\n                                        expr: tableExpr.table_ref,\n                                    }],\n                                },\n                            },\n                        },\n                        // AS <tblAliasRewrite>\n                        alias: { nodeName: FromItemAlias.NODE_NAME, as_kw: true, value: tblAliasRewrite },\n                    };\n\n                    selectItems = fromItem.expr.expr.select_list.entries;\n\n                    // Compose:\n                    // - WHERE <tblAliasOriginal.colRefOriginal> = <tblAliasRewrite.colRefRewrite>\n                    if (pkColumnRef) {\n                        selectItems.push({\n                            nodeName: SelectItem.NODE_NAME,\n                            expr: pkColumnRef,\n                        });\n                        pgGeneratedWhereClause = {\n                            nodeName: WhereClause.NODE_NAME,\n                            expr: createCorrelationExpr(pkColumnRef),\n                        };\n                    }\n                    // Declare entry...\n                    pgGeneratedFromItem = fromItem;\n                }\n\n                // 1. Select the rewritten ref\n                if (!selectItems.find((fieldJson) => _eq(fieldJson.expr.value, columnRef.value, fieldJson.expr.delim || columnRef.delim))) {\n                    selectItems.push({ nodeName: SelectItem.NODE_NAME, expr: columnRef });\n                }\n\n                // 2. Use ewritten ref for correlation in the absence of a primary key\n                if (!pkColumnRef) {\n                    let whereExpr = createCorrelationExpr(columnRef);\n                    if (pgGeneratedWhereClause) {\n                        whereExpr = {\n                            nodeName: BinaryExpr.NODE_NAME,\n                            left: pgGeneratedWhereClause.expr,\n                            operator: 'AND',\n                            right: whereExpr\n                        };\n                    }\n                    pgGeneratedWhereClause = {\n                        nodeName: WhereClause.NODE_NAME,\n                        expr: whereExpr,\n                    };\n                }\n\n                return {\n                    ...columnRef,\n                    qualifier: { nodeName: TableRef1.NODE_NAME, value: tblAliasRewrite },\n                };\n            };\n\n            // (1)\n            // Rewrite original references to FROM entry references\n            const rewrittenJoinEntries = [];\n            for (const [, { query: joinJson }] of selectorDimensions) {\n                rewrittenJoinEntries.push({\n                    ...joinJson,\n                    condition_clause: {\n                        ...joinJson.condition_clause,\n                        expr: {\n                            ...joinJson.condition_clause.expr,\n                            left: createOrPatchAFromEntry(joinJson.condition_clause.expr.left)\n                        },\n                    },\n                });\n            }\n\n            // (2)\n            // Inject the \"FROM\" list generated by createOrPatchAFromEntry()\n            const [fromClause, fromClauseClass] = this instanceof registry.DeleteStmt\n                ? ['pg_using_clause', 'UsingFromClause']\n                : ['pg_from_clause', 'FromClause'];\n\n            if (pgGeneratedFromItem) {\n                const fromItemNode = FromItem.fromJSON(pgGeneratedFromItem, this.options);\n                this._adoptNodes(fromItemNode);\n\n                resultJson = {\n                    ...resultJson,\n                    [fromClause]: {\n                        nodeName: registry[fromClauseClass].NODE_NAME,\n                        entries: (resultJson[fromClause]?.entries || []).concat(\n                            fromItemNode.jsonfy(options, transformer, schemaInference)\n                        ),\n                    },\n                    where_clause: !resultJson.where_clause ? pgGeneratedWhereClause : {\n                        nodeName: WhereClause.NODE_NAME,\n                        expr: {\n                            nodeName: BinaryExpr.NODE_NAME,\n                            left: pgGeneratedWhereClause.expr,\n                            operator: 'AND',\n                            right: resultJson.where_clause.expr,\n                        },\n                    },\n                };\n            }\n\n            return [\n                resultJson,\n                rewrittenJoinEntries,\n            ];\n        }\n\n        return [\n            resultJson,\n            [...selectorDimensions].map(([, { query: joinJson }]) => joinJson),\n        ];\n    }\n}\n", "import { AbstractNonDDLStmt } from '../abstracts/AbstractNonDDLStmt.js';\r\nimport { registry } from '../registry.js';\r\n\r\nexport class DMLStmt extends AbstractNonDDLStmt {\r\n\r\n    /* SYNTAX RULES */\r\n\r\n    static get syntaxRules() { return { type: ['InsertStmt', 'UpsertStmt', 'UpdateStmt', 'DeleteStmt'] }; }\r\n\r\n    finalizeOutputJSON(resultJson, transformer, schemaInference, options) {\r\n\r\n        if (resultJson.returning_clause) {\r\n            // 1. Re-resolve output list for cases of just-added deep refs in returning_clause\r\n            // wherein schemas wouldn't have been resolvable at the time\r\n            // 2. Finalize output list for the last time, honouring given deSugaring level with regards to star selects \"*\"\r\n            // and ofcos finalize output schemas\r\n            const returningClauseJson = this.returningClause().finalizeJSON(resultJson.returning_clause, transformer, schemaInference, options);\r\n            // Apply now\r\n            resultJson = {\r\n                ...resultJson,\r\n                returning_clause: returningClauseJson,\r\n                result_schema: returningClauseJson.result_schema,\r\n            };\r\n        } else {\r\n            resultJson = {\r\n                ...resultJson,\r\n                result_schema: registry.JSONSchema.fromJSON({ entries: [] }, this.options),\r\n            };\r\n        }\r\n\r\n        return resultJson;\r\n    }\r\n}\r\n", "import { SelectorStmtMixin } from '../abstracts/SelectorStmtMixin.js';\nimport { Transformer } from '../Transformer.js';\nimport { DMLStmt } from './DMLStmt.js';\n\nexport class DeleteStmt extends SelectorStmtMixin(DMLStmt) {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'keyword', value: 'DELETE' },\n            {\n                assert: true,\n                syntaxes: [\n                    {\n                        dialect: 'postgres',\n                        syntax: [\n                            { type: 'keyword', value: 'FROM' },\n                            { type: 'TableAbstraction2', as: 'table_expr' },\n                            { type: 'UsingFromClause', as: 'pg_using_clause', optional: true, autoIndent: true },\n                            { type: 'JoinClause', as: 'join_clauses', arity: Infinity, optional: true, autoIndent: true },\n                            { type: ['PGWhereCurrentClause', 'WhereClause'], as: 'where_clause', optional: true, autoIndent: true },\n                            { type: 'ReturningClause', as: 'returning_clause', optional: true, autoIndent: true },\n                        ],\n                    },\n                    {\n                        dialect: 'mysql',\n                        syntax: [\n                            { type: 'Identifier', as: 'my_delete_list', arity: { min: 1 }, itemSeparator },\n                            { type: 'FromClause', as: 'my_from_clause', autoIndent: true },\n                            { type: 'JoinClause', as: 'join_clauses', arity: Infinity, optional: true, autoIndent: true },\n                            { type: 'WhereClause', as: 'where_clause', optional: true, autoIndent: true },\n                        ],\n                    },\n                    {\n                        dialect: 'mysql',\n                        syntax: [\n                            { type: 'keyword', value: 'FROM' },\n                            { type: 'Identifier', as: 'my_delete_list', arity: { min: 1 }, itemSeparator },\n                            { type: 'UsingFromClause', as: 'my_using_clause', autoIndent: true },\n                            { type: 'JoinClause', as: 'join_clauses', arity: Infinity, optional: true, autoIndent: true },\n                            { type: 'WhereClause', as: 'where_clause', optional: true, autoIndent: true },\n                        ],\n                    },\n                    {\n                        dialect: 'mysql',\n                        syntax: [\n                            { type: 'keyword', value: 'FROM' },\n                            { type: 'TableAbstraction2', as: 'table_expr' },\n                            { type: 'MYPartitionClause', as: 'my_partition_clause', optional: true, autoIndent: true },\n                            { type: 'WhereClause', as: 'where_clause', optional: true, autoIndent: true },\n                            { type: 'OrderByClause', as: 'my_order_by_clause', optional: true, dialect: 'mysql', autoIndent: true },\n                            { type: 'LimitClause', as: 'my_limit_clause', optional: true, dialect: 'mysql', autoIndent: true },\n                        ],\n                    }\n                ],\n            },\n        ];\n    }\n\n    /* AST API */\n\n    tableExpr() { return this._get('table_expr'); }\n\n    joinClauses() { return this._get('join_clauses'); }\n\n    whereClause() { return this._get('where_clause'); }\n\n    returningClause() { return this._get('returning_clause'); }\n\n    // -- Postgres\n\n    pgUsingClause() { return this._get('pg_using_clause'); }\n\n    // -- MySQL\n\n    myUsingClause() { return this._get('my_using_clause'); }\n\n    myPartitionClause() { return this._get('my_partition_clause'); }\n\n    myDeleteList() { return this._get('my_delete_list'); }\n\n    myFromClause() { return this._get('my_from_clause'); }\n\n    myOrderByClause() { return this._get('my_order_by_clause'); }\n\n    myLimitClause() { return this._get('my_limit_clause'); }\n\n    /* JSON API */\n\n    jsonfy(options = {}, transformer = null, schemaInference = null) {\n        if (!options.deSugar) return super.jsonfy(options, transformer, schemaInference);\n\n        transformer = new Transformer((node, defaultTransform) => {\n            return defaultTransform();\n        }, transformer, this/* IMPORTANT */);\n\n        let resultJson = super.jsonfy(options, transformer, schemaInference);\n\n        // Order ouput JSON\n        if ((options.toDialect || this.options.dialect) === 'mysql') {\n            resultJson = {\n                uuid: resultJson.uuid,\n                nodeName: resultJson.nodeName,\n                my_delete_list: resultJson.my_delete_list,\n                my_from_clause: resultJson.my_from_clause,\n                my_using_clause: resultJson.my_using_clause,\n                join_clauses: resultJson.join_clauses,\n                where_clause: resultJson.where_clause,\n                // last syntax\n                table_expr: resultJson.table_expr,\n                my_partition_clause: resultJson.my_partition_clause,\n                my_order_by_clause: resultJson.my_order_by_clause,\n                my_limit_clause: resultJson.my_limit_clause,\n                // Both...\n                returning_clause: resultJson.returning_clause,\n                result_schema: resultJson.result_schema,\n            };\n        } else {\n            resultJson = {\n                uuid: resultJson.uuid,\n                nodeName: resultJson.nodeName,\n                table_expr: resultJson.table_expr,\n                pg_using_clause: resultJson.pg_using_clause,\n                join_clauses: resultJson.join_clauses,\n                where_clause: resultJson.where_clause,\n                returning_clause: resultJson.returning_clause,\n                result_schema: resultJson.result_schema,\n            };\n        }\n\n        // 1. Finalize output JSON\n\t\tresultJson = this.finalizeOutputJSON(resultJson, transformer, schemaInference, options);\n        // 2. Finalize generated JOINS\n        resultJson = this.finalizeSelectorJSON(resultJson, transformer, schemaInference, options);\n        \n        resultJson = {\n\t\t\t...resultJson,\n\t\t\torigin_schemas: this.getOriginSchemas(transformer),\n\t\t};\n        \n        return resultJson;\n    }\n}", "import { Transformer } from '../Transformer.js';\nimport { registry } from '../registry.js';\nimport { _eq } from './util.js';\n\nexport const PayloadStmtMixin = (Class) => class extends Class {\n\n\tget isPayloadStmt() { return true; }\n\n\tstatic morphsTo() { return registry.CTE; }\n\n\t/* DESUGARING API */\n\n\tjsonfy(options = {}, transformer = null, schemaInference = null) {\n\t\tif (!options.deSugar) return super.jsonfy(options, transformer, schemaInference);\n\n\t\tconst {\n\t\t\tLQDeepRef2,\n\t\t\tAssignmentExpr,\n\t\t\tDerivedQuery,\n\t\t\tColumnsConstructor,\n\t\t\tValuesConstructor,\n\t\t\tTypedRowConstructor,\n\t\t\tRowConstructor,\n\t\t} = registry;\n\n\t\tconst specials = ['column_list', 'pg_default_values_clause', 'values_clause', 'select_clause'].map((s) => this._get(s));\n\t\tconst [columnList, pgDefaultValuesClause, valuesClause, selectClause] = specials;\n\t\tconst hasTopLevelDeepRefs = columnList?.entries().some((c) => c instanceof LQDeepRef2);\n\n\t\t// --- ASSIGNMENT EXPRS ---------------\n\n\t\tconst ignoreList = hasTopLevelDeepRefs ? new Set(specials) : new Set;\n\t\ttransformer = new Transformer((node, defaultTransform, keyHint, { deSugar/* EXCLUSION */, ...$options }) => {\n\n\t\t\t// IMPORTANT!!! The bellow tells the default jsonfier to ignore the nodes we'll handle manually\n\t\t\tif (ignoreList.has(node)) {\n\t\t\t\treturn; // Exclude in output\n\t\t\t}\n\n\t\t\t// We want to only desugar AssignmentExpr\n\t\t\tif (!(node instanceof AssignmentExpr)) {\n\t\t\t\treturn defaultTransform();\n\t\t\t}\n\n\t\t\t// Is this assignment expr from within \"conflict_handling_clause\"?\n\t\t\tconst conflictHandlingClauseContext = !!this._get('conflict_handling_clause')?.containsNode(node);\n\t\t\tif (conflictHandlingClauseContext && this.options.dialect !== 'postgres') {\n\t\t\t\treturn defaultTransform();\n\t\t\t}\n\n\t\t\tconst $$options = { ...$options, conflictHandlingClauseContext };\n\n\t\t\t// Handle bare assignment exoressions\n\t\t\tif (node.left() instanceof LQDeepRef2) {\n\t\t\t\tconst [[deSugaredLhs], [[deSugaredRhs]]] = this.deSugarPayload(\n\t\t\t\t\tColumnsConstructor.fromJSON({ entries: [node.left().jsonfy()] }),\n\t\t\t\t\t[[node.right()]],\n\t\t\t\t\ttransformer,\n\t\t\t\t\tschemaInference,\n\t\t\t\t\t$$options,\n\t\t\t\t);\n\t\t\t\tif (!deSugaredLhs) return; // Exclude in output\n\t\t\t\treturn {\n\t\t\t\t\tnodeName: AssignmentExpr.NODE_NAME,\n\t\t\t\t\toperator: '=',\n\t\t\t\t\tleft: deSugaredLhs,\n\t\t\t\t\tright: deSugaredRhs,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Handle compound assignment exoressions\n\t\t\tif (node.left() instanceof ColumnsConstructor // Postgres\n\t\t\t\t&& node.left().entries().some((c) => c instanceof LQDeepRef2)) {\n\n\t\t\t\tconst columnList = node.left();\n\t\t\t\tlet deSugaredLhs,\n\t\t\t\t\tdeSugaredRhs;\n\n\t\t\t\tif (node.right() instanceof RowConstructor/* Still passes even for TypedRowConstructor */) {\n\t\t\t\t\t[deSugaredLhs, [deSugaredRhs]] = this.deSugarPayload(\n\t\t\t\t\t\tcolumnList,\n\t\t\t\t\t\t[node.right().entries()],\n\t\t\t\t\t\ttransformer,\n\t\t\t\t\t\tschemaInference,\n\t\t\t\t\t\t$$options,\n\t\t\t\t\t);\n\t\t\t\t\tdeSugaredRhs = { nodeName: TypedRowConstructor.NODE_NAME/* To be really formal */, entries: deSugaredRhs };\n\t\t\t\t} else if (node.right() instanceof DerivedQuery) {\n\t\t\t\t\t[deSugaredLhs, deSugaredRhs] = this.deSugarPayload(\n\t\t\t\t\t\tcolumnList,\n\t\t\t\t\t\tnode.right().expr(),\n\t\t\t\t\t\ttransformer,\n\t\t\t\t\t\tschemaInference,\n\t\t\t\t\t\t$$options,\n\t\t\t\t\t);\n\t\t\t\t\tdeSugaredRhs = { nodeName: DerivedQuery.NODE_NAME, expr: deSugaredRhs };\n\t\t\t\t} else {\n\t\t\t\t\t[deSugaredLhs, [deSugaredRhs]] = this.deSugarPayload(\n\t\t\t\t\t\tcolumnList,\n\t\t\t\t\t\t[[node.right()]],\n\t\t\t\t\t\ttransformer,\n\t\t\t\t\t\tschemaInference,\n\t\t\t\t\t\t$$options,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif (!deSugaredLhs.length) return; // Exclude in output\n\t\t\t\treturn {\n\t\t\t\t\tnodeName: AssignmentExpr.NODE_NAME,\n\t\t\t\t\toperator: '=',\n\t\t\t\t\tleft: { nodeName: ColumnsConstructor.NODE_NAME, entries: deSugaredLhs },\n\t\t\t\t\tright: deSugaredRhs,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn defaultTransform();\n\t\t}, transformer, this/* IMPORTANT */);\n\n\t\t// Base JSON\n\t\tlet resultJson = super.jsonfy(options, transformer, schemaInference);\n\n\t\t// --- TOP-LEVEL COLUMNS:VALUES/SELECT ---------------\n\n\t\t// Manually jsonfy these\n\t\tif (hasTopLevelDeepRefs) {\n\t\t\tconst [deSugaredLhs, deSugaredRhs] = this.deSugarPayload(\n\t\t\t\tcolumnList,\n\t\t\t\tpgDefaultValuesClause || valuesClause?.entries().map((rowSet) => rowSet.entries()) || selectClause,\n\t\t\t\ttransformer,\n\t\t\t\tschemaInference,\n\t\t\t\toptions,\n\t\t\t);\n\n\t\t\tresultJson = {\n\t\t\t\t...resultJson,\n\t\t\t\tcolumn_list: { nodeName: ColumnsConstructor.NODE_NAME, entries: deSugaredLhs },\n\t\t\t};\n\n\t\t\tif (pgDefaultValuesClause && Array.isArray(deSugaredRhs) || valuesClause) {\n\t\t\t\tconst rowsJson = deSugaredRhs.map((rowSetJson) => ({ nodeName: TypedRowConstructor.NODE_NAME/* Most cross-dialect */, entries: rowSetJson }));\n\t\t\t\tresultJson = {\n\t\t\t\t\t...resultJson,\n\t\t\t\t\tvalues_clause: { nodeName: ValuesConstructor.NODE_NAME, entries: rowsJson },\n\t\t\t\t};\n\t\t\t} else if (pgDefaultValuesClause) {\n\t\t\t\tresultJson = { ...resultJson, pg_default_values_clause: deSugaredRhs };\n\t\t\t} else {\n\t\t\t\tresultJson = { ...resultJson, select_clause: deSugaredRhs };\n\t\t\t}\n\t\t}\n\n\t\treturn resultJson;\n\t}\n\n\tdeSugarPayload(columns, values, transformer, schemaInference, { conflictHandlingClauseContext = false, deSugar, ...$options } = {}) {\n\t\tconst payloadDimensions = transformer.statementContext.artifacts.get('payloadDimensions');\n\n\t\tconst {\n\t\t\tLQDeepRef2,\n\t\t\tTableRef1,\n\t\t\tColumnRef1,\n\t\t\tSelectItemAlias,\n\t\t\tColumnRef2,\n\t\t\tColumnsConstructor,\n\t\t\tTypedRowConstructor,\n\t\t\tRowConstructor,\n\t\t\tDefaultLiteral,\n\t\t\tSelectStmt,\n\t\t\tCompleteSelectStmt,\n\t\t\tPGDefaultValuesClause,\n\t\t\tSelectList,\n\t\t\tSelectItem,\n\t\t\tFromClause,\n\t\t\tFromItem,\n\t\t} = registry;\n\n\t\tconst jsonfy = (node, _deSugar = deSugar) => {\n\t\t\treturn node.jsonfy({ ...$options, deSugar: _deSugar }, transformer, schemaInference);\n\t\t};\n\n\t\t// (1): Columns\n\t\tconst deSugarColumnsList = (columnList, dimensionsMap) => {\n\t\t\treturn columnList.entries().reduce((columnList, columnRef, columnOffset) => {\n\t\t\t\tif (columnRef instanceof LQDeepRef2) {\n\n\t\t\t\t\tconst dimension = this.createPayloadDimension(columnRef, transformer, schemaInference, { conflictHandlingClauseContext, ...$options });\n\t\t\t\t\tdimensionsMap.set(columnOffset, dimension);\n\n\t\t\t\t\tif (dimension.refMode === 'dependency' && dimension.lhsOperandJson) {\n\t\t\t\t\t\treturn columnList.concat({\n\t\t\t\t\t\t\tnodeName: ColumnRef2.NODE_NAME,\n\t\t\t\t\t\t\tvalue: dimension.lhsOperandJson.value,\n\t\t\t\t\t\t\tdelim: dimension.lhsOperandJson.delim,\n\t\t\t\t\t\t\tresult_schema: dimension.lhsOperandJson.result_schema,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\treturn columnList;\n\t\t\t\t}\n\n\t\t\t\treturn columnList.concat(jsonfy(columnRef));\n\t\t\t}, []);\n\t\t};\n\n\t\t// (2.a): Default Values\n\t\tconst deSugarValuesFromDefaultValues = (pgDefaultValuesClause, dimensionsMap) => {\n\t\t\tconst valuesRow = columns.entries().reduce((valuesRow, columnRef, columnOffset) => {\n\t\t\t\tconst valueJson = dimensionsMap.has(columnOffset)\n\t\t\t\t\t? dimensionsMap.get(columnOffset).offload(pgDefaultValuesClause)\n\t\t\t\t\t: { nodeName: DefaultLiteral.NODE_NAME, value: 'DEFAULT' };\n\t\t\t\treturn valueJson\n\t\t\t\t\t? valuesRow.concat(valueJson)\n\t\t\t\t\t: valuesRow;\n\t\t\t}, []);\n\n\t\t\tif (columns.length - valuesRow.length === dimensionsMap.size) {\n\t\t\t\t// There were no depencies; only dependents\n\t\t\t\treturn pgDefaultValuesClause.jsonfy();\n\t\t\t}\n\n\t\t\t// There were depencies\n\t\t\treturn [valuesRow];\n\t\t};\n\n\t\t// (2.b): Values\n\t\tconst deSugarValuesFromValues = (valuesEntries, dimensionsMap) => {\n\t\t\treturn valuesEntries.map((valuesRow, rowOffset) => {\n\t\t\t\treturn valuesRow.reduce((valuesRow, valueNode, columnOffset) => {\n\t\t\t\t\tlet valueJson;\n\t\t\t\t\tif (columns.get(columnOffset) instanceof LQDeepRef2 && valueNode instanceof DefaultLiteral) {\n\t\t\t\t\t\tvalueJson = dimensionsMap.get(columnOffset).offload(\n\t\t\t\t\t\t\tPGDefaultValuesClause.fromJSON({ value: 'DEFAULT' }, this.options),\n\t\t\t\t\t\t\trowOffset\n\t\t\t\t\t\t);\n\t\t\t\t\t} else if (dimensionsMap.has(columnOffset)) {\n\t\t\t\t\t\tvalueJson = dimensionsMap.get(columnOffset).offload(valueNode, rowOffset);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalueJson = jsonfy(valueNode);\n\t\t\t\t\t}\n\t\t\t\t\treturn valueJson\n\t\t\t\t\t\t? valuesRow.concat(valueJson)\n\t\t\t\t\t\t: valuesRow;\n\t\t\t\t}, []);\n\t\t\t});\n\t\t};\n\n\t\t// (2.c): Select\n\t\tconst deSugarValuesFromSelect = (selectStmt, dimensionsMap) => {\n\t\t\t// Declare base SELECT and select list\n\t\t\tlet baseSelect = { ...jsonfy(selectStmt, 2), result_schema: undefined };\n\t\t\tlet baseSelectItems = baseSelect.select_list.entries;\n\n\t\t\tif (baseSelectItems.length !== columns.length) {\n\t\t\t\tthrow new Error(`Select list (${baseSelectItems.length}) does not match columns length (${columns.length})`);\n\t\t\t}\n\n\t\t\t// Create a CTE entry?\n\t\t\tlet memoSelect;\n\t\t\tif (!conflictHandlingClauseContext\n\t\t\t\t&& baseSelect.from_clause\n\t\t\t\t&& !/^[`\"]\\$memo~.+[`\"]$/.test(selectStmt.fromClause().entries()[0].expr() + '')) {\n\t\t\t\tconst memoSelectAlias = transformer.rootContext.rand('memo');\n\t\t\t\tmemoSelect = {\n\t\t\t\t\t...baseSelect,\n\t\t\t\t\tuuid: memoSelectAlias,\n\t\t\t\t\tselect_list: { nodeName: SelectList.NODE_NAME, entries: [rowNumberExpr('$row_number~a')] },\n\t\t\t\t};\n\t\t\t\tpayloadDimensions.add({ refMode: 'memo', query: memoSelect });\n\n\t\t\t\tconst newBaseSelectFromItem = { nodeName: FromItem.NODE_NAME, expr: { nodeName: TableRef1.NODE_NAME, value: memoSelectAlias } };\n\t\t\t\tbaseSelect = {\n\t\t\t\t\tnodeName: CompleteSelectStmt.NODE_NAME,\n\t\t\t\t\tselect_list: { nodeName: SelectList.NODE_NAME, entries: [] },\n\t\t\t\t\tfrom_clause: { nodeName: FromClause.NODE_NAME, entries: [newBaseSelectFromItem] },\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Resolve base select list\n\t\t\tconst rewriteAgainstMemoSelect = (fieldJson, obfuscateAlias = false) => {\n\t\t\t\tif (!memoSelect) return fieldJson;\n\t\t\t\tif (fieldJson.alias && obfuscateAlias) {\n\t\t\t\t\tfieldJson = {\n\t\t\t\t\t\t...fieldJson,\n\t\t\t\t\t\talias: { ...fieldJson.alias, value: fieldJson.alias.value + transformer.rand('rand', { asSalt: true }) },\n\t\t\t\t\t};\n\t\t\t\t} else if (!fieldJson.alias) {\n\t\t\t\t\tfieldJson.alias = { nodeName: SelectItemAlias.NODE_NAME, as_kw: true, value: transformer.rand('value') };\n\t\t\t\t}\n\t\t\t\tmemoSelect.select_list.entries.push(fieldJson);\n\t\t\t\treturn {\n\t\t\t\t\tnodeName: SelectItem.NODE_NAME,\n\t\t\t\t\texpr: { nodeName: ColumnRef1.NODE_NAME, value: fieldJson.alias.value, delim: fieldJson.alias.delim },\n\t\t\t\t};\n\t\t\t};\n\n\t\t\tconst newBaseSelectList = baseSelectItems.reduce((selectList, fieldJson, columnOffset) => {\n\t\t\t\tif (dimensionsMap.has(columnOffset)) {\n\t\t\t\t\tlet subSelectItems;\n\n\t\t\t\t\tif ([TypedRowConstructor.NODE_NAME, RowConstructor.NODE_NAME].includes(fieldJson.expr.nodeName)) {\n\t\t\t\t\t\tsubSelectItems = fieldJson.expr.entries.map((entryJson) => {\n\t\t\t\t\t\t\treturn rewriteAgainstMemoSelect({\n\t\t\t\t\t\t\t\tnodeName: SelectItem.NODE_NAME,\n\t\t\t\t\t\t\t\texpr: entryJson,\n\t\t\t\t\t\t\t\talias: fieldJson.alias,\n\t\t\t\t\t\t\t}, true);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (!(columns.get(columnOffset).right() instanceof ColumnsConstructor)) {\n\t\t\t\t\t\t\tsubSelectItems = [{\n\t\t\t\t\t\t\t\tnodeName: SelectItem.NODE_NAME,\n\t\t\t\t\t\t\t\texpr: { nodeName: TypedRowConstructor.NODE_NAME, entries: subSelectItems.map((s) => s.expr) },\n\t\t\t\t\t\t\t}];\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsubSelectItems = [rewriteAgainstMemoSelect(fieldJson)];\n\t\t\t\t\t}\n\n\t\t\t\t\tconst valueNode = SelectStmt.fromJSON({\n\t\t\t\t\t\t...baseSelect,\n\t\t\t\t\t\tselect_list: { nodeName: SelectList.NODE_NAME, entries: subSelectItems },\n\t\t\t\t\t}, this.options);\n\n\t\t\t\t\tfieldJson = dimensionsMap.get(columnOffset).offload(valueNode);\n\n\t\t\t\t\tif (fieldJson) {\n\t\t\t\t\t\tconst lhsOperandJson = dimensionsMap.get(columnOffset).lhsOperandJson;\n\t\t\t\t\t\treturn selectList.concat({\n\t\t\t\t\t\t\tnodeName: SelectItem.NODE_NAME,\n\t\t\t\t\t\t\texpr: fieldJson,\n\t\t\t\t\t\t\talias: { nodeName: SelectItemAlias.NODE_NAME, as_kw: true, value: lhsOperandJson.value, delim: lhsOperandJson.delim }\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\treturn selectList;\n\t\t\t\t}\n\n\t\t\t\tif (!fieldJson.alias) {\n\t\t\t\t\tconst correspondingColumn = columns.get(columnOffset);\n\t\t\t\t\tfieldJson = {\n\t\t\t\t\t\t...fieldJson,\n\t\t\t\t\t\talias: { nodeName: SelectItemAlias.NODE_NAME, as_kw: true, value: correspondingColumn.value(), delim: correspondingColumn._get('delim') },\n\t\t\t\t\t};\n\t\t\t\t};\n\n\t\t\t\treturn selectList.concat(rewriteAgainstMemoSelect(fieldJson));\n\t\t\t}, []);\n\n\t\t\tbaseSelect = {\n\t\t\t\t...baseSelect,\n\t\t\t\tselect_list: {\n\t\t\t\t\tnodeName: SelectList.NODE_NAME,\n\t\t\t\t\tentries: newBaseSelectList,\n\t\t\t\t},\n\t\t\t}\n\n\t\t\treturn baseSelect;\n\t\t};\n\n\t\t// Process...\n\t\tconst dimensionsMap = new Map;\n\t\tconst deSugaredLhs = deSugarColumnsList(columns, dimensionsMap);\n\n\t\tconst deSugaredRhs = values instanceof PGDefaultValuesClause\n\t\t\t? deSugarValuesFromDefaultValues(values, dimensionsMap)\n\t\t\t: (values instanceof SelectStmt\n\t\t\t\t? deSugarValuesFromSelect(values, dimensionsMap)\n\t\t\t\t: deSugarValuesFromValues(values, dimensionsMap));\n\n\t\tdimensionsMap.clear();\n\n\t\treturn [deSugaredLhs, deSugaredRhs];\n\t}\n\n\tcreatePayloadDimension(LQRefColumn, transformer, schemaInference, { conflictHandlingClauseContext = false, ...$options } = {}) {\n\t\tconst { lhsOperand, rhsOperand, rhsTable, detail } = LQRefColumn.resolve(transformer, schemaInference, 2);\n\t\tconst payloadDimensions = transformer.statementContext.artifacts.get('payloadDimensions');\n\n\t\tconst {\n\t\t\tLQDeepRef2,\n\t\t\tLQBackRefAbstraction,\n\t\t\tReturningClause,\n\t\t\tColumnRef2,\n\t\t\tColumnRef1,\n\t\t\tTableRef1,\n\t\t\tSelectList,\n\t\t\tSelectItem,\n\t\t\tSelectItemAlias,\n\t\t\tAssignmentExpr,\n\t\t\tColumnsConstructor,\n\t\t\tTypedRowConstructor,\n\t\t\tRowConstructor,\n\t\t\tPGDefaultValuesClause,\n\t\t\tValuesConstructor,\n\t\t\tValuesTableLiteral,\n\t\t\tDefaultLiteral,\n\t\t\tSelectStmt,\n\t\t\tWhereClause,\n\t\t\tCompleteSelectStmt,\n\t\t\tScalarSubquery,\n\t\t\tDerivedQuery,\n\t\t\tFromItem,\n\t\t\tFromClause,\n\t\t\tSetClause,\n\t\t\tBinaryExpr,\n\t\t\tBoolLiteral,\n\t\t\tNumberLiteral,\n\t\t\tUpdateStmt,\n\t\t\tTableAbstraction2,\n\t\t} = registry;\n\n\t\tconst baseUUID = transformer.rootContext.hash(this, 'main');\n\t\tconst jsonfy = (node) => {\n\t\t\treturn node.jsonfy($options, transformer, schemaInference);\n\t\t};\n\n\t\tconst lhsOperandJson = jsonfy(lhsOperand);\n\t\tconst rhsOperandJson = jsonfy(rhsOperand);\n\t\tconst rhsTableJson = jsonfy(rhsTable);\n\n\t\tconst lhsOperand1Json = lhsOperand.jsonfy({ toKind: 1 });\n\t\tconst rhsOperand1Json = rhsOperand.jsonfy({ toKind: 1 });\n\t\tconst rhsTable1Json = { ...rhsTableJson, nodeName: TableRef1.NODE_NAME };\n\t\tconst refMode = LQRefColumn.left() instanceof LQBackRefAbstraction\n\t\t\t? 'dependent'\n\t\t\t: 'dependency';\n\t\tconst isDeepRef = detail instanceof LQDeepRef2;\n\n\t\t// Figure the expected payload structure\n\t\tlet columnsConstructorJson;\n\t\tif (detail instanceof ColumnsConstructor) {\n\t\t\tcolumnsConstructorJson = jsonfy(detail);\n\t\t} else if (detail instanceof ColumnRef2 || detail instanceof LQDeepRef2) {\n\t\t\tcolumnsConstructorJson = { nodeName: ColumnsConstructor.NODE_NAME, entries: [jsonfy(detail)] };\n\t\t} else {\n\t\t\tthrow new Error(`Invalid columns spec: ${LQRefColumn}`);\n\t\t}\n\n\t\t// Payload structure length validity\n\t\tconst columnsLength = columnsConstructorJson.entries.length;\n\t\tconst dimensionValidateRowLength = (rowNode, result_schema = null) => {\n\t\t\tif (isDeepRef) return rowNode;\n\t\t\tlet rowLength = 1;\n\t\t\tif (result_schema) {\n\t\t\t\trowLength = result_schema.length;\n\t\t\t} else if (rowNode instanceof RowConstructor || rowNode instanceof SelectStmt) {\n\t\t\t\trowLength = rowNode.length;\n\t\t\t} else if (rowNode instanceof SelectStmt) {\n\t\t\t\trowLength = rowNode.length;\n\t\t\t} else if (rowNode instanceof DerivedQuery) {\n\t\t\t\trowLength = rowNode.expr().length;\n\t\t\t}\n\t\t\tif (rowLength > columnsLength) throw new Error(`[${rowNode}] Payload has more columns than target columns: ${detail}.`);\n\t\t\tif (rowLength < columnsLength) throw new Error(`[${rowNode}] Payload has fewer columns than target columns: ${detail}.`);\n\t\t\treturn rowNode;\n\t\t};\n\n\t\t// Compose:\n\t\t// - (SELECT <sourceCol> FROM <sourceUuid> WHERE <rand> = <sourceRowIndex>)\n\t\tconst createForeignBinding = (sourceUuid, sourceCol, sourceRowIndex = null, innerFilter = null) => {\n\t\t\tlet whereExpr;\n\t\t\tlet whereExprRhs;\n\n\t\t\tif (typeof sourceRowIndex === 'number') {\n\t\t\t\twhereExprRhs = { nodeName: NumberLiteral.NODE_NAME, value: sourceRowIndex + 1 };\n\t\t\t} else if (sourceRowIndex) {\n\t\t\t\twhereExprRhs = sourceRowIndex;\n\t\t\t}\n\n\t\t\tif (whereExprRhs) {\n\t\t\t\twhereExpr = {\n\t\t\t\t\tnodeName: BinaryExpr.NODE_NAME,\n\t\t\t\t\tleft: { nodeName: ColumnRef1.NODE_NAME, value: '$row_number~b' },\n\t\t\t\t\toperator: '=',\n\t\t\t\t\tright: whereExprRhs,\n\t\t\t\t};\n\t\t\t} else if (innerFilter) {\n\t\t\t\twhereExpr = {\n\t\t\t\t\tnodeName: BinaryExpr.NODE_NAME,\n\t\t\t\t\tleft: { nodeName: ColumnRef1.NODE_NAME, value: innerFilter },\n\t\t\t\t\toperator: 'IS',\n\t\t\t\t\tright: { nodeName: BoolLiteral.NODE_NAME, value: 'TRUE' },\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tconst tableSpec = {\n\t\t\t\tnodeName: FromItem.NODE_NAME,\n\t\t\t\texpr: { nodeName: TableRef1.NODE_NAME, value: whereExprRhs ? `${sourceUuid}~indices` : sourceUuid },\n\t\t\t};\n\n\t\t\tconst selectStmt = {\n\t\t\t\tnodeName: CompleteSelectStmt.NODE_NAME,\n\t\t\t\tselect_list: { nodeName: SelectList.NODE_NAME, entries: [{ nodeName: SelectItem.NODE_NAME, expr: { ...sourceCol, qualifier: undefined } }] },\n\t\t\t\tfrom_clause: { nodeName: FromClause.NODE_NAME, entries: [tableSpec] },\n\t\t\t\twhere_clause: whereExpr && { nodeName: WhereClause.NODE_NAME, expr: whereExpr },\n\t\t\t};\n\n\t\t\treturn { nodeName: ScalarSubquery.NODE_NAME, expr: selectStmt };\n\t\t};\n\n\t\t// --- UPDATE -------------\n\n\t\tif (this instanceof UpdateStmt || conflictHandlingClauseContext) {\n\n\t\t\t// UPDATE t1 SET (a, (fk <~ fk <~ t2) ~> (a, b)) = ROW(2, ROW(44, 33))\n\t\t\t// UPDATE t1 SET (a, (fk <~ fk <~ t2) ~> a) = ROW(2, ROW(44, 33))\n\t\t\t// UPDATE t1 SET (a, (fk <~ fk <~ t2) ~> a) = (SELECT a, b FROM t3)\n\t\t\t// UPDATE t1 SET (a, fk ~> fk ~> (a, b)) = ROW(2, ROW(44, 33))\n\t\t\t// UPDATE t1 SET (a, fk ~> fk ~> a) = ROW(2, ROW(44, 33))\n\t\t\t// UPDATE t1 SET (a, fk ~> fk ~> a) = (SELECT a, b FROM t3)\n\n\t\t\t// Here we want to compose:\n\t\t\t// - WHERE <rhsOperandJson> IN (SELECT <lhsOperandJson> FROM <baseUUID> [WHERE <conflict_based_update> IS TRUE]? )\n\t\t\tconst onConflictUpdatedStatusAlias = conflictHandlingClauseContext\n\t\t\t\t? `${baseUUID}_conflict_based_update` : null;\n\n\t\t\tconst whereClause = {\n\t\t\t\tnodeName: BinaryExpr.NODE_NAME,\n\t\t\t\tleft: rhsOperand1Json,\n\t\t\t\toperator: 'IN',\n\t\t\t\tright: createForeignBinding(baseUUID, lhsOperandJson, null, onConflictUpdatedStatusAlias),\n\t\t\t};\n\n\t\t\tconst query = {\n\t\t\t\tuuid: transformer.rootContext.rand(refMode),\n\t\t\t\tnodeName: UpdateStmt.NODE_NAME,\n\t\t\t\ttable_expr: { nodeName: TableAbstraction2.NODE_NAME, table_ref: rhsTable1Json },\n\t\t\t\tset_clause: { nodeName: SetClause.NODE_NAME, entries: [] },\n\t\t\t\twhere_clause: { nodeName: WhereClause.NODE_NAME, expr: whereClause },\n\t\t\t};\n\n\t\t\tconst offload = (payload) => {\n\t\t\t\tif (payload instanceof ValuesTableLiteral) {\n\t\t\t\t\tthrow new Error(`Single-row payload structure expected for column structure: ${detail}. Recieved ${payload.NODE_NAME}.`);\n\t\t\t\t}\n\t\t\t\tif (query.set_clause.entries.length) {\n\t\t\t\t\tthrow new Error(`Unexpected multiple offload() call on ${LQRefColumn}`);\n\t\t\t\t}\n\n\t\t\t\t// Carry deep values forward\n\t\t\t\tlet payloadJson = jsonfy(payload);\n\t\t\t\tif (isDeepRef && !(payload instanceof PGDefaultValuesClause)) {\n\t\t\t\t\tpayload = TypedRowConstructor.fromJSON({ entries: [payloadJson] }, this.options);\n\t\t\t\t\tpayloadJson = jsonfy(payload);\n\t\t\t\t}\n\n\t\t\t\tif (payload instanceof SelectStmt) {\n\t\t\t\t\tpayloadJson = { nodeName: DerivedQuery.NODE_NAME, expr: payloadJson, result_schema: payloadJson.result_schema };\n\t\t\t\t\tdimensionValidateRowLength(payload, payloadJson.result_schema);\n\t\t\t\t} else if (payload instanceof DerivedQuery) {\n\t\t\t\t\tdimensionValidateRowLength(payload, payloadJson.result_schema);\n\t\t\t\t} else if (payload instanceof RowConstructor) {\n\t\t\t\t\tdimensionValidateRowLength(payload);\n\t\t\t\t} else if (!(payload instanceof PGDefaultValuesClause)) {\n\t\t\t\t\tpayloadJson = { nodeName: TypedRowConstructor.NODE_NAME/* most formal */, entries: [payloadJson] };\n\t\t\t\t}\n\n\t\t\t\tquery.set_clause.entries.push({\n\t\t\t\t\tnodeName: AssignmentExpr.NODE_NAME,\n\t\t\t\t\tleft: columnsConstructorJson,\n\t\t\t\t\toperator: '=',\n\t\t\t\t\tright: payloadJson,\n\t\t\t\t});\n\n\t\t\t\tif (refMode === 'dependency') {\n\t\t\t\t\treturn lhsOperand1Json;\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tconst payloadDimension = {\n\t\t\t\trefMode,\n\t\t\t\tquery,\n\t\t\t\toffload,\n\t\t\t\tlhsOperandJson,\n\t\t\t\tconflictHandlingClauseContext\n\t\t\t};\n\t\t\tpayloadDimensions.add(payloadDimension);\n\n\t\t\treturn payloadDimension;\n\t\t}\n\n\t\t// --- INSERT/UPSERT -------------\n\n\t\tconst queries = [];\n\n\t\t// This is for all INSERT types\n\t\tconst dimensionPushRow = (query, payload, fKBindingJson = null) => {\n\t\t\tif (payload instanceof PGDefaultValuesClause) {\n\t\t\t\tif (fKBindingJson) {\n\t\t\t\t\tconst lastIndex = query.column_list.entries.length - 1;\n\t\t\t\t\tquery.values_clause.entries.push({\n\t\t\t\t\t\tnodeName: TypedRowConstructor.NODE_NAME/* most formal */,\n\t\t\t\t\t\tentries: query.column_list.entries.map((c, i) => {\n\t\t\t\t\t\t\treturn i === lastIndex\n\t\t\t\t\t\t\t\t? fKBindingJson\n\t\t\t\t\t\t\t\t: { nodeName: DefaultLiteral.NODE_NAME, value: 'DEFAULT' };\n\t\t\t\t\t\t}),\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tdelete query.values_clause;\n\t\t\t\t\tquery.pg_default_values_clause = jsonfy(payload);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdimensionValidateRowLength(payload);\n\t\t\t\tlet rowJson = jsonfy(payload);\n\t\t\t\tif (!(payload instanceof RowConstructor)) {\n\t\t\t\t\trowJson = { nodeName: TypedRowConstructor.NODE_NAME/* most formal */, entries: [rowJson] };\n\t\t\t\t}\n\t\t\t\tif (fKBindingJson) {\n\t\t\t\t\trowJson = { ...rowJson, entries: rowJson.entries.concat(fKBindingJson) };\n\t\t\t\t}\n\t\t\t\tquery.values_clause.entries.push(rowJson);\n\t\t\t}\n\t\t};\n\n\t\t// BackRefing INSERTS\n\t\tif (refMode === 'dependent') {\n\n\t\t\t// INSERT INTO t1 (a, (fk <~ fk <~ t2) ~> (a, b)) VALUES (2, ROW(44, 33)), (3, ROW(11, 22))\n\t\t\t// INSERT INTO t1 (a, (fk <~ fk <~ t2) ~> a) VALUES (2, 44), (3, 11)\n\t\t\t// INSERT INTO t1 (a, (fk <~ fk <~ t2) ~> a) SELECT a, b FROM t3\n\n\t\t\tconst queryTemplate = () => ({\n\t\t\t\tuuid: transformer.rootContext.rand(refMode),\n\t\t\t\tnodeName: this.NODE_NAME,\n\t\t\t\ttable_ref: rhsTableJson,\n\t\t\t\tcolumn_list: ColumnsConstructor.fromJSON({ entries: columnsConstructorJson.entries.concat(rhsOperandJson) }).jsonfy(),\n\t\t\t});\n\n\t\t\tconst selectForeignBinding = (selectJson, fKBindingJson) => {\n\t\t\t\tconst fkField = {\n\t\t\t\t\tnodeName: SelectItem.NODE_NAME,\n\t\t\t\t\texpr: fKBindingJson,\n\t\t\t\t\talias: rhsOperand instanceof ColumnRef2\n\t\t\t\t\t\t? { nodeName: SelectItemAlias.NODE_NAME, as_kw: true, value: rhsOperand.value(), delim: rhsOperand._get('delim') }\n\t\t\t\t\t\t: undefined,\n\t\t\t\t};\n\t\t\t\treturn {\n\t\t\t\t\t...selectJson,\n\t\t\t\t\tselect_list: { ...selectJson.select_list, entries: selectJson.select_list.entries.concat(fkField) },\n\t\t\t\t};\n\t\t\t};\n\n\t\t\tconst offload = (payload, correlationRhs = null) => {\n\n\t\t\t\tif (!queries.length) {\n\t\t\t\t\tqueries.push(queryTemplate());\n\t\t\t\t}\n\t\t\t\tlet currentQuery = queries[queries.length - 1];\n\n\t\t\t\tif (payload instanceof SelectStmt) {\n\t\t\t\t\t// Meaning we're from a literal INSERT ... SELECT statement, not an INSERT ... VALUES (+SELECT) statement\n\t\t\t\t\t// and this time, we want to correlate with base query's row number\n\t\t\t\t\tcorrelationRhs = {\n\t\t\t\t\t\tnodeName: ColumnRef1.NODE_NAME,\n\t\t\t\t\t\tvalue: '$row_number~a',\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tconst fKBindingJson = createForeignBinding(baseUUID, lhsOperandJson, correlationRhs);\n\n\t\t\t\t// Scenario 2:\n\t\t\t\t// When the base query is an INSERT ... VALUES (+DerivedQuery)\n\t\t\t\tlet isDerivedQuery;\n\t\t\t\tif (payload instanceof DerivedQuery) {\n\t\t\t\t\tpayload = payload.expr();\n\t\t\t\t\t// For when preceding offload() was scenario 2 or 3\n\t\t\t\t\tif (currentQuery.select_clause || currentQuery.values_clause) {\n\t\t\t\t\t\tcurrentQuery = queryTemplate();\n\t\t\t\t\t\tqueries.push(currentQuery);\n\t\t\t\t\t}\n\t\t\t\t\tisDerivedQuery = true;\n\t\t\t\t}\n\n\t\t\t\t// Scenario 1 or 2:\n\t\t\t\t// When the base query is an INSERT ... SELECT\n\t\t\t\t// or when the preceding scenario is the case\n\t\t\t\tif (payload instanceof SelectStmt) {\n\t\t\t\t\tlet selectJson = jsonfy(payload);\n\t\t\t\t\tif (!isDerivedQuery && !isDeepRef) {\n\t\t\t\t\t\t// Fully qualify output names to match target column names. Not necessary at the LinkedQL level\n\t\t\t\t\t\tselectJson = deriveSelectAliasesFromColumns(selectJson, columnsConstructorJson);\n\t\t\t\t\t}\n\t\t\t\t\tdimensionValidateRowLength(payload, selectJson.result_schema);\n\t\t\t\t\tcurrentQuery.select_clause = selectForeignBinding(selectJson, fKBindingJson);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Scenario 3:\n\t\t\t\t// When base query is INSERT ... VALUES\n\n\t\t\t\t// For when preceding offload() was scenario 2\n\t\t\t\tif (currentQuery.select_clause) {\n\t\t\t\t\tcurrentQuery = queryTemplate();\n\t\t\t\t\tqueries.push(currentQuery);\n\t\t\t\t}\n\t\t\t\tif (!currentQuery.values_clause) {\n\t\t\t\t\tcurrentQuery.values_clause = { nodeName: ValuesConstructor.NODE_NAME, entries: [] };\n\t\t\t\t}\n\n\t\t\t\t// Carry deep values forward\n\t\t\t\tif (isDeepRef && !(payload instanceof PGDefaultValuesClause)) {\n\t\t\t\t\tpayload = TypedRowConstructor.fromJSON({ entries: [jsonfy(payload)] });\n\t\t\t\t}\n\n\t\t\t\tif (payload instanceof ValuesTableLiteral) {\n\t\t\t\t\tfor (const rowNode of payload.entries()) {\n\t\t\t\t\t\tdimensionPushRow(currentQuery, rowNode, fKBindingJson);\n\t\t\t\t\t}\n\t\t\t\t} else dimensionPushRow(currentQuery, payload, fKBindingJson);\n\t\t\t};\n\n\t\t\tconst payloadDimension = {\n\t\t\t\trefMode,\n\t\t\t\tqueries,\n\t\t\t\toffload,\n\t\t\t\tlhsOperandJson,\n\t\t\t};\n\n\t\t\tpayloadDimensions.add(payloadDimension);\n\n\t\t\treturn payloadDimension;\n\t\t}\n\n\t\t// INSERT INTO t1 (a, t2 ~> fk ~> (a, b)) VALUES (2, ROW(44, 33)), (3, ROW(11, 22))\n\t\t// INSERT INTO t1 (a, t2 ~> fk ~> a) VALUES (2, 44), (3, 11)\n\t\t// INSERT INTO t1 (a, t2 ~> fk ~> a) SELECT a, b FROM t3\n\n\t\t// The binding elements...\n\t\tconst rhsOperandPKJson = { nodeName: ColumnRef1.NODE_NAME, value: rhsOperand.value(), delim: rhsOperand._get('delim') };\n\n\t\tconst queryTemplate = () => ({\n\t\t\tuuid: transformer.rootContext.rand(refMode),\n\t\t\tnodeName: this.NODE_NAME,\n\t\t\ttable_ref: rhsTableJson,\n\t\t\tcolumn_list: columnsConstructorJson,\n\t\t\treturning_clause: {\n\t\t\t\tnodeName: ReturningClause.NODE_NAME,\n\t\t\t\tentries: [{ nodeName: SelectItem.NODE_NAME, expr: rhsOperand1Json }],\n\t\t\t},\n\t\t});\n\n\t\tconst offload = (payload) => {\n\n\t\t\tif (payload instanceof ValuesTableLiteral) {\n\t\t\t\tthrow new Error(`Single-row payload structure expected for column structure: ${LQRefColumn.right()}. Recieved ${payload.NODE_NAME}.`);\n\t\t\t}\n\n\t\t\tif (!queries.length) {\n\t\t\t\tqueries.push(queryTemplate());\n\t\t\t}\n\t\t\tlet currentQuery = queries[queries.length - 1];\n\n\t\t\tlet isDerivedQuery = false;\n\n\t\t\t// Scenario 2:\n\t\t\t// When the base query is an INSERT ... VALUES (+DerivedQuery)\n\t\t\tif (payload instanceof DerivedQuery) {\n\t\t\t\tpayload = payload.expr();\n\t\t\t\t// For when preceding offload() was scenario 2 or 3\n\t\t\t\tif (currentQuery.select_clause || currentQuery.values_clause) {\n\t\t\t\t\tcurrentQuery = queryTemplate();\n\t\t\t\t\tqueries.push(currentQuery);\n\t\t\t\t}\n\t\t\t\tisDerivedQuery = true;\n\t\t\t}\n\n\t\t\t// Scenario 1 or 2:\n\t\t\t// When the base query is an INSERT ... SELECT\n\t\t\t// or when the preceding scenario is the case\n\t\t\tif (payload instanceof SelectStmt) {\n\n\t\t\t\tlet selectJson = jsonfy(payload);\n\t\t\t\tlet correlationRhs;\n\n\t\t\t\tif (!isDerivedQuery) {\n\t\t\t\t\tif (!isDeepRef) {\n\t\t\t\t\t\t// Fully qualify output names to match target column names. Not necessary at the LinkedQL level\n\t\t\t\t\t\tselectJson = deriveSelectAliasesFromColumns(selectJson, columnsConstructorJson);\n\t\t\t\t\t}\n\t\t\t\t\t// Meaning we're from a literal INSERT ... SELECT statement, not an INSERT ... VALUES (+SELECT) statement\n\t\t\t\t\t// and this time, we want to correlate with base query's row number\n\t\t\t\t\tcorrelationRhs = { nodeName: ColumnRef1.NODE_NAME, value: '$row_number~a' };\n\t\t\t\t}\n\n\t\t\t\tdimensionValidateRowLength(payload, selectJson.result_schema);\n\t\t\t\tcurrentQuery.select_clause = selectJson;\n\n\t\t\t\treturn createForeignBinding(currentQuery.uuid, rhsOperandPKJson, correlationRhs);\n\t\t\t}\n\n\t\t\t// Scenario 3:\n\t\t\t// When base query is INSERT ... VALUES\n\n\t\t\t// For when preceding offload() was scenario 2\n\t\t\tif (currentQuery.select_clause) {\n\t\t\t\tcurrentQuery = queryTemplate();\n\t\t\t\tqueries.push(currentQuery);\n\t\t\t}\n\t\t\tif (!currentQuery.values_clause) {\n\t\t\t\tcurrentQuery.values_clause = { nodeName: ValuesConstructor.NODE_NAME, entries: [] };\n\t\t\t}\n\n\t\t\t// Carry deep values forward\n\t\t\tif (isDeepRef && !(payload instanceof PGDefaultValuesClause)) {\n\t\t\t\tpayload = TypedRowConstructor.fromJSON({ entries: [jsonfy(payload)] });\n\t\t\t}\n\n\t\t\tdimensionPushRow(currentQuery, payload);\n\n\t\t\tlet correlationRhs;\n\t\t\tif (currentQuery.values_clause) {\n\t\t\t\t// Meaning we're from an INSERT ... VALUES statement, not an INSERT ... DEFAULT VALUES statement\n\t\t\t\t// and this this time, currentQuery's row offset is what we use\n\t\t\t\tcorrelationRhs = currentQuery.values_clause.entries.length - 1;\n\t\t\t}\n\n\t\t\treturn createForeignBinding(currentQuery.uuid, rhsOperandPKJson, correlationRhs);\n\t\t};\n\n\t\tconst payloadDimension = {\n\t\t\trefMode,\n\t\t\tqueries,\n\t\t\toffload,\n\t\t\tlhsOperandJson,\n\t\t\trhsOperandJson: rhsOperand1Json\n\t\t};\n\n\t\tpayloadDimensions.add(payloadDimension);\n\n\t\treturn payloadDimension;\n\t}\n\n\tfinalizePayloadJSON(resultJson, transformer, schemaInference, options) {\n\n\t\tconst payloadDimensions = transformer.statementContext.artifacts.get('payloadDimensions');\n\t\tif (!payloadDimensions.size) {\n\t\t\treturn resultJson;\n\t\t}\n\n\t\tconst {\n\t\t\tColumnRef0,\n\t\t\tColumnRef1,\n\t\t\tTableRef1,\n\t\t\tFromItem,\n\t\t\tFromClause,\n\t\t\tAggrCallExpr,\n\t\t\tReturningClause,\n\t\t\tSelectList,\n\t\t\tSelectItem,\n\t\t\tSelectItemAlias,\n\t\t\tNumberLiteral,\n\t\t\tBinaryExpr,\n\t\t\tCTE,\n\t\t\tCTEItem,\n\t\t\tCTEItemAlias,\n\t\t\tCompleteSelectStmt,\n\t\t\tUpdateStmt,\n\t\t} = registry;\n\n\t\tconst baseUUID = transformer.rootContext.hash(this, 'main');\n\t\tconst cte = { nodeName: CTE.NODE_NAME, declarations: [], body: null };\n\t\tconst $transformer = transformer;//new Transformer((node, defaultTransform) => defaultTransform(), null, this);\n\n\t\t// Promote a query to a CTEItem\n\t\tconst toCTEItem = (dimensionID, queryJson, indices = [], transformer = $transformer) => {\n\n\t\t\tlet cteItemJson = CTEItem.fromJSON({\n\t\t\t\tnodeName: CTEItem.NODE_NAME,\n\t\t\t\talias: { nodeName: CTEItemAlias.NODE_NAME, value: dimensionID },\n\t\t\t\texpr: queryJson,\n\t\t\t}, this.options).jsonfy(options, transformer, schemaInference);\n\n\t\t\t// Desugar query and flatten if itself a CTE\n\t\t\tif (cteItemJson.expr?.nodeName === CTE.NODE_NAME) {\n\t\t\t\tcte.declarations.push(...cteItemJson.expr.declarations);\n\n\t\t\t\tif (this instanceof UpdateStmt && cteItemJson.expr.body.nodeName === CompleteSelectStmt.NODE_NAME) {\n\t\t\t\t\t// This is a stray \"SELECT COUNT(*)\" statement owing to how dependencies are rendered in the CTE as dependents\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tcteItemJson = {\n\t\t\t\t\tnodeName: CTEItem.NODE_NAME,\n\t\t\t\t\talias: { nodeName: CTEItemAlias.NODE_NAME, value: dimensionID },\n\t\t\t\t\texpr: cteItemJson.expr.body,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Compose declaration and add...\n\t\t\tcte.declarations.push(cteItemJson);\n\n\t\t\tif (!indices.length) return;\n\n\t\t\tcte.declarations.push(CTEItem.fromJSON({\n\t\t\t\tnodeName: CTEItem.NODE_NAME,\n\t\t\t\talias: { nodeName: CTEItemAlias.NODE_NAME, value: `${dimensionID}~indices` },\n\t\t\t\texpr: flipSelectFromWithRowNumbers(indices, dimensionID),\n\t\t\t}, this.options).jsonfy(options, transformer, schemaInference));\n\t\t};\n\n\t\t// Process entries in stringent order\n\t\tconst dependents = [],\n\t\t\tdeferedDependencies = [],\n\t\t\tlefts = [];\n\n\t\tlet onConflictUpdatedStatusRequired = false;\n\t\tconst originalReturningList = resultJson.returning_clause?.entries || [];\n\n\t\tfor (const { refMode, query: $query, queries, lhsOperandJson, rhsOperandJson, conflictHandlingClauseContext } of payloadDimensions) {\n\t\t\tfor (const { uuid, ...query } of ($query && [$query] || queries)) {\n\t\t\t\tif (refMode === 'dependent' || (this instanceof UpdateStmt && refMode === 'dependency') || conflictHandlingClauseContext) { // Defer dependents\n\n\t\t\t\t\tif (!lefts.find((existing) => _eq(existing.expr.value, lhsOperandJson.value))) {\n\t\t\t\t\t\tconst fieldExpr = { nodeName: SelectItem.NODE_NAME, expr: lhsOperandJson };\n\t\t\t\t\t\tif (originalReturningList.find((existing) => _eq((existing.alias || existing.expr).value, lhsOperandJson.value))) {\n\t\t\t\t\t\t\tfieldExpr.alias = { nodeName: SelectItemAlias.NODE_NAME, as_kw: true, value: transformer.rand('key') };\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlefts.push(fieldExpr);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (conflictHandlingClauseContext) {\n\t\t\t\t\t\tonConflictUpdatedStatusRequired = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tdependents.push({ uuid, ...query });\n\t\t\t\t} else if (refMode === 'dependency') {\n\t\t\t\t\tconst wherePredicate = [{ nodeName: SelectItem.NODE_NAME, expr: rhsOperandJson }];\n\n\t\t\t\t\tif (resultJson.select_clause) {\n\t\t\t\t\t\tdeferedDependencies.push({ uuid, wherePredicate, ...query }); // Dependencies that themselves depend on memo\n\t\t\t\t\t} else if (query.pg_default_values_clause || query.select_clause) {\n\t\t\t\t\t\ttoCTEItem(uuid, query);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttoCTEItem(uuid, query, wherePredicate);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ttoCTEItem(uuid, query);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// (1): Process dependencies with memo\n\t\tfor (const { uuid, wherePredicate, ...query } of deferedDependencies) {\n\t\t\ttoCTEItem(uuid, query, wherePredicate);\n\t\t}\n\n\t\t// (2): Process dependents\n\t\tif (dependents.length) {\n\n\t\t\t// Rewrite returning clause\n\t\t\tconst cteReturningList = [];\n\t\t\tconst newOuterReturningList = [];\n\t\t\tfor (let fieldExpr of originalReturningList) {\n\t\t\t\tif (!fieldExpr.alias) {\n\t\t\t\t\tfieldExpr = {\n\t\t\t\t\t\t...fieldExpr,\n\t\t\t\t\t\talias: { nodeName: SelectItemAlias.NODE_NAME, as_kw: true, value: transformer.rand('key') },\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tcteReturningList.push(fieldExpr);\n\t\t\t\tnewOuterReturningList.push({ ...fieldExpr, expr: { nodeName: ColumnRef1.NODE_NAME, value: fieldExpr.alias.value, delim: fieldExpr.alias.delim } });\n\t\t\t}\n\n\t\t\t// Add conflict_based_update?\n\t\t\tif (onConflictUpdatedStatusRequired) {\n\t\t\t\tconst onConflictUpdatedStatusAlias = `${baseUUID}_conflict_based_update`;\n\t\t\t\tcteReturningList.push({\n\t\t\t\t\tnodeName: SelectItem.NODE_NAME,\n\t\t\t\t\texpr: {\n\t\t\t\t\t\tnodeName: BinaryExpr.NODE_NAME,\n\t\t\t\t\t\tleft: { nodeName: ColumnRef1.NODE_NAME, value: 'XMAX' },\n\t\t\t\t\t\toperator: '!=',\n\t\t\t\t\t\tright: { nodeName: NumberLiteral.NODE_NAME, value: '0' },\n\t\t\t\t\t},\n\t\t\t\t\talias: { nodeName: SelectItemAlias.NODE_NAME, as_kw: true, value: onConflictUpdatedStatusAlias },\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Compose binding and add...\n\t\t\tconst cteReturningClause = { nodeName: ReturningClause.NODE_NAME, entries: [...cteReturningList, ...lefts/* NOTE: cteReturningList may contain \"*\" */] };\n\n\t\t\t// Base query as CTE item\n\t\t\t// If UpdateStmt or onConflictUpdatedStatusRequired, we do not pass lefts\n\t\t\tif (this instanceof UpdateStmt || onConflictUpdatedStatusRequired) {\n\t\t\t\ttoCTEItem(baseUUID, { ...resultJson, returning_clause: cteReturningClause });\n\t\t\t} else if (resultJson.pg_default_values_clause) {\n\t\t\t\ttoCTEItem(baseUUID, { ...resultJson, returning_clause: cteReturningClause });\n\t\t\t} else {\n\t\t\t\ttoCTEItem(baseUUID, { ...resultJson, returning_clause: cteReturningClause }, lefts);\n\t\t\t}\n\n\t\t\t// Process dependents... after having done the above\n\t\t\tfor (const { uuid, ...query } of dependents) {\n\t\t\t\ttoCTEItem(uuid, query);\n\t\t\t}\n\n\t\t\t// Derive final body...\n\t\t\tlet selectItems = newOuterReturningList;\n\n\t\t\tif (!selectItems.length) {\n\t\t\t\tselectItems = [{\n\t\t\t\t\tnodeName: SelectItem.NODE_NAME,\n\t\t\t\t\texpr: { nodeName: AggrCallExpr.NODE_NAME, name: 'COUNT', arguments: [{ nodeName: ColumnRef0.NODE_NAME, value: '*' }] },\n\t\t\t\t\talias: { nodeName: SelectItemAlias.NODE_NAME, as_kw: true, value: 'COUNT' },\n\t\t\t\t}];\n\t\t\t}\n\n\t\t\tconst tableSpec = { nodeName: FromItem.NODE_NAME, expr: { nodeName: TableRef1.NODE_NAME, value: baseUUID } };\n\n\t\t\tcte.body = CompleteSelectStmt.fromJSON({\n\t\t\t\tnodeName: CompleteSelectStmt.NODE_NAME,\n\t\t\t\tselect_list: { nodeName: SelectList.NODE_NAME, entries: selectItems },\n\t\t\t\tfrom_clause: { nodeName: FromClause.NODE_NAME, entries: [tableSpec] },\n\t\t\t}, this.options).jsonfy(options, $transformer, schemaInference);\n\t\t} else {\n\t\t\t// Use resultJson as-is\n\t\t\tconst Classes = [this.constructor].concat(this.constructor.morphsTo()); // InsertStmt/UpsertStmt\n\t\t\tconst instance = Classes.reduce((prev, C) => prev || C.fromJSON(resultJson, this.options), undefined);\n\t\t\tcte.body = instance.jsonfy(options, $transformer, schemaInference);\n\t\t}\n\n\t\treturn { ...cte, origin_schemas: cte.body.origin_schemas, result_schema: cte.body.result_schema };\n\t}\n}\n\nconst deriveSelectAliasesFromColumns = (selectJson, columnsConstructorJson) => {\n\tconst newSelectList = selectJson.select_list.entries.reduce((selectList, fieldJson, columnOffset) => {\n\t\tif (!fieldJson.alias) {\n\t\t\tconst correspondingColumn = columnsConstructorJson.entries[columnOffset];\n\t\t\tfieldJson = {\n\t\t\t\t...fieldJson,\n\t\t\t\talias: { nodeName: registry.SelectItemAlias.NODE_NAME, as_kw: true, value: correspondingColumn.value, delim: correspondingColumn.delim },\n\t\t\t}\n\t\t}\n\t\treturn selectList.concat(fieldJson);\n\t}, []);\n\treturn {\n\t\t...selectJson,\n\t\tselect_list: {\n\t\t\t...selectJson.select_list,\n\t\t\tentries: newSelectList,\n\t\t},\n\t};\n};\n\nconst flipSelectFromWithRowNumbers = (selectItems, fromName) => {\n\tconst rowNumberJson = rowNumberExpr('$row_number~b');\n\n\tselectItems = selectItems.map((fieldJson) => {\n\t\tif (fieldJson.alias) {\n\t\t\t// Flip expr/alias\n\t\t\treturn {\n\t\t\t\t...fieldJson,\n\t\t\t\texpr: { ...fieldJson.expr, value: fieldJson.alias.value, delim: fieldJson.alias.delim, qualifier: undefined },\n\t\t\t\talias: { ...fieldJson.alias, value: fieldJson.expr.value, delim: fieldJson.expr.delim },\n\t\t\t};\n\t\t}\n\t\treturn fieldJson.expr.nodeName === registry.ColumnRef0.NODE_NAME ? i : {\n\t\t\t...fieldJson,\n\t\t\texpr: { ...fieldJson.expr, qualifier: undefined },\n\t\t\talias: { nodeName: registry.SelectItemAlias.NODE_NAME, as_kw: true, value: fieldJson.expr.value, delim: fieldJson.expr.delim },\n\t\t};\n\t}).concat(rowNumberJson);\n\n\tconst fromItemJson = {\n\t\tnodeName: registry.FromItem.NODE_NAME,\n\t\texpr: { nodeName: registry.TableRef1.NODE_NAME, value: fromName },\n\t};\n\n\treturn {\n\t\tnodeName: registry.CompleteSelectStmt.NODE_NAME,\n\t\tselect_list: { nodeName: registry.SelectList.NODE_NAME, entries: selectItems },\n\t\tfrom_clause: { nodeName: registry.FromClause.NODE_NAME, entries: [fromItemJson] },\n\t};\n};\n\nconst rowNumberExpr = (alias) => ({\n\tnodeName: registry.SelectItem.NODE_NAME,\n\texpr: { nodeName: registry.AggrCallExpr.NODE_NAME, name: 'ROW_NUMBER', arguments: [], over_clause: { nodeName: registry.WindowSpec.NODE_NAME } },\n\talias: { nodeName: registry.SelectItemAlias.NODE_NAME, as_kw: true, value: alias || 3 },\n});", "import { PayloadStmtMixin } from '../abstracts/PayloadStmtMixin.js';\nimport { DMLStmt } from './DMLStmt.js';\nimport { Transformer } from '../Transformer.js';\nimport { registry } from '../registry.js';\n\nexport class InsertStmt extends PayloadStmtMixin(DMLStmt) {\n\n\t/* SYNTAX RULES */\n\n\tstatic get _clause() { return 'INSERT'; }\n\n\tstatic get syntaxRules() {\n\t\tconst optional_alias_postgres = {\n\t\t\toptional: true,\n\t\t\tsyntax: [\n\t\t\t\t{ type: 'keyword', value: 'AS', booleanfy: true },\n\t\t\t\t{ type: 'Identifier', as: 'pg_table_alias', assert: true }\n\t\t\t]\n\t\t};\n\n\t\tconst optional_alias_mysql = {\n\t\t\toptional: true,\n\t\t\tdialect: 'mysql',\n\t\t\tif: ['!select_clause', '!my_table_clause'],\n\t\t\tsyntax: [\n\t\t\t\t{ type: 'keyword', value: 'AS' },\n\t\t\t\t{ type: 'FromItemAlias', as: 'my_row_alias', assert: true }\n\t\t\t]\n\t\t};\n\n\t\treturn [\n\t\t\t{ type: 'keyword', value: this._clause },\n\t\t\t{ type: 'keyword', value: 'INTO' },\n\t\t\t{\n\t\t\t\tassert: true,\n\t\t\t\tsyntax: [\n\t\t\t\t\t{\n\t\t\t\t\t\tdialect: 'postgres',\n\t\t\t\t\t\tsyntax: [\n\t\t\t\t\t\t\t{ type: 'TableRef2', as: 'table_ref' },\n\t\t\t\t\t\t\t{ ...optional_alias_postgres },\n\t\t\t\t\t\t\t{ type: 'ColumnsConstructor', as: 'column_list', optional: true, autoIndent: true, },\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tsyntaxes: [\n\t\t\t\t\t\t\t\t\t{ type: 'PGDefaultValuesClause', as: 'pg_default_values_clause' },\n\t\t\t\t\t\t\t\t\t{ type: 'ValuesConstructor', as: 'values_clause' },\n\t\t\t\t\t\t\t\t\t{ type: 'SelectStmt', as: 'select_clause' },\n\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\tautoSpacing: '\\n'\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t...(this._clause === 'INSERT' ? [{ type: 'PGOnConflictClause', as: 'conflict_handling_clause', optional: true, autoSpacing: '\\n' }] : []),\n\t\t\t\t\t\t\t{ type: 'ReturningClause', as: 'returning_clause', optional: true, autoSpacing: '\\n' },\n\t\t\t\t\t\t],\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tdialect: 'mysql',\n\t\t\t\t\t\tsyntax: [\n\t\t\t\t\t\t\t{ type: 'TableRef2', as: 'table_ref' },\n\t\t\t\t\t\t\t{ type: 'MYPartitionClause', as: 'my_partition_clause', optional: true, autoIndent: true },\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tsyntaxes: [\n\t\t\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t\t{ type: 'ColumnsConstructor', as: 'column_list', optional: true, autoIndent: true },\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tsyntaxes: [\n\t\t\t\t\t\t\t\t\t\t\t\t{ type: 'ValuesConstructor', as: 'values_clause' },\n\t\t\t\t\t\t\t\t\t\t\t\t{ type: 'SelectStmt', as: 'select_clause' },\n\t\t\t\t\t\t\t\t\t\t\t\t{ type: 'TableStmt', as: 'my_table_clause' },\n\t\t\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\t\t\tautoSpacing: '\\n'\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\t{ type: 'SetClause', as: 'my_set_clause', autoSpacing: '\\n' },\n\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{ ...optional_alias_mysql },\n\t\t\t\t\t\t\t...(this._clause === 'INSERT' ? [{ type: 'MYOnDuplicateKeyUpdateClause', as: 'conflict_handling_clause', optional: true, autoSpacing: '\\n' }] : []),\n\t\t\t\t\t\t\t{ type: 'ReturningClause', as: 'returning_clause', optional: true, autoSpacing: '\\n' },\n\t\t\t\t\t\t],\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t}\n\t\t];\n\t}\n\n\t/* AST API */\n\n\ttableRef() { return this._get('table_ref'); }\n\n\tcolumnList() { return this._get('column_list'); }\n\n\tvaluesClause() { return this._get('values_clause'); }\n\n\tselectClause() { return this._get('select_clause'); }\n\n\tconflictHandlingClause() { return this._get('conflict_handling_clause'); }\n\n\treturningClause() { return this._get('returning_clause'); }\n\n\t// -- Postgres\n\n\tpgTableAlias() { return this._get('pg_table_alias'); }\n\n\tpgDefaultValuesClause() { return this._get('pg_default_values_clause'); }\n\n\t// -- MySQL\n\n\tmyRowAlias() { return this._get('my_row_alias'); }\n\n\tmyPartitionClause() { return this._get('my_partition_clause'); }\n\n\tmySetClause() { return this._get('my_set_clause'); }\n\n\tmyTableClause() { return this._get('my_table_clause'); }\n\n\t/* JSON API */\n\n\tjsonfy(options = {}, transformer = null, schemaInference = null) {\n\t\tif (!options.deSugar) return super.jsonfy(options, transformer, schemaInference);\n\n\t\ttransformer = new Transformer((node, defaultTransform) => {\n\t\t\t// Process table abstraction nodes\n\t\t\tif (node instanceof registry.TableRef2) {\n\t\t\t\tlet subResultJson = defaultTransform();\n\n\t\t\t\tlet resultSchema = subResultJson.result_schema;\n\t\t\t\tif (subResultJson.pg_table_alias) {\n\t\t\t\t\tresultSchema = resultSchema.clone({ renameTo: subResultJson.pg_table_alias });\n\t\t\t\t}\n\n\t\t\t\ttransformer.statementContext.artifacts.get('tableSchemas').add({ type: 'dml', resultSchema });\n\n\t\t\t\treturn subResultJson;\n\t\t\t}\n\t\t\treturn defaultTransform();\n\t\t}, transformer, this/* IMPORTANT */);\n\n\t\tlet resultJson = super.jsonfy(options, transformer, schemaInference);\n\t\tconst toDialect = options.toDialect || this.options.dialect;\n\n\t\t// Order ouput JSON\n\t\tif (toDialect === 'mysql') {\n\t\t\tresultJson = {\n\t\t\t\tuuid: resultJson.uuid,\n\t\t\t\tnodeName: resultJson.nodeName,\n\t\t\t\ttable_ref: resultJson.table_ref,\n\t\t\t\tmy_partition_clause: resultJson.my_partition_clause,\n\t\t\t\tcolumn_list: resultJson.column_list,\n\t\t\t\tvalues_clause: resultJson.values_clause,\n\t\t\t\tselect_clause: resultJson.select_clause,\n\t\t\t\tmy_table_clause: resultJson.my_table_clause,\n\t\t\t\tmy_set_clause: resultJson.my_set_clause,\n\t\t\t\tmy_row_alias: resultJson.my_row_alias,\n\t\t\t\tconflict_handling_clause: resultJson.conflict_handling_clause,\n\t\t\t\treturning_clause: resultJson.returning_clause,\n\t\t\t\tresult_schema: resultJson.result_schema,\n\t\t\t};\n\t\t} else {\n\t\t\tresultJson = {\n\t\t\t\tuuid: resultJson.uuid,\n\t\t\t\tnodeName: resultJson.nodeName,\n\t\t\t\ttable_ref: resultJson.table_ref,\n\t\t\t\tpg_table_alias: resultJson.pg_table_alias,\n\t\t\t\tcolumn_list: resultJson.column_list,\n\t\t\t\tpg_default_values_clause: resultJson.pg_default_values_clause,\n\t\t\t\tvalues_clause: resultJson.values_clause,\n\t\t\t\tselect_clause: resultJson.select_clause,\n\t\t\t\tconflict_handling_clause: resultJson.conflict_handling_clause,\n\t\t\t\treturning_clause: resultJson.returning_clause,\n\t\t\t\tresult_schema: resultJson.result_schema,\n\t\t\t};\n\t\t}\n\n        if (resultJson.conflict_handling_clause?.entries\n\t\t\t&& !resultJson.conflict_handling_clause.entries.length) {\n            // All assignments were BackRefs and have been offloaded\n            const pkConstraint = resultJson.table_ref.result_schema.pkConstraint(true);\n            const pkColumn = pkConstraint.columns()[0];\n            resultJson = {\n                ...resultJson,\n                conflict_handling_clause: {\n                    ...resultJson.conflict_handling_clause,\n                    entries: [{\n                        nodeName: registry.AssignmentExpr.NODE_NAME,\n                        left: pkColumn.jsonfy(),\n                        operator: '=',\n                        right: pkColumn.jsonfy({ toKind: 1 })\n                    }],\n                },\n            };\n        }\n\n\t\tif (toDialect === 'postgres'\n\t\t\t&& !resultJson.pg_table_alias\n\t\t\t&& (options.deSugar === true || Number(options.deSugar?.tableAliases) === 1)) {\n\t\t\tresultJson = {\n\t\t\t\t...resultJson,\n\t\t\t\tpg_table_alias: {\n\t\t\t\t\tnodeName: registry.Identifier.NODE_NAME,\n\t\t\t\t\tvalue: resultJson.table_ref.value,\n\t\t\t\t\tdelim: resultJson.table_ref.delim\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\n\t\t// 1. Finalize output JSON\n\t\tresultJson = this.finalizeOutputJSON(resultJson, transformer, schemaInference, options);\n\t\tresultJson = {\n\t\t\t...resultJson,\n\t\t\torigin_schemas: this.getOriginSchemas(transformer),\n\t\t};\n\t\t// 2. Finalize generated JOINS. Must come last\n\t\tresultJson = this.finalizePayloadJSON(resultJson, transformer, schemaInference, options);\n\t\t\n\t\treturn resultJson;\n\t}\n}", "import { AbstractNodeList } from '../abstracts/AbstractNodeList.js';\n\nexport class MYSetStmt extends AbstractNodeList {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'keyword', value: 'SET' },\n            { type: 'MYVarAssignmentExpr', as: 'entries', arity: { min: 1 }, itemSeparator, assert: true, autoIndent: 2 },\n        ];\n    }\n}", "import { SelectorStmtMixin } from '../abstracts/SelectorStmtMixin.js';\nimport { PayloadStmtMixin } from '../abstracts/PayloadStmtMixin.js';\nimport { DMLStmt } from './DMLStmt.js';\nimport { Transformer } from '../Transformer.js';\nimport { registry } from '../registry.js';\n\nexport class UpdateStmt extends PayloadStmtMixin/* Must be outer as can morph to a CTE */(SelectorStmtMixin(DMLStmt)) {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'keyword', value: 'UPDATE' },\n            {\n                assert: true,\n                syntaxes: [\n                    {\n                        dialect: 'postgres',\n                        syntax: [\n                            { type: 'TableAbstraction2', as: 'table_expr' },\n                            { type: 'SetClause', as: 'set_clause', autoSpacing: '\\n' },\n                            { type: 'FromClause', as: 'pg_from_clause', optional: true, dialect: 'postgres', autoSpacing: '\\n' },\n                            { type: 'JoinClause', as: 'join_clauses', arity: Infinity, optional: true, autoSpacing: '\\n' },\n                            { type: ['PGWhereCurrentClause', 'WhereClause'], as: 'where_clause', optional: true, autoSpacing: '\\n' },\n                            { type: 'ReturningClause', as: 'returning_clause', optional: true, autoSpacing: '\\n' },\n                        ],\n                    },\n                    {\n                        dialect: 'mysql',\n                        syntax: [\n                            { type: 'TableAbstraction2', as: 'table_expr' },\n                            { type: 'SetClause', as: 'set_clause', autoSpacing: '\\n' },\n                            { type: 'WhereClause', as: 'where_clause', optional: true, autoSpacing: '\\n' },\n                            { type: 'OrderByClause', as: 'my_order_by_clause', optional: true, autoSpacing: '\\n' },\n                            { type: 'LimitClause', as: 'my_limit_clause', optional: true, autoSpacing: '\\n' },\n                            { type: 'ReturningClause', as: 'returning_clause', optional: true, autoSpacing: '\\n' },\n                        ],\n                    },\n                    {\n                        dialect: 'mysql',\n                        syntax: [\n                            { type: 'TableAbstraction1', as: 'my_update_list', arity: { min: 1 }, itemSeparator },\n                            { type: 'JoinClause', as: 'join_clauses', arity: Infinity, optional: true, autoSpacing: '\\n' },\n                            { type: 'SetClause', as: 'set_clause', autoSpacing: '\\n' },\n                            { type: 'WhereClause', as: 'where_clause', optional: true, autoSpacing: '\\n' },\n                            { type: 'ReturningClause', as: 'returning_clause', optional: true, autoSpacing: '\\n' },\n                        ],\n                    },\n                ]\n            }\n        ];\n    }\n\n    /* AST API */\n\n    tableExpr() { return this._get('table_expr'); }\n\n    joinClauses() { return this._get('join_clauses'); }\n\n    setClause() { return this._get('set_clause'); }\n\n    whereClause() { return this._get('where_clause'); }\n\n    returningClause() { return this._get('returning_clause'); }\n\n    // Postgres\n\n    pgFromClause() { return this._get('pg_from_clause'); }\n\n    // MySQL\n\n    myUpdateList() { return this._get('my_update_list'); }\n\n    myOrderByClause() { return this._get('my_order_by_clause'); }\n\n    myLimitClause() { return this._get('my_limit_clause'); }\n\n    /* JSON API */\n\n    jsonfy(options = {}, transformer = null, schemaInference = null) {\n        if (!options.deSugar) return super.jsonfy(options, transformer, schemaInference);\n\n        let deferedTransforms = {};\n        transformer = new Transformer((node, defaultTransform) => {\n            // Defer SelectItem resolution\n            if (node instanceof registry.SetClause) {\n                deferedTransforms.set_clause = defaultTransform;\n                return; // Exclude for now\n            }\n            return defaultTransform();\n        }, transformer, this/* IMPORTANT */);\n\n        let resultJson = super.jsonfy(options, transformer, schemaInference);\n        resultJson = { ...resultJson, set_clause: deferedTransforms.set_clause() };\n\n        // Order ouput JSON\n        if ((options.toDialect || this.options.dialect) === 'mysql') {\n            resultJson = {\n                uuid: resultJson.uuid,\n                nodeName: resultJson.nodeName,\n                table_expr: resultJson.table_expr,\n                my_update_list: resultJson.my_update_list,\n                join_clauses: resultJson.join_clauses,\n                set_clause: resultJson.set_clause,\n                where_clause: resultJson.where_clause,\n                my_order_by_clause: resultJson.my_order_by_clause,\n                my_limit_clause: resultJson.my_limit_clause,\n                returning_clause: resultJson.returning_clause,\n                result_schema: resultJson.result_schema,\n            };\n        } else {\n            resultJson = {\n                uuid: resultJson.uuid,\n                nodeName: resultJson.nodeName,\n                table_expr: resultJson.table_expr,\n                set_clause: resultJson.set_clause,\n                pg_from_clause: resultJson.pg_from_clause,\n                join_clauses: resultJson.join_clauses,\n                where_clause: resultJson.where_clause,\n                returning_clause: resultJson.returning_clause,\n                result_schema: resultJson.result_schema,\n            };\n        }\n\n        if (!resultJson.set_clause?.entries.length) {\n            // All assignments were BackRefs and have been offloaded\n            const pkConstraint = resultJson.table_expr.result_schema.pkConstraint(true);\n            const pkColumn = pkConstraint.columns()[0];\n            resultJson = {\n                ...resultJson,\n                set_clause: {\n                    ...resultJson.set_clause,\n                    entries: [{\n                        nodeName: registry.AssignmentExpr.NODE_NAME,\n                        left: pkColumn.jsonfy(),\n                        operator: '=',\n                        right: pkColumn.jsonfy({ toKind: 1 })\n                    }],\n                },\n            };\n        }\n\n        // 1. Finalize output JSON\n\t\tresultJson = this.finalizeOutputJSON(resultJson, transformer, schemaInference, options);\n        // 2. Finalize generated JOINS. Must come first\n        resultJson = this.finalizeSelectorJSON(resultJson, transformer, schemaInference, options);\n        resultJson = {\n\t\t\t...resultJson,\n\t\t\torigin_schemas: this.getOriginSchemas(transformer),\n\t\t};\n        // 3. Finalize entire query rewrite - returning a CTE\n        resultJson = this.finalizePayloadJSON(resultJson, transformer, schemaInference, options);\n\n        return resultJson;\n    }\n}", "import { SugarMixin } from '../abstracts/SugarMixin.js';\nimport { InsertStmt } from './InsertStmt.js';\nimport { registry } from '../registry.js';\nimport { _eq } from '../abstracts/util.js';\n\nexport class UpsertStmt extends SugarMixin(InsertStmt) {\n\n\t/* SYNTAX RULES */\n\n\tstatic get _clause() { return 'UPSERT'; }\n\n\tstatic morphsTo() { return [InsertStmt].concat(super.morphsTo()); }\n\n\t/* DESUGARING API */\n\n\tfinalizePayloadJSON(resultJson, transformer, schemaInference, options) {\n\t\tif (resultJson.conflict_handling_clause) {\n\t\t\tthrow new Error(`An explicit conflict handling clause is forbidden on the UPSERT statement.`);\n\t\t}\n\n\t\tconst tableSchema = [...transformer.statementContext.artifacts.get('tableSchemas')].map((t) => t.resultSchema)[0];\n\t\tconst toDialect = options.toDialect || this.options.dialect;\n\n\t\tlet columnNamesJson;\n\t\tif (resultJson.my_set_clause) {\n\t\t\tcolumnNamesJson = resultJson.my_set_clause.entries.map((e) => ({ value: e.left.value, delim: e.left.delim }));\n\t\t} else if (resultJson.column_list) {\n\t\t\tcolumnNamesJson = resultJson.column_list.entries.map((e) => ({ value: e.value, delim: e.delim }));\n\t\t} else {\n\t\t\tcolumnNamesJson = tableSchema.columns().map((c) => c.name().jsonfy({ nodeNames: false }));\n\t\t}\n\n\t\tconst conflictHandlingClause = {\n\t\t\tnodeName: toDialect === 'mysql'\n\t\t\t\t? registry.MYOnDuplicateKeyUpdateClause.NODE_NAME\n\t\t\t\t: registry.PGOnConflictClause.NODE_NAME,\n\t\t\tentries: columnNamesJson.map((c) => ({\n\t\t\t\tnodeName: registry.AssignmentExpr.NODE_NAME,\n\t\t\t\tleft: {\n\t\t\t\t\tnodeName: toDialect === 'mysql'\n\t\t\t\t\t\t? registry.ColumnRef1.NODE_NAME\n\t\t\t\t\t\t: registry.ColumnRef2.NODE_NAME,\n\t\t\t\t\t...c,\n\t\t\t\t},\n\t\t\t\toperator: '=',\n\t\t\t\tright: {\n\t\t\t\t\t...c,\n\t\t\t\t\tnodeName: registry.ColumnRef1.NODE_NAME,\n\t\t\t\t\tqualifier: { value: toDialect === 'mysql' ? 'VALUES' : 'EXCLUDED' },\n\t\t\t\t}\n\t\t\t})),\n\t\t};\n\n\t\tif (toDialect === 'postgres') {\n\t\t\tconst uniqueKeysColumnSets = [].concat(tableSchema.pkConstraint(true) || []).concat(tableSchema.ukConstraints(true)).map((k) => k.columns().map((c) => c.jsonfy()));\n\t\t\tif (!uniqueKeysColumnSets.length) {\n\t\t\t\tthrow new Error(`Table ${this.tableRef()} has no unique keys defined to process an UPSERT operation. You may want to perform a direct INSERT operation.`);\n\t\t\t}\n\n\t\t\tconst firstUniqueKeysColumnSet = uniqueKeysColumnSets.find((colSet) => colSet.find((k) => columnNamesJson.find((c) => _eq(k.value, c.value, k.delim || c.delim)))) || uniqueKeysColumnSets[0];\n\n\t\t\tconflictHandlingClause.conflict_target = {\n\t\t\t\tnodeName: registry.PGConflictTarget.NODE_NAME,\n\t\t\t\tindex_list: firstUniqueKeysColumnSet.map((c) => ({\n\t\t\t\t\tnodeName: registry.PGConflictTargetIndexSpec.NODE_NAME,\n\t\t\t\t\tcolumn_name: c\n\t\t\t\t})),\n\t\t\t};\n\t\t}\n\t\t\n\t\treturn super.finalizePayloadJSON({\n\t\t\t...resultJson,\n\t\t\tnodeName: InsertStmt.NODE_NAME,\n\t\t\tconflict_handling_clause: conflictHandlingClause\n\t\t}, transformer, schemaInference, options);\n\t}\n}", "export * from './clauses/index.js';\nexport * from './TA/index.js';\nexport { CompleteSelectStmt } from './CompleteSelectStmt.js';\nexport { BasicSelectStmt } from './BasicSelectStmt.js';\nexport { CompositeSelectStmt } from './CompositeSelectStmt.js';\nexport { SelectStmt } from './SelectStmt.js';\nexport { TableStmt } from './TableStmt.js';\n", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class DistinctClause extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return {\n            syntaxes: [\n                {\n                    dialect: 'postgres',\n                    syntax: [\n                        { type: 'keyword', value: 'DISTINCT' },\n                        { type: 'keyword', value: 'ON' },\n                        {\n                            type: 'paren_block',\n                            syntax: { type: 'Expr', as: 'pg_distinct_on_list', arity: { min: 1 }, itemSeparator, assert: true }\n                        },\n                    ],\n                },\n                { type: 'keyword', as: 'all_or_distinct', value: ['ALL', 'DISTINCT'] },\n            ]\n        };\n    }\n\n    /* AST API */\n\n    allOrDistinct() { return this._get('all_or_distinct'); }\n\n    // -- Postgres\n\n    pgDistinctOnList() { return this._get('pg_distinct_on_list'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class ForClause extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'keyword', value: 'FOR' },\n            {\n                optional: true,\n                dialect: 'postgres',\n                syntaxes: [\n                    [\n                        { type: 'keyword', as: 'pg_no_key_kw', value: 'NO', booleanfy: true },\n                        { type: 'keyword', value: 'KEY', if: 'pg_no_key_kw', assert: true }\n                    ],\n                    { type: 'keyword', as: 'pg_key_kw', value: 'KEY', booleanfy: true },\n                ],\n            },\n            { type: 'keyword', as: 'intent_kw', value: ['UPDATE', 'SHARE'], assert: true },\n            {\n                optional: true,\n                syntax: [\n                    { type: 'keyword', value: 'OF' },\n                    { type: 'TableRef2', as: 'table_names', arity: { min: 1 }, itemSeparator, assert: true }\n                ],\n            },\n            {\n                optional: true,\n                syntaxes: [\n                    [\n                        { type: 'keyword', as: 'skip_locked_kw', value: 'SKIP', booleanfy: true },\n                        { type: 'keyword', value: 'LOCKED', assert: true }\n                    ],\n                    { type: 'keyword', as: 'nowait_kw', value: 'NOWAIT', booleanfy: true },\n                    {\n                        dialect: 'mysql',\n                        syntax: [\n                            { type: 'keyword', as: 'my_lock_in_share_mode', value: 'LOCK', booleanfy: true },\n                            { type: 'operator', value: 'IN', assert: true },\n                            { type: 'keyword', value: 'SHARE', assert: true },\n                            { type: 'keyword', value: 'MODE', assert: true },\n                        ],\n                    },\n                ],\n            }\n        ];\n    }\n\n    /* AST API */\n\n    intentKW() { return this._get('intent_kw'); }\n\n    tableNames() { return this._get('table_names'); }\n\n    skipLockedKW() { return this._get('skip_locked_kw'); }\n\n    nowaitKW() { return this._get('nowait_kw'); }\n\n    // -- Postgres\n\n    pgKeyKW() { return this._get('pg_key_kw'); }\n\n    pgNoKeyKW() { return this._get('pg_no_key_kw'); }\n\n    // -- MySQL\n\n    myLockInShareMode() { return this._get('my_lock_in_share_mode'); }\n}", "import { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\n\nexport class FromClause extends AbstractNodeList {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'keyword', value: 'FROM' },\n            { type: 'FromItem', as: 'entries', arity: { min: 1 }, itemSeparator, assert: true }\n        ];\n    }\n}", "import { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\n\nexport class GroupByClause extends AbstractNodeList {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'keyword', value: 'GROUP' },\n            { type: 'keyword', value: 'BY', assert: true },\n            { type: 'keyword', as: 'all_or_distinct', value: ['ALL', 'DISTINCT'], optional: true },\n            { type: 'GroupingElement', as: 'entries', arity: { min: 1 }, itemSeparator, assert: true, autoIndent: 2 },\n            {\n                optional: true,\n                autoIndent: true,\n                syntax: [\n                    { type: 'keyword', as: 'with_rollup', value: 'WITH', booleanfy: true },\n                    { type: 'keyword', value: 'ROLLUP', assert: true },\n                ]\n            },\n        ];\n    }\n\n    /* AST API */\n\n    allOrDistinct() { return this._get('all_or_distinct'); }\n\n    withRollup() { return this._get('with_rollup'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class GroupingElement extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return {\n            syntaxes: [\n                [\n                    { type: 'keyword', value: 'GROUPING SETS' },\n                    {\n                        type: 'paren_block', syntax:\n                            { type: 'GroupingElement', as: 'grouping_sets', arity: { min: 1 }, itemSeparator, assert: true, autoIndent: 2 },\n                        autoIndent: true\n                    }\n                ],\n                [\n                    { type: 'keyword', value: 'ROLLUP' },\n                    { type: 'RowConstructor', as: 'rollup_set', assert: true },\n                ],\n                [\n                    { type: 'keyword', value: 'CUBE' },\n                    { type: 'RowConstructor', as: 'cube_set', assert: true },\n                ],\n                { type: 'Expr', as: 'expr' },\n            ]\n        };\n    }\n\n    /* AST API */\n\n    groupingSets() { return this._get('grouping_sets'); }\n\n    rollupSet() { return this._get('rollup_set'); }\n\n    cubeSet() { return this._get('cube_set'); }\n\n    expr() { return this._get('expr'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class HavingClause extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', value: 'HAVING' },\n            { type: 'Expr', as: 'expr', assert: true }\n        ];\n    }\n\n    static get syntaxPriority() { return -1; }\n\n    /* AST API */\n\n    expr() { return this._get('expr'); }\n}", "import { ResultSchemaMixin } from '../../abstracts/ResultSchemaMixin.js';\nimport { AbstractNode } from '../../abstracts/AbstractNode.js';\nimport { Transformer } from '../../Transformer.js';\nimport { registry } from '../../registry.js';\n\nexport class FromItem extends ResultSchemaMixin(AbstractNode) {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n\n        const optional_table_sample_clause_postgres = {\n            optional: true,\n            dialect: 'postgres',\n            syntax: [\n                { type: 'keyword', value: 'TABLESAMPLE' },\n                {\n                    syntaxes: [\n                        [\n                            { type: 'keyword', as: 'pg_sampling_method', value: ['BERNOULLI', 'SYSTEM'] },\n                            { type: 'paren_block', syntax: { type: 'Expr', as: 'pg_sampling_arguments', arity: 1, itemSeparator, assert: true } },\n                        ],\n                        [\n                            { type: 'identifier', as: 'pg_sampling_method' },\n                            { type: 'paren_block', syntax: { type: 'Expr', as: 'pg_sampling_arguments', arity: Infinity, itemSeparator, assert: true } },\n                        ],\n                    ],\n                    assert: true,\n                },\n                {\n                    optional: true,\n                    syntax: [\n                        { type: 'keyword', value: 'REPEATABLE' },\n                        { type: 'paren_block', syntax: { type: 'Expr', as: 'pg_repeatable_seed' }, assert: true },\n                    ]\n                }\n            ]\n        };\n\n        return {\n            syntaxes: [\n                // SRFTableDef1, SRFTableDef2, SRFTableDef3, SRFTableDef4\n                [\n                    { type: 'keyword', as: 'lateral_kw', value: 'LATERAL', booleanfy: true, optional: true },\n                    { type: 'SRFExpr1', as: 'expr' },\n                ],\n                [\n                    { type: 'keyword', as: 'lateral_kw', value: 'LATERAL', booleanfy: true, optional: true },\n                    { type: ['SRFExpr2', 'SRFExpr4'], as: 'expr' },\n                    { type: 'FromItemAlias', as: 'alias', optional: true },\n                ],\n                // DerivedQuery, ValuesTableLiteral\n                [\n                    { type: 'keyword', as: 'lateral_kw', value: 'LATERAL', booleanfy: true, optional: true },\n                    { type: ['DerivedQuery', 'ValuesTableLiteral'], as: 'expr', dialect: 'postgres' },\n                    { type: 'DerivedQuery', as: 'expr', dialect: 'mysql' },\n                    { type: 'FromItemAlias', as: 'alias', optional: true },\n                ],\n                // TableRef1\n                [\n                    { type: 'keyword', as: 'pg_only_kw', value: 'ONLY', optional: true, dialect: 'postgres' },\n                    { type: ['TableRef1', 'TableRef2'], as: 'expr' },\n                    { type: 'operator', as: 'pg_star_ref', value: '*', booleanfy: true, optional: true, dialect: 'postgres' },\n                    { type: 'FromItemAlias', as: 'alias', optional: true },\n                    { ...optional_table_sample_clause_postgres },\n                ],\n            ],\n        };\n    }\n\n    /* AST API */\n\n    lateralKW() { return this._get('lateral_kw'); }\n\n    expr() { return this._get('expr'); }\n\n    alias() { return this._get('alias'); }\n\n    // -- Postgres\n\n    pgOnlyKW() { return this._get('pg_only_kw'); }\n\n    pgStarRef() { return this._get('pg_star_ref'); }\n\n    pgSamplingMethod() { return this._get('pg_sampling_method'); }\n\n    pgSamplingArguments() { return this._get('pg_sampling_arguments'); }\n\n    pgRepeatableSeed() { return this._get('pg_repeatable_seed'); }\n\n    /* SCHEMA API */\n\n    deriveAlias() {\n        let derivedAliasJson;\n        if (this.alias()?.value()) {\n            derivedAliasJson = { as_kw: true, value: this.alias().value(), delim: this.alias()._get('delim') };\n        } else if (this.expr() instanceof registry.TableRef1 || this.expr() instanceof registry.TableRef2) {\n            derivedAliasJson = { as_kw: true, value: this.expr().value(), delim: this.expr()._get('delim') };\n        } else if (this.expr() instanceof registry.SRFExpr1\n            && this.expr().qualif() instanceof registry.SRFExprDDL2) {\n            derivedAliasJson = { as_kw: true, value: this.expr().qualif().alias().value(), delim: this.expr().qualif().alias()._get('delim') };\n        }\n        if (derivedAliasJson) {\n            return registry.FromItemAlias.fromJSON(derivedAliasJson);\n        }\n    }\n\n    jsonfy(options = {}, transformer = null, schemaInference = null) {\n        let resultJson = super.jsonfy(options, transformer, schemaInference);\n        if (options.deSugar) {\n\n            const derivedAliasJson = resultJson.alias || this.deriveAlias()?.jsonfy();\n\n            const schemaIdent = derivedAliasJson?.value && {\n                nodeName: registry.Identifier.NODE_NAME,\n                value: derivedAliasJson.value,\n                delim: derivedAliasJson.delim,\n            };\n\n            let resultSchema = resultJson.expr.result_schema;\n\n\n            if (resultSchema instanceof registry.TableSchema) {\n                resultSchema = resultSchema.clone({ renameTo: schemaIdent });\n            } else if (schemaIdent) {\n                resultSchema = registry.TableSchema.fromJSON({\n                    name: schemaIdent,\n                    entries: resultSchema?.entries().map((s) => s.jsonfy()) || [],\n                }, { assert: true });\n            }\n            \n            if (resultJson.alias?.columns?.length) {\n                if (resultJson.alias.columns.length !== resultSchema.length) {\n                    throw new SyntaxError(`[${this}] Number of column aliases must match number of result columns.`);\n                }\n                resultSchema = resultSchema.clone({}, new Transformer((node, defaultTransform, key) => {\n                    if (typeof key === 'number' && node.parentNode === resultSchema) {\n                        if (node instanceof registry.ColumnSchema) {\n                            return node.jsonfy({ renameTo: resultJson.alias.columns[key] });\n                        }\n                        return {\n                            ...node.jsonfy(),\n                            nodeName: registry.ColumnSchema.NODE_NAME,\n                            name: resultJson.alias.columns[key],\n                        };\n                    }\n                    return defaultTransform();\n                }));\n            }\n\n            transformer.statementContext.artifacts.get('tableSchemas').add({ type: this.joinType?.() || 'dql', lateral: this.lateralKW(), resultSchema });\n\n            const applicableAliasJson = !(this.expr() instanceof registry.SRFExpr1) && (\n                options.deSugar === true ||  Number(options.deSugar?.tableAliases) === 1 || options.deSugar?.tableAliases === -1 && (this.parentNode?.length || 0) > 1\n            ) && derivedAliasJson || resultJson.alias;\n            resultJson = {\n                ...resultJson,\n                alias: applicableAliasJson,\n                result_schema: resultSchema,\n            };\n        }\n\n        return resultJson;\n    }\n}", "import { Transformer } from '../../Transformer.js';\nimport { FromItem } from '../TA/FromItem.js';\n\nexport class JoinClause extends FromItem {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            syntaxes: [\n                [\n                    { type: 'keyword', as: 'join_type', value: 'CROSS' },\n                    { type: 'keyword', value: 'JOIN', assert: true },\n                    ...[].concat(super.syntaxRules),\n                ],\n                [\n                    { type: 'keyword', as: 'natural_kw', value: 'NATURAL', booleanfy: true, optional: true },\n                    {\n                        optional: true,\n                        syntaxes: [\n                            { type: 'keyword', as: 'join_type', value: 'INNER' },\n                            [\n                                { type: 'keyword', as: 'join_type', value: ['LEFT', 'RIGHT', 'FULL'], dialect: 'postgres' },\n                                { type: 'keyword', as: 'join_type', value: ['LEFT', 'RIGHT'], dialect: 'mysql' },\n                                { type: 'keyword', as: 'outer_kw', value: 'OUTER', booleanfy: true, optional: true },\n                            ],\n                        ],\n                    },\n                    { type: 'keyword', value: 'JOIN' },\n                    ...[].concat(super.syntaxRules),\n                    { type: ['OnClause', 'UsingClause'], as: 'condition_clause', if: '!natural_kw', assert: true, autoIndent: true },\n                ],\n            ],\n        };\n    }\n\n    /* AST API */\n\n    naturalKW() { return this._get('natural_kw'); }\n\n    joinType() { return this._get('join_type'); }\n\n    outerKW() { return this._get('outer_kw'); }\n\n    conditionClause() { return this._get('condition_clause'); }\n\n    /* JSON API */\n\n    jsonfy(options = {}, transformer = null, schemaInference = null) {\n        let conditionClauseTransform;\n\n        if (options.deSugar) {\n            transformer = new Transformer((node, defaultTransform, keyHint) => {\n                if (keyHint === 'condition_clause') {\n                    conditionClauseTransform = defaultTransform;\n                } else return defaultTransform();\n            }, transformer, this.statementNode/* IMPORTANT */);\n        }\n\n        let resultJson = super.jsonfy(options, transformer, schemaInference);\n\n        if (conditionClauseTransform) {\n            resultJson = {\n                ...resultJson,\n                condition_clause: conditionClauseTransform(),\n            };\n        }\n\n        return resultJson;\n    }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class LimitClause extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', value: 'LIMIT' },\n            {\n                dialect: 'mysql',\n                syntax: [\n                    {\n                        optional: true,\n                        syntax: [\n                            { type: 'Expr', as: 'my_offset' },\n                            { type: 'punctuation', value: ',', autoSpacing: false },\n                        ]\n                    },\n                    { type: 'Expr', as: 'expr', assert: true, },\n                ]\n            },\n            {\n                dialect: 'postgres',\n                syntaxes: [\n                    { type: 'keyword', as: 'pg_all_kw', value: 'ALL' },\n                    { type: 'Expr', as: 'expr', assert: true },\n                ],\n            },\n        ];\n    }\n\n    /* AST API */\n\n    expr() { return this._get('expr'); }\n\n    // -- Postgres\n\n    pgAllKW() { return this._get('pg_all_kw'); }\n\n    // -- MySQL\n\n    myOffset() { return this._get('my_offset'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class OffsetClause extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', value: 'OFFSET' },\n            { type: 'Expr', as: 'expr', assert: true, },\n            { type: 'keyword', as: 'pg_row_kw', value: ['ROW', 'ROWS'], optional: true, dialect: 'postgres' },\n        ];\n    }\n\n    /* AST API */\n\n    expr() { return this._get('expr'); }\n\n    // -- Postgres\n\n    pgRowKW() { return this._get('pg_row_kw'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class OnClause extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', value: 'ON' },\n            { type: 'Expr', as: 'expr', assert: true }\n        ];\n    }\n\n    /* AST API */\n\n    expr() { return this._get('expr'); }\n}", "import { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\n\nexport class OrderByClause extends AbstractNodeList {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'keyword', value: 'ORDER' },\n            { type: 'keyword', value: 'BY', assert: true },\n            { type: 'OrderElement', as: 'entries', arity: { min: 1 }, itemSeparator, assert: true, autoIndent: 2 },\n            {\n                optional: true,\n                autoIndent: true,\n                syntax: [\n                    { type: 'keyword', as: 'with_rollup', value: 'WITH', booleanfy: true },\n                    { type: 'keyword', value: 'ROLLUP', assert: true },\n                ]\n            },\n        ];\n    }\n\n    /* AST API */\n\n    withRollup() { return this._get('with_rollup'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class OrderElement extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'Expr', as: 'expr' },\n            {\n                optional: true,\n                syntaxes: [\n                    { type: 'keyword', value: ['ASC', 'DESC'], as: 'dir' },\n                    { type: 'PGOrderOperator', as: 'dir' },\n                ]\n            },\n            {\n                optional: true,\n                syntax: [\n                    { type: 'keyword', value: 'NULLS' },\n                    { type: 'keyword', as: 'nulls_spec', value: ['FIRST', 'LAST'], assert: true },\n                ]\n            },\n        ];\n    }\n\n    /* AST API */\n\n    expr() { return this._get('expr'); }\n\n    dir() { return this._get('dir'); }\n\n    nullsSpec() { return this._get('nulls_spec'); }\n}", "import { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\n\nexport class PartitionByClause extends AbstractNodeList {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'keyword', value: 'PARTITION' },\n            { type: 'keyword', value: 'BY', assert: true },\n            { type: 'Expr', as: 'entries', arity: { min: 1 }, itemSeparator, assert: true, autoIndent: 2 }\n        ];\n    }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class PGFetchClause extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            dialect: 'postgres',\n            syntax: [\n                { type: 'keyword', value: 'FETCH' },\n                { type: 'keyword', as: 'rel_kw', value: ['FIRST', 'NEXT'] },\n                { type: 'Expr', as: 'expr', optional: true },\n                { type: 'keyword', as: 'row_kw', value: ['ROW', 'ROWS'], assert: true },\n                {\n                    syntaxes: [\n                        { type: 'keyword', value: 'ONLY' },\n                        [\n                            { type: 'keyword', as: 'with_ties', value: 'WITH' },\n                            { type: 'keyword', value: 'TIES', assert: true },\n                        ]\n                    ]\n                }\n            ]\n        };\n    }\n\n    /* AST API */\n\n    relKW() { return this._get('rel_kw'); }\n\n    expr() { return this._get('expr'); }\n\n    rowKW() { return this._get('row_kw'); }\n\n    withTies() { return this._get('with_ties'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class PGOrderOperator extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            dialect: 'postgres',\n            syntax: [\n                { type: 'keyword', value: 'USING' },\n                { type: 'operator', as: '.', assert: true },\n            ],\n        };\n    }\n\n    /* AST API */\n\n    value() { return this._get('value'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class UsingClause extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'keyword', value: 'USING' },\n            {\n                syntaxes: [\n                    { type: 'Identifier', as: 'column' },\n                    {\n                        type: 'paren_block',\n                        syntax: { type: 'Identifier', as: 'columns', arity: { min: 1 }, itemSeparator, assert: true }\n                    }\n                ], assert: true\n            },\n        ];\n    }\n\n    /* AST API */\n\n    column() { return this._get('column'); }\n\n    columns() { return this._get('columns'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class WhereClause extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', value: 'WHERE' },\n            { type: 'Expr', as: 'expr', assert: true }\n        ];\n    }\n\n    /* AST API */\n\n    expr() { return this._get('expr'); }\n}", "import { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\n\nexport class WindowClause extends AbstractNodeList {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'keyword', value: 'WINDOW' },\n            { type: 'WindowDeclaration', as: 'entries', arity: { min: 1 }, itemSeparator, assert: true, autoIndent: 2 },\n        ];\n    }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class WindowDeclaration extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'Identifier', as: 'name' },\n            { type: 'keyword', value: 'AS' },\n            { type: 'WindowSpec', as: 'spec', assert: true }\n        ];\n    }\n\n    /* AST API */\n\n    name() { return this._get('name'); }\n\n    spec() { return this._get('spec'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class WindowFrameSpec extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'operator', value: 'AND' };\n        return [\n            { type: 'keyword', as: 'specifier', value: ['ROWS', 'RANGE', 'GROUPS'] },\n            {\n                syntaxes: [\n                    [\n                        { type: 'operator', as: 'with_between_clause', value: 'BETWEEN', booleanfy: true },\n                        { type: 'WindowFrameBound', as: 'bounds', arity: 2, itemSeparator, assert: true },\n                    ],\n                    { type: 'WindowFrameBound', as: 'bounds', arity: 1, itemSeparator, assert: true },\n\n                ]\n            },\n            {\n                optional: true,\n                syntax: [\n                    { type: 'keyword', value: 'EXCLUDE' },\n                    { type: 'keyword', as: 'exclusion', value: ['CURRENT ROW', 'GROUP', 'TIES', 'NO OTHERS'], assert: true },\n                ]\n            },\n        ];\n    }\n\n    /* AST API */\n\n    specifier() { return this._get('specifier'); }\n\n    withBetweenClause() { return this._get('with_between_clause'); }\n\n    bounds() { return this._get('bounds'); }\n\n    exclusion() { return this._get('exclusion'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class WindowFrameBound extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            syntaxes: [\n                { type: 'keyword', as: 'specifier', value: 'CURRENT ROW' },\n                [\n                    { type: 'keyword', as: 'specifier', value: 'UNBOUNDED' },\n                    { type: 'keyword', as: 'dir', value: ['PRECEDING', 'FOLLOWING'] },\n                ],\n                [\n                    { type: 'number_literal', as: 'specifier' },\n                    { type: 'keyword', as: 'dir', value: ['PRECEDING', 'FOLLOWING'] },\n                ],\n                [\n                    { type: 'Expr'/* Ideally, Temporal types */, as: 'specifier' },\n                    { type: 'keyword', as: 'dir', value: ['PRECEDING', 'FOLLOWING'] },\n                ],\n            ]\n        };\n    }\n\n    /* AST API */\n\n    specifier() { return this._get('specifier'); }\n\n    dir() { return this._get('dir'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class WindowSpec extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            type: 'paren_block',\n            syntax: [\n                { type: 'WindowRef', as: 'super_window', optional: true },\n                { type: 'PartitionByClause', as: 'partition_by_clause', optional: true, autoIndent: true },\n                { type: 'OrderByClause', as: 'order_by_clause', optional: true, autoIndent: true },\n                { type: 'WindowFrameSpec', as: 'frame_spec', optional: true, autoIndent: true },\n            ],\n            autoIndent: true,\n            autoIndentAdjust: -1\n        };\n    }\n\n    /* AST API */\n\n    superWindow() { return this._get('super_window'); }\n\n    partitionByClause() { return this._get('partition_by_clause'); }\n\n    orderByClause() { return this._get('order_by_clause'); }\n\n    frameSpec() { return this._get('frame_spec'); }\n}", "import { Identifier } from '../../expr/ref/Identifier.js';\n\nexport class FromItemAlias extends Identifier {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            {\n                syntaxes: [\n                    { ...[].concat(super.syntaxRules)[0] },\n                    [\n                        { type: 'keyword', as: 'as_kw', value: 'AS', booleanfy: true },\n                        { ...[].concat(super.syntaxRules)[0], assert: true },\n                    ]\n                ]\n            },\n            {\n                type: 'paren_block',\n                syntax: { type: 'Identifier', as: 'columns', arity: { min: 1 }, itemSeparator, assert: true },\n                if: 'value',\n                optional: true,\n                optionalParens: true,\n            }\n        ];\n    }\n\n    /* AST API */\n\n    asKW() { return this._get('as_kw'); }\n\n    columns() { return this._get('columns'); }\n\n    // --------------\n\n    jsonfy(options = {}, transformer = null, schemaInference = null) {\n        let resultJson = super.jsonfy(options, transformer, schemaInference);\n        if ((options.deSugar === true || options.deSugar?.normalizeCasing) && !resultJson.delim) {\n            resultJson = { ...resultJson, value: resultJson.value.toLowerCase() };\n        }\n        return resultJson;\n    }\n}", "import { ResultSchemaMixin } from '../../abstracts/ResultSchemaMixin.js';\nimport { AbstractNode } from '../../abstracts/AbstractNode.js';\nimport { registry } from '../../registry.js';\n\nexport class SelectItem extends ResultSchemaMixin(AbstractNode) {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: ['Expr', 'ColumnRef0', 'MYVarAssignmentExpr'], as: 'expr' },\n            { type: 'SelectItemAlias', as: 'alias', optional: true }\n        ];\n    }\n\n    /* AST API */\n\n    expr() { return this._get('expr'); }\n\n    alias() { return this._get('alias'); }\n\n    /* SCHEMA API */\n\n    deriveAlias() {\n\n        let derivedAliasJson = this.alias()?.jsonfy();\n\n        let exprNode = this.expr();\n        if (exprNode instanceof registry.ColumnRef0) return;\n\n        // Resolve RowConstructor\n        if (exprNode instanceof registry.RowConstructor) {\n            exprNode = exprNode.exprUnwrapped();\n        }\n\n        // Resolve CastExpr | PGCastExpr2\n        if (exprNode instanceof registry.CastExpr\n            || exprNode instanceof registry.PGCastExpr2) {\n            exprNode = exprNode.expr();\n        }\n\n        if (!derivedAliasJson) {\n            if (exprNode instanceof registry.ColumnRef1) {\n                derivedAliasJson = { as_kw: true, value: exprNode.value(), delim: exprNode._get('delim') };\n            } else if (exprNode instanceof registry.LQDeepRef1 && exprNode.endpoint() instanceof registry.ColumnRef2) {\n                const endpointNode = exprNode.endpoint();\n                derivedAliasJson = { as_kw: true, value: endpointNode.value(), delim: endpointNode._get('delim') };\n            } else {\n                const isToPG = this.options.dialect === 'postgres';\n                if (exprNode instanceof registry.CallExpr && isToPG) {\n                    derivedAliasJson = { as_kw: true, value: exprNode.name().toLowerCase() };\n                }\n            }\n        }\n\n        return registry.SelectItemAlias.fromJSON(derivedAliasJson);\n    }\n\n    jsonfy(options = {}, transformer = null, schemaInference = null) {\n        if (options.deSugar) {\n\n            const derivedAliasNode = this.deriveAlias();\n\n            let asAggr,\n                derivedAliasJson = derivedAliasNode && (transformer\n                    ? transformer.transform(derivedAliasNode, ($options = options) => derivedAliasNode.jsonfy($options), 'alias', options)\n                    : derivedAliasNode.jsonfy(options));\n            if (derivedAliasJson?.is_aggr) ({ is_aggr: asAggr, ...derivedAliasJson } = derivedAliasJson);\n\n            const exprNode = this.expr();\n\n            let defaultExprTransform;\n\n            if (asAggr && !(exprNode instanceof registry.LQDeepRef1)) {\n                // Note the below where we wrap value in an aggr call\n                defaultExprTransform = ($options = options, childTransformer = transformer) => ({\n                    nodeName: registry.AggrCallExpr.NODE_NAME,\n                    name: (options.toDialect || this.options.dialect) === 'mysql' ? 'JSON_ARRAYAGG' : 'JSON_AGG',\n                    arguments: [exprNode.jsonfy($options, childTransformer, schemaInference)],\n                });\n            } else {\n                // Note the below where we derive value, if not specified, from key\n                defaultExprTransform = ($options = options, childTransformer = transformer) => {\n                    return exprNode.jsonfy($options, childTransformer, schemaInference);\n                };\n            }\n\n            const exprJson = transformer\n                ? transformer.transform(exprNode, defaultExprTransform, 'expr', { ...options, asAggr })\n                : defaultExprTransform();\n\n            // ----------------\n\n            const schemaIdent = derivedAliasJson && {\n                nodeName: registry.Identifier.NODE_NAME,\n                value: derivedAliasJson.value,\n                delim: derivedAliasJson.delim\n            } || {\n                nodeName: registry.Identifier.NODE_NAME,\n                value: this.options.dialect === 'postgres' ? '?column?' : exprNode.stringify(),\n            };\n\n            let resultSchema = exprJson.result_schema;\n\n            if (resultSchema instanceof registry.ColumnSchema) {\n                const tableSchema = resultSchema.parentNode;\n                resultSchema = resultSchema.clone({ renameTo: schemaIdent });\n                tableSchema?._adoptNodes(resultSchema);\n            } else if (!(exprNode instanceof registry.LQDeepRef1)\n                && !(exprNode instanceof registry.ColumnRef0)) {\n                resultSchema = registry.ColumnSchema.fromJSON({\n                    name: schemaIdent,\n                    data_type: this.expr().dataType().jsonfy(),\n                });\n                exprNode._adoptNodes(resultSchema);\n            }\n\n            const applicableAliasJson = (asAggr || options.deSugar === true || Number(options.deSugar?.selectAliases) === 1 || (\n                options.deSugar?.selectAliases === -1 && (this.parentNode?.entries().length || 0) > 1\n            )) && derivedAliasJson || this.alias()?.jsonfy();\n\n            return {\n                nodeName: SelectItem.NODE_NAME,\n                expr: exprJson,\n                alias: applicableAliasJson,\n                result_schema: resultSchema,\n            };\n        }\n        return super.jsonfy(options, transformer, schemaInference);\n    }\n}", "import { Identifier } from '../../expr/ref/Identifier.js';\n\nexport class SelectItemAlias extends Identifier {\n    static get syntaxRules() {\n        return [\n            {\n                syntaxes: [\n                    { ...[].concat(super.syntaxRules)[0] },\n                    [\n                        { type: 'keyword', as: 'as_kw', value: 'AS', booleanfy: true },\n                        { ...[].concat(super.syntaxRules)[0], assert: true },\n                    ]\n                ]\n            },\n            { type: 'AggrNotation', as: 'is_aggr', autoSpacing: false, optional: true },\n        ];\n    }\n\n    /* AST API */\n\n    asKW() { return this._get('as_kw'); }\n\n    isAggr() { return this._get('is_aggr'); }\n\n    // --------------\n\n    jsonfy(options = {}, transformer = null, schemaInference = null) {\n        let resultJson = super.jsonfy(options, transformer, schemaInference);\n        if ((options.deSugar === true || options.deSugar?.normalizeCasing) && !resultJson.delim) {\n            resultJson = { ...resultJson, value: resultJson.value.toLowerCase(), };\n        }\n        return resultJson;\n    }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\nimport { ResultSchemaMixin } from '../../abstracts/ResultSchemaMixin.js';\nimport { registry } from '../../registry.js';\n\nexport class SRFExpr1 extends ResultSchemaMixin(AbstractNode) {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'CallExpr', as: 'call_expr' },\n            { type: ['SRFExprDDL1', 'SRFExprDDL2'], as: 'qualif' },\n        ];\n    }\n\n    /* AST API */\n\n    callExpr() { return this._get('call_expr'); }\n\n    qualif() { return this._get('qualif'); }\n\n    /* JSON API */\n\n    jsonfy(options = {}, transformer = null, schemaInference = null) {\n        let resultJson = super.jsonfy(options, transformer, schemaInference);\n        if (options.deSugar) {\n            \n            const columnDefsJson = resultJson.qualif?.column_defs || [];\n            const resultSchema = resultJson.qualif?.alias\n                // a. Compose from \"column_defs\" with explicit table alias\n                ? registry.TableSchema.fromJSON({\n                    name: resultJson.qualif.alias,\n                    entries: columnDefsJson,\n                })\n                // b. Compose from \"column_defs\" without explicit table alias\n                : registry.JSONSchema.fromJSON({\n                    entries: columnDefsJson,\n                });\n\n            resultJson = {\n                ...resultJson,\n                result_schema: resultSchema\n            };\n        }\n\n        return resultJson;\n    }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\nimport { ResultSchemaMixin } from '../../abstracts/ResultSchemaMixin.js';\nimport { registry } from '../../registry.js';\n\nexport class SRFExpr2 extends ResultSchemaMixin(AbstractNode) {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'CallExpr', as: 'call_expr' },\n            {\n                optional: true,\n                syntax: [\n                    { type: 'keyword', as: 'with_ordinality', value: 'WITH', booleanfy: true },\n                    { type: 'keyword', value: 'ORDINALITY', assert: true },\n                ]\n            },\n        ];\n    }\n\n    /* AST API */\n\n    callExpr() { return this._get('call_expr'); }\n\n    withOrdinality() { return this._get('with_ordinality'); }\n\n    /* JSON API */\n\n    jsonfy(options = {}, transformer = null, schemaInference = null) {\n        let resultJson = super.jsonfy(options, transformer, schemaInference);\n        if (options.deSugar) {\n\n            let resultSchema;\n\n            let ordinalityColumn;\n            if (resultJson.with_ordinality) {\n                ordinalityColumn = registry.ColumnSchema.fromJSON({\n                    name: { nodeName: registry.Identifier.NODE_NAME, value: 'ordinality' },\n                    data_type: { nodeName: registry.DataType.NODE_NAME, value: 'INT' },\n                });\n            }\n\n            const schemaIdentFromFuncName = { nodeName: registry.Identifier.NODE_NAME, value: resultJson.call_expr.name };\n\n            if (resultJson.call_expr?.result_schema) {\n                // a. Compose from existing\n                resultSchema = resultJson.call_expr.result_schema;\n\n                if (resultSchema instanceof registry.TableSchema\n                    || resultSchema instanceof registry.JSONSchema) {\n\n                    if (ordinalityColumn) {\n                        const resultSchema_json = resultSchema.jsonfy();\n                        resultSchema = resultSchema.constructor.fromJSON({\n                            name: schemaIdentFromFuncName,\n                            ...resultSchema_json, // overridingly\n                            entries: [\n                                ...resultSchema_json.entries, \n                                ordinalityColumn\n                            ],\n                        });\n                    } else {\n                        resultSchema = resultSchema.clone();\n                    }\n\n                } else {\n                    resultSchema = registry.JSONSchema.fromJSON({\n                        entries: [\n                            resultSchema.jsonfy()\n                        ].concat(ordinalityColumn || []),\n                    });\n                }\n            } else {\n                // b. Compose from Func expr\n                resultSchema = registry.JSONSchema.fromJSON({\n                    entries: [{\n                        nodeName: registry.ColumnSchema.NODE_NAME,\n                        name: schemaIdentFromFuncName,\n                        data_type: this.callExpr().dataType().jsonfy(),\n                    }].concat(ordinalityColumn || []),\n                });\n            }\n\n            resultJson = {\n                ...resultJson,\n                result_schema: resultSchema\n            };\n        }\n\n        return resultJson;\n    }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\nimport { ResultSchemaMixin } from '../../abstracts/ResultSchemaMixin.js';\nimport { registry } from '../../registry.js';\n\nexport class SRFExpr3 extends ResultSchemaMixin(AbstractNode) {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'CallExpr', as: 'call_expr' },\n            { type: 'SRFExprDDL1', as: 'qualif', optional: true },\n        ];\n    }\n\n    /* AST API */\n\n    callExpr() { return this._get('call_expr'); }\n\n    qualif() { return this._get('qualif'); }\n\n    /* JSON API */\n\n    jsonfy(options = {}, transformer = null, schemaInference = null) {\n        let resultJson = super.jsonfy(options, transformer, schemaInference);\n        if (options.deSugar) {\n\n            let resultSchema;\n            if (resultJson.qualif?.column_defs.length) {\n                // a. Compose from \"column_defs\"\n                resultSchema = registry.JSONSchema.fromJSON({\n                    entries: resultJson.qualif.column_defs,\n                });\n            } else if (resultJson.call_expr?.result_schema) {\n                // b. Compose from existing\n                const givenSchema = resultJson.call_expr.result_schema;\n                resultSchema = givenSchema instanceof registry.TableSchema || givenSchema instanceof registry.JSONSchema\n                    ? givenSchema.clone()\n                    : registry.JSONSchema.fromJSON({\n                        entries: [givenSchema.jsonfy()],\n                    });\n            } else {\n                // c. Compose from Func expr\n                const schemaIdentFromFuncName = { nodeName: registry.Identifier.NODE_NAME, value: resultJson.call_expr.name };\n                resultSchema = registry.JSONSchema.fromJSON({\n                    entries: [{\n                        nodeName: registry.ColumnSchema.NODE_NAME,\n                        name: schemaIdentFromFuncName,\n                        data_type: this.callExpr().dataType().jsonfy(),\n                    }],\n                });\n            }\n\n            resultJson = {\n                ...resultJson,\n                result_schema: resultSchema\n            };\n        }\n\n        return resultJson;\n    }\n}", "import { ResultSchemaMixin } from '../../abstracts/ResultSchemaMixin.js';\nimport { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\nimport { registry } from '../../registry.js';\n\nexport class SRFExpr4 extends ResultSchemaMixin(AbstractNodeList) {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'keyword', value: 'ROWS' },\n            { type: 'keyword', value: 'FROM' },\n            {\n                type: 'paren_block',\n                syntax: { type: 'SRFExpr3', as: 'entries', arity: { min: 1 }, itemSeparator, assert: true, autoIndent: 2 },\n                autoIndent: true\n            },\n            {\n                optional: true,\n                syntax: [\n                    { type: 'keyword', as: 'with_ordinality', value: 'WITH', booleanfy: true },\n                    { type: 'keyword', value: 'ORDINALITY', assert: true },\n                ]\n            }\n        ];\n    }\n\n    static get syntaxPriority() { return -1; }\n\n    /* AST API */\n\n    withOrdinality() { return this._get('with_ordinality'); }\n\n    /* JSON API */\n\n    jsonfy(options = {}, transformer = null, schemaInference = null) {\n        let resultJson = super.jsonfy(options, transformer, schemaInference);\n        if (options.deSugar) {\n            let colIdx = 1;\n            const entries = resultJson.entries.reduce((entries, exprJson) => {\n                const exprJsonEntries = exprJson.result_schema.jsonfy().entries.map((x) => ({ ...x, name: { ...x.name, value: colIdx++ } }));\n                return entries.concat(exprJsonEntries);\n            }, []);\n            if (resultJson.with_ordinality) {\n                entries.push({\n                    name: { nodeName: registry.Identifier.NODE_NAME, value: colIdx },\n                    data_type: { nodeName: registry.DataType.NODE_NAME, value: 'INT' },\n                });\n            }\n            const resultSchema = registry.JSONSchema.fromJSON({ entries });\n            resultJson = {\n                ...resultJson,\n                result_schema: resultSchema\n            };\n        }\n\n        return resultJson;\n    }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class SRFExprDDL1 extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'keyword', as: 'as_kw', value: 'AS' },\n            {\n                type: 'paren_block',\n                syntax: { type: 'ColumnSchema', as: 'column_defs', arity: { min: 1 }, itemSeparator },\n            }\n        ];\n    }\n\n    /* AST API */\n\n    asKW() { return this._get('as_kw'); }\n\n    columnDefs() { return this._get('column_defs'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class SRFExprDDL2 extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            {\n                syntaxes: [\n                    { type: 'Identifier', as: 'alias', peek: [1, 'paren_block'] },\n                    [\n                        { type: 'keyword', as: 'as_kw', value: 'AS', peek: [2, 'paren_block'] },\n                        { type: 'Identifier', as: 'alias', assert: true }\n                    ]\n                ]\n            },\n            {\n                type: 'paren_block',\n                syntax: { type: 'ColumnSchema', as: 'column_defs', arity: { min: 1 }, itemSeparator },\n            }\n        ];\n    }\n\n    /* AST API */\n\n    asKW() { return this._get('as_kw'); }\n\n    alias() { return this._get('alias'); }\n\n    columnDefs() { return this._get('column_defs'); }\n}", "import { ValuesConstructor } from '../../dml/constructors/ValuesConstructor.js';\n\nexport class ValuesTableLiteral extends ValuesConstructor {\n    \n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return { type: 'paren_block', syntax: super.syntaxRules, autoIndent: true };\n    }\n}", "import { AbstractNonDDLStmt } from '../abstracts/AbstractNonDDLStmt.js';\nimport { registry } from '../registry.js';\n\nexport class SelectStmt extends AbstractNonDDLStmt {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() { return { type: ['CompleteSelectStmt', 'CompositeSelectStmt'], expression: true }; }\n\n    static buildSyntaxRules(part = null) {\n        const part1 = (extRules = []) => [\n            { type: 'keyword', value: 'SELECT' },\n            { type: 'DistinctClause', as: 'distinct_clause', optional: true },\n            { type: 'SelectList', as: 'select_list' },\n            {\n                optional: true,\n                syntax: [\n                    { type: 'FromClause', as: 'from_clause', autoSpacing: '\\n' },\n                    { type: 'JoinClause', as: 'join_clauses', arity: Infinity, optional: true, autoSpacing: '\\n' },\n\t\t\t\t\t{ type: 'MYPartitionClause', as: 'my_partition_clause', optional: true, autoSpacing: '\\n' },\n                    { type: 'WhereClause', as: 'where_clause', optional: true, autoSpacing: '\\n' },\n                    {\n                        optional: true,\n                        syntax: [\n                            { type: 'GroupByClause', as: 'group_by_clause', autoSpacing: '\\n' },\n                            { type: 'HavingClause', as: 'having_clause', optional: true, autoSpacing: '\\n' },\n                        ],\n                    },\n                    { type: 'WindowClause', as: 'window_clause', optional: true, autoSpacing: '\\n' },\n                    ...\n                    extRules\n                ], autoSpacing: '\\n',\n            },\n        ];\n        const part2 = () => [\n            { type: 'OrderByClause', as: 'order_by_clause', optional: true, autoSpacing: '\\n' },\n            { type: 'LimitClause', as: 'limit_clause', optional: true, autoSpacing: '\\n' },\n            { type: 'OffsetClause', as: 'offset_clause', optional: true, autoSpacing: '\\n' },\n            { type: 'PGFetchClause', as: 'pg_fetch_clause', optional: true, dialect: 'postgres', autoSpacing: '\\n' },\n            { type: 'ForClause', as: 'for_clause', optional: true, autoSpacing: '\\n' },\n        ];\n        if (part === 1) return part1();\n        if (part === 2) return part2();\n        return part1(part2());\n    }\n\n    dataType() { return registry.DataType.fromJSON({ value: 'SET' }); }\n}\n", "import { Transformer } from '../Transformer.js';\nimport { SelectorStmtMixin } from '../abstracts/SelectorStmtMixin.js';\nimport { ErrorRefUnknown } from '../expr/ref/abstracts/ErrorRefUnknown.js';\nimport { SelectStmt } from './SelectStmt.js';\nimport { registry } from '../registry.js';\n\nexport class BasicSelectStmt extends SelectorStmtMixin(\n    SelectStmt\n) {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() { return this.buildSyntaxRules(1); }\n\n    static get syntaxPriority() { return -1; }\n\n    /* Schema API */\n\n    distinctClause() { return this._get('distinct_clause'); }\n\n    selectList() { return this._get('select_list'); }\n\n    fromClause() { return this._get('from_clause'); }\n\n    joinClauses() { return this._get('join_clauses'); }\n\n    whereClause() { return this._get('where_clause'); }\n\n    groupByClause() { return this._get('group_by_clause'); }\n\n    havingClause() { return this._get('having_clause'); }\n\n    windowClause() { return this._get('window_clause'); }\n\n    // -- MySQL\n\n    myPartitionClause() { return this._get('my_partition_clause'); }\n\n    // --------\n\n    get length() { return this.selectList()?.length ?? 0; }\n\n    [Symbol.iterator]() { return (this.selectList() || [])[Symbol.iterator](); }\n\n    /* JSON API */\n\n    jsonfy(options = {}, transformer = null, schemaInference = null) {\n        if (!options.deSugar) return super.jsonfy(options, transformer, schemaInference);\n\n        const deferedTransforms = {\n            select_list: null,\n            group_by_clause: new Set,\n            having_clause: new Set,\n            order_by_clause: new Set,\n        };\n\n        transformer = new Transformer((node, defaultTransform, keyHint) => {\n\n            // Defer SelectItem resolution\n            if (node instanceof registry.SelectList) {\n                deferedTransforms.select_list = defaultTransform;\n                return; // Exclude for now\n            }\n\n            // Trigger fields resolution\n            if (node instanceof registry.GroupByClause\n                || node instanceof registry.HavingClause\n                || (node instanceof registry.OrderByClause && node.parentNode === this/* to exclude ORDER BYs within window functions */)) {\n                // Try to capture Linked QL's native GROUP BY clause that's derived\n                // from a back ref, which won't resolve at this time because the relevant generated JOIN\n                // hasn't been add\n                return defaultTransform((childNode, defaultChildTransform, subKeyHint) => {\n                    if ((typeof subKeyHint === 'number' || subKeyHint === 'expr'/* For Having clause */) && childNode.parentNode === node) {\n                        try {\n                            deferedTransforms[keyHint].add(defaultChildTransform());\n                        } catch (e) {\n                            if (e instanceof ErrorRefUnknown) {\n                                deferedTransforms[keyHint].add(defaultChildTransform);\n                            } else throw e;\n                        }\n                        return; // Exclude for now\n                    }\n                    return defaultChildTransform();\n                });\n            }\n\n            // For all other things...\n            return defaultTransform();\n        }, transformer, this/* IMPORTANT */);\n\n        // --------------\n\n        // 0. Run transform\n        let resultJson = super.jsonfy(options, transformer, schemaInference);\n\n        // 1. Transform the defered selectList\n        let selectListJson = deferedTransforms.select_list();\n\n        // 2. Finalize generated JOINS\n        // Generated JOINs are injected into the query\n        const { select_list: _, ..._resultJson } = this.finalizeSelectorJSON(resultJson, transformer, schemaInference, options);\n\n        // 3. Re-resolve output list for cases of just-added deep refs in selectList\n        // wherein schemas wouldn't have been resolvable at the time\n        // 4. Finalize output list for the last time, honouring given deSugaring level with regards to star selects \"*\"\n        // and ofcos finalize output schemas\n        selectListJson = this.selectList().finalizeJSON(selectListJson, transformer, schemaInference, options);\n\n        // Apply now\n        resultJson = {\n            select_list: selectListJson,\n            ..._resultJson,\n            result_schema: selectListJson.result_schema,\n            origin_schemas: this.getOriginSchemas(transformer),\n        };\n\n        // --------------\n\n        // 5. Resolve deferred GROUP BYs and HAVINGs\n        // after having published artifacts.outputSchemas\n        for (const [fieldName, deferreds] of Object.entries(deferedTransforms)) {\n\n            if (fieldName === 'select_list' || !deferreds.size) continue;\n            const resolveds = [];\n\n            for (let deferred of deferreds) {\n                if (typeof deferred === 'function') {\n                    deferred = deferred();\n                }\n                resolveds.push(deferred);\n            }\n\n            if (fieldName === 'having_clause') {\n                resultJson = { ...resultJson, [fieldName]: { expr: resolveds[0] } };\n            } else if (fieldName === 'group_by_clause' || fieldName === 'order_by_clause') {\n                resultJson = { ...resultJson, [fieldName]: { entries: resolveds } };\n            }\n        }\n\n        return resultJson;\n    }\n}", "import { BasicSelectStmt } from './BasicSelectStmt.js';\n\nexport class CompleteSelectStmt extends BasicSelectStmt {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() { return this.buildSyntaxRules(); }\n\n    static get syntaxPriority() { return 99; }\n\n    /* AST API */\n\n    orderByClause() { return this._get('order_by_clause'); }\n\n    offsetClause() { return this._get('offset_clause'); }\n\n    limitClause() { return this._get('limit_clause'); }\n\n    forClause() { return this._get('for_clause'); }\n\n    // -- Postgres\n\n    pgFetchClause() { return this._get('pg_fetch_clause'); }\n\n    /* Custom parse */\n\n    static async parse(input, { left = undefined, minPrecedence = 0, trail = [], ...options } = {}) {\n        if (left) return;\n\n        const tokenStream = await this.toStream(input, options);\n\n        const result = await super.parse(tokenStream, { minPrecedence, trail, ...options });\n        if (await tokenStream.match('operator', ['INTERSECT', 'UNION', 'EXCEPT'])) {\n            if (result.orderByClause() || result.offsetClause() || result.limitClause() || result.forClause()) {\n                const current = tokenStream.current();\n                const message = `[${this.NODE_NAME}] Unexpected ${current.type} token:${typeof current.value === 'string' ? ` \"${current.value}\"` : ''} at <line ${current.line}, column ${current.column}>`;\n                throw new SyntaxError(message);\n            }\n            return BasicSelectStmt.fromJSON({ ...result.jsonfy(), nodeName: undefined });\n        }\n\n        return result;\n    }\n}", "import { SelectStmt } from './SelectStmt.js';\n\nexport class CompositeSelectStmt extends SelectStmt {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const setTypes = ['DerivedQuery', 'ValuesTableLiteral', 'ParenExpr', 'BasicSelectStmt', 'CallExpr'];\n        return [\n            { type: setTypes, as: 'left' },\n            { type: 'operator', as: 'operator', value: ['INTERSECT', 'UNION', 'EXCEPT'], autoSpacing: '\\n' },\n            { type: 'keyword', as: 'all_or_distinct', value: ['ALL', 'DISTINCT'], optional: true },\n            { type: setTypes, as: 'right', assert: true, autoSpacing: '\\n' },\n            ...\n            this.buildSyntaxRules(2),\n        ];\n    }\n\n    static get syntaxPriority() { return 100; }\n\n    /* AST API */\n\n    left() { return this._get('left'); }\n\n    operator() { return this._get('operator'); }\n\n    allOrDistinct() { return this._get('all_or_distinct'); }\n\n    right() { return this._get('right'); }\n\n    // --------\n\n    orderByClause() { return this._get('order_by_clause'); }\n\n    offsetClause() { return this._get('offset_clause'); }\n\n    limitClause() { return this._get('limit_clause'); }\n\n    forClause() { return this._get('for_clause'); }\n\n    // -- Postgres\n\n    pgFetchClause() { return this._get('pg_fetch_clause'); }\n\n    // --------\n\n    get length() { return this.left()?.selectList()?.length ?? 0; }\n\n    [Symbol.iterator]() { return (this.left()?.selectList() || [])[Symbol.iterator](); }\n\n    /* JSON API */\n\n    jsonfy(options = {}, transformer = null, schemaInference = null) {\n        const resultJson = super.jsonfy(options, transformer, schemaInference);\n        return { ...resultJson, result_schema: resultJson.left?.result_schema };\n    }\n}", "import { AbstractStmt } from '../abstracts/AbstractStmt.js';\n\nexport class TableStmt extends AbstractStmt {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', value: 'TABLE' },\n            { type: 'keyword', as: 'pg_only_kw', value: 'ONLY', optional: true, dialect: 'postgres' },\n            { type: 'TableRef2', as: 'table_ref', assert: true },\n            { type: 'operator', as: 'pg_star_ref', value: '*', booleanfy: true, optional: true, dialect: 'postgres' },\n        ];\n    }\n\n    /* AST API */\n\n    tableRef() { return this._get('table_ref'); }\n\n    // -- Postgres\n\n    pgOnlyKW() { return this._get('pg_only_kw'); }\n\n    pgStarRef() { return this._get('pg_star_ref'); }\n\n    /* SCHEMA API */\n\n    querySchemas() {\n        const tableRef = this.tableRef();\n\n        const alias = registry.Identifier.fromJSON({ value: tableRef.value() });\n        const tableSchema = tableRef.resultSchema(transformer).clone({ renameTo: alias });\n        \n        return new Set([tableSchema]);\n    }\n}", "export { AggrNotation } from './AggrNotation.js';\nexport { LQVersionSpec } from './LQVersionSpec.js';\n", "import { AbstractNode } from '../abstracts/AbstractNode.js';\n\nexport class AggrNotation extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            type: 'bracket_block', syntax: { type: 'Expr', as: '_', arity: 0, assert: true }\n        };\n    }\n\n    static get syntaxPriority() { return -1; }\n}", "import { AbstractNode } from '../abstracts/AbstractNode.js';\n\nexport class LQVersionSpec extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() { return { type: 'version_spec', as: '.' }; }\n\n    static get syntaxPriority() { return -1; }\n\n    /* AST API */\n\n    value() { return this._get('value'); }\n}", "export { DataType } from './DataType.js';\n", "import { AbstractNode } from '../abstracts/AbstractNode.js';\n\nexport class DataType extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            {\n                syntaxes: [\n                    { type: 'data_type', as: '.' },\n                    { type: 'keyword', as: '.', value: ['SET'] },\n                ]\n            },\n            {\n                type: 'paren_block',\n                syntax: { type: 'Expr', as: 'specificity', arity: Infinity, itemSeparator, assert: true },\n                optional: true,\n                optionalParens: true,\n                autoSpacing: false\n            },\n            { type: 'AggrNotation', as: 'pg_is_aggr', autoSpacing: false, optional: true, dialect: 'postgres' },\n        ];\n    }\n\n    /* AST API */\n\n    value() { return this._get('value'); }\n\n    specificity() { return this._get('specificity'); }\n\n    // -- Postgres\n\n    pgIsAggr() { return this._get('pg_is_aggr'); }\n}", "import { AbstractNodeList } from './AbstractNodeList.js';\n\nexport class JSONSchema extends AbstractNodeList {\n    \n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return { type: ['JSONSchema', 'TableSchema', 'ColumnSchema', 'ColumnRef1'/* result of resolving ColumnRef0 */], as: 'entries', arity: Infinity };\n    }\n}", "import { AbstractNodeList } from './abstracts/AbstractNodeList.js';\n\nexport class Script extends AbstractNodeList {\n\n    /* SYNTAX RULES */\n\n    static get _contentTypes() {\n        return [\n            'SelectStmt',\n            'TableStmt',\n            'InsertStmt',\n            'UpsertStmt',\n            'UpdateStmt',\n            'DeleteStmt',\n            'MYSetStmt',\n            'CTE',\n            'CreateSchemaStmt',\n            'DropSchemaStmt',\n            'CreateTableStmt',\n            'DropTableStmt',\n        ];\n    }\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ';' };\n        return { type: this._contentTypes, as: 'entries', arity: Infinity, itemSeparator, autoSpacing: '\\n' };\n    }\n\n    /* API */\n\n    static async parse(input, options = {}) {\n        const tokenStream = await this.toStream(input, options);\n        const result = await super.parse(tokenStream, options);\n        if (!tokenStream.done && tokenStream.current()) {\n            const current = tokenStream.current();\n\t\t\tconst message = `[${this.NODE_NAME}] Unexpected ${current.type} token:${typeof current.value === 'string' ? ` \"${current.value}\"` : ''} at <line ${current.line}, column ${current.column}>`;\n            throw new SyntaxError(message);\n        }\n        return result;\n    }\n\n    stringify(options = {}) { return `${super.stringify(options)};`; }\n}", "import * as cte from './cte/index.js';\nimport * as ddl from './ddl/index.js';\nimport * as dml from './dml/index.js';\nimport * as dql from './dql/index.js';\nimport * as expr from './expr/index.js';\nimport * as qualif from './qualif/index.js';\nimport * as type from './type/index.js';\nimport { JSONSchema } from './abstracts/JSONSchema.js';\nimport { Script } from './Script.js';\nimport { registry } from './registry.js';\n\nObject.assign(registry, { ...cte, ...ddl, ...dml, ...dql, ...expr, ...qualif, ...type, Script, JSONSchema });\n"],
  "mappings": "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",
  "names": ["cte_exports", "__export", "CTE", "CTEItem", "CTEItemAlias", "PGCycleClause", "PGSearchClause", "isObject_default", "val", "_eq", "a", "b", "cs", "ignoreList", "x", "i", "isObject_default", "temp", "$ignoreList", "k", "prev", "_toCapsSnake", "str", "result", "toktypes_exports", "__export", "TOK_TYPES", "aggrFunctionNames", "dataTypes", "functionNames", "keywords", "operators", "statements", "dialect", "mysqlAnsiQuotes", "value", "TokenStreamState", "by", "isLf", "TokenStream", "#iterator", "#options", "#locked", "#started", "#done", "#rootSavepoint", "#history", "#current", "#peeks", "iterator", "_", "options", "#assertNotLocked", "value", "done", "#historyPush", "#peeksShift", "$type", "$value", "peek", "type", "match", "tok", "i", "length", "$length", "next", "#peeksPush", "#historyPop", "#peeksUnshift", "method", "point", "toIndex", "input", "dialect", "state", "s", "normalizeOptions", "stream", "localState", "$finalizeToken", "token", "forceYield", "finalizeToken", "chunk", "char", "possiblyChunked", "charIsWhitespace", "whitespace", "$throw", "isEndQuote", "isEndTag", "isString", "isDelimitedIdent", "isBlockComment", "isLineComment", "prevChar", "nextChar", "strings_inBackslashEscapeMode", "strings_atEscapePosition", "tokenEndSteps", "cursor", "tokenStart", "tokenStartBacksteps", "tokenStartForwardsteps", "__", "restTok", "modifierPattern", "modifierMatch", "modifier", "groupToken", "previousChar", "addMultiWord", "targetMap", "prefix", "_tok", "tokenCategory", "$tokenCategory", "tokenRegistry", "tokenDialectBranch", "entries", "toktypes_exports", "entry", "finalizeComment", "finalToken", "identResolution", "line", "column", "finalizeIdentifier", "multiwordBufferLength", "wordSoFar", "findInBranch", "branch", "matchResult", "resolveTok", "spaceBefore", "processExactMatch", "processPartialMatch", "multiwordMatched", "tokenCategory2", "matchResult2", "existing", "current", "registry", "AbstractNode", "_AbstractNode", "_toCapsSnake", "#ast", "#options", "#parentNode", "ast", "options", "node_s", "k", "fieldName", "index", "cs", "n", "value", "indexOrValue", "valueOnIndex", "existing", "all", "i", "args", "nodes", "node", "activeTrailStr", "visitor", "visit", "key", "possibleChild", "_eq", "transformer", "schemaInference", "resultJson", "prev", "C", "transformSpec", "dialect", "cacheKey", "result", "syntaxRules", "rulesArray", "trail", "schemaSet", "assertionTrail", "newDependencyTrail", "cloneSchemaSet", "sch", "rule", "type", "exposure", "inference", "arity", "singletons", "modifier", "booleanfy", "optional", "assert", "syntax", "syntaxes", "rest", "activeTrail", "unsupportedAttrs", "_getUnsupportedRuleAttrs", "isTokenRule", "TOK_TYPES", "t", "registry", "isObject_default", "keys", "a", "fieldSchema", "schema", "newAssertionTrail", "newSchemaSet", "schemaSetClone", "schemaSetCloneResult", "resultSchema", "schemasArray", "schemaA", "schemaAObj", "j", "schemaB", "schemaBObj", "inputJson", "callback", "astSchema", "hardCodedNodeName", "lastAssertion", "$decideThrow", "message", "rulePath", "assertsGrep", "matchTokenRule", "fieldJson", "expectedValue", "resolveField", "fieldValue", "acquireField", "resultAST", "depField", "_inferenceMatch", "count", "resultArray", "entry", "resultLenth", "havingDuplicate", "e", "_e", "paths_loop", "$astSchema", "$inputJson", "rootRule", "tokSchema", "attr", "jsonfy", "relevantTransformer", "defaultTransform", "options1", "childTransformer", "entries", "resultEntries", "input", "tokenStream", "TokenStream", "left", "minPrecedence", "savepoint", "types", "operator", "newLeft", "numSkippedRules_dialectWise", "newMinPrecedence", "requiredSpacing", "peek", "optionalParens", "itemSeparator", "supportsLeft", "acquireLeft", "peekToken", "name", "matchSpacing", "current", "adjustBy", "eatToken", "op", "tok", "parseNode", "activeTokenStream", "NodeClass", "tokenStreamPosition", "forceThrow", "proximityTerm", "_type", "line", "column", "spaceBefore", "prec", "assoc", "resultType", "itemMinPrecedence", "relevantOperatorDef", "currentAsUnexpected", "startingIndentLevel", "autoLineBreakThreshold", "renderingStats", "$space", "$lineBreak", "indentLevel", "resultTokens", "numSkippedRules_optionalWise", "autoSpacing", "autoIndent", "autoIndentAdjust", "$autoIndent", "activeOptions", "rendering", "highestRenderingScore", "newRenderingStats", "$rendering", "hasExpectedValue", "$rule", "shouldRender", "itemsRendering", "renderingsStr", "$autoItemSpacing", "$itemSeparator", "autoSpaceIgnore", "hitsAutoLineBreakThreshold", "blockAutoLineBreakMode", "delims", "precedingTok", "delimChars", "delimChar", "escChar", "defs", "match", "indent", "lines", "supportedRuleAttrs", "criteria", "exp", "PGCycleClause", "AbstractNode", "PGSearchClause", "AbstractNode", "ResultSchemaMixin", "Class", "#result_schema", "inputJson", "options", "callback", "AbstractNode", "result_schema", "restJson", "instance", "transformer", "schemaInference", "resultJson", "OriginSchemasMixin", "Class", "#origin_schemas", "inputJson", "options", "callback", "AbstractNode", "origin_schemas", "restJson", "instance", "transformer", "schemaInference", "resultJson", "originSchemas", "foundJSONSchema", "resultSchema", "registry", "AbstractStmt", "AbstractNode", "#uuid", "inputJson", "options", "callback", "uuid", "restJson", "instance", "transformer", "schemaInference", "resultJson", "AbstractNonDDLStmt", "ResultSchemaMixin", "OriginSchemasMixin", "AbstractStmt", "values", "queryBindings", "i", "bindings", "b", "dedupe", "redundants", "$offset", "newOffset", "Transformer", "_Transformer", "#callback", "#rands", "#hashes", "#parentTransformer", "#statementNode", "#isStatementContext", "#artifacts", "callback", "parentTransformer", "statementNode", "type", "asSalt", "rands", "value", "hashes", "node", "defaultTransform", "key", "options0", "originatingContext", "$defaultTransform", "options1", "childTransformer", "options2", "CTE", "AbstractNonDDLStmt", "options", "transformer", "schemaInference", "outerResultSchema", "Transformer", "node", "defaultTransform", "keyHint", "bodyResultJson", "CTEItem", "AbstractNonDDLStmt", "options", "transformer", "schemaInference", "resultJson", "schemaIdent", "registry", "resultSchema", "s", "Transformer", "node", "defaultTransform", "key", "Identifier", "_Identifier", "AbstractNode", "ident", "cs", "_eq", "CTEItemAlias", "Identifier", "itemSeparator", "ddl_exports", "__export", "CheckConstraint", "ColumnDefaultConstraint", "ColumnDiff", "ColumnExpressionConstraint", "ColumnFKConstraint", "ColumnIdent", "ColumnIdentityConstraint", "ColumnNullConstraint", "ColumnPKConstraint", "ColumnSchema", "ColumnUKConstraint", "ConstraintSchema", "CreateSchemaStmt", "CreateTableStmt", "DDLStmt", "DropSchemaStmt", "DropTableStmt", "FKDeleteRule", "FKMatchRule", "FKUpdateRule", "IndexDiff", "IndexSchema", "MYColumnAutoIncrementModifier", "MYColumnCommentModifier", "MYColumnOnUpdateModifier", "MYColumnVisibilityModifier", "PGIndexParamInclude", "PGIndexParamUsing", "PGIndexParamWith", "PGIndexParameters", "PGTableEXConstraint", "PGTableEXConstraintItem", "ReferentialAction", "SchemaDiff", "SchemaIdent", "SchemaSchema", "TableDiff", "TableFKConstraint", "TableIdent", "TablePKConstraint", "TableSchema", "TableUKConstraint", "AbstractNodeList", "AbstractNode", "index", "value", "args", "AbstractDiff", "AbstractNodeList", "ColumnDiff", "AbstractDiff", "AbstractSchema", "_AbstractSchema", "AbstractNodeList", "value", "args", "inputJson", "options", "callback", "AbstractNode", "ddl_name", "restJson", "node", "iddlNameIdent", "registry", "prev", "Class", "renameTo", "transformer", "schemaInference", "resultJson", "ColumnSchema", "AbstractSchema", "cons", "registry", "normalized", "pkConstraint", "pkColumns", "nodeName", "columns", "cJson", "instance", "c", "options", "transformer", "schemaInference", "resultJson", "tableLevelConstraints", "x", "method", "s", "FKMatchRule", "AbstractNode", "FKDeleteRule", "AbstractNode", "FKUpdateRule", "AbstractNode", "PGIndexParameters", "AbstractNodeList", "PGIndexParamInclude", "AbstractNodeList", "PGIndexParamUsing", "AbstractNode", "PGIndexParamWith", "AbstractNodeList", "ConstraintSchema", "AbstractSchema", "rules", "registry", "PGTableEXConstraintItem", "ConstraintSchema", "ReferentialAction", "AbstractNode", "CheckConstraint", "ConstraintSchema", "columns", "node", "registry", "ColumnDefaultConstraint", "ConstraintSchema", "ColumnExpressionConstraint", "ConstraintSchema", "ColumnSchema", "ColumnRef2", "registry", "ColumnFKConstraint", "ConstraintSchema", "itemSeparator", "MYColumnAutoIncrementModifier", "AbstractNode", "options", "transformer", "schemaInference", "ColumnIdentityConstraint", "ColumnIdentityConstraint", "ConstraintSchema", "options", "transformer", "schemaInference", "MYColumnAutoIncrementModifier", "ColumnNullConstraint", "ConstraintSchema", "ColumnPKConstraint", "ConstraintSchema", "registry", "ColumnUKConstraint", "ConstraintSchema", "ColumnSchema", "ColumnRef2", "registry", "MYColumnCommentModifier", "AbstractNode", "MYColumnOnUpdateModifier", "AbstractNode", "MYColumnVisibilityModifier", "AbstractNode", "PGTableEXConstraint", "ConstraintSchema", "itemSeparator", "TableFKConstraint", "ConstraintSchema", "itemSeparator", "TablePKConstraint", "ConstraintSchema", "itemSeparator", "TableUKConstraint", "ConstraintSchema", "itemSeparator", "PathMixin", "Class", "baseRule", "ident", "cs", "result", "tokenStream", "syntaxRules", "left", "minPrecedence", "trail", "options", "resultAST", "qualifierTokens", "qualifierExposure", "qualifierTypes", "qualifierStream", "qualifierOptions", "expr_exports", "__export", "AggrCallExpr", "AtTimeZoneExpr", "BetweenExpr", "BinaryExpr", "BindVar", "BitLiteral", "BoolLiteral", "CallExpr", "CaseBranch", "CaseExpr", "CastExpr", "ColumnRef0", "ColumnRef1", "ColumnRef2", "DefaultLiteral", "DistinctFromExpr", "Expr", "ExtractExpr", "HexLiteral", "Identifier", "InExpr", "LQArrayLiteral", "LQBackBackRef", "LQBackRef", "LQBackRefAbstraction", "LQBackRefEndpoint", "LQDeepDeepRef1", "LQDeepDeepRef2", "LQDeepRef1", "LQDeepRef2", "LQObjectLiteral", "LQObjectProperty", "NullLiteral", "NumberLiteral", "PGCastExpr2", "PGFilterClause", "PGTypedArrayLiteral", "PGWithinGroupClause", "ParenExpr", "PredicateExpr", "QuantitativeExpr", "RowConstructor", "ScalarSubquery", "SchemaRef", "StringLiteral", "SystemVar", "TableRef0", "TableRef1", "TableRef2", "TypedDateLiteral", "TypedIntervalLiteral", "TypedLiteral", "TypedRowConstructor", "TypedTimeLiteral", "TypedTimeZoneLiteral", "TypedTimestampLiteral", "UnaryExpr", "UnknownLiteral", "UserVar", "WindowRef", "TypeSysMixin", "Class", "registry", "AbstractClassicExpr", "TypeSysMixin", "AbstractNode", "ParenExpr", "_ParenExpr", "AbstractClassicExpr", "expr", "RowConstructor", "_RowConstructor", "ResultSchemaMixin", "TypeSysMixin", "AbstractNodeList", "registry", "options", "transformer", "schemaInference", "resultJson", "entriesNode", "resultSchemas", "entry", "i", "ident", "DerivedQuery", "ResultSchemaMixin", "ParenExpr", "#is_correlated", "inputJson", "options", "callback", "AbstractNode", "is_correlated", "restJson", "instance", "transformer", "schemaInference", "statementContextArtifacts", "resultJson", "correlationFlag", "resultSchema", "ScalarSubquery", "DerivedQuery", "registry", "options", "transformer", "schemaInference", "resultJson", "resultSchema", "TypedRowConstructor", "RowConstructor", "PGFilterClause", "AbstractNode", "PGWithinGroupClause", "AbstractNode", "CallExpr", "ResultSchemaMixin", "AbstractClassicExpr", "itemSeparator", "AggrCallExpr", "CallExpr", "itemSeparator", "optional_distinct_modifier", "optional_separator_arg", "optional_order_by_clause", "optional_filter_clause_postgres", "optional_within_group_clause_postgres", "optional_null_handling_directive", "optional_over_clause", "CaseExpr", "TypeSysMixin", "AbstractNodeList", "CaseBranch", "AbstractNode", "CastExpr", "AbstractClassicExpr", "BinaryExpr", "AbstractClassicExpr", "operator", "toDialect", "resultType", "operators", "registry", "ExtractExpr", "BinaryExpr", "PredicateExpr", "AbstractClassicExpr", "registry", "QuantitativeExpr", "AbstractNode", "AbstractLiteral", "AbstractClassicExpr", "BitLiteral", "AbstractLiteral", "registry", "BoolLiteral", "AbstractLiteral", "registry", "DefaultLiteral", "AbstractLiteral", "HexLiteral", "AbstractLiteral", "registry", "NullLiteral", "AbstractLiteral", "NumberLiteral", "AbstractLiteral", "registry", "StringLiteral", "AbstractLiteral", "registry", "TypedLiteral", "AbstractClassicExpr", "registry", "TypedDateLiteral", "TypedLiteral", "TypedIntervalLiteral", "TypedLiteral", "val", "str", "num", "unit", "#unitToParts", "sign", "parts", "toUnit", "y", "m", "#applySign", "d", "h", "hm", "hms", "s", "tokens", "i", "token", "u", "mapped", "k", "v", "baseDate", "dir", "TypedTimeLiteral", "TypedLiteral", "TypedTimestampLiteral", "TypedLiteral", "TypedTimeZoneLiteral", "TypedLiteral", "UnknownLiteral", "AbstractLiteral", "SugarMixin", "Class", "AbstractLQJsonLiteral", "SugarMixin", "TypeSysMixin", "AbstractNodeList", "registry", "LQArrayLiteral", "AbstractLQJsonLiteral", "registry", "options", "transformer", "schemaInference", "resultJson", "resultSchemas", "e", "i", "resultSchema", "schemaIdent", "LQObjectLiteral", "AbstractLQJsonLiteral", "registry", "options", "transformer", "schemaInference", "resultJson", "entries", "result", "propertyJson", "ref", "newPropertyJson", "existing", "_eq", "resultSchemas", "args", "i", "resultSchema", "schemaIdent", "LQObjectProperty", "_LQObjectProperty", "AbstractNode", "options", "transformer", "schemaInference", "keyNode", "asAggr", "keyJson", "$options", "valueNode", "registry", "defaultTransform", "childTransformer", "valueJson", "PGTypedArrayLiteral", "AbstractNodeList", "registry", "options", "transformer", "schemaInference", "resultJson", "AtTimeZoneExpr", "BinaryExpr", "registry", "BetweenExpr", "BinaryExpr", "DistinctFromExpr", "BinaryExpr", "InExpr", "BinaryExpr", "PGCastExpr2", "BinaryExpr", "UnaryExpr", "AbstractClassicExpr", "operator", "registry", "ErrorRefUnknown", "ErrorRefAmbiguous", "AbstractClassicRef", "ResultSchemaMixin", "TypeSysMixin", "Identifier", "#resolution", "transformer", "schemaInference", "resultSet", "objectType", "ErrorRefAmbiguous", "ErrorRefUnknown", "inputJson", "options", "callback", "AbstractNode", "resolution", "restJson", "instance", "resultJson", "ColumnRef1", "_ColumnRef1", "PathMixin", "AbstractClassicRef", "registry", "parentNode", "up", "deepMatchCallback", "transformer", "schemaInference", "name", "inGrepMode", "resultSet", "resolve", "columnSchema", "qualifierJson", "resolution", "result", "AbstractNode", "resultSchema", "resolvedColumnRef1", "statementContext", "tempTableRef", "tableSchema", "prev", "newQualifierJson", "compositeResult", "s", "toKind", "options", "resultJson", "resolved", "ColumnRef0", "ColumnRef1", "registry", "ErrorFKInvalid", "message", "AbstractMagicRef", "SugarMixin", "BinaryExpr", "transformer", "schemaInference", "fk", "ErrorFKInvalid", "ColumnRef2", "_ColumnRef2", "AbstractClassicRef", "registry", "deepMatchCallback", "transformer", "schemaInference", "name", "inGrepMode", "resultSet", "resolve", "columnSchema", "result", "AbstractNode", "resultSchema", "resolvedColumnRef2", "tableSchemasInScope", "AbstractMagicRef", "superParentNode", "up", "tableSchemas", "t", "outer", "tableSchema", "toKind", "options", "resultJson", "LQBackBackRef", "_LQBackBackRef", "AbstractMagicRef", "registry", "reverseRef", "toKind", "options", "transformer", "schemaInference", "LQBackRef", "LQBackBackRef", "transformer", "schemaInference", "tableRefs", "ErrorRefUnknown", "toKind", "left", "qualifiedLeftEndpoint", "leftEndpointQualifier", "unqualifiedLeftEndpoint", "registry", "leftFk", "ErrorFKInvalid", "leftEndpointTable", "qualifiedLeftOperand", "resolve", "ddlName", "tableSchema", "pkColumnRef2", "$qualifiedLeftOperand", "ErrorRefAmbiguous", "statementContext", "outer", "type", "qualifiedRightTable", "unqualifiedRightOperand", "LQBackRefAbstraction", "ParenExpr", "LQBackRefEndpoint", "ColumnRef2", "LQDeepDeepRef1", "_LQDeepDeepRef1", "AbstractMagicRef", "registry", "toDeepRef", "toKind", "options", "transformer", "schemaInference", "altsMap", "currentIndex", "LQDeepDeepRef2", "LQDeepDeepRef1", "toDeepRef", "toKind", "options", "transformer", "schemaInference", "LQDeepRef1", "_LQDeepRef1", "LQDeepDeepRef1", "transformer", "schemaInference", "registry", "left", "right", "lhsOperandJson", "rhsOperandJson", "deepRef", "toKind", "detail", "qualifiedLeftOperand", "qualifiedRightTable", "unqualifiedRightOperand", "LQDeepRef2", "LQDeepRef1", "transformer", "schemaInference", "toKind", "toDeepRef", "options", "SchemaRef", "AbstractClassicRef", "deepMatchCallback", "transformer", "schemaInference", "name", "inGrepMode", "resultSet", "resolve", "schemaSchema", "registry", "result", "AbstractNode", "resolvedSchemaRef1", "options", "resultJson", "TableRef1", "PathMixin", "AbstractClassicRef", "registry", "deepMatchCallback", "transformer", "schemaInference", "name", "inGrepMode", "isFromItemRef", "enclosingDerivedQuery", "canTraverseUp", "resultSet", "resolve", "tableSchema", "qualifierJson", "resolution", "result", "AbstractNode", "resolvedTableRef", "statementContext", "originalType", "inSuperScopeNow", "queryScopes", "type", "queryScope", "tempSchemaRef", "schemaSchema", "prev", "newQualifierJson", "compositeResult", "s", "options", "resultJson", "TableRef0", "TableRef1", "registry", "TableRef2", "TableRef1", "WindowRef", "Identifier", "BindVar", "AbstractClassicExpr", "SystemVar", "AbstractClassicExpr", "UserVar", "AbstractClassicExpr", "Expr", "AbstractClassicExpr", "ExprNamesInOrder", "instance", "expr_exports", "ExprNames", "k", "a", "b", "comp", "ColumnIdent", "PathMixin", "Identifier", "SchemaIdent", "Identifier", "TableIdent", "PathMixin", "Identifier", "IndexDiff", "AbstractDiff", "IndexSchema", "AbstractSchema", "SchemaDiff", "AbstractDiff", "SchemaSchema", "AbstractSchema", "result", "entry", "registry", "TableDiff", "AbstractDiff", "TableSchema", "AbstractSchema", "itemSeparator", "type", "result", "entry", "registry", "normalized", "pk", "instance", "fk", "uk", "ck", "options", "transformer", "schemaInference", "columnLockedConstraints", "consMap", "Transformer", "node", "defaultTransform", "resultJson", "DDLStmt", "AbstractStmt", "CreateSchemaStmt", "DDLStmt", "mameRule", "pgAuthorizationRule", "pgOptionalEntiresRule", "DropSchemaStmt", "DDLStmt", "CreateTableStmt", "DDLStmt", "DropTableStmt", "DDLStmt", "dml_exports", "__export", "AssignmentExpr", "ColumnsConstructor", "ConfigAssignmentExpr", "ConfigAssignmentExprAlt1", "ConfigAssignmentExprAlt2", "DeleteStmt", "InsertStmt", "MYOnDuplicateKeyUpdateClause", "MYPartitionClause", "MYSetStmt", "MYVarAssignmentExpr", "PGConflictTarget", "PGConflictTargetIndexSpec", "PGDefaultValuesClause", "PGOnConflictClause", "PGWhereCurrentClause", "ReturningClause", "SetClause", "TableAbstraction1", "TableAbstraction2", "UpdateStmt", "UpsertStmt", "UsingFromClause", "ValuesConstructor", "MYOnDuplicateKeyUpdateClause", "AbstractNodeList", "MYPartitionClause", "AbstractNodeList", "PGConflictTarget", "AbstractNode", "PGConflictTargetIndexSpec", "AbstractNode", "PGDefaultValuesClause", "AbstractNode", "PGOnConflictClause", "AbstractNodeList", "SelectList", "ResultSchemaMixin", "AbstractNodeList", "options", "transformer", "schemaInference", "resultJson", "resolvedOutputList", "shouldFlattenUnaliasedRootObjects", "shouldDedupe", "addOutputItem", "itemJson", "result", "existing", "_eq", "i", "selectItemJson", "columnRef", "exprJson", "aliasJson", "registry", "argPairs", "key", "value", "resultSchemas", "shouldDeSugarStars", "starsFound", "selectItems", "outputSchemas", "a", "b", "_originalStarJson", "fieldJson", "fieldNode", "ReturningClause", "SelectList", "PGWhereCurrentClause", "AbstractNode", "SetClause", "AbstractNodeList", "UsingFromClause", "AbstractNodeList", "ColumnsConstructor", "AbstractNodeList", "ValuesConstructor", "ResultSchemaMixin", "AbstractNodeList", "itemSeparator", "options", "transformer", "schemaInference", "resultJson", "row1_resultSchema", "AssignmentExpr", "BinaryExpr", "ConfigAssignmentExpr", "BinaryExpr", "ConfigAssignmentExprAlt1", "BinaryExpr", "ConfigAssignmentExprAlt2", "BinaryExpr", "MYVarAssignmentExpr", "BinaryExpr", "TableAbstraction2", "ResultSchemaMixin", "AbstractNode", "derivedAlias", "registry", "options", "transformer", "schemaInference", "resultJson", "derivedAliasJson", "schemaIdent", "resultSchema", "applicableAliasJson", "TableAbstraction1", "ResultSchemaMixin", "AbstractNode", "derivedAlias", "registry", "options", "transformer", "schemaInference", "resultJson", "derivedAliasJson", "schemaIdent", "resultSchema", "applicableAliasJson", "SelectorStmtMixin", "Class", "options", "transformer", "schemaInference", "ColumnRef1", "ColumnRef2", "AggrCallExpr", "LQBackRefAbstraction", "LQDeepRef1", "LQBackRef", "registry", "Transformer", "node", "defaultTransform", "keyHint", "deSugar", "asAggr", "$options", "isSpecialColumnRef1", "specialColumnRef1ToDeepRef", "columnRef", "lhsOperandJson", "rhsOperandJson", "deepRef", "toAggr", "nodeJson", "select", "detail", "detailJson", "alias", "LQRef", "lhsOperand", "rhsOperand", "rhsTable", "selectorDimensions", "CompleteSelectStmt", "DerivedQuery", "FromClause", "JoinClause", "OnClause", "GroupByClause", "GroupingElement", "FromItem", "SelectList", "SelectItem", "FromItemAlias", "SelectItemAlias", "TableRef1", "BinaryExpr", "$dimensionID", "dimensionID", "rands", "rhsOperandMask", "fieldSpec", "joinJson", "selectorDimension", "selectAlias", "resultJson", "rewrittenJoinEntries", "joinNode", "joinJson2", "childTransformer", "WhereClause", "rand", "tableExpr", "tblAliasOriginal", "tblAliasOriginal_delim", "tblAliasRewrite", "pkColumnRef", "pgGeneratedFromItem", "pgGeneratedWhereClause", "createCorrelationExpr", "selectItems", "createOrPatchAFromEntry", "_eq", "fromItem", "fieldJson", "whereExpr", "fromClause", "fromClauseClass", "fromItemNode", "DMLStmt", "AbstractNonDDLStmt", "resultJson", "transformer", "schemaInference", "options", "returningClauseJson", "registry", "DeleteStmt", "SelectorStmtMixin", "DMLStmt", "itemSeparator", "options", "transformer", "schemaInference", "Transformer", "node", "defaultTransform", "resultJson", "PayloadStmtMixin", "Class", "registry", "options", "transformer", "schemaInference", "LQDeepRef2", "AssignmentExpr", "DerivedQuery", "ColumnsConstructor", "ValuesConstructor", "TypedRowConstructor", "RowConstructor", "specials", "s", "columnList", "pgDefaultValuesClause", "valuesClause", "selectClause", "hasTopLevelDeepRefs", "c", "ignoreList", "Transformer", "node", "defaultTransform", "keyHint", "deSugar", "$options", "conflictHandlingClauseContext", "$$options", "deSugaredLhs", "deSugaredRhs", "resultJson", "rowSet", "rowsJson", "rowSetJson", "columns", "values", "payloadDimensions", "TableRef1", "ColumnRef1", "SelectItemAlias", "ColumnRef2", "DefaultLiteral", "SelectStmt", "CompleteSelectStmt", "PGDefaultValuesClause", "SelectList", "SelectItem", "FromClause", "FromItem", "jsonfy", "_deSugar", "deSugarColumnsList", "dimensionsMap", "columnRef", "columnOffset", "dimension", "deSugarValuesFromDefaultValues", "valuesRow", "valueJson", "deSugarValuesFromValues", "valuesEntries", "rowOffset", "valueNode", "deSugarValuesFromSelect", "selectStmt", "baseSelect", "baseSelectItems", "memoSelect", "memoSelectAlias", "rowNumberExpr", "newBaseSelectFromItem", "rewriteAgainstMemoSelect", "fieldJson", "obfuscateAlias", "newBaseSelectList", "selectList", "subSelectItems", "entryJson", "lhsOperandJson", "correspondingColumn", "LQRefColumn", "lhsOperand", "rhsOperand", "rhsTable", "detail", "LQBackRefAbstraction", "ReturningClause", "ValuesTableLiteral", "WhereClause", "ScalarSubquery", "SetClause", "BinaryExpr", "BoolLiteral", "NumberLiteral", "UpdateStmt", "TableAbstraction2", "baseUUID", "rhsOperandJson", "rhsTableJson", "lhsOperand1Json", "rhsOperand1Json", "rhsTable1Json", "refMode", "isDeepRef", "columnsConstructorJson", "columnsLength", "dimensionValidateRowLength", "rowNode", "result_schema", "rowLength", "createForeignBinding", "sourceUuid", "sourceCol", "sourceRowIndex", "innerFilter", "whereExpr", "whereExprRhs", "tableSpec", "onConflictUpdatedStatusAlias", "whereClause", "query", "payloadDimension", "payload", "payloadJson", "queries", "dimensionPushRow", "fKBindingJson", "lastIndex", "i", "rowJson", "queryTemplate", "selectForeignBinding", "selectJson", "fkField", "correlationRhs", "currentQuery", "isDerivedQuery", "deriveSelectAliasesFromColumns", "rhsOperandPKJson", "ColumnRef0", "AggrCallExpr", "CTE", "CTEItem", "CTEItemAlias", "cte", "$transformer", "toCTEItem", "dimensionID", "queryJson", "indices", "cteItemJson", "flipSelectFromWithRowNumbers", "dependents", "deferedDependencies", "lefts", "onConflictUpdatedStatusRequired", "originalReturningList", "$query", "uuid", "existing", "_eq", "fieldExpr", "wherePredicate", "cteReturningList", "newOuterReturningList", "cteReturningClause", "selectItems", "instance", "prev", "C", "newSelectList", "fromName", "rowNumberJson", "fromItemJson", "alias", "InsertStmt", "PayloadStmtMixin", "DMLStmt", "optional_alias_postgres", "optional_alias_mysql", "options", "transformer", "schemaInference", "Transformer", "node", "defaultTransform", "registry", "subResultJson", "resultSchema", "resultJson", "toDialect", "pkColumn", "MYSetStmt", "AbstractNodeList", "UpdateStmt", "PayloadStmtMixin", "SelectorStmtMixin", "DMLStmt", "options", "transformer", "schemaInference", "deferedTransforms", "Transformer", "node", "defaultTransform", "registry", "resultJson", "pkColumn", "UpsertStmt", "SugarMixin", "InsertStmt", "resultJson", "transformer", "schemaInference", "options", "tableSchema", "t", "toDialect", "columnNamesJson", "e", "c", "conflictHandlingClause", "registry", "uniqueKeysColumnSets", "k", "firstUniqueKeysColumnSet", "colSet", "_eq", "dql_exports", "__export", "BasicSelectStmt", "CompleteSelectStmt", "CompositeSelectStmt", "DerivedQuery", "DistinctClause", "ForClause", "FromClause", "FromItem", "FromItemAlias", "GroupByClause", "GroupingElement", "HavingClause", "JoinClause", "LimitClause", "OffsetClause", "OnClause", "OrderByClause", "OrderElement", "PGFetchClause", "PGOrderOperator", "PartitionByClause", "SRFExpr1", "SRFExpr2", "SRFExpr3", "SRFExpr4", "SRFExprDDL1", "SRFExprDDL2", "SelectItem", "SelectItemAlias", "SelectList", "SelectStmt", "TableStmt", "UsingClause", "ValuesTableLiteral", "WhereClause", "WindowClause", "WindowDeclaration", "WindowFrameBound", "WindowFrameSpec", "WindowSpec", "DistinctClause", "AbstractNode", "ForClause", "AbstractNode", "FromClause", "AbstractNodeList", "GroupByClause", "AbstractNodeList", "GroupingElement", "AbstractNode", "HavingClause", "AbstractNode", "FromItem", "ResultSchemaMixin", "AbstractNode", "itemSeparator", "derivedAliasJson", "registry", "options", "transformer", "schemaInference", "resultJson", "schemaIdent", "resultSchema", "s", "Transformer", "node", "defaultTransform", "key", "applicableAliasJson", "JoinClause", "FromItem", "options", "transformer", "schemaInference", "conditionClauseTransform", "Transformer", "node", "defaultTransform", "keyHint", "resultJson", "LimitClause", "AbstractNode", "OffsetClause", "AbstractNode", "OnClause", "AbstractNode", "OrderByClause", "AbstractNodeList", "OrderElement", "AbstractNode", "PartitionByClause", "AbstractNodeList", "PGFetchClause", "AbstractNode", "PGOrderOperator", "AbstractNode", "UsingClause", "AbstractNode", "WhereClause", "AbstractNode", "WindowClause", "AbstractNodeList", "WindowDeclaration", "AbstractNode", "WindowFrameSpec", "AbstractNode", "itemSeparator", "WindowFrameBound", "AbstractNode", "WindowSpec", "AbstractNode", "FromItemAlias", "Identifier", "itemSeparator", "options", "transformer", "schemaInference", "resultJson", "SelectItem", "_SelectItem", "ResultSchemaMixin", "AbstractNode", "derivedAliasJson", "exprNode", "registry", "endpointNode", "isToPG", "options", "transformer", "schemaInference", "derivedAliasNode", "asAggr", "$options", "defaultExprTransform", "childTransformer", "exprJson", "schemaIdent", "resultSchema", "tableSchema", "applicableAliasJson", "SelectItemAlias", "Identifier", "options", "transformer", "schemaInference", "resultJson", "SRFExpr1", "ResultSchemaMixin", "AbstractNode", "options", "transformer", "schemaInference", "resultJson", "columnDefsJson", "resultSchema", "registry", "SRFExpr2", "ResultSchemaMixin", "AbstractNode", "options", "transformer", "schemaInference", "resultJson", "resultSchema", "ordinalityColumn", "registry", "schemaIdentFromFuncName", "resultSchema_json", "SRFExpr3", "ResultSchemaMixin", "AbstractNode", "options", "transformer", "schemaInference", "resultJson", "resultSchema", "registry", "givenSchema", "schemaIdentFromFuncName", "SRFExpr4", "ResultSchemaMixin", "AbstractNodeList", "options", "transformer", "schemaInference", "resultJson", "colIdx", "entries", "exprJson", "exprJsonEntries", "x", "registry", "resultSchema", "SRFExprDDL1", "AbstractNode", "SRFExprDDL2", "AbstractNode", "ValuesTableLiteral", "ValuesConstructor", "SelectStmt", "AbstractNonDDLStmt", "part", "part1", "extRules", "part2", "registry", "BasicSelectStmt", "SelectorStmtMixin", "SelectStmt", "options", "transformer", "schemaInference", "deferedTransforms", "Transformer", "node", "defaultTransform", "keyHint", "registry", "childNode", "defaultChildTransform", "subKeyHint", "e", "ErrorRefUnknown", "resultJson", "selectListJson", "_", "_resultJson", "fieldName", "deferreds", "resolveds", "deferred", "CompleteSelectStmt", "BasicSelectStmt", "input", "left", "minPrecedence", "trail", "options", "tokenStream", "result", "current", "message", "CompositeSelectStmt", "SelectStmt", "setTypes", "options", "transformer", "schemaInference", "resultJson", "TableStmt", "AbstractStmt", "tableRef", "alias", "tableSchema", "qualif_exports", "__export", "AggrNotation", "LQVersionSpec", "AggrNotation", "AbstractNode", "LQVersionSpec", "AbstractNode", "type_exports", "__export", "DataType", "DataType", "AbstractNode", "JSONSchema", "AbstractNodeList", "Script", "AbstractNodeList", "itemSeparator", "input", "options", "tokenStream", "result", "current", "message", "registry", "cte_exports", "ddl_exports", "dml_exports", "dql_exports", "expr_exports", "qualif_exports", "type_exports", "Script", "JSONSchema"]
}
