{
  "version": 3,
  "sources": ["../src/lang/cte/index.js", "../node_modules/@webqit/util/js/isObject.js", "../src/lang/util.js", "../src/lang/toktypes.js", "../src/lang/TokenStream.js", "../src/lang/registry.js", "../src/lang/abstracts/AbstractNode.js", "../src/lang/cte/constructs/PGCycleClause.js", "../src/lang/cte/constructs/PGSearchClause.js", "../src/lang/abstracts/AbstractStmt.js", "../src/lang/abstracts/AbstractNonDDLStmt.js", "../src/lang/cte/CTE.js", "../src/lang/cte/CTEBinding.js", "../src/lang/ddl/index.js", "../src/lang/abstracts/SelectorStmtMixin.js", "../src/lang/ddl/CreateTableStmt.js", "../src/lang/dml/index.js", "../src/lang/abstracts/AbstractNodeList.js", "../src/lang/dml/constructors/ColumnsConstructor.js", "../src/lang/expr/op/BinaryExpr.js", "../src/lang/dml/constructs/AssignmentExpr.js", "../src/lang/dml/constructs/BasicTableExpr.js", "../src/lang/dml/constructs/MYOnDuplicateKeyUpdateClause.js", "../src/lang/dml/constructs/MYPartitionClause.js", "../src/lang/dml/constructs/MYStarredTableRef.js", "../src/lang/dml/constructs/MYVarAssignmentExpr.js", "../src/lang/dml/constructs/PGConflictTarget.js", "../src/lang/dml/constructs/PGConflictTargetIndexSpec.js", "../src/lang/dml/constructs/PGDefaultValuesClause.js", "../src/lang/dml/constructs/PGOnConflictClause.js", "../src/lang/dml/constructs/PGReturningClause.js", "../src/lang/dml/constructs/PGWhereCurrentClause.js", "../src/lang/dml/constructs/SetClause.js", "../src/lang/dml/constructs/UsingFromClause.js", "../src/lang/dml/DeleteStmt.js", "../src/lang/abstracts/PayloadStmtMixin.js", "../src/lang/dml/InsertStmt.js", "../src/lang/dml/MYSetStmt.js", "../src/lang/dml/UpdateStmt.js", "../src/lang/abstracts/SugarMixin.js", "../src/lang/dml/UpsertStmt.js", "../src/lang/dql/index.js", "../src/lang/dql/constructors/FunctionsSetConstructor.js", "../src/lang/expr/shape/ParenShape.js", "../src/lang/dql/constructors/LQBackRefConstructor.js", "../src/lang/dql/constructors/SetConstructor.js", "../src/lang/dql/constructors/RowConstructor.js", "../src/lang/dql/constructors/SubqueryConstructor.js", "../src/lang/dql/constructors/ValuesConstructor.js", "../src/lang/dql/constructors/ValuesSetConstructor.js", "../src/lang/expr/ref/Identifier.js", "../src/lang/dql/constructs/BasicAlias.js", "../src/lang/dql/constructs/CompositeAlias.js", "../src/lang/dql/constructs/DistinctClause.js", "../src/lang/dql/constructs/ForClause.js", "../src/lang/dql/constructs/FromClause.js", "../src/lang/dql/constructs/FromElement.js", "../src/lang/dql/constructs/GroupByClause.js", "../src/lang/dql/constructs/GroupingElement.js", "../src/lang/dql/constructs/HavingClause.js", "../src/lang/dql/constructs/JoinClause.js", "../src/lang/dql/constructs/LimitClause.js", "../src/lang/dql/constructs/OffsetClause.js", "../src/lang/dql/constructs/OnClause.js", "../src/lang/dql/constructs/OrderByClause.js", "../src/lang/dql/constructs/OrderElement.js", "../src/lang/dql/constructs/PartitionByClause.js", "../src/lang/dql/constructs/PGFetchClause.js", "../src/lang/dql/constructs/PGOrderOperator.js", "../src/lang/expr/call/CallExpr.js", "../src/lang/expr/call/AggrCallExpr.js", "../src/lang/dql/constructs/SelectElement.js", "../src/lang/dql/constructs/SRFSpec.js", "../src/lang/dql/constructs/UsingClause.js", "../src/lang/dql/constructs/WhereClause.js", "../src/lang/dql/constructs/WindowClause.js", "../src/lang/dql/constructs/WindowDeclaration.js", "../src/lang/dql/constructs/WindowFrameSpec.js", "../src/lang/dql/constructs/WindowFrameBound.js", "../src/lang/dql/constructs/WindowSpec.js", "../src/lang/dql/SelectStmt.js", "../src/lang/dql/BasicSelectStmt.js", "../src/lang/dql/CompleteSelectStmt.js", "../src/lang/dql/CompositeSelectStmt.js", "../src/lang/dql/TableStmt.js", "../src/lang/expr/index.js", "../src/lang/expr/call/constructs/PGFilterClause.js", "../src/lang/expr/call/constructs/PGWithinGroupClause.js", "../src/lang/expr/case/CaseExpr.js", "../src/lang/expr/case/CaseBranch.js", "../src/lang/expr/literal/AbstractLiteral.js", "../src/lang/expr/literal/BitLiteral.js", "../src/lang/expr/literal/BoolLiteral.js", "../src/lang/expr/literal/DefaultLiteral.js", "../src/lang/expr/literal/HexLiteral.js", "../src/lang/expr/literal/NullLiteral.js", "../src/lang/expr/literal/NumberLiteral.js", "../src/lang/expr/literal/StringLiteral.js", "../src/lang/expr/literal/TypedLiteral.js", "../src/lang/expr/literal/TypedDateLiteral.js", "../src/lang/expr/literal/TypedIntervalLiteral.js", "../src/lang/expr/literal/TypedTimeLiteral.js", "../src/lang/expr/literal/TypedTimestampLiteral.js", "../src/lang/expr/literal/TypedTimeZoneLiteral.js", "../src/lang/expr/literal/UnknownLiteral.js", "../src/lang/expr/op/AtTimeZoneExpr.js", "../src/lang/expr/op/BetweenExpr.js", "../src/lang/expr/op/CastExpr.js", "../src/lang/expr/op/ExtractExpr.js", "../src/lang/expr/op/DistinctFromExpr.js", "../src/lang/expr/op/PGCastExpr2.js", "../src/lang/expr/op/QuantifiedExpr.js", "../src/lang/expr/op/UnaryExpr.js", "../src/lang/expr/ref/ColumnNameRef.js", "../src/lang/abstracts/ErrorRefAmbiguous.js", "../src/lang/abstracts/ErrorRefUnknown.js", "../src/lang/abstracts/QualifierMixin.js", "../src/lang/expr/ref/ColumnRef.js", "../src/lang/expr/ref/DatabaseRef.js", "../src/lang/expr/ref/abstracts/AbstractMagicRef.js", "../src/lang/expr/ref/abstracts/ErrorFKInvalid.js", "../src/lang/expr/ref/LQBackBackRef.js", "../src/lang/expr/ref/LQBackRef.js", "../src/lang/expr/ref/LQDeepDeepRef.js", "../src/lang/expr/ref/LQDeepRef.js", "../src/lang/expr/ref/StarRef.js", "../src/lang/expr/ref/TableRef.js", "../src/lang/expr/ref/TableAbstractionRef.js", "../src/lang/expr/ref/WindowRef.js", "../src/lang/expr/shape/abstracts/AbstractLQShapeLiteral.js", "../src/lang/expr/shape/LQArrayLiteral.js", "../src/lang/expr/shape/LQObjectLiteral.js", "../src/lang/expr/shape/LQObjectProperty.js", "../src/lang/expr/shape/PGArrayLiteral.js", "../src/lang/expr/var/BindVar.js", "../src/lang/expr/var/SystemVar.js", "../src/lang/expr/var/UserVar.js", "../src/lang/expr/Expr.js", "../src/lang/qualif/index.js", "../src/lang/qualif/AggrNotation.js", "../src/lang/qualif/LQVersionSpec.js", "../src/lang/type/index.js", "../src/lang/type/DataType.js", "../src/lang/index.js", "../src/lang/Query.js"],
  "sourcesContent": ["export * from './constructs/index.js';\nexport { CTE } from './CTE.js';\nexport { CTEBinding } from './CTEBinding.js';\n", "\n/**\n * Tells if val is pure object.\n *\n * @param object\t \tval\n *\n * @return bool\n */\nexport default function(val) {\n\treturn !Array.isArray(val) && typeof val === 'object' && val;\n};\n", "import { _isObject } from '@webqit/util/js/index.js';\n\nexport function _eq(a, b, caseMatch = null, ignoreList = null) {\n    if (Array.isArray(a) && Array.isArray(b)) {\n        return a.length === b.length && (b = b.slice(0).sort())\n            && a.slice(0).sort().every((x, i) => _eq(x, b[i], caseMatch, ignoreList));\n    }\n    if (typeof a?.jsonfy === 'function') a = a.jsonfy();\n    if (typeof b?.jsonfy === 'function') b = b.jsonfy();\n    if (_isObject(a) && _isObject(b)) {\n        const temp = {\n            indexs_a: Object.keys(a),\n            indexs_b: Object.keys(b),\n        };\n        if (ignoreList?.length) {\n            const $ignoreList = [].concat(ignoreList);\n            temp.indexs_a = temp.indexs_a.filter((k) => !$ignoreList.includes(k));\n            temp.indexs_b = temp.indexs_b.filter((k) => !$ignoreList.includes(k));\n        }\n        return temp.indexs_a.length === temp.indexs_b.length\n            && temp.indexs_a.reduce((prev, k) => prev && _eq(a[k], b[k], caseMatch, ignoreList), true);\n    }\n    if (typeof a === 'string' && typeof b === 'string' && caseMatch === 'ci') {\n        return a.toLowerCase() === b.toLowerCase();\n    }\n    return a === b;\n}\n\nexport function _toCapsSnake(str) {\n    // Handle cases like \"myVariableName\" -> \"my_Variable_Name\"\n    // This regex looks for a lowercase letter or digit followed by an uppercase letter.\n    // It inserts an underscore between them.\n    let result = str.replace(/([a-z0-9])([A-Z])/g, '$1_$2');\n\n    // Handle cases like \"HTMLParser\" -> \"HTML_Parser\" or \"APICall\" -> \"API_Call\"\n    // This regex looks for an uppercase letter followed by another uppercase letter\n    // which is then followed by a lowercase letter. This targets the transition\n    // from an acronym to a new word.\n    // Example: In \"HTMLParser\", it matches 'L' and then 'P' (uppercase) followed by 'a' (lowercase).\n    // It inserts an underscore between the first uppercase letter and the second.\n    result = result.replace(/([A-Z])([A-Z][a-z])/g, '$1_$2');\n\n    // Convert the entire string to uppercase.\n    return result.toUpperCase();\n}", "/**\n * Token types:\n * Noted that some delims and modifiers are dialect-dependent, and those are correctly handle by the tokenizer.\n  * Note too that emitted tokens may have a \"spaceBefore\" field when options.spaces === true.\n  * Lastly, \"line\" and \"column\" fields are guaranteed to be emitted by the tokenizer.\n */\nexport const TOK_TYPES = {\n  // Data type names\n  // e.g. VARCHAR, INT, \"custom_type\"\n  data_type: {\n    type: 'data_type',\n    value: undefined,\n    resolve() { return this; }\n  },\n  // Identifiers, optionally delimited\n  // e.g. user_id, \"UserName\", `table$1`\n  identifier: {\n    type: 'identifier',\n    value: undefined,\n    delim: [undefined],\n    resolve({ dialect, mysqlAnsiQuotes } = {}) {\n      return {\n        ...this,\n        delim: this.delim.concat(\n          dialect === 'mysql' ? (mysqlAnsiQuotes ? ['\"', '`'] : ['`']) : ['\"']\n        ),\n      };\n    }\n  },\n  // Any of the predefined keywords\n  // e.g. 'SELECT', 'FROM', 'WHERE'\n  keyword: {\n    type: 'keyword',\n    value: undefined,\n    resolve() { return this; }\n  },\n  // Operators, with precedence and associativity\n  // e.g. '+', '-', '||', 'AND', '::'\n  operator: {\n    type: 'operator',\n    value: undefined,\n    prec: undefined, // number\n    assoc: undefined, // string\n    resolve() { return this; }\n  },\n  // Punctuation (., ,, :, ;, etc.)\n  // e.g. '.', ',', ':', ';', '(', ')'\n  punctuation: {\n    type: 'punctuation',\n    value: undefined,\n    resolve() { return this; }\n  },\n  // String literals, with required delim and optional modifier (e.g. E for Postgres, N for mysql)\n  // e.g. 'Hello', \"World\", $$foo$$, $tag$bar$tag$\n  string_literal: {\n    type: 'string_literal',\n    value: undefined,\n    delim: [\"'\"],\n    modifier: [undefined],\n    resolve({ dialect, mysqlAnsiQuotes } = {}) {\n      return {\n        ...this,\n        delim: this.delim.concat(\n          dialect === 'mysql' ? (!mysqlAnsiQuotes ? ['\"'] : []) : [/^(\\$\\$|\\$[a-zA-Z_][a-zA-Z0-9_]*\\$)$/]\n        ),\n        modifier: this.modifier.concat(\n          dialect === 'mysql' ? ['N'] : ['E']\n        ),\n      };\n    }\n  },\n  // Numbers (integer, float, exponential, etc.)\n  // e.g. 42, -3.14, 2e10, .004\n  number_literal: {\n    type: 'number_literal',\n    value: undefined,\n    match({ value }) {\n      // Match type \"number_literal\": 42, 3.14, .5, 5., 1e9, -2.7E-3, +0.001e+2\n      if (!/^[+-]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:[eE][+-]?\\d+)?$/.test(value)) return false;\n      return true;\n    }\n  },\n  // NULL Literal: NULL\n  null_literal: {\n    type: 'null_literal',\n    value: undefined,\n    resolve() { return this; }\n  },\n  // UNKNOWN Literal: NULL\n  unknown_literal: {\n    type: 'unknown_literal',\n    value: undefined,\n    resolve() { return this; }\n  },\n  // Bool Literals: TRUE | FALSE\n  bool_literal: {\n    type: 'bool_literal',\n    value: undefined,\n    resolve() { return this; }\n  },\n  // HEX Literals: 0xFF | X'FF'\n  hex_literal: {\n    type: 'hex_literal',\n    value: undefined,\n    resolve() { return this; }\n  },\n  // BIT Literals: 0b0101 | B'0101'\n  bit_literal: {\n    type: 'bit_literal',\n    value: undefined,\n    resolve() { return this; }\n  },\n  // Bindings (e.g. $1, ?, etc.), with required delim\n  // e.g. $1, $user, ?\n  bind_var: {\n    type: 'bind_var',\n    value: undefined,\n    delim: [],\n    resolve({ dialect } = {}) {\n      return {\n        ...this,\n        delim: this.delim.concat(dialect === 'mysql' ? ['?'] : ['$'])\n      };\n    }\n  },\n  // Version tags\n  // e.g. my_db@1_3, my_db@^2_1, my_db@~7_6, my_db @=3_4, my_db@<3, my_db@>4, my_db@<=3, my_db@>=4\n  version_spec: {\n    type: 'version_spec',\n    value: undefined,\n    delim: [undefined, \"'\"],\n    resolve() { return this; }\n  },\n  // User variables, with optional delim\n  // e.g. :foo, @bar, @'user var'\n  user_var: {\n    type: 'user_var',\n    value: undefined,\n    delim: [undefined],\n    resolve({ dialect } = {}) {\n      return {\n        ...this,\n        delim: this.delim.concat(dialect === 'mysql' ? [\"'\"] : [])\n      };\n    }\n  },\n  // MySQL system variables, with required notation\n  // e.g. @@baz\n  system_var: {\n    type: 'system_var',\n    value: undefined,\n    resolve() { return this; }\n  },\n  // Nest token type: \"brace\"\n  brace_block: {\n    type: 'brace_block',\n    value: undefined, // TokenStream\n    resolve() { return this; }\n  },\n  // Nest token type: \"bracket\"\n  bracket_block: {\n    type: 'bracket_block',\n    value: undefined, // TokenStream\n    resolve() { return this; }\n  },\n  // Nest token type: \"paren\"\n  parent_block: {\n    type: 'paren_block',\n    value: undefined, // TokenStream\n    resolve() { return this; }\n  },\n  // Block comments\n  // e.g. /* This is a comment */\n  block_comment: {\n    type: 'block_comment',\n    value: undefined,\n    resolve() { return this; }\n  },\n  // Line comments, with required delim (e.g. /*, --, #)\n  // e.g. -- This is a comment\n  line_comment: {\n    type: 'line_comment',\n    value: undefined,\n    delim: ['--'],\n    resolve({ dialect } = {}) {\n      return {\n        ...this,\n        delim: this.delim.concat(dialect === 'mysql' ? ['#'] : [])\n      };\n    }\n  },\n};\n\n// Lookup registries, organized by: statements, clauses, operators, keywords, dataTypes\n// Each registry is split into: common (standard/shared), postgres, mysql\n\nexport const statements = {\n  common: [\n    // DDL\n    'ALTER',\n    'CREATE',\n    'DROP',\n    // DML\n    'SELECT',\n    'INSERT',\n    'UPSERT',\n    'UPDATE',\n    'MERGE',\n    'DELETE',\n    // Transactions\n    'BEGIN',\n    'COMMIT',\n    'ROLLBACK',\n    'RELEASE',\n    // Utility\n    'DESCRIBE',\n    'EXPLAIN',\n    'USE'\n  ],\n  postgres: [\n    'ANALYZE',\n    'CLUSTER',\n    'COMMENT ON',\n    'REFRESH',\n    'REINDEX',\n    'VACUUM'\n  ],\n  mysql: [\n    'ANALYZE',\n    'FLUSH',\n    'LOCK',\n    'OPTIMIZE',\n    'RENAME',\n    'REPAIR',\n    'RESET',\n    'SET',\n    'SHOW',\n    'TRUNCATE',\n    'UNLOCK'\n  ]\n};\n\nexport const keywords = {\n  common: [\n    'ALL', 'ON', 'NO', 'KEY', 'ANY', 'AS', 'BY', 'ASC', 'CASE', 'CAST',\n    'DEFAULT', 'DESC', 'DO', 'DISTINCT', 'ELSE', 'END', 'ESCAPE',\n    'FIRST', 'LAST', 'FOLLOWING', 'FOR', 'HAVING', 'FILTER', 'SHARE',\n    'JOIN', 'SEPARATOR', 'SKIP', 'LOCKED', 'NOWAIT', 'OF', 'RECURSIVE',\n    'LIMIT', 'LOAD', 'NEXT', 'NOTHING', 'NULLS', 'OFFSET', 'ONLY', 'TIES',\n    'OVER', 'PARTITION', 'PRECEDING', 'RANGE', 'RETURNING', 'ROW', 'ROWS', 'EXCLUDE',\n    'SET', 'SOME', 'THEN', 'USING', 'MATERIALIZED', 'MODE', 'TEMPORARY',\n    'WITHIN', 'BOTH',\n    'DATABASE', 'TABLE', 'COLUMN', 'INDEX', 'SEQUENCE', 'TRIGGER', 'VIEW', 'SAVEPOINT',\n    'VALUES', 'WHEN', 'WHERE', 'WINDOW', 'WITH', 'WITHOUT', 'TO', 'INTO',\n    'FROM', 'GROUP', 'ORDER', 'PARTITION', 'BREADTH', 'DEPTH',\n    'INNER', 'LEFT', 'RIGHT', 'OUTER', 'FULL', 'CROSS', 'NATURAL', 'NO OTHERS',\n    'ROLLUP', 'UNBOUNDED', 'CURRENT ROW', 'GROUPS', 'IGNORE', 'RESPECT',\n  ],\n  postgres: [\n    'ARRAY', 'GROUPING SETS', 'CUBE', 'TABLESAMPLE', 'REPEATABLE', 'SEARCH',\n    'LATERAL', 'ORDINALITY', 'OVERLAPS', 'SIMILAR', 'BERNOULLI', 'SYSTEM',\n    'TABLESPACE', 'UNLOGGED', 'PERFORM', 'CURRENT OF', 'TYPE', 'EXTENSION',\n    'IMMUTABLE', 'STABLE', 'VOLATILE', 'CYCLE', 'CONFLICT', 'TEMP',\n    'TIME ZONE', 'FETCH', 'LOCAL'\n  ],\n  mysql: [\n    'LOCK', 'RENAME', 'REPLACE', 'SHOW', 'UNLOCK',\n    'HIGH_PRIORITY', 'CACHE', 'SQL_CACHE', 'SQL_NO_CACHE', 'STRAIGHT_JOIN',\n    'DATABASES', 'TABLES', 'COLUMNS', 'STATUS', 'PROCEDURE', 'FUNCTION',\n    'AUTO_INCREMENT', 'CHARACTER SET', 'ENGINE', 'VALUE', 'DUPLICATE',\n  ]\n};\n\nexport const functionNames = {\n  common: [\n    'NOW', 'CURRENT_DATE', 'CURRENT_TIME', 'CURRENT_TIMESTAMP',\n    'IF', 'NULLIF', 'IFNULL',\n    'COALESCE', 'GREATEST', 'LEAST', 'CONCAT', 'GROUPING',\n    'CONCAT_WS', 'FORMAT', 'UNNEST',\n    'MD5', 'SHA1',\n    'ST_ASTEXT', 'ST_ASGEOJSON', 'ST_GEOMFROMTEXT',\n    'ST_WITHIN', 'ST_CONTAINS', 'ST_INTERSECTS', 'ST_DISTANCE', 'ST_BUFFER'\n  ],\n  postgres: [\n    'MAKE_DATE', 'MAKE_TIME', 'MAKE_TIMESTAMP',\n    'TO_JSON', 'TO_JSONB', 'JSON_TYPEOF', 'JSONB_TYPEOF',\n    'JSON_BUILD_ARRAY', 'JSONB_BUILD_ARRAY', 'JSON_BUILD_OBJECT', 'JSONB_BUILD_OBJECT',\n    'JSON_POPULATE_RECORD', 'JSONB_POPULATE_RECORD', 'JSON_PATH_QUERY', 'JSON_PATH_EXISTS'\n  ],\n  mysql: [\n    'CURDATE', 'CURTIME', 'SYSDATE', 'STR_TO_DATE', 'MAKEDATE', 'MAKETIME',\n    'JSON_ARRAY', 'JSON_OBJECT', 'JSON_EXTRACT', 'JSON_UNQUOTE',\n    'JSON_SET', 'JSON_INSERT', 'JSON_REPLACE', 'JSON_REMOVE',\n    'JSON_SEARCH', 'JSON_CONTAINS', 'JSON_CONTAINS_PATH',\n    'JSON_KEYS', 'JSON_ARRAY_APPEND', 'JSON_ARRAY_INSERT',\n    'JSON_DEPTH', 'JSON_LENGTH', 'JSON_MERGE_PRESERVE',\n    'JSON_MERGE_PATCH', 'JSON_PRETTY', 'JSON_STORAGE_FREE'\n  ]\n};\n\nexport const aggrFunctionNames = {\n  common: [\n    'COUNT', 'SUM', 'AVG', 'MIN', 'MAX',\n    'COVAR_POP', 'COVAR_SAMP', 'CORR',\n    'ROW_NUMBER',\n    'BIT_AND', 'BIT_OR',\n    'STDDEV_POP', 'STDDEV_SAMP', 'VAR_POP', 'VAR_SAMP', 'VARIANCE', 'STD',\n    'LEAD', 'LAG', 'NTILE', 'FIRST_VALUE', 'LAST_VALUE',\n  ],\n  postgres: [\n    'ARRAY_AGG', 'STRING_AGG', 'REGR_SLOPE',\n    'PERCENTILE_CONT', 'PERCENTILE_DISC', 'MODE',\n    'RANK', 'DENSE_RANK',\n    'EVERY', 'BOOL_AND', 'BOOL_OR',\n    'JSON_AGG',\n    'JSON_OBJECT_AGG', 'JSONB_OBJECT_AGG',\n    'XMLAGG',\n  ],\n  mysql: [\n    'GROUP_CONCAT',\n    'BIT_XOR',\n    'JSON_ARRAYAGG',\n    'JSON_OBJECTAGG',\n  ]\n};\n\nexport const dataTypes = {\n  common: [\n    'SMALLINT', 'INTEGER', 'INT', 'BIGINT',\n    'DECIMAL', 'DEC', 'NUMERIC', 'REAL', 'FLOAT',\n    'DATE', 'TIME', 'TIMESTAMP', 'INTERVAL',\n    'CHAR', 'CHARACTER', 'VARCHAR', 'TEXT',\n    'BINARY', 'VARBINARY', 'BOOLEAN', 'JSON',\n    'GEOMETRY', 'POINT', 'LINESTRING', 'POLYGON',\n    'DOUBLE PRECISION', 'CHARACTER VARYING'\n  ],\n  postgres: [\n    'SERIAL', 'BIGSERIAL', 'MONEY', 'BIT',\n    'CIDR', 'INET', 'MACADDR', 'MACADDR8', 'TIMESTAMPTZ', 'TIMETZ',\n    'TSVECTOR', 'TSQUERY', 'UUID', 'XML',\n    'INT4RANGE', 'INT8RANGE', 'NUMRANGE',\n    'TSRANGE', 'TSTZRANGE', 'DATERANGE',\n    'BOX', 'PATH', 'CIRCLE', 'LINE', 'LSEG', 'POLYGON',\n    'OID', 'BIT VARYING', 'JSONB'/*, TODO'NAME'*/, 'REGCLASS'\n  ],\n  mysql: [\n    'TINYINT', 'MEDIUMINT', 'BIT', 'YEAR', 'DATETIME',\n    'TINYTEXT', 'QUERY', 'MEDIUMTEXT', 'LONGTEXT',\n    'TINYBLOB', 'BLOB', 'MEDIUMBLOB', 'LONGBLOB',\n    'ENUM',\n    'GEOMETRYCOLLECTION', 'MULTIPOINT', 'MULTILINESTRING', 'MULTIPOLYGON',\n    'BOOL'\n  ]\n};\n\nexport const operators = {\n  common: [\n    // Custom/graph-style\n    ['<~', { prec: 90, assoc: 'left' }],\n    ['~>', { prec: 90, assoc: 'right' }],\n    ['BETWEEN', { prec: 85/* Higher than NOT */, assoc: 'left' }],\n    ['EXISTS', { prec: 83/* Higher than NOT */, assoc: 'left' }],\n    ['UNIQUE', { prec: 83/* Higher than NOT */, assoc: 'left' }],\n    ['NOT', { prec: 80, assoc: 'right' }],\n    // Arithmetic\n    ['*', { prec: 70, assoc: 'left' }],\n    ['/', { prec: 70, assoc: 'left' }],\n    ['%', { prec: 70, assoc: 'left' }],\n    ['+', { prec: 60, assoc: 'left' }],\n    ['-', { prec: 60, assoc: 'left' }],\n    // Bitwise\n    ['&', { prec: 60, assoc: 'left' }],\n    ['|', { prec: 60, assoc: 'left' }],\n    ['<<', { prec: 60, assoc: 'left' }],\n    ['>>', { prec: 60, assoc: 'left' }],\n    // Comparison\n    ['=', { prec: 50, assoc: 'left' }],\n    ['!=', { prec: 50, assoc: 'left' }],\n    ['<>', { prec: 50, assoc: 'left' }],\n    ['<', { prec: 50, assoc: 'left' }],\n    ['<=', { prec: 50, assoc: 'left' }],\n    ['>', { prec: 50, assoc: 'left' }],\n    ['>=', { prec: 50, assoc: 'left' }],\n    ['IS', { prec: 50, assoc: 'left' }],\n    ['IS NOT', { prec: 50, assoc: 'left' }],\n    // Pattern / membership\n    ['DISTINCT FROM', { prec: 50, assoc: 'left' }],\n    ['IN', { prec: 50, assoc: 'left', negatable: true }],\n    ['LIKE', { prec: 50, assoc: 'left', negatable: true }],\n    // Logical\n    ['AND', { prec: 40, assoc: 'left' }],\n    ['OR', { prec: 30, assoc: 'left' }],\n    // 'INTERSECT', 'UNION', 'EXCEPT'\n    ['INTERSECT', { prec: 20, assoc: 'left' }],\n    ['UNION', { prec: 10, assoc: 'left' }],\n    ['EXCEPT', { prec: 10, assoc: 'left' }],\n  ],\n  postgres: [\n    ['COLLATE', { prec: 83, assoc: 'left' }],\n    ['||', { prec: 60, assoc: 'left' }],\n    // Cast\n    ['::', { prec: 100, assoc: 'left' }],\n    ['AT', { prec: 95, assoc: 'left' }],\n    ['^', { prec: 90, assoc: 'left' }],\n    ['#', { prec: 60, assoc: 'left' }],\n    // JSON/JSONB\n    ['->', { prec: 80, assoc: 'left' }],\n    ['->>', { prec: 80, assoc: 'left' }],\n    ['#>', { prec: 80, assoc: 'left' }],\n    ['#>>', { prec: 80, assoc: 'left' }],\n    ['@>', { prec: 80, assoc: 'left' }],\n    ['<@', { prec: 80, assoc: 'left' }],\n    ['?', { prec: 80, assoc: 'left' }],\n    ['?|', { prec: 80, assoc: 'left' }],\n    ['?&', { prec: 80, assoc: 'left' }],\n    ['-@', { prec: 80, assoc: 'left' }],\n    ['#-', { prec: 80, assoc: 'left' }],\n    ['@?', { prec: 80, assoc: 'left' }],\n    ['@@', { prec: 80, assoc: 'left' }],\n    ['ILIKE', { prec: 50, assoc: 'left', negatable: true }],\n    ['~', { prec: 50, assoc: 'left' }],\n    ['!~', { prec: 50, assoc: 'left' }],\n    ['~*', { prec: 50, assoc: 'left' }],\n    ['!~*', { prec: 50, assoc: 'left' }],\n    ['SIMILAR TO', { prec: 50, assoc: 'left' }],\n    // GIS/PostGIS\n    ['&&', { prec: 60, assoc: 'left' }],\n    ['<->', { prec: 60, assoc: 'left' }],\n    ['@', { prec: 60, assoc: 'left' }],\n    ['&<', { prec: 60, assoc: 'left' }],\n    ['&>', { prec: 60, assoc: 'left' }],\n    ['|-', { prec: 60, assoc: 'left' }],\n    ['-|', { prec: 60, assoc: 'left' }],\n    ['<<', { prec: 60, assoc: 'left' }],\n    ['>>', { prec: 60, assoc: 'left' }],\n    ['<<|', { prec: 60, assoc: 'left' }],\n    ['|>>', { prec: 60, assoc: 'left' }],\n    ['&<|', { prec: 60, assoc: 'left' }],\n    ['|&>', { prec: 60, assoc: 'left' }],\n    ['~=', { prec: 50, assoc: 'left' }],\n    ['?#', { prec: 60, assoc: 'left' }],\n    ['?-', { prec: 60, assoc: 'left' }],\n    ['?-|', { prec: 60, assoc: 'left' }],\n    ['?|', { prec: 60, assoc: 'left' }],\n    ['?||', { prec: 60, assoc: 'left' }],\n    ['#', { prec: 60, assoc: 'left' }],\n    ['##', { prec: 60, assoc: 'left' }],\n    ['@-@', { prec: 60, assoc: 'left' }]\n  ],\n  mysql: [\n    ['DIV', { prec: 70, assoc: 'left' }],\n    ['MOD', { prec: 70, assoc: 'left' }],\n    ['BINARY', { prec: 90, assoc: 'right' }],\n    ['^', { prec: 80, assoc: 'left' }],\n    ['~', { prec: 85, assoc: 'right' }],\n    ['<=>', { prec: 50, assoc: 'left' }],\n    ['REGEXP', { prec: 50, assoc: 'left' }],\n    ['RLIKE', { prec: 50, assoc: 'left' }],\n    ['!', { prec: 80, assoc: 'right' }],\n    ['XOR', { prec: 40, assoc: 'left' }],\n    ['&&', { prec: 40, assoc: 'left' }],\n    ['||', { prec: 30, assoc: 'left' }],\n    [':=', { prec: 10, assoc: 'right' }],\n    ['SOUNDS LIKE', { prec: 50, assoc: 'left' }]\n  ]\n};\n", "import * as toktypes from './toktypes.js';\n\nclass TokenStreamState {\n    buffer = '';\n    cursor = 0;\n    line = 1;\n    column = 1;\n    mysqlBindingIndex = 0;\n    nestingContext = [];\n    nextTokenEscape = 0;\n    next(by = 1, isLf = false) {\n        if (isLf) {\n            this.line++;\n            this.column = 0; // To immediately become 1 below\n        }\n        this.column += by;\n        this.cursor += by;\n        if (this.nextTokenEscape === 1) {\n            this.nextTokenEscape = 2;\n        } else if (this.nextTokenEscape === 2) {\n            this.nextTokenEscape = 0;\n        }\n    }\n}\n\nexport class TokenStream {\n\n    #iterator;\n    #options;\n    #locked = false;\n    #started = false;\n    #done = false;\n\n    #rootSavepoint = null;\n    #history = [];\n    #current;\n    #peeks = [];\n\n    constructor(iterator, { state: _, ...options } = {}) {\n        this.#iterator = iterator;\n        this.#options = options;\n    }\n\n    [Symbol.asyncIterator]() {\n        return this; // Make it an async iterator\n    }\n\n    get options() { return this.#options; }\n\n    get locked() { return this.#locked; }\n\n    get started() { return this.#started; }\n\n    get done() { return this.#done && !this.#peeks.length; }\n\n    previous() {\n        return this.#history[this.#history.length - 1];\n    }\n\n    current() {\n        return this.#current;\n    }\n\n    async next() {\n        this.#assertNotLocked('next()');\n        this.#started = true;\n        let value, done = false;\n        if (this.#peeks.length) {\n            this.#historyPush(this.#current);\n            this.#current = this.#peeksShift();\n            value = this.#current;\n        } else {\n            ({ value, done } = await this.#iterator.next());\n            this.#historyPush(this.#current);\n            this.#current = value;\n            this.#done = done;\n        }\n        if (this.#rootSavepoint !== null && value?.type.endsWith('_block')) {\n            value.value.savepoint();\n        }\n        return { value, done };\n    }\n\n    async match($type, $value = undefined) {\n        const [peek, type, value] = typeof arguments[0] === 'number'\n            ? arguments\n            : [0, $type, $value];\n        const match = (tok) => {\n            return tok && (\n                (Array.isArray(type) ? type.includes(tok.type) : type === tok.type) && (\n                    value === undefined || (Array.isArray(value) ? (value.includes(tok.value) || value.includes(undefined)) : value === tok.value)\n                )\n            ) && tok || undefined;\n        };\n        if (peek === Infinity) {\n            // Match progressively\n            let i = 0, tok;\n            while (tok = await this.peek(i++)) {\n                if (match(tok)) return tok;\n            }\n            return;\n        }\n        return match(\n            peek ? await this.peek(peek) : this.current()\n        );\n    }\n\n    async peek(length = 1) {\n        if (length === 0) return this.#current;\n        let $length = length - this.#peeks.length;\n        while ($length) {\n            const next = await this.#iterator.next();\n            if (next.done) break;\n            this.#peeksPush(next.value);\n            $length--;\n        }\n        const tok = this.#peeks[length - 1];\n        return tok;\n    }\n\n    async eat(type = undefined, value = undefined) {\n        const tok = !type ? this.current() : await this.match(type, value);\n        if (tok) (await this.next())?.value; // advance\n        return tok;\n    }\n\n    async expect(type, value = undefined) {\n        const tok = await this.eat(type, value);\n        if (!tok) throw new Error(`Expected token: ${type}${value ? ` (${value})` : ''}`);\n        return tok;\n    }\n\n    // Normal token flow\n\n    #historyPush(tok) {\n        // this.#history.push() <-- tok (this.#current)\n        if (tok?.type.endsWith('_block')) {\n            //tok.value.#locked = true;\n        }\n        if (this.#rootSavepoint !== null) {\n            this.#history.push(tok);\n        } else {\n            this.#history = [tok];\n        }\n    }\n\n    #peeksShift() {\n        // tok (this.#current) <-- this.#peeks.shift()\n        const tok = this.#peeks.shift();\n        if (tok?.type.endsWith('_block')) {\n            tok.value.#locked = false;\n        }\n        return tok;\n    }\n\n    // Reverse token flow\n\n    #historyPop() {\n        // this.#history.pop() --> tok (this.#current)\n        const tok = this.#history.pop();\n        if (tok?.type.endsWith('_block')) {\n            //tok.value.#locked = false;\n            tok.value.restore(tok.value.#rootSavepoint);\n        }\n        return tok;\n    }\n\n    #peeksUnshift(tok) {\n        // tok (this.#current) --> this.#peeks.unshift()\n        if (tok?.type.endsWith('_block')) {\n            tok.value.restore(tok.value.#rootSavepoint);\n            tok.value.#locked = true;\n        }\n        this.#peeks.unshift(tok);\n    }\n\n    // Peeking token flow\n\n    #peeksPush(tok) {\n        if (tok?.type.endsWith('_block')) {\n            tok.value.#locked = true;\n        }\n        this.#peeks.push(tok);\n    }\n\n    #assertNotLocked(method) {\n        if (this.#locked) {\n            throw new Error(`Can't execute ${method}; TokenStream is locked`);\n        }\n    }\n\n    savepoint() {\n        this.#assertNotLocked('savepoint()');\n        const point = this.#history.length;\n        if (this.#rootSavepoint === null) {\n            this.#rootSavepoint = point;\n        }\n        return point;\n    }\n\n    savepointStatus() {\n        return this.#rootSavepoint !== null\n            ? this.#history.length\n            : null;\n    }\n\n    restore(toIndex) {\n        this.#assertNotLocked('restore()');\n        if (this.#rootSavepoint === null || typeof toIndex !== 'number' || toIndex > this.#history.length) {\n            throw new Error(`Invalid restore point ${toIndex}${this.#rootSavepoint === null ? '. Not in savepoint mode' : ''}`);\n        }\n        while (toIndex < this.#history.length) {\n            if (this.#current) {\n                this.#peeksUnshift(this.#current);\n            }\n            this.#current = this.#historyPop();\n        }\n    }\n\n    commit(toIndex) {\n        this.#assertNotLocked('commit()');\n        if (toIndex !== this.#rootSavepoint) return;\n        let tok;\n        while (toIndex < this.#history.length && (tok = this.#historyPop())) {\n            if (tok.type.endsWith('_block')) {\n                tok.value.commit(tok.value.#rootSavepoint);\n            }\n        }\n        this.#rootSavepoint = null;\n    }\n\n    // Factory input -> to stream\n    static toStream(input) {\n        if (typeof input[Symbol.asyncIterator] === 'function') {\n            return typeof input.next === 'function' ? input : input[Symbol.asyncIterator]();\n        }\n        if (typeof input[Symbol.iterator] === 'function' && typeof input !== 'string' && !(input instanceof String)) {\n            return typeof input.next === 'function' ? input : input[Symbol.iterator]();\n        }\n        return (function* () { yield input + ''; })();\n    }\n\n    // Returns ToeknStream\n    static async create(input, { dialect = 'postgres', state = new TokenStreamState, ...options } = {}) {\n        // Normalize options. Consumers of the instance (i.e. parsers) might benefit from it\n        if (!options.normalized) {\n            options = normalizeOptions({ dialect, ...options, normalized: true });\n        }\n        return new this(\n            await this.createIterator(input, { dialect, state, ...options, extendedAPI: true }),\n            { dialect, ...options },\n        );\n    }\n\n    // Returns Iterator\n    static async * createIterator(input, { dialect = 'postgres', state = new TokenStreamState, ...options } = {}) {\n\n        // Normalize input to stream\n        const stream = this.toStream(input);\n        // Validate \"dialect\" and \"state\" input\n        if (!['postgres', 'mysql'].includes(dialect)) {\n            throw new Error(`Unknown dialect: ${dialect}`);\n        }\n        if (!(state instanceof TokenStreamState)) {\n            throw new Error('options.state must be an instance of TokenStreamState');\n        }\n        // Normalize options. Should it not have come from this.create()\n        if (!options.normalized) {\n            options = normalizeOptions({ dialect, ...options, normalized: true });\n        } else {\n            options = { dialect, ...options };\n        }\n        // Local state\n        const localState = {\n            token: null,\n            prevEmittedToken: null,\n            nextTokenSpaceBefore: '',\n            multiwordBuffer: [],\n        };\n        // Route token normalization\n        const $finalizeToken = (token, forceYield = false) => {\n            if (!token) return [];\n            const result = finalizeToken(token, { options, state, localState }, forceYield);\n            return result;\n        };\n\n        // Iterate over the input stream chunk by chunk\n        let chunk = { value: '' };\n        do {\n            state.buffer += chunk.value || ''/*when done*/;\n            let char;\n            while (char = state.buffer[state.cursor]) {\n\n                const possiblyChunked = state.buffer[state.cursor + 1] === undefined && !chunk.done;\n                const charIsWhitespace = whitespace.has(char);\n                const $throw = () => {\n                    throw new SyntaxError(`Unexpected token: ${char} at line ${state.line}, column ${state.column}`);\n                }\n\n                /**\n                 * ----------\n                 * PART A:\n                 * Feed or terminate sequences\n                 */\n\n                // ----------\n                // Feed (with validation) or terminate special literals.\n                // !ORDER: Note that because we're handling the ending of non-delimited \"literals\" here, (by whitespace)\n                // this block must run before the generic whitespace-handling block below\n                // Meanhwile, we're also using the opportunity to handle delimited ones's ending\n                if (localState.token?.type === 'hex_literal' || localState.token?.type === 'bit_literal') {\n                    const isEndTag = localState.token.delim ? char === localState.token.delim : charIsWhitespace;\n                    if (isEndTag) {\n                        yield* $finalizeToken(localState.token);\n                        localState.token = null;\n                        if (charIsWhitespace && options.spaces) {\n                            localState.nextTokenSpaceBefore += char;\n                        }\n                    } else {\n                        const type = localState.token?.type;\n                        if (type === 'hex_literal') {\n                            if (!/[0-9A-Fa-f]/.test(char)) $throw();\n                        } else {\n                            if (!/[01]/.test(char)) $throw();\n                        }\n                        localState.token.value += char;\n                    }\n                    state.next();\n                    continue;\n                }\n\n                // ----------\n                // Feed (with validation) or terminate \"version_specs\".\n                // !ORDER: Note that because we're handling the ending of non-delimited \"version_specs\" here, (by whitespace or dot)\n                // this block must run before the generic whitespace-handling block below\n                // Meanhwile, we're also using the opportunity to handle delimited ones's ending\n                if (localState.token?.type === 'version_spec') {\n                    const isEndTag = localState.token.delim ? char === localState.token.delim : (char === '.' || charIsWhitespace);\n                    if (isEndTag) {\n                        yield* $finalizeToken(localState.token);\n                        localState.token = null;\n                        if (charIsWhitespace && options.spaces) {\n                            localState.nextTokenSpaceBefore += char;\n                        }\n                    } else if (localState.token.value) {\n                        if (char === '=') {\n                            // \"=\" only allowed as @=2_4, @<=4, @>=2\n                            if (!['<', '>'].includes(localState.token.value)) $throw();\n                        } else if (char === '_') {\n                            // \"_\" only allowed as digits separator\n                            if (!/\\d$/.test(localState.token.value)) $throw();\n                        } else if (!/\\d/.test(char)) $throw();\n                        localState.token.value += char;\n                    } else {\n                        localState.token.value += char;\n                    }\n                    if (char !== '.') {\n                        state.next();\n                        continue;\n                    }\n                }\n\n                // ----------\n                // Whitespace and Linebreaks end sequences\n                // but:\n                // - whitespace is contigious with strings, delimited idents, and comments\n                // - line breaks end single-line comments\n                // !ORDER: Handle this early, but after the \"literals\" block above.\n                if (charIsWhitespace) {\n                    const isString = localState.token?.type === 'string_literal';\n                    const isDelimitedIdent = localState.token?.type === 'identifier' && localState.token.delim;\n                    const isBlockComment = localState.token?.type === 'block_comment';\n                    const isLineComment = localState.token?.type === 'line_comment';\n                    if (isString || isDelimitedIdent || isBlockComment || isLineComment && !(\n                        char === '\\r' || char === '\\n')\n                    ) {\n                        // Not a single-line comment ending. Treat as contigious!\n                        localState.token.value += char;\n                    } else {\n                        // Whitespace starting...? End current token!\n                        const prevChar = state.buffer[state.cursor - 1];\n                        if (!whitespace.has(prevChar) && localState.token) {\n                            yield* $finalizeToken(localState.token);\n                            localState.token = null;\n                        }\n                        if (options.spaces) {\n                            localState.nextTokenSpaceBefore += char;\n                        }\n                    }\n                    if (char === '\\n' || char === '\\r') {\n                        state.next(1, true);\n                    } else {\n                        state.next();\n                    }\n                    continue;\n                }\n\n                // ----------\n                // Handle backslahes in strings when in backslah-escaping mode\n                // - or when in nested context and is a Double Colon-escaping position\n                // !ORDER: Handle backslashes early.\n                if (char === '\\\\') {\n                    if (possiblyChunked) break; // We need to look ahead to know if this is comment ending\n                    let nextChar = state.buffer[state.cursor + 1];\n                    // String char escaping...\n                    const strings_inBackslashEscapeMode = localState.token?.type === 'string_literal' && (options.dialect === 'mysql' ? !options.mysqlNoBackslashEscapes : localState.token.modifier === 'E');\n                    const strings_atEscapePosition = nextChar === localState.token?.delim || nextChar === '\\\\' || nextChar === '0' || nextChar === 'b' || nextChar === 'f' || nextChar === 'n' || nextChar === 'r' || nextChar === 't' || nextChar === 'v' || nextChar === 'Z';\n                    if (strings_inBackslashEscapeMode && strings_atEscapePosition) {\n                        nextChar = {\n                            '\\\\': '\\\\', // to backslash char itself, here for completeness\n                            '0': '\\0', // to NUL byte (ASCII 0)\n                            'b': '\\b', // to backspace (ASCII 8)\n                            'f': '\\f', // to form feed\n                            'n': '\\n', // to newline\n                            'r': '\\r', // to carriage return\n                            't': '\\t', // to tab\n                            'v': '\\v', // to vertical tab\n                            'Z': '\\x1A', // to ASCII 26 (SUB / Control+Z) - represented as \\x1A in JS\n                        }[nextChar] || nextChar;\n                        localState.token.value += nextChar;\n                        state.next(2);\n                        continue;\n                    }\n                    state.nextTokenEscape = 1;\n                    state.next();\n                    continue;\n                }\n\n                // ----------\n                // Feed or terminate:\n                // - block_comment\n                // - string_literal\n                // - delimited identifier\n                // - delimited user_var\n                if (localState.token?.type === 'block_comment'\n                    || localState.token?.type === 'line_comment' // For feeding\n                    || localState.token?.type === 'string_literal'\n                    || (localState.token?.type === 'identifier' && localState.token.delim)\n                    || (localState.token?.type === 'user_var' && localState.token.delim)/*MySQL @'user-var'*/) {\n                    let tokenEndSteps;\n                    if (localState.token.type === 'block_comment') {\n                        if (char === '*') {\n                            if (possiblyChunked) break; // We need to look ahead to know if this is comment ending\n                            const nextChar = state.buffer[state.cursor + 1];\n                            tokenEndSteps = nextChar === '/' ? 2 : 0; // 2 chars for end tag, 0 otherwise: not a comment end\n                        }\n                    } else if (char === localState.token.delim) {\n                        // Two contiqious delims is escape when is identifier\n                        const twoContiqiousDelimsIsEscape = localState.token.type === 'identifier'\n                            // Or for strings, when not using backslash as escape\n                            || localState.token.type === 'string_literal' && (options.dialect === 'mysql' ? options.mysqlNoBackslashEscapes : localState.token.modifier !== 'E');\n                        // Do escaping if so\n                        if (twoContiqiousDelimsIsEscape) {\n                            if (possiblyChunked) break; // We need to look ahead to know if this is an quote escape quote\n                            const nextChar = state.buffer[state.cursor + 1];\n                            if (nextChar === char) {\n                                localState.token.value += char; // Pick one of the two quotes\n                                state.next(2); // and eat the other\n                                continue;\n                            }\n                        }\n                        // End token otherwise: char === localState.token.delim\n                        tokenEndSteps = 1;\n                    } else if (localState.token.type === 'string_literal' && localState.token.delim.startsWith('$')/*postgres*/ && char === '$') {\n                        // Specially catch Postgres' dollar-delims\n                        const cursor = state.cursor + 1;\n                        if (state.buffer.slice(cursor - localState.token.delim.length, cursor) === localState.token.delim) {\n                            localState.token.value = localState.token.value.slice(0, - localState.token.delim.length + 1);\n                            tokenEndSteps = 1;\n                        }\n                    }\n                    if (tokenEndSteps) {\n                        yield* $finalizeToken(localState.token);\n                        localState.token = null;\n                        state.next(tokenEndSteps);\n                        continue;\n                    }\n                    // Feed ongoing sequence\n                    localState.token.value += char;\n                    state.next();\n                    continue;\n                }\n\n                // ----------\n                // Handle closing nesting delims:\n                // - }\n                // - ]\n                // - )\n                if (state.nestingContext.length && char === { '{': '}', '[': ']', '(': ')' }[state.nestingContext[0]]) {\n                    yield* $finalizeToken(localState.token, true);\n                    state.nestingContext.shift();\n                    if (options.structured) {\n                        state.next(); // Eat the end tag\n                        localState.nestingEndTagSeen = true;\n                        return;\n                    }\n                    localState.token = null;\n                }\n\n                /**\n                 * ----------\n                 * PART B:\n                 * Start or restart sequences\n                 */\n\n                // ----------\n                // Start\n                // - comments\n                // - strings\n                // - identifiers\n                let tokenStart, tokenStartBacksteps = 0, tokenStartForwardsteps = 0;\n\n                if (options.dialect === 'postgres') {\n                    // Postgres' dollars :)\n                    if (localState.token?.type === 'pg_possible_dollar_delim' || char === '$') {\n                        // Catch the beginning of Postgres' dollar-delims\n                        if (localState.token?.type === 'pg_possible_dollar_delim') {\n                            if (char === '$') {\n                                const { type: _, value, delim: __, ...restTok } = localState.token;\n                                localState.token = { type: 'string_literal', value: '', delim: `$${value}$`, ...restTok };\n                            } else {\n                                localState.token.value += char;\n                            }\n                            state.next();\n                            continue;\n                        }\n                        if (possiblyChunked) break; // We need to look ahead to know if this is bind_var or...\n                        const nextChar = state.buffer[state.cursor + 1];\n                        if (/[0-9]/.test(nextChar)) {\n                            tokenStart = { type: 'bind_var' };\n                        } else {\n                            // ...possible dollar-delimited string\n                            tokenStart = { type: 'pg_possible_dollar_delim', delim: char };\n                        }\n                    }\n                } else if (options.dialect === 'mysql') {\n                    // MySQL's questions :)\n                    if (char === '?') {\n                        tokenStart = { type: 'bind_var' };\n                    }\n                    // MySQL's hash comments :)\n                    if (char === '#') {\n                        tokenStart = { type: 'line_comment', delim: char };\n                    }\n                    // MySQL's backflips :)\n                    if (char === '`') {\n                        tokenStart = { type: 'identifier', delim: char };\n                    }\n                }\n\n                // Strings and ansi-delimited identifers\n                if (char === \"'\") {\n                    const modifierPattern = new RegExp(`(@)$|^\\\\W?(${options.dialect === 'postgres' ? 'E|X|B' : 'N|X'})$`, 'i');\n                    const modifierMatch = state.buffer.slice(Math.max(state.cursor - 2, 0), state.cursor).match(modifierPattern);\n                    const modifier = modifierMatch?.[1] || modifierMatch?.[2];\n                    // First try to match LinkedQL version tag\n                    if (modifier === '@' && localState.prevEmittedToken?.type === 'identifier') {\n                        if (possiblyChunked) break; // We need to look ahead to properly determine if variable\n                        const nextChar = state.buffer[state.cursor + 1];\n                        if (/[\\^~=\\d<>!]/.test(nextChar)) {\n                            // Resolve to @'1_1_tags'\n                            tokenStart = { type: 'version_spec', delim: char };\n                            tokenStartBacksteps = 1;\n                        }\n                    }\n                    // Otherwise, resolve to:\n                    // E'new\\\\nline' (postgres)\n                    // N'unicode' (mysql)\n                    // X'FF' (mysql && postgres)\n                    // B'0101' (postgres)\n                    // @'mysql-user-var' (mysql)\n                    if (!tokenStart) {\n                        if (modifier && (modifier !== '@' || options.dialect === 'mysql')) {\n                            const type = /^(E|N)/i.test(modifier) ? 'string_literal' : (\n                                modifier === '@' ? 'user_var' : (modifier === 'X' ? 'hex_' : 'bit_') + 'literal'\n                            );\n                            tokenStart = { type, ...(type === 'string_literal' ? { modifier: modifier.toUpperCase() } : {}), delim: char };\n                            tokenStartBacksteps = modifier === '@' ? 1 : modifier.length;\n                        } else {\n                            tokenStart = { type: 'string_literal', delim: char };\n                        }\n                    }\n                } else if (char === '\"') {\n                    const type = options.dialect !== 'mysql' || options.mysqlAnsiQuotes ? 'identifier' : 'string_literal';\n                    tokenStart = { type, delim: char };\n                }\n\n                if (char === '@') {\n                    // LinkedQL version tag or MySQL user/system variable?\n                    if (possiblyChunked) break; // We need to look ahead to properly determine if variable\n                    const nextChar = state.buffer[state.cursor + 1];\n                    if ((localState.token || localState.prevEmittedToken)?.type === 'identifier' && /[\\^~=\\d<>!]/.test(nextChar)) {\n                        // LinkedQL @1_1_tags\n                        tokenStart = { type: 'version_spec' };\n                    } else if (options.dialect === 'mysql') {\n                        // MySQL's varieties :)\n                        if (nextChar === '@') {\n                            // MySQL system variables\n                            tokenStart = { type: 'system_var' };\n                            tokenStartForwardsteps = 1;\n                        } else if (/[a-zA-Z_$]/.test(nextChar)) {\n                            // MySQL user-defined variables\n                            tokenStart = { type: 'user_var' };\n                        }\n                    }\n                }\n\n                // Comments\n                if (char === '/' || char === '-') {\n                    if (possiblyChunked) break; // We need to look ahead to know if this is comment starting\n                    const nextChar = state.buffer[state.cursor + 1];\n                    if (char === '/' && nextChar === '*') {\n                        tokenStart = { type: 'block_comment' };\n                        tokenStartForwardsteps = 1;\n                    } else if (char === '-' && nextChar === '-') {\n                        tokenStart = { type: 'line_comment', delim: char + nextChar };\n                        tokenStartForwardsteps = 1;\n                    }\n                }\n\n                // Start token\n                if (tokenStart) {\n                    if (localState.token && !tokenStartBacksteps) {\n                        yield* $finalizeToken(localState.token);\n                    }\n                    localState.token = { type: tokenStart.type, value: '', ...tokenStart, line: state.line, column: tokenStartBacksteps ? state.column - tokenStartBacksteps : state.column };\n                    state.next(1 + tokenStartForwardsteps);\n                    continue;\n                }\n\n                // ----------\n                // Start nesting:\n                // - {\n                // - [\n                // - (\n                if (char === '{' || char === '[' || char === '(') {\n                    // When we encounter an opening nesting delim, we enter sub-tokenization\n                    yield* $finalizeToken(localState.token);\n                    localState.token = null;\n                    state.nestingContext.unshift(char);\n                    if (options.structured) {\n                        state.next();\n                        const groupToken = {\n                            type: { '{': 'brace_block', '[': 'bracket_block', '(': 'paren_block' }[char],\n                            value: await this[options.extendedAPI ? 'create' : 'createIterator'](stream, { state, ...options }),\n                        };\n                        yield* $finalizeToken(groupToken);\n                        if (options.extendedAPI) {\n                            await groupToken.value.peek(Infinity);\n                        } else {\n                            while (!(await groupToken.value.next()).done);\n                        }\n                        continue;\n                    }\n                }\n\n                /**\n                 * ----------\n                 * PART C:\n                 * Handle more nuanced sequences\n                 */\n\n                if (/[0-9]/.test(char)) {\n                    // A number \"literal\" or MySQL's HEX \"literal\" or Postgres' BIN \"literal\"\n                    // Passed along if this is part of an \"identifier\", \"bind_var\", \"version_spec\", \"*_literal\", or  \"*_var\" sequence\n                    if (localState.token?.type !== 'identifier' && localState.token?.type !== 'bind_var' && localState.token?.type !== 'version_spec' && !localState.token?.type.endsWith('_literal') && !localState.token?.type.endsWith('_var')) {\n                        yield* $finalizeToken(localState.token);\n                        if (/*HEX: 0xFF*/char === '0') {\n                            if (possiblyChunked) break; // We need to look ahead to know if this is an X\n                            const $type = state.buffer[state.cursor + 1]?.toUpperCase();\n                            if (($type === 'X' || $type === 'B') && options.dialect === 'mysql') {\n                                localState.token = { type: ($type === 'X' ? 'hex_' : 'bit_') + 'literal', value: '', line: state.line, column: state.column };\n                                state.next(2);\n                                continue;\n                            }\n                        }\n                        localState.token = { type: 'number_literal', value: char, line: state.line, column: state.column };\n                        state.next();\n                        continue;\n                    }\n                } else if (/[a-zA-Z_]/.test(char)) {\n                    // Alphanumeric sequences that start as \"identifier\" but could translate to \"keywords\", \"identifiers\", or even \"operators\"\n                    // Passed along if this is part of a \"identifier\" or \"*_var\" sequence or is the \"E\" in Scientific number notations\n                    if (localState.token?.type !== 'identifier' && !localState.token?.type.endsWith('_var') && !(localState.token?.type === 'number_literal'\n                        && /*EXP: 30e2*/(/\\d$/.test(localState.token.value) && /E/i.test(char)))) {\n                        // Throw if in mid-number sequence\n                        if (localState.token?.type === 'number_literal') $throw();\n                        yield* $finalizeToken(localState.token);\n                        // Start identifier\n                        localState.token = { type: 'identifier', value: char, line: state.line, column: state.column };\n                        state.next();\n                        continue;\n                    }\n                } else {\n                    // Handle punctuations and operators\n                    let type = 'operator';\n                    if (char === ';'\n                        || char === ','\n                        || char === ':'\n                        || char === '{'\n                        || char === '}'\n                        || char === '['\n                        || char === ']'\n                        || char === '('\n                        || char === ')') {\n                        if (char === ':' && (state.nestingContext[0] !== '{' || state.nextTokenEscape)) {\n                            type = 'operator'; // Postgres' colon is an operator, not a punctuation\n                        } else {\n                            type = 'punctuation';\n                        }\n                        if (options.dialect === 'postgres' && char === ':' && type === 'operator' && localState.token?.type !== 'operator') {\n                            const previousChar = state.buffer[state.cursor - 1];\n                            if (possiblyChunked) break; // We need to look ahead to know if this is number starting\n                            const nextChar = state.buffer[state.cursor + 1];\n                            if (previousChar !== ':' && /[a-zA-Z_]/.test(nextChar) && options.PL_SQL !== false) {\n                                type = 'user_var'; // PL/SQL variable\n                                char = '';\n                            }\n                        }\n                    } else if (char === '.') {\n                        if (localState.token?.type === 'number_literal') {\n                            // Mid-number punctuation; floats\n                            if (localState.token.value.includes('.')) $throw();\n                            type = 'number_literal'; // e.g. 2.4\n                        } else {\n                            // Pre-number punctuation? Same floats?\n                            if (possiblyChunked) break; // We need to look ahead to know if this is number starting or a punctuation\n                            const nextChar = state.buffer[state.cursor + 1];\n                            if (/\\d/.test(nextChar)) {\n                                type = 'number_literal'; // e.g. \".004\"\n                            } else {\n                                // Other punctuation. Standalone token:\n                                // e.g. tbl.col, tbl.*, db@<3_2.\"000-u\".id\n                                type = 'punctuation'; // e.g. \"tbl.col\", \"tbl . col\"\n                                // Or maybe MySQL special var punctuation?\n                                if (localState.token?.type === 'system_var') {\n                                    type = 'system_var'; // e.g. \"@@session. autocommit\"\n                                }\n                            }\n                        }\n                    } else if (char === '+' || char === '-') {\n                        if (localState.token?.type === 'number_literal' && /E$/i.test(localState.token.value)) {\n                            // Scientific number notation; EXP: 30e-2\n                            if (/\\+|\\-/.test(localState.token.value)) $throw();\n                            type = 'number_literal';\n                        }\n                    }\n\n                    // Feed an ongoing sequence or terminate that and start a new one?\n                    if (localState.token?.type !== type || type === 'punctuation' || (\n                        type === 'operator' && !options.operators.classic.has(`${localState.token.value}${char}`) /*not a valid operator afterall? e.g. \"=-\"*/\n                    )) {\n                        yield* $finalizeToken(localState.token);\n                        localState.token = { type, value: char, line: state.line, column: state.column };\n                        state.next();\n                        continue;\n                    }\n\n                    // Passed thru to feed an ongoing sequence\n                }\n\n                localState.token.value += char;\n                state.next();\n            }\n\n            if (chunk.done) break;\n            // Update buffer to handle overflow and continue from next chunk\n            state.buffer = state.buffer.slice(state.cursor);\n            state.cursor = 0;\n        } while (chunk = await stream.next());\n\n        if (localState.token) {\n            if (\n                (localState.token.type === 'operator' && localState.token.value !== '*')\n                || localState.token.type === 'number_literal' && /E$/i.test(localState.token.value)\n                || localState.token.type === 'block_comment'\n                || localState.token.type === 'pg_possible_dollar_delim'\n                || (\n                    ['string_literal', 'hex_literal', 'bit_literal', 'identifier', 'version_spec', 'user_var'].includes(localState.token.type)\n                    && localState.token.delim\n                )) {\n                throw new SyntaxError(`Unterminated ${localState.token.type} at line ${state.line}, column ${state.column}`);\n            }\n            yield* $finalizeToken(localState.token, true);\n        }\n        if (state.nestingContext.length && !localState.nestingEndTagSeen) {\n            throw new SyntaxError(`Unterminated nesting \"${state.nestingContext[0]}\" at line ${state.line}, column ${state.column}`);\n        }\n    }\n}\n\n// Lookups\nconst whitespace = new Set([' ', '\\f', '\\n', '\\r', '\\t', '\\v',]);\n\n// Normalize options\nfunction normalizeOptions(options) {\n    // Build the following list into our formats\n    const addMultiWord = (targetMap, prefix, tok, token) => {\n        tok.split(' ').reduce((_tok, chunk) => {\n            _tok = _tok ? `${_tok} ${chunk}` : chunk;\n            targetMap.set(_tok, token);\n            return _tok;\n        }, prefix);\n    };\n    for (const tokenCategory of ['statements', 'functionNames', 'aggrFunctionNames', 'keywords', 'operators', 'dataTypes']) {\n        const $tokenCategory = ['statements', 'functionNames', 'aggrFunctionNames'].includes(tokenCategory) ? 'keywords' : tokenCategory;\n        const tokenRegistry = options[$tokenCategory] || { classic: new Map, compound: new Map };\n        for (const tokenDialectBranch of ['common', options.dialect === 'mysql' ? 'mysql' : 'postgres']) {\n            const entries = toktypes[tokenCategory][tokenDialectBranch];\n            for (const entry of entries) {\n                const [value, token] = Array.isArray(entry) ? [entry[0], { ...entry[1], value: entry[0] }] : [entry, { value: entry }];\n                if (value.includes(' ')) {\n                    addMultiWord(tokenRegistry.compound, '', value, token);\n                } else {\n                    tokenRegistry.classic.set(value, token);\n                }\n            }\n        }\n        options = { ...options, [$tokenCategory]: tokenRegistry };\n    }\n    return options;\n}\n\n// Finalize tokens\nfunction finalizeToken(token, { options, state, localState }, forceYield = false) {\n    if (localState.nextTokenSpaceBefore) {\n        const { type, ...tok } = token;\n        token = { type, spaceBefore: localState.nextTokenSpaceBefore, ...tok };\n        localState.nextTokenSpaceBefore = '';\n    }\n    if (token.type === 'block_comment' || token.type === 'line_comment') {\n        return finalizeComment(token, { options });\n    }\n    let finalToken, identResolution = false;\n    if (options.dialect === 'mysql' && token.type === 'bind_var') {\n        finalToken = [{ ...token, value: `${++state.mysqlBindingIndex}` }];\n    } else if (token.type === 'operator') {\n        // Add operator definition details\n        const { line, column, ...restTok } = token;\n        finalToken = [{\n            ...restTok,\n            ...(options.operators.classic.get(token.value) || {}),\n            line,\n            column,\n        }];\n    } else if (token.type === 'identifier' && !token.delim) {\n        finalToken = finalizeIdentifier(token, { options, state, localState }, forceYield);\n        identResolution = true;\n    }\n    if (!finalToken/*Without asking length*/) {\n        finalToken = [token];\n    }\n    // -----\n    if (finalToken?.length) {\n        localState.prevEmittedToken = finalToken[0];\n    } else {\n        localState.prevEmittedToken = token;\n    }\n    // -----\n    if (!identResolution && finalToken.length && localState.multiwordBuffer.length) {\n        return localState.multiwordBuffer.splice(0).concat(finalToken);\n    }\n    return finalToken;\n}\n\n// Finalize comment tokens\nfunction finalizeComment(token, { options }) {\n    if (!options.comments) return [];\n    if (token.type === 'block_comment') {\n        token = { ...token, value: token.value.split('\\n').map((s) => s.replace(/^[ ]+\\*[ ]+?/, '').trim()).join('\\n') };\n    } else {\n        token = { ...token, value: token.value.trim() };\n    }\n    return [token];\n}\n\n// Finalize \"literal\" tokens\nfunction finalizeIdentifier(token, { options, state, localState }, forceYield = false) {\n    let finalToken,\n        multiwordBufferLength = localState.multiwordBuffer.length;\n    // Yield or build multiword operators\n    const wordSoFar = (\n        multiwordBufferLength ? localState.multiwordBuffer.map((tok) => tok.value).concat(token.value).join(' ') : token.value\n    ).toUpperCase();\n\n    const findInBranch = (branch) => {\n        for (const tokenCategory of ['keywords', 'operators', 'dataTypes']) {\n            const matchResult = options[tokenCategory][branch].get(wordSoFar);\n            if (matchResult) return [tokenCategory, matchResult];\n        }\n        return [];\n    };\n\n    const processExactMatch = () => {\n        let { type: _, spaceBefore, line, column, ...restTok } = token;\n        if (multiwordBufferLength) {\n            spaceBefore = localState.multiwordBuffer[0].spaceBefore;\n            line = localState.multiwordBuffer[0].line;\n            column = localState.multiwordBuffer[0].column;\n        }\n        const tok = {\n            type: tokenCategory === 'dataTypes' ? 'data_type' : tokenCategory.replace(/s$/, ''),\n            ...(spaceBefore ? { spaceBefore } : {}),\n            ...restTok,\n            ...matchResult, // Final value in here and overriding restTok.value\n            value: wordSoFar,\n            line, // \"line\" and \"column\" coming last now\n            column\n        };\n        if (multiwordBufferLength) {\n            finalToken = [tok];\n            localState.multiwordBuffer.splice(0);\n            multiwordBufferLength = 0;\n        } else {\n            finalToken = [tok];\n        }\n    };\n    const processPartialMatch = () => {\n        const tok = { ...token, type: tokenCategory === 'dataTypes' ? 'data_type' : tokenCategory.replace(/s$/, '') };\n        localState.multiwordBuffer.push(tok);\n        finalToken = [];\n    };\n\n    let multiwordMatched = false;\n    let [tokenCategory, matchResult] = findInBranch('compound');\n    if (matchResult?.value === wordSoFar || (forceYield && matchResult)) {\n        processExactMatch();\n        multiwordMatched = true;\n    } else if (matchResult) {\n        /* first (e.g. DISTINCT kw vs DISTINCT FROM op) */\n        const [tokenCategory2, matchResult2] = findInBranch('classic');\n        if (matchResult2 && tokenCategory2 !== tokenCategory) {\n            [tokenCategory, matchResult] = [tokenCategory2, matchResult2];\n        }\n        processPartialMatch();\n        multiwordMatched = true;\n    } else {\n        [tokenCategory, matchResult] = findInBranch('classic');\n        if (matchResult) {\n            processExactMatch();\n            multiwordMatched = true;\n        }\n    }\n    if (!multiwordMatched && multiwordBufferLength) {\n        const existing = localState.multiwordBuffer.splice(0);\n        const current = finalizeToken(token, { options, state, localState });\n        return [...existing, ...current];\n    }\n    // Treat as identifier\n    if (!finalToken && /^(TRUE|FALSE|NULL|UNKNOWN)$/i.test(token.value)) {\n        const { type: _, ...tok } = token;\n        finalToken = [{\n            type: /UNKNOWN/.test(token.value) ? 'unknown_literal' : (/NULL/i.test(token.value) ? 'null_literal' : 'bool_literal'),\n            ...tok\n        }];\n    }\n    return finalToken;\n}\n", "export const registry = Object.create(null);\n", "import { _isObject } from '@webqit/util/js/index.js';\r\nimport { _eq, _toCapsSnake } from '../util.js';\r\nimport { TokenStream } from '../TokenStream.js';\r\nimport { TOK_TYPES } from '../toktypes.js';\r\nimport { registry } from '../registry.js';\r\n\r\n/**\r\n * parse(str, { ... })|fromJSON(json, {\r\n *   dialect,\r\n * \t mysqlAnsiQuotes\r\n *   mysqlNoBackslashEscapes,\r\n *   assert\r\n * })\r\n * \r\n * stringify({\r\n *   prettyPrint,\r\n * \t startingIndentLevel,\r\n *   autoLineBreakThreshold,\r\n *   pruneOptionalParens,\r\n *   tabSpaces\r\n * })\r\n * \r\n * jsonfy({\r\n *   nodeNames,\r\n *   toDialect,\r\n *   deSugar,\r\n *   reverseRef,\r\n *   fullyQualified,\r\n * })\r\n */\r\n\r\nexport class AbstractNode {\r\n\r\n\tstatic get NODE_NAME() { return _toCapsSnake(this.name); }\r\n\tget NODE_NAME() { return this.constructor.NODE_NAME; }\r\n\r\n\t#ast;\r\n\t#options;\r\n\t#astSchema;\r\n\r\n\tconstructor(ast = {}, options = {}) {\r\n\t\tthis.#ast = ast;\r\n\t\tthis.#options = options;\r\n\t\tthis.#astSchema = this.constructor.compileASTSchemaFromSyntaxRules(this.options);\r\n\t\tfor (const node_s of Object.values(this.#ast)) {\r\n\t\t\tthis._adoptNodes(...[].concat(node_s));\r\n\t\t}\r\n\t}\r\n\r\n\t#contextNode;\r\n\r\n\tget contextNode() { return this.#contextNode; }\r\n\r\n\tget statementNode() { return this.#contextNode?.statementNode; }\r\n\r\n\tget rootNode() { return this.#contextNode?.rootNode || this; }\r\n\r\n\tget options() { return this.#options; }\r\n\r\n\t/**\r\n\t * -----------\r\n\t * AST API\r\n\t * -----------\r\n\t */\r\n\r\n\tget _astSchema() { return this.#ast; }\r\n\r\n\t_fieldSchema(fieldName, index = undefined) {\r\n\t\tconst fieldSchema = this.#astSchema[fieldName] || {};\r\n\t\tif (typeof index !== 'undefined') {\r\n\t\t\tconst activeTrailStr = `${this.NODE_NAME}.<${fieldName}>.<${index}>`;\r\n\t\t\tif ([undefined, null].includes(fieldSchema.arity)) {\r\n\t\t\t\tthrow new Error(`[${activeTrailStr}] Can't use index on \"${fieldName}\". Not index-based.`);\r\n\t\t\t}\r\n\t\t\tif (!fieldSchema.keyed && typeof index !== 'number') {\r\n\t\t\t\tthrow new Error(`[${activeTrailStr}] Can't use non-numeric index on \"${fieldName}\". Not keyed.`);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn fieldSchema;\r\n\t}\r\n\r\n\t_set(fieldName, indexOrValue, valueOnIndex = undefined) {\r\n\t\tconst index = arguments.length > 2 ? indexOrValue : undefined;\r\n\t\tconst value = arguments.length > 2 ? valueOnIndex : indexOrValue;\r\n\t\tconst fieldSchema = this._fieldSchema(fieldName, index);\r\n\t\tconst existing = this._get(fieldName, index);\r\n\t\tconst activeTrailStr = `${this.NODE_NAME}.<${fieldName}>`;\r\n\t\tif (existing) {\r\n\t\t\tthis._unadoptNodes(...[].concat(existing));\r\n\t\t}\r\n\t\tif (typeof index !== 'undefined') {\r\n\t\t\tthis.#ast[fieldName] = !existing ? this.#ast[fieldName].concat(value) : this.#ast[fieldName].reduce((all, n) => {\r\n\t\t\t\tif (n === existing) return all;\r\n\t\t\t\treturn all.concat(n);\r\n\t\t\t}, []);\r\n\t\t} else {\r\n\t\t\tif (![undefined, null].includes(fieldSchema.arity)) {\r\n\t\t\t\tif (!Array.isArray(value)) {\r\n\t\t\t\t\tthrow new Error(`[${activeTrailStr}] Invalid \"${fieldName}\" type provided. Array expected.`);\r\n\t\t\t\t}\r\n\t\t\t\tif (fieldSchema.arity !== Infinity) {\r\n\t\t\t\t\tconst count = value.length;\r\n\t\t\t\t\tif (_isObject(fieldSchema.arity)) {\r\n\t\t\t\t\t\tif ('min' in fieldSchema.arity && count < fieldSchema.arity.min) {\r\n\t\t\t\t\t\t\tthrow new Error(`[${activeTrailStr}] A minimum of ${fieldSchema.arity.min} argument(s) expected but got ${count}.`);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif ('max' in fieldSchema.arity && count > fieldSchema.arity.max) {\r\n\t\t\t\t\t\t\tthrow new Error(`[${activeTrailStr}] A maximum of ${fieldSchema.arity.max} argument(s) expected but got ${count}.`);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if (![].concat(fieldSchema.arity).includes(count)) {\r\n\t\t\t\t\t\tthrow new Error(`[${activeTrailStr}] Exactly ${[].concat(fieldSchema.arity).join(' or ')} argument(s) expected but got ${count}.`);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.#ast[fieldName] = value;\r\n\t\t}\r\n\t\tthis._adoptNodes(...[].concat(value));\r\n\t\treturn true;\r\n\t}\r\n\r\n\t_get(fieldName, index = undefined) {\r\n\t\t//const fieldSchema = this._fieldSchema(fieldName, index); TODO\r\n\t\tif (fieldName in this.#ast) {\r\n\t\t\t// Return value, optionally deeply\r\n\t\t\tlet value = this.#ast[fieldName];\r\n\t\t\tif (typeof index === 'number') {\r\n\t\t\t\tvalue = value[index];\r\n\t\t\t} else if (index) {\r\n\t\t\t\tvalue = value.find((n) => n.identifiesAs?.(index));\r\n\t\t\t}\r\n\t\t\treturn value;\r\n\t\t}\r\n\t\tif (typeof index === 'undefined') {\r\n\t\t\t// Return default\r\n\t\t\t//return ![undefined, null].includes(fieldSchema.arity) ? [] : fieldSchema.default;\r\n\t\t}\r\n\t}\r\n\r\n\t_delete(fieldName, index = undefined) {\r\n\t\tthis._fieldSchema(fieldName, index);\r\n\t\tif (!(fieldName in this.#ast)) return false;\r\n\t\tif (typeof index !== 'undefined') {\r\n\t\t\tthis.#ast[fieldName] = this.#ast[fieldName].reduce((all, n, i) => {\r\n\t\t\t\tconst matches = typeof index === 'number'\r\n\t\t\t\t\t? i === index\r\n\t\t\t\t\t: n.identifiesAs?.(index);\r\n\t\t\t\tif (matches) {\r\n\t\t\t\t\tthis._unadoptNodes(n);\r\n\t\t\t\t\treturn all;\r\n\t\t\t\t}\r\n\t\t\t\treturn all.concat(n);\r\n\t\t\t}, []);\r\n\t\t} else {\r\n\t\t\tthis._unadoptNodes(...[].concat(this.#ast[fieldName]));\r\n\t\t\tthis.#ast[fieldName] = this._default(fieldName);\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\t_has(fieldName, index = undefined) {\r\n\t\tthis._fieldSchema(fieldName, index);\r\n\t\tif (fieldName in this.#ast) {\r\n\t\t\tif (typeof index === 'number') {\r\n\t\t\t\treturn typeof this.#ast[fieldName][index] !== 'undefined';\r\n\t\t\t}\r\n\t\t\tif (index) {\r\n\t\t\t\treturn this.#ast[fieldName].some((n) => n.identifiesAs?.(index));\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t_add(fieldName, ...args) {\r\n\t\tconst fieldSchema = this._fieldSchema(fieldName);\r\n\t\tif ([undefined, null].includes(fieldSchema.arity)) {\r\n\t\t\tconst activeTrailStr = `${this.NODE_NAME}.<${fieldName}>`;\r\n\t\t\tthrow new Error(`[${activeTrailStr}] Can't perform add() on \"${fieldName}\". Not item-based.`);\r\n\t\t}\r\n\t\tthis._adoptNodes(...args);\r\n\t\tthis.#ast[fieldName] = this.#ast[fieldName].concat(args);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t_adoptNodes(...nodes) {\r\n\t\tfor (const node of nodes) {\r\n\t\t\tif (!(node instanceof AbstractNode)) continue;\r\n\t\t\tif (node.#contextNode && node.#contextNode !== this) {\r\n\t\t\t\tconst activeTrailStr = `${this.NODE_NAME}`;\r\n\t\t\t\tthrow new Error(`[${activeTrailStr}] Illegal node operation`);\r\n\t\t\t}\r\n\t\t\tnode.#contextNode = this;\r\n\t\t}\r\n\t}\r\n\r\n\t_unadoptNodes(...nodes) {\r\n\t\tfor (const node of nodes) {\r\n\t\t\tif (!(node instanceof AbstractNode)) continue;\r\n\t\t\tif (node.#contextNode !== this) {\r\n\t\t\t\tconst activeTrailStr = `${this.NODE_NAME}`;\r\n\t\t\t\tthrow new Error(`[${activeTrailStr}] Illegal node operation`);\r\n\t\t\t}\r\n\t\t\tnode.#contextNode = null;\r\n\t\t}\r\n\t}\r\n\r\n\t_walk(visitor) {\r\n\t\tfor (const value of Object.values(this.#ast)) {\r\n\t\t\tfor (const possibleNode of [].concat(value)) {\r\n\t\t\t\tif (possibleNode?._walk) possibleNode._walk(visitor);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (visitor?.visit) {\r\n\t\t\treturn visitor.visit(this);\r\n\t\t}\r\n\t\tif (typeof visitor === 'function') {\r\n\t\t\treturn visitor(this);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * -----------\r\n\t * CONTEXT API\r\n\t * -----------\r\n\t */\r\n\r\n\t_capture(requestName, requestSource) {\r\n\t\tif (arguments.length !== 2) {\r\n\t\t\tthrow new Error(`_capture() expects exactly 2 parameters.`);\r\n\t\t}\r\n\t\treturn this.#contextNode?._capture?.(requestName, requestSource);\r\n\t}\r\n\r\n\tcapture(requestName) {\r\n\t\tif (arguments.length !== 1) {\r\n\t\t\tthrow new Error(`capture() expects exactly 1 parameter.`);\r\n\t\t}\r\n\t\treturn this.#contextNode?._capture(requestName, this);\r\n\t}\r\n\r\n\t_bubble(eventType, eventSource) {\r\n\t\tif (arguments.length !== 2) {\r\n\t\t\tthrow new Error(`_bubble() expects exactly 2 parameters.`);\r\n\t\t}\r\n\t\tthis.#contextNode?._bubble?.(eventType, eventSource);\r\n\t\tif (eventSource === this && eventType === 'DISCONNECTED') { this.#contextNode = null; }\r\n\t}\r\n\r\n\tbubble(eventType) {\r\n\t\tif (arguments.length !== 1) {\r\n\t\t\tthrow new Error(`bubble() expects exactly 1 parameter.`);\r\n\t\t}\r\n\t\treturn this.#contextNode?._bubble?.(eventType, this);\r\n\t}\r\n\r\n\tcontainsNode(possibleChild) {\r\n\t\tif (!possibleChild) return false;\r\n\t\treturn this === possibleChild.contextNode || this.containsNode(possibleChild.contextNode);\r\n\t}\r\n\r\n\tidentifiesAs(value) {\r\n\t\tif (typeof value === 'undefined') return false;\r\n\t\tif (typeof value?.toJSON === 'function') return _eq(this.jsonfy(), value.jsonfy(), 'ci');\r\n\t}\r\n\r\n\t/**\r\n\t * -----------\r\n\t * TRANSFORMATION API\r\n\t * -----------\r\n\t */\r\n\r\n\tstatic morphsTo() { return this; }\r\n\r\n\tdeSugar(options = {}) {\r\n\t\toptions = { ...options, deSugar: true };\r\n\t\treturn this.clone(options);\r\n\t}\r\n\r\n\ttoDialect(dialect, options = {}) {\r\n\t\toptions = { ...options, toDialect: dialect };\r\n\t\treturn this.clone(options);\r\n\t}\r\n\r\n\tclone(options = {}) {\r\n\t\tconst resultJson = this.jsonfy(options);\r\n\t\tconst Classes = [].concat(this.constructor.morphsTo());\r\n\t\treturn Classes.reduce((prev, C) => prev || C.fromJSON(resultJson, { dialect: options.toDialect || this.options.dialect }), undefined);\r\n\t}\r\n\r\n\t/**\r\n\t * -----------\r\n\t * JSON API\r\n\t * -----------\r\n\t */\r\n\r\n\tstatic get syntaxRules() { return []; }\r\n\r\n\tstatic compileASTSchemaFromSyntaxRules({ dialect = 'postgres' } = {}) {\r\n\t\tif (!this._astSchemaCompileCache) {\r\n\t\t\tthis._astSchemaCompileCache = new Map;\r\n\t\t}\r\n\t\tconst cacheKey = `${this.NODE_NAME}:${dialect}`;\r\n\t\tif (!this._astSchemaCompileCache.has(cacheKey)) {\r\n\t\t\tlet result, syntaxRules = this.syntaxRules, rulesArray = [].concat(syntaxRules);\r\n\t\t\tif (rulesArray.length === 1 && Array.isArray(rulesArray[0].type) && !rulesArray[0].as) {\r\n\t\t\t\tresult = rulesArray[0];\r\n\t\t\t} else {\r\n\t\t\t\tresult = this._compileASTSchemaFromSyntaxRules(syntaxRules, dialect, { trail: [this.NODE_NAME] });\r\n\t\t\t}\r\n\t\t\tthis._astSchemaCompileCache.set(cacheKey, result);\r\n\t\t}\r\n\t\treturn this._astSchemaCompileCache.get(cacheKey);\r\n\t}\r\n\r\n\tstatic _compileASTSchemaFromSyntaxRules(syntaxRules, dialect = 'postgres', { trail = [], schemaSet = new Set([new Map]), assertionTrail = { dependencies: new Set, optional: false, assert: false } } = {}) {\r\n\t\tconst rulesArray = Array.isArray(syntaxRules) ? syntaxRules : [syntaxRules];\r\n\t\tconst newDependencyTrail = new Set(assertionTrail.dependencies);\r\n\t\tconst cloneSchemaSet = (schemaSet) => new Set([...schemaSet].map((sch) => new Map(sch)));\r\n\t\tfor (const [i, rule] of rulesArray.entries()) {\r\n\t\t\tif (rule.dialect && rule.dialect !== dialect) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tconst {\r\n\t\t\t\ttype,\r\n\t\t\t\tas: exposure,\r\n\t\t\t\tif: inference = assertionTrail.inference,\r\n\t\t\t\tvalue,\r\n\t\t\t\tarity,\r\n\t\t\t\tmodifier,\r\n\t\t\t\tbooleanfy,\r\n\t\t\t\toptional = assertionTrail.optional,\r\n\t\t\t\tassert = assertionTrail.assert,\r\n\t\t\t\tsyntax,\r\n\t\t\t\tsyntaxes,\r\n\t\t\t\t...rest\r\n\t\t\t} = rule;\r\n\t\t\tconst activeTrail = trail.concat(`${Array.isArray(syntaxRules) ? i : ''}${exposure ? `<${exposure}>` : ''}` || []);\r\n\t\t\tconst activeTrailStr = activeTrail.join('.');\r\n\t\t\tconst unsupportedAttrs = _getUnsupportedRuleAttrs(rest);\r\n\t\t\tif (unsupportedAttrs.length) {\r\n\t\t\t\tthrow new Error(`[${activeTrailStr}] Unsupported attributes in rule: \"${unsupportedAttrs.join('\", \"')}\".`);\r\n\t\t\t}\r\n\t\t\tconst isTokenRule = typeof type === 'string' && type[0] === type[0].toLowerCase();\r\n\t\t\tif (exposure) {\r\n\t\t\t\t// 1. Validate rule\r\n\t\t\t\tif (!type) throw new Error(`[${activeTrailStr}] Field rules must have a \"type\" attribute of type string.`);\r\n\t\t\t\tif (syntax || syntaxes) throw new Error(`[${activeTrailStr}] Field rules (\"${exposure}\") can not have a \"syntax\" or \"syntaxes\" attribute.`);\r\n\t\t\t\tif (exposure === '.') {\r\n\t\t\t\t\tif (!isTokenRule) throw new Error(`[${activeTrailStr}] Terminal Node rules must be token-typed rules.`);\r\n\t\t\t\t\tif (optional) throw new Error(`[${activeTrailStr}] Terminal Node rules can not be optional.`);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (modifier) throw new Error(`[${activeTrailStr}] Only Terminal Node rules can have a \"modifier\" attribute.`);\r\n\t\t\t\t}\r\n\t\t\t\tif (isTokenRule) {\r\n\t\t\t\t\tif (![undefined, null].includes(arity)) throw new Error(`[${activeTrailStr}] Token rules can not be item-based.`);\r\n\t\t\t\t\tif (!TOK_TYPES[type]) throw new Error(`[${activeTrailStr}] Unknown token type \"${type}\".`);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (value) throw new Error(`[${activeTrailStr}] Only token rules can have a \"value\" attribute.`);\r\n\t\t\t\t\tfor (const t of [].concat(type)) {\r\n\t\t\t\t\t\tif (!registry[t]) throw new Error(`[${activeTrailStr}] Unknown node type \"${t}\".`);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (![undefined, null].includes(arity)) {\r\n\t\t\t\t\t\tif (_isObject(arity)) {\r\n\t\t\t\t\t\t\tconst keys = Object.keys(arity);\r\n\t\t\t\t\t\t\tif (keys.some((k) => !['min', 'max', 'eager'].includes(k) || (typeof arity[k] !== (k === 'eager' ? 'boolean' : 'number')))) {\r\n\t\t\t\t\t\t\t\tthrow new Error(`Invalid arity object \"{ ${keys.join(', ')} }\" for field \"${exposure}\". Only \"min: <number>\", \"max: <number>\" and \"eager: <bool>\" expected.`);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else if ([].concat(arity).some((a) => typeof a !== 'number')) {\r\n\t\t\t\t\t\t\tthrow new Error(`[${activeTrailStr}] Invalid arity value \"${[].concat(arity).join(', ')}\" for field \"${exposure}\". Number(s) expected.`);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// 2. Compose schema\r\n\t\t\t\tconst fieldSchema = { rulePath: activeTrailStr, type };\r\n\t\t\t\tif (value) fieldSchema.value = value;\r\n\t\t\t\tif (modifier) fieldSchema.modifier = modifier;\r\n\t\t\t\tif (booleanfy) fieldSchema.booleanfy = booleanfy;\r\n\t\t\t\tif (![undefined, null].includes(arity)) fieldSchema.arity = arity;\r\n\t\t\t\tif (optional) fieldSchema.optional = true;\r\n\t\t\t\tif (assert) fieldSchema.assert = assert;\r\n\t\t\t\tif (inference) fieldSchema.if = inference;\r\n\t\t\t\tif (optional && assertionTrail.dependencies.size) {\r\n\t\t\t\t\tfieldSchema.dependencies = Array.from(assertionTrail.dependencies);\r\n\t\t\t\t}\r\n\t\t\t\t// 3. Expose\r\n\t\t\t\t// Earlier rules have populated schemas\r\n\t\t\t\tfor (const schema of schemaSet) {\r\n\t\t\t\t\tschema.set(exposure, fieldSchema);\r\n\t\t\t\t}\r\n\t\t\t\tif (exposure !== '.' && optional && !rule.optional) {\r\n\t\t\t\t\t// Optional context but rule NOT optional within context\r\n\t\t\t\t\tnewDependencyTrail.add(exposure);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (syntax || syntaxes) {\r\n\t\t\t\tconst newAssertionTrail = {\r\n\t\t\t\t\tdependencies: newDependencyTrail,\r\n\t\t\t\t\toptional,\r\n\t\t\t\t\tassert,\r\n\t\t\t\t\tinference,\r\n\t\t\t\t};\r\n\t\t\t\tif (syntax) {\r\n\t\t\t\t\tschemaSet = this._compileASTSchemaFromSyntaxRules(syntax, dialect, { trail: activeTrail.concat('syntax'), schemaSet, assertionTrail: newAssertionTrail });\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tconst newSchemaSet = new Set;\r\n\t\t\t\tfor (const [j, syntax] of syntaxes.entries()) {\r\n\t\t\t\t\tconst schemaSetClone = cloneSchemaSet(schemaSet);\r\n\t\t\t\t\tconst schemaSetCloneResult = this._compileASTSchemaFromSyntaxRules(syntax, dialect, { trail: activeTrail.concat('syntaxes', j), schemaSet: schemaSetClone, assertionTrail: newAssertionTrail });\r\n\t\t\t\t\tfor (const resultSchema of schemaSetCloneResult) {\r\n\t\t\t\t\t\tnewSchemaSet.add(resultSchema);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tschemaSet = newSchemaSet;\r\n\t\t\t}\r\n\t\t}\r\n\t\tconst schemasArray = Array.from(schemaSet);\r\n\t\tfor (let i = 0; i < schemasArray.length; i++) {\r\n\t\t\tconst schemaA = schemasArray[i];\r\n\t\t\tconst schemaAObj = Object.fromEntries(schemaA);\r\n\t\t\tif (!schemaA.size) {\r\n\t\t\t\tschemaSet.delete(schemaA);\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tfor (let j = i + 1; j < schemasArray.length; j++) {\r\n\t\t\t\tconst schemaB = schemasArray[j];\r\n\t\t\t\tconst schemaBObj = Object.fromEntries(schemaB);\r\n\t\t\t\tif (_eq(schemaAObj, schemaBObj, 'cs', 'rulePath')) {\r\n\t\t\t\t\tschemaSet.delete(schemaB);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn schemaSet;\r\n\t}\r\n\r\n\tstatic fromJSON(inputJson, options = {}, callback = null) {\r\n\t\t// This runs first: giving \"Expr\" - a polymorphic interface to run\r\n\t\tconst astSchema = this.compileASTSchemaFromSyntaxRules(options);\r\n\t\t// 1. Handle polymorphic interfaces\r\n\t\tif (Array.isArray(astSchema.type)) {\r\n\t\t\tfor (const type of astSchema.type) {\r\n\t\t\t\tconst NodeClass = registry[type];\r\n\t\t\t\tconst result = NodeClass.fromJSON(inputJson, options, callback);\r\n\t\t\t\tif (result) return result;\r\n\t\t\t}\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t// ----------\r\n\t\t// Pre compilation...\r\n\t\t// ----------\r\n\t\t// 1. Handle pre-formed nodes\r\n\t\tif (inputJson instanceof AbstractNode) {\r\n\t\t\tif (inputJson instanceof this) return inputJson;\r\n\t\t\treturn; // API mismatch\r\n\t\t}\r\n\t\t// 2. Handle typed JSON objects\r\n\t\tif (!_isObject(inputJson)) return;\r\n\t\tlet hardCodedNodeName = null;\r\n\t\tif ('nodeName' in inputJson) {\r\n\t\t\tif (inputJson.nodeName !== this.NODE_NAME) {\r\n\t\t\t\treturn; // API mismatch\r\n\t\t\t}\r\n\t\t\t({ nodeName: hardCodedNodeName, ...inputJson } = inputJson);\r\n\t\t}\r\n\t\t// ----------\r\n\t\t// Compilation...\r\n\t\t// ----------\r\n\t\t// ...defs first\r\n\t\tlet lastAssertion;\r\n\t\tconst $decideThrow = (message, rulePath = null, assertsGrep = false) => {\r\n\t\t\tif (!hardCodedNodeName && options.assert !== true && !(options.assert instanceof RegExp && options.assert.test(activeTrailStr))) return;\r\n\t\t\tif (rulePath) {\r\n\t\t\t\tmessage = `[${rulePath}] ${message}`;\r\n\t\t\t}\r\n\t\t\tif (assertsGrep) {\r\n\t\t\t\tlastAssertion = message;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tthrow new Error(message);\r\n\t\t};\r\n\t\tconst matchTokenRule = (fieldSchema, fieldJson) => {\r\n\t\t\t// Match any predefined value list\r\n\t\t\tif (fieldSchema.value !== undefined) {\r\n\t\t\t\tconst expectedValue = fieldSchema.booleanfy ? [true, false] : fieldSchema.value;\r\n\t\t\t\treturn [].concat(expectedValue).includes(fieldJson.value);\r\n\t\t\t}\r\n\t\t\t// Match standard\r\n\t\t\treturn TOK_TYPES[fieldSchema.type].match?.(fieldJson, options) !== false;\r\n\t\t}\r\n\t\tconst resolveField = (fieldSchema, fieldValue) => {\r\n\t\t\tfor (const type of [].concat(fieldSchema.type)) {\r\n\t\t\t\tconst isTokenRule = typeof type === 'string' && type[0] === type[0].toLowerCase();\r\n\t\t\t\tif (isTokenRule) {\r\n\t\t\t\t\tif (matchTokenRule(fieldSchema, { value: fieldValue }) === true) return fieldValue;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tconst node = registry[type].fromJSON(fieldValue, options);\r\n\t\t\t\t\tif (node) return node;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\tconst acquireField = (resultAST, fieldName, fieldSchema, assertsGrep = false) => {\r\n\t\t\t// 1. Validate dependencies\r\n\t\t\tif (fieldSchema.dependencies?.length) {\r\n\t\t\t\tfor (const depField of fieldSchema.dependencies) {\r\n\t\t\t\t\tif (!(depField in resultAST)) {\r\n\t\t\t\t\t\t$decideThrow(`Missing dependency field \"${depField}\" required by \"${fieldName}\"`, fieldSchema.rulePath, assertsGrep);\r\n\t\t\t\t\t\treturn false; // API mismatch\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (fieldSchema.if && !_inferenceMatch(fieldSchema.if, resultAST, fieldSchema.rulePath)) {\r\n\t\t\t\treturn true; // Much like optional\r\n\t\t\t}\r\n\t\t\t// 2. Acquire entries\r\n\t\t\tif (![undefined, null].includes(fieldSchema.arity)) {\r\n\t\t\t\tif (inputJson[fieldName] === undefined) {\r\n\t\t\t\t\t// Undefined at all or empty\r\n\t\t\t\t\tif (fieldSchema.optional) {\r\n\t\t\t\t\t\tresultAST[fieldName] = []; // Optional empty array\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t$decideThrow(`Missing required field \"${fieldName}\"`, fieldSchema.rulePath, assertsGrep);\r\n\t\t\t\t\treturn false; // API mismatch\r\n\t\t\t\t}\r\n\t\t\t\tif (!Array.isArray(inputJson[fieldName])) {\r\n\t\t\t\t\t$decideThrow(`Field \"${fieldName}\" must be an array`, fieldSchema.rulePath, assertsGrep);\r\n\t\t\t\t\treturn false; // Defined but API mismatch\r\n\t\t\t\t}\r\n\t\t\t\tif (fieldSchema.arity !== Infinity) {\r\n\t\t\t\t\tconst count = inputJson[fieldName].length;\r\n\t\t\t\t\tif (_isObject(fieldSchema.arity)) {\r\n\t\t\t\t\t\tif ('min' in fieldSchema.arity && count < fieldSchema.arity.min) {\r\n\t\t\t\t\t\t\t$decideThrow(`A minimum of ${fieldSchema.arity.min} argument(s) expected but got ${count}`, fieldSchema.rulePath, assertsGrep);\r\n\t\t\t\t\t\t\treturn false; // API mismatch\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif ('max' in fieldSchema.arity && count > fieldSchema.arity.max) {\r\n\t\t\t\t\t\t\t$decideThrow(`A maximum of ${fieldSchema.arity.max} argument(s) expected but got ${count}`, fieldSchema.rulePath, assertsGrep);\r\n\t\t\t\t\t\t\treturn false; // API mismatch\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if (![].concat(fieldSchema.arity).includes(count)) {\r\n\t\t\t\t\t\t$decideThrow(`Exactly ${[].concat(fieldSchema.arity).join(' or ')} argument(s) expected but got ${count}`, fieldSchema.rulePath, assertsGrep);\r\n\t\t\t\t\t\treturn false; // API mismatch\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tconst resultArray = inputJson[fieldName].map((entry) => resolveField(fieldSchema, entry)).filter((n) => n !== undefined);\r\n\t\t\t\tconst resultLenth = resultArray.length;\r\n\t\t\t\t// Some items resolved and some didn't?: Raise integrity error\r\n\t\t\t\tif (inputJson[fieldName].length > resultLenth) {\r\n\t\t\t\t\t// If resolution failed for all items...\r\n\t\t\t\t\tif (!resultLenth) {\r\n\t\t\t\t\t\t$decideThrow(`Failed to resolve any argument for \"${fieldName}\"`, fieldSchema.rulePath, assertsGrep);\r\n\t\t\t\t\t\treturn false; // API mismatch\r\n\t\t\t\t\t}\r\n\t\t\t\t\t$decideThrow(`Inconsistent \"${fieldName}\" argument(s)`, fieldSchema.rulePath, assertsGrep);\r\n\t\t\t\t\treturn false; // API mismatch\r\n\t\t\t\t}\r\n\t\t\t\tresultAST[fieldName] = resultArray;\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\t// 3. Acquire classic field\r\n\t\t\tif (inputJson[fieldName] === undefined) {\r\n\t\t\t\tif (fieldSchema.optional) {\r\n\t\t\t\t\tresultAST[fieldName] = fieldSchema.booleanfy ? false : undefined; // Optional undefined\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t\t$decideThrow(`Missing required field \"${fieldName}\"`, fieldSchema.rulePath, assertsGrep);\r\n\t\t\t\treturn false; // API mismatch\r\n\t\t\t}\r\n\t\t\tconst result = resolveField(fieldSchema, inputJson[fieldName]);\r\n\t\t\tif (result === undefined) {\r\n\t\t\t\t$decideThrow(`Failed to resolve field \"${fieldName}\"`, fieldSchema.rulePath, assertsGrep);\r\n\t\t\t\treturn false; // API mismatch\r\n\t\t\t}\r\n\t\t\tresultAST[fieldName] = result;\r\n\t\t\treturn true;\r\n\t\t};\r\n\t\t// On to the AST composition based on first match\r\n\t\tpaths_loop: for (const $astSchema of (astSchema instanceof Map ? [astSchema] : astSchema)) {\r\n\t\t\tconst resultAST = Object.create(null);\r\n\t\t\tconst astSchema = new Map($astSchema);\r\n\t\t\tlet $inputJson = inputJson;\r\n\t\t\t// Acquire root AST fields\r\n\t\t\tif (astSchema.has('.')) {\r\n\t\t\t\tconst rootRule = astSchema.get('.');\r\n\t\t\t\tconst tokSchema = TOK_TYPES[rootRule.type];\r\n\t\t\t\t// Transfer relevant attributes from \"inputJson\" to \"resultAST\"\r\n\t\t\t\t// This effectively removes root-token-level attributes from \"inputJson\" before the next step below\r\n\t\t\t\tif ([undefined, null].includes($inputJson.value)) {\r\n\t\t\t\t\tcontinue paths_loop;\r\n\t\t\t\t}\r\n\t\t\t\t({ value: resultAST.value, ...$inputJson } = $inputJson);\r\n\t\t\t\tfor (const attr of Object.keys(tokSchema)) {\r\n\t\t\t\t\tif (typeof tokSchema[attr] === 'function') continue;\r\n\t\t\t\t\tif (attr in $inputJson) {\r\n\t\t\t\t\t\t({ [attr]: resultAST[attr], ...$inputJson } = $inputJson);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (matchTokenRule(rootRule, resultAST) === false) {\r\n\t\t\t\t\tcontinue paths_loop;\r\n\t\t\t\t}\r\n\t\t\t\tastSchema.delete('.');\r\n\t\t\t}\r\n\t\t\t// Acquire other AST fields\r\n\t\t\tfor (const fieldName of new Set(Object.keys($inputJson).concat(...astSchema.keys()))) {\r\n\t\t\t\t// Handle early mismatch\r\n\t\t\t\tif (!astSchema.has(fieldName)) {\r\n\t\t\t\t\tcontinue paths_loop; // To next schema; API mismatch\r\n\t\t\t\t}\r\n\t\t\t\tconst fieldSchema = astSchema.get(fieldName);\r\n\t\t\t\tif (acquireField(resultAST, fieldName, fieldSchema, true) === false) {\r\n\t\t\t\t\tcontinue paths_loop; // To next schema; API mismatch\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// Done here. First match!!!\r\n\t\t\tif (typeof callback === 'function') {\r\n\t\t\t\treturn callback(resultAST, options);\r\n\t\t\t}\r\n\t\t\treturn new this(resultAST, options);\r\n\t\t}\r\n\t\t$decideThrow(`Failed to match any schema${lastAssertion ? `. ${lastAssertion}` : ''}`, this.NODE_NAME);\r\n\t}\r\n\r\n\t// -----------\r\n\r\n\ttoJSON(indexHint = null, options = {}) { return this.jsonfy(options); }\r\n\r\n\tjsonfy(options = {}, transformCallback = null) {\r\n\t\tconst jsonfy = (value, key) => {\r\n\t\t\tconst originalValue = value;\r\n\t\t\tif (transformCallback) {\r\n\t\t\t\tvalue = transformCallback(value, key, options);\r\n\t\t\t}\r\n\t\t\tif (value instanceof AbstractNode) {\r\n\t\t\t\tvalue = value.jsonfy(options, transformCallback);\r\n\t\t\t} else if (Array.isArray(originalValue) && Array.isArray(value) && value.every((n) => n instanceof AbstractNode)) {\r\n\t\t\t\tvalue = value.reduce((entries, value, i) => {\r\n\t\t\t\t\tconst result = jsonfy(value, i);\r\n\t\t\t\t\tif (result === undefined) return entries;\r\n\t\t\t\t\treturn entries.concat(result);\r\n\t\t\t\t}, []);\r\n\t\t\t}\r\n\t\t\treturn value;\r\n\t\t};\r\n\t\treturn {\r\n\t\t\t...(options.nodeNames !== false ? { nodeName: this.NODE_NAME } : {}),\r\n\t\t\t...Object.fromEntries(Object.entries(this.#ast).map(([fieldName, value]) => {\r\n\t\t\t\treturn [fieldName, jsonfy(value, fieldName)];\r\n\t\t\t})),\r\n\t\t};\r\n\t}\r\n\r\n\t/**\r\n\t * -----------\r\n\t * PARSER API\r\n\t * -----------\r\n\t */\r\n\r\n\tstatic async parse(input, { left, minPrecedence = 0, trail = [], returningTokenStream = false, ...options } = {}) {\r\n\t\tconst tokenStream = !(input instanceof TokenStream)\r\n\t\t\t? await TokenStream.create(input, { structured: true, spaces: true, ...options })\r\n\t\t\t: input;\r\n\t\tconst savepoint = tokenStream.savepoint();\r\n\t\tif (!tokenStream.current() && !tokenStream.done) {\r\n\t\t\tawait tokenStream.next();\r\n\t\t}\r\n\t\tconst syntaxRules = this.syntaxRules;\r\n\t\t// 1. Resolve polymorphic interfaces\r\n\t\tlet result, rulesArray;\r\n\t\tif ((rulesArray = [].concat(syntaxRules)).length === 1 && Array.isArray(rulesArray[0].type) && !rulesArray[0].as) {\r\n\t\t\tif (rulesArray[0].expression) {\r\n\t\t\t\tresult = await this._parseAsExpression(tokenStream, rulesArray[0].type, { left, minPrecedence, trail: trail.concat(this.NODE_NAME), ...options });\r\n\t\t\t} else {\r\n\t\t\t\tresult = await this._parseFromTypes(tokenStream, rulesArray[0].type, { left, minPrecedence, trail: trail.concat(this.NODE_NAME), ...options });\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t// 2. Resolve full syntax rules\r\n\t\t\tconst resultAST = await this._parseFromRules(tokenStream, syntaxRules, { left, minPrecedence, trail: trail.concat(this.NODE_NAME), ...options });\r\n\t\t\tif (resultAST) {\r\n\t\t\t\tresult = new this(resultAST, { ...options, dialect: tokenStream.options.dialect });\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (!result) tokenStream.restore(savepoint);\r\n\t\tif (returningTokenStream) {\r\n\t\t\treturn { result, tokenStream };\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n\r\n\tstatic async _parseAsExpression(tokenStream, types, { left = null, minPrecedence, trail, ...options }) {\r\n\t\tif (left) throw new Error(`TODO`);\r\n\t\tleft = await this._parseFromTypes(tokenStream, types, { minPrecedence, trail, ...options });\r\n\t\twhile (left) {\r\n\t\t\t// Compose binary expressions (e.g., col + 2)\r\n\t\t\tconst operator = await tokenStream.match('operator');\r\n\t\t\tif (!operator || operator.prec < minPrecedence) break;\r\n\t\t\tconst prevLeft = left;\r\n\t\t\tconst newLeft = await this._parseFromTypes(tokenStream, types, {\r\n\t\t\t\tleft,\r\n\t\t\t\tminPrecedence,//: operator.prec + (operator.assoc === 'right' ? 0 : 1),\r\n\t\t\t\ttrail,\r\n\t\t\t\t...options\r\n\t\t\t});\r\n\t\t\tif (!newLeft) return left;\r\n\t\t\tleft = newLeft;\r\n\t\t}\r\n\t\treturn left;\r\n\t}\r\n\r\n\tstatic async _parseFromRules(tokenStream, syntaxRules, { left, minPrecedence, trail, ...options }, resultAST = {}) {\r\n\t\tconst rulesArray = Array.isArray(syntaxRules) ? syntaxRules : [syntaxRules];\r\n\t\tlet numSkippedRules_dialectWise = 0;\r\n\t\tlet newMinPrecedence = minPrecedence; // Default being 0\r\n\r\n\t\tfor (const [i, rule] of rulesArray.entries()) {\r\n\t\t\tif (rule.dialect && rule.dialect !== tokenStream.options.dialect) {\r\n\t\t\t\tnumSkippedRules_dialectWise++;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\t// -----\r\n\t\t\t// Rule destructuring...\r\n\t\t\t// -----\r\n\r\n\t\t\tconst {\r\n\t\t\t\trequiredSpacing,\r\n\t\t\t\tpeek,\r\n\t\t\t\ttype, // Usable in combination with \"syntax\", \"syntaxes\" for type === \"*_block\"\r\n\t\t\t\tvalue, // Token value matching\r\n\t\t\t\tsyntax, // Mutually-exclusive with \"syntaxes\" and \"type\" - except for type === \"*_block\"\r\n\t\t\t\tsyntaxes, // Mutually-exclusive with \"syntax\" and \"type\" - except for type === \"*_block\"\r\n\t\t\t\tas: exposure,\r\n\t\t\t\tif: inference,\r\n\t\t\t\tarity,\r\n\t\t\t\titemSeparator,\r\n\t\t\t\toptional = false,\r\n\t\t\t\tassert = false,\r\n\t\t\t\tbooleanfy,\r\n\t\t\t\t...rest\r\n\t\t\t} = rule;\r\n\r\n\t\t\tconst activeTrail = trail.concat(`${Array.isArray(syntaxRules) ? i : ''}${exposure ? `<${exposure}>` : ''}` || []);\r\n\t\t\tconst activeTrailStr = activeTrail.join('.');\r\n\t\t\tconst unsupportedAttrs = _getUnsupportedRuleAttrs(rest);\r\n\t\t\tif (unsupportedAttrs.length) {\r\n\t\t\t\tthrow new Error(`[${activeTrailStr}] Unsupported attributes in rule: \"${unsupportedAttrs.join('\", \"')}\".`);\r\n\t\t\t}\r\n\t\t\tconst isTokenRule = typeof type === 'string' && type[0] === type[0].toLowerCase();\r\n\r\n\t\t\t// -----\r\n\t\t\t// Definitions...\r\n\t\t\t// -----\r\n\t\t\tconst acquireLeft = async () => {\r\n\t\t\t\tif (!exposure || isTokenRule) return;\r\n\t\t\t\tif (rulesArray[i + 1]?.type !== 'operator') return; // Not necessary but for the purpose of failing faster\r\n\t\t\t\tif (Array.isArray(peek) && !await peekToken(-1)) return;\r\n\t\t\t\tfor (const name of [].concat(type)) {\r\n\t\t\t\t\tif (left instanceof registry[name]) {\r\n\t\t\t\t\t\tresultAST[exposure] = left;\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn false;\r\n\t\t\t};\r\n\t\t\tconst matchSpacing = () => {\r\n\t\t\t\tconst current = tokenStream.current();\r\n\t\t\t\treturn (\r\n\t\t\t\t\t(requiredSpacing === false && !current?.spaceBefore) ||\r\n\t\t\t\t\t(requiredSpacing === true && current?.spaceBefore) ||\r\n\t\t\t\t\t(requiredSpacing === '\\n' && /\\n/.test(current?.spaceBefore))\r\n\t\t\t\t);\r\n\t\t\t};\r\n\t\t\tconst peekToken = async (adjustBy = 0) => {\r\n\t\t\t\tif (adjustBy) return await tokenStream.match(...[peek[0] + adjustBy, ...peek.slice(1)]);\r\n\t\t\t\treturn await tokenStream.match/*NOTE: not peek()*/(...peek);\r\n\t\t\t};\r\n\t\t\tconst eatToken = async () => {\r\n\t\t\t\tlet op;\r\n\t\t\t\tif ((op = await tokenStream.match('operator')) && op.prec < minPrecedence) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tconst tok = await tokenStream.eat(type, type.endsWith('_block') ? undefined : value);\r\n\t\t\t\tif (tok?.type === 'operator') {\r\n\t\t\t\t\tnewMinPrecedence = tok.prec + (tok.assoc === 'right' ? 0 : 1);\r\n\t\t\t\t}\r\n\t\t\t\treturn tok;\r\n\t\t\t};\r\n\t\t\tconst parseNode = async (activeTokenStream, newMinPrecedence) => {\r\n\t\t\t\tif (Array.isArray(type)) {\r\n\t\t\t\t\treturn await this._parseFromTypes(activeTokenStream, type, { minPrecedence: newMinPrecedence, trail: activeTrail, ...options });\r\n\t\t\t\t}\r\n\t\t\t\tconst NodeClass = registry[type];\r\n\t\t\t\tif (!NodeClass) throw new Error(`[${activeTrailStr}] Unknown node type <${type}>.`);\r\n\t\t\t\treturn await NodeClass.parse(activeTokenStream, { minPrecedence: newMinPrecedence, trail: activeTrail, ...options });\r\n\t\t\t};\r\n\t\t\tconst $decideThrow = (activeTokenStream, message, tokenStreamPosition = false) => {\r\n\t\t\t\tif (!assert && options.assert !== true && !(options.assert instanceof RegExp && options.assert.test(activeTrailStr))) return;\r\n\t\t\t\tif (tokenStreamPosition) {\r\n\t\t\t\t\tconst current = activeTokenStream.current() || activeTokenStream.previous();\r\n\t\t\t\t\tconst proximityTerm = activeTokenStream.current() ? (tokenStreamPosition === 1 ? ':' : ' near') : ' by';\r\n\t\t\t\t\tmessage += !current ? `${proximityTerm} end of stream` : `${proximityTerm}${typeof current.value === 'string' ? ` \"${current.value}\" (${current.type})` : ''} at <line ${current.line}, column ${current.column}>`;\r\n\t\t\t\t}\r\n\t\t\t\tthrow new Error(`[${activeTrailStr}] ${message}.`);\r\n\t\t\t};\r\n\r\n\t\t\t// -----\r\n\t\t\t// Validation...\r\n\t\t\t// -----\r\n\r\n\t\t\tif (left && type) {\r\n\t\t\t\tif (!await acquireLeft()) return;\r\n\t\t\t\tleft = null;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\t// 2. Exit on any of the following...\r\n\t\t\t// Exit if a certain prop isn't in AST\r\n\t\t\tif (inference && !_inferenceMatch(inference, resultAST, activeTrailStr)) {\r\n\t\t\t\tcontinue; // Much like optional\r\n\t\t\t}\r\n\t\t\t// Exit if spacing doesn't match\r\n\t\t\tif (requiredSpacing !== undefined && !matchSpacing()) {\r\n\t\t\t\t$decideThrow(tokenStream, 'Required spacing mismatch', true);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\t// Exit if look-ahead fails\r\n\t\t\tif (Array.isArray(peek) && !await peekToken()) {\r\n\t\t\t\t$decideThrow(tokenStream, 'Peek failure', true);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// -----\r\n\t\t\t// Parsing...\r\n\t\t\t// -----\r\n\r\n\t\t\t// 1. Terminal node rules...\r\n\t\t\tif (exposure === '.') {\r\n\t\t\t\tif (!type || !isTokenRule) throw new Error(`[${activeTrailStr}] Terminal node rules must be token-typed rules.`);\r\n\t\t\t\tconst tok = await eatToken();\r\n\t\t\t\tif (!tok) {\r\n\t\t\t\t\t$decideThrow(tokenStream, `Token of type \"${type}\"${value ? ` and value \"${value}\"` : ''} expected but got \"${tokenStream.current()?.type}\"`, true);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tlet _type, line, column, spaceBefore, prec, assoc, rest;\r\n\t\t\t\t({ type: _type, line, column, spaceBefore, prec, assoc, ...rest } = tok);\r\n\t\t\t\tObject.assign(resultAST, rest);\r\n\t\t\t\tcontinue; // To next rule\r\n\t\t\t}\r\n\r\n\t\t\t// 2. Block rules... Unwrapped for the next set of evaluation...\r\n\t\t\tlet activeTokenStream = tokenStream;\r\n\t\t\tif (typeof type === 'string' && type.endsWith('_block')) {\r\n\t\t\t\tif (!(activeTokenStream = (await eatToken())?.value)) {\r\n\t\t\t\t\tif (optional) {\r\n\t\t\t\t\t\tcontinue; // To next rule\r\n\t\t\t\t\t}\r\n\t\t\t\t\t$decideThrow(tokenStream, `Token of type \"${type}\" expected but got \"${tokenStream.current()?.type}\"`, true);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tnewMinPrecedence = 0; // IMPORTANT: minPrecedence don't apply to blocks\r\n\t\t\t\tif (!activeTokenStream.current() && !activeTokenStream.done) {\r\n\t\t\t\t\tawait activeTokenStream.next();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// 3. Variadic field rules...\r\n\t\t\tif (![undefined, null].includes(arity)) {\r\n\t\t\t\tif (!exposure) throw new Error(`[${activeTrailStr}] Multi-argument field rules must have a \"as\" attribute.`);\r\n\t\t\t\tif (!type) throw new Error(`[${activeTrailStr}] Multi-argument field rules must have a \"type\" attribute.`);\r\n\t\t\t\tif (isTokenRule) throw new Error(`[${activeTrailStr}] Multi-argument field rules must be node-typed rules.`);\r\n\r\n\t\t\t\tlet entry, entries = [], itemMinPrecedence = newMinPrecedence;\r\n\t\t\t\tif (itemSeparator?.type === 'operator') {\r\n\t\t\t\t\t// Use the binding power of the itemSeparator\r\n\t\t\t\t\tconst relevantOperatorDef = itemSeparator.value && (\r\n\t\t\t\t\t\tactiveTokenStream.options.operators?.classic.get(itemSeparator.value) || activeTokenStream.options.operators?.compound.get(itemSeparator.value)\r\n\t\t\t\t\t);\r\n\t\t\t\t\tif (relevantOperatorDef?.prec) {\r\n\t\t\t\t\t\titemMinPrecedence = relevantOperatorDef?.prec + 1;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\twhile ((entry = await parseNode(activeTokenStream, itemMinPrecedence))) {\r\n\t\t\t\t\tentries.push(entry);\r\n\t\t\t\t\tif (_isObject(arity) && arity.eager === false && entries.length === arity.max) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (itemSeparator && !await activeTokenStream.eat(\r\n\t\t\t\t\t\titemSeparator.type,\r\n\t\t\t\t\t\titemSeparator.value\r\n\t\t\t\t\t)) break;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (arity !== Infinity) {\r\n\t\t\t\t\tconst count = entries.length;\r\n\t\t\t\t\tif (!count && optional) {\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tconst current = activeTokenStream.current();\r\n\t\t\t\t\tconst currentAsUnexpected = current ? `. Unexpected ${current.type}${typeof current.value === 'string' ? ` \"${current.value}\"` : ''}` : '';\r\n\t\t\t\t\tif (_isObject(arity)) {\r\n\t\t\t\t\t\tif ('min' in arity && count < arity.min) {\r\n\t\t\t\t\t\t\t$decideThrow(activeTokenStream, `A minimum of ${arity.min} argument(s) expected but got ${count}${currentAsUnexpected}`, true);\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif ('max' in arity && count > arity.max) {\r\n\t\t\t\t\t\t\t$decideThrow(activeTokenStream, `A maximum of ${arity.max} argument(s) expected but got ${count}${currentAsUnexpected}`, true);\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if (![].concat(arity).includes(count)) {\r\n\t\t\t\t\t\t$decideThrow(activeTokenStream, `Exactly ${[].concat(arity).join(' or ')} argument(s) expected but got ${count}${currentAsUnexpected}`, true);\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tresultAST[exposure] = entries;\r\n\t\t\t\tcontinue; // To next rule\r\n\t\t\t}\r\n\r\n\t\t\t// 4. Classic rules...\r\n\t\t\tlet result;\r\n\t\t\tif (syntax) {\r\n\t\t\t\tconst savepoint = activeTokenStream.savepoint();\r\n\t\t\t\tresult = await this._parseFromRules(activeTokenStream, syntax, { left, minPrecedence: newMinPrecedence, trail: activeTrail.concat('syntax'), ...options });\r\n\t\t\t\tif (result === undefined) {\r\n\t\t\t\t\tactiveTokenStream.restore(savepoint);\r\n\t\t\t\t} else if (left) {\r\n\t\t\t\t\tleft = null;\r\n\t\t\t\t}\r\n\t\t\t} else if (syntaxes) {\r\n\t\t\t\tfor (const [j, syntax] of syntaxes.entries()) {\r\n\t\t\t\t\tconst savepoint = activeTokenStream.savepoint();\r\n\t\t\t\t\tresult = await this._parseFromRules(activeTokenStream, syntax, { left, minPrecedence: newMinPrecedence, trail: activeTrail.concat('syntaxes', j), ...options });\r\n\t\t\t\t\tif (result === undefined) {\r\n\t\t\t\t\t\tactiveTokenStream.restore(savepoint);\r\n\t\t\t\t\t} else break;\r\n\t\t\t\t}\r\n\t\t\t\tif (result !== undefined && left) {\r\n\t\t\t\t\tleft = null;\r\n\t\t\t\t}\r\n\t\t\t} else if (!(typeof type === 'string' && type.endsWith('_block'))) {\r\n\t\t\t\tresult = isTokenRule\r\n\t\t\t\t\t? (await eatToken())?.value\r\n\t\t\t\t\t: await parseNode(activeTokenStream, newMinPrecedence);\r\n\t\t\t} else if (!type) {\r\n\t\t\t\tthrow new Error(`[${activeTrailStr}] Rules must have a \"type\", \"syntax\" or \"syntaxes\" attribute.`);\r\n\t\t\t}\r\n\r\n\t\t\tif (result === undefined && !optional) {\r\n\t\t\t\t$decideThrow(activeTokenStream, type ? 'Unexpected token' : null, 1);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif (exposure) {\r\n\t\t\t\tif (booleanfy) {\r\n\t\t\t\t\tresult = result !== undefined;\r\n\t\t\t\t}\r\n\t\t\t\tresultAST[exposure] = result;\r\n\t\t\t} else if (syntax || syntaxes) {\r\n\t\t\t\tObject.assign(resultAST, result);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (numSkippedRules_dialectWise === rulesArray.length) {\r\n\t\t\t// IMPORTANT: Hard-exit to prevent returning a false positive, empty, resultAST\r\n\t\t\treturn;\r\n\t\t}\r\n\t\treturn resultAST;\r\n\t}\r\n\r\n\tstatic async _parseFromTypes(tokenStream, types, { left, minPrecedence, trail, ...options }) {\r\n\t\tfor (const type of types) {\r\n\t\t\tconst isTokenRule = typeof type === 'string' && type[0] === type[0].toLowerCase();\r\n\r\n\t\t\tif (isTokenRule) {\r\n\t\t\t\tif (await tokenStream.match(type)) {\r\n\t\t\t\t\treturn await tokenStream.eat();\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tconst NodeClass = registry[type];\r\n\t\t\t\tif (!NodeClass) throw new Error(`[${this.NODE_NAME}] Unknown node type \"${type}\".`);\r\n\t\t\t\tconst result = await NodeClass.parse(tokenStream, { left, minPrecedence, trail, ...options });\r\n\t\t\t\tif (result !== undefined) return result;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// -----------\r\n\r\n\ttoString() { return this.stringify(); }\r\n\r\n\tstringify(options = {}) {\r\n\t\t// Main\r\n\t\tconst rendering = this._stringifyFromRules(this.constructor.syntaxRules, { trail: [this.NODE_NAME], ...options });\r\n\t\treturn rendering;\r\n\t}\r\n\r\n\t_stringifyFromRules(syntaxRules, { trail = [], startingIndentLevel = 0, autoLineBreakThreshold = 100, ...options }, renderingStats = null) {\r\n\t\t// Formatters\r\n\t\tconst $space = () => ' ';\r\n\t\tconst $lineBreak = (indentLevel) => {\r\n\t\t\treturn `\\n${(\r\n\t\t\t\toptions.tabSpaces === 4 ? '\\t' : ' '.repeat(options.tabSpaces || 2)\r\n\t\t\t).repeat(indentLevel)}`;\r\n\t\t};\r\n\r\n\t\tconst resultTokens = [];\r\n\t\tconst rulesArray = [].concat(syntaxRules);\r\n\t\tlet numSkippedRules_optionalWise = 0;\r\n\r\n\t\tfor (const [i, rule] of rulesArray.entries()) {\r\n\t\t\tif (rule.dialect && rule.dialect !== this.options.dialect) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\t// -----\r\n\t\t\t// Rule destructuring...\r\n\t\t\t// -----\r\n\r\n\t\t\tconst {\r\n\t\t\t\trequiredSpacing,\r\n\t\t\t\ttype,\r\n\t\t\t\tvalue,\r\n\t\t\t\tbooleanfy,\r\n\t\t\t\tsyntax,\r\n\t\t\t\tsyntaxes,\r\n\t\t\t\tas: exposure,\r\n\t\t\t\tif: inference,\r\n\t\t\t\tarity,\r\n\t\t\t\titemSeparator,\r\n\t\t\t\toptional = false,\r\n\t\t\t\tautoSpacing = requiredSpacing,\r\n\t\t\t\toptionalParens,\r\n\t\t\t\tautoIndent = false,\r\n\t\t\t\tautoIndentAdjust = 0,\r\n\t\t\t} = rule;\r\n\r\n\t\t\tconst activeTrail = trail.concat(`${Array.isArray(syntaxRules) ? i : ''}${exposure ? `<${exposure}>` : ''}` || []);\r\n\t\t\tconst activeTrailStr = activeTrail.join('.');\r\n\t\t\tlet $autoIndent = autoIndent;\r\n\r\n\t\t\tif (inference && !_inferenceMatch(inference, this.#ast, this.NODE_NAME)) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tconst activeOptions = { startingIndentLevel: startingIndentLevel + (autoIndent ? 1 : 0) + autoIndentAdjust, autoLineBreakThreshold, ...options };\r\n\r\n\t\t\tlet rendering;\r\n\t\t\tif (![undefined, null].includes(arity)) {\r\n\t\t\t\tlet shouldRender = false; // Until we match items to syntax's arity\r\n\t\t\t\tconst entries = this._get(exposure);\r\n\t\t\t\tif (entries) {\r\n\t\t\t\t\tif (!(shouldRender = arity === Infinity)) {\r\n\t\t\t\t\t\tconst count = entries.length;\r\n\t\t\t\t\t\tif (_isObject(arity)) {\r\n\t\t\t\t\t\t\tshouldRender = (!('min' in arity) || count >= arity.min)\r\n\t\t\t\t\t\t\t\t&& (!('max' in arity) || count <= arity.max);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tshouldRender = [].concat(arity).includes(count)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (shouldRender) {\r\n\t\t\t\t\tconst itemsRendering = entries.map((entry) => entry.stringify(activeOptions));\r\n\t\t\t\t\t$autoIndent = autoIndent === true\r\n\t\t\t\t\t\t|| (typeof autoIndent === 'number' && entries.length >= autoIndent)\r\n\t\t\t\t\t\t|| autoSpacing === '\\n';\r\n\t\t\t\t\t// Determine item spacing...\r\n\t\t\t\t\tconst $autoItemSpacing = activeOptions.prettyPrint && $autoIndent && itemsRendering.join(' ').length > autoLineBreakThreshold\r\n\t\t\t\t\t\t? $lineBreak(activeOptions.startingIndentLevel)\r\n\t\t\t\t\t\t: $space();\r\n\t\t\t\t\t// Compose separator\r\n\t\t\t\t\tlet $itemSeparator = itemSeparator ? this._stringifyTerminal(itemSeparator, activeOptions) : '';\r\n\t\t\t\t\tif (/^\\w+$/.test($itemSeparator)) {\r\n\t\t\t\t\t\t$itemSeparator = `${$autoItemSpacing}${$itemSeparator}${$autoItemSpacing}`;\r\n\t\t\t\t\t} else if ($itemSeparator === ';' && activeOptions.prettyPrint) {\r\n\t\t\t\t\t\t$itemSeparator = `${$itemSeparator}\\n${$autoItemSpacing}`;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t$itemSeparator = `${$itemSeparator}${$autoItemSpacing}`;\r\n\t\t\t\t\t}\r\n\t\t\t\t\trendering = itemsRendering.join($itemSeparator);\r\n\t\t\t\t}\r\n\t\t\t} else if (syntax) {\r\n\t\t\t\trendering = this._stringifyFromRules(syntax, { trail: activeTrail.concat('syntax'), ...activeOptions }, renderingStats);\r\n\t\t\t} else if (syntaxes) {\r\n\t\t\t\tlet highestRenderingScore = -1;\r\n\t\t\t\tfor (const [j, syntax] of syntaxes.entries()) {\r\n\t\t\t\t\tconst newRenderingStats = { score: 0 };\r\n\t\t\t\t\tconst $rendering = this._stringifyFromRules(syntax, { trail: activeTrail.concat('syntaxes', j), ...activeOptions }, newRenderingStats);\r\n\t\t\t\t\tif (typeof $rendering === 'string' && newRenderingStats.score > highestRenderingScore) {\r\n\t\t\t\t\t\trendering = $rendering;\r\n\t\t\t\t\t\thighestRenderingScore = newRenderingStats.score;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (renderingStats) { renderingStats.score += highestRenderingScore; }\r\n\t\t\t} else {\r\n\t\t\t\tif (exposure) {\r\n\t\t\t\t\tlet fieldValue = this._get(exposure === '.' ? 'value' : exposure);\r\n\t\t\t\t\tconst hasExpectedValue = value !== undefined && value !== null;\r\n\t\t\t\t\tif (hasExpectedValue && booleanfy) {\r\n\t\t\t\t\t\tif (fieldValue === true) {\r\n\t\t\t\t\t\t\tfieldValue = value;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (hasExpectedValue) {\r\n\t\t\t\t\t\tif ([].concat(value).includes(fieldValue)) {\r\n\t\t\t\t\t\t\tif (renderingStats) {\r\n\t\t\t\t\t\t\t\trenderingStats.score++;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tfieldValue = undefined;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (fieldValue !== undefined) {\r\n\t\t\t\t\t\tif (fieldValue instanceof AbstractNode) {\r\n\t\t\t\t\t\t\tfieldValue = fieldValue.stringify(activeOptions);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tconst $rule = exposure === '.'\r\n\t\t\t\t\t\t\t? { ...rule, ...this.#ast }\r\n\t\t\t\t\t\t\t: { ...rule, value: fieldValue };\r\n\t\t\t\t\t\trendering = this._stringifyTerminal($rule, activeOptions);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\t\t\t\t\trendering = this._stringifyTerminal(rule, activeOptions);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// -----\r\n\r\n\t\t\tif (type === 'paren_block' && optionalParens) {\r\n\t\t\t\tif (!rendering?.trim()) {\r\n\t\t\t\t\tif (optionalParens === true || options.pruneOptionalParens) {\r\n\t\t\t\t\t\tif (renderingStats) {\r\n\t\t\t\t\t\t\trenderingStats.score++;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tnumSkippedRules_optionalWise++;\r\n\t\t\t\t\t\tcontinue; // Skip this rule\r\n\t\t\t\t\t}\r\n\t\t\t\t\trendering = '';\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (rendering === undefined) {\r\n\t\t\t\tif (optional) {\r\n\t\t\t\t\tnumSkippedRules_optionalWise++;\r\n\t\t\t\t\tcontinue; // Skip this rule\r\n\t\t\t\t}\r\n\t\t\t\treturn; // Exit whole rule sequence\r\n\t\t\t}\r\n\t\t\tif (exposure && renderingStats) {\r\n\t\t\t\trenderingStats.score++;\r\n\t\t\t}\r\n\r\n\t\t\t// Add \"block\" tags?\r\n\t\t\tlet autoSpaceIgnore = false;\r\n\t\t\tif (typeof type === 'string' && type.endsWith('_block')) {\r\n\t\t\t\tconst blockAutoLineBreakMode = activeOptions.prettyPrint && autoIndent && rendering/* *_block rendering */.length > autoLineBreakThreshold;\r\n\t\t\t\tconst delims = { brace_block: '{}', bracket_block: '[]', paren_block: '()' }[type];\r\n\r\n\t\t\t\trendering = [\r\n\t\t\t\t\tdelims[0],\r\n\t\t\t\t\tblockAutoLineBreakMode && !/^\\s/.test(rendering) ? $lineBreak(startingIndentLevel + 1) : (delims[0] === '{' ? $space() : ''),\r\n\t\t\t\t\trendering,\r\n\t\t\t\t\tblockAutoLineBreakMode ? $lineBreak(startingIndentLevel) : (delims[1] === '}' ? $space() : ''),\r\n\t\t\t\t\tdelims[1],\r\n\t\t\t\t].join('');\r\n\t\t\t} else if (activeOptions.prettyPrint && $autoIndent && rendering !== '') {\r\n\r\n\t\t\t\trendering = [\r\n\t\t\t\t\t$lineBreak(startingIndentLevel + (autoSpacing === '\\n' ? 0 : 1)),\r\n\t\t\t\t\trendering,\r\n\t\t\t\t].join('');\r\n\r\n\t\t\t\tautoSpaceIgnore = true;\r\n\t\t\t}\r\n\t\t\t// Space this chunk?\r\n\t\t\tconst precedingTok = resultTokens[resultTokens.length - 1];\r\n\t\t\tif (rendering !== ''\r\n\t\t\t\t&& !autoSpaceIgnore\r\n\t\t\t\t&& resultTokens.length\r\n\t\t\t\t// \"Do\" autoSpacing didnt already end with a space character\r\n\t\t\t\t&& !/\\s$/.test(precedingTok)\r\n\t\t\t\t// \"Force\" autoSpacing if previous token ends as alphanumeric and new token (rendering) starts as alphanumeric\r\n\t\t\t\t&& (Array.isArray(autoSpacing) ? autoSpacing.includes(precedingTok) : autoSpacing !== false)) {\r\n\t\t\t\tif (autoSpacing === '\\n' && activeOptions.prettyPrint) {\r\n\t\t\t\t\tresultTokens.push($lineBreak(startingIndentLevel));\r\n\t\t\t\t} else {\r\n\t\t\t\t\tresultTokens.push($space());\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tresultTokens.push(rendering);\r\n\t\t}\r\n\t\tif (resultTokens.length || numSkippedRules_optionalWise === rulesArray.length) {\r\n\t\t\treturn resultTokens.join('');\r\n\t\t}\r\n\t}\r\n\r\n\t_stringifyTerminal(tok, options = {}) {\r\n\t\tswitch (tok.type) {\r\n\t\t\tcase 'data_type': return this._stringifyDataType(tok, options);\r\n\t\t\tcase 'identifier': return this._stringifyIdentifier(tok, options);\r\n\t\t\tcase 'keyword': return this._stringifyKeyword(tok, options);\r\n\t\t\tcase 'operator': return this._stringifyOperator(tok, options);\r\n\t\t\tcase 'punctuation': return this._stringifyPunctuation(tok, options);\r\n\t\t\tcase 'bind_var': return this._stringifyBindVar(tok, options);\r\n\t\t\tcase 'version_spec': return `@${tok.value}`;\r\n\t\t}\r\n\t\tif (!Array.isArray(tok.type)) {\r\n\t\t\tif (tok.type.endsWith('_literal')) {\r\n\t\t\t\treturn this._stringifyLiteral(tok, options);\r\n\t\t\t}\r\n\t\t\tif (tok.type.endsWith('_var')) {\r\n\t\t\t\treturn this._stringifyVariable(tok, options);\r\n\t\t\t}\r\n\t\t\tif (tok.type.endsWith('_comment')) {\r\n\t\t\t\treturn this._stringifyComment(tok, options);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn String(tok.value);\r\n\t}\r\n\r\n\t_stringifyIdentifier(tok) {\r\n\t\tconst { value } = tok;\r\n\t\tconst delimChars = ['\"'];\r\n\t\t// ------------\r\n\t\t// Resolve from mysqlAnsiQuotes if mysql...\r\n\t\tif (this.options.dialect === 'mysql') {\r\n\t\t\tif (this.options.mysqlAnsiQuotes) {\r\n\t\t\t\tdelimChars.push('`'); // Backticks is ALSO identifier delim\r\n\t\t\t} else {\r\n\t\t\t\tdelimChars.fill('`'); // Backticks is ONLY identifier delim\r\n\t\t\t}\r\n\t\t}\r\n\t\t// Use tok-specified delim if valid\r\n\t\tconst delimChar = delimChars.includes(tok.delim)\r\n\t\t\t? tok.delim // Choose this one\r\n\t\t\t: delimChars[0];\r\n\t\t// ------------\r\n\t\tconst shouldQuote = /^\\d/.test(value) || !/^(\\*|[\\w]+)$/.test(value);\r\n\t\treturn shouldQuote\r\n\t\t\t? `${delimChar}${(value || '').replace(new RegExp(delimChar, 'g'), delimChar.repeat(2))}${delimChar}`\r\n\t\t\t: value;\r\n\t}\r\n\r\n\t_stringifyKeyword(tok) { return String(tok.value); }\r\n\r\n\t_stringifyOperator(tok) {\r\n\t\tif (tok.value === ':' && this.#contextNode?.isProperty) {\r\n\t\t\treturn '\\\\:';\r\n\t\t}\r\n\t\treturn String(tok.value);\r\n\t}\r\n\r\n\t_stringifyPunctuation(tok) { return String(tok.value); }\r\n\r\n\t_stringifyDataType(tok) { return String(tok.value); }\r\n\r\n\t_stringifyLiteral(tok, options) {\r\n\t\tconst { value } = tok;\r\n\t\t// ------------\r\n\t\tswitch (tok.type) {\r\n\t\t\tcase 'bit_literal': return this._stringifyBitLiteral(tok, options);\r\n\t\t\tcase 'hex_literal': return this._stringifyHexLiteral(tok, options);\r\n\t\t\tcase 'number_literal': return this._stringifyNumberLiteral(tok, options);\r\n\t\t\tcase 'string_literal': return this._stringifyStringLiteral(tok, options);\r\n\t\t\tcase 'bool_literal': return /^true$/i.test(value + '') ? 'TRUE' : 'FALSE';\r\n\t\t\tcase 'null_literal': return 'NULL';\r\n\t\t}\r\n\t\treturn String(value);\r\n\t}\r\n\r\n\t_stringifyBindVar(tok) {\r\n\t\tconst { value } = tok;\r\n\t\t// ------------\r\n\t\tif (this.options.dialect === 'mysql') {\r\n\t\t\treturn `?`;\r\n\t\t}\r\n\t\treturn `$${value}`;\r\n\t}\r\n\r\n\t_stringifyBitLiteral(tok) {\r\n\t\tconst { value } = tok;\r\n\t\t// ------------\r\n\t\tif (this.options.dialect === 'mysql') {\r\n\t\t\treturn `0b${value}`;\r\n\t\t}\r\n\t\treturn `B'${value}'`;\r\n\t}\r\n\r\n\t_stringifyHexLiteral(tok) {\r\n\t\tconst { value } = tok;\r\n\t\t// ------------\r\n\t\tif (this.options.dialect === 'mysql') {\r\n\t\t\treturn `0x${value}`;\r\n\t\t}\r\n\t\treturn `X'${value}'`;\r\n\t}\r\n\r\n\t_stringifyNumberLiteral(tok) {\r\n\t\tconst { value } = tok;\r\n\t\t// ------------\r\n\t\treturn String(value);\r\n\t}\r\n\r\n\t_stringifyStringLiteral(tok) {\r\n\t\tlet { value } = tok;\r\n\t\tconst delimChars = [\"'\"];\r\n\t\tlet escChar = null;\r\n\t\t// ------------\r\n\t\t// Resolve from dialect...\r\n\t\tif (this.options.dialect === 'postgres' && tok.delim?.startsWith('$')) {\r\n\t\t\tdelimChars.fill(tok.delim); // OVERRIDE\r\n\t\t} else if (this.options.dialect === 'mysql' && !this.options.mysqlAnsiQuotes) {\r\n\t\t\tdelimChars.push('\"'); // Double quotes is ALSO string delim\r\n\t\t}\r\n\t\t// Use tok-specified delim if valid\r\n\t\tconst delimChar = delimChars.includes(tok.delim)\r\n\t\t\t? tok.delim // Choose this one\r\n\t\t\t: delimChars[0];\r\n\t\t// Using backslash escaping?\r\n\t\tif (this.options.dialect === 'mysql' && !this.options.mysqlNoBackslashEscapes\r\n\t\t\t|| this.options.dialect === 'postgres' && tok.modifier === 'E') {\r\n\t\t\tescChar = '\\\\'; // In which case: the delim plus [\\\\\\0\\b\\r\\n\\t\\x1A] are backslashed/encoded\r\n\t\t}\r\n\t\t// ------------\r\n\t\t// Is Postgres dollar-quoted string?\r\n\t\tif (delimChar.length > 1) { // e.g. for $$string$$\r\n\t\t\treturn `${delimChar}${value}${delimChar}`;\r\n\t\t}\r\n\t\tif (!escChar) {\r\n\t\t\tescChar = delimChar;\r\n\t\t} else if (escChar === '\\\\') {\r\n\t\t\tconst defs = {\r\n\t\t\t\t'\\\\': '\\\\\\\\', // from backslash char itself\r\n\t\t\t\t'\\0': '\\\\0', // from NUL byte (ASCII 0)\r\n\t\t\t\t'\\b': '\\\\b', // from backspace (ASCII 8)\r\n\t\t\t\t'\\f': '\\\\f', // from form feed\r\n\t\t\t\t'\\n': '\\\\n', // from newline\r\n\t\t\t\t'\\r': '\\\\r', // from carriage return\r\n\t\t\t\t'\\t': '\\\\t', // from tab\r\n\t\t\t\t'\\v': '\\\\v', // from vertical tab\r\n\t\t\t\t'\\x1A': '\\\\Z' // from ASCII 26 (SUB / Control+Z) - as represented in JS\r\n\t\t\t};\r\n\t\t\tvalue = value.replace(/[\\\\\\0\\b\\r\\n\\t\\x1A]/g, (match) => defs[match]);\r\n\t\t}\r\n\t\tvalue = `${delimChar}${(value || '').replace(new RegExp(delimChar, 'g'), `${escChar}${delimChar}`)}${delimChar}`;\r\n\t\treturn tok.modifier\r\n\t\t\t? `${tok.modifier}${value}`\r\n\t\t\t: value;\r\n\t}\r\n\r\n\t_stringifyVariable(tok) {\r\n\t\tconst { type, value } = tok;\r\n\t\t// ------------\r\n\t\tif (this.options.dialect === 'mysql') {\r\n\t\t\treturn `${type === 'system_var' ? '@@' : '@'}${value}`;\r\n\t\t}\r\n\t\treturn `${this.#contextNode?.isProperty ? '\\\\:' : ':'}${value}`;\r\n\t}\r\n\r\n\t_stringifyComment(tok, options = {}) {\r\n\t\tconst { value } = tok;\r\n\t\t// ------------\r\n\t\tif (tok.type === 'block_comment') {\r\n\t\t\tconst indent = '  '.repeat(options.startingIndentLevel || 0);\r\n\t\t\tconst lines = value.trim().split('\\n').map((line) => line.trim());\r\n\t\t\tconst formatted = [\r\n\t\t\t\t`${indent}/**`,\r\n\t\t\t\t...lines.map((line) => `${indent} * ${line}`),\r\n\t\t\t\t`${indent} */`\r\n\t\t\t];\r\n\t\t\treturn formatted.join('\\n');\r\n\t\t}\r\n\t\t// ------------\r\n\t\tconst delimChars = ['--'];\r\n\t\tif (this.options.dialect === 'mysql') {\r\n\t\t\tdelimChars.push('#');\r\n\t\t}\r\n\t\tconst delimChar = delimChars.includes(tok.delim)\r\n\t\t\t? tok.delim\r\n\t\t\t: delimChars[0];\r\n\t\treturn `${delimChar} ${value}`;\r\n\t}\r\n}\r\n\r\nconst _getUnsupportedRuleAttrs = (rule) => {\r\n\treturn Object.keys(rule).filter((k) => !supportedRuleAttrs.has(k));\r\n};\r\nconst supportedRuleAttrs = new Set([\r\n\t'dialect',\r\n\t// 1. Pretty-printing\r\n\t'autoSpacing',\r\n\t'optionalParens',\r\n\t'autoIndent',\r\n\t'autoIndentAdjust',\r\n\t// 2. Type system: token and node\r\n\t'type',\r\n\t// 2.1 Token matching\r\n\t'value',\r\n\t'delim',\r\n\t'modifier',\r\n\t// 2.2 Compound matching\r\n\t'syntax',\r\n\t'syntaxes',\r\n\t// 3. AST fields\r\n\t'as',\r\n\t'booleanfy',\r\n\t'if',\r\n\t// 4. Variadic fields\r\n\t'arity',\r\n\t'itemSeparator',\r\n\t'keyed',\r\n\t// 5. Other attributes\r\n\t'requiredSpacing',\r\n\t'peek',\r\n\t'optional',\r\n\t'assert',\r\n]);\r\n\r\nconst _inferenceMatch = (inference, resultAST, activeTrailStr) => {\r\n\treturn [].concat(inference).some((criteria) => {\r\n\t\tif (_isObject(criteria)) {\r\n\t\t\treturn Object.entries(criteria).every(([key, value]) => {\r\n\t\t\t\tlet exp = true;\r\n\t\t\t\tif (key.startsWith('!')) {\r\n\t\t\t\t\tkey = key.slice(1);\r\n\t\t\t\t\texp = false;\r\n\t\t\t\t}\r\n\t\t\t\treturn (\r\n\t\t\t\t\tArray.isArray(value) ? value.includes(resultAST[key]) : resultAST[key] === value\r\n\t\t\t\t) === exp;\r\n\t\t\t});\r\n\t\t}\r\n\t\tif (typeof criteria !== 'string') throw new Error(`[${activeTrailStr}] A specifier of type string or object expected in inferenceMatch but got ${criteria === null ? 'null' : `type ${typeof criteria}`}`);\r\n\t\tlet exp = true;\r\n\t\tif (criteria.startsWith('!')) {\r\n\t\t\tcriteria = criteria.slice(1);\r\n\t\t\texp = false;\r\n\t\t}\r\n\t\treturn (![undefined, null, false].includes(resultAST[criteria])) === exp;\r\n\t});\r\n};", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class PGCycleClause extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return {\n            dialect: 'postgres',\n            syntax: [\n                { type: 'keyword', value: 'CYCLE' },\n                {\n                    assert: true,\n                    syntax: [\n                        { type: 'ColumnRef', as: 'column_names', arity: { min: 1 }, itemSeparator, assert: true, autoIndent: 2 },\n                        { type: 'keyword', value: 'SET' },\n                        { type: 'ColumnRef', as: 'mark_col_name' },\n                        {\n                            optional: true,\n                            syntax: [\n                                { type: 'keyword', value: 'TO' },\n                                { type: 'Expr', as: 'mark_value' },\n                                { type: 'keyword', value: 'DEFAULT' },\n                                { type: 'Expr', as: 'mark_default' },\n                            ]\n                        },\n                        { type: 'keyword', value: 'USING' },\n                        { type: 'ColumnRef', as: 'path_col_name' },\n                    ]\n                },\n            ]\n        };\n    }\n\n    /* AST API */\n\n    breadthOrDepthFirst() { return this._get('breadth_or_depth_first'); }\n\n    columnNames() { return this._get('column_names'); }\n\n    markColName() { return this._get('mark_col_name'); }\n\n    markValue() { return this._get('mark_value'); }\n\n    markDefault() { return this._get('mark_default'); }\n\n    pathColName() { return this._get('path_col_name'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class PGSearchClause extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return {\n            dialect: 'postgres',\n            syntax: [\n                { type: 'keyword', value: 'SEARCH' },\n                {\n                    assert: true,\n                    syntax: [\n                        { type: 'keyword', as: 'breadth_or_depth_first', value: ['BREADTH', 'DEPTH'] },\n                        { type: 'keyword', value: 'FIRST' },\n                        { type: 'keyword', value: 'BY' },\n                        { type: 'ColumnRef', as: 'column_names', arity: { min: 1 }, itemSeparator, assert: true, autoIndent: 2 },\n                        { type: 'keyword', value: 'SET' },\n                        { type: 'ColumnRef', as: 'seq_col_name' },\n                    ]\n                }\n            ]\n        };\n    }\n\n    /* AST API */\n\n    breadthOrDepthFirst() { return this._get('breadth_or_depth_first'); }\n\n    columnNames() { return this._get('column_names'); }\n\n    seqColName() { return this._get('seq_col_name'); }\n}", "import { AbstractNode } from './AbstractNode.js';\n\nexport class AbstractStmt extends AbstractNode {\n\n    #rand = 0;\n    _rand(key) {\n        return `${key}::${this.#rand++}`;\n        return `${key}::${(0 | Math.random() * 9e6).toString(36)}`;\n    }\n\n    #uuid;\n    get uuid() {\n        if (!this.#uuid) this.#uuid = this._rand('query');\n        return this.#uuid;\n    }\n\n    static fromJSON(inputJson, options = {}) {\n        const { uuid, ...restJson } = inputJson;\n        const node = super.fromJSON(restJson, options);\n        if (uuid && node) node.#uuid = uuid;\n        return node;\n    }\n\n    jsonfy(options = {}) {\n        const resultJson = super.jsonfy(options);\n        return { ...resultJson, uuid: this.#uuid };\n    }\n}", "//import { RootSchema } from \"../ddl/RootSchema.js\";\r\n//import { Binding } from \"../expr/Binding.js\";\r\n\r\nimport { AbstractStmt } from './AbstractStmt.js';\r\n\r\nexport class AbstractNonDDLStmt extends AbstractStmt {\r\n\r\n\t_capture(requestName, requestSource) {\r\n\t\tconst result = super._capture(requestName, requestSource);\r\n\t\tif (requestName === 'CONTEXT.ROOT_SCHEMA' && !result) {\r\n\t\t\treturn RootSchema.fromJSON(this, []);\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n\r\n\trenderBindings(values) {\r\n\t\tif (!Array.isArray(values)) throw new Error(`Values must be an array`);\r\n\t\tconst queryBindings = [...this.queryBindings()];\r\n\t\tfor (let i = 0; i < values.length; i++) {\r\n\t\t\tconst bindings = queryBindings.filter(b => b.offset() === i+1);\r\n\t\t\tif (!bindings.length) throw new Error(`No bindings exists at offset #${i}`);\r\n\t\t\tbindings.forEach(b => b.value(values[i]));\r\n\t\t}\r\n\t}\r\n\r\n\tnormalizeBindings(dedupe = false) {\r\n\t\tconst queryBindings = [...this.queryBindings()];\r\n\t\tif (!dedupe) {\r\n\t\t\tqueryBindings.forEach((b, i) => b.offset(i+1));\r\n\t\t\treturn queryBindings;\r\n\t\t}\r\n\t\tlet redundants = new Map, $offset = 1;\r\n\t\tfor (const b of queryBindings) {\r\n\t\t\tif (b.offset() === 0 || !redundants.has(b.offset())) {\r\n\t\t\t\tconst newOffset = $offset++;\r\n\t\t\t\tredundants.set(b.offset(), newOffset);\r\n\t\t\t\tb.offset(newOffset);\r\n\t\t\t} else b.offset(redundants.get(b.offset())).withDetail('redundant', true);\r\n\t\t}\r\n\t\treturn queryBindings.filter(b => !b.getDetail('redundant'));\r\n\t}\r\n}\r\n", "import { AbstractNonDDLStmt } from '../abstracts/AbstractNonDDLStmt.js';\n\nexport class CTE extends AbstractNonDDLStmt {\n\n    /* SYNTAX RULES */\n\n    static get _bodyTypes() {\n        return [\n            'SelectStmt',\n            'TableStmt',\n            'InsertStmt',\n            'UpsertStmt',\n            'UpdateStmt',\n            'DeleteStmt',\n            'ValuesConstructor',\n        ];\n    }\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'keyword', value: 'WITH' },\n            { type: 'keyword', as: 'recursive', value: 'RECURSIVE', booleanfy: true, optional: true },\n            { type: 'CTEBinding', as: 'bindings', arity: { min: 1 }, itemSeparator, assert: true, autoIndent: 2 },\n            { type: this._bodyTypes, as: 'body', assert: true, autoSpacing: '\\n' },\n        ];\n    }\n\n    /* AST API */\n\n    recursive() { return this._get('recursive'); }\n\n    bindings() { return this._get('bindings'); }\n\n    body() { return this._get('body'); }\n}", "import { AbstractNode } from '../abstracts/AbstractNode.js';\n\nexport class CTEBinding extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'CompositeAlias', as: 'alias', assert: true },\n            { type: 'keyword', value: 'AS' },\n            {\n                optional: true,\n                syntaxes: [\n                    [\n                        { type: 'operator', as: 'not_materialized_kw', value: 'NOT', booleanfy: true },\n                        { type: 'keyword', value: 'MATERIALIZED', assert: true },\n                    ],\n                    { type: 'keyword', as: 'materialized', value: 'MATERIALIZED', booleanfy: true },\n                ],\n            },\n            { type: ['SubqueryConstructor', 'ValuesSetConstructor'], as: 'expr' },\n            { type: 'PGSearchClause', as: 'search_clause', optional: true },\n            { type: 'PGCycleClause', as: 'cycle_clause', optional: true },\n        ];\n    }\n\n    /* AST API */\n\n    alias() { return this._get('alias'); }\n\n    notMaterializedKW() { return this._get('not_materialized_kw'); }\n\n    materialized() { return this._get('materialized'); }\n\n    expr() { return this._get('expr'); }\n\n    searchClause() { return this._get('search_clause'); }\n\n    cycleClause() { return this._get('cycle_clause'); }\n}", "export { CreateTableStmt } from './CreateTableStmt.js';", "import { registry } from '../registry.js';\n\nconst {\n    // Statement and clause nodes\n    CompleteSelectStmt,\n    SubqueryConstructor,\n    FromClause,\n    JoinClause,\n    OnClause,\n    GroupByClause,\n\n    // Table and field specification\n    FromElement,\n    SelectElement,\n\n    // Alias nodes\n    CompositeAlias,\n    BasicAlias,\n\n    // Computed/derived references\n    TableAbstractionRef,\n    ColumnRef,\n\n    // Expressions\n    BinaryExpr,\n\n    // Logical query references\n    LQDeepRef,\n    LQBackRef,\n    LQBackRefConstructor,\n} = registry;\n\nexport const SelectorStmtMixin = (Class) => class extends Class {\n\n    get isSelectorStmt() { return true; }\n\n    /* DESUGARING API */\n\n    jsonfy(options = {}, superTransformCallback = null) {\n        if (!options.deSugar) return super.jsonfy(options);\n\n        const selectorDimensions = new Map;\n        const transformCallback = (node, keyHint, { deSugar/* IMPORTANT */, ...$options }) => {\n            // Defer to super callback\n            if (superTransformCallback) {\n                node = superTransformCallback(node, keyHint, { deSugar/* IMPORTANT */, ...$options });\n            }\n            // LQDeepRef\n            if (deSugar && node instanceof LQDeepRef) {\n                const { select } = this.createSelectorDimension(node, selectorDimensions, $options);\n                return select(node.right());\n            }\n            // LQBackRef, LQBackRefConstructor\n            if (deSugar && (node instanceof LQBackRef || node instanceof LQBackRefConstructor)) {\n                if (node instanceof LQBackRefConstructor) {\n                    node = node.expr();\n                }\n                const { alias } = this.createSelectorDimension(node, selectorDimensions, $options);\n                return alias();\n            }\n            // Other\n            return node;\n        };\n\n        // Jsonfy with transformCallback as visitor\n        let resultJson = super.jsonfy(options, transformCallback);\n\n        // Apply selectorDimensions\n        if (selectorDimensions.size) {\n            resultJson = this.applySelectorDimensions(resultJson, selectorDimensions, options);\n        }\n        return resultJson;\n    }\n\n    createSelectorDimension(LQRef, selectorDimensions = null, { asAggr = false, ...$options } = {}) {\n        const { left, right, table } = LQRef.getOperands();\n        \n        const dimensionID = `dimension${asAggr ? '/g' : ''}::${[left, right, table].join('/')}`;\n        if (selectorDimensions?.has(dimensionID)) {\n            return selectorDimensions.get(dimensionID);\n        }\n\n        // Mask \"right\"\n        const rightMask = this._rand('rand');\n        const fieldSpec = {\n            nodeName: SelectElement.NODE_NAME,\n            expr: right.jsonfy($options),\n            alias: { nodeName: BasicAlias.NODE_NAME, value: rightMask },\n            as_kw: true,\n        };\n\n        // Compose:\n        // - LEFT JOIN ( SELECT [fieldSpec] FROM <table> [GROUP BY]? )\n        // - AS <dimensionID>\n        // - ON <dimensionID>.<rightMask> = <left>\n        const joinJson = {\n            nodeName: JoinClause.NODE_NAME,\n            join_type: 'LEFT',\n            expr: {\n                nodeName: SubqueryConstructor.NODE_NAME,\n                // SELECT <fieldSpec>\n                expr: {\n                    nodeName: CompleteSelectStmt.NODE_NAME,\n                    select_list: [fieldSpec],\n                    // FROM <table>\n                    from_clause: {\n                        nodeName: FromClause.NODE_NAME,\n                        entries: [{ nodeName: FromElement.NODE_NAME, expr: table.jsonfy($options) }]\n                    },\n                    // GROUP BY <rightMask>\n                    group_by_clause: asAggr ? {\n                        nodeName: GroupByClause.NODE_NAME,\n                        entries: [{ nodeName: ColumnRef.NODE_NAME, value: rightMask }]\n                    } : undefined,\n                }\n            },\n            // AS <dimensionID>\n            as_kw: true,\n            alias: { nodeName: CompositeAlias.NODE_NAME, value: dimensionID },\n            // ON <dimensionID>.<rightMask> = <left>\n            condition_clause: {\n                nodeName: OnClause.NODE_NAME,\n                expr: {\n                    nodeName: BinaryExpr.NODE_NAME,\n                    operator: '=',\n                    left: left.jsonfy($options),\n                    right: {\n                        nodeName: ColumnRef.NODE_NAME,\n                        qualifier: { nodeName: TableAbstractionRef.NODE_NAME, value: dimensionID },\n                        value: rightMask\n                    },\n                }\n            },\n        };\n\n        // Join ALias as Table ref...\n        const alias = () => ({ nodeName: TableAbstractionRef.NODE_NAME, value: dimensionID });\n\n        // Add entry...\n        const select = (detail) => {\n            const selectAlias = this._rand('ref');\n            // Compose:\n            // - [...detail] AS <selectAlias>\n            joinJson.expr.expr.select_list.push({\n                nodeName: SelectElement.NODE_NAME,\n                expr: detail.jsonfy($options),\n                alias: { nodeName: BasicAlias.NODE_NAME, value: selectAlias },\n                as_kw: true,\n            });\n            return {\n                nodeName: ColumnRef.NODE_NAME,\n                qualifier: { nodeName: TableAbstractionRef.NODE_NAME, value: dimensionID },\n                value: selectAlias\n            };\n        };\n\n        const selectorDimension = { id: dimensionID, type: 'join', query: joinJson, alias, select };\n        selectorDimensions\n            ?.set(dimensionID, selectorDimension);\n\n        return selectorDimension;\n    }\n\n    applySelectorDimensions(resultJson, selectorDimensions, options) {\n        resultJson = {\n            ...resultJson,\n            join_clauses: resultJson.join_clauses?.slice(0) || [],\n        };\n        for (const [, { query: joinJson }] of selectorDimensions) {\n            resultJson.join_clauses.push(\n                JoinClause.fromJSON(joinJson, this.options).jsonfy(options)\n            );\n        }\n        return resultJson;\n    }\n}", "import { SelectorStmtMixin } from '../abstracts/SelectorStmtMixin.js';\nimport { AbstractNonDDLStmt } from '../abstracts/AbstractNonDDLStmt.js';\nimport { registry } from '../registry.js';\n\nconst {\n    FromElement,\n    BasicTableExpr,\n    TableRef,\n    BasicAlias,\n    CompositeAlias,\n    TableAbstractionRef,\n    ColumnRef,\n    SelectElement,\n    FromClause,\n    CompleteSelectStmt,\n    SubqueryConstructor,\n    BinaryExpr,\n} = registry;\n\nexport class CreateTableStmt extends SelectorStmtMixin(\n    AbstractNonDDLStmt\n) {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'keyword', value: 'CREATE' },\n            {\n                optional: true,\n                syntaxes: [\n                    { type: 'keyword', as: 'temporary_kw', value: 'TEMPORARY', booleanfy: true },\n                    { type: 'keyword', as: 'temporary_kw', value: 'TEMP', booleanfy: true, dialect: 'postgres' },\n                ],\n            },\n            { type: 'keyword', value: 'TABLE' },\n            {\n                optional: true,\n                syntax: [\n                    { type: 'keyword', as: 'if_not_exists', value: 'IF' },\n                    { type: 'operator', value: 'NOT' },\n                    { type: 'keyword', value: 'EXISTS' },\n                ],\n            },\n            {\n                assert: true,\n                syntaxes: [\n                    {\n                        dialect: 'postgres',\n                        syntax: [\n                            { type: 'keyword', value: 'FROM' },\n                            { type: 'BasicTableExpr', as: 'table_expr' },\n                            { type: 'UsingFromClause', as: 'using_clause', optional: true, autoIndent: true },\n                            { type: 'JoinClause', as: 'join_clause', optional: true, autoIndent: true },\n                            { type: ['PGWhereCurrentClause', 'WhereClause'], as: 'where_clause', optional: true, autoIndent: true },\n                            { type: 'PGReturningClause', as: 'pg_returning_clause', optional: true, autoIndent: true },\n                        ],\n                    },\n                    {\n                        dialect: 'mysql',\n                        syntax: [\n                            { type: 'MYStarredTableRef', as: 'my_delete_list', arity: { min: 1 }, itemSeparator },\n                            { type: 'FromClause', as: 'my_from_clause', autoIndent: true },\n                            { type: 'JoinClause', as: 'join_clause', optional: true, autoIndent: true },\n                            { type: 'WhereClause', as: 'where_clause', optional: true, autoIndent: true },\n                        ],\n                    },\n                    {\n                        dialect: 'mysql',\n                        syntax: [\n                            { type: 'keyword', value: 'FROM' },\n                            { type: 'MYStarredTableRef', as: 'my_delete_list', arity: { min: 1 }, itemSeparator },\n                            { type: 'UsingFromClause', as: 'using_clause', autoIndent: true },\n                            { type: 'JoinClause', as: 'join_clause', optional: true, autoIndent: true },\n                            { type: 'WhereClause', as: 'where_clause', optional: true, autoIndent: true },\n                        ],\n                    },\n                    {\n                        dialect: 'mysql',\n                        syntax: [\n                            { type: 'keyword', value: 'FROM' },\n                            { type: 'BasicTableExpr', as: 'table_expr' },\n                            { type: 'MYPartitionClause', as: 'my_partition_clause', optional: true, autoIndent: true },\n                            { type: 'WhereClause', as: 'where_clause', optional: true, autoIndent: true },\n                            { type: 'OrderByClause', as: 'my_order_by_clause', optional: true, dialect: 'mysql', autoIndent: true },\n                            { type: 'LimitClause', as: 'my_limit_clause', optional: true, dialect: 'mysql', autoIndent: true },\n                        ],\n                    }\n                ],\n            },\n        ];\n    }\n\n    /* AST API */\n\n    temporaryKW() { return this._get('temporary_kw'); }\n\n    ifNotExists() { return this._get('if_not_exists'); }\n\n    joinClause() { return this._get('join_clause'); }\n\n    whereClause() { return this._get('where_clause'); }\n\n    // -- Postgres\n\n    pgPGReturningClause() { return this._get('pg_returning_clause'); }\n\n    // -- MySQL\n\n    myPartitionClause() { return this._get('my_partition_clause'); }\n\n    myDeleteList() { return this._get('my_delete_list'); }\n\n    myFromClause() { return this._get('my_from_clause'); }\n\n    myOrderByClause() { return this._get('my_order_by_clause'); }\n\n    myLimitClause() { return this._get('my_limit_clause'); }\n\n    /* DESUGARING API */\n\n    applySelectorDimensions(resultJson, selectorDimensions, options) {\n        // This is Postgres-specific\n        if (this.options.dialect !== 'postgres') {\n            return super/* SelectorStmtMixin */.applySelectorDimensions(resultJson, selectorDimensions, options);\n        }\n\n        if (resultJson.where_clause?.cursor_name) {\n            throw new Error(`Deep/Back Refs are currently not supported with a \"WHERE CURRENT OF...\" statement`);\n        }\n\n        const rand = this._rand('rand');\n\n        // Rewrite to a \"WHERE IN ( SELECT ... )\" logic\n        // moving the existing WHERE clause, if any, into the subquery\n\n        const tblRefOriginal = resultJson.table_expr.name.value;\n        const tblAliasOriginal = resultJson.table_expr.alias ? resultJson.table_expr.alias.value : resultJson.table_expr.name.value;\n        const tblAliasRewrite = `${rand}::${tblAliasOriginal}`;\n        const whereClauseOriginal = resultJson.where_clause;\n        const pk = this.table().tableSchema().primaryKey().columns()[0];\n\n        // The re-write...\n        resultJson = {\n            ...resultJson,\n            table_expr: {\n                nodeName: BasicTableExpr.NODE_NAME,\n                name: { nodeName: TableRef.NODE_NAME, value: tblRefOriginal },\n                alias: { nodeName: BasicAlias.NODE_NAME, value: tblAliasRewrite }\n            },\n            where_clause: {\n                nodeName: BinaryExpr.NODE_NAME,\n                left: {\n                    nodeName: ColumnRef.NODE_NAME,\n                    qualifier: { nodeName: TableAbstractionRef.NODE_NAME, value: tblAliasRewrite },\n                    value: pk,\n                },\n                operator: 'IN',\n                right: {\n                    nodeName: SubqueryConstructor.NODE_NAME,\n                    expr: {\n                        // SELECT <...>\n                        nodeName: CompleteSelectStmt.NODE_NAME,\n                        select_list: [{\n                            nodeName: SelectElement.NODE_NAME,\n                            expr: { nodeName: ColumnRef.NODE_NAME, value: pk }\n                        }],\n                        from_clause: {\n                            // FROM <tblRefOriginal>\n                            nodeName: FromClause.NODE_NAME,\n                            entries: [{\n                                nodeName: FromElement.NODE_NAME,\n                                expr: { nodeName: TableRef.NODE_NAME, value: tblRefOriginal },\n                                alias: { nodeName: CompositeAlias.NODE_NAME, value: tblAliasOriginal }\n                            }]\n                        },\n                        where_clause: whereClauseOriginal,\n                        join_clauses: [...selectorDimensions].map((d) => d.query),\n                    },\n                }\n\n            }\n        };\n\n        return resultJson;\n    }\n}", "export * from './constructors/index.js';\nexport * from './constructs/index.js';\nexport { DeleteStmt } from './DeleteStmt.js';\nexport { InsertStmt } from './InsertStmt.js';\nexport { MYSetStmt } from './MYSetStmt.js';\nexport { UpdateStmt } from './UpdateStmt.js';\nexport { UpsertStmt } from './UpsertStmt.js';\n", "import { AbstractNode } from './AbstractNode.js';\n\nexport class AbstractNodeList extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() { return []; }\n\n    // API\n\n    get length() { return (this._get('entries') || []).length; }\n\n    [Symbol.iterator]() { return (this._get('entries') || [])[Symbol.iterator](); }\n\n    ['entries']() { return (this._get('entries') || []).slice(0); }\n\n    get(index) { return this._get('entries', index); }\n\n    set(index, value) { return this._set('entries', index, value); }\n\n    has(index) { return this._has('entries', index); }\n\n    add(...args) { return this._add('entries', ...args); }\n}", "import { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\n\nexport class ColumnsConstructor extends AbstractNodeList {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return {\n            syntax: [\n                {\n                    type: 'paren_block',\n                    syntax: { type: 'ColumnNameRef', as: 'entries', arity: Infinity, itemSeparator, autoIndent: 2 },\n                    autoIndent: true,\n                    autoIndentAdjust: -1,\n                },\n            ],\n        };\n    }\n\n    static get syntaxPriority() { return -1; }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class BinaryExpr extends AbstractNode {\n\n    /* DEFS */\n\n    static get syntaxRules() {\n        return [\n            { type: 'Expr', as: 'left', peek: [1, 'operator', ['NOT', undefined/* IMPORTANT */]] },\n            { type: 'operator', as: 'negation', value: 'NOT', booleanfy: true, optional: true },\n            { type: 'operator', as: 'operator' },\n            { type: 'Expr', as: 'right' },\n        ];\n    }\n\n    static get syntaxPriority() { return 0; }\n\n    /* AST API */\n\n    left() { return this._get('left'); }\n\n    negation() { return this._get('negation'); }\n\n    operator() { return this._get('operator'); }\n\n    right() { return this._get('right'); }\n}", "import { BinaryExpr } from '../../expr/op/BinaryExpr.js';\n\nexport class AssignmentExpr extends BinaryExpr {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: ['LQDeepRef', 'ColumnsConstructor', 'ColumnRef'], as: 'left' },\n            { type: 'operator', as: 'operator', value: '=' },\n            { type: ['ValuesSetConstructor', 'Expr'], as: 'right' },\n        ];\n    }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class BasicTableExpr extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const optional_alias = {\n            optional: true,\n            syntaxes: [\n                { type: 'BasicAlias', as: 'alias' },\n                [\n                    { type: 'keyword', as: 'as_kw', value: 'AS', booleanfy: true },\n                    { type: 'BasicAlias', as: 'alias', assert: true }\n                ]\n            ]\n        };\n        return [\n            { type: 'keyword', as: 'pg_only_kw', value: 'ONLY', optional: true, dialect: 'postgres' },\n            { type: 'TableRef', as: 'name', assert: true },\n            { type: 'StarRef', as: 'pg_star_ref', optional: true, dialect: 'postgres' },\n            { ...optional_alias },\n        ];\n    }\n\n    /* AST API */\n\n    name() { return this._get('name'); }\n\n    alias() { return this._get('alias'); }\n\n    // -- Postgres\n\n    pgOnlyKW() { return this._get('pg_only_kw'); }\n\n    pgStarRef() { return this._get('pg_star_ref'); }\n}", "import { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\n\nexport class MYOnDuplicateKeyUpdateClause extends AbstractNodeList {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return {\n            dialect: 'mysql',\n            syntax: [\n                { type: 'keyword', value: 'ON' },\n                { type: 'keyword', value: 'DUPLICATE' },\n                { type: 'keyword', value: 'KEY' },\n                { type: 'keyword', value: 'UPDATE' },\n                { type: 'AssignmentExpr', as: 'entries', arity: { min: 1 }, itemSeparator, assert: true, autoIndent: 2 },\n            ]\n        };\n    }\n}", "import { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\n\nexport class MYPartitionClause extends AbstractNodeList {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return {\n            dialect: 'mysql',\n            syntax: [\n                { type: 'keyword', value: 'PARTITION' },\n                { type: 'Identifier', as: 'entries', arity: { min: 1 }, itemSeparator, assert: true }\n            ],\n        };\n    }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class MYStarredTableRef extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            dialect: 'mysql',\n            syntax: [\n                { type: 'TableRef', as: 'name' },\n                {\n                    optional: true,\n                    syntax: [\n                        { type: 'punctuation', value: '.', autoSpacing: false },\n                        { type: 'StarRef', as: 'star_ref', autoSpacing: false },\n                    ],\n                },\n            ],\n        };\n    }\n\n    /* AST API */\n\n    name() { return this._get('name'); }\n\n    starRef() { return this._get('star_ref'); }\n}", "import { BinaryExpr } from '../../expr/op/BinaryExpr.js';\n\nexport class MYVarAssignmentExpr extends BinaryExpr {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            dialect: 'mysql',\n            syntax: [\n                { type: ['UserVar', 'SystemVar'], as: 'left' },\n                { type: 'operator', as: 'operator', value: ['=', ':='] },\n                { type: 'Expr', as: 'right' },\n            ],\n        };\n    }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class PGConflictTarget extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return {\n            syntaxes: [\n                [\n                    { type: 'keyword', value: 'ON' },\n                    { type: 'keyword', value: 'CONSTRAINT' },\n                    { type: 'Identifier', as: 'constraint_name', assert: true }\n                ],\n                [\n                    {\n                        type: 'paren_block',\n                        syntax: { type: 'PGConflictTargetIndexSpec', as: 'index_list', arity: { min: 1 }, itemSeparator, assert: true },\n                        autoIndent: true,\n                    },\n                    { type: 'WhereClause', as: 'where_clause', optional: true, autoIndent: true },\n                ],\n            ],\n        };\n    }\n\n    /* AST API */\n\n    constraintName() { return this._get('constraint_name'); }\n\n    indexList() { return this._get('index_list'); }\n\n    whereClause() { return this._get('where_clause'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class PGConflictTargetIndexSpec extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            {\n                syntaxes: [\n                    { type: 'ColumnNameRef', as: 'column_name' },\n                    { type: 'paren_block', syntax: { type: 'Expr', as: 'expr', assert: true }, autoIndent: true },\n                    { type: 'CallExpr', as: 'expr' }, // Must come after the parens option\n                ],\n            },\n            {\n                optional: true,\n                syntax: [\n                    { type: 'operator', value: 'COLLATE' },\n                    { type: 'string_literal', as: 'collation', assert: true },\n                ],\n            },\n            { type: 'Identifier', as: 'opclass', optional: true },\n        ];\n    }\n\n    /* AST API */\n\n    columnName() { return this._get('column_name'); }\n\n    expr() { return this._get('expr'); }\n\n    collation() { return this._get('collation'); }\n\n    opclass() { return this._get('opclass'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class PGDefaultValuesClause extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            dialect: 'postgres',\n            syntax: [\n                { type: 'keyword', value: 'DEFAULT' },\n                { type: 'keyword', as: '_'/* temp fix */, value: 'VALUES' },\n            ]\n        };\n    }\n}", "import { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\n\nexport class PGOnConflictClause extends AbstractNodeList {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return {\n            dialect: 'postgres',\n            syntax: [\n                { type: 'keyword', value: 'ON' },\n                { type: 'keyword', value: 'CONFLICT' },\n                {\n                    syntaxes: [\n                        [\n                            { type: 'PGConflictTarget', as: 'conflict_target', optional: true },\n                            { type: 'keyword', as: 'do_nothing', value: 'DO' },\n                            { type: 'keyword', value: 'NOTHING' },\n                        ],\n                        [\n                            { type: 'PGConflictTarget', as: 'conflict_target' },\n                            { type: 'keyword', value: 'DO' },\n                            { type: 'keyword', value: 'UPDATE' },\n                            { type: 'keyword', value: 'SET' },\n                            { type: 'AssignmentExpr', as: 'entries', arity: { min: 1 }, itemSeparator, assert: true, autoIndent: 2 },\n                            { type: 'WhereClause', as: 'where_clause', optional: true, autoIndent: true },\n                        ],\n                    ],\n                }\n            ],\n        };\n    }\n\n    /* AST API */\n\n    conflictTarget() { return this._get('conflict_target'); }\n\n    doNothing() { return this._get('do_nothing'); }\n\n    whereClause() { return this._get('where_clause'); }\n}", "import { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\n\nexport class PGReturningClause extends AbstractNodeList {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return {\n            dialect: 'postgres',\n            syntax: [\n                { type: 'keyword', value: 'RETURNING' },\n                { type: 'SelectElement', as: 'entries', arity: { min: 1 }, itemSeparator, assert: true, autoIndent: 2 },\n            ],\n        };\n    }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class PGWhereCurrentClause extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            dialect: 'postgres',\n            syntax: [\n                { type: 'keyword', value: 'WHERE' },\n                { type: 'keyword', value: 'CURRENT OF' },\n                { type: 'identifier', as: 'cursor_name', assert: true }\n            ]\n        };\n    }\n\n    /* AST API */\n\n    cursorName() { return this._get('cursor_name'); }\n}", "import { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\n\nexport class SetClause extends AbstractNodeList {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'keyword', value: 'SET' },\n            { type: 'AssignmentExpr', as: 'entries', arity: { min: 1 }, itemSeparator, assert: true, autoIndent: 2 },\n        ];\n    }\n}", "import { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\n\nexport class UsingFromClause extends AbstractNodeList {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'keyword', value: 'USING' },\n            { type: 'FromElement', as: 'entries', arity: { min: 1 }, itemSeparator, assert: true }\n        ];\n    }\n}", "import { SelectorStmtMixin } from '../abstracts/SelectorStmtMixin.js';\nimport { AbstractNonDDLStmt } from '../abstracts/AbstractNonDDLStmt.js';\nimport { registry } from '../registry.js';\n\nconst {\n    FromElement,\n    BasicTableExpr,\n    TableRef,\n    BasicAlias,\n    CompositeAlias,\n    TableAbstractionRef,\n    ColumnRef,\n    SelectElement,\n    FromClause,\n    CompleteSelectStmt,\n    SubqueryConstructor,\n    BinaryExpr,\n} = registry;\n\nexport class DeleteStmt extends SelectorStmtMixin(\n    AbstractNonDDLStmt\n) {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'keyword', value: 'DELETE' },\n            {\n                assert: true,\n                syntaxes: [\n                    {\n                        dialect: 'postgres',\n                        syntax: [\n                            { type: 'keyword', value: 'FROM' },\n                            { type: 'BasicTableExpr', as: 'table_expr' },\n                            { type: 'UsingFromClause', as: 'using_clause', optional: true, autoIndent: true },\n                            { type: 'JoinClause', as: 'join_clause', optional: true, autoIndent: true },\n                            { type: ['PGWhereCurrentClause', 'WhereClause'], as: 'where_clause', optional: true, autoIndent: true },\n                            { type: 'PGReturningClause', as: 'pg_returning_clause', optional: true, autoIndent: true },\n                        ],\n                    },\n                    {\n                        dialect: 'mysql',\n                        syntax: [\n                            { type: 'MYStarredTableRef', as: 'my_delete_list', arity: { min: 1 }, itemSeparator },\n                            { type: 'FromClause', as: 'my_from_clause', autoIndent: true },\n                            { type: 'JoinClause', as: 'join_clause', optional: true, autoIndent: true },\n                            { type: 'WhereClause', as: 'where_clause', optional: true, autoIndent: true },\n                        ],\n                    },\n                    {\n                        dialect: 'mysql',\n                        syntax: [\n                            { type: 'keyword', value: 'FROM' },\n                            { type: 'MYStarredTableRef', as: 'my_delete_list', arity: { min: 1 }, itemSeparator },\n                            { type: 'UsingFromClause', as: 'using_clause', autoIndent: true },\n                            { type: 'JoinClause', as: 'join_clause', optional: true, autoIndent: true },\n                            { type: 'WhereClause', as: 'where_clause', optional: true, autoIndent: true },\n                        ],\n                    },\n                    {\n                        dialect: 'mysql',\n                        syntax: [\n                            { type: 'keyword', value: 'FROM' },\n                            { type: 'BasicTableExpr', as: 'table_expr' },\n                            { type: 'MYPartitionClause', as: 'my_partition_clause', optional: true, autoIndent: true },\n                            { type: 'WhereClause', as: 'where_clause', optional: true, autoIndent: true },\n                            { type: 'OrderByClause', as: 'my_order_by_clause', optional: true, dialect: 'mysql', autoIndent: true },\n                            { type: 'LimitClause', as: 'my_limit_clause', optional: true, dialect: 'mysql', autoIndent: true },\n                        ],\n                    }\n                ],\n            },\n        ];\n    }\n\n    /* AST API */\n\n    tableExpr() { return this._get('table_expr'); }\n\n    usingClause() { return this._get('using_clause'); }\n\n    joinClause() { return this._get('join_clause'); }\n\n    whereClause() { return this._get('where_clause'); }\n\n    // -- Postgres\n\n    pgPGReturningClause() { return this._get('pg_returning_clause'); }\n\n    // -- MySQL\n\n    myPartitionClause() { return this._get('my_partition_clause'); }\n\n    myDeleteList() { return this._get('my_delete_list'); }\n\n    myFromClause() { return this._get('my_from_clause'); }\n\n    myOrderByClause() { return this._get('my_order_by_clause'); }\n\n    myLimitClause() { return this._get('my_limit_clause'); }\n\n    /* DESUGARING API */\n\n    applySelectorDimensions(resultJson, selectorDimensions, options) {\n        // This is Postgres-specific\n        if (this.options.dialect !== 'postgres') {\n            return super/* SelectorStmtMixin */.applySelectorDimensions(resultJson, selectorDimensions, options);\n        }\n\n        if (resultJson.where_clause?.cursor_name) {\n            throw new Error(`Deep/Back Refs are currently not supported with a \"WHERE CURRENT OF...\" statement`);\n        }\n\n        const rand = this._rand('rand');\n\n        // Rewrite to a \"WHERE IN ( SELECT ... )\" logic\n        // moving the existing WHERE clause, if any, into the subquery\n\n        const tblRefOriginal = resultJson.table_expr.name.value;\n        const tblAliasOriginal = resultJson.table_expr.alias ? resultJson.table_expr.alias.value : resultJson.table_expr.name.value;\n        const tblAliasRewrite = `${rand}::${tblAliasOriginal}`;\n        const whereClauseOriginal = resultJson.where_clause;\n        const pk = this.table().tableSchema().primaryKey().columns()[0];\n\n        // The re-write...\n        resultJson = {\n            ...resultJson,\n            table_expr: {\n                nodeName: BasicTableExpr.NODE_NAME,\n                name: { nodeName: TableRef.NODE_NAME, value: tblRefOriginal },\n                alias: { nodeName: BasicAlias.NODE_NAME, value: tblAliasRewrite }\n            },\n            where_clause: {\n                nodeName: BinaryExpr.NODE_NAME,\n                left: {\n                    nodeName: ColumnRef.NODE_NAME,\n                    qualifier: { nodeName: TableAbstractionRef.NODE_NAME, value: tblAliasRewrite },\n                    value: pk,\n                },\n                operator: 'IN',\n                right: {\n                    nodeName: SubqueryConstructor.NODE_NAME,\n                    expr: {\n                        // SELECT <...>\n                        nodeName: CompleteSelectStmt.NODE_NAME,\n                        select_list: [{\n                            nodeName: SelectElement.NODE_NAME,\n                            expr: { nodeName: ColumnRef.NODE_NAME, value: pk }\n                        }],\n                        from_clause: {\n                            // FROM <tblRefOriginal>\n                            nodeName: FromClause.NODE_NAME,\n                            entries: [{\n                                nodeName: FromElement.NODE_NAME,\n                                expr: { nodeName: TableRef.NODE_NAME, value: tblRefOriginal },\n                                alias: { nodeName: CompositeAlias.NODE_NAME, value: tblAliasOriginal }\n                            }]\n                        },\n                        where_clause: whereClauseOriginal,\n                        join_clauses: [...selectorDimensions].map((d) => d.query),\n                    },\n                }\n\n            }\n        };\n\n        return resultJson;\n    }\n}", "import { registry } from '../registry.js';\nimport { _eq } from '../util.js';\n\n// AssignmentExpr and others\n// UpsertStmt\n\nconst {\n\t// Core references and constructors\n\tLQDeepRef,\n\tLQBackRefConstructor,\n\tColumnNameRef,\n\tColumnRef,\n\tTableRef,\n\tBasicAlias,\n\n\t// Assignment and set/row/column constructors\n\tAssignmentExpr,\n\tColumnsConstructor,\n\tRowConstructor,\n\tSetConstructor,\n\tValuesConstructor,\n\tValuesSetConstructor,\n\n\t// Query and clause nodes\n\tSelectStmt,\n\tCompleteSelectStmt,\n\tSubqueryConstructor,\n\tSelectElement,\n\tFromElement,\n\tCompositeAlias,\n\tFromClause,\n\tSetClause,\n\tPGReturningClause,\n\n\t// Operators and literals\n\tBinaryExpr,\n\tBoolLiteral,\n\tNumberLiteral,\n\n\t// Special references\n\tStarRef,\n\n\t// Statement types\n\tCTE,\n\tCTEBinding,\n\tUpdateStmt,\n\tInsertStmt,\n\tUpsertStmt\n} = registry;\n\nexport const PayloadStmtMixin = (Class) => class extends Class {\n\n\tget isPayloadStmt() { return true; }\n\n\tstatic morphsTo() { return CTE; }\n\n\t/* DESUGARING API */\n\n\tjsonfy(options = {}, superTransformCallback = null) {\n\t\tif (!options.deSugar) return super.jsonfy(options);\n\t\tconst payloadDimensions = new Set;\n\n\t\tconst specials = ['columns_list', 'default_values_clause', 'values_clause', 'select_clause'].map((s) => this._get(s));\n\t\tconst [columnsList, defaultValuesClause, valuesClause, selectClause] = specials;\n\t\tconst hasTopLevelDeepRefs = columnsList?.some((c) => c instanceof LQDeepRef);\n\n\t\t// --- ASSIGNMENT EXPRS ---------------\n\n\t\tconst ignoreList = hasTopLevelDeepRefs ? new Set(specials) : new Set;\n\t\tconst transformCallback = (node, keyHint, { deSugar/* IMPORTANT */, ...$options }) => {\n\t\t\t// Defer to super callback first\n\t\t\tif (superTransformCallback) {\n\t\t\t\tnode = superTransformCallback(node, keyHint, { deSugar/* IMPORTANT */, ...$options });\n\t\t\t}\n\n\t\t\t// IMPORTANT!!! The bellow tells the default jsonfier to ignore the nodes we'll handle manually\n\t\t\tif (ignoreList.has(node)) return; // Exclude in output\n\t\t\t// We want to only desugar AssignmentExpr\n\t\t\tif (!(deSugar && node instanceof AssignmentExpr)) return node; // Default jsonfy\n\n\t\t\t// Is this assignment expr from within \"on_conflict_clause\"?\n\t\t\tconst onConflictClauseContext = !!this._get('on_conflict_clause')?.containsNode(node);\n\t\t\tconst $$options = { ...$options, onConflictClauseContext };\n\n\t\t\t// Handle bare assignment exoressions\n\t\t\tif (node.left() instanceof LQDeepRef) {\n\t\t\t\tconst [[deSugaredLeft], [[deSugaredRight]]] = this.deSugarPayload(\n\t\t\t\t\t[node.left()],\n\t\t\t\t\t[[node.right()]],\n\t\t\t\t\tpayloadDimensions,\n\t\t\t\t\t$$options,\n\t\t\t\t);\n\t\t\t\tif (!deSugaredLeft) return; // Exclude in output\n\t\t\t\treturn {\n\t\t\t\t\tnodeName: AssignmentExpr.NODE_NAME,\n\t\t\t\t\toperator: '=',\n\t\t\t\t\tleft: deSugaredLeft,\n\t\t\t\t\tright: deSugaredRight,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Handle compound assignment exoressions\n\t\t\tif (node.left() instanceof ColumnsConstructor // Postgres\n\t\t\t\t&& node.left().entries().some((c) => c instanceof LQDeepRef)) {\n\n\t\t\t\tconst columnsList = node.left().entries();\n\t\t\t\tlet deSugaredColumns,\n\t\t\t\t\tdeSugaredRight;\n\n\t\t\t\tif (node.right() instanceof SetConstructor/* Still passes even for RowConstructor */) {\n\t\t\t\t\t[deSugaredColumns, deSugaredRight] = this.deSugarPayload(\n\t\t\t\t\t\tcolumnsList,\n\t\t\t\t\t\t[node.right().entries()],\n\t\t\t\t\t\tpayloadDimensions,\n\t\t\t\t\t\t$$options,\n\t\t\t\t\t);\n\t\t\t\t\tdeSugaredRight = { nodeName: RowConstructor.NODE_NAME/* To be really formal */, entries: deSugaredRight };\n\t\t\t\t} else if (node.right() instanceof SubqueryConstructor) {\n\t\t\t\t\t[deSugaredColumns, deSugaredRight] = this.deSugarPayload(\n\t\t\t\t\t\tcolumnsList,\n\t\t\t\t\t\tnode.right().expr(),\n\t\t\t\t\t\tpayloadDimensions,\n\t\t\t\t\t\t$$options,\n\t\t\t\t\t);\n\t\t\t\t\tdeSugaredRight = { nodeName: SubqueryConstructor.NODE_NAME, expr: deSugaredRight };\n\t\t\t\t} else {\n\t\t\t\t\t[deSugaredColumns, deSugaredRight] = this.deSugarPayload(\n\t\t\t\t\t\tcolumnsList,\n\t\t\t\t\t\t[[node.right()]],\n\t\t\t\t\t\tpayloadDimensions,\n\t\t\t\t\t\t$$options,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif (!deSugaredColumns.length) return; // Exclude in output\n\t\t\t\treturn {\n\t\t\t\t\tnodeName: AssignmentExpr.NODE_NAME,\n\t\t\t\t\toperator: '=',\n\t\t\t\t\tleft: { nodeName: ColumnsConstructor.NODE_NAME, entries: deSugaredColumns },\n\t\t\t\t\tright: deSugaredRight,\n\t\t\t\t};\n\t\t\t}\n\t\t};\n\n\t\t// Base JSON\n\t\tlet resultJson = super.jsonfy(options, transformCallback);\n\n\t\t// --- TOP-LEVEL COLUMNS:VALUES/SELECT ---------------\n\n\t\t// Manually jsonfy these\n\t\tif (hasTopLevelDeepRefs) {\n\t\t\tconst [deSugaredColumns, deSugaredValues] = this.deSugarPayload(\n\t\t\t\tcolumnsList,\n\t\t\t\tselectClause || valuesClause.entries().map((rowSet) => rowSet.entries()),\n\t\t\t\tpayloadDimensions,\n\t\t\t\toptions\n\t\t\t);\n\t\t\tresultJson = {\n\t\t\t\t...resultJson,\n\t\t\t\tcolumns_list: deSugaredColumns,\n\t\t\t};\n\t\t\tif (selectClause) {\n\t\t\t\tresultJson = { ...resultJson, select_clause: deSugaredValues };\n\t\t\t} else {\n\t\t\t\tconst rowsJson = deSugaredValues.map((rowSetJson) => ({ nodeName: RowConstructor.NODE_NAME/* Most cross-dialect */, entries: rowSetJson }));\n\t\t\t\tresultJson = {\n\t\t\t\t\t...resultJson,\n\t\t\t\t\tvalues_clause: { nodeName: ValuesConstructor.NODE_NAME, entries: rowsJson },\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\t// Apply payloadDimensions\n\t\tif (payloadDimensions.size) {\n\t\t\tresultJson = this.applyPayloadDimensions(resultJson, payloadDimensions, options);\n\t\t}\n\t\treturn resultJson;\n\t}\n\n\tdeSugarPayload(columns, values, payloadDimensions, { onConflictClauseContext = false, deSugar, ...$options } = {}) {\n\n\t\t// (1): Columns\n\t\tconst deSugarColumnsList = (columnsList, dimensionsMap) => {\n\t\t\treturn columnsList.reduce(columnsList, (columnRef, columnOffset) => {\n\t\t\t\tif (columnRef instanceof LQDeepRef) {\n\t\t\t\t\tconst dimension = this.createPayloadDimension(columnRef, payloadDimensions, { onConflictClauseContext, ...$options });\n\t\t\t\t\tdimensionsMap.set(columnOffset, dimension);\n\t\t\t\t\tif (dimension.type === 'dependency' && dimension.leftJson) {\n\t\t\t\t\t\treturn columnsList.concat(dimension.leftJson);\n\t\t\t\t\t}\n\t\t\t\t\treturn columnsList;\n\t\t\t\t}\n\t\t\t\treturn columnsList.concat(columnRef.jsonfy({ deSugar, ...$options }));\n\t\t\t}, []);\n\t\t};\n\n\t\t// (2.a): Select\n\t\tconst deSugarValuesFromSelect = (selectStmt, dimensionsMap) => {\n\t\t\t// Declare base SELECT and select list\n\t\t\tlet baseSelect = selectStmt.jsonfy($options);\n\t\t\tlet baseSelectList = baseSelect.select_list;\n\t\t\tif (baseSelectList[0].expr.nodeName === StarRef.NODE_NAME) {\n\t\t\t\tbaseSelectList/* = infer from schema */; throw new Error(`TODO`);\n\t\t\t}\n\t\t\t// Create a CTE entry?\n\t\t\tif (!onConflictClauseContext) {\n\t\t\t\tconst cteAlias = this._rand('cte');\n\t\t\t\tconst cteSelect = { ...baseSelect, uuid: cteAlias, select_list: [{ nodeName: SelectElement.NODE_NAME, expr: { nodeName: StarRef.NODE_NAME } }] };\n\t\t\t\tpayloadDimensions\n\t\t\t\t\t?.add({ type: 'memo', query: cteSelect });\n\t\t\t\t// Use that as new base\n\t\t\t\tconst newBaseSelectFromElement = { nodeName: FromElement.NODE_NAME, expr: { nodeName: TableRef.NODE_NAME, value: cteAlias } };\n\t\t\t\tbaseSelect = {\n\t\t\t\t\tnodeName: CompleteSelectStmt.NODE_NAME,\n\t\t\t\t\tfrom_clause: { nodeName: FromClause.NODE_NAME, entries: [newBaseSelectFromElement] }\n\t\t\t\t};\n\t\t\t}\n\t\t\t// Resolve base select list\n\t\t\tconst newBaseSelectList = baseSelectList.reduce((selectList, fieldJson, columnOffset) => {\n\t\t\t\tif (dimensionsMap.has(columnOffset)) {\n\t\t\t\t\tlet subSelectList;\n\t\t\t\t\tif (fieldJson.expr.nodeName === RowConstructor.NODE_NAME) {\n\t\t\t\t\t\tsubSelectList = fieldJson.expr.entries;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsubSelectList = [fieldJson.expr];\n\t\t\t\t\t}\n\t\t\t\t\tconst valueNode = SelectStmt.fromJson({ ...baseSelect, select_list: subSelectList.map((f) => ({ nodeName: SelectElement.NODE_NAME, expr: f })) });\n\t\t\t\t\tfieldJson = dimensionsMap.get(columnOffset).offload(valueNode, rowOffset);\n\t\t\t\t\tif (fieldJson) return selectList.concat(fieldJson);\n\t\t\t\t}\n\t\t\t\treturn selectList.concat(fieldJson);\n\t\t\t}, []);\n\t\t\t// The final deSugared query\n\t\t\treturn { ...baseSelect, select_list: newBaseSelectList };\n\t\t};\n\n\t\t// (2.b): Values\n\t\tconst deSugarValuesFromValues = (valuesEntries, dimensionsMap) => {\n\t\t\treturn valuesEntries.map((valuesRow, rowOffset) => {\n\t\t\t\treturn valuesRow.reduce((valuesRow, valueNode, columnOffset) => {\n\t\t\t\t\tconst valueJson = dimensionsMap.has(columnOffset)\n\t\t\t\t\t\t? dimensionsMap.get(columnOffset).offload(valueNode, rowOffset)\n\t\t\t\t\t\t: valueNode.jsonfy({ deSugar, ...$options });\n\t\t\t\t\tif (valueJson) return valuesRow.concat(valueJson);\n\t\t\t\t\treturn valuesRow;\n\t\t\t\t}, []);\n\t\t\t});\n\t\t};\n\n\t\t// Process...\n\t\tconst dimensionsMap = new Map;\n\t\tconst deSugaredColumns = deSugarColumnsList(columns, dimensionsMap);\n\t\tconst deSugaredValues = values instanceof SelectStmt\n\t\t\t? deSugarValuesFromSelect(values, dimensionsMap)\n\t\t\t: deSugarValuesFromValues(values, dimensionsMap);\n\t\tdimensionsMap.clear();\n\n\t\treturn [deSugaredColumns, deSugaredValues];\n\t}\n\n\tcreatePayloadDimension(LQRefColumn, payloadDimensions = null, { onConflictClauseContext = false, ...$options } = {}) {\n\t\tconst { left, right, table } = LQRefColumn.getOperands();\n\n\t\tconst dimensionID = `dimension${onConflictClauseContext ? '/c' : ''}::${[left, right, table].join('/')}`;\n\t\tconst leftJson = left.jsonfy($options);\n\t\tconst rightJson = right.jsonfy($options);\n\n\t\t// Figure the expected payload structure\n\t\tlet columnsConstructorJson;\n\t\tconst refRight = LQRefColumn.right();\n\t\tif (refRight instanceof ColumnsConstructor) {\n\t\t\tcolumnsConstructorJson = refRight.jsonfy($options);\n\t\t} else if (refRight instanceof ColumnNameRef || refRight instanceof LQDeepRef) {\n\t\t\tcolumnsConstructorJson = { nodeName: ColumnsConstructor.NODE_NAME, entries: [refRight.jsonfy($options)] };\n\t\t} else {\n\t\t\tthrow new Error(`Invalid columns spec: ${LQRefColumn}`);\n\t\t}\n\n\t\t// Payload structure length validity\n\t\tconst columnsLength = columnsConstructorJson.entries.length;\n\t\tconst dimensionValidateRowLength = (rowNode) => {\n\t\t\tlet rowLength = 1;\n\t\t\tif (rowNode instanceof SubqueryConstructor) {\n\t\t\t\trowLength = rowNode.expr().length;\n\t\t\t} else if (rowNode instanceof SelectStmt) {\n\t\t\t\trowLength = rowNode.length;\n\t\t\t} else if (rowNode instanceof RowConstructor) {\n\t\t\t\trowLength = rowNode.length;\n\t\t\t}\n\t\t\tif (rowLength > columnsLength) throw new Error(`INSERT has more expressions than target columns`);\n\t\t\tif (rowLength < columnsLength) throw new Error(`INSERT has more target columns than expressions`);\n\t\t\treturn rowNode;\n\t\t};\n\n\t\t// Compose:\n\t\t// - (SELECT <sourceCol> ->> <sourceRowIndex> FROM <sourceUuid>)\n\t\tconst createForeignBinding = (sourceUuid, sourceCol, sourceRowIndex = null, innerFilter = null) => {\n\t\t\tconst fieldExpr = typeof sourceRowIndex === 'number' ? ({\n\t\t\t\tnodeName: BinaryExpr.NODE_NAME,\n\t\t\t\toperator: '->>',\n\t\t\t\tleft: sourceCol,\n\t\t\t\tright: { nodeName: NumberLiteral.NODE_NAME, value: sourceRowIndex },\n\t\t\t}) : sourceCol;\n\t\t\tconst innerFilterExpr = typeof innerFilter === 'string' ? ({\n\t\t\t\tnodeName: BinaryExpr.NODE_NAME,\n\t\t\t\toperator: 'IS',\n\t\t\t\tleft: { nodeName: ColumnRef.NODE_NAME, value: innerFilter },\n\t\t\t\tright: { nodeName: BoolLiteral.NODE_NAME, value: 'TRUE' },\n\t\t\t}) : null;\n\t\t\tconst tableSpec = { nodeName: FromElement.NODE_NAME, expr: { nodeName: TableRef.NODE_NAME, value: sourceUuid } };\n\t\t\tconst selectStmt = {\n\t\t\t\tnodeName: CompleteSelectStmt.NODE_NAME,\n\t\t\t\tselect_list: [{ nodeName: SelectElement.NODE_NAME, expr: fieldExpr }],\n\t\t\t\tfrom_clause: { nodeName: FromClause.NODE_NAME, entries: [tableSpec] },\n\t\t\t\t...(innerFilterExpr ? { where_clause: innerFilterExpr } : {}),\n\t\t\t};\n\t\t\treturn { nodeName: SubqueryConstructor.NODE_NAME, expr: selectStmt };\n\t\t};\n\n\t\t// --- UPDATE -------------\n\n\t\tif (this instanceof UpdateStmt || onConflictClauseContext) {\n\n\t\t\t// UPDATE t1 SET (a, (fk <~ fk <~ t2) ~> (a, b)) = ROW(2, ROW(44, 33))\n\t\t\t// UPDATE t1 SET (a, (fk <~ fk <~ t2) ~> a) = ROW(2, ROW(44, 33))\n\t\t\t// UPDATE t1 SET (a, (fk <~ fk <~ t2) ~> a) = (SELECT a, b FROM t3)\n\t\t\t// UPDATE t1 SET (a, fk ~> fk ~> (a, b)) = ROW(2, ROW(44, 33))\n\t\t\t// UPDATE t1 SET (a, fk ~> fk ~> a) = ROW(2, ROW(44, 33))\n\t\t\t// UPDATE t1 SET (a, fk ~> fk ~> a) = (SELECT a, b FROM t3)\n\n\t\t\t// Here we want to compose:\n\t\t\t// - WHERE <rightJson> IN (SELECT <leftJson> FROM <this.uuid> [WHERE <on_conflict_updated_status> IS TRUE]? )\n\t\t\tconst onConflictUpdatedStatusAlias = onConflictClauseContext\n\t\t\t\t? `${this.uuid}_on_conflict_updated_status` : null;\n\t\t\tconst whereClause = {\n\t\t\t\tnodeName: BinaryExpr.NODE_NAME,\n\t\t\t\toperator: 'IN',\n\t\t\t\tleft: rightJson,\n\t\t\t\tright: createForeignBinding(this.uuid, leftJson, null, onConflictUpdatedStatusAlias),\n\t\t\t};\n\n\t\t\tconst query = {\n\t\t\t\tuuid: this._rand('query'),\n\t\t\t\tnodeName: UpdateStmt.NODE_NAME,\n\t\t\t\ttables: [{ nodeName: FromElement.NODE_NAME, expr: table.jsonfy($options) }],\n\t\t\t\tset_clause: { nodeName: SetClause.NODE_NAME, entries: [] },\n\t\t\t\twhere_clause: whereClause,\n\t\t\t};\n\n\t\t\tconst offload = (payload) => {\n\t\t\t\tif (payload instanceof ValuesSetConstructor) {\n\t\t\t\t\tthrow new Error(`Single-row payload structure expected for column structure: ${LQRefColumn.right()}. Recieved ${payload.NODE_NAME}.`);\n\t\t\t\t}\n\t\t\t\tif (query.set_clause.entries.length) {\n\t\t\t\t\tthrow new Error(`Unexpected offload() call on ${LQRefColumn}`);\n\t\t\t\t}\n\t\t\t\tdimensionValidateRowLength(payload);\n\t\t\t\tlet payloadJson = payload.jsonfy($options);\n\t\t\t\tif (payload instanceof SelectStmt) {\n\t\t\t\t\tpayloadJson = { nodeName: SubqueryConstructor.NODE_NAME, expr: payloadJson };\n\t\t\t\t} else if (!(payload instanceof SetConstructor)) {\n\t\t\t\t\tpayloadJson = { nodeName: RowConstructor.NODE_NAME/* most formal */, entries: [payloadJson] };\n\t\t\t\t}\n\t\t\t\tquery.set_clause.entries.push({\n\t\t\t\t\tnodeName: AssignmentExpr.NODE_NAME,\n\t\t\t\t\toperator: '=',\n\t\t\t\t\tleft: columnsConstructorJson,\n\t\t\t\t\tright: payloadJson,\n\t\t\t\t});\n\t\t\t};\n\n\t\t\tconst payloadDimension = {\n\t\t\t\tid: dimensionID,\n\t\t\t\ttype: 'dependent',\n\t\t\t\tquery,\n\t\t\t\toffload,\n\t\t\t\tleftJson,\n\t\t\t\tonConflictClauseContext\n\t\t\t};\n\n\t\t\tpayloadDimensions\n\t\t\t\t?.add(payloadDimension);\n\n\t\t\treturn payloadDimension;\n\t\t}\n\n\t\t// --- INSERT/UPSERT -------------\n\n\t\tconst query = {\n\t\t\tuuid: this._rand('query'),\n\t\t\tnodeName: this.NODE_NAME,\n\t\t\ttable: table.jsonfy($options),\n\t\t\tcolumns_list: columnsConstructorJson,\n\t\t\tvalues_clause: { nodeName: ValuesConstructor.NODE_NAME, entries: [] },\n\t\t};\n\n\t\tconst dimensionPushRow = (payload, fKBindingJson = null) => {\n\t\t\tdimensionValidateRowLength(payload);\n\t\t\tconst rowJson = payload instanceof SetConstructor\n\t\t\t\t? payload.jsonfy($options)\n\t\t\t\t: { nodeName: RowConstructor.NODE_NAME/* most formal */, entries: [payload.jsonfy($options)] };\n\t\t\tif (fKBindingJson) {\n\t\t\t\tquery.values_clause.entries.push({ ...rowJson, entries: rowJson.entries.concat(fKBindingJson) });\n\t\t\t} else query.values_clause.entries.push(rowJson);\n\t\t};\n\n\t\tif (LQRefColumn.left() instanceof LQBackRefConstructor) {\n\n\t\t\t// INSERT INTO t1 (a, (fk <~ fk <~ t2) ~> (a, b)) VALUES (2, ROW(44, 33)), (3, ROW(11, 22))\n\t\t\t// INSERT INTO t1 (a, (fk <~ fk <~ t2) ~> a) VALUES (2, 44), (3, 11)\n\t\t\t// INSERT INTO t1 (a, (fk <~ fk <~ t2) ~> a) SELECT a, b FROM t3\n\n\t\t\tquery.columns_list.push(rightJson);\n\n\t\t\tconst offload = (payload, rowOffset) => {\n\t\t\t\tconst fKBindingJson = createForeignBinding(this.uuid, leftJson, rowOffset);\n\n\t\t\t\tif (payload instanceof CompleteSelectStmt) {\n\t\t\t\t\tdimensionValidateRowLength(payload);\n\t\t\t\t\tdelete query.values_clause;\n\t\t\t\t\tconst fkField = {\n\t\t\t\t\t\tnodeName: SelectElement.NODE_NAME,\n\t\t\t\t\t\texpr: fKBindingJson,\n\t\t\t\t\t\talias: right instanceof ColumnRef ? { nodeName: BasicAlias.NODE_NAME, value: right.value() } : undefined\n\t\t\t\t\t};\n\t\t\t\t\tconst selectJson = payload.jsonfy($options);\n\t\t\t\t\tquery.select_clause = { ...selectJson, select_list: selectJson.select_list.concat(fkField) };\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (payload instanceof ValuesSetConstructor) {\n\t\t\t\t\tfor (const rowNode of payload.expr()) {\n\t\t\t\t\t\tdimensionPushRow(rowNode, fKBindingJson);\n\t\t\t\t\t}\n\t\t\t\t} else dimensionPushRow(payload, fKBindingJson);\n\t\t\t};\n\n\t\t\tconst payloadDimension = {\n\t\t\t\tid: dimensionID,\n\t\t\t\ttype: 'dependent',\n\t\t\t\tquery,\n\t\t\t\toffload,\n\t\t\t\tleftJson\n\t\t\t};\n\n\t\t\tpayloadDimensions\n\t\t\t\t?.add(payloadDimension);\n\n\t\t\treturn payloadDimension;\n\t\t}\n\n\t\t// INSERT INTO t1 (a, t2 ~> fk ~> (a, b)) VALUES (2, ROW(44, 33)), (3, ROW(11, 22))\n\t\t// INSERT INTO t1 (a, t2 ~> fk ~> a) VALUES (2, 44), (3, 11)\n\t\t// INSERT INTO t1 (a, t2 ~> fk ~> a) SELECT a, b FROM t3\n\n\t\tconst offload = (payload, rowOffset) => {\n\t\t\tif (payload instanceof ValuesSetConstructor) {\n\t\t\t\tthrow new Error(`Single-row payload structure expected for column structure: ${LQRefColumn.right()}. Recieved ${payload.NODE_NAME}.`);\n\t\t\t}\n\t\t\tif (query.values_clause.entries.length || query.select_clause) {\n\t\t\t\tthrow new Error(`Unexpected offload() call on ${LQRefColumn}`);\n\t\t\t}\n\t\t\tif (payload instanceof CompleteSelectStmt) {\n\t\t\t\tdimensionValidateRowLength(payload);\n\t\t\t\tdelete query.values_clause;\n\t\t\t\tquery.select_clause = payload.jsonfy($options);\n\t\t\t} else dimensionPushRow(payload);\n\t\t\t// The binding element...\n\t\t\tconst rightPKJson = { nodeName: ColumnRef.NODE_NAME, value: right.value() };\n\t\t\tconst fKBindingJson = createForeignBinding(query.uuid, rightPKJson, rowOffset);\n\t\t\treturn fKBindingJson;\n\t\t};\n\n\t\tconst payloadDimension = {\n\t\t\tid: dimensionID,\n\t\t\ttype: 'dependency',\n\t\t\tquery,\n\t\t\toffload,\n\t\t\tleftJson\n\t\t};\n\n\t\tpayloadDimensions\n\t\t\t?.add(payloadDimension);\n\n\t\treturn payloadDimension;\n\t}\n\n\tapplyPayloadDimensions(resultJson, payloadDimensions, options) {\n\t\tconst cte = { nodeName: CTE.NODE_NAME, bindings: [], body: null };\n\n\t\t// Promote a query to a CTEBinding\n\t\tconst toBinding = (dimensionID, queryJson) => {\n\t\t\t// Desugar query and flatten if itself a CTE\n\t\t\tif (queryJson.nodeName === CTE.NODE_NAME) {\n\t\t\t\tcte.bindings.push(...queryJson.bindings);\n\t\t\t\tqueryJson = queryJson.body;\n\t\t\t}\n\t\t\t// Compose binding and add...\n\t\t\tcte.bindings.push({\n\t\t\t\tnodeName: CTEBinding.NODE_NAME,\n\t\t\t\talias: { nodeName: CompositeAlias.NODE_NAME, value: dimensionID },\n\t\t\t\texpr: queryJson,\n\t\t\t});\n\t\t};\n\t\tconst fromJSON = (queryJson, options) => {\n\t\t\tfor (const Class of [UpdateStmt, InsertStmt, UpsertStmt]) {\n\t\t\t\tconst node = Class.fromJSON(queryJson, options);\n\t\t\t\tif (node) return node;\n\t\t\t}\n\t\t};\n\n\t\t// (1): Process non-dependent entries\n\t\tconst dependents = [], lefts = [];\n\t\tlet onConflictUpdatedStatusRequired;\n\t\tfor (const { id: dimensionID, type, query, leftJson, onConflictClauseContext } of payloadDimensions) {\n\t\t\t// Defer dependents\n\t\t\tif (type === 'dependent') {\n\t\t\t\tif (!lefts.find((existing) => _eq(existing, leftJson))) {\n\t\t\t\t\tlefts.push(leftJson);\n\t\t\t\t}\n\t\t\t\tif (onConflictClauseContext) {\n\t\t\t\t\tonConflictUpdatedStatusRequired = true;\n\t\t\t\t}\n\t\t\t\tdependents.push({ id: dimensionID, query });\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// Desugar query and flatten if itself a CTE\n\t\t\ttoBinding(dimensionID, fromJSON(query, this.options).jsonfy(options));\n\t\t}\n\n\t\t// (2): Rewrite resultJson as a CTEBinding?\n\t\tif (dependents.length) {\n\t\t\t// Rewrite returning clause\n\t\t\tconst originalPGReturningClause = resultJson.returning_clause;\n\n\t\t\t// Compose binding and add...\n\t\t\tconst newPGReturningClause = { nodeName: PGReturningClause.NODE_NAME, entries: [...lefts] };\n\t\t\tif (onConflictUpdatedStatusRequired) {\n\t\t\t\tconst onConflictUpdatedStatusAlias = `${this.uuid}_on_conflict_updated_status`;\n\t\t\t\t// TODO\n\t\t\t}\n\t\t\ttoBinding(this.uuid, { ...resultJson, returning_clause: newPGReturningClause });\n\n\t\t\t// Process dependents... after having done the above\n\t\t\tfor (const { id: dimensionID, query } of dependents) {\n\t\t\t\ttoBinding(dimensionID, fromJSON(query, this.options).jsonfy(options));\n\t\t\t}\n\n\t\t\t// Derive final body...\n\t\t\tconst tableSpec = { nodeName: FromElement.NODE_NAME, expr: { nodeName: TableRef.NODE_NAME, value: this.uuid } };\n\t\t\tcte.body = {\n\t\t\t\tnodeName: CompleteSelectStmt.NODE_NAME,\n\t\t\t\tselect_list: originalPGReturningClause.entries,\n\t\t\t\tfrom_clause: { nodeName: FromClause.NODE_NAME, entries: [tableSpec] },\n\t\t\t};\n\t\t} else {\n\t\t\t// Use resultJson as-is\n\t\t\tcte.body = resultJson;\n\t\t}\n\n\t\treturn cte;\n\t}\n}", "import { PayloadStmtMixin } from '../abstracts/PayloadStmtMixin.js';\nimport { AbstractNonDDLStmt } from '../abstracts/AbstractNonDDLStmt.js';\n\nexport class InsertStmt extends PayloadStmtMixin(\n\tAbstractNonDDLStmt\n) {\n\n\t/* SYNTAX RULES */\n\n\tstatic get _clause() { return 'INSERT'; }\n\n\tstatic get syntaxRules() {\n\t\tconst itemSeparator = { type: 'punctuation', value: ',' };\n\t\tconst optional_alias_mysql = {\n\t\t\toptional: true,\n\t\t\tdialect: 'mysql',\n\t\t\tif: ['!select_clause', '!my_table_clause'],\n\t\t\tsyntax: [\n\t\t\t\t{ type: 'keyword', value: 'AS' },\n\t\t\t\t{ type: 'CompositeAlias', as: 'my_alias', assert: true }\n\t\t\t]\n\t\t};\n\t\treturn [\n\t\t\t{ type: 'keyword', value: this._clause },\n\t\t\t{ type: 'keyword', value: 'INTO' },\n\t\t\t{\n\t\t\t\tassert: true,\n\t\t\t\tsyntax: [\n\t\t\t\t\t{\n\t\t\t\t\t\tdialect: 'postgres',\n\t\t\t\t\t\tsyntax: [\n\t\t\t\t\t\t\t{ type: 'BasicTableExpr', as: 'table_expr' },\n\t\t\t\t\t\t\t{ type: 'ColumnsConstructor', as: 'column_list', arity: { min: 1 }, itemSeparator, optional: true, autoIndent: 2 },\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tsyntaxes: [\n\t\t\t\t\t\t\t\t\t{ type: 'PGDefaultValuesClause', as: 'pg_default_values_clause', autoIndent: true },\n\t\t\t\t\t\t\t\t\t{ type: 'ValuesConstructor', as: 'values_clause', autoIndent: true },\n\t\t\t\t\t\t\t\t\t{ type: 'SelectStmt', as: 'select_clause', autoIndent: true },\n\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t...(this._clause === 'INSERT' ? [{ type: 'PGOnConflictClause', as: 'conflict_handling_clause', optional: true, autoIndent: true }] : []),\n\t\t\t\t\t\t\t{ type: 'PGReturningClause', as: 'pg_returning_clause', optional: true, autoIndent: true },\n\t\t\t\t\t\t],\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tdialect: 'mysql',\n\t\t\t\t\t\tsyntax: [\n\t\t\t\t\t\t\t{ type: 'TableRef', as: 'table_expr' },\n\t\t\t\t\t\t\t{ type: 'MYPartitionClause', as: 'my_partition_clause', optional: true, autoIndent: true },\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tsyntaxes: [\n\t\t\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t\t{ type: 'ColumnsConstructor', as: 'column_list', arity: { min: 1 }, itemSeparator, optional: true, autoIndent: 2 },\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tsyntaxes: [\n\t\t\t\t\t\t\t\t\t\t\t\t{ type: 'ValuesConstructor', as: 'values_clause', autoIndent: true },\n\t\t\t\t\t\t\t\t\t\t\t\t{ type: 'SelectStmt', as: 'select_clause', autoIndent: true },\n\t\t\t\t\t\t\t\t\t\t\t\t{ type: 'TableStmt', as: 'my_table_clause', autoIndent: true },\n\t\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\t{ type: 'SetClause', as: 'my_set_clause', autoIndent: true },\n\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{ ...optional_alias_mysql },\n\t\t\t\t\t\t\t...(this._clause === 'INSERT' ? [{ type: 'MYOnDuplicateKeyUpdateClause', as: 'conflict_handling_clause', optional: true, autoIndent: true }] : []),\n\t\t\t\t\t\t],\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t}\n\t\t];\n\t}\n\n\t/* AST API */\n\n\ttableExpr() { return this._get('table_expr'); }\n\n\tcolumnList() { return this._get('column_list'); }\n\n\tvaluesClause() { return this._get('values_clause'); }\n\n\tselectClause() { return this._get('select_clause'); }\n\n\tconflictHandlingClause() { return this._get('conflict_handling_clause'); }\n\n\t// -- Postgres\n\n\tpgDefaultValuesClause() { return this._get('pg_default_values_clause'); }\n\n\tpgPGReturningClause() { return this._get('pg_returning_clause'); }\n\n\t// -- MySQL\n\n\tmyAlias() { return this._get('my_alias'); }\n\n\tmyPartitionClause() { return this._get('my_partition_clause'); }\n\n\tmySetClause() { return this._get('my_set_clause'); }\n\n\tmyTableClause() { return this._get('my_table_clause'); }\n}", "import { AbstractNodeList } from '../abstracts/AbstractNodeList.js';\n\nexport class MYSetStmt extends AbstractNodeList {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'keyword', value: 'SET' },\n            { type: 'MYVarAssignmentExpr', as: 'entries', arity: { min: 1 }, itemSeparator, assert: true, autoIndent: 2 },\n        ];\n    }\n}", "import { SelectorStmtMixin } from '../abstracts/SelectorStmtMixin.js';\nimport { PayloadStmtMixin } from '../abstracts/PayloadStmtMixin.js';\nimport { AbstractNonDDLStmt } from '../abstracts/AbstractNonDDLStmt.js';\nimport { registry } from '../registry.js';\n\nconst {\n    SubqueryConstructor,\n    CompleteSelectStmt,\n    SelectElement,\n    BasicAlias,\n    CompositeAlias,\n    FromClause,\n    WhereClause,\n    ColumnRef,\n    TableAbstractionRef,\n    BinaryExpr,\n    TableRef,\n    FromElement,\n} = registry;\n\nexport class UpdateStmt extends PayloadStmtMixin/* Must be outer as can morph to a CTE */(SelectorStmtMixin(\n    AbstractNonDDLStmt\n)) {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'keyword', value: 'UPDATE' },\n            {\n                assert: true,\n                syntaxes: [\n                    {\n                        dialect: 'postgres',\n                        syntax: [\n                            { type: 'BasicTableExpr', as: 'table_expr' },\n                            { type: 'SetClause', as: 'set_clause' },\n                            { type: 'FromClause', as: 'pg_from_clause', optional: true, dialect: 'postgres', autoIndent: true },\n                            { type: 'JoinClause', as: 'join_clause', optional: true, autoIndent: true },\n                            { type: ['PGWhereCurrentClause', 'WhereClause'], as: 'where_clause', optional: true, autoIndent: true },\n                            { type: 'PGReturningClause', as: 'pg_returning_clause', optional: true, autoIndent: true },\n                        ],\n                    },\n                    {\n                        dialect: 'mysql',\n                        syntax: [\n                            { type: 'BasicTableExpr', as: 'table_expr' },\n                            { type: 'SetClause', as: 'set_clause' },\n                            { type: 'WhereClause', as: 'where_clause', optional: true, autoIndent: true },\n                            { type: 'OrderByClause', as: 'my_order_by_clause', optional: true, autoIndent: true },\n                            { type: 'LimitClause', as: 'my_limit_clause', optional: true, autoIndent: true },\n                        ],\n                    },\n                    {\n                        dialect: 'mysql',\n                        syntax: [\n                            { type: 'MYStarredTableRef', as: 'my_update_list', arity: { min: 1 }, itemSeparator },\n                            { type: 'JoinClause', as: 'join_clause', optional: true, autoIndent: true },\n                            { type: 'SetClause', as: 'set_clause' },\n                            { type: 'WhereClause', as: 'where_clause', optional: true, autoIndent: true },\n                        ],\n                    },\n                ]\n            }\n        ];\n    }\n\n    /* AST API */\n\n    tableExpr() { return this._get('table_expr'); }\n\n    joinClause() { return this._get('join_clause'); }\n\n    setClause() { return this._get('set_clause'); }\n\n    whereClause() { return this._get('where_clause'); }\n\n    // Postgres\n\n    pgFromClause() { return this._get('pg_from_clause'); }\n\n    pgPGReturningClause() { return this._get('pg_returning_clause'); }\n\n    // MySQL\n\n    myUpdateList() { return this._get('my_update_list'); }\n\n    myOrderByClause() { return this._get('my_order_by_clause'); }\n\n    myLimitClause() { return this._get('my_limit_clause'); }\n\n    /* DESUGARING API */\n\n    jsonfy(options = {}) {\n        if (!options.deSugar) return super.jsonfy(options);\n\n        // Define our transformer\n        const selectorDimensions = new Map;\n        const transformCallback = (node, keyHint, { deSugar/* IMPORTANT */, ...$options }) => {\n            // LQDeepRef\n            if (deSugar && node instanceof LQDeepRef) {\n                const { select } = this.deSugarLQRef(selectorDimensions, node, $options);\n                return select(node.right());\n            }\n            // LQBackRef, LQBackRefConstructor\n            if (deSugar && (node instanceof LQBackRef || node instanceof LQBackRefConstructor)) {\n                if (node instanceof LQBackRefConstructor) {\n                    node = node.expr();\n                }\n                const { alias } = this.deSugarLQRef(selectorDimensions, node, $options);\n                return alias();\n            }\n            // Other\n            return node;\n        };\n\n        // Jsonfy with transformCallback as optional visitor\n        let resultJson = super.jsonfy(options, transformCallback);\n\n        // Inject selectorDimensions into resultJson\n        if (selectorDimensions.size) {\n            resultJson = this.applySelectorDimensions(resultJson, selectorDimensions, options);\n        }\n        return resultJson;\n    }\n\n    applySelectorDimensions(resultJson, selectorDimensions, options) {\n        // This is Postgres-specific\n        if (this.options.dialect !== 'postgres') {\n            return super/* SelectorStmtMixin */.applySelectorDimensions(resultJson, selectorDimensions, options);\n        }\n\n        if (resultJson.where_clause?.cursor_name) {\n            throw new Error(`Deep/Back Refs are currently not supported with a \"WHERE CURRENT OF...\" statement`);\n        }\n\n        const rand = this._rand('rand');\n\n        // Each table involved in a Deep/BackRef should have a corresponding entry\n        // in the \"FROM\" list where we have the chance to establish our JOIN\n        // with a corresponding extra \"WHERE\" clause that correlates the generated table with the original table\n\n        let pgGeneratedFromEntry;\n        const createOrPatchAFromEntry = (columnRef) => {\n\n            const tableExpr = resultJson.table_expr;\n            const tblRefOriginal = tableExpr.name.value;\n            const tblAliasOriginal = tableExpr.alias ? tableExpr.alias.value : tableExpr.name.value;\n            const colRefOriginal = columnRef.value;\n\n            if (columnRef.qualifier.value !== tblAliasOriginal) return columnRef;\n\n            const tblAliasRewrite = `${rand}::${tblAliasOriginal}`;\n            const colRefRewrite = `${rand}::${colRefOriginal}`;\n\n            if (!pgGeneratedFromEntry) {\n                // Compose:\n                // - ( SELECT [] FROM <tblRefOriginal> )\n                // - AS <tblAliasRewrite>\n                const fromEntry = {\n                    nodeName: FromElement.NODE_NAME,\n                    expr: {\n                        nodeName: SubqueryConstructor.NODE_NAME,\n                        expr: {\n                            // SELECT <...>\n                            nodeName: CompleteSelectStmt.NODE_NAME,\n                            select_list: [],\n                            pg_from_clause: {\n                                // FROM <tblRefOriginal>\n                                nodeName: FromClause.NODE_NAME,\n                                entries: [{\n                                    nodeName: FromElement.NODE_NAME,\n                                    expr: { nodeName: TableRef.NODE_NAME, value: tblRefOriginal }\n                                }]\n                            },\n                        },\n                    },\n                    // AS <tblAliasRewrite>\n                    as_kw: true,\n                    alias: { nodeName: CompositeAlias.NODE_NAME, value: tblAliasRewrite },\n                };\n\n                // Compose:\n                // - WHERE <tblAliasOriginal.colRefOriginal> = <tblAliasRewrite.colRefRewrite>\n                const whereClause = {\n                    nodeName: BinaryExpr.NODE_NAME,\n                    left: {\n                        nodeName: ColumnRef.NODE_NAME,\n                        qualifier: { nodeName: TableAbstractionRef.NODE_NAME, value: tblAliasOriginal },\n                        value: colRefOriginal\n                    },\n                    operator: '=',\n                    right: {\n                        nodeName: ColumnRef.NODE_NAME,\n                        qualifier: { nodeName: TableAbstractionRef.NODE_NAME, value: tblAliasRewrite },\n                        value: colRefRewrite\n                    }\n                };\n\n                // Add entry...\n                pgGeneratedFromEntry = { from: fromEntry, where: whereClause };\n            }\n\n            // Select the rewritten ref\n            pgGeneratedFromEntry.from.expr.expr.select_list.push({\n                nodeName: SelectElement.NODE_NAME,\n                expr: { nodeName: ColumnRef.NODE_NAME, value: colRefOriginal },\n                alias: { nodeName: BasicAlias.NODE_NAME, value: colRefRewrite }\n            });\n\n            // Return the rewritten ref\n            return {\n                nodeName: ColumnRef.NODE_NAME,\n                qualifier: { nodeName: TableAbstractionRef.NODE_NAME, value: tblAliasRewrite },\n                value: colRefRewrite,\n            };\n        };\n\n        // (1)\n        // Inject the generated joins\n        resultJson = {\n            ...resultJson,\n            join_clauses: resultJson.join_clauses?.slice(0) || []\n        };\n\n        // Rewrite original references as FROM entry references\n        for (const [, { query: joinJson }] of selectorDimensions) {\n            const binaryExpr = { ...joinJson.condition_clause/* OnClause */.expr };\n            binaryExpr.left = createOrPatchAFromEntry(binaryExpr.left);\n            resultJson.join_clauses.push(joinJson);\n        }\n\n        // (2)\n        // Inject the \"FROM\" list generated by createOrPatchAFromEntry()\n        if (pgGeneratedFromEntry) {\n            resultJson = {\n                ...resultJson,\n                pg_from_clause: {\n                    nodeName: FromClause.NODE_NAME,\n                    entries: resultJson.pg_from_clause?.entries?.slice(0) || []\n                }\n            };\n            // ...each a SubqueryConstructor\n            resultJson.pg_from_clause.entries.push(pgGeneratedFromEntry.from);\n            // The \"WHERE\" clause for correlation\n            if (resultJson.where_clause) {\n                resultJson.where_clause = {\n                    nodeName: WhereClause.NODE_NAME,\n                    expr: {\n                        nodeName: BinaryExpr.NODE_NAME,\n                        operator: 'AND',\n                        left: resultJson.where_clause.expr,\n                        right: pgGeneratedFromEntry.where\n                    }\n                };\n            } else {\n                resultJson.where_clause = { nodeName: WhereClause.NODE_NAME, expr: pgGeneratedFromEntry.where };\n            }\n        }\n\n        return resultJson;\n    }\n}", "export const SugarMixin = Class => class extends Class {\n    get isSugar() { return true; }\n}", "import { SugarMixin } from '../abstracts/SugarMixin.js';\nimport { InsertStmt } from './InsertStmt.js';\n\nexport class UpsertStmt extends SugarMixin(InsertStmt) {\n\n\t/* SYNTAX RULES */\n\n\tstatic get _clause() { return 'UPSERT'; }\n\n\t/* DESUGARING API */\n\t\n    jsonfy(options = {}) {\n\t\tif (!options.deSugar) return super.jsonfy(options);\n\n\t\tif (this.conflictHandlingClause()) {\n\t\t\tthrow new Error(`A redundanct \"ON CONFLICT\" clause in query.`);\n\t\t}\n\t\tconst resultJson = super.jsonfy(options);\n\n\t\t// So let's auto-construct the on-conflict clause for the operation\n\t\tconst columns = (this.set() ? this.set().columns() : this.columns().entries()).map(c => c.name());\n\t\tconst refFn = this.params.dialect === 'mysql' ? col => q => q.fn('VALUES', col) : col => ['EXCLUDED', col];\n\t\tconst onConflictClause = OnConflictClause.fromJSON(this, { entries: [] });\n\t\tfor (const col of columns) onConflictClause.add([col, refFn(col)]);\n\t\t// Postgres requires conflict conditions to be specified\n\t\tif (this.params.dialect !== 'mysql') {\n\t\t\tconst tblSchema = this.into().schema();\n\t\t\tconst uniqueKeys = [].concat(tblSchema.primaryKey() || []).concat(tblSchema.uniqueKeys()).map(uk => uk.columns());\n\t\t\tif (!uniqueKeys.length) throw new Error(`Table ${ this.into().clone({ fullyQualified: true }) } has no unique keys defined to process an UPSERT operation. You may want to perform a direct INSERT operation.`);\n\t\t\tconst conflictTarget = uniqueKeys.find(keyComp => _intersect(keyComp, columns).length) || uniqueKeys[0];\n\t\t\tonConflictClause.columnsSpec(...conflictTarget);\n\t\t}\n        return {\n            nodeName: InsertStatement.NODE_NAME,\n\t\t\t...superJson,\n\t\t\tonConflictClause: onConflictClause.jsonfy(options),\n\t\t\t...(flags ? { flags } : {})\n        };\n\t}\n}", "export * from './constructors/index.js';\nexport * from './constructs/index.js';\nexport { CompleteSelectStmt } from './CompleteSelectStmt.js';\nexport { BasicSelectStmt } from './BasicSelectStmt.js';\nexport { CompositeSelectStmt } from './CompositeSelectStmt.js';\nexport { SelectStmt } from './SelectStmt.js';\nexport { TableStmt } from './TableStmt.js';\n", "import { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\n\nexport class FunctionsSetConstructor extends AbstractNodeList {\n        \n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'keyword', value: 'ROWS' },\n            { type: 'keyword', value: 'FROM' },\n            {\n                type: 'paren_block',\n                syntax: { type: 'SRFSpec', as: 'entries', arity: { min: 1 }, itemSeparator, assert: true, autoIndent: 2 },\n                autoIndent: true,\n                autoSpacing: false\n            }\n        ];\n    }\n    \n    static get syntaxPriority() { return -1; }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class ParenShape extends AbstractNode {   \n        \n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            type: 'paren_block',\n            syntax: { type: 'Expr', as: 'expr' },\n            autoIndent: true,\n        };\n    }\n\n    static get syntaxPriority() { return -1; }\n\n    /* AST API */\n\n    expr() { return this._get('expr'); }\n\n    exprUnwrapped() {\n        const expr = this._get('expr');\n        if (expr instanceof ParenShape) {\n            return expr.exprUnwrapped();\n        }\n        return expr;\n    }\n}", "import { ParenShape } from '../../expr/shape/ParenShape.js';\nimport { registry } from '../../registry.js';\n\nconst {\n\tLQBackRef,\n} = registry;\n\nexport class LQBackRefConstructor extends ParenShape {\n\n\t/* SYNTAX RULES */\n\n\tstatic get syntaxRules() {\n\t\treturn { type: 'paren_block', syntax: { type: 'Expr', as: 'expr', peek: [1, 'operator', '<~'] } };\n\t}\n\n\tstatic get syntaxPriority() { return 51; } // Above SetConstructor\n\n\tstatic morphsTo() { return this.expr()?.constructor().morphsTo(); }\n\n\t/* SYSTEM HOOKS */\n\n\t_capture(requestName, requestSource) {\n\t\tif (requestName === 'CONTEXT.TABLE_SCHEMA') {\n\t\t\treturn this.tableSchema();\n\t\t}\n\t\treturn super._capture(requestName, requestSource);\n\t}\n\n\t/* API */\n\n\texpr() { return this._get('expr'); }\n\n\ttableSchema() {\n\t\tconst expr = this.expr();\n\t\tif (!(expr instanceof LQBackRef)) {\n\t\t\tthrow new Error(`[${this.constructor.name}.<expr>] Expects an instance of LQBackRef but got ${expr?.constructor.name}`);\n\t\t}\n\t\treturn expr.tableSchema();\n\t}\n\n\tjsonfy(options = {}, transformCallback = null) {\n\t\tif (options.deSugar) {\n\t\t\tconst expr = this.expr();\n\t\t\tif (!(expr instanceof LQBackRef)) {\n\t\t\t\tthrow new Error(`[${this.constructor.name}.<expr>] Expects an instance of LQBackRef but got ${expr?.constructor.name}`);\n\t\t\t}\n\t\t\treturn expr.jsonfy(options, transformCallback);\n\t\t}\n\t\treturn super.jsonfy(options, transformCallback);\n\t}\n}", "import { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\n\nexport class SetConstructor extends AbstractNodeList {\n        \n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return {\n            syntax: [\n                {\n                    type: 'paren_block',\n                    syntax: { type: 'Expr', as: 'entries', arity: Infinity, itemSeparator, autoIndent: 2 },\n                    autoIndent: true,\n                    autoIndentAdjust: -1,\n                },\n            ],\n        };\n    }\n\n    static get syntaxPriority() { return 49; } // Below all () shapes like SubqueryConstructor and LQBackRefConstructor\n}", "import { SetConstructor } from './SetConstructor.js';\n\nexport class RowConstructor extends SetConstructor {\n        \n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', value: 'ROW' },\n            ...[].concat(super.syntaxRules)\n        ];\n    }\n}", "import { ParenShape } from '../../expr/shape/ParenShape.js';\n\nexport class SubqueryConstructor extends ParenShape {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            type: 'paren_block',\n            syntax: { type: ['SelectStmt', 'InsertStmt', 'UpsertStmt', 'UpdateStmt', 'DeleteStmt', 'CTE'], as: 'expr' },\n            autoIndent: true,\n        };\n    }\n    \n    static get syntaxPriority() { return 51; } // Above SetConstructor\n}", "import { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\n\nexport class ValuesConstructor extends AbstractNodeList {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return {\n            syntaxes: [\n                [\n                    { type: 'keyword', value: 'VALUES' },\n                    { type: 'SetConstructor', as: 'entries', arity: { min: 1 }, itemSeparator, assert: true }\n                ],\n                {\n                    dialect: 'mysql',\n                    syntax: [\n                        { type: 'keyword', value: ['VALUES', 'VALUE'] },\n                        { type: 'SetConstructor', as: 'entries', arity: { min: 1 }, itemSeparator, assert: true }\n                    ]\n                },\n            ],\n        };\n    }\n\n    static get syntaxPriority() { return -1; }\n}", "import { ValuesConstructor } from './ValuesConstructor.js';\n\nexport class ValuesSetConstructor extends ValuesConstructor {\n        \n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return { type: 'paren_block', syntax: super.syntaxRules, autoIndent: true };\n    }\n    \n    static get syntaxPriority() { return -1; }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class Identifier extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() { return { type: 'identifier', as: '.' }; }\n\n    static get syntaxPriority() { return -1; }\n\n    /* AST API */\n\n    value() { return this._get('value'); }\n\n    /* API */\n\n    identifiesAs(value) {\n        if (typeof value === 'string') {\n            return this._eq(this._get('value'), value, 'ci');\n        }\n        return super.identifiesAs(value);\n    }\n}", "import { Identifier } from '../../expr/ref/Identifier.js';\n\nexport class BasicAlias extends Identifier {\n    static get syntaxRules() {\n        return [\n            ...[].concat(super.syntaxRules),\n            { type: 'AggrNotation', as: 'is_aggr', autoSpacing: false, optional: true },\n        ];\n    }\n\n    /* AST API */\n\n    isAggr() { return this._get('is_aggr'); }\n}", "import { Identifier } from '../../expr/ref/Identifier.js';\n\nexport class CompositeAlias extends Identifier {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return {\n            syntaxes: [\n                [\n                    { ...[].concat(super.syntaxRules)[0] },\n                    {\n                        type: 'paren_block',\n                        syntax: { type: 'Identifier', as: 'columns', arity: { min: 1 }, itemSeparator, assert: true },\n                        if: 'value',\n                        optional: true,\n                        optionalParens: true,\n                    }\n                ],\n                {\n                    type: 'paren_block',\n                    syntax: { type: 'Identifier', as: 'columns', arity: { min: 1 }, itemSeparator, assert: true },\n                },\n            ],\n        };\n    }\n\n    /* AST API */\n\n    columns() { return this._get('columns'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class DistinctClause extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return {\n            syntaxes: [\n                {\n                    dialect: 'postgres',\n                    syntax: [\n                        { type: 'keyword', value: 'DISTINCT' },\n                        { type: 'keyword', value: 'ON' },\n                        {\n                            type: 'paren_block',\n                            syntax: { type: 'Expr', as: 'pg_distinct_on_list', arity: { min: 1 }, itemSeparator, assert: true }\n                        },\n                    ],\n                },\n                { type: 'keyword', as: 'all_or_distinct', value: ['ALL', 'DISTINCT'] },\n            ]\n        };\n    }\n\n    /* AST API */\n\n    allOrDistinct() { return this._get('all_or_distinct'); }\n\n    // -- Postgres\n\n    pgDistinctOnList() { return this._get('pg_distinct_on_list'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class ForClause extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'keyword', value: 'FOR' },\n            {\n                optional: true,\n                dialect: 'postgres',\n                syntaxes: [\n                    [\n                        { type: 'keyword', as: 'pg_no_key_kw', value: 'NO', booleanfy: true },\n                        { type: 'keyword', value: 'KEY', if: 'pg_no_key_kw', assert: true }\n                    ],\n                    { type: 'keyword', as: 'pg_key_kw', value: 'KEY', booleanfy: true },\n                ],\n            },\n            { type: 'keyword', as: 'intent_kw', value: ['UPDATE', 'SHARE'], assert: true },\n            {\n                optional: true,\n                syntax: [\n                    { type: 'keyword', value: 'OF' },\n                    { type: 'TableAbstractionRef', as: 'table_names', arity: { min: 1 }, itemSeparator, assert: true }\n                ],\n            },\n            {\n                optional: true,\n                syntaxes: [\n                    [\n                        { type: 'keyword', as: 'skip_locked_kw', value: 'SKIP', booleanfy: true },\n                        { type: 'keyword', value: 'LOCKED', assert: true }\n                    ],\n                    { type: 'keyword', as: 'nowait_kw', value: 'NOWAIT', booleanfy: true },\n                    {\n                        dialect: 'mysql',\n                        syntax: [\n                            { type: 'keyword', as: 'my_lock_in_share_mode', value: 'LOCK', booleanfy: true },\n                            { type: 'operator', value: 'IN', assert: true },\n                            { type: 'keyword', value: 'SHARE', assert: true },\n                            { type: 'keyword', value: 'MODE', assert: true },\n                        ],\n                    },\n                ],\n            }\n        ];\n    }\n\n    /* AST API */\n\n    intentKW() { return this._get('intent_kw'); }\n\n    tableNames() { return this._get('table_names'); }\n\n    skipLockedKW() { return this._get('skip_locked_kw'); }\n\n    nowaitKW() { return this._get('nowait_kw'); }\n\n    // -- Postgres\n\n    pgKeyKW() { return this._get('pg_key_kw'); }\n\n    pgNoKeyKW() { return this._get('pg_no_key_kw'); }\n\n    // -- MySQL\n\n    myLockInShareMode() { return this._get('my_lock_in_share_mode'); }\n}", "import { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\n\nexport class FromClause extends AbstractNodeList {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'keyword', value: 'FROM' },\n            { type: 'FromElement', as: 'entries', arity: { min: 1 }, itemSeparator, assert: true }\n        ];\n    }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class FromElement extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        const optional_alias = {\n            optional: true,\n            syntaxes: [\n                { type: 'CompositeAlias', as: 'alias' },\n                [\n                    { type: 'keyword', as: 'as_kw', value: 'AS', booleanfy: true },\n                    { type: 'CompositeAlias', as: 'alias', assert: true }\n                ]\n            ]\n        };\n        const optional_table_sample_clause_postgres = {\n            optional: true,\n            dialect: 'postgres',\n            syntax: [\n                { type: 'keyword', value: 'TABLESAMPLE' },\n                {\n                    syntaxes: [\n                        [\n                            { type: 'keyword', as: 'pg_sampling_method', value: ['BERNOULLI', 'SYSTEM'] },\n                            { type: 'paren_block', syntax: { type: 'Expr', as: 'pg_sampling_arguments', arity: 1, itemSeparator, assert: true } },\n                        ],\n                        [\n                            { type: 'identifier', as: 'pg_sampling_method' },\n                            { type: 'paren_block', syntax: { type: 'Expr', as: 'pg_sampling_arguments', arity: Infinity, itemSeparator, assert: true } },\n                        ],\n                    ],\n                    assert: true,\n                },\n                {\n                    optional: true,\n                    syntax: [\n                        { type: 'keyword', value: 'REPEATABLE' },\n                        { type: 'paren_block', syntax: { type: 'Expr', as: 'pg_repeatable_seed' }, assert: true },\n                    ]\n                }\n            ]\n        };\n        const optional_with_ordinality_clause_postgres = {\n            optional: true,\n            dialect: 'postgres',\n            syntax: [\n                { type: 'keyword', as: 'pg_with_ordinality', value: 'WITH', booleanfy: true },\n                { type: 'keyword', value: 'ORDINALITY', assert: true },\n            ]\n        };\n\n        return {\n            syntaxes: [\n                [\n                    { type: 'keyword', as: 'lateral_kw', value: 'LATERAL', optional: true },\n                    { type: 'CallExpr', as: 'expr' },\n                    { ...optional_alias, optional: false },\n                ],\n                {\n                    dialect: 'postgres',\n                    syntax: [\n                        { type: 'keyword', as: 'lateral_kw', value: 'LATERAL', optional: true },\n                        { type: ['FunctionsSetConstructor', 'CallExpr'], as: 'expr' },\n                        { ...optional_with_ordinality_clause_postgres },\n                        { ...optional_alias },\n                    ],\n                },\n                [\n                    { type: 'keyword', as: 'lateral_kw', value: 'LATERAL', optional: true },\n                    { type: ['SubqueryConstructor', 'ValuesSetConstructor'], as: 'expr', dialect: 'postgres' },\n                    { type: 'SubqueryConstructor', as: 'expr', dialect: 'mysql' },\n                    { ...optional_alias },\n                ],\n                [\n                    { type: 'keyword', as: 'pg_only_kw', value: 'ONLY', optional: true, dialect: 'postgres' },\n                    { type: 'TableRef', as: 'expr' },\n                    { type: 'StarRef', as: 'pg_star_ref', optional: true, dialect: 'postgres' },\n                    { ...optional_alias },\n                    { ...optional_table_sample_clause_postgres },\n                ],\n            ],\n        };\n    }\n\n    /* AST API */\n\n    expr() { return this._get('expr'); }\n\n    lateralKW() { return this._get('lateral_kw'); }\n\n    asKW() { return this._get('as_kw'); }\n\n    alias() { return this._get('alias'); }\n\n    // -- Postgres\n\n    pgOnlyKW() { return this._get('pg_only_kw'); }\n\n    pgStarRef() { return this._get('pg_star_ref'); }\n\n    pgSamplingMethod() { return this._get('pg_sampling_method'); }\n\n    pgSamplingArguments() { return this._get('pg_sampling_arguments'); }\n\n    pgRepeatableSeed() { return this._get('pg_repeatable_seed'); }\n\n    pgWithOrdinality() { return this._get('pg_with_ordinality'); }\n}", "import { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\n\nexport class GroupByClause extends AbstractNodeList {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'keyword', value: 'GROUP' },\n            { type: 'keyword', value: 'BY', assert: true },\n            { type: 'keyword', as: 'all_or_distinct', value: ['ALL', 'DISTINCT'], optional: true },\n            { type: 'GroupingElement', as: 'entries', arity: { min: 1 }, itemSeparator, assert: true, autoIndent: 2 },\n            {\n                optional: true,\n                autoIndent: true,\n                syntax: [\n                    { type: 'keyword', as: 'with_rollup', value: 'WITH', booleanfy: true },\n                    { type: 'keyword', value: 'ROLLUP', assert: true },\n                ]\n            },\n        ];\n    }\n\n    /* AST API */\n\n    allOrDistinct() { return this._get('all_or_distinct'); }\n\n    withRollup() { return this._get('with_rollup'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class GroupingElement extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return {\n            syntaxes: [\n                [\n                    { type: 'keyword', value: 'GROUPING SETS' },\n                    {\n                        type: 'paren_block', syntax:\n                            { type: 'GroupingElement', as: 'grouping_sets', arity: { min: 1 }, itemSeparator, assert: true, autoIndent: 2 },\n                        autoIndent: true\n                    }\n                ],\n                [\n                    { type: 'keyword', value: 'ROLLUP' },\n                    { type: 'SetConstructor', as: 'rollup_set', assert: true },\n                ],\n                [\n                    { type: 'keyword', value: 'CUBE' },\n                    { type: 'SetConstructor', as: 'cube_set', assert: true },\n                ],\n                { type: ['Expr', 'ParenShape'], as: 'expr' },\n            ]\n        };\n    }\n\n    /* AST API */\n\n    groupingSets() { return this._get('grouping_sets'); }\n\n    rollupSet() { return this._get('rollup_set'); }\n\n    cubeSet() { return this._get('cube_set'); }\n\n    expr() { return this._get('expr'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class HavingClause extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', value: 'HAVING' },\n            { type: 'Expr', as: 'expr', assert: true }\n        ];\n    }\n\n    static get syntaxPriority() { return -1; }\n\n    /* AST API */\n\n    expr() { return this._get('expr'); }\n}", "import { FromElement } from './FromElement.js';\n\nexport class JoinClause extends FromElement {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            syntaxes: [\n                [\n                    { type: 'keyword', as: 'join_type', value: 'CROSS' },\n                    { type: 'keyword', value: 'JOIN', assert: true },\n                    ...[].concat(super.syntaxRules),\n                ],\n                [\n                    { type: 'keyword', as: 'natural_kw', value: 'NATURAL', booleanfy: true, optional: true },\n                    {\n                        optional: true,\n                        syntaxes: [\n                            { type: 'keyword', as: 'join_type', value: 'INNER' },\n                            [\n                                { type: 'keyword', as: 'join_type', value: ['LEFT', 'RIGHT', 'FULL'], dialect: 'postgres' },\n                                { type: 'keyword', as: 'join_type', value: ['LEFT', 'RIGHT'], dialect: 'mysql' },\n                                { type: 'keyword', as: 'outer_kw', value: 'OUTER', booleanfy: true, optional: true },\n                            ],\n                        ],\n                    },\n                    { type: 'keyword', value: 'JOIN' },\n                    ...[].concat(super.syntaxRules),\n                    { type: ['OnClause', 'UsingClause'], as: 'condition_clause', if: '!natural_kw', autoIndent: true },\n                ],\n            ],\n        };\n    }\n\n    /* AST API */\n\n    naturalKW() { return this._get('natural_kw'); }\n\n    joinType() { return this._get('join_type'); }\n\n    outerKW() { return this._get('outer_kw'); }\n\n    conditionClause() { return this._get('condition_clause'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class LimitClause extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', value: 'LIMIT' },\n            {\n                dialect: 'mysql',\n                syntax: [\n                    {\n                        optional: true,\n                        syntax: [\n                            { type: 'Expr', as: 'my_offset' },\n                            { type: 'punctuation', value: ',', autoSpacing: false },\n                        ]\n                    },\n                    { type: 'Expr', as: 'expr', assert: true, },\n                ]\n            },\n            {\n                dialect: 'postgres',\n                syntaxes: [\n                    { type: 'keyword', as: 'pg_all_kw', value: 'ALL' },\n                    { type: 'Expr', as: 'expr', assert: true, },\n                ],\n            },\n        ];\n    }\n\n    /* AST API */\n\n    expr() { return this._get('expr'); }\n\n    // -- Postgres\n\n    pgAllKW() { return this._get('pg_all_kw'); }\n\n    // -- MySQL\n\n    myOffset() { return this._get('my_offset'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class OffsetClause extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', value: 'OFFSET' },\n            { type: 'Expr', as: 'expr', assert: true, },\n            { type: 'keyword', as: 'pg_row_kw', value: ['ROW', 'ROWS'], optional: true, dialect: 'postgres' },\n        ];\n    }\n\n    /* AST API */\n\n    expr() { return this._get('expr'); }\n\n    // -- Postgres\n\n    pgRowKW() { return this._get('pg_row_kw'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class OnClause extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', value: 'ON' },\n            { type: 'Expr', as: 'expr', assert: true }\n        ];\n    }\n\n    /* AST API */\n\n    expr() { return this._get('expr'); }\n}", "import { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\n\nexport class OrderByClause extends AbstractNodeList {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'keyword', value: 'ORDER' },\n            { type: 'keyword', value: 'BY', assert: true },\n            { type: 'OrderElement', as: 'entries', arity: { min: 1 }, itemSeparator, assert: true, autoIndent: 2 },\n            {\n                optional: true,\n                autoIndent: true,\n                syntax: [\n                    { type: 'keyword', as: 'with_rollup', value: 'WITH', booleanfy: true },\n                    { type: 'keyword', value: 'ROLLUP', assert: true },\n                ]\n            },\n        ];\n    }\n\n    /* AST API */\n\n    withRollup() { return this._get('with_rollup'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class OrderElement extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'Expr', as: 'expr' },\n            {\n                optional: true,\n                syntaxes: [\n                    { type: 'keyword', value: ['ASC', 'DESC'], as: 'dir' },\n                    { type: 'PGOrderOperator', as: 'dir' },\n                ]\n            },\n            {\n                optional: true,\n                syntax: [\n                    { type: 'keyword', value: 'NULLS' },\n                    { type: 'keyword', as: 'nulls_spec', value: ['FIRST', 'LAST'], assert: true },\n                ]\n            },\n        ];\n    }\n\n    /* AST API */\n\n    expr() { return this._get('expr'); }\n\n    dir() { return this._get('dir'); }\n\n    nullsSpec() { return this._get('nulls_spec'); }\n}", "import { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\n\nexport class PartitionByClause extends AbstractNodeList {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'keyword', value: 'PARTITION' },\n            { type: 'keyword', value: 'BY', assert: true },\n            { type: 'Expr', as: 'entries', arity: { min: 1 }, itemSeparator, assert: true, autoIndent: 2 }\n        ];\n    }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class PGFetchClause extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            dialect: 'postgres',\n            syntax: [\n                { type: 'keyword', value: 'FETCH' },\n                { type: 'keyword', as: 'rel_kw', value: ['FIRST', 'NEXT'] },\n                { type: ['SubqueryConstructor', 'Expr'], as: 'expr', optional: true },\n                { type: 'keyword', as: 'row_kw', value: ['ROW', 'ROWS'], assert: true },\n                {\n                    syntaxes: [\n                        { type: 'keyword', value: 'ONLY' },\n                        [\n                            { type: 'keyword', as: 'with_ties', value: 'WITH' },\n                            { type: 'keyword', value: 'TIES', assert: true },\n                        ]\n                    ]\n                }\n            ]\n        };\n    }\n\n    /* AST API */\n\n    relKW() { return this._get('rel_kw'); }\n\n    expr() { return this._get('expr'); }\n\n    rowKW() { return this._get('row_kw'); }\n\n    withTies() { return this._get('with_ties'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class PGOrderOperator extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            dialect: 'postgres',\n            syntax: [\n                { type: 'keyword', value: 'USING' },\n                { type: 'operator', as: '.', assert: true },\n            ],\n        };\n    }\n\n    /* AST API */\n\n    value() { return this._get('value'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class CallExpr extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n\n        return {\n            syntaxes: [\n                {\n                    peek: [0, 'keyword', [\n                        'NOW', 'CURRENT_DATE', 'CURRENT_TIME', 'CURRENT_TIMESTAMP',\n                        'IF', 'NULLIF', 'IFNULL',\n                        'COALESCE', 'GREATEST', 'LEAST', 'CONCAT',\n                        'CONCAT_WS', 'FORMAT',\n                        'MD5', 'SHA1',\n                        'TO_JSON', 'TO_JSONB', 'JSON_TYPEOF', 'JSONB_TYPEOF',\n                        'JSON_BUILD_ARRAY', 'JSONB_BUILD_ARRAY', 'JSON_BUILD_OBJECT', 'JSONB_BUILD_OBJECT',\n                        'JSON_POPULATE_RECORD', 'JSONB_POPULATE_RECORD', 'JSON_PATH_QUERY', 'JSON_PATH_EXISTS',\n                        'JSON_ARRAY', 'JSON_OBJECT', 'JSON_EXTRACT', 'JSON_UNQUOTE',\n                        'JSON_SET', 'JSON_INSERT', 'JSON_REPLACE', 'JSON_REMOVE',\n                        'JSON_SEARCH', 'JSON_CONTAINS', 'JSON_CONTAINS_PATH',\n                        'JSON_KEYS', 'JSON_ARRAY_APPEND', 'JSON_ARRAY_INSERT',\n                        'JSON_DEPTH', 'JSON_LENGTH', 'JSON_MERGE_PRESERVE',\n                        'JSON_MERGE_PATCH', 'JSON_PRETTY', 'JSON_STORAGE_FREE',\n                        'ST_ASTEXT', 'ST_ASGEOJSON', 'ST_GEOMFROMTEXT',\n                        'ST_WITHIN', 'ST_CONTAINS', 'ST_INTERSECTS', 'ST_DISTANCE', 'ST_BUFFER',\n                        'MAKE_DATE', 'MAKE_TIME', 'MAKE_TIMESTAMP', 'ARRAY',\n                        'CURDATE', 'CURTIME', 'SYSDATE', 'STR_TO_DATE', 'MAKEDATE', 'MAKETIME',\n                    ]],\n                    syntaxes: [\n\n                        // ---------- \uD83E\uDDEE Cross-dialect scalar functions (fixed arity)\n\n                        [\n                            { type: 'keyword', as: 'name', value: ['CURRENT_DATE', 'CURRENT_TIME', 'CURRENT_TIMESTAMP'] },\n                            {\n                                type: 'paren_block',\n                                syntax: { type: 'Expr', as: 'arguments', arity: 0, itemSeparator, assert: true },\n                                optional: true,\n                                optionalParens: true,\n                                autoSpacing: false\n                            }\n                        ],\n                        [\n                            { type: 'keyword', as: 'name', value: ['NOW'] },\n                            {\n                                type: 'paren_block',\n                                syntax: { type: 'Expr', as: 'arguments', arity: 0, itemSeparator, assert: true },\n                                optional: true,\n                                autoSpacing: false\n                            }\n                        ],\n                        [\n                            { type: 'keyword', as: 'name', value: ['IF', 'NULLIF', 'IFNULL'] },\n                            {\n                                type: 'paren_block',\n                                syntax: { type: 'Expr', as: 'arguments', arity: { min: 2, max: 3 }, itemSeparator, assert: true },\n                                autoSpacing: false\n                            }\n                        ],\n\n                        // ---------- \uD83D\uDCD0 Cross-dialect scalar functions (variadic)\n\n                        [\n                            { type: 'keyword', as: 'name', value: ['COALESCE', 'GREATEST', 'LEAST', 'CONCAT'] },\n                            {\n                                type: 'paren_block',\n                                syntax: { type: 'Expr', as: 'arguments', arity: { min: 1 }, itemSeparator, assert: true },\n                                autoSpacing: false\n                            }\n                        ],\n                        [\n                            { type: 'keyword', as: 'name', value: ['CONCAT_WS', 'FORMAT'] },\n                            {\n                                type: 'paren_block',\n                                syntax: { type: 'Expr', as: 'arguments', arity: { min: 2 }, itemSeparator, assert: true },\n                                autoSpacing: false\n                            }\n                        ],\n                        [\n                            { type: 'keyword', as: 'name', value: ['MD5', 'SHA1'] },\n                            {\n                                type: 'paren_block',\n                                syntax: { type: 'Expr', as: 'arguments', arity: 1, itemSeparator, assert: true },\n                                autoSpacing: false\n                            }\n                        ],\n\n                        // ---------- \uD83D\uDFE9 Spatial functions (PostgreSQL & MySQL)\n\n                        [\n                            { type: 'keyword', as: 'name', value: ['ST_ASTEXT', 'ST_ASGEOJSON', 'ST_GEOMFROMTEXT'] },\n                            {\n                                type: 'paren_block',\n                                syntax: { type: 'Expr', as: 'arguments', arity: 1, itemSeparator, assert: true },\n                                autoSpacing: false\n                            }\n                        ],\n                        [\n                            { type: 'keyword', as: 'name', value: ['ST_WITHIN', 'ST_CONTAINS', 'ST_INTERSECTS', 'ST_DISTANCE', 'ST_BUFFER'] },\n                            {\n                                type: 'paren_block',\n                                syntax: { type: 'Expr', as: 'arguments', arity: 2, itemSeparator, assert: true },\n                                autoSpacing: false\n                            }\n                        ],\n\n                        // ---------- \uD83D\uDFEB PostgreSQL JSON functions\n\n                        {\n                            dialect: 'postgres',\n                            syntax: [\n                                { type: 'keyword', as: 'name', value: ['TO_JSON', 'TO_JSONB', 'JSON_TYPEOF', 'JSONB_TYPEOF'] },\n                                {\n                                    type: 'paren_block',\n                                    syntax: { type: 'Expr', as: 'arguments', arity: 1, itemSeparator, assert: true },\n                                    autoSpacing: false\n                                }\n                            ]\n                        },\n                        {\n                            dialect: 'postgres',\n                            syntax: [\n                                { type: 'keyword', as: 'name', value: ['JSON_BUILD_ARRAY', 'JSONB_BUILD_ARRAY', 'JSON_BUILD_OBJECT', 'JSONB_BUILD_OBJECT'] },\n                                {\n                                    type: 'paren_block',\n                                    syntax: { type: 'Expr', as: 'arguments', arity: { min: 0 }, itemSeparator, assert: true },\n                                    autoSpacing: false\n                                }\n                            ]\n                        },\n                        {\n                            dialect: 'postgres',\n                            syntax: [\n                                { type: 'keyword', as: 'name', value: ['JSON_POPULATE_RECORD', 'JSONB_POPULATE_RECORD', 'JSON_PATH_QUERY', 'JSON_PATH_EXISTS'] },\n                                {\n                                    type: 'paren_block',\n                                    syntax: { type: 'Expr', as: 'arguments', arity: 2, itemSeparator, assert: true },\n                                    autoSpacing: false\n                                }\n                            ]\n                        },\n                        {\n                            dialect: 'postgres',\n                            syntax: [\n                                { type: 'keyword', as: 'name', value: ['ARRAY'] },\n                                {\n                                    type: 'paren_block',\n                                    syntax: { type: 'SelectStmt', as: 'arguments', arity: 1, itemSeparator, assert: true },\n                                    autoIndent: true,\n                                    autoSpacing: true\n                                }\n                            ]\n                        },\n\n                        // ---------- \uD83D\uDFEB PostgreSQL Date functions\n\n                        {\n                            dialect: 'postgres',\n                            syntax: [\n                                { type: 'keyword', as: 'name', value: ['MAKE_DATE', 'MAKE_TIME', 'MAKE_TIMESTAMP'] },\n                                {\n                                    type: 'paren_block',\n                                    syntax: { type: 'Expr', as: 'arguments', arity: Infinity, itemSeparator, assert: true },\n                                    autoSpacing: false\n                                }\n                            ]\n                        },\n\n                        // ---------- \uD83D\uDFE7 MySQL JSON functions\n\n                        {\n                            dialect: 'mysql',\n                            syntax: [\n                                {\n                                    type: 'keyword', as: 'name', value: [\n                                        'JSON_ARRAY', 'JSON_OBJECT', 'JSON_EXTRACT', 'JSON_UNQUOTE',\n                                        'JSON_SET', 'JSON_INSERT', 'JSON_REPLACE', 'JSON_REMOVE',\n                                        'JSON_SEARCH', 'JSON_CONTAINS', 'JSON_CONTAINS_PATH',\n                                        'JSON_KEYS', 'JSON_ARRAY_APPEND', 'JSON_ARRAY_INSERT',\n                                        'JSON_DEPTH', 'JSON_LENGTH', 'JSON_MERGE_PRESERVE',\n                                        'JSON_MERGE_PATCH', 'JSON_PRETTY', 'JSON_STORAGE_FREE'\n                                    ]\n                                },\n                                {\n                                    type: 'paren_block',\n                                    syntax: { type: 'Expr', as: 'arguments', arity: { min: 1 }, itemSeparator, assert: true },\n                                    autoSpacing: false\n                                }\n                            ]\n                        },\n\n                        // ---------- \uD83D\uDFE7 MySQL Date functions\n\n                        {\n                            dialect: 'mysql',\n                            syntax: [\n                                { type: 'keyword', as: 'name', value: ['CURDATE', 'CURTIME', 'SYSDATE'] },\n                                {\n                                    type: 'paren_block',\n                                    syntax: { type: 'Expr', as: 'arguments', arity: 0, itemSeparator, optional: true, assert: true },\n                                    autoSpacing: false\n                                }\n                            ]\n                        },\n                        {\n                            dialect: 'mysql',\n                            syntax: [\n                                { type: 'keyword', as: 'name', value: 'STR_TO_DATE' },\n                                {\n                                    type: 'paren_block',\n                                    syntax: { type: 'Expr', as: 'arguments', arity: 2, itemSeparator, assert: true },\n                                    autoSpacing: false\n                                }\n                            ]\n                        },\n                        {\n                            dialect: 'mysql',\n                            syntax: [\n                                { type: 'keyword', as: 'name', value: ['MAKEDATE', 'MAKETIME'] },\n                                {\n                                    type: 'paren_block',\n                                    syntax: { type: 'Expr', as: 'arguments', arity: 2, itemSeparator, assert: true },\n                                    autoSpacing: false\n                                }\n                            ]\n                        }\n                    ]\n                },\n\n                // ---------- \uD83E\uDDE0 Fallback: general call syntax\n\n                [\n                    { type: 'keyword', as: 'name' },\n                    {\n                        type: 'paren_block',\n                        syntax: { type: 'Expr', as: 'arguments', arity: Infinity, itemSeparator },\n                        autoSpacing: false\n                    }\n                ],\n                [\n                    { type: 'identifier', as: 'name' },\n                    {\n                        type: 'paren_block',\n                        syntax: { type: 'Expr', as: 'arguments', arity: Infinity, itemSeparator },\n                        autoSpacing: false\n                    }\n                ]\n            ]\n        };\n    }\n\n    static get syntaxPriority() { return 51; }\n\n    /* AST API */\n\n    name() { return this._get('name'); }\n\n    arguments() { return this._get('arguments'); }\n}\n", "import { CallExpr } from './CallExpr.js';\n\nexport class AggrCallExpr extends CallExpr {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n\n        // Optional modifiers and clauses\n        const optional_distinct_modifier = { type: 'keyword', as: 'distinct', value: 'DISTINCT', booleanfy: true, optional: true };\n        const optional_separator_arg = {\n            optional: true,\n            syntax: [\n                { type: 'keyword', value: 'SEPARATOR' },\n                { type: 'Expr', as: 'separator', assert: true }\n            ]\n        };\n        const optional_order_by_clause = { type: 'OrderByClause', as: 'order_by_clause', optional: true };\n        const optional_filter_clause_postgres = { type: 'PGFilterClause', as: 'pg_filter_clause', optional: true, dialect: 'postgres' };\n        const optional_within_group_clause_postgres = { type: 'PGWithinGroupClause', as: 'pg_within_group_clause', optional: true, dialect: 'postgres' };\n        const optional_null_handling_directive = {\n            optional: true,\n            syntax: [\n                { type: 'keyword', as: 'null_handling', value: ['IGNORE', 'RESPECT'] },\n                { type: 'keyword', value: 'NULLS', assert: true }\n            ]\n        };\n        const optional_over_clause = {\n            optional: true,\n            syntax: [\n                { type: 'keyword', value: 'OVER' },\n                { type: ['WindowRef', 'WindowSpec'], as: 'over_clause', assert: true }\n            ]\n        };\n\n        // The syntax compositions\n        return {\n            peek: [0, 'keyword', [\n                'COUNT', 'SUM', 'AVG', 'MIN', 'MAX',\n                'ARRAY_AGG', 'STRING_AGG', 'GROUP_CONCAT',\n                'REGR_SLOPE', 'COVAR_POP', 'COVAR_SAMP', 'CORR',\n                'PERCENTILE_CONT', 'PERCENTILE_DISC', 'MODE',\n                'RANK', 'DENSE_RANK', 'ROW_NUMBER',\n                'EVERY', 'BOOL_AND', 'BOOL_OR',\n                'BIT_AND', 'BIT_OR', 'BIT_XOR',\n                'JSON_AGG', 'JSON_ARRAYAGG', 'JSON_OBJECT_AGG', 'JSONB_OBJECT_AGG', 'JSON_OBJECTAGG',\n                'STDDEV_POP', 'STDDEV_SAMP', 'VAR_POP', 'VAR_SAMP', 'VARIANCE', 'STD',\n                'XMLAGG', 'LEAD', 'LAG', 'NTILE', 'FIRST_VALUE', 'LAST_VALUE'\n            ]],\n            syntaxes: [\n\n                // ---------- \uD83D\uDD22 Basic aggregates\n\n                [ // COUNT(), COUNT(*)\n                    { type: 'keyword', as: 'name', value: 'COUNT' },\n                    {\n                        type: 'paren_block',\n                        syntax: [\n                            { dialect: 'postgres', type: 'StarRef', as: 'arguments', arity: 1, assert: false/* note: to give syntax2 a chance */, itemSeparator },\n                            { dialect: 'mysql', type: 'StarRef', as: 'arguments', arity: { max: 1 }, assert: false/* note: to give syntax2 a chance */, itemSeparator, optional: true }\n                        ],\n                        autoSpacing: false,\n                    },\n                    { ...optional_filter_clause_postgres },\n                    { ...optional_over_clause },\n                ],\n                [ // COUNT|SUM|AVG|MIN|MAX([DISTINCT] expr) [FILTER (...)] [OVER (...)]\n                    { type: 'keyword', as: 'name', value: ['COUNT', 'SUM', 'AVG', 'MIN', 'MAX'] },\n                    {\n                        type: 'paren_block',\n                        syntax: [\n                            { ...optional_distinct_modifier },\n                            { type: 'Expr', as: 'arguments', arity: 1, itemSeparator, assert: true }\n                        ],\n                        autoSpacing: false,\n                    },\n                    { ...optional_filter_clause_postgres },\n                    { ...optional_over_clause },\n                ],\n\n                // ---------- \uD83E\uDDF5 List / string aggregates\n\n                {\n                    dialect: 'postgres',\n                    syntax: [ // ARRAY_AGG()\n                        { type: 'keyword', as: 'name', value: 'ARRAY_AGG' },\n                        {\n                            type: 'paren_block',\n                            syntax: [\n                                { ...optional_distinct_modifier },\n                                { type: 'Expr', as: 'arguments', arity: { min: 1 }, itemSeparator, assert: true },\n                                { ...optional_order_by_clause },\n                            ],\n                            autoSpacing: false,\n                        },\n                        { ...optional_filter_clause_postgres },\n                        { ...optional_over_clause },\n                    ]\n                },\n                {\n                    dialect: 'postgres',\n                    syntax: [ // STRING_AGG()\n                        { type: 'keyword', as: 'name', value: 'STRING_AGG' },\n                        {\n                            type: 'paren_block',\n                            syntax: [\n                                { ...optional_distinct_modifier },\n                                { type: 'Expr', as: 'arguments', arity: 2, itemSeparator, assert: true },\n                                { ...optional_order_by_clause },\n                                { ...optional_separator_arg },\n                            ],\n                            autoSpacing: false,\n                        },\n                        { ...optional_filter_clause_postgres },\n                        { ...optional_over_clause },\n                    ]\n                },\n                {\n                    dialect: 'mysql',\n                    syntax: [ // GROUP_CONCAT()\n                        { type: 'keyword', as: 'name', value: 'GROUP_CONCAT' },\n                        {\n                            type: 'paren_block',\n                            syntax: [\n                                { ...optional_distinct_modifier },\n                                { type: 'Expr', as: 'arguments', arity: { min: 1 }, itemSeparator, assert: true },\n                                { ...optional_order_by_clause },\n                                { ...optional_separator_arg },\n                            ],\n                            autoSpacing: false,\n                        },\n                        { ...optional_over_clause },\n                    ]\n                },\n\n                // ---------- \uD83D\uDCC8 Statistical aggregates\n\n                {\n                    dialect: 'postgres',\n                    syntax: [ // REGR_SLOPE() [FILTER (...)] [OVER (...)]\n                        { type: 'keyword', as: 'name', value: 'REGR_SLOPE' },\n                        {\n                            type: 'paren_block',\n                            syntax: { type: 'Expr', as: 'arguments', arity: 2, itemSeparator, assert: true },\n                            autoSpacing: false,\n                        },\n                        { ...optional_filter_clause_postgres },\n                        { ...optional_over_clause },\n                    ]\n                },\n                [ // COVAR_POP|COVAR_SAMP|CORR() [FILTER (...)] [OVER (...)]\n                    { type: 'keyword', as: 'name', value: ['COVAR_POP', 'COVAR_SAMP', 'CORR'] },\n                    {\n                        type: 'paren_block',\n                        syntax: { type: 'Expr', as: 'arguments', arity: 2, itemSeparator, assert: true },\n                        autoSpacing: false,\n                    },\n                    { ...optional_filter_clause_postgres },\n                    { ...optional_over_clause },\n                ],\n\n                // ---------- \uD83D\uDCD0 Ordered-set aggregates (PostgreSQL only)\n\n                {\n                    dialect: 'postgres',\n                    syntax: [ // PERCENTILE_CONT|PERCENTILE_DISC(expr) [FILTER (...)] [WITHIN GROUP (...)]\n                        { type: 'keyword', as: 'name', value: ['PERCENTILE_CONT', 'PERCENTILE_DISC'] },\n                        {\n                            type: 'paren_block',\n                            syntax: { type: 'Expr', as: 'arguments', arity: 1, itemSeparator, assert: true },\n                            autoSpacing: false,\n                        },\n                        { ...optional_filter_clause_postgres },\n                        { ...optional_within_group_clause_postgres, optional: false/* OVERRIDE for \"required\" */ },\n                    ]\n                },\n                {\n                    dialect: 'postgres',\n                    syntax: [ // MODE() [FILTER (...)] [WITHIN GROUP (...)]\n                        { type: 'keyword', as: 'name', value: 'MODE' },\n                        {\n                            type: 'paren_block',\n                            syntax: { type: 'Expr', as: 'arguments', arity: 0, itemSeparator, assert: true },\n                            autoSpacing: false,\n                        },\n                        { ...optional_filter_clause_postgres },\n                        { ...optional_within_group_clause_postgres, optional: false/* OVERRIDE for \"required\" */ },\n                    ]\n                },\n                {\n                    dialect: 'postgres',\n                    syntax: [ // RANK|DENSE_RANK() [FILTER (...)] [OVER (...)]\n                        { type: 'keyword', as: 'name', value: ['RANK', 'DENSE_RANK'] },\n                        {\n                            type: 'paren_block',\n                            syntax: { type: 'Expr', as: 'arguments', arity: 0, itemSeparator, assert: true },\n                            autoSpacing: false,\n                        },\n                        { ...optional_filter_clause_postgres },\n                        { ...optional_over_clause, optional: false },\n                    ]\n                },\n                [ // ROW_NUMBER() [OVER (...)]\n                    { type: 'keyword', as: 'name', value: 'ROW_NUMBER' },\n                    {\n                        type: 'paren_block',\n                        syntax: { type: 'Expr', as: 'arguments', arity: 0, itemSeparator, assert: true },\n                        autoSpacing: false,\n                    },\n                    { ...optional_over_clause, optional: false },\n                ],\n\n                // ---------- \uD83E\uDDE0 Boolean aggregates\n\n                {\n                    dialect: 'postgres',\n                    syntax: [ // EVERY|BOOL_AND|BOOL_OR([DISTINCT] expr) [FILTER (...)] [OVER (...)]\n                        { type: 'keyword', as: 'name', value: ['EVERY', 'BOOL_AND', 'BOOL_OR'] },\n                        {\n                            type: 'paren_block',\n                            syntax: [\n                                { ...optional_distinct_modifier },\n                                { type: 'Expr', as: 'arguments', arity: 1, itemSeparator, assert: true }\n                            ],\n                            autoSpacing: false,\n                        },\n                        { ...optional_filter_clause_postgres },\n                        { ...optional_over_clause },\n                    ]\n                },\n\n                // ---------- \uD83D\uDCE6 JSON aggregates\n\n                {\n                    dialect: 'postgres',\n                    syntax: [ // JSON_AGG([DISTINCT] expr) [FILTER (...)] [OVER (...)]\n                        { type: 'keyword', as: 'name', value: 'JSON_AGG' },\n                        {\n                            type: 'paren_block',\n                            syntax: [\n                                { ...optional_distinct_modifier },\n                                { type: 'Expr', as: 'arguments', arity: { min: 1 }, itemSeparator, assert: true }\n                            ],\n                            autoSpacing: false,\n                        },\n                        { ...optional_filter_clause_postgres },\n                        { ...optional_over_clause },\n                    ]\n                },\n                {\n                    dialect: 'mysql',\n                    syntax: [ // JSON_ARRAYAGG([DISTINCT] expr) [OVER (...)]\n                        { type: 'keyword', as: 'name', value: 'JSON_ARRAYAGG' },\n                        {\n                            type: 'paren_block',\n                            syntax: [\n                                { ...optional_distinct_modifier },\n                                { type: 'Expr', as: 'arguments', arity: { min: 1 }, itemSeparator, assert: true }\n                            ],\n                            autoSpacing: false,\n                        },\n                        { ...optional_over_clause },\n                    ]\n                },\n\n                // ---------- \uD83D\uDCE6 Others 1\n\n                {\n                    dialect: 'mysql',\n                    syntax: [ // BIT_XOR (MySQL only)\n                        { type: 'keyword', as: 'name', value: 'BIT_XOR' },\n                        {\n                            type: 'paren_block',\n                            syntax: [\n                                { ...optional_distinct_modifier },\n                                { type: 'Expr', as: 'arguments', arity: 1, itemSeparator, assert: true }\n                            ],\n                            autoSpacing: false,\n                        },\n                        { ...optional_over_clause },\n                    ]\n                },\n                [ // BIT_AND, BIT_OR (PostgreSQL + MySQL)\n                    { type: 'keyword', as: 'name', value: ['BIT_AND', 'BIT_OR'] },\n                    {\n                        type: 'paren_block',\n                        syntax: [\n                            { ...optional_distinct_modifier },\n                            { type: 'Expr', as: 'arguments', arity: 1, itemSeparator, assert: true }\n                        ],\n                        autoSpacing: false,\n                    },\n                    { ...optional_filter_clause_postgres },\n                    { ...optional_over_clause },\n                ],\n\n                // ---------- \uD83D\uDCE6 Others 2\n\n                {\n                    dialect: 'postgres',\n                    syntax: [\n                        { type: 'keyword', as: 'name', value: ['JSON_OBJECT_AGG', 'JSONB_OBJECT_AGG'] },\n                        {\n                            type: 'paren_block',\n                            syntax: [\n                                { ...optional_distinct_modifier },\n                                { type: 'Expr', as: 'arguments', arity: 2, itemSeparator, assert: true } // key, value\n                            ],\n                            autoSpacing: false,\n                        },\n                        { ...optional_filter_clause_postgres },\n                        { ...optional_over_clause },\n                    ]\n                },\n                {\n                    dialect: 'mysql',\n                    syntax: [\n                        { type: 'keyword', as: 'name', value: 'JSON_OBJECTAGG' },\n                        {\n                            type: 'paren_block',\n                            syntax: [\n                                { ...optional_distinct_modifier },\n                                { type: 'Expr', as: 'arguments', arity: 2, itemSeparator, assert: true } // key, value\n                            ],\n                            autoSpacing: false,\n                        },\n                        { ...optional_over_clause },\n                    ]\n                },\n\n                // ---------- \uD83D\uDCE6 Others 3\n\n                [\n                    { type: 'keyword', as: 'name', value: ['STDDEV_POP', 'STDDEV_SAMP', 'VAR_POP', 'VAR_SAMP', 'VARIANCE', 'STD'] },\n                    {\n                        type: 'paren_block',\n                        syntax: [\n                            { ...optional_distinct_modifier },\n                            { type: 'Expr', as: 'arguments', arity: 1, itemSeparator, assert: true }\n                        ],\n                        autoSpacing: false,\n                    },\n                    { ...optional_filter_clause_postgres },\n                    { ...optional_over_clause },\n                ],\n\n                // ---------- \uD83D\uDCE6 Others 4\n\n                {\n                    dialect: 'postgres',\n                    syntax: [\n                        { type: 'keyword', as: 'name', value: 'XMLAGG' },\n                        {\n                            type: 'paren_block',\n                            syntax: [\n                                { type: 'Expr', as: 'arguments', arity: 1, itemSeparator, assert: true },\n                                { ...optional_order_by_clause }\n                            ],\n                            autoSpacing: false,\n                        },\n                        { ...optional_filter_clause_postgres },\n                        { ...optional_over_clause },\n                    ]\n                },\n\n                // ---------- \uD83D\uDCE6 Others 5\n\n                [\n                    { type: 'keyword', as: 'name', value: ['LEAD', 'LAG'] },\n                    {\n                        type: 'paren_block',\n                        syntax: { type: 'Expr', as: 'arguments', arity: { max: 3 }, itemSeparator, optional: true, assert: true },\n                        autoSpacing: false,\n                    },\n                    { ...optional_null_handling_directive },\n                    { ...optional_over_clause },\n                ],\n                [\n                    { type: 'keyword', as: 'name', value: ['NTILE', 'FIRST_VALUE', 'LAST_VALUE'] },\n                    {\n                        type: 'paren_block',\n                        syntax: { type: 'Expr', as: 'arguments', arity: 1, itemSeparator, assert: true },\n                        autoSpacing: false,\n                    },\n                    { ...optional_over_clause, optional: false },\n                ],\n            ]\n        };\n    }\n\n    /* AST API */\n\n    distinct() { return this._get('distinct'); }\n\n    orderByClause() { return this._get('order_by_clause'); }\n\n    separator() { return this._get('separator'); }\n\n    overClause() { return this._get('over_clause'); }\n\n    // -- Postgres\n\n    pgFilterClause() { return this._get('pg_filter_clause'); }\n\n    pgWithinGroupClause() { return this._get('pg_within_group_clause'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\nimport { AggrCallExpr } from '../../expr/call/AggrCallExpr.js';\nimport { BasicAlias } from './BasicAlias.js';\n\nexport class SelectElement extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: ['Expr', 'MYVarAssignmentExpr'], as: 'expr' },\n            {\n                optional: true,\n                syntaxes: [\n                    { type: 'BasicAlias', as: 'alias' },\n                    [\n                        { type: 'keyword', as: 'as_kw', value: 'AS', booleanfy: true },\n                        { type: 'BasicAlias', as: 'alias', assert: true }\n                    ]\n                ]\n            }\n        ];\n    }\n\n    /* AST API */\n\n    expr() { return this._get('expr'); }\n\n    asKW() { return this._get('as_kw'); }\n\n    alias() { return this._get('alias'); }\n\n    /* DESUGARING API */\n\n    jsonfy(options = {}, transformCallback = null) {\n        if (options.deSugar && this.alias()?.isAggr()) {\n            // Note the below where we wrap value in an aggr call\n            const exprJson = {\n                nodeName: AggrCallExpr.NODE_NAME,\n                name: (options.toDialect || this.options.dialect) === 'mysql' ? 'JSON_ARRAYAGG' : 'JSON_AGG',\n                arguments: [this.expr().jsonfy({ ...options, asAggr: true/* for use by any Back/DeefRef */ }, transformCallback)],\n            };\n            // Note the below instead of .jsonfy() as the former would still add the \"[]\" notation\n            const aliasJson = {\n                nodeName: BasicAlias.NODE_NAME,\n                value: this.alias().value()\n            };\n            return {\n                nodeName: SelectElement.NODE_NAME,\n                expr: exprJson,\n                as_kw: this.asKW(),\n                alias: aliasJson\n            };\n        }\n        return super.jsonfy(options, transformCallback);\n    }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class SRFSpec extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'CallExpr', as: 'expr' },\n            {\n                optional: true,\n                syntax: [\n                    {\n                        syntaxes: [\n                            { type: 'CompositeAlias', as: 'alias' },\n                            [\n                                { type: 'keyword', as: 'as_kw', value: 'AS', booleanfy: true },\n                                { type: 'CompositeAlias', as: 'alias', assert: true }\n                            ]\n                        ]\n                    }\n                ]\n            }\n        ];\n    }\n\n    /* AST API */\n\n    expr() { return this._get('expr'); }\n\n    asKW() { return this._get('as_kw'); }\n\n    alias() { return this._get('alias'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class UsingClause extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', value: 'USING' },\n            { type: ['ColumnNameRef', 'ColumnsConstructor'], as: 'column', assert: true }\n        ];\n    }\n\n    /* AST API */\n\n    column() { return this._get('column'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class WhereClause extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', value: 'WHERE' },\n            { type: 'Expr', as: 'expr', assert: true }\n        ];\n    }\n\n    /* AST API */\n\n    expr() { return this._get('expr'); }\n}", "import { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\n\nexport class WindowClause extends AbstractNodeList {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'keyword', value: 'WINDOW' },\n            { type: 'WindowDeclaration', as: 'entries', arity: { min: 1 }, itemSeparator, assert: true, autoIndent: 2 }\n        ];\n    }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class WindowDeclaration extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'Identifier', as: 'name' },\n            { type: 'keyword', value: 'AS' },\n            { type: 'WindowSpec', as: 'spec', assert: true }\n        ];\n    }\n\n    /* AST API */\n\n    name() { return this._get('name'); }\n\n    spec() { return this._get('spec'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class WindowFrameSpec extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'operator', value: 'AND' };\n        return [\n            { type: 'keyword', as: 'specifier', value: ['ROWS', 'RANGE', 'GROUPS'] },\n            {\n                syntaxes: [\n                    [\n                        { type: 'operator', as: 'with_between_clause', value: 'BETWEEN', booleanfy: true },\n                        { type: 'WindowFrameBound', as: 'bounds', arity: 2, itemSeparator, assert: true },\n                    ],\n                    { type: 'WindowFrameBound', as: 'bounds', arity: 1, itemSeparator, assert: true },\n\n                ]\n            },\n            {\n                optional: true,\n                syntax: [\n                    { type: 'keyword', value: 'EXCLUDE' },\n                    { type: 'keyword', as: 'exclusion', value: ['CURRENT ROW', 'GROUP', 'TIES', 'NO OTHERS'], assert: true },\n                ]\n            },\n        ];\n    }\n\n    /* AST API */\n\n    specifier() { return this._get('specifier'); }\n\n    withBetweenClause() { return this._get('with_between_clause'); }\n\n    bounds() { return this._get('bounds'); }\n\n    exclusion() { return this._get('exclusion'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class WindowFrameBound extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            syntaxes: [\n                { type: 'keyword', as: 'specifier', value: 'CURRENT ROW' },\n                [\n                    { type: 'keyword', as: 'specifier', value: 'UNBOUNDED' },\n                    { type: 'keyword', as: 'dir', value: ['PRECEDING', 'FOLLOWING'] },\n                ],\n                [\n                    { type: 'number_literal', as: 'specifier' },\n                    { type: 'keyword', as: 'dir', value: ['PRECEDING', 'FOLLOWING'] },\n                ],\n                [\n                    { type: 'Expr'/* Ideally, Temporal types */, as: 'specifier' },\n                    { type: 'keyword', as: 'dir', value: ['PRECEDING', 'FOLLOWING'] },\n                ],\n            ]\n        };\n    }\n\n    /* AST API */\n\n    specifier() { return this._get('specifier'); }\n\n    dir() { return this._get('dir'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class WindowSpec extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            type: 'paren_block',\n            syntax: [\n                { type: 'WindowRef', as: 'super_window', optional: true },\n                { type: 'PartitionByClause', as: 'partition_by_clause', optional: true, autoIndent: true },\n                { type: 'OrderByClause', as: 'order_by_clause', optional: true, autoIndent: true },\n                { type: 'WindowFrameSpec', as: 'frame_spec', optional: true, autoIndent: true },\n            ],\n            autoIndent: true,\n            autoIndentAdjust: -1\n        };\n    }\n\n    /* AST API */\n\n    superWindow() { return this._get('super_window'); }\n\n    partitionByClause() { return this._get('partition_by_clause'); }\n\n    orderByClause() { return this._get('order_by_clause'); }\n\n    frameSpec() { return this._get('frame_spec'); }\n}", "import { AbstractNonDDLStmt } from '../abstracts/AbstractNonDDLStmt.js';\n\nexport class SelectStmt extends AbstractNonDDLStmt {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() { return { type: ['CompleteSelectStmt', 'CompositeSelectStmt'], expression: true }; }\n\n    static _getSyntaxRules(full = false) {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'keyword', value: 'SELECT' },\n            { type: 'DistinctClause', as: 'distinct_clause', optional: true },\n            { type: 'SelectElement', as: 'select_list', arity: { min: 1 }, itemSeparator, assert: true, autoIndent: 2 },\n            {\n                optional: true,\n                syntax: [\n                    { type: 'FromClause', as: 'from_clause', autoIndent: true },\n                    { type: 'JoinClause', as: 'join_clauses', arity: Infinity, optional: true, autoIndent: true },\n\t\t\t\t\t{ type: 'MYPartitionClause', as: 'my_partition_clause', optional: true, autoIndent: true },\n                    { type: 'WhereClause', as: 'where_clause', optional: true, autoIndent: true },\n                    {\n                        optional: true,\n                        syntax: [\n                            { type: 'GroupByClause', as: 'group_by_clause', autoIndent: true },\n                            { type: 'HavingClause', as: 'having_clause', optional: true, autoIndent: true },\n                        ],\n                    },\n                    { type: 'WindowClause', as: 'window_clause', optional: true, autoIndent: true },\n                    ...\n                    (full ? this._getSyntaxRulesTail() : [])\n                ],\n            },\n        ];\n    }\n\n    static _getSyntaxRulesTail() {\n        return [\n            { type: 'OrderByClause', as: 'order_by_clause', optional: true, autoIndent: true },\n            { type: 'LimitClause', as: 'limit_clause', optional: true, autoIndent: true },\n            { type: 'OffsetClause', as: 'offset_clause', optional: true, autoIndent: true },\n            { type: 'PGFetchClause', as: 'pg_fetch_clause', optional: true, dialect: 'postgres', autoIndent: true },\n            { type: 'ForClause', as: 'for_clause', optional: true, autoIndent: true },\n        ];\n    }\n}\n", "import { SelectorStmtMixin } from '../abstracts/SelectorStmtMixin.js';\nimport { SelectStmt } from './SelectStmt.js';\nimport { registry } from '../registry.js';\n\nconst {\n    LQObjectLiteral,\n    BasicAlias,\n    SelectElement,\n} = registry;\n\nexport class BasicSelectStmt extends SelectorStmtMixin(\n    SelectStmt\n) {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() { return this._getSyntaxRules(false); }\n\n    static get syntaxPriority() { return -1; }\n\n    /* Schema API */\n\n    distinctClause() { return this._get('distinct_clause'); }\n\n    selectList() { return this._get('select_list'); }\n\n    fromClause() { return this._get('from_clause'); }\n\n    joinClauses() { return this._get('join_clauses'); }\n\n    whereClause() { return this._get('where_clause'); }\n\n    groupByClause() { return this._get('group_by_clause'); }\n\n    havingClause() { return this._get('having_clause'); }\n\n    windowClause() { return this._get('window_clause'); }\n\n    // -- MySQL\n\n    myPartitionClause() { return this._get('my_partition_clause'); }\n\n    // --------\n\n    get length() { return this.selectList()?.length ?? 0; }\n\n    [Symbol.iterator]() { return (this.selectList() || [])[Symbol.iterator](); }\n\n    /* DESUGARING API */\n\n    jsonfy(options = {}) {\n        let resultJson = super.jsonfy(options);\n\n        // Normalize special case LQObjectLiteral\n        let selectList;\n        if (options.deSugar\n            && (selectList = this.selectList()).length === 1\n            && selectList[0].expr() instanceof LQObjectLiteral\n            && !selectList[0].alias()\n        ) {\n            // Make pairs of arguments\n            const [argPairs] = resultJson.select_list[0].arguments.reduce(([argPairs, key], arg) => {\n                if (key) return [...argPairs, [{ nodeName: BasicAlias.NODE_NAME, value: key.value }, arg]];\n                return [argPairs, arg];\n            }, [[]]);\n            resultJson = {\n                ...resultJson,\n                select_list: argPairs.map(([alias, expr]) => ({\n                    nodeName: SelectElement.NODE_NAME,\n                    expr,\n                    alias,\n                    as_kw: true,\n                }))\n            };\n        }\n\n        return resultJson;\n    }\n}", "import { BasicSelectStmt } from './BasicSelectStmt.js';\n\nexport class CompleteSelectStmt extends BasicSelectStmt {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() { return this._getSyntaxRules(true); }\n\n    static get syntaxPriority() { return 99; }\n\n    /* AST API */\n\n    orderByClause() { return this._get('order_by_clause'); }\n\n    offsetClause() { return this._get('offset_clause'); }\n\n    limitClause() { return this._get('limit_clause'); }\n\n    forClause() { return this._get('for_clause'); }\n\n    // -- Postgres\n\n    pgFetchClause() { return this._get('pg_fetch_clause'); }\n}", "import { SelectStmt } from './SelectStmt.js';\n\nexport class CompositeSelectStmt extends SelectStmt {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const setTypes = ['SubqueryConstructor', 'ValuesSetConstructor', 'ParenShape', 'BasicSelectStmt', 'CallExpr'];\n        return [\n            { type: setTypes.concat('CompleteSelectStmt'), as: 'left' },\n            { type: 'operator', as: 'operator', value: ['INTERSECT', 'UNION', 'EXCEPT'], autoSpacing: '\\n' },\n            { type: 'keyword', as: 'all_or_distinct', value: ['ALL', 'DISTINCT'], optional: true },\n            { type: setTypes, as: 'right', assert: true, autoSpacing: '\\n' },\n            ...\n            this._getSyntaxRulesTail(),\n        ];\n    }\n\n    static get syntaxPriority() { return 100; }\n\n    /* AST API */\n\n    left() { return this._get('left'); }\n\n    operator() { return this._get('operator'); }\n\n    allOrDistinct() { return this._get('all_or_distinct'); }\n\n    right() { return this._get('right'); }\n\n    // --------\n    \n    orderByClause() { return this._get('order_by_clause'); }\n\n    offsetClause() { return this._get('offset_clause'); }\n\n    limitClause() { return this._get('limit_clause'); }\n\n    forClause() { return this._get('for_clause'); }\n\n    // -- Postgres\n\n    pgFetchClause() { return this._get('pg_fetch_clause'); }\n\n    // --------\n\n    get length() { return this.left()?.selectList()?.length ?? 0; }\n\n    [Symbol.iterator]() { return (this.left()?.selectList() || [])[Symbol.iterator](); }\n}", "import { AbstractStmt } from '../abstracts/AbstractStmt.js';\n\nexport class TableStmt extends AbstractStmt {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', value: 'TABLE' },\n            { type: 'keyword', as: 'pg_only_kw', value: 'ONLY', optional: true, dialect: 'postgres' },\n            { type: 'TableRef', as: 'table_name', assert: true },\n            { type: 'StarRef', as: 'pg_star_ref', optional: true, dialect: 'postgres' },\n        ];\n    }\n\n    /* AST API */\n\n    tableName() { return this._get('table_name'); }\n\n    // -- Postgres\n\n    pgOnlyKW() { return this._get('pg_only_kw'); }\n\n    pgStarRef() { return this._get('pg_star_ref'); }\n}", "export * from './call/index.js';\nexport * from './case/index.js';\nexport * from './literal/index.js';\nexport * from './op/index.js';\nexport * from './ref/index.js';\nexport * from './shape/index.js';\nexport * from './var/index.js';\nexport { LQBackRefConstructor } from '../dql/constructors/LQBackRefConstructor.js';\nexport { RowConstructor } from '../dql/constructors/RowConstructor.js';\nexport { SetConstructor } from '../dql/constructors/SetConstructor.js';\nexport { SubqueryConstructor } from '../dql/constructors/SubqueryConstructor.js';\nexport { Expr } from './Expr.js';                                                              \n", "import { AbstractNode } from '../../../abstracts/AbstractNode.js';\n\nexport class PGFilterClause extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            dialect: 'postgres',\n            syntax: [\n                { type: 'keyword', value: 'FILTER' },\n                {\n                    type: 'paren_block',\n                    syntax: { type: 'WhereClause', as: 'where_clause' },\n                    assert: true,\n                    autoIndent: true\n                }\n            ]\n        };\n    }\n\n    static get syntaxPriority() { return -1; }\n\n    /* AST API */\n\n    whereClause() { return this._get('where_clause'); }\n}", "import { AbstractNode } from '../../../abstracts/AbstractNode.js';\n\nexport class PGWithinGroupClause extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            dialect: 'postgres',\n            syntax: [\n                { type: 'keyword', value: 'WITHIN' },\n                { type: 'keyword', value: 'GROUP' },\n                {\n                    type: 'paren_block',\n                    syntax: { type: 'OrderByClause', as: 'order_by_clause' },\n                    assert: true,\n                    autoIndent: true,\n                },\n            ]\n        };\n    }\n\n    static get syntaxPriority() { return -1; }\n\n    /* AST API */\n\n    orderByClause() { return this._get('order_by_clause'); }\n}", "import { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\n\nexport class CaseExpr extends AbstractNodeList {\n\n    /* DEFS */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', value: 'CASE' },\n            { type: 'Expr', as: 'subject', optional: true },\n            { type: 'CaseBranch', as: 'entries', arity: { min: 1 }, assert: true, autoIndent: 2 },\n            {\n                optional: true,\n                syntax: [\n                    { type: 'keyword', value: 'ELSE' },\n                    { type: 'Expr', as: 'alternate', autoIndent: true },\n                ],\n                autoSpacing: '\\n',\n            },\n            { type: 'keyword', value: 'END', autoSpacing: '\\n' },\n        ];\n    }\n\n    /* AST API */\n\n    subject() { return this._get('subject'); }\n    \n    branches() { return this.entries(); }\n\n    alternate() { return this._get('alternate'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class CaseBranch extends AbstractNode {\n\n    /* DEFS */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', value: 'WHEN' },\n            { type: 'Expr', as: 'condition' },\n            { type: 'keyword', value: 'THEN' },\n            { type: 'Expr', as: 'consequent' }\n        ];\n    }\n\n    static get syntaxPriority() { return -1; }\n\n    /* AST API */\n\n    condition() { return this._get('condition'); }\n\n    consequent() { return this._get('consequent'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class AbstractLiteral extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxPriority() { return 49; }\n    \n    /* AST API */\n\n    value() { return this._get('value'); }\n}", "import { AbstractLiteral } from './AbstractLiteral.js';\n\nexport class BitLiteral extends AbstractLiteral {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() { return { type: 'bit_literal', as: '.' }; }\n}", "import { AbstractLiteral } from './AbstractLiteral.js';\n\nexport class BoolLiteral extends AbstractLiteral {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() { return { type: 'bool_literal', as: '.' }; }\n}", "import { AbstractLiteral } from './AbstractLiteral.js';\n\nexport class DefaultLiteral extends AbstractLiteral {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() { return { type: 'keyword', as: '.', value: 'DEFAULT' }; }\n}", "import { AbstractLiteral } from './AbstractLiteral.js';\n\nexport class HexLiteral extends AbstractLiteral {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() { return { type: 'hex_literal', as: '.' }; }\n}", "import { AbstractLiteral } from './AbstractLiteral.js';\n\nexport class NullLiteral extends AbstractLiteral {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() { return { type: 'null_literal', as: '.' }; }\n }", "import { AbstractLiteral } from './AbstractLiteral.js';\n\nexport class NumberLiteral extends AbstractLiteral {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() { return { type: 'number_literal', as: '.' }; }\n}", "import { AbstractLiteral } from './AbstractLiteral.js';\n\nexport class StringLiteral extends AbstractLiteral {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() { return { type: 'string_literal', as: '.' }; }\n    \n    /* AST API */\n\n    qualifier() { return this._get('qualifier'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class TypedLiteral extends AbstractNode {\n\n\t/* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'data_type', as: 'data_type' },\n            { type: 'string_literal', as: 'value' },\n        ];\n    }\n\n    static get syntaxPriority() { return 50; }\n\n    /* AST API */\n\n    dataType() { return Number(this._get('data_type')); }\n\n    value() { return Number(this._get('value')); }\n}", "import { TypedLiteral } from './TypedLiteral.js';\n\nexport class TypedDateLiteral extends TypedLiteral {\n\n\t/* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'data_type', as: 'data_type', value: 'DATE' },\n            { type: 'string_literal', as: 'value' },\n        ];\n    }\n}", "import { TypedLiteral } from './TypedLiteral.js';\n\nexport class TypedIntervalLiteral extends TypedLiteral {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'data_type', as: 'data_type', value: 'INTERVAL' },\n            {\n                syntaxes: [\n                    { type: 'string_literal', as: 'value' },\n                    { type: 'number_literal', as: 'value', dialect: 'mysql' },\n                ]\n            },\n            {\n                optional: true,\n                syntax: [\n                    { type: 'keyword', as: 'unit', value: ['YEAR', 'MONTH', 'DAY', 'HOUR', 'MINUTE', 'SECOND'] },\n                    {\n                        optional: true,\n                        syntax: [\n                            { type: 'keyword', value: 'TO' },\n                            { type: 'keyword', as: 'to_unit', value: ['YEAR', 'MONTH', 'DAY', 'HOUR', 'MINUTE', 'SECOND'], assert: true },\n                        ]\n                    },\n                ]\n            },\n        ];\n    }\n\n    /* AST API */\n\n    unit() { return Number(this._get('unit')); }\n\n    toUnit() { return Number(this._get('to_unit')); }\n}", "import { TypedLiteral } from './TypedLiteral.js';\n\nexport class TypedTimeLiteral extends TypedLiteral {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'data_type', as: 'data_type', value: 'TIME' },\n            { type: 'string_literal', as: 'value' },\n            {\n                optional: true,\n                dialect: 'postgres',\n                syntax: [\n                    { type: 'keyword', as: 'pg_with_tz', value: ['WITH', 'WITHOUT'] },\n                    { type: 'keyword', value: 'TIME ZONE', assert: true },\n                ]\n            },\n        ];\n    }\n\n    /* AST API */\n\n    pgWithTZ() { return Number(this._get('pg_with_tz')); }\n}", "import { TypedLiteral } from './TypedLiteral.js';\n\nexport class TypedTimestampLiteral extends TypedLiteral {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'data_type', as: 'data_type', value: 'TIMESTAMP', dialect: 'postgres' },\n            { type: 'data_type', as: 'data_type', value: ['TIMESTAMP', 'DATETIME'], dialect: 'mysql' },\n            { type: 'string_literal', as: 'value' },\n            {\n                optional: true,\n                dialect: 'postgres',\n                syntax: [\n                    { type: 'keyword', as: 'pg_with_tz', value: ['WITH', 'WITHOUT'] },\n                    { type: 'keyword', value: 'TIME ZONE', assert: true },\n                ]\n            }\n        ];\n    }\n\n    /* AST API */\n\n    pgWithTZ() { return Number(this._get('pg_with_tz')); }\n}", "import { TypedLiteral } from './TypedLiteral.js';\n\nexport class TypedTimeZoneLiteral extends TypedLiteral {\n\n\t/* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', value: 'TIME ZONE' },\n            { type: 'Expr', as: 'value' },\n        ];\n    }\n}", "import { AbstractLiteral } from './AbstractLiteral.js';\n\nexport class UnknownLiteral extends AbstractLiteral {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() { return { type: 'unknown_literal', as: '.' }; }\n }", "import { BinaryExpr } from './BinaryExpr.js';\n\nexport class AtTimeZoneExpr extends BinaryExpr {\n\n    /* DEFS */\n\n    static get syntaxRules() {\n        return [\n            { type: 'Expr', as: 'left', peek: [1, 'operator', 'AT'] },\n            { type: 'operator', as: 'operator', value: 'AT' },\n            {\n                syntaxes: [\n                    { type: 'TypedTimeZoneLiteral', as: 'right' },\n                    { type: 'keyword', as: 'right', value: 'LOCAL' }\n                ]\n            }\n        ];\n    }\n\n    static get syntaxPriority() { return 0; }\n\n    /* AST API */\n\n    left() { return this._get('left'); }\n\n    right() { return this._get('right'); }\n}", "import { BinaryExpr } from './BinaryExpr.js';\n\nexport class BetweenExpr extends BinaryExpr {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'operator', value: 'AND' };\n        return [\n            { type: 'Expr', as: 'left', peek: [1, 'operator', ['NOT', 'BETWEEN']] },\n            { type: 'operator', as: 'negation', value: 'NOT', booleanfy: true, optional: true },\n            { type: 'operator', as: 'operator', value: 'BETWEEN' },\n            { type: 'Expr', as: 'right', arity: { min: 2, max: 2, eager: false }, itemSeparator, assert: true },\n        ];\n    }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class CastExpr extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', value: 'CAST' },\n            {\n                type: 'paren_block',\n                syntax: [\n                    { type: 'Expr', as: 'left' },\n                    { type: 'keyword', value: 'AS' },\n                    { type: 'DataType', as: 'right', assert: true },\n                ],\n                assert: true,\n                autoSpacing: false,\n            }\n        ];\n    }\n\n    /* AST API */\n\n    left() { return this._get('left'); }\n\n    right() { return this._get('right'); }\n}", "import { BinaryExpr } from './BinaryExpr.js';\n\nexport class ExtractExpr extends BinaryExpr {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', value: 'EXTRACT' },\n            {\n                type: 'paren_block',\n                syntax: [\n                    { type: 'Expr', as: 'left' },\n                    { type: 'keyword', value: 'FROM' },\n                    { type: 'Expr', as: 'right', assert: true },\n                ],\n                autoSpacing: false\n            }\n        ];\n    }\n    \n    /* AST API */\n\n    left() { return this._get('left'); }\n\n    right() { return this._get('right'); }\n}", "import { BinaryExpr } from './BinaryExpr.js';\n\nexport class DistinctFromExpr extends BinaryExpr {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'Expr', as: 'left', peek: [1, 'operator', ['IS', 'IS NOT']] },\n            { type: 'operator', as: 'logic', value: ['IS', 'IS NOT'] },\n            { type: 'operator', as: 'operator', value: 'DISTINCT FROM' },\n            { type: 'Expr', as: 'right', assert: true },\n        ];\n    }\n\n    /* AST API */\n\n    logic() { return this._get('logic'); }\n}", "import { BinaryExpr } from './BinaryExpr.js';\n\nexport class PGCastExpr2 extends BinaryExpr {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            dialect: 'postgres',\n            syntax: [\n                { type: 'Expr', as: 'left', peek: [1, 'operator', '::'] },\n                { type: 'operator', as: 'operator', value: '::', autoSpacing: false },\n                { type: 'DataType', as: 'right', assert: true, autoSpacing: false },\n            ]\n        };\n    }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class QuantifiedExpr extends AbstractNode {\n\n    /* DEFS */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', as: 'quantifier', value: ['ALL', 'ANY', 'SOME'] },\n            { type: ['SubqueryConstructor', 'SetConstructor'], as: 'expr' },\n        ];\n    }\n\n    /* AST API */\n\n    quantifier() { return this._get('quantifier'); }\n\n    expr() { return this._get('expr'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class UnaryExpr extends AbstractNode {\n\n    /* DEFS */\n\n    static get syntaxRules() {\n        return [\n            { type: 'operator', as: 'operator', value: ['-', '+', 'NOT', 'EXISTS'] },\n            { type: 'Expr', as: 'operand', autoSpacing: ['NOT', 'EXISTS'] },\n        ];\n    }\n\n    static get syntaxPriority() { return 1;/* higher than BinaryExpr */ }\n\n    /* AST API */\n\n    operator() { return this._get('operator'); }\n\n    operand() { return this._get('operand'); }\n}", "import { Identifier } from './Identifier.js';\n\nexport class ColumnNameRef extends Identifier {\n\n    /* SYNTAX RULES */\n\n    static get syntaxPriority() { return -1; }\n\n    /* API */\n\n    selectSchema(filter = null) {\n        const name = this.value();\n        const tableSchemaInScope = this.capture('CONTEXT.TABLE_SCHEMA');\n        const columnSchemas = name\n            ? [].concat(tableSchemaInScope?.column(name) || [])\n            : tableSchemaInScope.columns();\n        return filter ? columnSchemas.filter(filter) : columnSchemas;\n    }\n}", "export class ErrorRefAmbiguous extends Error {}", "export class ErrorRefUnknown extends Error {}", "import { _isObject } from '@webqit/util/js/index.js';\nimport { ErrorRefAmbiguous } from './ErrorRefAmbiguous.js';\nimport { ErrorRefUnknown } from './ErrorRefUnknown.js';\nimport { registry } from '../registry.js';\n\nexport const QualifierMixin = (Class) => class extends Class {\n\n\t/* DESUGARING API */\n\t\n\tjsonfy(options = {}, transformCallback = null) {\n\t\tlet resultJson = super.jsonfy(options, transformCallback);\n\t\tif (!resultJson.qualifier && (options.deSugar || options.fullyQualified)) {\n\t\t\tconst qualifier = this.qualifier(true).jsonfy(options, transformCallback);\n\t\t\tresultJson = {\n\t\t\t\t...resultJson,\n\t\t\t\tqualifier: qualifier.value ? qualifier : undefined\n\t\t\t};\n\t\t}\n\t\treturn resultJson;\n\t}\n\t\n\t/* API */\n\n\tqualifier(init = null) {\n\t\tconst qualifier = this._get('qualifier');\n\t\tif (!arguments.length) return qualifier;\n\t\t// Return a fresh instance\n\t\tif (init !== true && typeof init !== 'string') {\n\t\t\tthrow new TypeError('\"init\" must be true or a string.');\n\t\t}\n\t\tconst name = this._get('value');\n\t\tif (!name && !qualifier && init === true) {\n\t\t\tthrow new TypeError('Can\\'t auto-resolve qualifier for anonymous ident.');\n\t\t}\n\t\tconst QualifierNode = registry[this.constructor._qualifierType];\n\t\tconst instance = QualifierNode.fromJSON(init === true && qualifier?.jsonfy() || { value: init !== true ? '' : init });\n\t\tthis._adoptNodes(instance);\n\t\t// If typeof init === 'string'\n\t\t// - it becomes value of instance, and that's all\n\t\t// If init === true:\n\t\t// - if qualifier, instance is first a clone of qualifier\n\t\t// - if not qualifier, then instance is initially empty\n\t\tif (init === true && !qualifier) {\n\t\t\tconst entriesField = `${this.constructor._domainKind}s`;\n\t\t\tconst possibleQualifierSchemas = instance.selectSchema((possibleQualifierSchema) => possibleQualifierSchema._has(entriesField, name));\n\t\t\tif (possibleQualifierSchemas.length > 1) {\n\t\t\t\tconst refs = possibleQualifierSchemas.map((s) => this.constructor.fromJSON({ qualifier: s.name(), value: this.value() }));\n\t\t\t\tthrow new ErrorRefAmbiguous(`[${this.clone({ fullyQualified: true })}]: ${this.value()} is ambiguous. (Is it ${refs.join(' or ')}?)`);\n\t\t\t} else if (!possibleQualifierSchemas.length) {\n\t\t\t\tthrow new ErrorRefUnknown(`[${this.clone({ fullyQualified: true })}]: ${this.value()} is unknown.`);\n\t\t\t}\n\t\t\tinstance._set('value', possibleQualifierSchemas[0].name());\n\t\t}\n\t\treturn instance;\n\t}\n\n\tselectSchema(filter = null) {\n\t\tconst name = this.value();\n\t\tconst possibleParentSchemas = this.qualifier(true).schema();\n\t\tconst entriesField = `${this.constructor._domainKind}s`;\n\t\treturn possibleParentSchemas.reduce((schemas, possibleParentSchema) => {\n\t\t\t// \"If\" we have a name...\n\t\t\tconst matches = name\n\t\t\t\t// narrow down to us within possibleParentSchema\n\t\t\t\t? [].concat(possibleParentSchema._get(entriesField, name) || [])\n\t\t\t\t// otherwise, select all children of our kind\n\t\t\t\t: possibleParentSchema._get(entriesField);\n\t\t\t// Optionally further filter matches\n\t\t\treturn schemas.concat(filter ? matches.filter(filter) : matches);\n\t\t}, []);\n\t}\n\n\tidentifiesAs(ident) {\n\t\tif (ident instanceof Class) {\n\t\t\treturn this._eq(this.value(), ident.value(), 'ci')\n\t\t\t\t&& (!ident.qualifier() || !!this.qualifier(true).identifiesAs(ident.qualifier()));\n\t\t}\n\t\treturn super.identifiesAs(ident);\n\t}\n\n\tstatic fromJSON(inputJson, options = {}, callback = null) {\n\t\tif (typeof inputJson === 'string') {\n\t\t\tinputJson = { value: inputJson, qualifier: null };\n\t\t} else if (Array.isArray(inputJson) && inputJson.some((s) => typeof s === 'string') && (inputJson = inputJson.slice())) {\n\t\t\tinputJson = { value: inputJson.pop(), qualifier: inputJson.pop() };\n\t\t} else if (!_isObject(inputJson)) return;\n\t\treturn super.fromJSON(inputJson, options, callback);\n\t}\n};", "import { QualifierMixin } from '../../abstracts/QualifierMixin.js';\nimport { Identifier } from './Identifier.js';\n\nexport class ColumnRef extends QualifierMixin(Identifier) {\n\n    /* SYNTAX RULES */\n\n    static get _domainKind() { return 'column'; }\n\n    static get _qualifierType() { return 'TableAbstractionRef'; }\n\n    static get syntaxRules() {\n        return [\n            {\n                optional: true,\n                syntaxes: [\n                    [\n                        { type: 'LQBackRefConstructor', as: 'qualifier', peek: [1, 'punctuation', '.'] },\n                        { type: 'punctuation', value: '.', assert: true, autoSpacing: false },\n                    ],\n                    [\n                        { type: this._qualifierType, as: 'qualifier', peek: [1, 'version_spec'] },\n                        { type: 'punctuation', value: '.', assert: true, autoSpacing: false },\n                    ],\n                    [\n                        { type: this._qualifierType, as: 'qualifier', peek: [1, 'punctuation', '.'] },\n                        { type: 'punctuation', value: '.', assert: true, autoSpacing: false },\n                    ],\n                ],\n            },\n            {\n                syntaxes: [\n                    { ...[].concat(super.syntaxRules)[0] },\n                    { type: 'operator', as: '.', value: '*' },\n                ],\n                autoSpacing: false\n            }\n        ];\n    }\n\n    static get syntaxPriority() { return 51; } // above LQBackRefConstructor\n}", "import { Identifier } from './Identifier.js';\n\nexport class DatabaseRef extends Identifier {\n\n\t/* SYNTAX RULES */\n\n\tstatic get syntaxRules() {\n\t\treturn [\n            ...[].concat(super.syntaxRules),\n            { type: 'LQVersionSpec', as: 'version_spec', optional: true, autoSpacing: false }\n        ];\n\t}\n\n    static get syntaxPriority() { return -1; }\n\n    /* DESUGARING API */\n\n    versionSpec() { return this._get('version_spec'); }\n\n    /* API */\n\n    selectSchema(filter = null) {\n        const name = this.value();\n        const rootSchemaInScope = this.capture('CONTEXT.ROOT_SCHEMA');\n        const databasesSchemas = name\n            ? [].concat(rootSchemaInScope?.database(name) || [])\n            : rootSchemaInScope.databases();\n        return filter ? databasesSchemas.filter(filter) : databasesSchemas;\n    }\n}\n", "import { SugarMixin } from '../../../abstracts/SugarMixin.js';\nimport { BinaryExpr } from '../../op/BinaryExpr.js';\n\nexport class AbstractMagicRef extends SugarMixin(BinaryExpr) {}", "export class ErrorFKInvalid extends Error {\n\n    constructor(message) {\n        super(message);\n        this.name = 'ErrorFKInvalid';\n    }\n\n}", "import { AbstractMagicRef } from './abstracts/AbstractMagicRef.js';\nimport { ErrorFKInvalid } from './abstracts/ErrorFKInvalid.js';\nimport { registry } from '../../registry.js';\n\nconst {\n\tLQDeepRef,\n} = registry;\n\nexport class LQBackBackRef extends AbstractMagicRef {\n\n\t/* SYNTAX RULES */\n\n\tstatic get _leftType() { return ['ColumnRef'/* must come first to prevent left-recursion */, 'LQBackBackRef']; } // for inheritance\n\n\tstatic get syntaxRules() {\n\t\treturn [\n\t\t\t{ type: this._leftType, as: 'left', peek: [1, 'operator', '<~'] },\n\t\t\t{ type: 'operator', value: '<~' },\n\t\t\t{ type: 'ColumnNameRef', as: 'right', peek: [1, 'operator', '<~'] },\n\t\t];\n\t}\n\n\tstatic get syntaxPriority() { return 1; }\n\n\tstatic morphsTo() { return LQDeepRef; }\n\n\t/* DESUGARING API */\n\t\n\tjsonfy(options = {}, transformCallback = null) {\n\t\tif (options.reverseRef) {\n\t\t\treturn {\n\t\t\t\tnodeName: LQDeepRef.NODE_NAME,\n\t\t\t\tleft: this.right().jsonfy(options, transformCallback),\n\t\t\t\tright: this.left().jsonfy(options, transformCallback),\n\t\t\t};\n\t\t}\n\t\treturn super.jsonfy(options, transformCallback);\n\t}\n\n\t/* SYSTEM HOOKS */\n\n\t_capture(requestName, requestSource) {\n\t\tif (requestName === 'CONTEXT.TABLE_SCHEMA' && requestSource === this.left()) {\n\t\t\treturn this.tableSchema();\n\t\t}\n\t\treturn super._capture(requestName, requestSource);\n\t}\n\n\t/* API */\n\n\ttableSchema() {\n\t\tconst fk = this.right().columnSchema().foreignKey();\n\t\tif (!fk) throw new ErrorFKInvalid(`[${this}]: Column ${this.right().clone({ fullyQualified: true })} is not a foreign key.`);\n\t\treturn fk.targetTable()/*the table in there*/.tableSchema();\n\t}\n\n\tendpoint() { return this.left() instanceof LQBackBackRef ? this.left().endpoint() : this.left(); }\n}", "import { LQBackBackRef } from './LQBackBackRef.js';\nimport { ErrorFKInvalid } from './abstracts/ErrorFKInvalid.js';\nimport { registry } from '../../registry.js';\n\nconst {\n\tColumnRef,\n\tTableRef,\n} = registry;\n\nexport class LQBackRef extends LQBackBackRef {\n\n\t/* SYNTAX RULES */\n\n\tstatic get syntaxRules() {\n\t\treturn [\n\t\t\t{ type: this._leftType, as: 'left', peek: [1, 'operator', '<~'] },\n\t\t\t{ type: 'operator', value: '<~' },\n\t\t\t{ type: 'TableRef', as: 'right' }\n\t\t];\n\t}\n\n\tstatic get syntaxPriority() { return 0; }\n\n\t/* SYSTEM HOOKS */\n\n\t_capture(requestName, requestSource) {\n\t\tif (requestName === 'CONTEXT.TABLE_SCHEMA') {\n\t\t\treturn this.tableSchema();\n\t\t}\n\t\treturn super._capture(requestName, requestSource);\n\t}\n\n\t/* API */\n\n\ttableSchema() { return this.right().tableSchema(); }\n\n\tgetOperands() {\n\t\tlet keyLeft_ref, keyRight_ref;\n\t\tconst left = this.left();\n\t\tconst leftEndpoint = left instanceof LQBackBackRef\n\t\t\t? left.endpoint()\n\t\t\t: left;\n\t\tconst leftFk = leftEndpoint.columnSchema().foreignKey();\n\t\tif (!leftFk) throw new ErrorFKInvalid(`[${this}]: Column ${leftEndpoint.clone()} is not a foreign key.`);\n\t\tconst leftEndpointTable = leftFk.targetTable();\n\t\tconst querySchema = this.capture('CONTEXT.QUERY_SCHEMA'); // Intentionally using capture here\n\t\tfor (const $col of querySchema/*query*/.columns()) {\n\t\t\tif (!$col.primaryKey()) continue;\n\t\t\tif ($col.qualifier(true).identifiesAs(leftEndpointTable)) {\n\t\t\t\tconst $keyLeft_ref = ColumnRef.fromJSON({\n\t\t\t\t\tqualifier: $col.parentSchema(true).name(),\n\t\t\t\t\tvalue: $col.name()\n\t\t\t\t});\n\t\t\t\tif (keyLeft_ref) throw new Error(`[${this}]: Target primary key for foreign key ${leftEndpoint.clone()} is ambiguous. (Is it ${keyLeft_ref} or ${$keyLeft_ref}?)`);\n\t\t\t\tkeyLeft_ref = $keyLeft_ref;\n\t\t\t}\n\t\t}\n\t\tif (!keyLeft_ref) {\n\t\t\tif (0) {\n\t\t\t\t// TODO\n\t\t\t} else throw new Error(`LQBackRef ${this} could not be resolved against table query.`);\n\t\t}\n\t\tkeyRight_ref = left instanceof LQBackBackRef\n\t\t\t? left.clone({ reverseRef: true })\n\t\t\t: left.clone();\n\t\tconst targetTable_schema = this.tableSchema();\n\t\tconst targetTable_ref = TableRef.fromJSON({\n\t\t\tqualifier: targetTable_schema.parentSchema(true).name(),\n\t\t\tvalue: targetTable_schema.name()\n\t\t});\n\t\treturn {\n\t\t\ttable: targetTable_ref,\n\t\t\tleft: keyLeft_ref,\n\t\t\tright: keyRight_ref,\n\t\t};\n\t}\n}\n", "import { AbstractMagicRef } from './abstracts/AbstractMagicRef.js';\nimport { ErrorFKInvalid } from './abstracts/ErrorFKInvalid.js';\n\nexport class LQDeepDeepRef extends AbstractMagicRef {\n\n\t/* SYNTAX RULES */\n\n\tstatic get _rightType() { return ['LQDeepDeepRef', 'LQObjectLiteral', 'LQArrayLiteral', 'ColumnsConstructor', 'ColumnNameRef']; } // for inheritance\n\n\tstatic get syntaxRules() {\n\t\treturn [\n\t\t\t{ type: 'ColumnNameRef', as: 'left', peek: [1, 'operator', '~>'] },\n\t\t\t{ type: 'operator', value: '~>' },\n\t\t\t{ type: this._rightType, as: 'right' },\n\t\t];\n\t}\n\n\tstatic get syntaxPriority() { return -1; }\n\n\t/* SYSTEM HOOKS */\n\n\t_capture(requestName, requestSource) {\n\t\tif (requestName === 'CONTEXT.TABLE_SCHEMA' && requestSource === this.right()) {\n\t\t\treturn this.tableSchema();\n\t\t}\n\t\treturn super._capture(requestName, requestSource);\n\t}\n\n\t/* API */\n\n\ttableSchema() {\n\t\tconst fk = this.left().columnSchema().foreignKey();\n\t\tif (!fk) throw new ErrorFKInvalid(`[${this}]: Column ${this.left().clone({ fullyQualified: true })} is not a foreign key.`);\n\t\treturn fk.targetTable()/*the table in there*/.tableSchema();\n\t}\n\n\tendpoint() { return this.right() instanceof LQDeepDeepRef ? this.right().endpoint() : this.right(); }\n}", "import { LQDeepDeepRef } from './LQDeepDeepRef.js';\nimport { registry } from '../../registry.js';\n\nconst {\n\tLQBackRefConstructor,\n\tColumnNameRef,\n\tTableRef,\n} = registry;\n\nexport class LQDeepRef extends LQDeepDeepRef {\n\n\t/* SYNTAX RULES */\n\n\tstatic get syntaxRules() {\n\t\treturn [\n\t\t\t{\n\t\t\t\tsyntaxes: [\n\t\t\t\t\t[\n\t\t\t\t\t\t{ type: ['ColumnRef', 'LQBackRefConstructor'], as: 'left', peek: [1, 'operator', '~>'] }, // fk ~> col | (fk2 <~ fk1 <~ tbl) ~> col\n\t\t\t\t\t\t{ type: 'operator', value: '~>' },\n\t\t\t\t\t],\n\t\t\t\t\t[\n\t\t\t\t\t\t{ type: 'ColumnRef', as: 'left', peek: [3, 'operator', '~>'] }, // tbl.fk ~> col | (fk2 <~ fk1 <~ tbl).fk ~> col\n\t\t\t\t\t\t{ type: 'operator', value: '~>' },\n\t\t\t\t\t]\n\t\t\t\t]\n\t\t\t},\n\t\t\t{ type: this._rightType, as: 'right' },\n\t\t];\n\t}\n\n\tstatic get syntaxPriority() { return 1; }\n\n\t/* API */\n\n\ttableSchema() {\n\t\tif (this.left() instanceof LQBackRefConstructor) {\n\t\t\treturn this.left().tableSchema();\n\t\t}\n\t\treturn super.tableSchema();\n\t}\n\n\tgetOperands() {\n\t\tconst targetTable_schema = this.tableSchema();\n\t\tconst keyLeft_ref = this.left().clone({ fullyQualified: true });\n\t\tconst keyRight_ref = ColumnNameRef.fromJSON({\n\t\t\tvalue: targetTable_schema.primaryKey().columns()[0]\n\t\t});\n\t\tconst targetTable_ref = TableRef.fromJSON({\n\t\t\tqualifier: targetTable_schema.parentSchema(true).name(),\n\t\t\tvalue: targetTable_schema.name()\n\t\t});\n\t\treturn {\n\t\t\ttable: targetTable_ref,\n\t\t\tleft: keyLeft_ref,\n\t\t\tright: keyRight_ref,\n\t\t};\n\t}\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class StarRef extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() { return { type: 'operator', value: '*', as: '.' }; }\n\n    static get syntaxPriority() { return -1; }\n\n    /* AST API */\n\n    value() { return this._get('value'); }\n}", "import { QualifierMixin } from '../../abstracts/QualifierMixin.js';\nimport { Identifier } from './Identifier.js';\n\nexport class TableRef extends QualifierMixin(Identifier) {\n\n\t/* SYNTAX RULES */\n\n\tstatic get _domainKind() { return 'table'; }\n\n\tstatic get _qualifierType() { return 'DatabaseRef'; }\n\n\tstatic get syntaxRules() {\n\t\treturn [\n\t\t\t{\n\t\t\t\toptional: true,\n\t\t\t\tsyntaxes: [\n\t\t\t\t\t[\n\t\t\t\t\t\t{ type: this._qualifierType, as: 'qualifier', peek: [1, 'punctuation', '.'] },\n\t\t\t\t\t\t{ type: 'punctuation', value: '.', assert: true, autoSpacing: false },\n\t\t\t\t\t],\n\t\t\t\t\t[\n\t\t\t\t\t\t{ type: this._qualifierType, as: 'qualifier', peek: [1, 'version_spec'] },\n\t\t\t\t\t\t{ type: 'punctuation', value: '.', assert: true, autoSpacing: false },\n\t\t\t\t\t]\n\t\t\t\t],\n\t\t\t},\n\t\t\t{ ...[].concat(super.syntaxRules)[0], autoSpacing: false },\n\t\t];\n\t}\n\n\tstatic get syntaxPriority() { return -1; }\n}", "import { TableRef } from './TableRef.js';\n\nexport class TableAbstractionRef extends TableRef {\n\n    /* API */\n\n    selectSchema(filter = null) {\n        const name = this.value();\n        const databaseSchemaInScope = this.capture('CONTEXT.QUERY_SCHEMA');\n        const tableSchemas = name\n            ? [].concat(databaseSchemaInScope?.table(name) || [])\n            : databaseSchemaInScope.tables();\n        return filter ? tableSchemas.filter(filter) : tableSchemas;\n    }\n}", "import { Identifier } from './Identifier.js';\n\nexport class WindowRef extends Identifier {\n    \n    /* SYNTAX RULES */\n\n    static get syntaxPriority() { return -1; }\n}", "import { SugarMixin } from '../../../abstracts/SugarMixin.js';\nimport { AbstractNodeList } from '../../../abstracts/AbstractNodeList.js';\n\nexport class AbstractLQShapeLiteral extends SugarMixin(AbstractNodeList) {}", "import { AbstractLQShapeLiteral } from './abstracts/AbstractLQShapeLiteral.js';\nimport { registry } from '../../registry.js';\n\nconst {\n    CallExpr,\n} = registry;\n\nexport class LQArrayLiteral extends AbstractLQShapeLiteral {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return {\n            syntax: [\n                {\n                    type: 'bracket_block',\n                    syntax: { type: 'Expr', as: 'entries', arity: Infinity, itemSeparator, autoIndent: 2 },\n                },\n            ],\n        };\n    }\n\n    /* DESUGARING API */\n\n    jsonfy(options = {}, transformCallback = null) {\n        if (options.deSugar) {\n            return {\n                nodeName: CallExpr.NODE_NAME,\n                name: (options.toDialect || this.options.dialect) === 'mysql' ? 'JSON_ARRAY' : 'JSON_BUILD_ARRAY',\n                entries: this.entries().map((e) => e.jsonfy(options, transformCallback)),\n            };\n        }\n        return super.jsonfy(options, transformCallback);\n    }\n}", "import { AbstractLQShapeLiteral } from './abstracts/AbstractLQShapeLiteral.js';\nimport { registry } from '../../registry.js';\n\nconst {\n    StringLiteral,\n    CallExpr,\n} = registry;\n\nexport class LQObjectLiteral extends AbstractLQShapeLiteral {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return {\n            syntax: [\n                {\n                    type: 'brace_block',\n                    syntax: { type: 'LQObjectProperty', as: 'entries', arity: Infinity, itemSeparator, autoIndent: 2 },\n                },\n            ],\n        };\n    }\n\n    /* DESUGARING API */\n\n    jsonfy(options = {}, transformCallback = null) {\n        let resultJson = super.jsonfy(options, transformCallback);\n        if (options.deSugar) {\n            resultJson = {\n                nodeName: CallExpr.NODE_NAME,\n                name: (options.toDialect || this.options.dialect) === 'mysql' ? 'JSON_OBJECT' : 'JSON_BUILD_OBJECT',\n                arguments: resultJson.entries.reduce((args, propertyJson) => {\n                    return args.concat(\n                        { nodeName: StringLiteral.NODE_NAME, value: propertyJson.key },\n                        propertyJson.value\n                    );\n                }, []),\n            };\n        }\n        return resultJson;\n    }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\nimport { registry } from '../../registry.js';\n\nconst {\n    AggrCallExpr,\n    ColumnRef,\n} = registry;\n\nexport class LQObjectProperty extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'identifier', as: 'key' },\n            {\n                optional: true,\n                syntax: [\n                    { type: 'AggrNotation', as: 'is_aggr', optional: true },\n                    { type: 'punctuation', value: ':', autoSpacing: false },\n                    { type: 'Expr', as: 'value', assert: true },\n                ],\n                autoSpacing: false,\n            },\n        ];\n    }\n\n    static get syntaxPriority() { return -1; }\n\n    get isProperty() { return true; }\n\n    /* AST API */\n\n    key() { return this._get('key'); }\n\n    isAggr() { return this._get('is_aggr'); }\n\n    value() { return this._get('value'); }\n\n    /* DESUGARING API */\n\n    jsonfy(options = {}, transformCallback = null) {\n        if (options.deSugar) {\n            let valueJson;\n            if (this.isAggr()) {\n                // Note the below where we wrap value in an aggr call\n                valueJson = {\n                    nodeName: AggrCallExpr.NODE_NAME,\n                    name: (options.toDialect || this.options.dialect) === 'mysql' ? 'JSON_ARRAYAGG' : 'JSON_AGG',\n                    arguments: [this.value().jsonfy({ ...options, asAggr: true/* for use by any Back/DeefRef */ }, transformCallback)],\n                };\n            } else {\n                // Note the below where we derive value, if not specified, from key\n                valueJson = this.value()?.jsonfy(options, transformCallback)\n                    ?? { nodeName: ColumnRef.NODE_NAME, value: this.key() };\n            }\n            // plus, we'll drop the is_aggr flag\n            return {\n                nodeName: LQObjectProperty.NODE_NAME,\n                key: this.key(),\n                is_aggr: false,\n                value: valueJson\n            };\n        }\n        return super.jsonfy(options, transformCallback);\n    }\n}", "import { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\nimport { registry } from '../../registry.js';\n\nconst {\n    CallExpr,\n} = registry;\n\nexport class PGArrayLiteral extends AbstractNodeList {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return {\n            dialect: 'postgres',\n            syntax: [\n                { type: 'keyword', value: 'ARRAY' },\n                {\n                    type: 'bracket_block',\n                    syntax: { type: 'Expr', as: 'entries', arity: Infinity, itemSeparator, autoIndent: 2 },\n                    autoSpacing: false,\n                },\n            ],\n        };\n    }\n\n    /* DESUGARING API */\n\n    jsonfy(options = {}, transformCallback = null) {\n        if ((options.toDialect || this.options.dialect) === 'mysql') {\n            return {\n                nodeName: CallExpr.NODE_NAME,\n                name: 'JSON_ARRAY',\n                arguments: this.entries().map((e) => e.jsonfy(options, transformCallback)),\n            };\n        }\n        return super.jsonfy(options, transformCallback);\n    }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class BindVar extends AbstractNode {\n\n\t/* SYNTAX RULES */\n\n    static get syntaxRules() { return { type: 'bind_var', as: '.' }; }\n\n    /* AST API */\n\n    value() { return Number(this._get('value')); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class SystemVar extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() { return { type: 'system_var', as: '.' }; }\n\n    /* AST API */\n\n    value() { return this._get('value'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class UserVar extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() { return { type: 'user_var', as: '.' }; }\n\n    /* AST API */\n\n    value() { return this._get('value'); }\n}", "import { AbstractNode } from '../abstracts/AbstractNode.js';\nimport * as exprs from './index.js';\n\nexport class Expr extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return { type: ExprNamesInOrder, expression: true };\n    }\n\n    /* API */\n\n    static [Symbol.hasInstance](instance) {\n        return instance.constructor.name in exprs;\n    }\n}\n\nconst ExprNames = Object.keys(exprs);\nconst ExprNamesInOrder = ExprNames.filter((k) => {\n    return exprs[k] !== Expr && exprs[k].syntaxPriority !== -1;\n}).sort((a, b) => {\n    const comp = (exprs[b].syntaxPriority ?? 100) - (exprs[a].syntaxPriority ?? 100);\n    if (comp === 0) return exprs[b].prototype.isPrototypeOf(exprs[a].prototype) ? -1 : 1;\n    return comp;\n});\n", "export { AggrNotation } from './AggrNotation.js';\nexport { LQVersionSpec } from './LQVersionSpec.js';\n", "import { AbstractNode } from '../abstracts/AbstractNode.js';\n\nexport class AggrNotation extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            type: 'bracket_block', syntax: { type: 'Expr', as: '_', arity: 0, assert: true }\n        };\n    }\n\n    static get syntaxPriority() { return -1; }\n}", "import { AbstractNode } from '../abstracts/AbstractNode.js';\n\nexport class LQVersionSpec extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() { return { type: 'version_spec', as: '.' }; }\n\n    static get syntaxPriority() { return -1; }\n\n    /* AST API */\n\n    value() { return this._get('value'); }\n}", "export { DataType } from './DataType.js';\n", "import { AbstractNode } from '../abstracts/AbstractNode.js';\n\nexport class DataType extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'data_type', as: '.' },\n            {\n                type: 'paren_block',\n                syntax: { type: 'Expr', as: 'specificity', arity: Infinity, itemSeparator, assert: true },\n                optional: true,\n                optionalParens: true,\n                autoSpacing: false\n            },\n            { type: 'AggrNotation', as: 'pg_is_aggr', autoSpacing: false, optional: true, dialect: 'postgres' },\n        ];\n    }\n\n    /* AST API */\n\n    value() { return this._get('value'); }\n\n    specificity() { return this._get('specificity'); }\n\n    // -- Postgres\n\n    pgIsAggr() { return this._get('pg_is_aggr'); }\n}", "import * as cte from './cte/index.js';\nimport * as ddl from './ddl/index.js';\nimport * as dml from './dml/index.js';\nimport * as dql from './dql/index.js';\nimport * as expr from './expr/index.js';\nimport * as qualif from './qualif/index.js';\nimport * as type from './type/index.js';\nimport { registry } from './registry.js';\n\nObject.assign(registry, { ...cte, ...ddl, ...dml, ...dql, ...expr, ...qualif, ...type });\n", "import { AbstractNodeList } from './abstracts/AbstractNodeList.js';\n\nexport class Query extends AbstractNodeList {\n\n    /* SYNTAX RULES */\n\n    static get _contentTypes() {\n        return [\n            'SelectStmt',\n            'TableStmt',\n            'InsertStmt',\n            'UpsertStmt',\n            'UpdateStmt',\n            'DeleteStmt',\n            'MYSetStmt',\n            'CTE'\n        ];\n    }\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ';' };\n        return { type: this._contentTypes, as: 'entries', arity: Infinity, itemSeparator, autoSpacing: '\\n' };\n    }\n\n    /* API */\n\n    static async parse(input, options = {}) {\n        const { result, tokenStream } = await super.parse(input, { returningTokenStream: true, ...options });\n        if (!tokenStream.done && tokenStream.current()) {\n            const current = tokenStream.current();\n\t\t\tconst message = `[${this.NODE_NAME}] Unexpected token:${typeof current.value === 'string' ? ` \"${current.value}\" (${current.type})` : ''} at <line ${current.line}, column ${current.column}>`;\n            throw new Error(message);\n        }\n        return result;\n    }\n\n    stringify(options = {}) { return `${super.stringify(options)};`; }\n}"],
  "mappings": "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",
  "names": ["cte_exports", "__export", "CTE", "CTEBinding", "PGCycleClause", "PGSearchClause", "isObject_default", "val", "_eq", "a", "b", "caseMatch", "ignoreList", "x", "i", "isObject_default", "temp", "$ignoreList", "k", "prev", "_toCapsSnake", "str", "result", "toktypes_exports", "__export", "TOK_TYPES", "aggrFunctionNames", "dataTypes", "functionNames", "keywords", "operators", "statements", "dialect", "mysqlAnsiQuotes", "value", "TokenStreamState", "by", "isLf", "TokenStream", "#iterator", "#options", "#locked", "#started", "#done", "#rootSavepoint", "#history", "#current", "#peeks", "iterator", "_", "options", "#assertNotLocked", "value", "done", "#historyPush", "#peeksShift", "$type", "$value", "peek", "type", "match", "tok", "i", "length", "$length", "next", "#peeksPush", "#historyPop", "#peeksUnshift", "method", "point", "toIndex", "input", "dialect", "state", "normalizeOptions", "stream", "localState", "$finalizeToken", "token", "forceYield", "finalizeToken", "chunk", "char", "possiblyChunked", "charIsWhitespace", "whitespace", "$throw", "isString", "isDelimitedIdent", "isBlockComment", "isLineComment", "prevChar", "nextChar", "strings_inBackslashEscapeMode", "strings_atEscapePosition", "tokenEndSteps", "cursor", "tokenStart", "tokenStartBacksteps", "tokenStartForwardsteps", "__", "restTok", "modifierPattern", "modifierMatch", "modifier", "groupToken", "previousChar", "addMultiWord", "targetMap", "prefix", "_tok", "tokenCategory", "$tokenCategory", "tokenRegistry", "tokenDialectBranch", "entries", "toktypes_exports", "entry", "finalizeComment", "finalToken", "identResolution", "line", "column", "finalizeIdentifier", "s", "multiwordBufferLength", "wordSoFar", "findInBranch", "branch", "matchResult", "processExactMatch", "spaceBefore", "processPartialMatch", "multiwordMatched", "tokenCategory2", "matchResult2", "existing", "current", "registry", "AbstractNode", "_AbstractNode", "_toCapsSnake", "#ast", "#options", "#astSchema", "ast", "options", "node_s", "#contextNode", "fieldName", "index", "fieldSchema", "activeTrailStr", "indexOrValue", "valueOnIndex", "value", "existing", "all", "n", "count", "isObject_default", "i", "args", "nodes", "node", "visitor", "possibleNode", "requestName", "requestSource", "eventType", "eventSource", "possibleChild", "_eq", "dialect", "resultJson", "prev", "C", "cacheKey", "result", "syntaxRules", "rulesArray", "trail", "schemaSet", "assertionTrail", "newDependencyTrail", "cloneSchemaSet", "sch", "rule", "type", "exposure", "inference", "arity", "modifier", "booleanfy", "optional", "assert", "syntax", "syntaxes", "rest", "activeTrail", "unsupportedAttrs", "_getUnsupportedRuleAttrs", "isTokenRule", "TOK_TYPES", "t", "registry", "keys", "k", "a", "schema", "newAssertionTrail", "newSchemaSet", "j", "schemaSetClone", "schemaSetCloneResult", "resultSchema", "schemasArray", "schemaA", "schemaAObj", "schemaB", "schemaBObj", "inputJson", "callback", "astSchema", "hardCodedNodeName", "lastAssertion", "$decideThrow", "message", "rulePath", "assertsGrep", "matchTokenRule", "fieldJson", "expectedValue", "resolveField", "fieldValue", "acquireField", "resultAST", "depField", "_inferenceMatch", "resultArray", "entry", "resultLenth", "paths_loop", "$astSchema", "$inputJson", "rootRule", "tokSchema", "attr", "indexHint", "transformCallback", "jsonfy", "key", "originalValue", "entries", "input", "left", "minPrecedence", "returningTokenStream", "tokenStream", "TokenStream", "savepoint", "types", "operator", "prevLeft", "newLeft", "numSkippedRules_dialectWise", "newMinPrecedence", "requiredSpacing", "peek", "itemSeparator", "acquireLeft", "peekToken", "name", "matchSpacing", "current", "adjustBy", "eatToken", "op", "tok", "parseNode", "activeTokenStream", "NodeClass", "tokenStreamPosition", "proximityTerm", "_type", "line", "column", "spaceBefore", "prec", "assoc", "itemMinPrecedence", "relevantOperatorDef", "currentAsUnexpected", "startingIndentLevel", "autoLineBreakThreshold", "renderingStats", "$space", "$lineBreak", "indentLevel", "resultTokens", "numSkippedRules_optionalWise", "autoSpacing", "optionalParens", "autoIndent", "autoIndentAdjust", "$autoIndent", "activeOptions", "rendering", "highestRenderingScore", "newRenderingStats", "$rendering", "hasExpectedValue", "$rule", "shouldRender", "itemsRendering", "$autoItemSpacing", "$itemSeparator", "autoSpaceIgnore", "blockAutoLineBreakMode", "delims", "precedingTok", "delimChars", "delimChar", "escChar", "defs", "match", "indent", "lines", "supportedRuleAttrs", "criteria", "exp", "PGCycleClause", "AbstractNode", "PGSearchClause", "AbstractNode", "AbstractStmt", "AbstractNode", "#rand", "key", "#uuid", "inputJson", "options", "uuid", "restJson", "node", "AbstractNonDDLStmt", "AbstractStmt", "requestName", "requestSource", "result", "values", "queryBindings", "i", "bindings", "b", "dedupe", "redundants", "$offset", "newOffset", "CTE", "AbstractNonDDLStmt", "CTEBinding", "AbstractNode", "ddl_exports", "__export", "CreateTableStmt", "CompleteSelectStmt", "SubqueryConstructor", "FromClause", "JoinClause", "OnClause", "GroupByClause", "FromElement", "SelectElement", "CompositeAlias", "BasicAlias", "TableAbstractionRef", "ColumnRef", "BinaryExpr", "LQDeepRef", "LQBackRef", "LQBackRefConstructor", "registry", "SelectorStmtMixin", "Class", "options", "superTransformCallback", "selectorDimensions", "transformCallback", "node", "keyHint", "deSugar", "$options", "select", "alias", "resultJson", "LQRef", "asAggr", "left", "right", "table", "dimensionID", "rightMask", "fieldSpec", "joinJson", "selectorDimension", "detail", "selectAlias", "FromElement", "BasicTableExpr", "TableRef", "BasicAlias", "CompositeAlias", "TableAbstractionRef", "ColumnRef", "SelectElement", "FromClause", "CompleteSelectStmt", "SubqueryConstructor", "BinaryExpr", "registry", "CreateTableStmt", "SelectorStmtMixin", "AbstractNonDDLStmt", "itemSeparator", "resultJson", "selectorDimensions", "options", "rand", "tblRefOriginal", "tblAliasOriginal", "tblAliasRewrite", "whereClauseOriginal", "pk", "d", "dml_exports", "__export", "AssignmentExpr", "BasicTableExpr", "ColumnsConstructor", "DeleteStmt", "InsertStmt", "MYOnDuplicateKeyUpdateClause", "MYPartitionClause", "MYSetStmt", "MYStarredTableRef", "MYVarAssignmentExpr", "PGConflictTarget", "PGConflictTargetIndexSpec", "PGDefaultValuesClause", "PGOnConflictClause", "PGReturningClause", "PGWhereCurrentClause", "SetClause", "UpdateStmt", "UpsertStmt", "UsingFromClause", "AbstractNodeList", "AbstractNode", "index", "value", "args", "ColumnsConstructor", "AbstractNodeList", "BinaryExpr", "AbstractNode", "AssignmentExpr", "BinaryExpr", "BasicTableExpr", "AbstractNode", "MYOnDuplicateKeyUpdateClause", "AbstractNodeList", "MYPartitionClause", "AbstractNodeList", "MYStarredTableRef", "AbstractNode", "MYVarAssignmentExpr", "BinaryExpr", "PGConflictTarget", "AbstractNode", "PGConflictTargetIndexSpec", "AbstractNode", "PGDefaultValuesClause", "AbstractNode", "PGOnConflictClause", "AbstractNodeList", "PGReturningClause", "AbstractNodeList", "PGWhereCurrentClause", "AbstractNode", "SetClause", "AbstractNodeList", "UsingFromClause", "AbstractNodeList", "FromElement", "BasicTableExpr", "TableRef", "BasicAlias", "CompositeAlias", "TableAbstractionRef", "ColumnRef", "SelectElement", "FromClause", "CompleteSelectStmt", "SubqueryConstructor", "BinaryExpr", "registry", "DeleteStmt", "SelectorStmtMixin", "AbstractNonDDLStmt", "itemSeparator", "resultJson", "selectorDimensions", "options", "rand", "tblRefOriginal", "tblAliasOriginal", "tblAliasRewrite", "whereClauseOriginal", "pk", "d", "LQDeepRef", "LQBackRefConstructor", "ColumnNameRef", "ColumnRef", "TableRef", "BasicAlias", "AssignmentExpr", "ColumnsConstructor", "RowConstructor", "SetConstructor", "ValuesConstructor", "ValuesSetConstructor", "SelectStmt", "CompleteSelectStmt", "SubqueryConstructor", "SelectElement", "FromElement", "CompositeAlias", "FromClause", "SetClause", "PGReturningClause", "BinaryExpr", "BoolLiteral", "NumberLiteral", "StarRef", "CTE", "CTEBinding", "UpdateStmt", "InsertStmt", "UpsertStmt", "registry", "PayloadStmtMixin", "Class", "options", "superTransformCallback", "payloadDimensions", "specials", "s", "columnsList", "defaultValuesClause", "valuesClause", "selectClause", "hasTopLevelDeepRefs", "c", "ignoreList", "transformCallback", "node", "keyHint", "deSugar", "$options", "onConflictClauseContext", "$$options", "deSugaredLeft", "deSugaredRight", "deSugaredColumns", "resultJson", "deSugaredValues", "rowSet", "rowsJson", "rowSetJson", "columns", "values", "deSugarColumnsList", "dimensionsMap", "columnRef", "columnOffset", "dimension", "deSugarValuesFromSelect", "selectStmt", "baseSelect", "baseSelectList", "cteAlias", "cteSelect", "newBaseSelectFromElement", "newBaseSelectList", "selectList", "fieldJson", "subSelectList", "valueNode", "f", "deSugarValuesFromValues", "valuesEntries", "valuesRow", "rowOffset", "valueJson", "LQRefColumn", "left", "right", "table", "dimensionID", "leftJson", "rightJson", "columnsConstructorJson", "refRight", "columnsLength", "dimensionValidateRowLength", "rowNode", "rowLength", "createForeignBinding", "sourceUuid", "sourceCol", "sourceRowIndex", "innerFilter", "fieldExpr", "innerFilterExpr", "tableSpec", "onConflictUpdatedStatusAlias", "whereClause", "query", "payloadDimension", "payload", "payloadJson", "dimensionPushRow", "fKBindingJson", "rowJson", "fkField", "selectJson", "rightPKJson", "cte", "toBinding", "queryJson", "fromJSON", "dependents", "lefts", "onConflictUpdatedStatusRequired", "type", "existing", "_eq", "originalPGReturningClause", "newPGReturningClause", "InsertStmt", "PayloadStmtMixin", "AbstractNonDDLStmt", "itemSeparator", "optional_alias_mysql", "MYSetStmt", "AbstractNodeList", "SubqueryConstructor", "CompleteSelectStmt", "SelectElement", "BasicAlias", "CompositeAlias", "FromClause", "WhereClause", "ColumnRef", "TableAbstractionRef", "BinaryExpr", "TableRef", "FromElement", "registry", "UpdateStmt", "PayloadStmtMixin", "SelectorStmtMixin", "AbstractNonDDLStmt", "options", "selectorDimensions", "transformCallback", "node", "keyHint", "deSugar", "$options", "select", "alias", "resultJson", "rand", "pgGeneratedFromEntry", "createOrPatchAFromEntry", "columnRef", "tableExpr", "tblRefOriginal", "tblAliasOriginal", "colRefOriginal", "tblAliasRewrite", "colRefRewrite", "fromEntry", "whereClause", "joinJson", "binaryExpr", "SugarMixin", "Class", "UpsertStmt", "SugarMixin", "InsertStmt", "options", "resultJson", "columns", "c", "refFn", "col", "q", "onConflictClause", "tblSchema", "uniqueKeys", "uk", "conflictTarget", "keyComp", "dql_exports", "__export", "BasicAlias", "BasicSelectStmt", "CompleteSelectStmt", "CompositeAlias", "CompositeSelectStmt", "DistinctClause", "ForClause", "FromClause", "FromElement", "FunctionsSetConstructor", "GroupByClause", "GroupingElement", "HavingClause", "JoinClause", "LQBackRefConstructor", "LimitClause", "OffsetClause", "OnClause", "OrderByClause", "OrderElement", "PGFetchClause", "PGOrderOperator", "PartitionByClause", "RowConstructor", "SRFSpec", "SelectElement", "SelectStmt", "SetConstructor", "SubqueryConstructor", "TableStmt", "UsingClause", "ValuesConstructor", "ValuesSetConstructor", "WhereClause", "WindowClause", "WindowDeclaration", "WindowFrameBound", "WindowFrameSpec", "WindowSpec", "FunctionsSetConstructor", "AbstractNodeList", "ParenShape", "_ParenShape", "AbstractNode", "expr", "LQBackRef", "registry", "LQBackRefConstructor", "ParenShape", "requestName", "requestSource", "expr", "options", "transformCallback", "SetConstructor", "AbstractNodeList", "RowConstructor", "SetConstructor", "SubqueryConstructor", "ParenShape", "ValuesConstructor", "AbstractNodeList", "itemSeparator", "ValuesSetConstructor", "ValuesConstructor", "Identifier", "AbstractNode", "value", "BasicAlias", "Identifier", "CompositeAlias", "Identifier", "itemSeparator", "DistinctClause", "AbstractNode", "ForClause", "AbstractNode", "FromClause", "AbstractNodeList", "FromElement", "AbstractNode", "itemSeparator", "optional_alias", "optional_table_sample_clause_postgres", "optional_with_ordinality_clause_postgres", "GroupByClause", "AbstractNodeList", "GroupingElement", "AbstractNode", "HavingClause", "AbstractNode", "JoinClause", "FromElement", "LimitClause", "AbstractNode", "OffsetClause", "AbstractNode", "OnClause", "AbstractNode", "OrderByClause", "AbstractNodeList", "OrderElement", "AbstractNode", "PartitionByClause", "AbstractNodeList", "PGFetchClause", "AbstractNode", "PGOrderOperator", "AbstractNode", "CallExpr", "AbstractNode", "itemSeparator", "AggrCallExpr", "CallExpr", "itemSeparator", "optional_distinct_modifier", "optional_separator_arg", "optional_order_by_clause", "optional_filter_clause_postgres", "optional_within_group_clause_postgres", "optional_null_handling_directive", "optional_over_clause", "SelectElement", "_SelectElement", "AbstractNode", "options", "transformCallback", "exprJson", "AggrCallExpr", "aliasJson", "BasicAlias", "SRFSpec", "AbstractNode", "UsingClause", "AbstractNode", "WhereClause", "AbstractNode", "WindowClause", "AbstractNodeList", "WindowDeclaration", "AbstractNode", "WindowFrameSpec", "AbstractNode", "itemSeparator", "WindowFrameBound", "AbstractNode", "WindowSpec", "AbstractNode", "SelectStmt", "AbstractNonDDLStmt", "full", "LQObjectLiteral", "BasicAlias", "SelectElement", "registry", "BasicSelectStmt", "SelectorStmtMixin", "SelectStmt", "options", "resultJson", "selectList", "argPairs", "key", "arg", "alias", "expr", "CompleteSelectStmt", "BasicSelectStmt", "CompositeSelectStmt", "SelectStmt", "setTypes", "TableStmt", "AbstractStmt", "expr_exports", "__export", "AggrCallExpr", "AtTimeZoneExpr", "BetweenExpr", "BinaryExpr", "BindVar", "BitLiteral", "BoolLiteral", "CallExpr", "CaseBranch", "CaseExpr", "CastExpr", "ColumnNameRef", "ColumnRef", "DatabaseRef", "DefaultLiteral", "DistinctFromExpr", "Expr", "ExtractExpr", "HexLiteral", "Identifier", "LQArrayLiteral", "LQBackBackRef", "LQBackRef", "LQBackRefConstructor", "LQDeepDeepRef", "LQDeepRef", "LQObjectLiteral", "LQObjectProperty", "NullLiteral", "NumberLiteral", "PGArrayLiteral", "PGCastExpr2", "PGFilterClause", "PGWithinGroupClause", "ParenShape", "QuantifiedExpr", "RowConstructor", "SetConstructor", "StarRef", "StringLiteral", "SubqueryConstructor", "SystemVar", "TableAbstractionRef", "TableRef", "TypedDateLiteral", "TypedIntervalLiteral", "TypedLiteral", "TypedTimeLiteral", "TypedTimeZoneLiteral", "TypedTimestampLiteral", "UnaryExpr", "UnknownLiteral", "UserVar", "WindowRef", "PGFilterClause", "AbstractNode", "PGWithinGroupClause", "AbstractNode", "CaseExpr", "AbstractNodeList", "CaseBranch", "AbstractNode", "AbstractLiteral", "AbstractNode", "BitLiteral", "AbstractLiteral", "BoolLiteral", "AbstractLiteral", "DefaultLiteral", "AbstractLiteral", "HexLiteral", "AbstractLiteral", "NullLiteral", "AbstractLiteral", "NumberLiteral", "AbstractLiteral", "StringLiteral", "AbstractLiteral", "TypedLiteral", "AbstractNode", "TypedDateLiteral", "TypedLiteral", "TypedIntervalLiteral", "TypedLiteral", "TypedTimeLiteral", "TypedLiteral", "TypedTimestampLiteral", "TypedLiteral", "TypedTimeZoneLiteral", "TypedLiteral", "UnknownLiteral", "AbstractLiteral", "AtTimeZoneExpr", "BinaryExpr", "BetweenExpr", "BinaryExpr", "CastExpr", "AbstractNode", "ExtractExpr", "BinaryExpr", "DistinctFromExpr", "BinaryExpr", "PGCastExpr2", "BinaryExpr", "QuantifiedExpr", "AbstractNode", "UnaryExpr", "AbstractNode", "ColumnNameRef", "Identifier", "filter", "name", "tableSchemaInScope", "columnSchemas", "ErrorRefAmbiguous", "ErrorRefUnknown", "QualifierMixin", "Class", "options", "transformCallback", "resultJson", "qualifier", "init", "name", "instance", "registry", "entriesField", "possibleQualifierSchemas", "possibleQualifierSchema", "refs", "s", "ErrorRefAmbiguous", "ErrorRefUnknown", "filter", "possibleParentSchemas", "schemas", "possibleParentSchema", "matches", "ident", "inputJson", "callback", "isObject_default", "ColumnRef", "QualifierMixin", "Identifier", "DatabaseRef", "Identifier", "filter", "name", "rootSchemaInScope", "databasesSchemas", "AbstractMagicRef", "SugarMixin", "BinaryExpr", "ErrorFKInvalid", "message", "LQDeepRef", "registry", "LQBackBackRef", "_LQBackBackRef", "AbstractMagicRef", "options", "transformCallback", "requestName", "requestSource", "fk", "ErrorFKInvalid", "ColumnRef", "TableRef", "registry", "LQBackRef", "LQBackBackRef", "requestName", "requestSource", "keyLeft_ref", "keyRight_ref", "left", "leftEndpoint", "leftFk", "ErrorFKInvalid", "leftEndpointTable", "querySchema", "$col", "$keyLeft_ref", "targetTable_schema", "LQDeepDeepRef", "_LQDeepDeepRef", "AbstractMagicRef", "requestName", "requestSource", "fk", "ErrorFKInvalid", "LQBackRefConstructor", "ColumnNameRef", "TableRef", "registry", "LQDeepRef", "LQDeepDeepRef", "targetTable_schema", "keyLeft_ref", "keyRight_ref", "StarRef", "AbstractNode", "TableRef", "QualifierMixin", "Identifier", "TableAbstractionRef", "TableRef", "filter", "name", "databaseSchemaInScope", "tableSchemas", "WindowRef", "Identifier", "AbstractLQShapeLiteral", "SugarMixin", "AbstractNodeList", "CallExpr", "registry", "LQArrayLiteral", "AbstractLQShapeLiteral", "options", "transformCallback", "e", "StringLiteral", "CallExpr", "registry", "LQObjectLiteral", "AbstractLQShapeLiteral", "options", "transformCallback", "resultJson", "args", "propertyJson", "AggrCallExpr", "ColumnRef", "registry", "LQObjectProperty", "_LQObjectProperty", "AbstractNode", "options", "transformCallback", "valueJson", "CallExpr", "registry", "PGArrayLiteral", "AbstractNodeList", "options", "transformCallback", "e", "BindVar", "AbstractNode", "SystemVar", "AbstractNode", "UserVar", "AbstractNode", "Expr", "AbstractNode", "ExprNamesInOrder", "instance", "expr_exports", "ExprNames", "k", "a", "b", "comp", "qualif_exports", "__export", "AggrNotation", "LQVersionSpec", "AggrNotation", "AbstractNode", "LQVersionSpec", "AbstractNode", "type_exports", "__export", "DataType", "DataType", "AbstractNode", "registry", "cte_exports", "ddl_exports", "dml_exports", "dql_exports", "expr_exports", "qualif_exports", "type_exports", "Query", "AbstractNodeList", "itemSeparator", "input", "options", "result", "tokenStream", "current", "message"]
}
