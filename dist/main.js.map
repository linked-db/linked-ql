{
  "version": 3,
  "sources": ["../src/lang/cte/index.js", "../node_modules/@webqit/util/js/isObject.js", "../src/lang/util.js", "../src/lang/toktypes.js", "../src/lang/TokenStream.js", "../src/lang/registry.js", "../src/lang/abstracts/AbstractNode.js", "../src/lang/cte/constructs/PGCycleClause.js", "../src/lang/cte/constructs/PGSearchClause.js", "../src/lang/abstracts/DDLSchemaMixin.js", "../src/lang/abstracts/AbstractStmt.js", "../src/lang/abstracts/AbstractNonDDLStmt.js", "../src/lang/Transformer.js", "../src/lang/cte/CTE.js", "../src/lang/cte/CTEItem.js", "../src/lang/expr/ref/Identifier.js", "../src/lang/cte/CTEItemAlias.js", "../src/lang/ddl/index.js", "../src/lang/abstracts/AbstractNodeList.js", "../src/lang/abstracts/AbstractDiff.js", "../src/lang/ddl/column/ColumnDiff.js", "../src/lang/abstracts/AbstractSchema.js", "../src/lang/ddl/column/ColumnSchema.js", "../src/lang/ddl/constraint/constructs/FKMatchRule.js", "../src/lang/ddl/constraint/constructs/FKDeleteRule.js", "../src/lang/ddl/constraint/constructs/FKUpdateRule.js", "../src/lang/ddl/constraint/constructs/PGIndexParameters.js", "../src/lang/ddl/constraint/constructs/PGIndexParamInclude.js", "../src/lang/ddl/constraint/constructs/PGIndexParamUsing.js", "../src/lang/ddl/constraint/constructs/PGIndexParamWith.js", "../src/lang/ddl/constraint/ConstraintSchema.js", "../src/lang/ddl/constraint/constructs/PGTableEXConstraintItem.js", "../src/lang/ddl/constraint/constructs/ReferentialAction.js", "../src/lang/ddl/constraint/CheckConstraint.js", "../src/lang/ddl/constraint/ColumnDefaultConstraint.js", "../src/lang/ddl/constraint/ColumnExpressionConstraint.js", "../src/lang/ddl/constraint/ColumnFKConstraint.js", "../src/lang/ddl/constraint/MYColumnAutoIncrementModifier.js", "../src/lang/ddl/constraint/ColumnIdentityConstraint.js", "../src/lang/ddl/constraint/ColumnNullConstraint.js", "../src/lang/ddl/constraint/ColumnPKConstraint.js", "../src/lang/ddl/constraint/ColumnUKConstraint.js", "../src/lang/ddl/constraint/MYColumnCommentModifier.js", "../src/lang/ddl/constraint/MYColumnOnUpdateModifier.js", "../src/lang/ddl/constraint/MYColumnVisibilityModifier.js", "../src/lang/ddl/constraint/PGTableEXConstraint.js", "../src/lang/ddl/constraint/TableFKConstraint.js", "../src/lang/ddl/constraint/TablePKConstraint.js", "../src/lang/ddl/constraint/TableUKConstraint.js", "../src/lang/abstracts/PathMixin.js", "../src/lang/expr/index.js", "../src/lang/abstracts/TypeSysMixin.js", "../src/lang/expr/AbstractClassicExpr.js", "../src/lang/expr/abstraction/ParenExpr.js", "../src/lang/expr/abstraction/RowConstructor.js", "../src/lang/dql/TA/DerivedQuery.js", "../src/lang/expr/abstraction/ScalarSubquery.js", "../src/lang/expr/abstraction/TypedRowConstructor.js", "../src/lang/expr/call/constructs/PGFilterClause.js", "../src/lang/expr/call/constructs/PGWithinGroupClause.js", "../src/lang/expr/call/CallExpr.js", "../src/lang/expr/call/AggrCallExpr.js", "../src/lang/expr/case/CaseExpr.js", "../src/lang/expr/case/CaseBranch.js", "../src/lang/expr/etc/CastExpr.js", "../src/lang/expr/op/BinaryExpr.js", "../src/lang/expr/etc/ExtractExpr.js", "../src/lang/expr/etc/PredicateExpr.js", "../src/lang/expr/etc/QuantitativeExpr.js", "../src/lang/expr/literals/AbstractLiteral.js", "../src/lang/expr/literals/BitLiteral.js", "../src/lang/expr/literals/BoolLiteral.js", "../src/lang/expr/literals/DefaultLiteral.js", "../src/lang/expr/literals/HexLiteral.js", "../src/lang/expr/literals/NullLiteral.js", "../src/lang/expr/literals/NumberLiteral.js", "../src/lang/expr/literals/StringLiteral.js", "../src/lang/expr/literals/TypedLiteral.js", "../src/lang/expr/literals/TypedDateLiteral.js", "../src/lang/expr/literals/TypedIntervalLiteral.js", "../src/lang/expr/literals/TypedTimeLiteral.js", "../src/lang/expr/literals/TypedTimestampLiteral.js", "../src/lang/expr/literals/TypedTimeZoneLiteral.js", "../src/lang/expr/literals/UnknownLiteral.js", "../src/lang/abstracts/SugarMixin.js", "../src/lang/expr/literals/AbstractLQJsonLiteral.js", "../src/lang/expr/literals/LQArrayLiteral.js", "../src/lang/expr/literals/LQObjectLiteral.js", "../src/lang/expr/literals/LQObjectProperty.js", "../src/lang/expr/literals/PGTypedArrayLiteral.js", "../src/lang/expr/op/AtTimeZoneExpr.js", "../src/lang/expr/op/BetweenExpr.js", "../src/lang/expr/op/DistinctFromExpr.js", "../src/lang/expr/op/InExpr.js", "../src/lang/expr/op/PGCastExpr2.js", "../src/lang/expr/op/UnaryExpr.js", "../src/lang/expr/ref/abstracts/ErrorRefUnknown.js", "../src/lang/expr/ref/abstracts/ErrorRefAmbiguous.js", "../src/lang/expr/ref/abstracts/AbstractClassicRef.js", "../src/lang/expr/ref/ColumnRef1.js", "../src/lang/expr/ref/ColumnRef0.js", "../src/lang/expr/ref/abstracts/ErrorFKInvalid.js", "../src/lang/expr/ref/abstracts/AbstractMagicRef.js", "../src/lang/expr/ref/ColumnRef2.js", "../src/lang/expr/ref/LQBackBackRef.js", "../src/lang/expr/ref/LQBackRef.js", "../src/lang/expr/ref/LQBackRefAbstraction.js", "../src/lang/expr/ref/LQBackRefEndpoint.js", "../src/lang/expr/ref/LQDeepDeepRef1.js", "../src/lang/expr/ref/LQDeepDeepRef2.js", "../src/lang/expr/ref/LQDeepRef1.js", "../src/lang/expr/ref/LQDeepRef2.js", "../src/lang/expr/ref/SchemaRef.js", "../src/lang/expr/ref/TableRef1.js", "../src/lang/expr/ref/TableRef0.js", "../src/lang/expr/ref/TableRef2.js", "../src/lang/expr/ref/WindowRef.js", "../src/lang/expr/var/BindVar.js", "../src/lang/expr/var/SystemVar.js", "../src/lang/expr/var/UserVar.js", "../src/lang/expr/Expr.js", "../src/lang/ddl/ident/ColumnIdent.js", "../src/lang/ddl/ident/SchemaIdent.js", "../src/lang/ddl/ident/TableIdent.js", "../src/lang/ddl/index/IndexDiff.js", "../src/lang/ddl/index/IndexSchema.js", "../src/lang/ddl/schema/SchemaDiff.js", "../src/lang/ddl/schema/SchemaSchema.js", "../src/lang/ddl/table/TableDiff.js", "../src/lang/ddl/table/TableSchema.js", "../src/lang/ddl/DDLStmt.js", "../src/lang/ddl/CreateTableStmt.js", "../src/lang/dml/index.js", "../src/lang/dml/clauses/MYOnDuplicateKeyUpdateClause.js", "../src/lang/dml/clauses/MYPartitionClause.js", "../src/lang/dml/clauses/PGConflictTarget.js", "../src/lang/dml/clauses/PGConflictTargetIndexSpec.js", "../src/lang/dml/clauses/PGDefaultValuesClause.js", "../src/lang/dml/clauses/PGOnConflictClause.js", "../src/lang/dql/clauses/SelectList.js", "../src/lang/dml/clauses/ReturningClause.js", "../src/lang/dml/clauses/PGWhereCurrentClause.js", "../src/lang/dml/clauses/SetClause.js", "../src/lang/dml/clauses/UsingFromClause.js", "../src/lang/dml/constructors/ColumnsConstructor.js", "../src/lang/dml/constructors/ValuesConstructor.js", "../src/lang/dml/expr/AssignmentExpr.js", "../src/lang/dml/expr/ConfigAssignmentExpr.js", "../src/lang/dml/expr/ConfigAssignmentExprAlt1.js", "../src/lang/dml/expr/ConfigAssignmentExprAlt2.js", "../src/lang/dml/expr/MYVarAssignmentExpr.js", "../src/lang/dml/TA/TableAbstraction2.js", "../src/lang/dml/TA/TableAbstraction1.js", "../src/lang/abstracts/SelectorStmtMixin.js", "../src/lang/dml/DMLStmt.js", "../src/lang/dml/DeleteStmt.js", "../src/lang/abstracts/PayloadStmtMixin.js", "../src/lang/dml/InsertStmt.js", "../src/lang/dml/MYSetStmt.js", "../src/lang/dml/UpdateStmt.js", "../src/lang/dml/UpsertStmt.js", "../src/lang/dql/index.js", "../src/lang/dql/clauses/DistinctClause.js", "../src/lang/dql/clauses/ForClause.js", "../src/lang/dql/clauses/FromClause.js", "../src/lang/dql/clauses/GroupByClause.js", "../src/lang/dql/clauses/GroupingElement.js", "../src/lang/dql/clauses/HavingClause.js", "../src/lang/dql/TA/FromItem.js", "../src/lang/dql/clauses/JoinClause.js", "../src/lang/dql/clauses/LimitClause.js", "../src/lang/dql/clauses/OffsetClause.js", "../src/lang/dql/clauses/OnClause.js", "../src/lang/dql/clauses/OrderByClause.js", "../src/lang/dql/clauses/OrderElement.js", "../src/lang/dql/clauses/PartitionByClause.js", "../src/lang/dql/clauses/PGFetchClause.js", "../src/lang/dql/clauses/PGOrderOperator.js", "../src/lang/dql/clauses/UsingClause.js", "../src/lang/dql/clauses/WhereClause.js", "../src/lang/dql/clauses/WindowClause.js", "../src/lang/dql/clauses/WindowDeclaration.js", "../src/lang/dql/clauses/WindowFrameSpec.js", "../src/lang/dql/clauses/WindowFrameBound.js", "../src/lang/dql/clauses/WindowSpec.js", "../src/lang/dql/TA/FromItemAlias.js", "../src/lang/dql/TA/SelectItem.js", "../src/lang/dql/TA/SelectItemAlias.js", "../src/lang/dql/TA/SRFExpr1.js", "../src/lang/dql/TA/SRFExpr2.js", "../src/lang/dql/TA/SRFExpr3.js", "../src/lang/dql/TA/SRFExpr4.js", "../src/lang/dql/TA/SRFExprDDL1.js", "../src/lang/dql/TA/SRFExprDDL2.js", "../src/lang/dql/TA/ValuesTableLiteral.js", "../src/lang/dql/SelectStmt.js", "../src/lang/dql/BasicSelectStmt.js", "../src/lang/dql/CompleteSelectStmt.js", "../src/lang/dql/CompositeSelectStmt.js", "../src/lang/dql/TableStmt.js", "../src/lang/qualif/index.js", "../src/lang/qualif/AggrNotation.js", "../src/lang/qualif/LQVersionSpec.js", "../src/lang/type/index.js", "../src/lang/type/DataType.js", "../src/lang/abstracts/JSONSchema.js", "../src/lang/index.js", "../src/lang/Query.js"],
  "sourcesContent": ["export * from './constructs/index.js';\nexport { CTE } from './CTE.js';\nexport { CTEItem } from './CTEItem.js';\nexport { CTEItemAlias } from './CTEItemAlias.js';\n", "\n/**\n * Tells if val is pure object.\n *\n * @param object\t \tval\n *\n * @return bool\n */\nexport default function(val) {\n\treturn !Array.isArray(val) && typeof val === 'object' && val;\n};\n", "import { _isObject } from '@webqit/util/js/index.js';\n\nexport function _eq(a, b, cs = false, ignoreList = null) {\n    if (Array.isArray(a) && Array.isArray(b)) {\n        return a.length === b.length && (b = b.slice(0).sort())\n            && a.slice(0).sort().every((x, i) => _eq(x, b[i], cs, ignoreList));\n    }\n    if (typeof a?.jsonfy === 'function') a = a.jsonfy();\n    if (typeof b?.jsonfy === 'function') b = b.jsonfy();\n    if (_isObject(a) && _isObject(b)) {\n        const temp = {\n            indexs_a: Object.keys(a),\n            indexs_b: Object.keys(b),\n        };\n        if (ignoreList?.length) {\n            const $ignoreList = [].concat(ignoreList);\n            temp.indexs_a = temp.indexs_a.filter((k) => !$ignoreList.includes(k));\n            temp.indexs_b = temp.indexs_b.filter((k) => !$ignoreList.includes(k));\n        }\n        return temp.indexs_a.length === temp.indexs_b.length\n            && temp.indexs_a.reduce((prev, k) => prev && _eq(a[k], b[k], cs, ignoreList), true);\n    }\n    if (typeof a === 'string' && typeof b === 'string' && cs === false) {\n        return a.toLowerCase() === b.toLowerCase();\n    }\n    return a === b;\n}\n\nexport function _toCapsSnake(str) {\n    // Handle cases like \"myVariableName\" -> \"my_Variable_Name\"\n    // This regex looks for a lowercase letter or digit followed by an uppercase letter.\n    // It inserts an underscore between them.\n    let result = str.replace(/([a-z0-9])([A-Z])/g, '$1_$2');\n\n    // Handle cases like \"HTMLParser\" -> \"HTML_Parser\" or \"APICall\" -> \"API_Call\"\n    // This regex looks for an uppercase letter followed by another uppercase letter\n    // which is then followed by a lowercase letter. This targets the transition\n    // from an acronym to a new word.\n    // Example: In \"HTMLParser\", it matches 'L' and then 'P' (uppercase) followed by 'a' (lowercase).\n    // It inserts an underscore between the first uppercase letter and the second.\n    result = result.replace(/([A-Z])([A-Z][a-z])/g, '$1_$2');\n\n    // Convert the entire string to uppercase.\n    return result.toUpperCase();\n}", "/**\n * Token types:\n * Noted that some delims and modifiers are dialect-dependent, and those are correctly handle by the tokenizer.\n  * Note too that emitted tokens may have a \"spaceBefore\" field when options.spaces === true.\n  * Lastly, \"line\" and \"column\" fields are guaranteed to be emitted by the tokenizer.\n */\nexport const TOK_TYPES = {\n  // Data type names\n  // e.g. VARCHAR, INT, \"custom_type\"\n  data_type: {\n    type: 'data_type',\n    value: undefined,\n    resolve() { return this; }\n  },\n  // Identifiers, optionally delimited\n  // e.g. user_id, \"UserName\", `table$1`\n  identifier: {\n    type: 'identifier',\n    value: undefined,\n    delim: [undefined],\n    resolve({ dialect, mysqlAnsiQuotes } = {}) {\n      return {\n        ...this,\n        delim: this.delim.concat(\n          dialect === 'mysql' ? (mysqlAnsiQuotes ? ['\"', '`'] : ['`']) : ['\"']\n        ),\n      };\n    }\n  },\n  // Any of the predefined keywords\n  // e.g. 'SELECT', 'FROM', 'WHERE'\n  keyword: {\n    type: 'keyword',\n    value: undefined,\n    resolve() { return this; }\n  },\n  // Operators, with precedence and associativity\n  // e.g. '+', '-', '||', 'AND', '::'\n  operator: {\n    type: 'operator',\n    value: undefined,\n    prec: undefined, // number\n    assoc: undefined, // string\n    resultType: undefined, // string\n    resolve() { return this; }\n  },\n  // Punctuation (., ,, :, ;, etc.)\n  // e.g. '.', ',', ':', ';', '(', ')'\n  punctuation: {\n    type: 'punctuation',\n    value: undefined,\n    resolve() { return this; }\n  },\n  // String literals, with required delim and optional modifier (e.g. E for Postgres, N for mysql)\n  // e.g. 'Hello', \"World\", $$foo$$, $tag$bar$tag$\n  string_literal: {\n    type: 'string_literal',\n    value: undefined,\n    delim: [\"'\"],\n    modifier: [undefined],\n    resolve({ dialect, mysqlAnsiQuotes } = {}) {\n      return {\n        ...this,\n        delim: this.delim.concat(\n          dialect === 'mysql' ? (!mysqlAnsiQuotes ? ['\"'] : []) : [/^(\\$\\$|\\$[a-zA-Z_][a-zA-Z0-9_]*\\$)$/]\n        ),\n        modifier: this.modifier.concat(\n          dialect === 'mysql' ? ['N'] : ['E']\n        ),\n      };\n    }\n  },\n  // Numbers (integer, float, exponential, etc.)\n  // e.g. 42, -3.14, 2e10, .004\n  number_literal: {\n    type: 'number_literal',\n    value: undefined,\n    match({ value }) {\n      // Match type \"number_literal\": 42, 3.14, .5, 5., 1e9, -2.7E-3, +0.001e+2\n      if (!/^[+-]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:[eE][+-]?\\d+)?$/.test(value)) return false;\n      return true;\n    }\n  },\n  // NULL Literal: NULL\n  null_literal: {\n    type: 'null_literal',\n    value: undefined,\n    resolve() { return this; }\n  },\n  // UNKNOWN Literal: NULL\n  unknown_literal: {\n    type: 'unknown_literal',\n    value: undefined,\n    resolve() { return this; }\n  },\n  // Bool Literals: TRUE | FALSE\n  bool_literal: {\n    type: 'bool_literal',\n    value: undefined,\n    resolve() { return this; }\n  },\n  // HEX Literals: 0xFF | X'FF'\n  hex_literal: {\n    type: 'hex_literal',\n    value: undefined,\n    resolve() { return this; }\n  },\n  // BIT Literals: 0b0101 | B'0101'\n  bit_literal: {\n    type: 'bit_literal',\n    value: undefined,\n    resolve() { return this; }\n  },\n  // Bindings (e.g. $1, ?, etc.), with required delim\n  // e.g. $1, $user, ?\n  bind_var: {\n    type: 'bind_var',\n    value: undefined,\n    delim: [],\n    resolve({ dialect } = {}) {\n      return {\n        ...this,\n        delim: this.delim.concat(dialect === 'mysql' ? ['?'] : ['$'])\n      };\n    }\n  },\n  // Version tags\n  // e.g. my_db@1_3, my_db@^2_1, my_db@~7_6, my_db @=3_4, my_db@<3, my_db@>4, my_db@<=3, my_db@>=4\n  version_spec: {\n    type: 'version_spec',\n    value: undefined,\n    delim: [undefined, \"'\"],\n    resolve() { return this; }\n  },\n  // User variables, with optional delim\n  // e.g. :foo, @bar, @'user var'\n  user_var: {\n    type: 'user_var',\n    value: undefined,\n    delim: [undefined],\n    resolve({ dialect } = {}) {\n      return {\n        ...this,\n        delim: this.delim.concat(dialect === 'mysql' ? [\"'\"] : [])\n      };\n    }\n  },\n  // MySQL system variables, with required notation\n  // e.g. @@baz\n  system_var: {\n    type: 'system_var',\n    value: undefined,\n    resolve() { return this; }\n  },\n  // Nest token type: \"brace\"\n  brace_block: {\n    type: 'brace_block',\n    value: undefined, // TokenStream\n    resolve() { return this; }\n  },\n  // Nest token type: \"bracket\"\n  bracket_block: {\n    type: 'bracket_block',\n    value: undefined, // TokenStream\n    resolve() { return this; }\n  },\n  // Nest token type: \"paren\"\n  parent_block: {\n    type: 'paren_block',\n    value: undefined, // TokenStream\n    resolve() { return this; }\n  },\n  // Block comments\n  // e.g. /* This is a comment */\n  block_comment: {\n    type: 'block_comment',\n    value: undefined,\n    resolve() { return this; }\n  },\n  // Line comments, with required delim (e.g. /*, --, #)\n  // e.g. -- This is a comment\n  line_comment: {\n    type: 'line_comment',\n    value: undefined,\n    delim: ['--'],\n    resolve({ dialect } = {}) {\n      return {\n        ...this,\n        delim: this.delim.concat(dialect === 'mysql' ? ['#'] : [])\n      };\n    }\n  },\n};\n\n// Lookup registries, organized by: statements, clauses, operators, keywords, dataTypes\n// Each registry is split into: common (standard/shared), postgres, mysql\n\nexport const statements = {\n  common: [\n    // DDL\n    'ALTER',\n    'CREATE',\n    'DROP',\n    // DML\n    'SELECT',\n    'INSERT',\n    'UPSERT',\n    'UPDATE',\n    'MERGE',\n    'DELETE',\n    // Transactions\n    'BEGIN',\n    'COMMIT',\n    'ROLLBACK',\n    'RELEASE',\n    // Utility\n    'DESCRIBE',\n    'EXPLAIN',\n    'USE'\n  ],\n  postgres: [\n    'ANALYZE',\n    'CLUSTER',\n    'COMMENT ON',\n    'REFRESH',\n    'REINDEX',\n    'VACUUM'\n  ],\n  mysql: [\n    'ANALYZE',\n    'FLUSH',\n    'LOCK',\n    'OPTIMIZE',\n    'RENAME',\n    'REPAIR',\n    'RESET',\n    'SET',\n    'SHOW',\n    'TRUNCATE',\n    'UNLOCK'\n  ]\n};\n\nexport const keywords = {\n  common: [\n    'ALL', 'ON', 'NO', 'KEY', 'ANY', 'AS', 'BY', 'ASC', 'CASE', 'CAST',\n    'DEFAULT', 'DESC', 'DO', 'DISTINCT', 'ELSE', 'END', 'ESCAPE', 'EXISTS',\n    'FIRST', 'LAST', 'FOLLOWING', 'FOR', 'HAVING', 'FILTER', 'SHARE', 'UNIQUE',\n    'JOIN', 'SEPARATOR', 'SKIP', 'LOCKED', 'NOWAIT', 'OF', 'RECURSIVE',\n    'LIMIT', 'LOAD', 'NEXT', 'NOTHING', 'NULLS', 'OFFSET', 'ONLY', 'TIES',\n    'OVER', 'PARTITION', 'PRECEDING', 'RANGE', 'RETURNING', 'ROW', 'ROWS', 'INCLUDE', 'EXCLUDE',\n    'SET', 'SOME', 'THEN', 'USING', 'MATERIALIZED', 'MODE', 'TEMPORARY', 'MATCH', 'PARTIAL', 'SIMPLE',\n    'WITHIN', 'BOTH', 'CHECK', 'PRIMARY', 'FOREIGN', 'CONSTRAINT', 'REFERENCES', 'INHERITS',\n    'DATABASE', 'TABLE', 'COLUMN', 'INDEX', 'SEQUENCE', 'TRIGGER', 'VIEW', 'SAVEPOINT',\n    'VALUES', 'WHEN', 'WHERE', 'WINDOW', 'WITH', 'WITHOUT', 'TO', 'TABLESPACE', 'INTO',\n    'FROM', 'GROUP', 'ORDER', 'PARTITION', 'BREADTH', 'DEPTH', 'GENERATED', 'ALWAYS',\n    'INNER', 'LEFT', 'RIGHT', 'OUTER', 'FULL', 'CROSS', 'NATURAL', 'NO OTHERS', 'NO INHERIT',\n    'ROLLUP', 'UNBOUNDED', 'CURRENT ROW', 'GROUPS', 'IGNORE', 'RESPECT', 'CHARACTER SET',\n    'NO ACTION', 'SET NULL', 'SET DEFAULT', 'RESTRICT', 'CASCADE', 'STORED', 'GIST'\n  ],\n  postgres: [\n    'ARRAY', 'GROUPING SETS', 'CUBE', 'TABLESAMPLE', 'REPEATABLE', 'SEARCH',\n    'LATERAL', 'ORDINALITY', 'OVERLAPS', 'SIMILAR', 'BERNOULLI', 'SYSTEM',\n    'UNLOGGED', 'PERFORM', 'CURRENT OF', 'TYPE', 'EXTENSION',\n    'IMMUTABLE', 'STABLE', 'VOLATILE', 'CYCLE', 'CONFLICT', 'TEMP',\n    'TIME ZONE', 'FETCH', 'LOCAL', 'IDENTITY', 'DEFERRABLE', 'INITIALLY', 'DEFERRED', 'IMMEDIATE'\n  ],\n  mysql: [\n    'LOCK', 'RENAME', 'REPLACE', 'SHOW', 'UNLOCK', 'VIRTUAL', 'VISIBLE', 'INVISIBLE',\n    'HIGH_PRIORITY', 'CACHE', 'SQL_CACHE', 'SQL_NO_CACHE', 'STRAIGHT_JOIN', 'COMMENT',\n    'DATABASES', 'TABLES', 'COLUMNS', 'PROCEDURE', 'FUNCTION',\n    'AUTO_INCREMENT', 'CHARACTER SET', 'ENGINE', 'VALUE', 'DUPLICATE',\n  ]\n};\n\nexport const functionNames = {\n  common: [\n    'NOW', 'CURRENT_DATE', 'CURRENT_TIME', 'CURRENT_TIMESTAMP',\n    'IF', 'NULLIF', 'IFNULL',\n    'COALESCE', 'GREATEST', 'LEAST', 'CONCAT', 'GROUPING',\n    'CONCAT_WS', 'FORMAT', 'UNNEST',\n    'MD5', 'SHA1',\n    'ST_ASTEXT', 'ST_ASGEOJSON', 'ST_GEOMFROMTEXT',\n    'ST_WITHIN', 'ST_CONTAINS', 'ST_INTERSECTS', 'ST_DISTANCE', 'ST_BUFFER'\n  ],\n  postgres: [\n    'MAKE_DATE', 'MAKE_TIME', 'MAKE_TIMESTAMP',\n    'TO_JSON', 'TO_JSONB', 'JSON_TYPEOF', 'JSONB_TYPEOF',\n    'JSON_BUILD_ARRAY', 'JSONB_BUILD_ARRAY', 'JSON_BUILD_OBJECT', 'JSONB_BUILD_OBJECT',\n    'JSON_POPULATE_RECORD', 'JSONB_POPULATE_RECORD', 'JSON_PATH_QUERY', 'JSON_PATH_EXISTS'\n  ],\n  mysql: [\n    'CURDATE', 'CURTIME', 'SYSDATE', 'STR_TO_DATE', 'MAKEDATE', 'MAKETIME',\n    'JSON_ARRAY', 'JSON_OBJECT', 'JSON_EXTRACT', 'JSON_UNQUOTE',\n    'JSON_SET', 'JSON_INSERT', 'JSON_REPLACE', 'JSON_REMOVE',\n    'JSON_SEARCH', 'JSON_CONTAINS', 'JSON_CONTAINS_PATH',\n    'JSON_KEYS', 'JSON_ARRAY_APPEND', 'JSON_ARRAY_INSERT',\n    'JSON_DEPTH', 'JSON_LENGTH', 'JSON_MERGE_PRESERVE',\n    'JSON_MERGE_PATCH', 'JSON_PRETTY', 'JSON_STORAGE_FREE'\n  ]\n};\n\nexport const aggrFunctionNames = {\n  common: [\n    'COUNT', 'SUM', 'AVG', 'MIN', 'MAX',\n    'COVAR_POP', 'COVAR_SAMP', 'CORR',\n    'ROW_NUMBER',\n    'BIT_AND', 'BIT_OR',\n    'STDDEV_POP', 'STDDEV_SAMP', 'VAR_POP', 'VAR_SAMP', 'VARIANCE', 'STD',\n    'LEAD', 'LAG', 'NTILE', 'FIRST_VALUE', 'LAST_VALUE',\n  ],\n  postgres: [\n    'ARRAY_AGG', 'STRING_AGG', 'REGR_SLOPE',\n    'PERCENTILE_CONT', 'PERCENTILE_DISC', 'MODE',\n    'RANK', 'DENSE_RANK',\n    'EVERY', 'BOOL_AND', 'BOOL_OR',\n    'JSON_AGG',\n    'JSON_OBJECT_AGG', 'JSONB_OBJECT_AGG',\n    'XMLAGG',\n  ],\n  mysql: [\n    'GROUP_CONCAT',\n    'BIT_XOR',\n    'JSON_ARRAYAGG',\n    'JSON_OBJECTAGG',\n  ]\n};\n\nexport const dataTypes = {\n  common: [\n    'SMALLINT', 'INTEGER', 'INT', 'BIGINT',\n    'DECIMAL', 'DEC', 'NUMERIC', 'REAL', 'FLOAT',\n    'DATE', 'TIME', 'TIMESTAMP', 'INTERVAL',\n    'CHAR', 'CHARACTER', 'VARCHAR', 'TEXT',\n    'BINARY', 'VARBINARY', 'BOOLEAN', 'JSON',\n    'GEOMETRY', 'POINT', 'LINESTRING', 'POLYGON',\n    'DOUBLE PRECISION', 'CHARACTER VARYING', 'BYTEA',\n    'ENUM',\n  ],\n  postgres: [\n    'SERIAL', 'BIGSERIAL', 'MONEY', 'BIT',\n    'CIDR', 'INET', 'MACADDR', 'MACADDR8', 'TIMESTAMPTZ', 'TIMETZ',\n    'TSVECTOR', 'TSQUERY', 'UUID', 'XML',\n    'INT4RANGE', 'INT8RANGE', 'NUMRANGE',\n    'TSRANGE', 'TSTZRANGE', 'DATERANGE',\n    'BOX', 'PATH', 'CIRCLE', 'LINE', 'LSEG', 'POLYGON',\n    'OID', 'BIT VARYING', 'JSONB'/*, TODO'NAME'*/, 'REGCLASS',\n  ],\n  mysql: [\n    'TINYINT', 'MEDIUMINT', 'BIT', 'YEAR', 'DATETIME',\n    'TINYTEXT', 'QUERY', 'MEDIUMTEXT', 'LONGTEXT',\n    'TINYBLOB', 'BLOB', 'MEDIUMBLOB', 'LONGBLOB',\n    'GEOMETRYCOLLECTION', 'MULTIPOINT', 'MULTILINESTRING', 'MULTIPOLYGON',\n    'BOOL'\n  ]\n};\n\nexport const operators = {\n  common: [\n    // Custom/graph-style\n    ['<~', { prec: 90, assoc: 'left', resultType: ':right' }],\n    ['~>', { prec: 90, assoc: 'right', resultType: ':right' }],\n    ['BETWEEN', { prec: 85, assoc: 'left', resultType: 'boolean' }],\n    ['NOT', { prec: 80, assoc: 'right', resultType: 'boolean' }],\n    // Arithmetic\n    ['*', { prec: 70, assoc: 'left', resultType: 'number' }],\n    ['/', { prec: 70, assoc: 'left', resultType: 'number' }],\n    ['%', { prec: 70, assoc: 'left', resultType: 'number' }],\n    ['+', { prec: 60, assoc: 'left', resultType: 'number' }],\n    ['-', { prec: 60, assoc: 'left', resultType: 'number' }],\n    // Bitwise\n    ['&', { prec: 60, assoc: 'left', resultType: 'number' }],\n    ['|', { prec: 60, assoc: 'left', resultType: 'number' }],\n    ['<<', { prec: 60, assoc: 'left', resultType: 'number' }],\n    ['>>', { prec: 60, assoc: 'left', resultType: 'number' }],\n    // Comparison\n    ['=', { prec: 50, assoc: 'left', resultType: 'boolean' }],\n    ['!=', { prec: 50, assoc: 'left', resultType: 'boolean' }],\n    ['<>', { prec: 50, assoc: 'left', resultType: 'boolean' }],\n    ['<', { prec: 50, assoc: 'left', resultType: 'boolean' }],\n    ['<=', { prec: 50, assoc: 'left', resultType: 'boolean' }],\n    ['>', { prec: 50, assoc: 'left', resultType: 'boolean' }],\n    ['>=', { prec: 50, assoc: 'left', resultType: 'boolean' }],\n    ['IS', { prec: 50, assoc: 'left', resultType: 'boolean' }],\n    ['IS NOT', { prec: 50, assoc: 'left', resultType: 'boolean' }],\n    ['DISTINCT FROM', { prec: 50, assoc: 'left', resultType: 'boolean' }],\n    // Pattern / membership\n    ['IN', { prec: 50, assoc: 'left', resultType: 'boolean' }],\n    ['LIKE', { prec: 50, assoc: 'left', resultType: 'boolean' }],\n    // Logical\n    ['AND', { prec: 40, assoc: 'left', resultType: 'boolean' }],\n    ['OR', { prec: 30, assoc: 'left', resultType: 'boolean' }],\n    // Set operators\n    ['INTERSECT', { prec: 20, assoc: 'left', resultType: 'set' }],\n    ['UNION', { prec: 10, assoc: 'left', resultType: 'set' }],\n    ['EXCEPT', { prec: 10, assoc: 'left', resultType: 'set' }]\n  ],\n  postgres: [\n    ['COLLATE', { prec: 83, assoc: 'left', resultType: 'string' }],\n    ['||', { prec: 60, assoc: 'left', resultType: 'string' }],\n    ['::', { prec: 100, assoc: 'left', resultType: 'casted' }],\n    ['AT', { prec: 95, assoc: 'left', resultType: 'timestamptz' }],\n    ['^', { prec: 90, assoc: 'left', resultType: 'number' }],\n    ['#', { prec: 60, assoc: 'left', resultType: 'number' }],\n    // JSON/JSONB\n    ['->', { prec: 80, assoc: 'left', resultType: 'json' }],\n    ['->>', { prec: 80, assoc: 'left', resultType: 'text' }],\n    ['#>', { prec: 80, assoc: 'left', resultType: 'json' }],\n    ['#>>', { prec: 80, assoc: 'left', resultType: 'text' }],\n    ['@>', { prec: 80, assoc: 'left', resultType: 'boolean' }],\n    ['<@', { prec: 80, assoc: 'left', resultType: 'boolean' }],\n    ['?', { prec: 80, assoc: 'left', resultType: 'boolean' }],\n    ['?|', { prec: 80, assoc: 'left', resultType: 'boolean' }],\n    ['?&', { prec: 80, assoc: 'left', resultType: 'boolean' }],\n    ['-@', { prec: 80, assoc: 'left', resultType: 'boolean' }],\n    ['#-', { prec: 80, assoc: 'left', resultType: 'json' }],\n    ['@?', { prec: 80, assoc: 'left', resultType: 'boolean' }],\n    ['@@', { prec: 80, assoc: 'left', resultType: 'boolean' }],\n    ['ILIKE', { prec: 50, assoc: 'left', resultType: 'boolean' }],\n    ['~', { prec: 50, assoc: 'left', resultType: 'boolean' }],\n    ['!~', { prec: 50, assoc: 'left', resultType: 'boolean' }],\n    ['~*', { prec: 50, assoc: 'left', resultType: 'boolean' }],\n    ['!~*', { prec: 50, assoc: 'left', resultType: 'boolean' }],\n    ['SIMILAR TO', { prec: 50, assoc: 'left', resultType: 'boolean' }],\n    // GIS/PostGIS\n    ['&&', { prec: 60, assoc: 'left', resultType: 'boolean' }],\n    ['<->', { prec: 60, assoc: 'left', resultType: 'number' }],\n    ['@', { prec: 60, assoc: 'left', resultType: 'geometry' }],\n    ['&<', { prec: 60, assoc: 'left', resultType: 'boolean' }],\n    ['&>', { prec: 60, assoc: 'left', resultType: 'boolean' }],\n    ['|-', { prec: 60, assoc: 'left', resultType: 'boolean' }],\n    ['-|', { prec: 60, assoc: 'left', resultType: 'boolean' }],\n    ['<<', { prec: 60, assoc: 'left', resultType: 'boolean' }],\n    ['>>', { prec: 60, assoc: 'left', resultType: 'boolean' }],\n    ['<<|', { prec: 60, assoc: 'left', resultType: 'boolean' }],\n    ['|>>', { prec: 60, assoc: 'left', resultType: 'boolean' }],\n    ['&<|', { prec: 60, assoc: 'left', resultType: 'boolean' }],\n    ['|&>', { prec: 60, assoc: 'left', resultType: 'boolean' }],\n    ['~=', { prec: 50, assoc: 'left', resultType: 'boolean' }],\n    ['?#', { prec: 60, assoc: 'left', resultType: 'boolean' }],\n    ['?-', { prec: 60, assoc: 'left', resultType: 'boolean' }],\n    ['?-|', { prec: 60, assoc: 'left', resultType: 'boolean' }],\n    ['?|', { prec: 60, assoc: 'left', resultType: 'boolean' }],\n    ['?||', { prec: 60, assoc: 'left', resultType: 'boolean' }],\n    ['#', { prec: 60, assoc: 'left', resultType: 'number' }],\n    ['##', { prec: 60, assoc: 'left', resultType: 'geometry' }],\n    ['@-@', { prec: 60, assoc: 'left', resultType: 'number' }]\n  ],\n  mysql: [\n    ['DIV', { prec: 70, assoc: 'left', resultType: 'number' }],\n    ['MOD', { prec: 70, assoc: 'left', resultType: 'number' }],\n    ['BINARY', { prec: 90, assoc: 'right', resultType: 'binary' }],\n    ['^', { prec: 80, assoc: 'left', resultType: 'number' }],\n    ['~', { prec: 85, assoc: 'right', resultType: 'number' }],\n    ['<=>', { prec: 50, assoc: 'left', resultType: 'boolean' }],\n    ['REGEXP', { prec: 50, assoc: 'left', resultType: 'boolean' }],\n    ['RLIKE', { prec: 50, assoc: 'left', resultType: 'boolean' }],\n    ['!', { prec: 80, assoc: 'right', resultType: 'boolean' }],\n    ['XOR', { prec: 40, assoc: 'left', resultType: 'boolean' }],\n    ['&&', { prec: 40, assoc: 'left', resultType: 'boolean' }],\n    ['||', { prec: 30, assoc: 'left', resultType: 'boolean' }],\n    [':=', { prec: 10, assoc: 'right', resultType: ':right' }],\n    ['SOUNDS LIKE', { prec: 50, assoc: 'left', resultType: 'boolean' }]\n  ]\n};\n", "import * as toktypes from './toktypes.js';\n\nclass TokenStreamState {\n    buffer = '';\n    cursor = 0;\n    line = 1;\n    column = 1;\n    mysqlBindingIndex = 0;\n    nestingContext = [];\n    nextTokenEscape = 0;\n    next(by = 1, isLf = false) {\n        if (isLf) {\n            this.line++;\n            this.column = 0; // To immediately become 1 below\n        }\n        this.column += by;\n        this.cursor += by;\n        if (this.nextTokenEscape === 1) {\n            this.nextTokenEscape = 2;\n        } else if (this.nextTokenEscape === 2) {\n            this.nextTokenEscape = 0;\n        }\n    }\n}\n\nexport class TokenStream {\n\n    #iterator;\n    #options;\n    #locked = false;\n    #started = false;\n    #done = false;\n\n    #rootSavepoint = null;\n    #history = [];\n    #current;\n    #peeks = [];\n\n    constructor(iterator, { state: _, ...options } = {}) {\n        this.#iterator = iterator;\n        this.#options = options;\n    }\n\n    [Symbol.asyncIterator]() {\n        return this; // Make it an async iterator\n    }\n\n    get options() { return this.#options; }\n\n    get locked() { return this.#locked; }\n\n    get started() { return this.#started; }\n\n    get done() { return this.#done && !this.#peeks.length; }\n\n    previous() {\n        return this.#history[this.#history.length - 1];\n    }\n\n    current() {\n        return this.#current;\n    }\n\n    async next() {\n        this.#assertNotLocked('next()');\n        this.#started = true;\n        let value, done = false;\n        if (this.#peeks.length) {\n            this.#historyPush(this.#current);\n            this.#current = this.#peeksShift();\n            value = this.#current;\n        } else {\n            ({ value, done } = await this.#iterator.next());\n            this.#historyPush(this.#current);\n            this.#current = value;\n            this.#done = done;\n        }\n        if (this.#rootSavepoint !== null && value?.type.endsWith('_block')) {\n            value.value.savepoint();\n        }\n        return { value, done };\n    }\n\n    async match($type, $value = undefined) {\n        const [peek, type, value] = typeof arguments[0] === 'number'\n            ? arguments\n            : [0, $type, $value];\n        const match = (tok) => {\n            return tok && (\n                (Array.isArray(type) ? type.includes(tok.type) : type === tok.type) && (\n                    value === undefined || (Array.isArray(value) ? (value.includes(tok.value) || value.includes(undefined)) : value === tok.value)\n                )\n            ) && tok || undefined;\n        };\n        if (peek === Infinity) {\n            // Match progressively\n            let i = 0, tok;\n            while (tok = await this.peek(i++)) {\n                if (match(tok)) return tok;\n            }\n            return;\n        }\n        return match(\n            peek ? await this.peek(peek) : this.current()\n        );\n    }\n\n    async peek(length = 1) {\n        if (length === 0) return this.#current;\n        let $length = length - this.#peeks.length;\n        while ($length) {\n            const next = await this.#iterator.next();\n            if (next.done) break;\n            this.#peeksPush(next.value);\n            $length--;\n        }\n        const tok = this.#peeks[length - 1];\n        return tok;\n    }\n\n    async eat(type = undefined, value = undefined) {\n        const tok = !type ? this.current() : await this.match(type, value);\n        if (tok) (await this.next())?.value; // advance\n        return tok;\n    }\n\n    async expect(type, value = undefined) {\n        const tok = await this.eat(type, value);\n        if (!tok) throw new Error(`Expected token: ${type}${value ? ` (${value})` : ''}`);\n        return tok;\n    }\n\n    // Normal token flow\n\n    #historyPush(tok) {\n        // this.#history.push() <-- tok (this.#current)\n        if (tok?.type.endsWith('_block')) {\n            //tok.value.#locked = true;\n        }\n        if (this.#rootSavepoint !== null) {\n            this.#history.push(tok);\n        } else {\n            this.#history = [tok];\n        }\n    }\n\n    #peeksShift() {\n        // tok (this.#current) <-- this.#peeks.shift()\n        const tok = this.#peeks.shift();\n        if (tok?.type.endsWith('_block')) {\n            tok.value.#locked = false;\n        }\n        return tok;\n    }\n\n    // Reverse token flow\n\n    #historyPop() {\n        // this.#history.pop() --> tok (this.#current)\n        const tok = this.#history.pop();\n        if (tok?.type.endsWith('_block')) {\n            //tok.value.#locked = false;\n            tok.value.restore(tok.value.#rootSavepoint);\n        }\n        return tok;\n    }\n\n    #peeksUnshift(tok) {\n        // tok (this.#current) --> this.#peeks.unshift()\n        if (tok?.type.endsWith('_block')) {\n            tok.value.restore(tok.value.#rootSavepoint);\n            tok.value.#locked = true;\n        }\n        this.#peeks.unshift(tok);\n    }\n\n    // Peeking token flow\n\n    #peeksPush(tok) {\n        if (tok?.type.endsWith('_block')) {\n            tok.value.#locked = true;\n        }\n        this.#peeks.push(tok);\n    }\n\n    #assertNotLocked(method) {\n        if (this.#locked) {\n            throw new Error(`Can't execute ${method}; TokenStream is locked`);\n        }\n    }\n\n    savepoint() {\n        this.#assertNotLocked('savepoint()');\n        const point = this.#history.length;\n        if (this.#rootSavepoint === null) {\n            this.#rootSavepoint = point;\n        }\n        return point;\n    }\n\n    savepointStatus() {\n        return this.#rootSavepoint !== null\n            ? this.#history.length\n            : null;\n    }\n\n    restore(toIndex) {\n        this.#assertNotLocked('restore()');\n        if (this.#rootSavepoint === null || typeof toIndex !== 'number' || toIndex > this.#history.length) {\n            throw new Error(`Invalid restore point ${toIndex}${this.#rootSavepoint === null ? '. Not in savepoint mode' : ''}`);\n        }\n        while (toIndex < this.#history.length) {\n            if (this.#current) {\n                this.#peeksUnshift(this.#current);\n            }\n            this.#current = this.#historyPop();\n        }\n    }\n\n    commit(toIndex) {\n        this.#assertNotLocked('commit()');\n        if (toIndex !== this.#rootSavepoint) return;\n        let tok;\n        while (toIndex < this.#history.length && (tok = this.#historyPop())) {\n            if (tok.type.endsWith('_block')) {\n                tok.value.commit(tok.value.#rootSavepoint);\n            }\n        }\n        this.#rootSavepoint = null;\n    }\n\n    // Returns ToeknStream\n    static async create(input, { dialect = 'postgres', state = new TokenStreamState, ...options } = {}) {\n        if (Array.isArray(input) && input.every((s) => typeof s === 'object' && s?.type) && (input = input.slice())) {\n            return new this(\n                input[Symbol.iterator](),\n                { dialect, ...options },\n            );\n        }\n        // Normalize options. Consumers of the instance (i.e. parsers) might benefit from it\n        if (!options.normalized) {\n            options = normalizeOptions({ dialect, ...options, normalized: true });\n        }\n        return new this(\n            await this.createIterator(input, { dialect, state, ...options, extendedAPI: true }),\n            { dialect, ...options },\n        );\n    }\n\n    // Factory input -> to stream\n    static toIterator(input) {\n        if (typeof input[Symbol.asyncIterator] === 'function') {\n            return typeof input.next === 'function' ? input : input[Symbol.asyncIterator]();\n        }\n        if (typeof input[Symbol.iterator] === 'function' && typeof input !== 'string' && !(input instanceof String)) {\n            return typeof input.next === 'function' ? input : input[Symbol.iterator]();\n        }\n        return (function* () { yield input + ''; })();\n    }\n\n    // Returns Iterator\n    static async * createIterator(input, { dialect = 'postgres', state = new TokenStreamState, ...options } = {}) {\n\n        // Normalize input to stream\n        const stream = this.toIterator(input);\n        // Validate \"dialect\" and \"state\" input\n        if (!['postgres', 'mysql'].includes(dialect)) {\n            throw new Error(`Unknown dialect: ${dialect}`);\n        }\n        if (!(state instanceof TokenStreamState)) {\n            throw new Error('options.state must be an instance of TokenStreamState');\n        }\n        // Normalize options. Should it not have come from this.create()\n        if (!options.normalized) {\n            options = normalizeOptions({ dialect, ...options, normalized: true });\n        } else {\n            options = { dialect, ...options };\n        }\n        // Local state\n        const localState = {\n            token: null,\n            prevEmittedToken: null,\n            nextTokenSpaceBefore: '',\n            multiwordBuffer: [],\n        };\n        // Route token normalization\n        const $finalizeToken = (token, forceYield = false) => {\n            if (!token) return [];\n            const result = finalizeToken(token, { options, state, localState }, forceYield);\n            return result;\n        };\n\n        // Iterate over the input stream chunk by chunk\n        let chunk = { value: '' };\n        do {\n            state.buffer += chunk.value || ''/*when done*/;\n            let char;\n            while (char = state.buffer[state.cursor]) {\n\n                const possiblyChunked = state.buffer[state.cursor + 1] === undefined && !chunk.done;\n                const charIsWhitespace = whitespace.has(char);\n                const $throw = () => {\n                    throw new SyntaxError(`Unexpected token: ${char} at line ${state.line}, column ${state.column}`);\n                }\n\n                /**\n                 * ----------\n                 * PART A:\n                 * Feed or terminate sequences\n                 */\n\n                // ----------\n                // Feed (with validation) or terminate special literals.\n                // !ORDER: Note that because we're handling the ending of non-delimited \"literals\" here, (by whitespace)\n                // this block must run before the generic whitespace-handling block below\n                // Meanhwile, we're also using the opportunity to handle delimited ones's ending\n                if (localState.token?.type === 'hex_literal' || localState.token?.type === 'bit_literal') {\n                    const isEndTag = localState.token.delim ? char === localState.token.delim : charIsWhitespace;\n                    if (isEndTag) {\n                        yield* $finalizeToken(localState.token);\n                        localState.token = null;\n                        if (charIsWhitespace && options.spaces) {\n                            localState.nextTokenSpaceBefore += char;\n                        }\n                    } else {\n                        const type = localState.token?.type;\n                        if (type === 'hex_literal') {\n                            if (!/[0-9A-Fa-f]/.test(char)) $throw();\n                        } else {\n                            if (!/[01]/.test(char)) $throw();\n                        }\n                        localState.token.value += char;\n                    }\n                    state.next();\n                    continue;\n                }\n\n                // ----------\n                // Feed (with validation) or terminate \"version_specs\".\n                // !ORDER: Note that because we're handling the ending of non-delimited \"version_specs\" here, (by whitespace or dot)\n                // this block must run before the generic whitespace-handling block below\n                // Meanhwile, we're also using the opportunity to handle delimited ones's ending\n                if (localState.token?.type === 'version_spec') {\n                    const isEndQuote = localState.token.delim && char === localState.token.delim;\n                    const isEndTag = isEndQuote || (charIsWhitespace || char === '.' || char === ',' || char === ';' || char === ')');\n                    if (isEndTag) {\n                        yield* $finalizeToken(localState.token);\n                        localState.token = null;\n                    } else if (localState.token.value) {\n                        if (char === '=') {\n                            // \"=\" only allowed as @=2_4, @<=4, @>=2\n                            if (!['<', '>'].includes(localState.token.value)) $throw();\n                        } else if (char === '_') {\n                            // \"_\" only allowed as digits separator\n                            if (!/\\d$/.test(localState.token.value)) $throw();\n                        } else if (!/\\d/.test(char)) $throw();\n                        localState.token.value += char;\n                    } else {\n                        localState.token.value += char;\n                    }\n                    if (!isEndTag || isEndQuote) {\n                        state.next();\n                        continue;\n                    }\n                }\n\n                // ----------\n                // Whitespace and Linebreaks end sequences\n                // but:\n                // - whitespace is contigious with strings, delimited idents, and comments\n                // - line breaks end single-line comments\n                // !ORDER: Handle this early, but after the \"literals\" block above.\n                if (charIsWhitespace) {\n                    const isString = localState.token?.type === 'string_literal';\n                    const isDelimitedIdent = localState.token?.type === 'identifier' && localState.token.delim;\n                    const isBlockComment = localState.token?.type === 'block_comment';\n                    const isLineComment = localState.token?.type === 'line_comment';\n                    if (isString || isDelimitedIdent || isBlockComment || isLineComment && !(\n                        char === '\\r' || char === '\\n')\n                    ) {\n                        // Not a single-line comment ending. Treat as contigious!\n                        localState.token.value += char;\n                    } else {\n                        // Whitespace starting...? End current token!\n                        const prevChar = state.buffer[state.cursor - 1];\n                        if (!whitespace.has(prevChar) && localState.token) {\n                            yield* $finalizeToken(localState.token);\n                            localState.token = null;\n                        }\n                        if (options.spaces) {\n                            localState.nextTokenSpaceBefore += char;\n                        }\n                    }\n                    if (char === '\\n' || char === '\\r') {\n                        state.next(1, true);\n                    } else {\n                        state.next();\n                    }\n                    continue;\n                }\n\n                // ----------\n                // Handle backslahes in strings when in backslah-escaping mode\n                // - or when in nested context and is a Double Colon-escaping position\n                // !ORDER: Handle backslashes early.\n                if (char === '\\\\') {\n                    if (possiblyChunked) break; // We need to look ahead to know if this is comment ending\n                    let nextChar = state.buffer[state.cursor + 1];\n                    // String char escaping...\n                    const strings_inBackslashEscapeMode = localState.token?.type === 'string_literal' && (options.dialect === 'mysql' ? !options.mysqlNoBackslashEscapes : localState.token.modifier === 'E');\n                    const strings_atEscapePosition = nextChar === localState.token?.delim || nextChar === '\\\\' || nextChar === '0' || nextChar === 'b' || nextChar === 'f' || nextChar === 'n' || nextChar === 'r' || nextChar === 't' || nextChar === 'v' || nextChar === 'Z';\n                    if (strings_inBackslashEscapeMode && strings_atEscapePosition) {\n                        nextChar = {\n                            '\\\\': '\\\\', // to backslash char itself, here for completeness\n                            '0': '\\0', // to NUL byte (ASCII 0)\n                            'b': '\\b', // to backspace (ASCII 8)\n                            'f': '\\f', // to form feed\n                            'n': '\\n', // to newline\n                            'r': '\\r', // to carriage return\n                            't': '\\t', // to tab\n                            'v': '\\v', // to vertical tab\n                            'Z': '\\x1A', // to ASCII 26 (SUB / Control+Z) - represented as \\x1A in JS\n                        }[nextChar] || nextChar;\n                        localState.token.value += nextChar;\n                        state.next(2);\n                        continue;\n                    }\n                    state.nextTokenEscape = 1;\n                    state.next();\n                    continue;\n                }\n\n                // ----------\n                // Feed or terminate:\n                // - block_comment\n                // - string_literal\n                // - delimited identifier\n                // - delimited user_var\n                if (localState.token?.type === 'block_comment'\n                    || localState.token?.type === 'line_comment' // For feeding\n                    || localState.token?.type === 'string_literal'\n                    || (localState.token?.type === 'identifier' && localState.token.delim)\n                    || (localState.token?.type === 'user_var' && localState.token.delim)/*MySQL @'user-var'*/) {\n                    let tokenEndSteps;\n                    if (localState.token.type === 'block_comment') {\n                        if (char === '*') {\n                            if (possiblyChunked) break; // We need to look ahead to know if this is comment ending\n                            const nextChar = state.buffer[state.cursor + 1];\n                            tokenEndSteps = nextChar === '/' ? 2 : 0; // 2 chars for end tag, 0 otherwise: not a comment end\n                        }\n                    } else if (char === localState.token.delim) {\n                        // Two contiqious delims is escape when is identifier\n                        const twoContiqiousDelimsIsEscape = localState.token.type === 'identifier'\n                            // Or for strings, when not using backslash as escape\n                            || localState.token.type === 'string_literal' && (options.dialect === 'mysql' ? options.mysqlNoBackslashEscapes : localState.token.modifier !== 'E');\n                        // Do escaping if so\n                        if (twoContiqiousDelimsIsEscape) {\n                            if (possiblyChunked) break; // We need to look ahead to know if this is an quote escape quote\n                            const nextChar = state.buffer[state.cursor + 1];\n                            if (nextChar === char) {\n                                localState.token.value += char; // Pick one of the two quotes\n                                state.next(2); // and eat the other\n                                continue;\n                            }\n                        }\n                        // End token otherwise: char === localState.token.delim\n                        tokenEndSteps = 1;\n                    } else if (localState.token.type === 'string_literal' && localState.token.delim.startsWith('$')/*postgres*/ && char === '$') {\n                        // Specially catch Postgres' dollar-delims\n                        const cursor = state.cursor + 1;\n                        if (state.buffer.slice(cursor - localState.token.delim.length, cursor) === localState.token.delim) {\n                            localState.token.value = localState.token.value.slice(0, - localState.token.delim.length + 1);\n                            tokenEndSteps = 1;\n                        }\n                    }\n                    if (tokenEndSteps) {\n                        yield* $finalizeToken(localState.token);\n                        localState.token = null;\n                        state.next(tokenEndSteps);\n                        continue;\n                    }\n                    // Feed ongoing sequence\n                    localState.token.value += char;\n                    state.next();\n                    continue;\n                }\n\n                // ----------\n                // Handle closing nesting delims:\n                // - }\n                // - ]\n                // - )\n                if (state.nestingContext.length && char === { '{': '}', '[': ']', '(': ')' }[state.nestingContext[0]]) {\n                    yield* $finalizeToken(localState.token, true);\n                    state.nestingContext.shift();\n                    if (options.structured) {\n                        state.next(); // Eat the end tag\n                        localState.nestingEndTagSeen = true;\n                        return;\n                    }\n                    localState.token = null;\n                }\n\n                /**\n                 * ----------\n                 * PART B:\n                 * Start or restart sequences\n                 */\n\n                // ----------\n                // Start\n                // - comments\n                // - strings\n                // - identifiers\n                let tokenStart, tokenStartBacksteps = 0, tokenStartForwardsteps = 0;\n\n                if (options.dialect === 'postgres') {\n                    // Postgres' dollars :)\n                    if (localState.token?.type === 'pg_possible_dollar_delim' || char === '$') {\n                        // Catch the beginning of Postgres' dollar-delims\n                        if (localState.token?.type === 'pg_possible_dollar_delim') {\n                            if (char === '$') {\n                                const { type: _, value, delim: __, ...restTok } = localState.token;\n                                localState.token = { type: 'string_literal', value: '', delim: `$${value}$`, ...restTok };\n                            } else {\n                                localState.token.value += char;\n                            }\n                            state.next();\n                            continue;\n                        }\n                        if (possiblyChunked) break; // We need to look ahead to know if this is bind_var or...\n                        const nextChar = state.buffer[state.cursor + 1];\n                        if (/[0-9]/.test(nextChar)) {\n                            tokenStart = { type: 'bind_var' };\n                        } else {\n                            // ...possible dollar-delimited string\n                            tokenStart = { type: 'pg_possible_dollar_delim', delim: char };\n                        }\n                    }\n                } else if (options.dialect === 'mysql') {\n                    // MySQL's questions :)\n                    if (char === '?') {\n                        tokenStart = { type: 'bind_var' };\n                    }\n                    // MySQL's hash comments :)\n                    if (char === '#') {\n                        tokenStart = { type: 'line_comment', delim: char };\n                    }\n                    // MySQL's backflips :)\n                    if (char === '`') {\n                        tokenStart = { type: 'identifier', delim: char };\n                    }\n                }\n\n                // Strings and ansi-delimited identifers\n                if (char === \"'\") {\n                    const modifierPattern = new RegExp(`(@)$|^\\\\W?(${options.dialect === 'postgres' ? 'E|X|B' : 'N|X'})$`, 'i');\n                    const modifierMatch = state.buffer.slice(Math.max(state.cursor - 2, 0), state.cursor).match(modifierPattern);\n                    const modifier = modifierMatch?.[1] || modifierMatch?.[2];\n                    // First try to match LinkedQL version tag\n                    if (modifier === '@' && localState.prevEmittedToken?.type === 'identifier') {\n                        if (possiblyChunked) break; // We need to look ahead to properly determine if variable\n                        const nextChar = state.buffer[state.cursor + 1];\n                        if (/[\\^~=\\d<>!]/.test(nextChar)) {\n                            // Resolve to @'1_1_tags'\n                            tokenStart = { type: 'version_spec', delim: char };\n                            tokenStartBacksteps = 1;\n                        }\n                    }\n                    // Otherwise, resolve to:\n                    // E'new\\\\nline' (postgres)\n                    // N'unicode' (mysql)\n                    // X'FF' (mysql && postgres)\n                    // B'0101' (postgres)\n                    // @'mysql-user-var' (mysql)\n                    if (!tokenStart) {\n                        if (modifier && (modifier !== '@' || options.dialect === 'mysql')) {\n                            const type = /^(E|N)/i.test(modifier) ? 'string_literal' : (\n                                modifier === '@' ? 'user_var' : (modifier === 'X' ? 'hex_' : 'bit_') + 'literal'\n                            );\n                            tokenStart = { type, ...(type === 'string_literal' ? { modifier: modifier.toUpperCase() } : {}), delim: char };\n                            tokenStartBacksteps = modifier === '@' ? 1 : modifier.length;\n                        } else {\n                            tokenStart = { type: 'string_literal', delim: char };\n                        }\n                    }\n                } else if (char === '\"') {\n                    const type = options.dialect !== 'mysql' || options.mysqlAnsiQuotes ? 'identifier' : 'string_literal';\n                    tokenStart = { type, delim: char };\n                }\n\n                if (char === '@') {\n                    // LinkedQL version tag or MySQL user/system variable?\n                    if (possiblyChunked) break; // We need to look ahead to properly determine if variable\n                    const nextChar = state.buffer[state.cursor + 1];\n                    if ((localState.token || localState.prevEmittedToken)?.type === 'identifier' && /[\\^~=\\d<>!]/.test(nextChar)) {\n                        // LinkedQL @1_1_tags\n                        tokenStart = { type: 'version_spec' };\n                    } else if (options.dialect === 'mysql') {\n                        // MySQL's varieties :)\n                        if (nextChar === '@') {\n                            // MySQL system variables\n                            tokenStart = { type: 'system_var' };\n                            tokenStartForwardsteps = 1;\n                        } else if (/[a-zA-Z_$]/.test(nextChar)) {\n                            // MySQL user-defined variables\n                            tokenStart = { type: 'user_var' };\n                        }\n                    }\n                }\n\n                // Comments\n                if (char === '/' || char === '-') {\n                    if (possiblyChunked) break; // We need to look ahead to know if this is comment starting\n                    const nextChar = state.buffer[state.cursor + 1];\n                    if (char === '/' && nextChar === '*') {\n                        tokenStart = { type: 'block_comment' };\n                        tokenStartForwardsteps = 1;\n                    } else if (char === '-' && nextChar === '-') {\n                        tokenStart = { type: 'line_comment', delim: char + nextChar };\n                        tokenStartForwardsteps = 1;\n                    }\n                }\n\n                // Start token\n                if (tokenStart) {\n                    if (localState.token && !tokenStartBacksteps) {\n                        yield* $finalizeToken(localState.token);\n                    }\n                    localState.token = { type: tokenStart.type, value: '', ...tokenStart, line: state.line, column: tokenStartBacksteps ? state.column - tokenStartBacksteps : state.column };\n                    state.next(1 + tokenStartForwardsteps);\n                    continue;\n                }\n\n                // ----------\n                // Start nesting:\n                // - {\n                // - [\n                // - (\n                if (char === '{' || char === '[' || char === '(') {\n                    // When we encounter an opening nesting delim, we enter sub-tokenization\n                    yield* $finalizeToken(localState.token);\n                    localState.token = null;\n                    state.nestingContext.unshift(char);\n                    if (options.structured) {\n                        state.next();\n                        const groupToken = {\n                            type: { '{': 'brace_block', '[': 'bracket_block', '(': 'paren_block' }[char],\n                            value: await this[options.extendedAPI ? 'create' : 'createIterator'](stream, { state, ...options }),\n                            line: state.line,\n                            column: state.column,\n                        };\n                        yield* $finalizeToken(groupToken);\n                        if (options.extendedAPI) {\n                            await groupToken.value.peek(Infinity);\n                        } else {\n                            while (!(await groupToken.value.next()).done);\n                        }\n                        continue;\n                    }\n                }\n\n                /**\n                 * ----------\n                 * PART C:\n                 * Handle more nuanced sequences\n                 */\n\n                if (/[0-9]/.test(char)) {\n                    // A number \"literal\" or MySQL's HEX \"literal\" or Postgres' BIN \"literal\"\n                    // Passed along if this is part of an \"identifier\", \"bind_var\", \"version_spec\", \"*_literal\", or  \"*_var\" sequence\n                    if (localState.token?.type !== 'identifier' && localState.token?.type !== 'bind_var' && localState.token?.type !== 'version_spec' && !localState.token?.type.endsWith('_literal') && !localState.token?.type.endsWith('_var')) {\n                        yield* $finalizeToken(localState.token);\n                        if (/*HEX: 0xFF*/char === '0') {\n                            if (possiblyChunked) break; // We need to look ahead to know if this is an X\n                            const $type = state.buffer[state.cursor + 1]?.toUpperCase();\n                            if (($type === 'X' || $type === 'B') && options.dialect === 'mysql') {\n                                localState.token = { type: ($type === 'X' ? 'hex_' : 'bit_') + 'literal', value: '', line: state.line, column: state.column };\n                                state.next(2);\n                                continue;\n                            }\n                        }\n                        localState.token = { type: 'number_literal', value: char, line: state.line, column: state.column };\n                        state.next();\n                        continue;\n                    }\n                } else if (/[a-zA-Z_]/.test(char)) {\n                    // Alphanumeric sequences that start as \"identifier\" but could translate to \"keywords\", \"identifiers\", or even \"operators\"\n                    // Passed along if this is part of a \"identifier\" or \"*_var\" sequence or is the \"E\" in Scientific number notations\n                    if (localState.token?.type !== 'identifier' && !localState.token?.type.endsWith('_var') && !(localState.token?.type === 'number_literal'\n                        && /*EXP: 30e2*/(/\\d$/.test(localState.token.value) && /E/i.test(char)))) {\n                        // Throw if in mid-number sequence\n                        if (localState.token?.type === 'number_literal') $throw();\n                        yield* $finalizeToken(localState.token);\n                        // Start identifier\n                        localState.token = { type: 'identifier', value: char, line: state.line, column: state.column };\n                        state.next();\n                        continue;\n                    }\n                } else {\n                    // Handle punctuations and operators\n                    let type = 'operator';\n                    if (char === ';'\n                        || char === ','\n                        || char === ':'\n                        || char === '{'\n                        || char === '}'\n                        || char === '['\n                        || char === ']'\n                        || char === '('\n                        || char === ')') {\n                        if (char === ':' && (state.nestingContext[0] !== '{' || state.nextTokenEscape)) {\n                            type = 'operator'; // Postgres' colon is an operator, not a punctuation\n                        } else {\n                            type = 'punctuation';\n                        }\n                        if (options.dialect === 'postgres' && char === ':' && type === 'operator' && localState.token?.type !== 'operator') {\n                            const previousChar = state.buffer[state.cursor - 1];\n                            if (possiblyChunked) break; // We need to look ahead to know if this is number starting\n                            const nextChar = state.buffer[state.cursor + 1];\n                            if (previousChar !== ':' && /[a-zA-Z_]/.test(nextChar) && options.PL_SQL !== false) {\n                                type = 'user_var'; // PL/SQL variable\n                                char = '';\n                            }\n                        }\n                    } else if (char === '.') {\n                        if (localState.token?.type === 'number_literal') {\n                            // Mid-number punctuation; floats\n                            if (localState.token.value.includes('.')) $throw();\n                            type = 'number_literal'; // e.g. 2.4\n                        } else {\n                            // Pre-number punctuation? Same floats?\n                            if (possiblyChunked) break; // We need to look ahead to know if this is number starting or a punctuation\n                            const nextChar = state.buffer[state.cursor + 1];\n                            if (/\\d/.test(nextChar)) {\n                                type = 'number_literal'; // e.g. \".004\"\n                            } else {\n                                // Other punctuation. Standalone token:\n                                // e.g. tbl.col, tbl.*, db@<3_2.\"000-u\".id\n                                type = 'punctuation'; // e.g. \"tbl.col\", \"tbl . col\"\n                                // Or maybe MySQL special var punctuation?\n                                if (localState.token?.type === 'system_var') {\n                                    type = 'system_var'; // e.g. \"@@session. autocommit\"\n                                }\n                            }\n                        }\n                    } else if (char === '+' || char === '-') {\n                        if (localState.token?.type === 'number_literal' && /E$/i.test(localState.token.value)) {\n                            // Scientific number notation; EXP: 30e-2\n                            if (/\\+|\\-/.test(localState.token.value)) $throw();\n                            type = 'number_literal';\n                        }\n                    }\n\n                    // Feed an ongoing sequence or terminate that and start a new one?\n                    if (localState.token?.type !== type || type === 'punctuation' || (\n                        type === 'operator' && !options.operators.classic.has(`${localState.token.value}${char}`) /*not a valid operator afterall? e.g. \"=-\"*/\n                    )) {\n                        yield* $finalizeToken(localState.token);\n                        localState.token = { type, value: char, line: state.line, column: state.column };\n                        state.next();\n                        continue;\n                    }\n\n                    // Passed thru to feed an ongoing sequence\n                }\n\n                localState.token.value += char;\n                state.next();\n            }\n\n            if (chunk.done) break;\n            // Update buffer to handle overflow and continue from next chunk\n            state.buffer = state.buffer.slice(state.cursor);\n            state.cursor = 0;\n        } while (chunk = await stream.next());\n\n        if (localState.token) {\n            if (\n                (localState.token.type === 'operator' && localState.token.value !== '*')\n                || localState.token.type === 'number_literal' && /E$/i.test(localState.token.value)\n                || localState.token.type === 'block_comment'\n                || localState.token.type === 'pg_possible_dollar_delim'\n                || (\n                    ['string_literal', 'hex_literal', 'bit_literal', 'identifier', 'version_spec', 'user_var'].includes(localState.token.type)\n                    && localState.token.delim\n                )) {\n                throw new SyntaxError(`Unterminated ${localState.token.type} at line ${state.line}, column ${state.column}`);\n            }\n            yield* $finalizeToken(localState.token, true);\n        }\n        if (state.nestingContext.length && !localState.nestingEndTagSeen) {\n            throw new SyntaxError(`Unterminated nesting \"${state.nestingContext[0]}\" at line ${state.line}, column ${state.column}`);\n        }\n    }\n}\n\n// Lookups\nconst whitespace = new Set([' ', '\\f', '\\n', '\\r', '\\t', '\\v',]);\n\n// Normalize options\nfunction normalizeOptions(options) {\n    // Build the following list into our formats\n    const addMultiWord = (targetMap, prefix, tok, token) => {\n        tok.split(' ').reduce((_tok, chunk) => {\n            _tok = _tok ? `${_tok} ${chunk}` : chunk;\n            targetMap.set(_tok, token);\n            return _tok;\n        }, prefix);\n    };\n    for (const tokenCategory of ['statements', 'functionNames', 'aggrFunctionNames', 'keywords', 'operators', 'dataTypes']) {\n        const $tokenCategory = ['statements', 'functionNames', 'aggrFunctionNames'].includes(tokenCategory) ? 'keywords' : tokenCategory;\n        const tokenRegistry = options[$tokenCategory] || { classic: new Map, compound: new Map };\n        for (const tokenDialectBranch of ['common', options.dialect === 'mysql' ? 'mysql' : 'postgres']) {\n            const entries = toktypes[tokenCategory][tokenDialectBranch];\n            for (const entry of entries) {\n                const [value, token] = Array.isArray(entry) ? [entry[0], { ...entry[1], value: entry[0] }] : [entry, { value: entry }];\n                if (value.includes(' ')) {\n                    addMultiWord(tokenRegistry.compound, '', value, token);\n                } else {\n                    tokenRegistry.classic.set(value, token);\n                }\n            }\n        }\n        options = { ...options, [$tokenCategory]: tokenRegistry };\n    }\n    return options;\n}\n\n// Finalize tokens\nfunction finalizeToken(token, { options, state, localState }, forceYield = false) {\n    if (localState.nextTokenSpaceBefore) {\n        const { type, ...tok } = token;\n        token = { type, spaceBefore: localState.nextTokenSpaceBefore, ...tok };\n        localState.nextTokenSpaceBefore = '';\n    }\n    if (token.type === 'block_comment' || token.type === 'line_comment') {\n        return finalizeComment(token, { options });\n    }\n    let finalToken, identResolution = false;\n    if (options.dialect === 'mysql' && token.type === 'bind_var') {\n        finalToken = [{ ...token, value: `${++state.mysqlBindingIndex}` }];\n    } else if (token.type === 'operator') {\n        // Add operator definition details\n        const { line, column, ...restTok } = token;\n        finalToken = [{\n            ...restTok,\n            ...(options.operators.classic.get(token.value) || {}),\n            line,\n            column,\n        }];\n    } else if (token.type === 'identifier' && !token.delim) {\n        finalToken = finalizeIdentifier(token, { options, state, localState }, forceYield);\n        identResolution = true;\n    }\n    if (!finalToken/*Without asking length*/) {\n        finalToken = [token];\n    }\n    // -----\n    if (finalToken?.length) {\n        localState.prevEmittedToken = finalToken[0];\n    } else {\n        localState.prevEmittedToken = token;\n    }\n    // -----\n    if (!identResolution && finalToken.length && localState.multiwordBuffer.length) {\n        return localState.multiwordBuffer.splice(0).concat(finalToken);\n    }\n    return finalToken;\n}\n\n// Finalize comment tokens\nfunction finalizeComment(token, { options }) {\n    if (!options.comments) return [];\n    if (token.type === 'block_comment') {\n        token = { ...token, value: token.value.split('\\n').map((s) => s.replace(/^[ ]+\\*[ ]+?/, '').trim()).join('\\n') };\n    } else {\n        token = { ...token, value: token.value.trim() };\n    }\n    return [token];\n}\n\n// Finalize \"literal\" tokens\nfunction finalizeIdentifier(token, { options, state, localState }, forceYield = false) {\n    let finalToken,\n        multiwordBufferLength = localState.multiwordBuffer.length;\n    // Yield or build multiword operators\n    const wordSoFar = (\n        multiwordBufferLength ? localState.multiwordBuffer.map((tok) => tok.value).concat(token.value).join(' ') : token.value\n    ).toUpperCase();\n\n    const findInBranch = (branch) => {\n        for (const tokenCategory of ['keywords', 'operators', 'dataTypes']) {\n            const matchResult = options[tokenCategory][branch].get(wordSoFar);\n            if (matchResult) return [tokenCategory, matchResult];\n        }\n        return [];\n    };\n\n    const processExactMatch = () => {\n        let { type: _, spaceBefore, line, column, ...restTok } = token;\n        if (multiwordBufferLength) {\n            spaceBefore = localState.multiwordBuffer[0].spaceBefore;\n            line = localState.multiwordBuffer[0].line;\n            column = localState.multiwordBuffer[0].column;\n        }\n        const tok = {\n            type: tokenCategory === 'dataTypes' ? 'data_type' : tokenCategory.replace(/s$/, ''),\n            ...(spaceBefore ? { spaceBefore } : {}),\n            ...restTok,\n            ...matchResult, // Final value in here and overriding restTok.value\n            value: wordSoFar,\n            line, // \"line\" and \"column\" coming last now\n            column\n        };\n        if (multiwordBufferLength) {\n            finalToken = [tok];\n            localState.multiwordBuffer.splice(0);\n            multiwordBufferLength = 0;\n        } else {\n            finalToken = [tok];\n        }\n    };\n    const processPartialMatch = () => {\n        const tok = { ...token, type: tokenCategory === 'dataTypes' ? 'data_type' : tokenCategory.replace(/s$/, '') };\n        localState.multiwordBuffer.push(tok);\n        finalToken = [];\n    };\n\n    let multiwordMatched = false;\n    let [tokenCategory, matchResult] = findInBranch('compound');\n    if (matchResult?.value === wordSoFar) {\n        processExactMatch();\n        multiwordMatched = true;\n    } else if (matchResult) {\n        // first (e.g. DISTINCT kw vs DISTINCT FROM op)\n        const [tokenCategory2, matchResult2] = findInBranch('classic');\n        if (matchResult2 && tokenCategory2 !== tokenCategory) {\n            [tokenCategory, matchResult] = [tokenCategory2, matchResult2];\n        }\n        if (forceYield) {\n            processExactMatch();\n        } else {\n            processPartialMatch();\n        }\n        multiwordMatched = true;\n    } else {\n        [tokenCategory, matchResult] = findInBranch('classic');\n        if (matchResult) {\n            processExactMatch();\n            multiwordMatched = true;\n        }\n    }\n    if (!multiwordMatched && multiwordBufferLength) {\n        const existing = localState.multiwordBuffer.splice(0);\n        const current = finalizeToken(token, { options, state, localState });\n        return [...existing, ...current];\n    }\n    // Treat as identifier\n    if (!finalToken && /^(TRUE|FALSE|NULL|UNKNOWN)$/i.test(token.value)) {\n        const { type: _, ...tok } = token;\n        finalToken = [{\n            type: /UNKNOWN/.test(token.value) ? 'unknown_literal' : (/NULL/i.test(token.value) ? 'null_literal' : 'bool_literal'),\n            ...tok,\n            value: token.value.toUpperCase(),\n        }];\n    }\n    return finalToken;\n}\n", "export const registry = Object.create(null);\n", "import { _isObject } from '@webqit/util/js/index.js';\r\nimport { _eq, _toCapsSnake } from '../util.js';\r\nimport { TokenStream } from '../TokenStream.js';\r\nimport { TOK_TYPES } from '../toktypes.js';\r\nimport { registry } from '../registry.js';\r\n\r\n/**\r\n * parse(str, { ... })|fromJSON(json, {\r\n *   dialect,\r\n * \t mysqlAnsiQuotes\r\n *   mysqlNoBackslashEscapes,\r\n *   assert\r\n * })\r\n * \r\n * stringify({\r\n *   prettyPrint,\r\n * \t startingIndentLevel,\r\n *   autoLineBreakThreshold,\r\n *   pruneOptionalParens,\r\n *   tabSpaces\r\n * })\r\n * \r\n * jsonfy({\r\n *   nodeNames,\r\n *   toDialect,\r\n *   deSugar,\r\n *   reverseRef,\r\n *   memoizeDimensionalInsertSelect,\r\n * })\r\n */\r\n\r\nexport class AbstractNode {\r\n\r\n\tstatic get NODE_NAME() { return _toCapsSnake(this.name); }\r\n\tget NODE_NAME() { return this.constructor.NODE_NAME; }\r\n\r\n\t#ast;\r\n\tget _ast() { return this.#ast; }\r\n\r\n\t#options;\r\n\tget options() {\r\n\t\tconst options = this.#options || this.#parentNode?.options || { dialect: 'postgres' };\r\n\t\treturn options;\r\n\t}\r\n\r\n\t#parentNode;\r\n\tget parentNode() { return this.#parentNode; }\r\n\r\n\tget statementNode() { return this.#parentNode?.statementNode; }\r\n\r\n\tget rootNode() { return this.#parentNode?.rootNode || this; }\r\n\r\n\tconstructor(ast = {}, options = {}) {\r\n\t\tthis.#ast = ast;\r\n\t\tthis.#options = options;\r\n\t\tfor (const node_s of Object.values(this.#ast)) {\r\n\t\t\tthis._adoptNodes(...[].concat(node_s));\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * -----------\r\n\t * AST API\r\n\t * -----------\r\n\t */\r\n\r\n\t_has(fieldName, index = undefined, cs = undefined) {\r\n\t\tif (!(fieldName in this.#ast)) return false;\r\n\t\tif (typeof index === 'number') {\r\n\t\t\treturn typeof this.#ast[fieldName][index] !== 'undefined';\r\n\t\t}\r\n\t\tif (index) {\r\n\t\t\treturn this.#ast[fieldName].some((n) => n.identifiesAs?.(index, cs));\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\t_get(fieldName, index = undefined, cs = undefined) {\r\n\t\tif (!(fieldName in this.#ast)) return;\r\n\t\tif (typeof index !== 'undefined' && !Array.isArray(this.#ast[fieldName])) {\r\n\t\t\tthrow new Error(`Can't use index in field \"${fieldName}\"; not an array.`)\r\n\t\t}\r\n\t\tlet value = this.#ast[fieldName];\r\n\t\tif (typeof index === 'number') {\r\n\t\t\tvalue = value[index];\r\n\t\t} else if (index) {\r\n\t\t\tvalue = value.find((n) => n.identifiesAs?.(index, cs));\r\n\t\t}\r\n\t\treturn value;\r\n\t}\r\n\r\n\t_set(fieldName, indexOrValue, valueOnIndex = undefined, cs = undefined) {\r\n\t\tconst index = arguments.length > 2 ? indexOrValue : undefined;\r\n\t\tconst value = arguments.length > 2 ? valueOnIndex : indexOrValue;\r\n\t\tconst existing = this._get(fieldName, index, cs);\r\n\t\tif (existing) {\r\n\t\t\tthis._unadoptNodes(...[].concat(existing));\r\n\t\t}\r\n\t\tif (typeof index !== 'undefined') {\r\n\t\t\tthis.#ast[fieldName] = !existing\r\n\t\t\t\t? this.#ast[fieldName].concat(value)\r\n\t\t\t\t: this.#ast[fieldName].reduce((all, n) => {\r\n\t\t\t\t\tif (n === existing) return all.concat(value);\r\n\t\t\t\t\treturn all.concat(n);\r\n\t\t\t\t}, []);\r\n\t\t} else {\r\n\t\t\tthis.#ast[fieldName] = value;\r\n\t\t}\r\n\t\tthis._adoptNodes(...[].concat(value));\r\n\t\treturn true;\r\n\t}\r\n\r\n\t_delete(fieldName, index = undefined, cs = undefined) {\r\n\t\tif (!(fieldName in this.#ast)) return false;\r\n\t\tif (typeof index !== 'undefined' && !Array.isArray(this.#ast[fieldName])) {\r\n\t\t\tthrow new Error(`Can't use index in field \"${fieldName}\"; not an array.`)\r\n\t\t}\r\n\t\tif (typeof index !== 'undefined') {\r\n\t\t\tthis.#ast[fieldName] = this.#ast[fieldName].reduce((all, n, i) => {\r\n\t\t\t\tconst matches = typeof index === 'number' ? i === index : n.identifiesAs?.(index, cs);\r\n\t\t\t\tif (matches) {\r\n\t\t\t\t\tthis._unadoptNodes(n);\r\n\t\t\t\t\treturn all;\r\n\t\t\t\t}\r\n\t\t\t\treturn all.concat(n);\r\n\t\t\t}, []);\r\n\t\t} else {\r\n\t\t\tthis._unadoptNodes(...[].concat(this.#ast[fieldName]));\r\n\t\t\tthis.#ast[fieldName] = Array.isArray(this.#ast[fieldName]) ? [] : undefined;\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\t_add(fieldName, ...args) {\r\n\t\tif (!Array.isArray(this.#ast[fieldName])) {\r\n\t\t\tthrow new Error(`Can't add on field \"${fieldName}\"; not an array.`)\r\n\t\t}\r\n\t\tthis._adoptNodes(...args);\r\n\t\tthis.#ast[fieldName] = this.#ast[fieldName].concat(args);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t_adoptNodes(...nodes) {\r\n\t\tfor (const node of nodes) {\r\n\t\t\tif (!(node instanceof AbstractNode)) continue;\r\n\t\t\tif (node.#parentNode && node.#parentNode !== this) {\r\n\t\t\t\tconst activeTrailStr = `${this.NODE_NAME}`;\r\n\t\t\t\tthrow new Error(`[${activeTrailStr}] Illegal node operation`);\r\n\t\t\t}\r\n\t\t\tnode.#parentNode = this;\r\n\t\t}\r\n\t}\r\n\r\n\t_unadoptNodes(...nodes) {\r\n\t\tfor (const node of nodes) {\r\n\t\t\tif (!(node instanceof AbstractNode)) continue;\r\n\t\t\tif (node.#parentNode !== this) {\r\n\t\t\t\tconst activeTrailStr = `${this.NODE_NAME}`;\r\n\t\t\t\tthrow new Error(`[${activeTrailStr}] Illegal node operation`);\r\n\t\t\t}\r\n\t\t\tnode.#parentNode = null;\r\n\t\t}\r\n\t}\r\n\r\n\tclimbTree(visitor) {\r\n\t\tif (!this.#parentNode) return;\r\n\t\treturn visitor(this.#parentNode, () => {\r\n\t\t\treturn this.#parentNode.climbTree(visitor);\r\n\t\t});\r\n\t}\r\n\r\n\twalkTree(visitor) {\r\n\t\tconst visit = (value, key) => {\r\n\t\t\tif (!(value instanceof AbstractNode)\r\n\t\t\t\t&& !Array.isArray(value)) return;\r\n\r\n\t\t\tconst result = visitor(value, key);\r\n\t\t\tif (result !== value) return;\r\n\r\n\t\t\tif (Array.isArray(value)) {\r\n\t\t\t\tvalue.map(visit);\r\n\t\t\t} else if (value.statementNode !== value) {\r\n\t\t\t\tvalue.walkTree(visitor);\r\n\t\t\t}\r\n\t\t};\r\n\t\tfor (const [key, value] of Object.entries(this.#ast)) {\r\n\t\t\tvisit(value, key);\r\n\t\t}\r\n\t}\r\n\r\n\tcontainsNode(possibleChild) {\r\n\t\tif (!possibleChild) return false;\r\n\t\treturn this === possibleChild.parentNode || this.containsNode(possibleChild.parentNode);\r\n\t}\r\n\r\n\tidentifiesAs(value, cs = false) {\r\n\t\tif (typeof value === 'undefined') return false;\r\n\t\tif (typeof value?.jsonfy === 'function') {\r\n\t\t\treturn _eq(this.jsonfy({ nodeNames: false }), value.jsonfy({ nodeNames: false }), cs);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * -----------\r\n\t * TRANSFORMATION API\r\n\t * -----------\r\n\t */\r\n\r\n\tstatic morphsTo() { return this; }\r\n\r\n\tclone(options = {}, transformer = null, linkedDb = null) {\r\n\t\tconst resultJson = this.jsonfy(options, transformer, linkedDb);\r\n\t\tconst Classes = [this.constructor].concat(this.constructor.morphsTo());\r\n\t\tconst instance = Classes.reduce((prev, C) => prev || C.fromJSON(resultJson, { dialect: options.toDialect || this.options.dialect }), undefined);\r\n\t\treturn instance;\r\n\t}\r\n\r\n\tdeSugar(toLevl = 1, options = {}, transformer = null, linkedDb = null) {\r\n\t\toptions = { ...options, deSugar: toLevl/* overrridingly */ };\r\n\t\treturn this.clone(options, transformer, linkedDb);\r\n\t}\r\n\r\n\ttoDialect(dialect, options = {}, transformer = null, linkedDb = null) {\r\n\t\toptions = { ...options, toDialect: dialect/* overrridingly */ };\r\n\t\treturn this.clone(options, transformer, linkedDb);\r\n\t}\r\n\r\n\t/**\r\n\t * -----------\r\n\t * JSON API\r\n\t * -----------\r\n\t */\r\n\r\n\tstatic get syntaxRules() { return []; }\r\n\r\n\tstatic compileASTSchemaFromSyntaxRules({ dialect = 'postgres' } = {}) {\r\n\t\tif (!this._astSchemaCompileCache) {\r\n\t\t\tthis._astSchemaCompileCache = new Map;\r\n\t\t}\r\n\t\tconst cacheKey = `${this.NODE_NAME}:${dialect}`;\r\n\t\tif (!this._astSchemaCompileCache.has(cacheKey)) {\r\n\t\t\tlet result, syntaxRules = this.syntaxRules, rulesArray = [].concat(syntaxRules);\r\n\t\t\tif (rulesArray.length === 1 && Array.isArray(rulesArray[0].type) && !rulesArray[0].as) {\r\n\t\t\t\tresult = rulesArray[0];\r\n\t\t\t} else {\r\n\t\t\t\tresult = this._compileASTSchemaFromSyntaxRules(syntaxRules, dialect, { trail: [this.NODE_NAME] });\r\n\t\t\t}\r\n\t\t\tthis._astSchemaCompileCache.set(cacheKey, result);\r\n\t\t}\r\n\t\treturn this._astSchemaCompileCache.get(cacheKey);\r\n\t}\r\n\r\n\tstatic _compileASTSchemaFromSyntaxRules(syntaxRules, dialect = 'postgres', { trail = [], schemaSet = new Set([new Map]), assertionTrail = { dependencies: new Set, optional: false, assert: false } } = {}) {\r\n\t\tconst rulesArray = Array.isArray(syntaxRules) ? syntaxRules : [syntaxRules];\r\n\t\tconst newDependencyTrail = new Set(assertionTrail.dependencies);\r\n\t\tconst cloneSchemaSet = (schemaSet) => new Set([...schemaSet].map((sch) => new Map(sch)));\r\n\t\tfor (const [i, rule] of rulesArray.entries()) {\r\n\t\t\tif (rule.dialect && rule.dialect !== dialect) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tconst {\r\n\t\t\t\ttype,\r\n\t\t\t\tas: exposure,\r\n\t\t\t\tif: inference = assertionTrail.inference,\r\n\t\t\t\tvalue,\r\n\t\t\t\tarity,\r\n\t\t\t\tsingletons,\r\n\t\t\t\tmodifier,\r\n\t\t\t\tbooleanfy,\r\n\t\t\t\toptional = assertionTrail.optional,\r\n\t\t\t\tassert = assertionTrail.assert,\r\n\t\t\t\tsyntax,\r\n\t\t\t\tsyntaxes,\r\n\t\t\t\t...rest\r\n\t\t\t} = rule;\r\n\t\t\tconst activeTrail = trail.concat(`${Array.isArray(syntaxRules) ? i : ''}${exposure ? `<${exposure}>` : ''}` || []);\r\n\t\t\tconst activeTrailStr = activeTrail.join('.');\r\n\t\t\tconst unsupportedAttrs = _getUnsupportedRuleAttrs(rest);\r\n\t\t\tif (unsupportedAttrs.length) {\r\n\t\t\t\tthrow new SyntaxError(`[${activeTrailStr}] Unsupported attributes in rule: \"${unsupportedAttrs.join('\", \"')}\".`);\r\n\t\t\t}\r\n\t\t\tconst isTokenRule = typeof type === 'string' && type[0] === type[0].toLowerCase();\r\n\t\t\tif (exposure) {\r\n\t\t\t\t// 1. Validate rule\r\n\t\t\t\tif (!type) throw new SyntaxError(`[${activeTrailStr}] Field rules must have a \"type\" attribute of type string.`);\r\n\t\t\t\tif (syntax || syntaxes) throw new SyntaxError(`[${activeTrailStr}] Field rules (\"${exposure}\") can not have a \"syntax\" or \"syntaxes\" attribute.`);\r\n\t\t\t\tif (exposure === '.') {\r\n\t\t\t\t\tif (!isTokenRule) throw new SyntaxError(`[${activeTrailStr}] Terminal Node rules must be token-typed rules.`);\r\n\t\t\t\t\tif (optional) throw new SyntaxError(`[${activeTrailStr}] Terminal Node rules can not be optional.`);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (modifier) throw new SyntaxError(`[${activeTrailStr}] Only Terminal Node rules can have a \"modifier\" attribute.`);\r\n\t\t\t\t}\r\n\t\t\t\tif (isTokenRule) {\r\n\t\t\t\t\tif (![undefined, null].includes(arity)) throw new SyntaxError(`[${activeTrailStr}] Token rules can not be item-based.`);\r\n\t\t\t\t\tif (!TOK_TYPES[type]) throw new SyntaxError(`[${activeTrailStr}] Unknown token type \"${type}\".`);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (value) throw new SyntaxError(`[${activeTrailStr}] Only token rules can have a \"value\" attribute.`);\r\n\t\t\t\t\tfor (const t of [].concat(type)) {\r\n\t\t\t\t\t\tif (!registry[t]) throw new SyntaxError(`[${activeTrailStr}] Unknown node type \"${t}\".`);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (![undefined, null].includes(arity)) {\r\n\t\t\t\t\t\tif (_isObject(arity)) {\r\n\t\t\t\t\t\t\tconst keys = Object.keys(arity);\r\n\t\t\t\t\t\t\tif (keys.some((k) => !['min', 'max', 'eager'].includes(k) || (typeof arity[k] !== (k === 'eager' ? 'boolean' : 'number')))) {\r\n\t\t\t\t\t\t\t\tthrow new SyntaxError(`Invalid arity object \"{ ${keys.join(', ')} }\" for field \"${exposure}\". Only \"min: <number>\", \"max: <number>\" and \"eager: <bool>\" expected.`);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else if ([].concat(arity).some((a) => typeof a !== 'number')) {\r\n\t\t\t\t\t\t\tthrow new SyntaxError(`[${activeTrailStr}] Invalid arity value \"${[].concat(arity).join(', ')}\" for field \"${exposure}\". Number(s) expected.`);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// 2. Compose schema\r\n\t\t\t\tconst fieldSchema = { rulePath: activeTrailStr, type };\r\n\t\t\t\tif (value) fieldSchema.value = value;\r\n\t\t\t\tif (modifier) fieldSchema.modifier = modifier;\r\n\t\t\t\tif (booleanfy) fieldSchema.booleanfy = booleanfy;\r\n\t\t\t\tif (![undefined, null].includes(arity)) fieldSchema.arity = arity;\r\n\t\t\t\tif (singletons) fieldSchema.singletons = singletons;\r\n\t\t\t\tif (optional) fieldSchema.optional = true;\r\n\t\t\t\tif (assert) fieldSchema.assert = assert;\r\n\t\t\t\tif (inference) fieldSchema.if = inference;\r\n\t\t\t\tif (optional && assertionTrail.dependencies.size) {\r\n\t\t\t\t\tfieldSchema.dependencies = Array.from(assertionTrail.dependencies);\r\n\t\t\t\t}\r\n\t\t\t\t// 3. Expose\r\n\t\t\t\t// Earlier rules have populated schemas\r\n\t\t\t\tfor (const schema of schemaSet) {\r\n\t\t\t\t\tschema.set(exposure, fieldSchema);\r\n\t\t\t\t}\r\n\t\t\t\tif (exposure !== '.' && optional && !rule.optional) {\r\n\t\t\t\t\t// Optional context but rule NOT optional within context\r\n\t\t\t\t\tnewDependencyTrail.add(exposure);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (syntax || syntaxes) {\r\n\t\t\t\tconst newAssertionTrail = {\r\n\t\t\t\t\tdependencies: newDependencyTrail,\r\n\t\t\t\t\toptional,\r\n\t\t\t\t\tassert,\r\n\t\t\t\t\tinference,\r\n\t\t\t\t};\r\n\t\t\t\tif (syntax) {\r\n\t\t\t\t\tschemaSet = this._compileASTSchemaFromSyntaxRules(syntax, dialect, { trail: activeTrail.concat('syntax'), schemaSet, assertionTrail: newAssertionTrail });\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tconst newSchemaSet = new Set;\r\n\t\t\t\tfor (const [j, syntax] of syntaxes.entries()) {\r\n\t\t\t\t\tconst schemaSetClone = cloneSchemaSet(schemaSet);\r\n\t\t\t\t\tconst schemaSetCloneResult = this._compileASTSchemaFromSyntaxRules(syntax, dialect, { trail: activeTrail.concat('syntaxes', j), schemaSet: schemaSetClone, assertionTrail: newAssertionTrail });\r\n\t\t\t\t\tfor (const resultSchema of schemaSetCloneResult) {\r\n\t\t\t\t\t\tnewSchemaSet.add(resultSchema);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tschemaSet = newSchemaSet;\r\n\t\t\t}\r\n\t\t}\r\n\t\tconst schemasArray = Array.from(schemaSet);\r\n\t\tfor (let i = 0; i < schemasArray.length; i++) {\r\n\t\t\tconst schemaA = schemasArray[i];\r\n\t\t\tconst schemaAObj = Object.fromEntries(schemaA);\r\n\t\t\tif (!schemaA.size) {\r\n\t\t\t\tschemaSet.delete(schemaA);\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tfor (let j = i + 1; j < schemasArray.length; j++) {\r\n\t\t\t\tconst schemaB = schemasArray[j];\r\n\t\t\t\tconst schemaBObj = Object.fromEntries(schemaB);\r\n\t\t\t\tif (_eq(schemaAObj, schemaBObj, 'cs', 'rulePath')) {\r\n\t\t\t\t\tschemaSet.delete(schemaB);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn schemaSet;\r\n\t}\r\n\r\n\tstatic fromJSON(inputJson, options = {}, callback = null) {\r\n\r\n\t\t// This runs first: giving \"Expr\" - a polymorphic interface to run\r\n\t\tconst astSchema = this.compileASTSchemaFromSyntaxRules(options);\r\n\t\t// 1. Handle polymorphic interfaces\r\n\t\tif (Array.isArray(astSchema.type)) {\r\n\t\t\tfor (const type of astSchema.type) {\r\n\t\t\t\tconst NodeClass = registry[type];\r\n\t\t\t\tconst result = NodeClass.fromJSON(inputJson, options, callback);\r\n\t\t\t\tif (result) return result;\r\n\t\t\t}\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t// ----------\r\n\t\t// Pre compilation...\r\n\t\t// ----------\r\n\t\t// 1. Handle pre-formed nodes\r\n\t\tif (inputJson instanceof AbstractNode) {\r\n\t\t\tif (inputJson instanceof this) return inputJson;\r\n\t\t\tinputJson = inputJson.jsonfy();\r\n\t\t}\r\n\t\t// 2. Handle typed JSON objects\r\n\t\tif (!_isObject(inputJson)) return;\r\n\t\tlet hardCodedNodeName = null;\r\n\t\tif ('nodeName' in inputJson) {\r\n\t\t\tif (inputJson.nodeName && inputJson.nodeName !== this.NODE_NAME) {\r\n\t\t\t\treturn; // API mismatch\r\n\t\t\t}\r\n\t\t\t({ nodeName: hardCodedNodeName, ...inputJson } = inputJson);\r\n\t\t}\r\n\t\t// ----------\r\n\t\t// Compilation...\r\n\t\t// ----------\r\n\t\t// ...defs first\r\n\t\tlet lastAssertion;\r\n\t\tconst $decideThrow = (message, rulePath = null, assertsGrep = false) => {\r\n\t\t\tif (!hardCodedNodeName && options.assert !== true && !(options.assert instanceof RegExp && options.assert.test(activeTrailStr))) return;\r\n\t\t\tif (rulePath) {\r\n\t\t\t\tmessage = `[${rulePath}] ${message}`;\r\n\t\t\t}\r\n\t\t\tif (assertsGrep) {\r\n\t\t\t\tlastAssertion = message;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tthrow new Error(message);\r\n\t\t};\r\n\t\tconst matchTokenRule = (fieldSchema, fieldJson) => {\r\n\t\t\t// Match any predefined value list\r\n\t\t\tif (fieldSchema.value !== undefined) {\r\n\t\t\t\tconst expectedValue = fieldSchema.booleanfy ? [true, false] : fieldSchema.value;\r\n\t\t\t\treturn [].concat(expectedValue).includes(fieldJson.value);\r\n\t\t\t}\r\n\t\t\t// Match standard\r\n\t\t\treturn TOK_TYPES[fieldSchema.type].match?.(fieldJson, options) !== false;\r\n\t\t}\r\n\t\tconst resolveField = (fieldSchema, fieldValue) => {\r\n\t\t\tfor (const type of [].concat(fieldSchema.type)) {\r\n\t\t\t\tconst isTokenRule = typeof type === 'string' && type[0] === type[0].toLowerCase();\r\n\t\t\t\tif (isTokenRule) {\r\n\t\t\t\t\tif (matchTokenRule(fieldSchema, { value: fieldValue }) === true) return fieldValue;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tconst node = registry[type].fromJSON(fieldValue, { ...options, assert: false });\r\n\t\t\t\t\tif (node) return node;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\tconst acquireField = (resultAST, fieldName, fieldSchema, assertsGrep = false) => {\r\n\t\t\t// 1. Validate dependencies\r\n\t\t\tif (fieldSchema.dependencies?.length) {\r\n\t\t\t\tfor (const depField of fieldSchema.dependencies) {\r\n\t\t\t\t\tif (!(depField in resultAST)) {\r\n\t\t\t\t\t\t$decideThrow(`Missing dependency field \"${depField}\" required by \"${fieldName}\"`, fieldSchema.rulePath, assertsGrep);\r\n\t\t\t\t\t\treturn false; // API mismatch\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (fieldSchema.if && !_inferenceMatch(fieldSchema.if, resultAST, fieldSchema.rulePath)) {\r\n\t\t\t\treturn true; // Much like optional\r\n\t\t\t}\r\n\t\t\t// 2. Acquire entries\r\n\t\t\tif (![undefined, null].includes(fieldSchema.arity)) {\r\n\t\t\t\tif (inputJson[fieldName] === undefined) {\r\n\t\t\t\t\t// Undefined at all or empty\r\n\t\t\t\t\tif (fieldSchema.optional) {\r\n\t\t\t\t\t\tresultAST[fieldName] = undefined; // Show up\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t$decideThrow(`Missing required field \"${fieldName}\"`, fieldSchema.rulePath, assertsGrep);\r\n\t\t\t\t\treturn false; // API mismatch\r\n\t\t\t\t}\r\n\t\t\t\tif (!Array.isArray(inputJson[fieldName])) {\r\n\t\t\t\t\t$decideThrow(`Field \"${fieldName}\" must be an array`, fieldSchema.rulePath, assertsGrep);\r\n\t\t\t\t\treturn false; // Defined but API mismatch\r\n\t\t\t\t}\r\n\t\t\t\tif (fieldSchema.arity !== Infinity) {\r\n\t\t\t\t\tconst count = inputJson[fieldName].length;\r\n\t\t\t\t\tif (_isObject(fieldSchema.arity)) {\r\n\t\t\t\t\t\tif ('min' in fieldSchema.arity && count < fieldSchema.arity.min) {\r\n\t\t\t\t\t\t\t$decideThrow(`A minimum of ${fieldSchema.arity.min} argument(s) expected but got ${count}`, fieldSchema.rulePath, assertsGrep);\r\n\t\t\t\t\t\t\treturn false; // API mismatch\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif ('max' in fieldSchema.arity && count > fieldSchema.arity.max) {\r\n\t\t\t\t\t\t\t$decideThrow(`A maximum of ${fieldSchema.arity.max} argument(s) expected but got ${count}`, fieldSchema.rulePath, assertsGrep);\r\n\t\t\t\t\t\t\treturn false; // API mismatch\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if (![].concat(fieldSchema.arity).includes(count)) {\r\n\t\t\t\t\t\t$decideThrow(`Exactly ${[].concat(fieldSchema.arity).join(' or ')} argument(s) expected but got ${count}`, fieldSchema.rulePath, assertsGrep);\r\n\t\t\t\t\t\treturn false; // API mismatch\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tconst resultArray = inputJson[fieldName].map((entry) => resolveField(fieldSchema, entry)).filter((n) => n !== undefined);\r\n\t\t\t\tconst resultLenth = resultArray.length;\r\n\t\t\t\t// Some items resolved and some didn't?: Raise integrity error\r\n\t\t\t\tif (inputJson[fieldName].length > resultLenth) {\r\n\t\t\t\t\t// If resolution failed for all items...\r\n\t\t\t\t\tif (!resultLenth) {\r\n\t\t\t\t\t\t$decideThrow(`Failed to resolve any argument for \"${fieldName}\"`, fieldSchema.rulePath, assertsGrep);\r\n\t\t\t\t\t\treturn false; // API mismatch\r\n\t\t\t\t\t}\r\n\t\t\t\t\t$decideThrow(`Failed to resolve some arguments for \"${fieldName}\"`, fieldSchema.rulePath, assertsGrep);\r\n\t\t\t\t\treturn false; // API mismatch\r\n\t\t\t\t}\r\n\t\t\t\tif (fieldSchema.singletons) {\r\n\t\t\t\t\tconst havingDuplicate = resultArray.find((e, i) => {\r\n\t\t\t\t\t\treturn resultArray.slice(i + 1).some((_e) => {\r\n\t\t\t\t\t\t\treturn fieldSchema.singletons === 'BY_KEY'\r\n\t\t\t\t\t\t\t\t? _e.identifiesAs?.(e)\r\n\t\t\t\t\t\t\t\t: _e instanceof e.constructor;\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t});\r\n\t\t\t\t\tif (havingDuplicate) {\r\n\t\t\t\t\t\t$decideThrow(`Duplicate entry of type \"${havingDuplicate.constructor.name}\"`, fieldSchema.rulePath, assertsGrep);\r\n\t\t\t\t\t\treturn false; // API mismatch\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tresultAST[fieldName] = resultArray;\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\t// 3. Acquire classic field\r\n\t\t\tif (inputJson[fieldName] === undefined) {\r\n\t\t\t\tif (fieldSchema.optional) {\r\n\t\t\t\t\tresultAST[fieldName] = fieldSchema.booleanfy ? false : undefined; // Optional undefined\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t\t$decideThrow(`Missing required field \"${fieldName}\"`, fieldSchema.rulePath, assertsGrep);\r\n\t\t\t\treturn false; // API mismatch\r\n\t\t\t}\r\n\t\t\tconst result = resolveField(fieldSchema, inputJson[fieldName]);\r\n\t\t\tif (result === undefined) {\r\n\t\t\t\t$decideThrow(`Failed to resolve field \"${fieldName}\"`, fieldSchema.rulePath, assertsGrep);\r\n\t\t\t\treturn false; // API mismatch\r\n\t\t\t}\r\n\t\t\tresultAST[fieldName] = result;\r\n\t\t\treturn true;\r\n\t\t};\r\n\t\t// On to the AST composition based on first match\r\n\t\tpaths_loop: for (const $astSchema of (astSchema instanceof Map ? [astSchema] : astSchema)) {\r\n\t\t\tconst resultAST = Object.create(null);\r\n\t\t\tconst astSchema = new Map($astSchema);\r\n\t\t\tlet $inputJson = inputJson;\r\n\t\t\t// Acquire root AST fields\r\n\t\t\tif (astSchema.has('.')) {\r\n\t\t\t\tconst rootRule = astSchema.get('.');\r\n\t\t\t\tconst tokSchema = TOK_TYPES[rootRule.type];\r\n\t\t\t\t// Transfer relevant attributes from \"inputJson\" to \"resultAST\"\r\n\t\t\t\t// This effectively removes root-token-level attributes from \"inputJson\" before the next step below\r\n\t\t\t\tif ([undefined, null].includes($inputJson.value)) {\r\n\t\t\t\t\tcontinue paths_loop;\r\n\t\t\t\t}\r\n\t\t\t\t({ value: resultAST.value, ...$inputJson } = $inputJson);\r\n\t\t\t\tfor (const attr of Object.keys(tokSchema)) {\r\n\t\t\t\t\tif (typeof tokSchema[attr] === 'function') continue;\r\n\t\t\t\t\tif (attr in $inputJson) {\r\n\t\t\t\t\t\t({ [attr]: resultAST[attr], ...$inputJson } = $inputJson);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (matchTokenRule(rootRule, resultAST) === false) {\r\n\t\t\t\t\tcontinue paths_loop;\r\n\t\t\t\t}\r\n\t\t\t\tastSchema.delete('.');\r\n\t\t\t}\r\n\t\t\t// Acquire other AST fields\r\n\t\t\tfor (const fieldName of new Set(Object.keys($inputJson).concat(...astSchema.keys()))) {\r\n\t\t\t\t// Handle early mismatch\r\n\t\t\t\tif (!astSchema.has(fieldName)) {\r\n\t\t\t\t\tif (inputJson[fieldName] === undefined) {\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcontinue paths_loop; // To next schema; API mismatch\r\n\t\t\t\t}\r\n\t\t\t\tconst fieldSchema = astSchema.get(fieldName);\r\n\t\t\t\tif (acquireField(resultAST, fieldName, fieldSchema, true) === false) {\r\n\t\t\t\t\tcontinue paths_loop; // To next schema; API mismatch\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// Done here. First match!!!\r\n\t\t\tif (typeof callback === 'function') {\r\n\t\t\t\treturn callback(resultAST, options);\r\n\t\t\t}\r\n\t\t\treturn new this(resultAST, options);\r\n\t\t}\r\n\t\t$decideThrow(`Failed to match any schema${lastAssertion ? `. ${lastAssertion}` : ''}`, this.NODE_NAME);\r\n\t}\r\n\r\n\t// -----------\r\n\r\n\ttoJSON() { return this.jsonfy(); }\r\n\r\n\tjsonfy(options = {}, transformer = null, linkedDb = null) {\r\n\r\n\t\tconst jsonfy = (key, value, relevantTransformer) => {\r\n\r\n\t\t\tconst defaultTransform = (options1 = options, childTransformer = relevantTransformer) => {\r\n\t\t\t\tif (Array.isArray(value)) {\r\n\t\t\t\t\treturn value.reduce((entries, value, i) => {\r\n\t\t\t\t\t\tconst result = jsonfy(i, value, childTransformer);\r\n\t\t\t\t\t\tif (result === undefined) return entries;\r\n\t\t\t\t\t\treturn entries.concat(result);\r\n\t\t\t\t\t}, []);\r\n\t\t\t\t}\r\n\t\t\t\tif (value instanceof AbstractNode) {\r\n\t\t\t\t\treturn value.jsonfy(options1, childTransformer, linkedDb);\r\n\t\t\t\t}\r\n\t\t\t\treturn value;\r\n\t\t\t};\r\n\r\n\t\t\tif (value === undefined) return;\r\n\t\t\t\r\n\t\t\tconst result = relevantTransformer\r\n\t\t\t\t? relevantTransformer.transform(value, defaultTransform, key, options)\r\n\t\t\t\t: defaultTransform();\r\n\r\n\t\t\tif (result instanceof AbstractNode) {\r\n\t\t\t\tthrow new Error(`\"jsonfy\" transforms must return plain JSON objects.`);\r\n\t\t\t}\r\n\r\n\t\t\treturn result;\r\n\t\t};\r\n\r\n\t\treturn {\r\n\t\t\t...(options.nodeNames !== false ? { nodeName: this.NODE_NAME } : {}),\r\n\t\t\t...Object.fromEntries(Object.entries(this.#ast).reduce((resultEntries, [fieldName, value]) => {\r\n\r\n\t\t\t\tconst result = jsonfy(fieldName, value, transformer);\r\n\t\t\t\tif (result === undefined) return resultEntries;\r\n\r\n\t\t\t\treturn [...resultEntries, [fieldName, result]];\r\n\t\t\t}, [])),\r\n\t\t};\r\n\t}\r\n\r\n\t/**\r\n\t * -----------\r\n\t * PARSER API\r\n\t * -----------\r\n\t */\r\n\r\n\tstatic async toStream(input, options = {}) {\r\n\t\tconst tokenStream = !(input instanceof TokenStream)\r\n\t\t\t? await TokenStream.create(input, { structured: true, spaces: true, ...options })\r\n\t\t\t: input;\r\n\t\tif (!tokenStream.current() && !tokenStream.done) {\r\n\t\t\tawait tokenStream.next();\r\n\t\t}\r\n\t\treturn tokenStream;\r\n\t}\r\n\r\n\tstatic async parse(input, { left = undefined, minPrecedence = 0, trail = [], ...options } = {}) {\r\n\t\tconst tokenStream = await this.toStream(input, options);\r\n\t\tconst savepoint = tokenStream.savepoint();\r\n\t\tconst syntaxRules = this.syntaxRules;\r\n\t\t// 1. Resolve polymorphic interfaces\r\n\t\tlet result, rulesArray;\r\n\t\tif ((rulesArray = [].concat(syntaxRules)).length === 1 && Array.isArray(rulesArray[0].type) && !rulesArray[0].as) {\r\n\t\t\tif (rulesArray[0].expression) {\r\n\t\t\t\tresult = await this._parseAsExpression(tokenStream, rulesArray[0].type, { left, minPrecedence, trail: trail.concat(this.NODE_NAME), ...options });\r\n\t\t\t} else {\r\n\t\t\t\tresult = await this._parseFromTypes(tokenStream, rulesArray[0].type, { left, minPrecedence, trail: trail.concat(this.NODE_NAME), ...options });\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t// 2. Resolve full syntax rules\r\n\t\t\tconst resultAST = await this._parseFromRules(tokenStream, syntaxRules, { left, minPrecedence, trail: trail.concat(this.NODE_NAME), ...options });\r\n\t\t\tif (resultAST) {\r\n\t\t\t\tresult = new this(resultAST, { ...options, dialect: tokenStream.options.dialect });\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (!result) tokenStream.restore(savepoint);\r\n\t\treturn result;\r\n\t}\r\n\r\n\tstatic async _parseAsExpression(tokenStream, types, { left = undefined, minPrecedence, trail, ...options }) {\r\n\t\tif (left) throw new Error(`TODO`);\r\n\t\tleft = await this._parseFromTypes(tokenStream, types, { minPrecedence, trail, ...options });\r\n\t\twhile (left) {\r\n\t\t\t// Compose binary expressions (e.g., col + 2)\r\n\t\t\tconst operator = await tokenStream.match('operator');\r\n\t\t\tif (!operator || operator.prec < minPrecedence) break;\r\n\t\t\tconst prevLeft = left;\r\n\t\t\tconst newLeft = await this._parseFromTypes(tokenStream, types, {\r\n\t\t\t\tleft,\r\n\t\t\t\tminPrecedence,//: operator.prec + (operator.assoc === 'right' ? 0 : 1),\r\n\t\t\t\ttrail,\r\n\t\t\t\t...options\r\n\t\t\t});\r\n\t\t\tif (!newLeft) return left;\r\n\t\t\tleft = newLeft;\r\n\t\t}\r\n\t\treturn left;\r\n\t}\r\n\r\n\tstatic async _parseFromRules(tokenStream, syntaxRules, { left, minPrecedence, trail, ...options }, resultAST = {}) {\r\n\t\tconst rulesArray = Array.isArray(syntaxRules) ? syntaxRules : [syntaxRules];\r\n\t\tlet numSkippedRules_dialectWise = 0;\r\n\t\tlet newMinPrecedence = minPrecedence; // Default being 0\r\n\r\n\t\tfor (const [i, rule] of rulesArray.entries()) {\r\n\t\t\tif (rule.dialect && rule.dialect !== tokenStream.options.dialect) {\r\n\t\t\t\tnumSkippedRules_dialectWise++;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\t// -----\r\n\t\t\t// Rule destructuring...\r\n\t\t\t// -----\r\n\r\n\t\t\tconst {\r\n\t\t\t\trequiredSpacing,\r\n\t\t\t\tpeek,\r\n\t\t\t\ttype, // Usable in combination with \"syntax\", \"syntaxes\" for type === \"*_block\"\r\n\t\t\t\tvalue, // Token value matching\r\n\t\t\t\tsyntax, // Mutually-exclusive with \"syntaxes\" and \"type\" - except for type === \"*_block\"\r\n\t\t\t\tsyntaxes, // Mutually-exclusive with \"syntax\" and \"type\" - except for type === \"*_block\"\r\n\t\t\t\tas: exposure,\r\n\t\t\t\tif: inference,\r\n\t\t\t\tarity,\r\n\t\t\t\toptionalParens,\r\n\t\t\t\tsingletons,\r\n\t\t\t\titemSeparator,\r\n\t\t\t\toptional = false,\r\n\t\t\t\tassert = false,\r\n\t\t\t\tbooleanfy,\r\n\t\t\t\t...rest\r\n\t\t\t} = rule;\r\n\r\n\t\t\tconst activeTrail = trail.concat(`${Array.isArray(syntaxRules) ? i : ''}${exposure ? `<${exposure}>` : ''}` || []);\r\n\t\t\tconst activeTrailStr = activeTrail.join('.');\r\n\t\t\tconst unsupportedAttrs = _getUnsupportedRuleAttrs(rest);\r\n\t\t\tif (unsupportedAttrs.length) {\r\n\t\t\t\tthrow new SyntaxError(`[${activeTrailStr}] Unsupported attributes in rule: \"${unsupportedAttrs.join('\", \"')}\".`);\r\n\t\t\t}\r\n\t\t\tconst isTokenRule = typeof type === 'string' && type[0] === type[0].toLowerCase();\r\n\t\t\tconst supportsLeft = exposure && !isTokenRule && rulesArray[i + 1]?.type === 'operator' || (rulesArray[i + 1]?.type === 'punctuation' && rulesArray[i + 1]?.value === '.');\r\n\t\t\t// -----\r\n\t\t\t// Definitions...\r\n\t\t\t// -----\r\n\t\t\tconst acquireLeft = async () => {\r\n\t\t\t\tif (Array.isArray(peek) && !await peekToken(-1)) return;\r\n\t\t\t\tfor (const name of [].concat(type)) {\r\n\t\t\t\t\tif (left instanceof registry[name]) {\r\n\t\t\t\t\t\tresultAST[exposure] = left;\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn false;\r\n\t\t\t};\r\n\t\t\tconst matchSpacing = () => {\r\n\t\t\t\tconst current = tokenStream.current();\r\n\t\t\t\treturn (\r\n\t\t\t\t\t(requiredSpacing === false && !current?.spaceBefore) ||\r\n\t\t\t\t\t(requiredSpacing === true && current?.spaceBefore) ||\r\n\t\t\t\t\t(requiredSpacing === '\\n' && /\\n/.test(current?.spaceBefore))\r\n\t\t\t\t);\r\n\t\t\t};\r\n\t\t\tconst peekToken = async (adjustBy = 0) => {\r\n\t\t\t\tif (adjustBy) return await tokenStream.match(...[peek[0] + adjustBy, ...peek.slice(1)]);\r\n\t\t\t\treturn await tokenStream.match/*NOTE: not peek()*/(...peek);\r\n\t\t\t};\r\n\t\t\tconst eatToken = async () => {\r\n\t\t\t\tlet op;\r\n\t\t\t\tif ((op = await tokenStream.match('operator')) && op.prec < minPrecedence) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tconst tok = await tokenStream.eat(type, type.endsWith('_block') ? undefined : value);\r\n\t\t\t\tif (tok?.type === 'operator') {\r\n\t\t\t\t\tnewMinPrecedence = tok.prec + (tok.assoc === 'right' ? 0 : 1);\r\n\t\t\t\t}\r\n\t\t\t\treturn tok;\r\n\t\t\t};\r\n\t\t\tconst parseNode = async (activeTokenStream, newMinPrecedence) => {\r\n\t\t\t\tif (Array.isArray(type)) {\r\n\t\t\t\t\treturn await this._parseFromTypes(activeTokenStream, type, { minPrecedence: newMinPrecedence, trail: activeTrail, ...options });\r\n\t\t\t\t}\r\n\t\t\t\tconst NodeClass = registry[type];\r\n\t\t\t\tif (!NodeClass) throw new SyntaxError(`[${activeTrailStr}] Unknown node type <${type}>.`);\r\n\t\t\t\treturn await NodeClass.parse(activeTokenStream, { minPrecedence: newMinPrecedence, trail: activeTrail, ...options });\r\n\t\t\t};\r\n\t\t\tconst $decideThrow = (activeTokenStream, message, tokenStreamPosition = false, forceThrow = false) => {\r\n\t\t\t\tif (!assert && !forceThrow && options.assert !== true && !(options.assert instanceof RegExp && options.assert.test(activeTrailStr))) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tif (tokenStreamPosition) {\r\n\t\t\t\t\tconst current = activeTokenStream.current() || activeTokenStream.previous();\r\n\t\t\t\t\tconst proximityTerm = activeTokenStream.current() ? (tokenStreamPosition === 1 ? ':' : ' near') : ' by';\r\n\t\t\t\t\tmessage += !current ? `${proximityTerm} end of stream` : `${proximityTerm}${typeof current.value === 'string' ? ` \"${current.value}\"` : ''} (${current.type}) at <line ${current.line}, column ${current.column}>`;\r\n\t\t\t\t}\r\n\t\t\t\tthrow new SyntaxError(`[${activeTrailStr}] ${message}.`);\r\n\t\t\t};\r\n\r\n\t\t\t// -----\r\n\t\t\t// Validation...\r\n\t\t\t// -----\r\n\r\n\t\t\tif (type) {\r\n\t\t\t\tif (left) {\r\n\t\t\t\t\tif (!supportsLeft) return;\r\n\t\t\t\t\t// left === false is typically passed from PathMixin()\r\n\t\t\t\t\tif (!await acquireLeft()) return;\r\n\t\t\t\t\tleft = null;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t} else if (left === false && supportsLeft) {\r\n\t\t\t\t\tif (optional) {\r\n\t\t\t\t\t\tleft = null;\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// 2. Exit on any of the following...\r\n\t\t\t// Exit if a certain prop isn't in AST\r\n\t\t\tif (inference && !_inferenceMatch(inference, resultAST, activeTrailStr)) {\r\n\t\t\t\tcontinue; // Much like optional\r\n\t\t\t}\r\n\t\t\t// Exit if spacing doesn't match\r\n\t\t\tif (requiredSpacing !== undefined && !matchSpacing()) {\r\n\t\t\t\t$decideThrow(tokenStream, 'Required spacing mismatch', true);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\t// Exit if look-ahead fails\r\n\t\t\tif (Array.isArray(peek) && !await peekToken()) {\r\n\t\t\t\t$decideThrow(tokenStream, 'Peek failure', true);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// -----\r\n\t\t\t// Parsing...\r\n\t\t\t// -----\r\n\r\n\t\t\t// 1. Terminal node rules...\r\n\t\t\tif (exposure === '.') {\r\n\t\t\t\tif (!type || !isTokenRule) throw new SyntaxError(`[${activeTrailStr}] Terminal node rules must be token-typed rules.`);\r\n\t\t\t\tconst tok = await eatToken();\r\n\t\t\t\tif (!tok) {\r\n\t\t\t\t\t$decideThrow(tokenStream, `Token of type \"${type}\"${value ? ` and value \"${value}\"` : ''} expected but got \"${tokenStream.current()?.type}\"`, true);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tlet _type, line, column, spaceBefore, prec, assoc, resultType, rest;\r\n\t\t\t\t({ type: _type, line, column, spaceBefore, prec, assoc, resultType, ...rest } = tok);\r\n\t\t\t\tObject.assign(resultAST, rest);\r\n\t\t\t\tcontinue; // To next rule\r\n\t\t\t}\r\n\r\n\t\t\t// 2. Block rules... Unwrapped for the next set of evaluation...\r\n\t\t\tlet activeTokenStream = tokenStream;\r\n\t\t\tif (typeof type === 'string' && type.endsWith('_block')) {\r\n\t\t\t\tif (!(activeTokenStream = (await eatToken())?.value)) {\r\n\t\t\t\t\tif (optional) {\r\n\t\t\t\t\t\tcontinue; // To next rule\r\n\t\t\t\t\t}\r\n\t\t\t\t\t$decideThrow(tokenStream, `Token of type \"${type}\" expected but got \"${tokenStream.current()?.type}\"`, true);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tnewMinPrecedence = 0; // IMPORTANT: minPrecedence don't apply to blocks\r\n\t\t\t\tif (!activeTokenStream.current() && !activeTokenStream.done) {\r\n\t\t\t\t\tawait activeTokenStream.next();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// 3. Variadic field rules...\r\n\t\t\tif (![undefined, null].includes(arity)) {\r\n\t\t\t\tif (!exposure) throw new SyntaxError(`[${activeTrailStr}] Multi-argument field rules must have a \"as\" attribute.`);\r\n\t\t\t\tif (!type) throw new SyntaxError(`[${activeTrailStr}] Multi-argument field rules must have a \"type\" attribute.`);\r\n\t\t\t\tif (isTokenRule) throw new SyntaxError(`[${activeTrailStr}] Multi-argument field rules must be node-typed rules.`);\r\n\r\n\t\t\t\tlet entry, entries = [], itemMinPrecedence = newMinPrecedence;\r\n\t\t\t\tif (itemSeparator?.type === 'operator') {\r\n\t\t\t\t\t// Use the binding power of the itemSeparator\r\n\t\t\t\t\tconst relevantOperatorDef = itemSeparator.value && (\r\n\t\t\t\t\t\tactiveTokenStream.options.operators?.classic.get(itemSeparator.value) || activeTokenStream.options.operators?.compound.get(itemSeparator.value)\r\n\t\t\t\t\t);\r\n\t\t\t\t\tif (relevantOperatorDef?.prec) {\r\n\t\t\t\t\t\titemMinPrecedence = relevantOperatorDef?.prec + 1;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\twhile ((entry = await parseNode(activeTokenStream, itemMinPrecedence))) {\r\n\t\t\t\t\tif (singletons) {\r\n\t\t\t\t\t\tconst isDuplicate = singletons === 'BY_KEY'\r\n\t\t\t\t\t\t\t? entries.some((e) => e.identifiesAs?.(entry))\r\n\t\t\t\t\t\t\t: entries.some((e) => e instanceof entry.constructor);\r\n\t\t\t\t\t\tif (isDuplicate) {\r\n\t\t\t\t\t\t\t$decideThrow(activeTokenStream, `Duplicate entry of type \"${entry.constructor.name}\"`, true, true);\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tentries.push(entry);\r\n\t\t\t\t\tif (_isObject(arity) && arity.eager === false && entries.length === arity.max) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (itemSeparator && !await activeTokenStream.eat(\r\n\t\t\t\t\t\titemSeparator.type,\r\n\t\t\t\t\t\titemSeparator.value\r\n\t\t\t\t\t)) break;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (arity !== Infinity) {\r\n\t\t\t\t\tconst count = entries.length;\r\n\t\t\t\t\tif (!count && optional) {\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tconst current = activeTokenStream.current();\r\n\t\t\t\t\tconst currentAsUnexpected = current ? `. Unexpected ${current.type}${typeof current.value === 'string' ? ` \"${current.value}\"` : ''}` : '';\r\n\t\t\t\t\tif (_isObject(arity)) {\r\n\t\t\t\t\t\tif ('min' in arity && count < arity.min) {\r\n\t\t\t\t\t\t\t$decideThrow(activeTokenStream, `A minimum of ${arity.min} argument(s) expected but got ${count}${currentAsUnexpected}`, true);\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif ('max' in arity && count > arity.max) {\r\n\t\t\t\t\t\t\t$decideThrow(activeTokenStream, `A maximum of ${arity.max} argument(s) expected but got ${count}${currentAsUnexpected}`, true);\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if (![].concat(arity).includes(count)) {\r\n\t\t\t\t\t\t$decideThrow(activeTokenStream, `Exactly ${[].concat(arity).join(' or ')} argument(s) expected but got ${count}${currentAsUnexpected}`, true);\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tresultAST[exposure] = entries;\r\n\t\t\t\tcontinue; // To next rule\r\n\t\t\t}\r\n\r\n\t\t\t// 4. Classic rules...\r\n\t\t\tlet result;\r\n\t\t\tif (syntax) {\r\n\t\t\t\tconst savepoint = activeTokenStream.savepoint();\r\n\t\t\t\tresult = await this._parseFromRules(activeTokenStream, syntax, { left, minPrecedence: newMinPrecedence, trail: activeTrail.concat('syntax'), ...options });\r\n\t\t\t\tif (result === undefined) {\r\n\t\t\t\t\tactiveTokenStream.restore(savepoint);\r\n\t\t\t\t} else if (left) {\r\n\t\t\t\t\tleft = null;\r\n\t\t\t\t}\r\n\t\t\t} else if (syntaxes) {\r\n\t\t\t\tfor (const [j, syntax] of syntaxes.entries()) {\r\n\t\t\t\t\tconst savepoint = activeTokenStream.savepoint();\r\n\t\t\t\t\tresult = await this._parseFromRules(activeTokenStream, syntax, { left, minPrecedence: newMinPrecedence, trail: activeTrail.concat('syntaxes', j), ...options });\r\n\t\t\t\t\tif (result === undefined) {\r\n\t\t\t\t\t\tactiveTokenStream.restore(savepoint);\r\n\t\t\t\t\t} else break;\r\n\t\t\t\t}\r\n\t\t\t\tif (result !== undefined && left) {\r\n\t\t\t\t\tleft = null;\r\n\t\t\t\t}\r\n\t\t\t} else if (!(typeof type === 'string' && type.endsWith('_block'))) {\r\n\t\t\t\tresult = isTokenRule\r\n\t\t\t\t\t? (await eatToken())?.value\r\n\t\t\t\t\t: await parseNode(activeTokenStream, newMinPrecedence);\r\n\t\t\t} else if (!type) {\r\n\t\t\t\tthrow new SyntaxError(`[${activeTrailStr}] Rules must have a \"type\", \"syntax\" or \"syntaxes\" attribute.`);\r\n\t\t\t}\r\n\r\n\t\t\tif (result === undefined && !optional) {\r\n\t\t\t\t$decideThrow(activeTokenStream, type ? 'Unexpected token' : null, 1);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif (typeof type === 'string' && type.endsWith('_block')\r\n\t\t\t\t&& !activeTokenStream.done\r\n\t\t\t\t&& activeTokenStream.current()) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif (exposure) {\r\n\t\t\t\tif (booleanfy) {\r\n\t\t\t\t\tresult = result !== undefined;\r\n\t\t\t\t}\r\n\t\t\t\tresultAST[exposure] = result;\r\n\t\t\t} else if (syntax || syntaxes) {\r\n\t\t\t\tObject.assign(resultAST, result);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (numSkippedRules_dialectWise === rulesArray.length) {\r\n\t\t\t// IMPORTANT: Hard-exit to prevent returning a false positive, empty, resultAST\r\n\t\t\treturn;\r\n\t\t}\r\n\t\treturn resultAST;\r\n\t}\r\n\r\n\tstatic async _parseFromTypes(tokenStream, types, { left, minPrecedence, trail, ...options }) {\r\n\t\tfor (const type of types) {\r\n\t\t\tconst isTokenRule = typeof type === 'string' && type[0] === type[0].toLowerCase();\r\n\r\n\t\t\tif (isTokenRule) {\r\n\t\t\t\tif (await tokenStream.match(type)) {\r\n\t\t\t\t\treturn await tokenStream.eat();\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tconst NodeClass = registry[type];\r\n\t\t\t\tif (!NodeClass) throw new SyntaxError(`[${this.NODE_NAME}] Unknown node type \"${type}\".`);\r\n\t\t\t\tconst result = await NodeClass.parse(tokenStream, { left, minPrecedence, trail, ...options });\r\n\t\t\t\tif (result !== undefined) return result;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// -----------\r\n\r\n\ttoString() { return this.stringify(); }\r\n\r\n\tstringify(options = {}) {\r\n\t\t// Main\r\n\t\tconst rendering = this._stringifyFromRules(this.constructor.syntaxRules, { trail: [this.NODE_NAME], ...options });\r\n\t\treturn rendering;\r\n\t}\r\n\r\n\t_stringifyFromRules(syntaxRules, { trail = [], startingIndentLevel = 0, autoLineBreakThreshold = 60, ...options }, renderingStats = null) {\r\n\t\t// Formatters\r\n\t\tconst $space = () => ' ';\r\n\t\tconst $lineBreak = (indentLevel) => {\r\n\t\t\treturn `\\n${(\r\n\t\t\t\toptions.tabSpaces === 4 ? '\\t' : ' '.repeat(options.tabSpaces || 2)\r\n\t\t\t).repeat(indentLevel)}`;\r\n\t\t};\r\n\r\n\t\tconst resultTokens = [];\r\n\t\tconst rulesArray = [].concat(syntaxRules);\r\n\t\tlet numSkippedRules_optionalWise = 0;\r\n\r\n\t\tfor (const [i, rule] of rulesArray.entries()) {\r\n\t\t\tif (rule.dialect && rule.dialect !== this.options.dialect) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\t// -----\r\n\t\t\t// Rule destructuring...\r\n\t\t\t// -----\r\n\r\n\t\t\tconst {\r\n\t\t\t\trequiredSpacing,\r\n\t\t\t\ttype,\r\n\t\t\t\tvalue,\r\n\t\t\t\tbooleanfy,\r\n\t\t\t\tsyntax,\r\n\t\t\t\tsyntaxes,\r\n\t\t\t\tas: exposure,\r\n\t\t\t\tif: inference,\r\n\t\t\t\tarity,\r\n\t\t\t\titemSeparator,\r\n\t\t\t\toptional = false,\r\n\t\t\t\tautoSpacing = requiredSpacing,\r\n\t\t\t\toptionalParens,\r\n\t\t\t\tautoIndent = false,\r\n\t\t\t\tautoIndentAdjust = 0,\r\n\t\t\t} = rule;\r\n\r\n\t\t\tconst activeTrail = trail.concat(`${Array.isArray(syntaxRules) ? i : ''}${exposure ? `<${exposure}>` : ''}` || []);\r\n\t\t\tconst activeTrailStr = activeTrail.join('.');\r\n\t\t\tlet $autoIndent = autoIndent;\r\n\r\n\t\t\tif (inference && !_inferenceMatch(inference, this.#ast, this.NODE_NAME)) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tconst activeOptions = {\r\n\t\t\t\tstartingIndentLevel: startingIndentLevel + (autoIndent ? 1 : 0) + autoIndentAdjust,\r\n\t\t\t\tautoLineBreakThreshold,\r\n\t\t\t\t...options\r\n\t\t\t};\r\n\r\n\t\t\tlet rendering;\r\n\t\t\tif (![undefined, null].includes(arity)) {\r\n\t\t\t\tlet shouldRender = false; // Until we match items to syntax's arity\r\n\r\n\t\t\t\tconst entries = this._get(exposure);\r\n\t\t\t\tconst count = entries?.length || 0;\r\n\r\n\t\t\t\tif (typeof autoIndent === 'number' && count < autoIndent) {\r\n\t\t\t\t\tactiveOptions.startingIndentLevel -= 1;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (entries) {\r\n\t\t\t\t\tif (!(shouldRender = arity === Infinity)) {\r\n\t\t\t\t\t\tif (_isObject(arity)) {\r\n\t\t\t\t\t\t\tshouldRender = (!('min' in arity) || count >= arity.min)\r\n\t\t\t\t\t\t\t\t&& (!('max' in arity) || count <= arity.max);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tshouldRender = [].concat(arity).includes(count)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (shouldRender) {\r\n\t\t\t\t\tconst itemsRendering = entries.map((entry) => entry.stringify(activeOptions));\r\n\t\t\t\t\t$autoIndent = autoIndent === true\r\n\t\t\t\t\t\t|| (typeof autoIndent === 'number' && entries.length >= autoIndent)\r\n\t\t\t\t\t\t|| autoSpacing === '\\n';\r\n\t\t\t\t\t// Determine item spacing...\r\n\t\t\t\t\tconst renderingsStr = itemsRendering.join(' ');\r\n\t\t\t\t\tconst $autoItemSpacing = activeOptions.prettyPrint && $autoIndent && (renderingsStr.length > autoLineBreakThreshold || renderingsStr.includes('\\n'))\r\n\t\t\t\t\t\t? $lineBreak(activeOptions.startingIndentLevel)\r\n\t\t\t\t\t\t: $space();\r\n\t\t\t\t\t// Compose separator\r\n\t\t\t\t\tlet $itemSeparator = itemSeparator ? this._stringifyTerminal(itemSeparator, activeOptions) : '';\r\n\t\t\t\t\tif (/^\\w+$/.test($itemSeparator)) {\r\n\t\t\t\t\t\t$itemSeparator = `${$autoItemSpacing}${$itemSeparator}${$autoItemSpacing}`;\r\n\t\t\t\t\t} else if ($itemSeparator === ';' && activeOptions.prettyPrint) {\r\n\t\t\t\t\t\t$itemSeparator = `${$itemSeparator}\\n${$autoItemSpacing}`;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t$itemSeparator = `${$itemSeparator}${$autoItemSpacing}`;\r\n\t\t\t\t\t}\r\n\t\t\t\t\trendering = itemsRendering.join($itemSeparator);\r\n\t\t\t\t}\r\n\t\t\t} else if (syntax) {\r\n\t\t\t\trendering = this._stringifyFromRules(syntax, { trail: activeTrail.concat('syntax'), ...activeOptions }, renderingStats);\r\n\t\t\t} else if (syntaxes) {\r\n\r\n\t\t\t\tlet highestRenderingScore = -1;\r\n\r\n\t\t\t\tfor (const [j, syntax] of syntaxes.entries()) {\r\n\t\t\t\t\tconst newRenderingStats = { score: 0 };\r\n\t\t\t\t\tconst $rendering = this._stringifyFromRules(syntax, { trail: activeTrail.concat('syntaxes', j), ...activeOptions }, newRenderingStats);\r\n\t\t\t\t\tif (typeof $rendering === 'string' && newRenderingStats.score > highestRenderingScore) {\r\n\t\t\t\t\t\trendering = $rendering;\r\n\t\t\t\t\t\thighestRenderingScore = newRenderingStats.score;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (renderingStats) { renderingStats.score += highestRenderingScore; }\r\n\t\t\t} else {\r\n\t\t\t\tif (exposure) {\r\n\t\t\t\t\tlet fieldValue = this._get(exposure === '.' ? 'value' : exposure);\r\n\t\t\t\t\tconst hasExpectedValue = value !== undefined && value !== null;\r\n\t\t\t\t\tif (hasExpectedValue && booleanfy) {\r\n\t\t\t\t\t\tif (fieldValue === true) {\r\n\t\t\t\t\t\t\tfieldValue = value;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (hasExpectedValue) {\r\n\t\t\t\t\t\tif ([].concat(value).includes(fieldValue)) {\r\n\t\t\t\t\t\t\tif (renderingStats) {\r\n\t\t\t\t\t\t\t\trenderingStats.score++;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tfieldValue = undefined;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (fieldValue !== undefined) {\r\n\t\t\t\t\t\tif (fieldValue instanceof AbstractNode) {\r\n\t\t\t\t\t\t\tfieldValue = fieldValue.stringify(activeOptions);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tconst $rule = exposure === '.'\r\n\t\t\t\t\t\t\t? { ...rule, ...this.#ast }\r\n\t\t\t\t\t\t\t: { ...rule, value: fieldValue };\r\n\t\t\t\t\t\trendering = this._stringifyTerminal($rule, activeOptions);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\t\t\t\t\trendering = this._stringifyTerminal(rule, activeOptions);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// -----\r\n\r\n\t\t\tif (type === 'paren_block' && optionalParens) {\r\n\t\t\t\tif (!rendering?.trim()) {\r\n\t\t\t\t\tif (optionalParens === true || options.pruneOptionalParens) {\r\n\t\t\t\t\t\tif (renderingStats) {\r\n\t\t\t\t\t\t\trenderingStats.score++;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tnumSkippedRules_optionalWise++;\r\n\t\t\t\t\t\tcontinue; // Skip this rule\r\n\t\t\t\t\t}\r\n\t\t\t\t\trendering = '';\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (rendering === undefined) {\r\n\t\t\t\tif (optional) {\r\n\t\t\t\t\tnumSkippedRules_optionalWise++;\r\n\t\t\t\t\tcontinue; // Skip this rule\r\n\t\t\t\t}\r\n\t\t\t\treturn; // Exit whole rule sequence\r\n\t\t\t}\r\n\t\t\tif (exposure && renderingStats) {\r\n\t\t\t\trenderingStats.score++;\r\n\t\t\t}\r\n\r\n\t\t\t// Add \"block\" tags?\r\n\t\t\tlet autoSpaceIgnore = false;\r\n\t\t\tconst hitsAutoLineBreakThreshold = rendering.length > autoLineBreakThreshold || /**/rendering.includes('\\n');\r\n\t\t\tif (typeof type === 'string' && type.endsWith('_block')) {\r\n\t\t\t\tconst blockAutoLineBreakMode = activeOptions.prettyPrint && autoIndent && hitsAutoLineBreakThreshold;\r\n\t\t\t\tconst delims = { brace_block: '{}', bracket_block: '[]', paren_block: '()' }[type];\r\n\r\n\t\t\t\trendering = [\r\n\t\t\t\t\tdelims[0],\r\n\t\t\t\t\tblockAutoLineBreakMode && !/^\\s/.test(rendering) ? $lineBreak(startingIndentLevel + 1) : (delims[0] === '{' ? $space() : ''),\r\n\t\t\t\t\trendering,\r\n\t\t\t\t\tblockAutoLineBreakMode || /^\\s/.test(rendering) ? $lineBreak(startingIndentLevel) : (delims[1] === '}' ? $space() : ''),\r\n\t\t\t\t\tdelims[1],\r\n\t\t\t\t].join('');\r\n\t\t\t} else if (activeOptions.prettyPrint && $autoIndent && (resultTokens.length || hitsAutoLineBreakThreshold) && rendering !== '') {\r\n\r\n\t\t\t\trendering = [\r\n\t\t\t\t\t$lineBreak(startingIndentLevel + (autoSpacing === '\\n' ? 0 : 1)),\r\n\t\t\t\t\trendering,\r\n\t\t\t\t].join('');\r\n\r\n\t\t\t\tautoSpaceIgnore = true;\r\n\t\t\t}\r\n\t\t\t// Space this chunk?\r\n\t\t\tconst precedingTok = resultTokens[resultTokens.length - 1];\r\n\t\t\tif (rendering !== ''\r\n\t\t\t\t&& !autoSpaceIgnore\r\n\t\t\t\t&& resultTokens.length\r\n\t\t\t\t// \"Do\" autoSpacing didnt already end with a space character\r\n\t\t\t\t&& !/\\s$/.test(precedingTok)\r\n\t\t\t\t// \"Force\" autoSpacing if previous token ends as alphanumeric and new token (rendering) starts as alphanumeric\r\n\t\t\t\t&& (Array.isArray(autoSpacing) ? autoSpacing.includes(precedingTok) : autoSpacing !== false)) {\r\n\t\t\t\tif (autoSpacing === '\\n' && activeOptions.prettyPrint) {\r\n\t\t\t\t\tresultTokens.push($lineBreak(startingIndentLevel));\r\n\t\t\t\t} else {\r\n\t\t\t\t\tresultTokens.push($space());\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tresultTokens.push(rendering);\r\n\t\t}\r\n\t\tif (resultTokens.length || numSkippedRules_optionalWise === rulesArray.length) {\r\n\t\t\treturn resultTokens.join('');\r\n\t\t}\r\n\t}\r\n\r\n\t_stringifyTerminal(tok, options = {}) {\r\n\t\tswitch (tok.type) {\r\n\t\t\tcase 'data_type': return this._stringifyDataType(tok, options);\r\n\t\t\tcase 'identifier': return this._stringifyIdentifier(tok, options);\r\n\t\t\tcase 'keyword': return this._stringifyKeyword(tok, options);\r\n\t\t\tcase 'operator': return this._stringifyOperator(tok, options);\r\n\t\t\tcase 'punctuation': return this._stringifyPunctuation(tok, options);\r\n\t\t\tcase 'bind_var': return this._stringifyBindVar(tok, options);\r\n\t\t\tcase 'version_spec': return `@${tok.value}`;\r\n\t\t}\r\n\t\tif (!Array.isArray(tok.type)) {\r\n\t\t\tif (tok.type.endsWith('_literal')) {\r\n\t\t\t\treturn this._stringifyLiteral(tok, options);\r\n\t\t\t}\r\n\t\t\tif (tok.type.endsWith('_var')) {\r\n\t\t\t\treturn this._stringifyVariable(tok, options);\r\n\t\t\t}\r\n\t\t\tif (tok.type.endsWith('_comment')) {\r\n\t\t\t\treturn this._stringifyComment(tok, options);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn String(tok.value);\r\n\t}\r\n\r\n\t_stringifyIdentifier(tok) {\r\n\t\tconst { value } = tok;\r\n\t\tconst delimChars = ['\"'];\r\n\t\t// ------------\r\n\t\t// Resolve from mysqlAnsiQuotes if mysql...\r\n\t\tif (this.options.dialect === 'mysql') {\r\n\t\t\tif (this.options.mysqlAnsiQuotes) {\r\n\t\t\t\tdelimChars.push('`'); // Backticks is ALSO identifier delim\r\n\t\t\t} else {\r\n\t\t\t\tdelimChars.fill('`'); // Backticks is ONLY identifier delim\r\n\t\t\t}\r\n\t\t}\r\n\t\t// Use tok-specified delim if valid\r\n\t\tconst delimChar = delimChars.includes(tok.delim)\r\n\t\t\t? tok.delim // Choose this one\r\n\t\t\t: delimChars[0];\r\n\t\t// ------------\r\n\t\tconst shouldQuote = tok.delim\r\n\t\t\t|| /^\\d/.test(value)\r\n\t\t\t|| !/^(\\*|[\\w]+)$/.test(value);\r\n\t\treturn shouldQuote\r\n\t\t\t? `${delimChar}${String(value || '').replace(new RegExp(delimChar, 'g'), delimChar.repeat(2))}${delimChar}`\r\n\t\t\t: value;\r\n\t}\r\n\r\n\t_stringifyKeyword(tok) { return String(tok.value); }\r\n\r\n\t_stringifyOperator(tok) {\r\n\t\tif (tok.value === ':' && this.#parentNode?.isProperty) {\r\n\t\t\treturn '\\\\:';\r\n\t\t}\r\n\t\treturn String(tok.value);\r\n\t}\r\n\r\n\t_stringifyPunctuation(tok) { return String(tok.value); }\r\n\r\n\t_stringifyDataType(tok) { return String(tok.value); }\r\n\r\n\t_stringifyLiteral(tok, options) {\r\n\t\tconst { value } = tok;\r\n\t\t// ------------\r\n\t\tswitch (tok.type) {\r\n\t\t\tcase 'bit_literal': return this._stringifyBitLiteral(tok, options);\r\n\t\t\tcase 'hex_literal': return this._stringifyHexLiteral(tok, options);\r\n\t\t\tcase 'number_literal': return this._stringifyNumberLiteral(tok, options);\r\n\t\t\tcase 'string_literal': return this._stringifyStringLiteral(tok, options);\r\n\t\t\tcase 'bool_literal': return /^true$/i.test(value + '') ? 'TRUE' : 'FALSE';\r\n\t\t\tcase 'null_literal': return 'NULL';\r\n\t\t}\r\n\t\treturn String(value);\r\n\t}\r\n\r\n\t_stringifyBindVar(tok) {\r\n\t\tconst { value } = tok;\r\n\t\t// ------------\r\n\t\tif (this.options.dialect === 'mysql') {\r\n\t\t\treturn `?`;\r\n\t\t}\r\n\t\treturn `$${value}`;\r\n\t}\r\n\r\n\t_stringifyBitLiteral(tok) {\r\n\t\tconst { value } = tok;\r\n\t\t// ------------\r\n\t\tif (this.options.dialect === 'mysql') {\r\n\t\t\treturn `0b${value}`;\r\n\t\t}\r\n\t\treturn `B'${value}'`;\r\n\t}\r\n\r\n\t_stringifyHexLiteral(tok) {\r\n\t\tconst { value } = tok;\r\n\t\t// ------------\r\n\t\tif (this.options.dialect === 'mysql') {\r\n\t\t\treturn `0x${value}`;\r\n\t\t}\r\n\t\treturn `X'${value}'`;\r\n\t}\r\n\r\n\t_stringifyNumberLiteral(tok) {\r\n\t\tconst { value } = tok;\r\n\t\t// ------------\r\n\t\treturn String(value);\r\n\t}\r\n\r\n\t_stringifyStringLiteral(tok) {\r\n\t\tlet { value } = tok;\r\n\t\tconst delimChars = [\"'\"];\r\n\t\tlet escChar = null;\r\n\t\t// ------------\r\n\t\t// Resolve from dialect...\r\n\t\tif (this.options.dialect === 'postgres' && tok.delim?.startsWith('$')) {\r\n\t\t\tdelimChars.fill(tok.delim); // OVERRIDE\r\n\t\t} else if (this.options.dialect === 'mysql' && !this.options.mysqlAnsiQuotes) {\r\n\t\t\tdelimChars.push('\"'); // Double quotes is ALSO string delim\r\n\t\t}\r\n\t\t// Use tok-specified delim if valid\r\n\t\tconst delimChar = delimChars.includes(tok.delim)\r\n\t\t\t? tok.delim // Choose this one\r\n\t\t\t: delimChars[0];\r\n\t\t// Using backslash escaping?\r\n\t\tif (this.options.dialect === 'mysql' && !this.options.mysqlNoBackslashEscapes\r\n\t\t\t|| this.options.dialect === 'postgres' && tok.modifier === 'E') {\r\n\t\t\tescChar = '\\\\'; // In which case: the delim plus [\\\\\\0\\b\\r\\n\\t\\x1A] are backslashed/encoded\r\n\t\t}\r\n\t\t// ------------\r\n\t\t// Is Postgres dollar-quoted string?\r\n\t\tif (delimChar.length > 1) { // e.g. for $$string$$\r\n\t\t\treturn `${delimChar}${value}${delimChar}`;\r\n\t\t}\r\n\t\tif (!escChar) {\r\n\t\t\tescChar = delimChar;\r\n\t\t} else if (escChar === '\\\\') {\r\n\t\t\tconst defs = {\r\n\t\t\t\t'\\\\': '\\\\\\\\', // from backslash char itself\r\n\t\t\t\t'\\0': '\\\\0', // from NUL byte (ASCII 0)\r\n\t\t\t\t'\\b': '\\\\b', // from backspace (ASCII 8)\r\n\t\t\t\t'\\f': '\\\\f', // from form feed\r\n\t\t\t\t'\\n': '\\\\n', // from newline\r\n\t\t\t\t'\\r': '\\\\r', // from carriage return\r\n\t\t\t\t'\\t': '\\\\t', // from tab\r\n\t\t\t\t'\\v': '\\\\v', // from vertical tab\r\n\t\t\t\t'\\x1A': '\\\\Z' // from ASCII 26 (SUB / Control+Z) - as represented in JS\r\n\t\t\t};\r\n\t\t\tvalue = value.replace(/[\\\\\\0\\b\\r\\n\\t\\x1A]/g, (match) => defs[match]);\r\n\t\t}\r\n\t\tvalue = `${delimChar}${(value || '').replace(new RegExp(delimChar, 'g'), `${escChar}${delimChar}`)}${delimChar}`;\r\n\t\treturn tok.modifier\r\n\t\t\t? `${tok.modifier}${value}`\r\n\t\t\t: value;\r\n\t}\r\n\r\n\t_stringifyVariable(tok) {\r\n\t\tconst { type, value } = tok;\r\n\t\t// ------------\r\n\t\tif (this.options.dialect === 'mysql') {\r\n\t\t\treturn `${type === 'system_var' ? '@@' : '@'}${value}`;\r\n\t\t}\r\n\t\treturn `${this.#parentNode?.isProperty ? '\\\\:' : ':'}${value}`;\r\n\t}\r\n\r\n\t_stringifyComment(tok, options = {}) {\r\n\t\tconst { value } = tok;\r\n\t\t// ------------\r\n\t\tif (tok.type === 'block_comment') {\r\n\t\t\tconst indent = '  '.repeat(options.startingIndentLevel || 0);\r\n\t\t\tconst lines = value.trim().split('\\n').map((line) => line.trim());\r\n\t\t\tconst formatted = [\r\n\t\t\t\t`${indent}/**`,\r\n\t\t\t\t...lines.map((line) => `${indent} * ${line}`),\r\n\t\t\t\t`${indent} */`\r\n\t\t\t];\r\n\t\t\treturn formatted.join('\\n');\r\n\t\t}\r\n\t\t// ------------\r\n\t\tconst delimChars = ['--'];\r\n\t\tif (this.options.dialect === 'mysql') {\r\n\t\t\tdelimChars.push('#');\r\n\t\t}\r\n\t\tconst delimChar = delimChars.includes(tok.delim)\r\n\t\t\t? tok.delim\r\n\t\t\t: delimChars[0];\r\n\t\treturn `${delimChar} ${value}`;\r\n\t}\r\n}\r\n\r\nconst _getUnsupportedRuleAttrs = (rule) => {\r\n\treturn Object.keys(rule).filter((k) => !supportedRuleAttrs.has(k));\r\n};\r\nconst supportedRuleAttrs = new Set([\r\n\t'dialect',\r\n\t// 1. Pretty-printing\r\n\t'autoSpacing',\r\n\t'optionalParens',\r\n\t'autoIndent',\r\n\t'autoIndentAdjust',\r\n\t// 2. Type system: token and node\r\n\t'type',\r\n\t// 2.1 Token matching\r\n\t'value',\r\n\t'delim',\r\n\t'modifier',\r\n\t// 2.2 Compound matching\r\n\t'syntax',\r\n\t'syntaxes',\r\n\t// 3. AST fields\r\n\t'as',\r\n\t'booleanfy',\r\n\t'if',\r\n\t// 4. Variadic fields\r\n\t'arity',\r\n\t'itemSeparator',\r\n\t'singletons',\r\n\t'keyed',\r\n\t// 5. Other attributes\r\n\t'requiredSpacing',\r\n\t'peek',\r\n\t'optional',\r\n\t'assert',\r\n]);\r\n\r\nconst _inferenceMatch = (inference, resultAST, activeTrailStr) => {\r\n\treturn [].concat(inference).some((criteria) => {\r\n\t\tif (_isObject(criteria)) {\r\n\t\t\treturn Object.entries(criteria).every(([key, value]) => {\r\n\t\t\t\tlet exp = true;\r\n\t\t\t\tif (key.startsWith('!')) {\r\n\t\t\t\t\tkey = key.slice(1);\r\n\t\t\t\t\texp = false;\r\n\t\t\t\t}\r\n\t\t\t\treturn (\r\n\t\t\t\t\tArray.isArray(value) ? value.includes(resultAST[key]) : resultAST[key] === value\r\n\t\t\t\t) === exp;\r\n\t\t\t});\r\n\t\t}\r\n\t\tif (typeof criteria !== 'string') throw new SyntaxError(`[${activeTrailStr}] A specifier of type string or object expected in inferenceMatch but got ${criteria === null ? 'null' : `type ${typeof criteria}`}`);\r\n\t\tlet exp = true;\r\n\t\tif (criteria.startsWith('!')) {\r\n\t\t\tcriteria = criteria.slice(1);\r\n\t\t\texp = false;\r\n\t\t}\r\n\t\treturn (![undefined, null, false].includes(resultAST[criteria])) === exp;\r\n\t});\r\n};", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class PGCycleClause extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return {\n            dialect: 'postgres',\n            syntax: [\n                { type: 'keyword', value: 'CYCLE' },\n                {\n                    assert: true,\n                    syntax: [\n                        { type: 'ColumnRef1', as: 'column_names', arity: { min: 1 }, itemSeparator, assert: true, autoIndent: 2 },\n                        { type: 'keyword', value: 'SET' },\n                        { type: 'ColumnRef1', as: 'mark_col_name' },\n                        {\n                            optional: true,\n                            syntax: [\n                                { type: 'keyword', value: 'TO' },\n                                { type: 'Expr', as: 'mark_value' },\n                                { type: 'keyword', value: 'DEFAULT' },\n                                { type: 'Expr', as: 'mark_default' },\n                            ]\n                        },\n                        { type: 'keyword', value: 'USING' },\n                        { type: 'ColumnRef1', as: 'path_col_name' },\n                    ]\n                },\n            ]\n        };\n    }\n\n    /* AST API */\n\n    breadthOrDepthFirst() { return this._get('breadth_or_depth_first'); }\n\n    columnNames() { return this._get('column_names'); }\n\n    markColName() { return this._get('mark_col_name'); }\n\n    markValue() { return this._get('mark_value'); }\n\n    markDefault() { return this._get('mark_default'); }\n\n    pathColName() { return this._get('path_col_name'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class PGSearchClause extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return {\n            dialect: 'postgres',\n            syntax: [\n                { type: 'keyword', value: 'SEARCH' },\n                {\n                    assert: true,\n                    syntax: [\n                        { type: 'keyword', as: 'breadth_or_depth_first', value: ['BREADTH', 'DEPTH'] },\n                        { type: 'keyword', value: 'FIRST' },\n                        { type: 'keyword', value: 'BY' },\n                        { type: 'ColumnRef1', as: 'column_names', arity: { min: 1 }, itemSeparator, assert: true, autoIndent: 2 },\n                        { type: 'keyword', value: 'SET' },\n                        { type: 'ColumnRef1', as: 'seq_col_name' },\n                    ]\n                }\n            ]\n        };\n    }\n\n    /* AST API */\n\n    breadthOrDepthFirst() { return this._get('breadth_or_depth_first'); }\n\n    columnNames() { return this._get('column_names'); }\n\n    seqColName() { return this._get('seq_col_name'); }\n}", "import { AbstractNode } from './AbstractNode.js';\n\nexport const DDLSchemaMixin = (Class) => class extends Class {\n\n\t#result_schema;\n\n\tresultSchema() { return this.#result_schema; }\n\n\tstatic fromJSON(inputJson, options = {}, callback = null) {\n\t\tif (inputJson instanceof AbstractNode) {\n\t\t\treturn super.fromJSON(inputJson, options, callback);\n\t\t}\n\t\tconst { result_schema, ...restJson } = inputJson;\n\n\t\tconst instance = super.fromJSON(restJson, options, callback);\n\t\tif (instance && result_schema) {\n\t\t\tif (!(result_schema instanceof AbstractNode)) {\n\t\t\t\tthrow new Error(`Invalid Schema object passed at inputJson.result_schema`);\n\t\t\t}\n\t\t\tinstance.#result_schema = result_schema;\n\t\t}\n\t\treturn instance;\n\t}\n\n\tjsonfy(options = {}, transformer = null, linkedDb = null) {\n\t\tlet resultJson = super.jsonfy(options, transformer, linkedDb);\n\t\tif (this.#result_schema) {\n\t\t\tresultJson = {\n\t\t\t\t...resultJson,\n\t\t\t\tresult_schema: this.#result_schema,\n\t\t\t};\n\t\t}\n\t\treturn resultJson;\n\t}\n}", "import { AbstractNode } from './AbstractNode.js';\n\nexport class AbstractStmt extends AbstractNode {\n    \n    get statementNode() { return this; }\n\n    /* JSON API */\n\n\t#uuid;\n\n    get uuid() {\n        if (!this.#uuid) {\n            this.#uuid = `$query${(0 | Math.random() * 9e6).toString(36)}`;\n        }\n        return this.#uuid;\n    }\n\n\tstatic fromJSON(inputJson, options = {}, callback = null) {\n\t\tif (inputJson instanceof AbstractNode) {\n\t\t\treturn super.fromJSON(inputJson, options, callback);\n\t\t}\n\t\tconst { uuid, ...restJson } = inputJson;\n\t\tconst instance = super.fromJSON(restJson, options, callback);\n\t\tif (instance) {\n\t\t\tinstance.#uuid = uuid;\n\t\t}\n\t\treturn instance;\n\t}\n\n\tjsonfy(options = {}, transformer = null, linkedDb = null) {\n\t\tlet resultJson = super.jsonfy(options, transformer, linkedDb);\n\t\tif (this.#uuid) {\n\t\t\tresultJson = {\n\t\t\t\tuuid: this.#uuid,\n\t\t\t\t...resultJson,\n\t\t\t};\n\t\t}\n\t\treturn resultJson;\n\t}\n}", "import { DDLSchemaMixin } from './DDLSchemaMixin.js';\r\nimport { AbstractStmt } from './AbstractStmt.js';\r\n\r\nexport class AbstractNonDDLStmt extends DDLSchemaMixin(AbstractStmt) {\r\n\r\n\trenderBindings(values) {\r\n\t\tif (!Array.isArray(values)) throw new Error(`Values must be an array`);\r\n\t\tconst queryBindings = [...this.queryBindings()];\r\n\t\tfor (let i = 0; i < values.length; i++) {\r\n\t\t\tconst bindings = queryBindings.filter(b => b.offset() === i+1);\r\n\t\t\tif (!bindings.length) throw new Error(`No bindings exists at offset #${i}`);\r\n\t\t\tbindings.forEach(b => b.value(values[i]));\r\n\t\t}\r\n\t}\r\n\r\n\tnormalizeBindings(dedupe = false) {\r\n\t\tconst queryBindings = [...this.queryBindings()];\r\n\t\tif (!dedupe) {\r\n\t\t\tqueryBindings.forEach((b, i) => b.offset(i+1));\r\n\t\t\treturn queryBindings;\r\n\t\t}\r\n\t\tlet redundants = new Map, $offset = 1;\r\n\t\tfor (const b of queryBindings) {\r\n\t\t\tif (b.offset() === 0 || !redundants.has(b.offset())) {\r\n\t\t\t\tconst newOffset = $offset++;\r\n\t\t\t\tredundants.set(b.offset(), newOffset);\r\n\t\t\t\tb.offset(newOffset);\r\n\t\t\t} else b.offset(redundants.get(b.offset())).withDetail('redundant', true);\r\n\t\t}\r\n\t\treturn queryBindings.filter(b => !b.getDetail('redundant'));\r\n\t}\r\n}\r\n", "import { registry } from './registry.js';\n\nexport class Transformer {\n\n    #callback;\n    get cb() { return this.#callback; }\n\n    #rands = new Map;\n    #hashes = new Map;\n\n    #parentTransformer;\n    get parentTransformer() { return this.#parentTransformer; }\n\n    #statementNode;\n    get statementNode() { return this.#statementNode; }\n\n    get statementContext() {\n        if (this.#isStatementContext) return this;\n        return this.#parentTransformer.statementContext;\n    }\n\n    get rootContext() {\n        return this.#parentTransformer?.rootContext || this;\n    }\n\n    #isStatementContext;\n    get isStatementContext() { return this.#isStatementContext; }\n\n    #artifacts = new Map([\n        ['outputSchemas', new Set],\n        ['tableSchemas', new Set],\n        ['selectorDimensions', new Map],\n        ['payloadDimensions', new Set],\n    ]);\n    get artifacts() { return this.#artifacts; }\n\n    constructor(callback, parentTransformer = null, statementNode = null) {\n        this.#callback = callback;\n        this.#parentTransformer = parentTransformer;\n        this.#statementNode = statementNode;\n        this.#isStatementContext = !parentTransformer\n            || statementNode !== parentTransformer.statementNode;\n    }\n\n    rand(type, { asSalt = false, rands = this.#rands } = {}) {\n        rands.set(type, !rands.has(type) ? 0 : rands.get(type) + 1);\n        return `${asSalt ? '~' : '$'}${type}~${rands.get(type)}`;\n    }\n\n    hash(value, type, { hashes = this.#hashes } = {}) {\n        if (!hashes.has(value)) {\n            hashes.set(value, this.rand(type));\n        }\n        return hashes.get(value);\n    }\n\n    transform(node, defaultTransform, key, options0, originatingContext = this) {\n\n        const $defaultTransform = (options1 = options0, childTransformer = originatingContext) => {\n\n            // From parentTransformer:\n            // implicitly inherit current instance for sub-transforms\n            if (typeof options1 === 'function') {\n                childTransformer = new Transformer(options1, childTransformer, this.#statementNode);\n                options1 = options0;\n            }\n\n            // If this.transform() was called from a subquery scope identified by originatingContext\n            if (originatingContext.statementNode !== this.#statementNode) {\n                // don't call handlers in this scope\n                return defaultTransform(options1, childTransformer);\n            }\n\n            return this.#callback(node, (options2 = options1) => {\n\n                // From callback:\n                // implicitly inherit current instance for sub-transforms\n                if (typeof options2 === 'function') {\n                    childTransformer = new Transformer(options2, childTransformer, this.#statementNode);\n                    options2 = options1;\n                }\n\n                return defaultTransform(options2, childTransformer);\n            }, key, options1);\n        };\n\n        if (this.#parentTransformer) {\n            // Call parentTransformer and pass originating scope\n            return this.#parentTransformer.transform(node, $defaultTransform, key, options0, originatingContext);\n        }\n\n        return $defaultTransform();\n    }\n}", "import { AbstractNonDDLStmt } from '../abstracts/AbstractNonDDLStmt.js';\nimport { Transformer } from '../Transformer.js';\nimport { registry } from '../registry.js';\n\nexport class CTE extends AbstractNonDDLStmt {\n\n    /* SYNTAX RULES */\n\n    static get _bodyTypes() {\n        return [\n            'SelectStmt',\n            'TableStmt',\n            'InsertStmt',\n            'UpsertStmt',\n            'UpdateStmt',\n            'DeleteStmt',\n            'ValuesConstructor',\n        ];\n    }\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'keyword', value: 'WITH' },\n            { type: 'keyword', as: 'recursive', value: 'RECURSIVE', booleanfy: true, optional: true },\n            { type: 'CTEItem', as: 'declarations', arity: { min: 1 }, itemSeparator, assert: true, autoIndent: 2 },\n            { type: this._bodyTypes, as: 'body', assert: true, autoSpacing: '\\n' },\n        ];\n    }\n\n    /* AST API */\n\n    recursive() { return this._get('recursive'); }\n\n    declarations() { return this._get('declarations'); }\n\n    body() { return this._get('body'); }\n\n    /* JSON API */\n\n    jsonfy(options = {}, transformer = null, linkedDb = null) {\n        if (!options.deSugar) return super.jsonfy(options, transformer, linkedDb);\n\n        let outerResultSchema;\n\n        transformer = new Transformer((node, defaultTransform, keyHint) => {\n            // Process body nodes\n            if (keyHint === 'body' && node.parentNode === this) {\n                const bodyResultJson = defaultTransform();\n\n                outerResultSchema = bodyResultJson.result_schema;\n\n                return bodyResultJson;\n            }\n\n            return defaultTransform();\n        }, transformer, this);\n\n        // Run transform\n        const resultJson = super.jsonfy(options, transformer, linkedDb);\n        return {\n            ...resultJson,\n            result_schema: outerResultSchema,\n        };\n    }\n}", "import { AbstractNonDDLStmt } from '../abstracts/AbstractNonDDLStmt.js';\nimport { Transformer } from '../Transformer.js';\nimport { registry } from '../registry.js';\n\nexport class CTEItem extends AbstractNonDDLStmt {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'CTEItemAlias', as: 'alias', assert: true },\n            { type: 'keyword', value: 'AS' },\n            {\n                optional: true,\n                dialect: 'postgres',\n                syntaxes: [\n                    [\n                        { type: 'operator', as: 'not_materialized_kw', value: 'NOT', booleanfy: true },\n                        { type: 'keyword', value: 'MATERIALIZED', assert: true },\n                    ],\n                    { type: 'keyword', as: 'materialized', value: 'MATERIALIZED', booleanfy: true },\n                ],\n            },\n            {\n                type: 'paren_block',\n                syntax: { type: ['SelectStmt', 'InsertStmt', 'UpsertStmt', 'UpdateStmt', 'DeleteStmt', 'TableStmt', 'ValuesConstructor'], as: 'expr', autoIndent: true },\n            },\n            { type: 'PGSearchClause', as: 'search_clause', optional: true },\n            { type: 'PGCycleClause', as: 'cycle_clause', optional: true },\n        ];\n    }\n\n    /* AST API */\n\n    alias() { return this._get('alias'); }\n\n    notMaterializedKW() { return this._get('not_materialized_kw'); }\n\n    materialized() { return this._get('materialized'); }\n\n    expr() { return this._get('expr'); }\n\n    searchClause() { return this._get('search_clause'); }\n\n    cycleClause() { return this._get('cycle_clause'); }\n\n    /* JSON API */\n\n    jsonfy(options = {}, transformer = null, linkedDb = null) {\n        let resultJson = super.jsonfy(options, transformer, linkedDb);\n        if (options.deSugar) {\n\n            const schemaIdent = {\n                nodeName: registry.Identifier.NODE_NAME,\n                value: resultJson.alias.value,\n                delim: resultJson.alias.delim,\n            };\n\n            let resultSchema = resultJson.expr.result_schema;\n\n            if (resultSchema instanceof registry.TableSchema) {\n                resultSchema = resultSchema.clone({ renameTo: schemaIdent });\n            } else {\n                resultSchema = registry.TableSchema.fromJSON({\n                    name: schemaIdent,\n                    entries: resultSchema?.entries().map((s) => s.jsonfy()) || [],\n                });\n            }\n\n            if (resultJson.alias.columns?.length) {\n                if (resultJson.alias.columns.length !== resultSchema.length) {\n                    throw new SyntaxError(`[${this}] Number of column aliases must match number of result columns.`);\n                }\n                resultSchema = resultSchema.clone({}, new Transformer((node, defaultTransform, key) => {\n                    if (typeof key === 'number' && node.parentNode === resultSchema) {\n                        if (node instanceof registry.ColumnSchema) {\n                            return node.jsonfy({ renameTo: resultJson.alias.columns[key] });\n                        }\n                        return {\n                            ...node.jsonfy(),\n                            nodeName: registry.ColumnSchema.NODE_NAME,\n                            name: resultJson.alias.columns[key],\n                        };\n                    }\n                    return defaultTransform();\n                }));\n            }\n\n            transformer.statementContext.artifacts.get('tableSchemas').add({ type: 'CTEItem', resultSchema });\n\n            resultJson = {\n                ...resultJson,\n                result_schema: resultSchema,\n            };\n        }\n\n        return resultJson;\n    }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\nimport { _eq } from '../../util.js';\n\nexport class Identifier extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() { return { type: 'identifier', as: '.' }; }\n\n    static get syntaxPriority() { return -1; }\n\n    /* AST API */\n\n    value() { return this._get('value'); }\n\n    /* API */\n\n    identifiesAs(ident, cs = undefined) {\n        if (ident instanceof Identifier) {\n\t\t\treturn _eq(this.value(), ident.value(), cs === undefined ? (this._has('delim') || ident._has('delim')) : cs);\n\t\t}\n        if (typeof ident === 'string') {\n            return _eq(this._get('value'), ident, cs === undefined ? this._has('delim') : cs);\n        }\n        return super.identifiesAs(ident, cs);\n    }\n}", "import { Identifier } from '../expr/ref/Identifier.js';\n\nexport class CTEItemAlias extends Identifier {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { ...[].concat(super.syntaxRules)[0] },\n            {\n                type: 'paren_block',\n                syntax: { type: 'Identifier', as: 'columns', arity: { min: 1 }, itemSeparator, assert: true },\n                if: 'value',\n                optional: true,\n                optionalParens: true,\n            }\n        ];\n    }\n\n    /* AST API */\n\n    columns() { return this._get('columns'); }\n}", "export * from './column/index.js';\nexport * from './constraint/index.js';\nexport * from './ident/index.js';\nexport * from './index/index.js';\nexport * from './schema/index.js';\nexport * from './table/index.js';\nexport { CreateTableStmt } from './CreateTableStmt.js';", "import { AbstractNode } from './AbstractNode.js';\n\nexport class AbstractNodeList extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() { return []; }\n\n    // API\n\n    get length() { return (this._get('entries') || []).length; }\n\n    [Symbol.iterator]() { return (this._get('entries') || [])[Symbol.iterator](); }\n\n    ['entries']() { return (this._get('entries') || []).slice(0); }\n\n    get(index) { return this._get('entries', index); }\n\n    set(index, value) { return this._set('entries', index, value); }\n\n    has(index) { return this._has('entries', index); }\n\n    add(...args) { return this._add('entries', ...args); }\n}", "import { AbstractNodeList } from './AbstractNodeList.js';\n\nexport class AbstractDiff extends AbstractNodeList {\n\n    /* AST API */\n}", "import { AbstractDiff } from '../../abstracts/AbstractDiff.js';\n\nexport class ColumnDiff extends AbstractDiff {}", "import { AbstractNodeList } from './AbstractNodeList.js';\nimport { AbstractNode } from './AbstractNode.js';\nimport { registry } from '../registry.js';\n\nexport class AbstractSchema extends AbstractNodeList {\n\n    /* AST API */\n\n    name() { return this._get('name'); }\n\n    /* API */\n\n    identifiesAs(value, ...args) {\n        return this.name()?.identifiesAs(\n            value instanceof AbstractSchema ? value.name() : value,\n            ...args\n        );\n    }\n\n    /* JSON API */\n\n    static fromJSON(inputJson, options = {}, callback = null) {\n        if (inputJson instanceof AbstractNode) {\n            return super.fromJSON(inputJson, options, callback);\n        }\n        const { ddl_name, ...restJson } = inputJson;\n        const node = super.fromJSON(restJson, options, callback);\n        if (ddl_name && node) {\n            const iddlNameIdent = [registry.SchemaIdent, registry.TableIdent, registry.ColumnIdent].reduce((prev, Class) => prev || Class.fromJSON(ddl_name), null);\n            node._set('ddl_name', iddlNameIdent);\n        }\n        return node;\n    }\n\n    jsonfy({ renameTo, ...options } = {}, transformer = null, linkedDb = null) {\n        let resultJson = super.jsonfy(options, transformer, linkedDb);\n        if (renameTo) {\n            if (renameTo instanceof AbstractNode) {\n                throw new Error(`options.renameTo must be a JSON value.`);\n            }\n            if (resultJson.name?.value && !resultJson.ddl_name) {\n                resultJson = { ...resultJson, ddl_name: resultJson.name };\n            }\n            return { ...resultJson, name: renameTo };\n        }\n        return resultJson;\n    }\n}", "import { AbstractSchema } from '../../abstracts/AbstractSchema.js';\nimport { registry } from '../../registry.js';\n\nexport class ColumnSchema extends AbstractSchema {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const type = [\n            'CheckConstraint',\n            'ColumnDefaultConstraint',\n            'ColumnExpressionConstraint',\n            'ColumnFKConstraint',\n            'ColumnIdentityConstraint',\n            'ColumnNullConstraint',\n            'ColumnPKConstraint',\n            'ColumnUKConstraint',\n            'MYColumnAutoIncrementModifier',\n            'MYColumnCommentModifier',\n            'MYColumnOnUpdateModifier',\n            'MYColumnVisibilityModifier',\n        ];\n        return [\n            { type: ['ColumnIdent', 'Identifier'/* to support mock names */], as: 'name' },\n            { type: 'DataType', as: 'data_type', assert: true },\n            { type, as: 'entries', arity: Infinity, singletons: true, optional: true },\n\n        ];\n    }\n\n    /* AST API */\n\n    dataType() { return this._get('data_type'); }\n\n    /* API */\n\n    defaultConstraint() {\n        for (const cons of this) {\n            if (cons instanceof registry.ColumnDefaultConstraint) return cons;\n        }\n    }\n\n    expressionConstraint() {\n        for (const cons of this) {\n            if (cons instanceof registry.ColumnExpressionConstraint) return cons;\n        }\n    }\n\n    identityConstraint() {\n        for (const cons of this) {\n            if (cons instanceof registry.ColumnIdentityConstraint) return cons;\n        }\n    }\n\n    nullConstraint() {\n        for (const cons of this) {\n            if (cons instanceof registry.ColumnNullConstraint) return cons;\n        }\n    }\n\n    pkConstraint(normalized = false) {\n        for (const cons of this) {\n            if (cons instanceof registry.ColumnPKConstraint) return cons;\n        }\n        if (normalized && this.parentNode instanceof registry.TableSchema) {\n            const pkConstraint = this.parentNode.pkConstraint(false);\n            const pkColumns = pkConstraint?.columns() || [];\n            if (pkColumns.length === 1 && pkColumns[0].identifiesAs(this.name())) {\n                const { nodeName, columns, ...cJson } = pkConstraint.jsonfy();\n                const instance = registry.ColumnPKConstraint.fromJSON(cJson);\n                this._adoptNodes(instance);\n                return instance;\n            }\n        }\n    }\n\n    fkConstraint(normalized = false) {\n        for (const cons of this) {\n            if (cons instanceof registry.ColumnFKConstraint) return cons;\n        }\n        if (normalized && this.parentNode instanceof registry.TableSchema) {\n            const { nodeName, columns, ...cJson } = this.parentNode.fkConstraints(false).find((c) => {\n                const columns = c.columns();\n                return columns.length === 1 && columns[0].identifiesAs(this.name());\n            })?.jsonfy() || {};\n            if (nodeName) {\n                const instance = registry.ColumnFKConstraint.fromJSON(cJson);\n                this._adoptNodes(instance);\n                return instance;\n            }\n        }\n    }\n\n    ukConstraint(normalized = false) {\n        for (const cons of this) {\n            if (cons instanceof registry.ColumnUKConstraint) return cons;\n        }\n        if (normalized && this.parentNode instanceof registry.TableSchema) {\n            const { nodeName, columns, ...cJson } = this.parentNode.ukConstraints(false).find((c) => {\n                const columns = c.columns();\n                return columns.length === 1 && columns[0].identifiesAs(this.name());\n            })?.jsonfy() || {};\n            if (nodeName) {\n                const instance = registry.ColumnUKConstraint.fromJSON(cJson);\n                this._adoptNodes(instance);\n                return instance;\n            }\n        }\n    }\n\n    ckConstraint(normalized = false) {\n        for (const cons of this) {\n            if (cons instanceof registry.CheckConstraint) return cons;\n        }\n        if (normalized && this.parentNode instanceof registry.TableSchema) {\n            let instance = this.parentNode.ckConstraints(false).find((c) => {\n                const columns = c.columns();\n                return columns.length === 1 && columns[0].identifiesAs(this.name());\n            });\n            if (instance = instance?.clone()) {\n                this._adoptNodes(instance);\n                return instance;\n            }\n        }\n    }\n\n    jsonfy({ normalized = false, ...options } = {}, transformer = null, linkedDb = null) {\n        let resultJson = super.jsonfy(options, transformer, linkedDb);\n        if (normalized) {\n            let tableLevelConstraints = [];\n            for (const x of ['pk', 'fk', 'uk', 'ck']) {\n                const method = `${x}Constraint`;\n                if (!this[method]()) {\n                    tableLevelConstraints.push(this[method](true)?.jsonfy());\n                }\n            }\n            if ((tableLevelConstraints = tableLevelConstraints.filter((s) => s)).length) {\n                return {\n                    ...resultJson,\n                    entries: resultJson.entries.concat(tableLevelConstraints)\n                }\n            }\n        }\n        return resultJson;\n    }\n}\n", "import { AbstractNode } from '../../../abstracts/AbstractNode.js';\n\nexport class FKMatchRule extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', value: 'MATCH' },\n            { type: 'keyword', as: 'value', value: ['FULL', 'PARTIAL', 'SIMPLE'], assert: true },\n        ];\n    }\n\n    /*. AST API */\n\n    value() { return this._get('value'); }\n}", "import { AbstractNode } from '../../../abstracts/AbstractNode.js';\n\nexport class FKDeleteRule extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', value: 'ON' },\n            { type: 'keyword', value: 'DELETE' },\n            { type: 'ReferentialAction', as: 'action', assert: true },\n        ];\n    }\n\n    /*. AST API */\n\n    action() { return this._get('action'); }\n}", "import { AbstractNode } from '../../../abstracts/AbstractNode.js';\n\nexport class FKUpdateRule extends AbstractNode {\n    \n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', value: 'ON' },\n            { type: 'keyword', value: 'UPDATE' },\n            { type: 'ReferentialAction', as: 'action', assert: true },\n        ];\n    }\n\n    /*. AST API */\n\n    action() { return this._get('action'); }\n}", "import { AbstractNodeList } from '../../../abstracts/AbstractNodeList.js';\n\nexport class PGIndexParameters extends AbstractNodeList {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: ['PGIndexParamInclude', 'PGIndexParamUsing', 'PGIndexParamWith'], as: 'entries', arity: Infinity, singletons: true },\n        ];\n    }\n}", "import { AbstractNodeList } from '../../../abstracts/AbstractNodeList.js';\n\nexport class PGIndexParamInclude extends AbstractNodeList {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'keyword', value: 'INCLUDE' },\n            {\n                type: 'paren_block',\n                syntax: { type: 'ColumnRef2', as: 'entries', arity: { min: 1 }, itemSeparator },\n            }\n        ];\n    }\n}", "import { AbstractNode } from '../../../abstracts/AbstractNode.js';\n\nexport class PGIndexParamUsing extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', value: 'USING' },\n            { type: 'keyword', value: 'INDEX' },\n            { type: 'keyword', value: 'TABLESPACE' },\n            { type: 'identifier', as: '.' },\n        ];\n    }\n}", "import { AbstractNodeList } from '../../../abstracts/AbstractNodeList.js';\n\nexport class PGIndexParamWith extends AbstractNodeList {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'keyword', value: 'WITH' },\n            {\n                type: 'paren_block',\n                syntax: { type: 'ConfigAssignmentExprAlt2', as: 'entries', arity: { min: 1 }, itemSeparator },\n            }\n        ];\n    }\n}", "import { AbstractSchema } from '../../abstracts/AbstractSchema.js';\nimport { registry } from '../../registry.js';\n\nexport class ConstraintSchema extends AbstractSchema {\n\n    /* SYNTAX RULES */\n\n    static buildSyntaxRules(rules) {\n        return [\n            {\n                optional: true,\n                syntax: [\n                    { type: 'keyword', value: 'CONSTRAINT' },\n                    { type: 'Identifier', as: 'name', assert: true },\n                ]\n            },\n            ...\n            rules,\n            {\n                optional: true,\n                dialect: 'postgres',\n                syntaxes: [\n                    [\n                        { type: 'operator', as: 'pg_deferrable', value: 'NOT' },\n                        { type: 'keyword', value: 'DEFERRABLE' },\n                    ],\n                    { type: 'keyword', as: 'pg_deferrable', value: 'DEFERRABLE' },\n                ],\n            },\n            {\n                optional: true,\n                dialect: 'postgres',\n                syntax: [\n                    { type: 'keyword', value: 'INITIALLY' },\n                    { type: 'keyword', as: 'pg_deferred', value: ['DEFERRED', 'IMMEDIATE'] },\n                ],\n            },\n        ];\n    }\n\n    static get syntaxRules() {\n        return {\n            type: [\n                // Table-only constraints must match first\n                'TableFKConstraint',\n                'TablePKConstraint',\n                'TableUKConstraint',\n                // then, non-table-only constraints\n                'CheckConstraint',\n                'ColumnDefaultConstraint',\n                'ColumnExpressionConstraint',\n                'ColumnFKConstraint',\n                'ColumnIdentityConstraint',\n                'ColumnNullConstraint',\n                'ColumnPKConstraint',\n                'ColumnUKConstraint',\n            ],\n        };\n    }\n\n    get isColumnLevel() { return this.parentNode instanceof registry.ColumnSchema; }\n\n    /* AST API */\n\n    pgDeferrable() { return this._get('pg_deferrable'); }\n\n    pgDeferred() { return this._get('pg_deferred'); }\n}", "import { ConstraintSchema } from '../ConstraintSchema.js';\n\nexport class PGTableEXConstraintItem extends ConstraintSchema {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            {\n                syntaxes: [\n                    { type: 'ColumnRef2', as: 'expr' },\n                    { type: 'ParenExpr', as: 'expr' },\n                ],\n            },\n            {\n                optional: true,\n                syntax: [\n                    { type: 'operator', value: 'COLLATE' },\n                    { type: 'string_literal', as: 'collation', assert: true },\n                ],\n            },\n            {\n                optional: true,\n                syntax: [\n                    { type: 'Identifier', as: 'opclass' },\n                    {\n                        optional: true,\n                        type: 'paren_block',\n                        syntax: { type: 'ConfigAssignmentExpr', as: 'opclass_parameters', arity: { min: 1 }, itemSeparator, assert: true },\n                    },\n                ],\n            },\n            { type: 'keyword', value: ['ASC', 'DESC'], as: 'dir', optional: true },\n            {\n                optional: true,\n                syntax: [\n                    { type: 'keyword', value: 'NULLS' },\n                    { type: 'keyword', as: 'nulls_spec', value: ['FIRST', 'LAST'], assert: true },\n                ]\n            },\n            { type: 'keyword', value: 'WITH' },\n            { type: 'operator', as: 'operator' },\n        ];\n    }\n\n    /* AST API */\n\n    expr() { return this._get('expr'); }\n\n    collation() { return this._get('collation'); }\n\n    opclass() { return this._get('opclass'); }\n\n    opclassParameters() { return this._get('opclass_parameters'); }\n\n    dir() { return this._get('dir'); }\n\n    nullsSpec() { return this._get('nulls_spec'); }\n\n    operator() { return this._get('operator'); }\n}", "import { AbstractNode } from '../../../abstracts/AbstractNode.js';\n\nexport class ReferentialAction extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return {\n            syntaxes: [\n                { type: 'keyword', as: 'value', value: ['NO ACTION', 'RESTRICT', 'CASCADE'] },\n                [\n                    { type: 'keyword', as: 'value', value: ['SET NULL', 'SET DEFAULT'] },\n                    {\n                        optional: true,\n                        dialect: 'postgres',\n                        type: 'paren_block',\n                        syntax: { type: 'Identifier', as: 'columns', arity: { min: 1 }, itemSeparator },\n                    }\n                ],\n            ],\n        };\n    }\n\n    /*. AST API */\n\n    value() { return this._get('value'); }\n\n    columns() { return this._get('columns'); }\n}", "import { registry } from '../../registry.js';\nimport { ConstraintSchema } from './ConstraintSchema.js';\n\nexport class CheckConstraint extends ConstraintSchema {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return this.buildSyntaxRules([\n            { type: 'keyword', value: 'CHECK' },\n            {\n                type: 'paren_block',\n                syntax: { type: 'Expr', as: 'expr', assert: true },\n                assert: true,\n            },\n            { type: 'keyword', as: 'no_inherit_kw', value: 'NO INHERIT', optional: true }\n        ]);\n    }\n\n    /* AST API */\n\n    expr() { return this._get('expr'); }\n\n    noInheritKW() { return this._get('no_inherit_kw'); }\n\n    /* API */\n\n    columns() {\n        const columns = [];\n        this.expr()?.walkTree((node) => {\n            if (node instanceof registry.ColumnRef1) {\n                columns.push(registry.ColumnRef2.fromJSON({ value: node.value() }))\n            } else return node;\n        });\n        return columns;\n    }\n}", "import { ConstraintSchema } from './ConstraintSchema.js';\n\nexport class ColumnDefaultConstraint extends ConstraintSchema {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return this.buildSyntaxRules([\n            { type: 'keyword', value: 'DEFAULT' },\n            { type: 'Expr', as: 'expr', assert: true, dialect: 'postgres' },\n            { type: ['NumberLiteral', 'StringLiteral', 'NullLiteral', 'BoolLiteral', 'CallExpr', 'RowConstructor'], as: 'expr', assert: true, dialect: 'mysql' },\n        ]);\n    }\n\n    /* AST API */\n\n    expr() { return this._get('expr'); }\n}", "import { ConstraintSchema } from './ConstraintSchema.js';\n\nexport class ColumnExpressionConstraint extends ConstraintSchema {\n\n\t/* SYNTAX RULES */\n\n\tstatic get syntaxRules() {\n\t\treturn this.buildSyntaxRules([\n\t\t\t{\n\t\t\t\tdialect: 'postgres',\n\t\t\t\tsyntax: [\n\t\t\t\t\t{ type: 'keyword', value: 'GENERATED' },\n\t\t\t\t\t{ type: 'keyword', value: 'ALWAYS' },\n\t\t\t\t\t{ type: 'keyword', value: 'AS' },\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: 'paren_block',\n\t\t\t\t\t\tsyntax: { type: 'Expr', as: 'expr', assert: true },\n\t\t\t\t\t},\n\t\t\t\t\t{ type: 'keyword', as: 'stored', value: 'STORED', assert: true },\n\t\t\t\t],\n\t\t\t},\n\t\t\t{\n\t\t\t\tdialect: 'mysql',\n\t\t\t\tsyntax: [\n\t\t\t\t\t{\n\t\t\t\t\t\toptional: true,\n\t\t\t\t\t\tsyntax: [\n\t\t\t\t\t\t\t{ type: 'keyword', as: 'my_generated_kw', value: 'GENERATED', booleanfy: true },\n\t\t\t\t\t\t\t{ type: 'keyword', value: 'ALWAYS' },\n\t\t\t\t\t\t],\n\t\t\t\t\t},\n\t\t\t\t\t{ type: 'keyword', value: 'AS' },\n\t\t\t\t\t{\n\t\t\t\t\t\ttype: 'paren_block',\n\t\t\t\t\t\tsyntax: { type: 'Expr', as: 'expr', assert: true },\n\t\t\t\t\t},\n\t\t\t\t\t{ type: 'keyword', as: 'stored', value: ['STORED', 'VIRTUAL'], optional: true },\n\t\t\t\t],\n\t\t\t},\n\t\t]);\n\t}\n\n\t/* AST API */\n\n\tmyGeneratedKW() { return this._get('my_generated_kw'); }\n\n\texpr() { return this._get('expr'); }\n\n\tstored() { return this._get('stored'); }\n}", "import { ConstraintSchema } from './ConstraintSchema.js';\nimport { registry } from '../../registry.js';\n\nconst {\n    ColumnSchema,\n    ColumnRef2,\n} = registry;\n\nexport class ColumnFKConstraint extends ConstraintSchema {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return this.buildSyntaxRules([\n            { type: 'keyword', value: 'REFERENCES' },\n            { type: 'TableRef2', as: 'target_table', assert: true },\n            {\n                dialect: 'postgres',\n                optional: true,\n                type: 'paren_block',\n                syntax: { type: 'Identifier', as: 'target_columns', arity: 1, itemSeparator, singletons: 'BY_KEY', assert: true },\n            },\n            {\n                dialect: 'mysql',\n                type: 'paren_block',\n                syntax: { type: 'Identifier', as: 'target_columns', arity: 1, itemSeparator, singletons: 'BY_KEY', assert: true },\n            },\n            { type: ['FKMatchRule', 'FKDeleteRule', 'FKUpdateRule'], as: 'referential_rules', arity: Infinity, singletons: true },\n\n        ]);\n    }\n\n    /* AST API */\n\n    targetTable() { return this._get('target_table'); }\n\n    targetColumns() { return this._get('target_columns'); }\n\n    referentialRules() { return this._get('referential_rules'); }\n\n    /* API */\n\n    columns() {\n        return this.parentNode instanceof ColumnSchema\n            ? [ColumnRef2.fromJSON({ value: this.parentNode.name().value() })]\n            : [];\n    }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\nimport { ColumnIdentityConstraint } from './ColumnIdentityConstraint.js';\n\nexport class MYColumnAutoIncrementModifier extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            dialect: 'mysql',\n            syntax: { type: 'keyword', as: '.', value: 'AUTO_INCREMENT' },\n        };\n    }\n\n    /* JSON RULES */\n\n    jsonfy(options = {}, transformer = null, linkedDb = null) {\n        return (options.toDialect || this.options.dialect) === 'postgres'\n            ? (new ColumnIdentityConstraint).jsonfy(options, transformer, linkedDb)\n            : super.jsonfy(options, transformer, linkedDb);\n    }\n}", "import { MYColumnAutoIncrementModifier } from './MYColumnAutoIncrementModifier.js';\nimport { ConstraintSchema } from './ConstraintSchema.js';\n\nexport class ColumnIdentityConstraint extends ConstraintSchema {\n\n\t/* SYNTAX RULES */\n\n\tstatic get syntaxRules() {\n\t\treturn this.buildSyntaxRules([\n\t\t\t{ type: 'keyword', value: 'GENERATED' },\n\t\t\t{\n\t\t\t\tsyntaxes: [\n\t\t\t\t\t{ type: 'keyword', as: 'always_kw', value: 'ALWAYS', booleanfy: true },\n\t\t\t\t\t{\n\t\t\t\t\t\tsyntax: [\n\t\t\t\t\t\t\t{ type: 'keyword', as: 'by_default_kw', value: 'BY', booleanfy: true },\n\t\t\t\t\t\t\t{ type: 'keyword', value: 'DEFAULT', assert: true },\n\t\t\t\t\t\t],\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t},\n\t\t\t{\n\t\t\t\toptional: true,\n\t\t\t\tsyntax: [\n\t\t\t\t\t{ type: 'keyword', as: 'as_identity_kw', value: 'AS', booleanfy: true },\n\t\t\t\t\t{ type: 'keyword', value: 'IDENTITY', assert: true },\n\t\t\t\t]\n\t\t\t}\n\t\t]);\n\t}\n\n\t/* AST API */\n\n\talwaysKW() { return this._get('always_kw'); }\n\n\tbyDefaultKW() { return this._get('by_default_kw'); }\n\n\tasIdentityKW() { return this._get('as_identity_kw'); }\n\n\t/* JSON API */\n\n\tjsonfy(options = {}, transformer = null, linkedDb = null) {\n\t\treturn (options.toDialect || this.options.dialect) === 'mysql'\n\t\t\t? (new MYColumnAutoIncrementModifier).jsonfy(options, transformer, linkedDb)\n\t\t\t: super.jsonfy(options, transformer, linkedDb);\n\t}\n}", "import { ConstraintSchema } from './ConstraintSchema.js';\n\nexport class ColumnNullConstraint extends ConstraintSchema {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return this.buildSyntaxRules([\n            {\n                syntaxes: [\n                    [\n                        { type: 'operator', as: '.', value: 'NOT' },\n                        { type: 'null_literal', value: 'NULL' },\n                    ],\n                    { type: 'null_literal', as: '.', value: 'NULL' },\n                ]\n            }\n        ]);\n    }\n\n    /* AST API */\n\n    value() { return this._get('value'); }\n}", "import { ConstraintSchema } from './ConstraintSchema.js';\nimport { registry } from '../../registry.js';\n\nexport class ColumnPKConstraint extends ConstraintSchema {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return this.buildSyntaxRules([\n            { type: 'keyword', value: 'PRIMARY' },\n            { type: 'keyword', value: 'KEY', assert: true },\n            { type: 'PGIndexParameters', as: 'pg_index_parameters', optional: true, dialect: 'postgres' },\n        ]);\n    }\n\n    /* AST API */\n\n    primaryKW() { return this._get('primary_kw'); }\n\n    pgIndexParameters() { return this._get('pg_index_parameters'); }\n\n    /* API */\n\n    columns() {\n        return this.parentNode instanceof registry.ColumnSchema\n            ? [registry.ColumnRef2.fromJSON({ value: this.parentNode.name().value() })]\n            : [];\n    }\n}", "import { ConstraintSchema } from './ConstraintSchema.js';\nimport { registry } from '../../registry.js';\n\nexport class ColumnUKConstraint extends ConstraintSchema {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return this.buildSyntaxRules([\n            { type: 'keyword', value: 'UNIQUE' },\n            { type: 'keyword', as: 'my_key_kw', value: ['KEY', 'INDEX'], optional: true, dialect: 'mysql' },\n            {\n                optional: true,\n                dialect: 'postgres',\n                syntaxes: [\n                    [\n                        { type: 'keyword', value: 'NULLS' },\n                        { type: 'operator', as: 'pg_nulls_distinct', value: 'NOT' },\n                        { type: 'keyword', value: 'DISTINCT', assert: true },\n                    ],\n                    [\n                        { type: 'keyword', value: 'NULLS' },\n                        { type: 'keyword', as: 'pg_nulls_distinct', value: 'DISTINCT', assert: true },\n                    ],\n                ]\n            },\n            { type: 'PGIndexParameters', as: 'pg_index_parameters', optional: true, dialect: 'postgres' }\n        ]);\n    }\n\n    /* AST API */\n\n    myKeyKW() { return this._get('my_key_kw'); }\n\n    pgNullsDistinct() { return this._get('pg_nulls_distinct'); }\n\n    pgIndexParameters() { return this._get('pg_index_parameters'); }\n\n    /* API */\n\n    columns() {\n        const {\n            ColumnSchema,\n            ColumnRef2,\n        } = registry;\n        return this.parentNode instanceof ColumnSchema\n            ? [ColumnRef2.fromJSON({ value: this.parentNode.name().value() })]\n            : [];\n    }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class MYColumnCommentModifier extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            dialect: 'mysql',\n            syntax: [\n                { type: 'keyword', value: 'COMMENT' },\n                { type: 'string_literal', as: '.' },\n            ],\n        };\n    }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class MYColumnOnUpdateModifier extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            dialect: 'mysql',\n            syntax: [\n                { type: 'keyword', value: 'ON' },\n                { type: 'keyword', value: 'UPDATE' },\n                { type: 'keyword', as: '.' },\n            ],\n        };\n    }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class MYColumnVisibilityModifier extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            dialect: 'mysql',\n            syntaxes: [\n                { type: 'keyword', as: '.', value: 'VISIBLE' },\n                { type: 'keyword', as: '.', value: 'INVISIBLE' },\n            ],\n        };\n    }\n}", "import { ConstraintSchema } from './ConstraintSchema.js';\n\nexport class PGTableEXConstraint extends ConstraintSchema {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return {\n            dialect: 'postgres',\n            syntax: this.buildSyntaxRules([\n                { type: 'keyword', value: 'EXCLUDE' },\n                {\n                    optional: true,\n                    syntax: [\n                        { type: 'keyword', value: 'USING' },\n                        { type: 'keyword', as: 'index_method', assert: true },\n                    ],\n                },\n                {\n                    type: 'paren_block',\n                    syntax: { type: 'PGTableEXConstraintItem', as: 'entries', arity: { min: 1 }, itemSeparator, assert: true },\n                    assert: true,\n                },\n                { type: 'PGIndexParameters', as: 'pg_index_parameters', optional: true },\n                {\n                    optional: true,\n                    syntax: [\n                        { type: 'keyword', value: 'WHERE' },\n                        {\n                            type: 'paren_block',\n                            syntax: { type: 'Expr', as: 'where_predicate', assert: true },\n                            assert: true,\n                        }\n                    ],\n                }\n            ])\n        };\n    }\n\n    /* AST API */\n\n    indexMethod() { return this._get('index_method'); }\n\n    entries() { return this._get('entries'); }\n\n    pgIndexParameters() { return this._get('pg_index_parameters'); }\n\n    wherePredicate() { return this._get('where_predicate'); }\n}", "import { ConstraintSchema } from './ConstraintSchema.js';\n\nexport class TableFKConstraint extends ConstraintSchema {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return this.buildSyntaxRules([\n            { type: 'keyword', value: 'FOREIGN' },\n            { type: 'keyword', value: 'KEY', assert: true },\n            {\n                type: 'paren_block',\n                syntax: { type: 'ColumnRef2', as: 'columns', arity: { min: 1 }, itemSeparator, assert: true, singletons: 'BY_KEY' },\n            },\n            { type: 'keyword', value: 'REFERENCES' },\n            { type: 'TableRef2', as: 'target_table', assert: true },\n            {\n                dialect: 'postgres',\n                optional: true,\n                type: 'paren_block',\n                syntax: { type: 'Identifier', as: 'target_columns', arity: { min: 1 }, itemSeparator, singletons: 'BY_KEY', assert: true },\n            },\n            {\n                dialect: 'mysql',\n                type: 'paren_block',\n                syntax: { type: 'Identifier', as: 'target_columns', arity: { min: 1 }, itemSeparator, singletons: 'BY_KEY', assert: true },\n            },\n            { type: ['FKMatchRule', 'FKDeleteRule', 'FKUpdateRule'], as: 'referential_rules', arity: Infinity, assert: true, singletons: true },\n        ]);\n    }\n\n    /* AST API */\n\n    columns() { return this._get('columns'); }\n\n    targetTable() { return this._get('target_table'); }\n\n    targetColumns() { return this._get('target_columns'); }\n\n    referentialRules() { return this._get('referential_rules'); }\n}\n", "import { ConstraintSchema } from './ConstraintSchema.js';\n\nexport class TablePKConstraint extends ConstraintSchema {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return this.buildSyntaxRules([\n            { type: 'keyword', value: 'PRIMARY' },\n            { type: 'keyword', value: 'KEY', assert: true },\n            {\n                type: 'paren_block',\n                syntax: { type: 'ColumnRef2', as: 'columns', arity: { min: 1 }, itemSeparator, singletons: 'BY_KEY', assert: true },\n                assert: true,\n            },\n            { type: 'PGIndexParameters', as: 'pg_index_parameters', optional: true, dialect: 'postgres' },\n        ]);\n    }\n\n    /* AST API */\n\n    columns() { return this._get('columns'); }\n    \n    pgIndexParameters() { return this._get('pg_index_parameters'); }\n}", "import { ConstraintSchema } from './ConstraintSchema.js';\n\nexport class TableUKConstraint extends ConstraintSchema {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return this.buildSyntaxRules([\n            { type: 'keyword', value: 'UNIQUE' },\n            { type: 'keyword', as: 'my_key_kw', value: ['KEY', 'INDEX'], optional: true, dialect: 'mysql' },\n            {\n                optional: true,\n                dialect: 'postgres',\n                syntaxes: [\n                    [\n                        { type: 'keyword', value: 'NULLS' },\n                        { type: 'operator', as: 'pg_nulls_distinct', value: 'NOT' },\n                        { type: 'keyword', value: 'DISTINCT', assert: true },\n                    ],\n                    [\n                        { type: 'keyword', value: 'NULLS' },\n                        { type: 'keyword', as: 'pg_nulls_distinct', value: 'DISTINCT', assert: true },\n                    ],\n                ]\n            },\n            {\n                type: 'paren_block',\n                syntax: { type: 'ColumnRef2', as: 'columns', arity: { min: 1 }, itemSeparator, singletons: 'BY_KEY', assert: true },\n                assert: true,\n            },\n            { type: 'PGIndexParameters', as: 'pg_index_parameters', optional: true, dialect: 'postgres' }\n        ]);\n    }\n\n    /* AST API */\n\n    myKeyKW() { return this._get('my_key_kw'); }\n\n    pgNullsDistinct() { return this._get('pg_nulls_distinct'); }\n\n    columns() { return this._get('columns'); }\n\n    pgIndexParameters() { return this._get('pg_index_parameters'); }\n}", "export const PathMixin = (Class) => class extends Class {\n\n\t/* SYNTAX RULES */\n\n\tstatic get _qualifierType() { return 'Identifier'; }\n\n\tstatic buildSyntaxRules(baseRule = null) {\n\t\treturn [\n\t\t\t{\n\t\t\t\toptional: true,\n\t\t\t\tsyntax: [\n\t\t\t\t\t{ type: this._qualifierType, as: 'qualifier' },\n\t\t\t\t\t{ type: 'punctuation', value: '.', autoSpacing: false },\n\t\t\t\t],\n\t\t\t},\n\t\t\tbaseRule ||\n\t\t\t{ ...[].concat(super.syntaxRules)[0], autoSpacing: false },\n\t\t];\n\t}\n\n\tstatic get syntaxRules() { return this.buildSyntaxRules(); }\n\n\tstatic get syntaxPriority() { return -1; }\n\n\t/* AST API */\n\n\tqualifier() { return this._get('qualifier'); }\n\n\t/* API */\n\n\tidentifiesAs(ident, cs = undefined) {\n\t\tconst result = super.identifiesAs(ident, cs);\n\t\tif (result && this.qualifier() && ident.qualifier?.()) {\n\t\t\treturn this.qualifier().identifiesAs(ident.qualifier(), cs);\n\t\t}\n\t\treturn result;\n\t}\n\n\tstatic async _parseFromRules(tokenStream, syntaxRules, { left = undefined, minPrecedence = 0, trail, ...options }, resultAST = {}) {\n\t\tif (left) return super._parseFromRules(tokenStream, syntaxRules, { left, minPrecedence, trail, ...options }, resultAST);\n\t\tconst qualifierTokens = [];\n\n\t\twhile (true) {\n\t\t\tif (await tokenStream.match(1, 'punctuation', '.')) {\n\t\t\t\tqualifierTokens.push(await tokenStream.eat());\n\t\t\t} else if (await tokenStream.match(1, 'version_spec') && await tokenStream.match(2, 'punctuation', '.')) {\n\t\t\t\tqualifierTokens.push(await tokenStream.eat());\n\t\t\t\tqualifierTokens.push(await tokenStream.eat());\n\t\t\t} else break;\n\t\t\t// Determine whether to eat the punctuation ahead of another loop\n\t\t\tif (await tokenStream.match(2, 'punctuation', '.') || (await tokenStream.match(2, 'version_spec') && await tokenStream.match(3, 'punctuation', '.'))) {\n\t\t\t\tqualifierTokens.push(await tokenStream.eat());\n\t\t\t}\n\t\t}\n\n\t\tconst qualifierExposure = 'qualifier';\n\t\tif (qualifierTokens.length) {\n\t\t\tconst qualifierTypes = [].concat(this._qualifierType);\n\t\t\tconst qualifierStream = await this.toStream(qualifierTokens, options);\n\t\t\tconst qualifierOptions = { minPrecedence, trail: trail.concat(this.NODE_NAME, `<${qualifierExposure}>`), ...options };\n\t\t\tleft = await this._parseFromTypes(qualifierStream, qualifierTypes, qualifierOptions);\n\t\t} else {\n\t\t\tleft = false; // Explicitly set to false to prevent super.parse() trying parsing the qualifier rule\n\t\t}\n\n\t\treturn await super._parseFromRules(tokenStream, syntaxRules, { left, minPrecedence, trail, ...options }, resultAST);\n\t}\n}", "export * from './abstraction/index.js';\nexport * from './call/index.js';\nexport * from './case/index.js';\nexport * from './etc/index.js';\nexport * from './literals/index.js';\nexport * from './op/index.js';\nexport * from './ref/index.js';\nexport * from './abstraction/index.js';\nexport * from './var/index.js';\nexport { LQBackRefAbstraction } from './ref/LQBackRefAbstraction.js';\nexport { RowConstructor } from './abstraction/RowConstructor.js';\nexport { ScalarSubquery } from './abstraction/ScalarSubquery.js';\nexport { TypedRowConstructor } from './abstraction/TypedRowConstructor.js';\nexport { Expr } from './Expr.js';                                                              \n", "import { registry } from '../registry.js';\n\nexport const TypeSysMixin = (Class) => class extends Class {\n\n\tdataType() { return registry.DataType.fromJSON({ value: 'TEXT' }); };\n}", "import { TypeSysMixin } from '../abstracts/TypeSysMixin.js';\nimport { AbstractNode } from '../abstracts/AbstractNode.js';\n\nexport class AbstractClassicExpr extends TypeSysMixin(AbstractNode) {}", "import { AbstractClassicExpr } from '../AbstractClassicExpr.js';\n\nexport class ParenExpr extends AbstractClassicExpr {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            type: 'paren_block',\n            syntax: { type: 'Expr', as: 'expr' },\n            autoIndent: true,\n        };\n    }\n\n    static get syntaxPriority() { return -1; }\n\n    /* AST API */\n\n    expr() { return this._get('expr'); }\n\n    exprUnwrapped() {\n        const expr = this._get('expr');\n        if (expr instanceof ParenExpr) {\n            return expr.exprUnwrapped();\n        }\n        return expr;\n    }\n\n    /* TYPESYS */\n\n    dataType() { return this.expr()?.dataType(); }\n}", "import { TypeSysMixin } from '../../abstracts/TypeSysMixin.js';\nimport { DDLSchemaMixin } from '../../abstracts/DDLSchemaMixin.js';\nimport { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\nimport { registry } from '../../registry.js';\n\nexport class RowConstructor extends DDLSchemaMixin(TypeSysMixin(AbstractNodeList)) {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return {\n            syntax: [\n                {\n                    type: 'paren_block',\n                    syntax: {\n                        type: [\n                            'DerivedQuery'/* to support dimensional RHS in DML, and should appear before Expr.RowConstructor */,\n                            'ValuesTableLiteral',\n                            'Expr',\n                        ], as: 'entries', arity: Infinity, itemSeparator, autoIndent: 10\n                    },\n                },\n            ],\n        };\n    }\n\n    static get syntaxPriority() { return 49; } // Below all () shapes like LQBackRefAbstraction but above DerivedQuery \n\n    /* API */\n\n    exprUnwrapped() {\n        if (this._get('entries')?.length === 1 && this._get('entries')[0] instanceof RowConstructor) {\n            return this._get('entries')[0].exprUnwrapped();\n        }\n        return this;\n    }\n\n    /* TYPESYS */\n\n    dataType() { return registry.DataType.fromJSON({ value: 'SET' }); }\n\n    /* JSON API */\n\n    jsonfy(options = {}, transformer = null, linkedDb = null) {\n        let resultJson = super.jsonfy(options, transformer, linkedDb);\n        if (Number(options.deSugar || 0) > 5 || options.forceDeSugar) {\n\n            const entriesNode = this.entries() || [];\n            const entriesJson = resultJson.entries || [];\n\n            const resultSchemas = entriesJson.map((entry, i) => {\n                const ident = { nodeName: registry.Identifier.NODE_NAME, value: i };\n                if (entry.result_schema instanceof registry.ColumnSchema) {\n                    return entry.result_schema.clone({ renameTo: ident });\n                }\n                return registry.ColumnSchema.fromJSON({\n                    name: ident,\n                    data_type: entriesNode[i].dataType().jsonfy(),\n                });\n            });\n\n            resultJson = {\n                ...resultJson,\n                result_schema: registry.JSONSchema.fromJSON({ entries: resultSchemas }, { assert: true }),\n            };\n        }\n\n        return resultJson;\n    }\n}", "import { DDLSchemaMixin } from '../../abstracts/DDLSchemaMixin.js';\nimport { ParenExpr } from '../../expr/abstraction/ParenExpr.js';\n\nexport class DerivedQuery extends DDLSchemaMixin(ParenExpr) {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            type: 'paren_block',\n            syntax: { type: ['SelectStmt', 'TableStmt', 'CTE'], as: 'expr', autoIndent: true },\n            \n        };\n    }\n\n    static get syntaxPriority() { return -1; }\n\n    /* TYPESYS API */\n\n    dataType() { return this.expr()?.dataType(); }\n\n    /* JSON API */\n\n    jsonfy(options = {}, transformer = null, linkedDb = null) {\n        let resultJson = super.jsonfy(options, transformer, linkedDb);\n        if (options.deSugar) {\n            const resultSchema = resultJson.expr?.result_schema;\n            resultJson = {\n                ...resultJson,\n                result_schema: resultSchema,\n            };\n        }\n        return resultJson;\n    }\n}", "import { DerivedQuery } from '../../dql/TA/DerivedQuery.js';\nimport { registry } from '../../registry.js';\n\nexport class ScalarSubquery extends DerivedQuery {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            type: 'paren_block',\n            syntax: { type: ['SelectStmt', 'CTE'], as: 'expr' },\n            autoIndent: true,\n        };\n    }\n\n    static get syntaxPriority() { return 48; } // Below RowConstructor\n\n    /* TYPESYS API */\n\n    dataType() {\n        if (this.resultSchema()) {\n            return this.resultSchema().dataType();\n        }\n        return registry.DataType.fromJSON({ value: 'TEXT' });\n    }\n\n    /* JSON API */\n\n    jsonfy(options = {}, transformer = null, linkedDb = null) {\n        let resultJson = super.jsonfy(options, transformer, linkedDb);\n        if (options.deSugar) {\n            let resultSchema = resultJson.expr?.result_schema;\n            if (resultSchema?.length !== 1) {\n                throw new Error(`Scalar subqueries must return a scalar value.`);\n            }\n            resultSchema = resultSchema.entries()[0];\n            resultJson = {\n                ...resultJson,\n                result_schema: resultSchema,\n            };\n        }\n        return resultJson;\n    }\n}", "import { RowConstructor } from './RowConstructor.js';\n\nexport class TypedRowConstructor extends RowConstructor {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', value: 'ROW' },\n            ...[].concat(super.syntaxRules)\n        ];\n    }\n\n    static get syntaxPriority() { return 52; } // Above CallExpr\n}", "import { AbstractNode } from '../../../abstracts/AbstractNode.js';\n\nexport class PGFilterClause extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            dialect: 'postgres',\n            syntax: [\n                { type: 'keyword', value: 'FILTER' },\n                {\n                    type: 'paren_block',\n                    syntax: { type: 'WhereClause', as: 'where_clause' },\n                    assert: true,\n                    autoIndent: true\n                }\n            ]\n        };\n    }\n\n    static get syntaxPriority() { return -1; }\n\n    /* AST API */\n\n    whereClause() { return this._get('where_clause'); }\n}", "import { AbstractNode } from '../../../abstracts/AbstractNode.js';\n\nexport class PGWithinGroupClause extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            dialect: 'postgres',\n            syntax: [\n                { type: 'keyword', value: 'WITHIN' },\n                { type: 'keyword', value: 'GROUP' },\n                {\n                    type: 'paren_block',\n                    syntax: { type: 'OrderByClause', as: 'order_by_clause' },\n                    assert: true,\n                    autoIndent: true,\n                },\n            ]\n        };\n    }\n\n    static get syntaxPriority() { return -1; }\n\n    /* AST API */\n\n    orderByClause() { return this._get('order_by_clause'); }\n}", "import { DDLSchemaMixin } from '../../abstracts/DDLSchemaMixin.js';\nimport { AbstractClassicExpr } from '../AbstractClassicExpr.js';\n\nexport class CallExpr extends DDLSchemaMixin(AbstractClassicExpr) {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n\n        return {\n            syntaxes: [\n                {\n                    peek: [0, 'keyword', [\n                        'NOW', 'CURRENT_DATE', 'CURRENT_TIME', 'CURRENT_TIMESTAMP',\n                        'IF', 'NULLIF', 'IFNULL',\n                        'COALESCE', 'GREATEST', 'LEAST', 'CONCAT',\n                        'CONCAT_WS', 'FORMAT',\n                        'MD5', 'SHA1',\n                        'TO_JSON', 'TO_JSONB', 'JSON_TYPEOF', 'JSONB_TYPEOF',\n                        'JSON_BUILD_ARRAY', 'JSONB_BUILD_ARRAY', 'JSON_BUILD_OBJECT', 'JSONB_BUILD_OBJECT',\n                        'JSON_POPULATE_RECORD', 'JSONB_POPULATE_RECORD', 'JSON_PATH_QUERY', 'JSON_PATH_EXISTS',\n                        'JSON_ARRAY', 'JSON_OBJECT', 'JSON_EXTRACT', 'JSON_UNQUOTE',\n                        'JSON_SET', 'JSON_INSERT', 'JSON_REPLACE', 'JSON_REMOVE',\n                        'JSON_SEARCH', 'JSON_CONTAINS', 'JSON_CONTAINS_PATH',\n                        'JSON_KEYS', 'JSON_ARRAY_APPEND', 'JSON_ARRAY_INSERT',\n                        'JSON_DEPTH', 'JSON_LENGTH', 'JSON_MERGE_PRESERVE',\n                        'JSON_MERGE_PATCH', 'JSON_PRETTY', 'JSON_STORAGE_FREE',\n                        'ST_ASTEXT', 'ST_ASGEOJSON', 'ST_GEOMFROMTEXT',\n                        'ST_WITHIN', 'ST_CONTAINS', 'ST_INTERSECTS', 'ST_DISTANCE', 'ST_BUFFER',\n                        'MAKE_DATE', 'MAKE_TIME', 'MAKE_TIMESTAMP', 'ARRAY',\n                        'CURDATE', 'CURTIME', 'SYSDATE', 'STR_TO_DATE', 'MAKEDATE', 'MAKETIME',\n                    ]],\n                    syntaxes: [\n\n                        // ---------- \uD83E\uDDEE Cross-dialect scalar functions (fixed arity)\n\n                        [\n                            { type: 'keyword', as: 'name', value: ['CURRENT_DATE', 'CURRENT_TIME', 'CURRENT_TIMESTAMP'] },\n                            {\n                                type: 'paren_block',\n                                syntax: { type: 'Expr', as: 'arguments', arity: 0, itemSeparator, assert: true },\n                                optional: true,\n                                optionalParens: true,\n                                autoSpacing: false\n                            }\n                        ],\n                        [\n                            { type: 'keyword', as: 'name', value: ['NOW'] },\n                            {\n                                type: 'paren_block',\n                                syntax: { type: 'Expr', as: 'arguments', arity: 0, itemSeparator, assert: true },\n                                optional: true,\n                                autoSpacing: false\n                            }\n                        ],\n                        [\n                            { type: 'keyword', as: 'name', value: ['IF', 'NULLIF', 'IFNULL'] },\n                            {\n                                type: 'paren_block',\n                                syntax: { type: 'Expr', as: 'arguments', arity: { min: 2, max: 3 }, itemSeparator, assert: true },\n                                autoSpacing: false\n                            }\n                        ],\n\n                        // ---------- \uD83D\uDCD0 Cross-dialect scalar functions (variadic)\n\n                        [\n                            { type: 'keyword', as: 'name', value: ['COALESCE', 'GREATEST', 'LEAST', 'CONCAT'] },\n                            {\n                                type: 'paren_block',\n                                syntax: { type: 'Expr', as: 'arguments', arity: { min: 1 }, itemSeparator, assert: true },\n                                autoSpacing: false\n                            }\n                        ],\n                        [\n                            { type: 'keyword', as: 'name', value: ['CONCAT_WS', 'FORMAT'] },\n                            {\n                                type: 'paren_block',\n                                syntax: { type: 'Expr', as: 'arguments', arity: { min: 2 }, itemSeparator, assert: true },\n                                autoSpacing: false\n                            }\n                        ],\n                        [\n                            { type: 'keyword', as: 'name', value: ['MD5', 'SHA1'] },\n                            {\n                                type: 'paren_block',\n                                syntax: { type: 'Expr', as: 'arguments', arity: 1, itemSeparator, assert: true },\n                                autoSpacing: false\n                            }\n                        ],\n\n                        // ---------- \uD83D\uDFE9 Spatial functions (PostgreSQL & MySQL)\n\n                        [\n                            { type: 'keyword', as: 'name', value: ['ST_ASTEXT', 'ST_ASGEOJSON', 'ST_GEOMFROMTEXT'] },\n                            {\n                                type: 'paren_block',\n                                syntax: { type: 'Expr', as: 'arguments', arity: 1, itemSeparator, assert: true },\n                                autoSpacing: false\n                            }\n                        ],\n                        [\n                            { type: 'keyword', as: 'name', value: ['ST_WITHIN', 'ST_CONTAINS', 'ST_INTERSECTS', 'ST_DISTANCE', 'ST_BUFFER'] },\n                            {\n                                type: 'paren_block',\n                                syntax: { type: 'Expr', as: 'arguments', arity: 2, itemSeparator, assert: true },\n                                autoSpacing: false\n                            }\n                        ],\n\n                        // ---------- \uD83D\uDFEB PostgreSQL JSON functions\n\n                        {\n                            dialect: 'postgres',\n                            syntax: [\n                                { type: 'keyword', as: 'name', value: ['TO_JSON', 'TO_JSONB', 'JSON_TYPEOF', 'JSONB_TYPEOF'] },\n                                {\n                                    type: 'paren_block',\n                                    syntax: { type: 'Expr', as: 'arguments', arity: 1, itemSeparator, assert: true },\n                                    autoSpacing: false\n                                }\n                            ]\n                        },\n                        {\n                            dialect: 'postgres',\n                            syntax: [\n                                { type: 'keyword', as: 'name', value: ['JSON_BUILD_ARRAY', 'JSONB_BUILD_ARRAY', 'JSON_BUILD_OBJECT', 'JSONB_BUILD_OBJECT'] },\n                                {\n                                    type: 'paren_block',\n                                    syntax: { type: 'Expr', as: 'arguments', arity: { min: 0 }, itemSeparator, assert: true },\n                                    autoSpacing: false\n                                }\n                            ]\n                        },\n                        {\n                            dialect: 'postgres',\n                            syntax: [\n                                { type: 'keyword', as: 'name', value: ['JSON_POPULATE_RECORD', 'JSONB_POPULATE_RECORD', 'JSON_PATH_QUERY', 'JSON_PATH_EXISTS'] },\n                                {\n                                    type: 'paren_block',\n                                    syntax: { type: 'Expr', as: 'arguments', arity: 2, itemSeparator, assert: true },\n                                    autoSpacing: false\n                                }\n                            ]\n                        },\n                        {\n                            dialect: 'postgres',\n                            syntax: [\n                                { type: 'keyword', as: 'name', value: ['ARRAY'] },\n                                {\n                                    type: 'paren_block',\n                                    syntax: { type: 'SelectStmt', as: 'arguments', arity: 1, itemSeparator, assert: true },\n                                    autoIndent: true,\n                                    autoSpacing: true\n                                }\n                            ]\n                        },\n\n                        // ---------- \uD83D\uDFEB PostgreSQL Date functions\n\n                        {\n                            dialect: 'postgres',\n                            syntax: [\n                                { type: 'keyword', as: 'name', value: ['MAKE_DATE', 'MAKE_TIME', 'MAKE_TIMESTAMP'] },\n                                {\n                                    type: 'paren_block',\n                                    syntax: { type: 'Expr', as: 'arguments', arity: Infinity, itemSeparator, assert: true },\n                                    autoSpacing: false\n                                }\n                            ]\n                        },\n\n                        // ---------- \uD83D\uDFE7 MySQL JSON functions\n\n                        {\n                            dialect: 'mysql',\n                            syntax: [\n                                {\n                                    type: 'keyword', as: 'name', value: [\n                                        'JSON_ARRAY', 'JSON_OBJECT', 'JSON_EXTRACT', 'JSON_UNQUOTE',\n                                        'JSON_SET', 'JSON_INSERT', 'JSON_REPLACE', 'JSON_REMOVE',\n                                        'JSON_SEARCH', 'JSON_CONTAINS', 'JSON_CONTAINS_PATH',\n                                        'JSON_KEYS', 'JSON_ARRAY_APPEND', 'JSON_ARRAY_INSERT',\n                                        'JSON_DEPTH', 'JSON_LENGTH', 'JSON_MERGE_PRESERVE',\n                                        'JSON_MERGE_PATCH', 'JSON_PRETTY', 'JSON_STORAGE_FREE'\n                                    ]\n                                },\n                                {\n                                    type: 'paren_block',\n                                    syntax: { type: 'Expr', as: 'arguments', arity: { min: 1 }, itemSeparator, assert: true },\n                                    autoSpacing: false\n                                }\n                            ]\n                        },\n\n                        // ---------- \uD83D\uDFE7 MySQL Date functions\n\n                        {\n                            dialect: 'mysql',\n                            syntax: [\n                                { type: 'keyword', as: 'name', value: ['CURDATE', 'CURTIME', 'SYSDATE'] },\n                                {\n                                    type: 'paren_block',\n                                    syntax: { type: 'Expr', as: 'arguments', arity: 0, itemSeparator, optional: true, assert: true },\n                                    autoSpacing: false\n                                }\n                            ]\n                        },\n                        {\n                            dialect: 'mysql',\n                            syntax: [\n                                { type: 'keyword', as: 'name', value: 'STR_TO_DATE' },\n                                {\n                                    type: 'paren_block',\n                                    syntax: { type: 'Expr', as: 'arguments', arity: 2, itemSeparator, assert: true },\n                                    autoSpacing: false\n                                }\n                            ]\n                        },\n                        {\n                            dialect: 'mysql',\n                            syntax: [\n                                { type: 'keyword', as: 'name', value: ['MAKEDATE', 'MAKETIME'] },\n                                {\n                                    type: 'paren_block',\n                                    syntax: { type: 'Expr', as: 'arguments', arity: 2, itemSeparator, assert: true },\n                                    autoSpacing: false\n                                }\n                            ]\n                        }\n                    ]\n                },\n\n                // ---------- \uD83E\uDDE0 Fallback: general call syntax\n\n                [\n                    { type: 'keyword', as: 'name' },\n                    {\n                        type: 'paren_block',\n                        syntax: { type: 'Expr', as: 'arguments', arity: Infinity, itemSeparator },\n                        autoSpacing: false\n                    }\n                ],\n                [\n                    { type: 'identifier', as: 'name' },\n                    {\n                        type: 'paren_block',\n                        syntax: { type: 'Expr', as: 'arguments', arity: Infinity, itemSeparator },\n                        autoSpacing: false\n                    }\n                ]\n            ]\n        };\n    }\n\n    static get syntaxPriority() { return 51; }\n\n    /* AST API */\n\n    name() { return this._get('name'); }\n\n    arguments() { return this._get('arguments'); }\n}\n", "import { CallExpr } from './CallExpr.js';\n\nexport class AggrCallExpr extends CallExpr {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n\n        // Optional modifiers and clauses\n        const optional_distinct_modifier = { type: 'keyword', as: 'distinct', value: 'DISTINCT', booleanfy: true, optional: true };\n        const optional_separator_arg = {\n            optional: true,\n            syntax: [\n                { type: 'keyword', value: 'SEPARATOR' },\n                { type: 'Expr', as: 'separator', assert: true }\n            ]\n        };\n        const optional_order_by_clause = { type: 'OrderByClause', as: 'order_by_clause', optional: true };\n        const optional_filter_clause_postgres = { type: 'PGFilterClause', as: 'pg_filter_clause', optional: true, dialect: 'postgres' };\n        const optional_within_group_clause_postgres = { type: 'PGWithinGroupClause', as: 'pg_within_group_clause', optional: true, dialect: 'postgres' };\n        const optional_null_handling_directive = {\n            optional: true,\n            syntax: [\n                { type: 'keyword', as: 'null_handling', value: ['IGNORE', 'RESPECT'] },\n                { type: 'keyword', value: 'NULLS', assert: true }\n            ]\n        };\n        const optional_over_clause = {\n            optional: true,\n            syntax: [\n                { type: 'keyword', value: 'OVER' },\n                { type: ['WindowRef', 'WindowSpec'], as: 'over_clause', assert: true }\n            ]\n        };\n\n        // The syntax compositions\n        return {\n            peek: [0, 'keyword', [\n                'COUNT', 'SUM', 'AVG', 'MIN', 'MAX',\n                'ARRAY_AGG', 'STRING_AGG', 'GROUP_CONCAT',\n                'REGR_SLOPE', 'COVAR_POP', 'COVAR_SAMP', 'CORR',\n                'PERCENTILE_CONT', 'PERCENTILE_DISC', 'MODE',\n                'RANK', 'DENSE_RANK', 'ROW_NUMBER',\n                'EVERY', 'BOOL_AND', 'BOOL_OR',\n                'BIT_AND', 'BIT_OR', 'BIT_XOR',\n                'JSON_AGG', 'JSON_ARRAYAGG', 'JSON_OBJECT_AGG', 'JSONB_OBJECT_AGG', 'JSON_OBJECTAGG',\n                'STDDEV_POP', 'STDDEV_SAMP', 'VAR_POP', 'VAR_SAMP', 'VARIANCE', 'STD',\n                'XMLAGG', 'LEAD', 'LAG', 'NTILE', 'FIRST_VALUE', 'LAST_VALUE'\n            ]],\n            syntaxes: [\n\n                // ---------- \uD83D\uDD22 Basic aggregates\n\n                [ // COUNT(), COUNT(*)\n                    { type: 'keyword', as: 'name', value: 'COUNT' },\n                    {\n                        type: 'paren_block',\n                        syntax: [\n                            { dialect: 'postgres', type: 'ColumnRef0', as: 'arguments', arity: 1, assert: false/* note: to give syntax2 a chance */, itemSeparator },\n                            { dialect: 'mysql', type: 'ColumnRef0', as: 'arguments', arity: Infinity, assert: false/* note: to give syntax2 a chance */, itemSeparator, optional: true }\n                        ],\n                        autoSpacing: false,\n                    },\n                    { ...optional_filter_clause_postgres },\n                    { ...optional_over_clause },\n                ],\n                [ // COUNT|SUM|AVG|MIN|MAX([DISTINCT] expr) [FILTER (...)] [OVER (...)]\n                    { type: 'keyword', as: 'name', value: ['COUNT', 'SUM', 'AVG', 'MIN', 'MAX'] },\n                    {\n                        type: 'paren_block',\n                        syntax: [\n                            { ...optional_distinct_modifier },\n                            { type: 'Expr', as: 'arguments', arity: 1, itemSeparator, assert: true }\n                        ],\n                        autoSpacing: false,\n                    },\n                    { ...optional_filter_clause_postgres },\n                    { ...optional_over_clause },\n                ],\n\n                // ---------- \uD83E\uDDF5 List / string aggregates\n\n                {\n                    dialect: 'postgres',\n                    syntax: [ // ARRAY_AGG()\n                        { type: 'keyword', as: 'name', value: 'ARRAY_AGG' },\n                        {\n                            type: 'paren_block',\n                            syntax: [\n                                { ...optional_distinct_modifier },\n                                { type: 'Expr', as: 'arguments', arity: { min: 1 }, itemSeparator, assert: true },\n                                { ...optional_order_by_clause },\n                            ],\n                            autoSpacing: false,\n                        },\n                        { ...optional_filter_clause_postgres },\n                        { ...optional_over_clause },\n                    ]\n                },\n                {\n                    dialect: 'postgres',\n                    syntax: [ // STRING_AGG()\n                        { type: 'keyword', as: 'name', value: 'STRING_AGG' },\n                        {\n                            type: 'paren_block',\n                            syntax: [\n                                { ...optional_distinct_modifier },\n                                { type: 'Expr', as: 'arguments', arity: 2, itemSeparator, assert: true },\n                                { ...optional_order_by_clause },\n                                { ...optional_separator_arg },\n                            ],\n                            autoSpacing: false,\n                        },\n                        { ...optional_filter_clause_postgres },\n                        { ...optional_over_clause },\n                    ]\n                },\n                {\n                    dialect: 'mysql',\n                    syntax: [ // GROUP_CONCAT()\n                        { type: 'keyword', as: 'name', value: 'GROUP_CONCAT' },\n                        {\n                            type: 'paren_block',\n                            syntax: [\n                                { ...optional_distinct_modifier },\n                                { type: 'Expr', as: 'arguments', arity: { min: 1 }, itemSeparator, assert: true },\n                                { ...optional_order_by_clause },\n                                { ...optional_separator_arg },\n                            ],\n                            autoSpacing: false,\n                        },\n                        { ...optional_over_clause },\n                    ]\n                },\n\n                // ---------- \uD83D\uDCC8 Statistical aggregates\n\n                {\n                    dialect: 'postgres',\n                    syntax: [ // REGR_SLOPE() [FILTER (...)] [OVER (...)]\n                        { type: 'keyword', as: 'name', value: 'REGR_SLOPE' },\n                        {\n                            type: 'paren_block',\n                            syntax: { type: 'Expr', as: 'arguments', arity: 2, itemSeparator, assert: true },\n                            autoSpacing: false,\n                        },\n                        { ...optional_filter_clause_postgres },\n                        { ...optional_over_clause },\n                    ]\n                },\n                [ // COVAR_POP|COVAR_SAMP|CORR() [FILTER (...)] [OVER (...)]\n                    { type: 'keyword', as: 'name', value: ['COVAR_POP', 'COVAR_SAMP', 'CORR'] },\n                    {\n                        type: 'paren_block',\n                        syntax: { type: 'Expr', as: 'arguments', arity: 2, itemSeparator, assert: true },\n                        autoSpacing: false,\n                    },\n                    { ...optional_filter_clause_postgres },\n                    { ...optional_over_clause },\n                ],\n\n                // ---------- \uD83D\uDCD0 Ordered-set aggregates (PostgreSQL only)\n\n                {\n                    dialect: 'postgres',\n                    syntax: [ // PERCENTILE_CONT|PERCENTILE_DISC(expr) [FILTER (...)] [WITHIN GROUP (...)]\n                        { type: 'keyword', as: 'name', value: ['PERCENTILE_CONT', 'PERCENTILE_DISC'] },\n                        {\n                            type: 'paren_block',\n                            syntax: { type: 'Expr', as: 'arguments', arity: 1, itemSeparator, assert: true },\n                            autoSpacing: false,\n                        },\n                        { ...optional_filter_clause_postgres },\n                        { ...optional_within_group_clause_postgres, optional: false/* OVERRIDE for \"required\" */ },\n                    ]\n                },\n                {\n                    dialect: 'postgres',\n                    syntax: [ // MODE() [FILTER (...)] [WITHIN GROUP (...)]\n                        { type: 'keyword', as: 'name', value: 'MODE' },\n                        {\n                            type: 'paren_block',\n                            syntax: { type: 'Expr', as: 'arguments', arity: 0, itemSeparator, assert: true },\n                            autoSpacing: false,\n                        },\n                        { ...optional_filter_clause_postgres },\n                        { ...optional_within_group_clause_postgres, optional: false/* OVERRIDE for \"required\" */ },\n                    ]\n                },\n                {\n                    dialect: 'postgres',\n                    syntax: [ // RANK|DENSE_RANK() [FILTER (...)] [OVER (...)]\n                        { type: 'keyword', as: 'name', value: ['RANK', 'DENSE_RANK'] },\n                        {\n                            type: 'paren_block',\n                            syntax: { type: 'Expr', as: 'arguments', arity: 0, itemSeparator, assert: true },\n                            autoSpacing: false,\n                        },\n                        { ...optional_filter_clause_postgres },\n                        { ...optional_over_clause, optional: false },\n                    ]\n                },\n                [ // ROW_NUMBER() [OVER (...)]\n                    { type: 'keyword', as: 'name', value: 'ROW_NUMBER' },\n                    {\n                        type: 'paren_block',\n                        syntax: { type: 'Expr', as: 'arguments', arity: 0, itemSeparator, assert: true },\n                        autoSpacing: false,\n                    },\n                    { ...optional_over_clause, optional: false },\n                ],\n\n                // ---------- \uD83E\uDDE0 Boolean aggregates\n\n                {\n                    dialect: 'postgres',\n                    syntax: [ // EVERY|BOOL_AND|BOOL_OR([DISTINCT] expr) [FILTER (...)] [OVER (...)]\n                        { type: 'keyword', as: 'name', value: ['EVERY', 'BOOL_AND', 'BOOL_OR'] },\n                        {\n                            type: 'paren_block',\n                            syntax: [\n                                { ...optional_distinct_modifier },\n                                { type: 'Expr', as: 'arguments', arity: 1, itemSeparator, assert: true }\n                            ],\n                            autoSpacing: false,\n                        },\n                        { ...optional_filter_clause_postgres },\n                        { ...optional_over_clause },\n                    ]\n                },\n\n                // ---------- \uD83D\uDCE6 JSON aggregates\n\n                {\n                    dialect: 'postgres',\n                    syntax: [ // JSON_AGG([DISTINCT] expr) [FILTER (...)] [OVER (...)]\n                        { type: 'keyword', as: 'name', value: 'JSON_AGG' },\n                        {\n                            type: 'paren_block',\n                            syntax: [\n                                { ...optional_distinct_modifier },\n                                { type: 'Expr', as: 'arguments', arity: { min: 1 }, itemSeparator, assert: true }\n                            ],\n                            autoSpacing: false,\n                        },\n                        { ...optional_filter_clause_postgres },\n                        { ...optional_over_clause },\n                    ]\n                },\n                {\n                    dialect: 'mysql',\n                    syntax: [ // JSON_ARRAYAGG([DISTINCT] expr) [OVER (...)]\n                        { type: 'keyword', as: 'name', value: 'JSON_ARRAYAGG' },\n                        {\n                            type: 'paren_block',\n                            syntax: [\n                                { ...optional_distinct_modifier },\n                                { type: 'Expr', as: 'arguments', arity: { min: 1 }, itemSeparator, assert: true }\n                            ],\n                            autoSpacing: false,\n                        },\n                        { ...optional_over_clause },\n                    ]\n                },\n\n                // ---------- \uD83D\uDCE6 Others 1\n\n                {\n                    dialect: 'mysql',\n                    syntax: [ // BIT_XOR (MySQL only)\n                        { type: 'keyword', as: 'name', value: 'BIT_XOR' },\n                        {\n                            type: 'paren_block',\n                            syntax: [\n                                { ...optional_distinct_modifier },\n                                { type: 'Expr', as: 'arguments', arity: 1, itemSeparator, assert: true }\n                            ],\n                            autoSpacing: false,\n                        },\n                        { ...optional_over_clause },\n                    ]\n                },\n                [ // BIT_AND, BIT_OR (PostgreSQL + MySQL)\n                    { type: 'keyword', as: 'name', value: ['BIT_AND', 'BIT_OR'] },\n                    {\n                        type: 'paren_block',\n                        syntax: [\n                            { ...optional_distinct_modifier },\n                            { type: 'Expr', as: 'arguments', arity: 1, itemSeparator, assert: true }\n                        ],\n                        autoSpacing: false,\n                    },\n                    { ...optional_filter_clause_postgres },\n                    { ...optional_over_clause },\n                ],\n\n                // ---------- \uD83D\uDCE6 Others 2\n\n                {\n                    dialect: 'postgres',\n                    syntax: [\n                        { type: 'keyword', as: 'name', value: ['JSON_OBJECT_AGG', 'JSONB_OBJECT_AGG'] },\n                        {\n                            type: 'paren_block',\n                            syntax: [\n                                { ...optional_distinct_modifier },\n                                { type: 'Expr', as: 'arguments', arity: 2, itemSeparator, assert: true } // key, value\n                            ],\n                            autoSpacing: false,\n                        },\n                        { ...optional_filter_clause_postgres },\n                        { ...optional_over_clause },\n                    ]\n                },\n                {\n                    dialect: 'mysql',\n                    syntax: [\n                        { type: 'keyword', as: 'name', value: 'JSON_OBJECTAGG' },\n                        {\n                            type: 'paren_block',\n                            syntax: [\n                                { ...optional_distinct_modifier },\n                                { type: 'Expr', as: 'arguments', arity: 2, itemSeparator, assert: true } // key, value\n                            ],\n                            autoSpacing: false,\n                        },\n                        { ...optional_over_clause },\n                    ]\n                },\n\n                // ---------- \uD83D\uDCE6 Others 3\n\n                [\n                    { type: 'keyword', as: 'name', value: ['STDDEV_POP', 'STDDEV_SAMP', 'VAR_POP', 'VAR_SAMP', 'VARIANCE', 'STD'] },\n                    {\n                        type: 'paren_block',\n                        syntax: [\n                            { ...optional_distinct_modifier },\n                            { type: 'Expr', as: 'arguments', arity: 1, itemSeparator, assert: true }\n                        ],\n                        autoSpacing: false,\n                    },\n                    { ...optional_filter_clause_postgres },\n                    { ...optional_over_clause },\n                ],\n\n                // ---------- \uD83D\uDCE6 Others 4\n\n                {\n                    dialect: 'postgres',\n                    syntax: [\n                        { type: 'keyword', as: 'name', value: 'XMLAGG' },\n                        {\n                            type: 'paren_block',\n                            syntax: [\n                                { type: 'Expr', as: 'arguments', arity: 1, itemSeparator, assert: true },\n                                { ...optional_order_by_clause }\n                            ],\n                            autoSpacing: false,\n                        },\n                        { ...optional_filter_clause_postgres },\n                        { ...optional_over_clause },\n                    ]\n                },\n\n                // ---------- \uD83D\uDCE6 Others 5\n\n                [\n                    { type: 'keyword', as: 'name', value: ['LEAD', 'LAG'] },\n                    {\n                        type: 'paren_block',\n                        syntax: { type: 'Expr', as: 'arguments', arity: { max: 3 }, itemSeparator, optional: true, assert: true },\n                        autoSpacing: false,\n                    },\n                    { ...optional_null_handling_directive },\n                    { ...optional_over_clause },\n                ],\n                [\n                    { type: 'keyword', as: 'name', value: ['NTILE', 'FIRST_VALUE', 'LAST_VALUE'] },\n                    {\n                        type: 'paren_block',\n                        syntax: { type: 'Expr', as: 'arguments', arity: 1, itemSeparator, assert: true },\n                        autoSpacing: false,\n                    },\n                    { ...optional_over_clause, optional: false },\n                ],\n            ]\n        };\n    }\n\n    /* AST API */\n\n    distinct() { return this._get('distinct'); }\n\n    orderByClause() { return this._get('order_by_clause'); }\n\n    separator() { return this._get('separator'); }\n\n    overClause() { return this._get('over_clause'); }\n\n    // -- Postgres\n\n    pgFilterClause() { return this._get('pg_filter_clause'); }\n\n    pgWithinGroupClause() { return this._get('pg_within_group_clause'); }\n}", "import { TypeSysMixin } from '../../abstracts/TypeSysMixin.js';\nimport { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\n\nexport class CaseExpr extends TypeSysMixin(AbstractNodeList) {\n\n    /* DEFS */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', value: 'CASE' },\n            { type: 'Expr', as: 'subject', optional: true },\n            { type: 'CaseBranch', as: 'entries', arity: { min: 1 }, assert: true, autoIndent: 2 },\n            {\n                optional: true,\n                syntax: [\n                    { type: 'keyword', value: 'ELSE' },\n                    { type: 'Expr', as: 'alternate', autoIndent: true },\n                ],\n                autoSpacing: '\\n',\n            },\n            { type: 'keyword', value: 'END', autoSpacing: '\\n' },\n        ];\n    }\n\n    /* AST API */\n\n    subject() { return this._get('subject'); }\n    \n    branches() { return this.entries(); }\n\n    alternate() { return this._get('alternate'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class CaseBranch extends AbstractNode {\n\n    /* DEFS */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', value: 'WHEN' },\n            { type: 'Expr', as: 'condition' },\n            { type: 'keyword', value: 'THEN' },\n            { type: 'Expr', as: 'consequent' }\n        ];\n    }\n\n    static get syntaxPriority() { return -1; }\n\n    /* AST API */\n\n    condition() { return this._get('condition'); }\n\n    consequent() { return this._get('consequent'); }\n}", "import { AbstractClassicExpr } from '../AbstractClassicExpr.js';\n\nexport class CastExpr extends AbstractClassicExpr {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', value: 'CAST' },\n            {\n                type: 'paren_block',\n                syntax: [\n                    { type: 'Expr', as: 'expr' },\n                    { type: 'keyword', value: 'AS' },\n                    { type: 'DataType', as: 'data_type', assert: true },\n                ],\n                assert: true,\n                autoSpacing: false,\n            }\n        ];\n    }\n\n    /* AST API */\n\n    expr() { return this._get('expr'); }\n\n    dataType() { return this._get('data_type'); }\n}", "import { AbstractClassicExpr } from '../AbstractClassicExpr.js';\nimport { operators } from '../../toktypes.js';\nimport { registry } from '../../registry.js';\n\nexport class BinaryExpr extends AbstractClassicExpr {\n\n    /* DEFS */\n\n    static get syntaxRules() {\n        return [\n            { type: 'Expr', as: 'left', peek: [1, 'operator', ['NOT', undefined/* IMPORTANT */]] },\n            { type: 'operator', as: 'negation', value: 'NOT', booleanfy: true, optional: true },\n            { type: 'operator', as: 'operator' },\n            { type: 'Expr', as: 'right' },\n        ];\n    }\n\n    static get syntaxPriority() { return 0; }\n\n    /* AST API */\n\n    left() { return this._get('left'); }\n\n    negation() { return this._get('negation'); }\n\n    operator() { return this._get('operator'); }\n\n    right() { return this._get('right'); }\n\n    /* TYPESYS API */\n\n    dataType() {\n        const operator = this.operator();\n        if (!operator) return this.left()?.dataType();\n\n        const toDialect = this.options.dialect;\n        const operatorMap = new Map(operators.common.concat(operators[toDialect]));\n        const resultType = operatorMap.get(operator)?.resultType;\n        if (!resultType) return;\n\n        if (resultType === ':right') {\n            return this.right()?.dataType();\n        }\n        if (resultType === ':left') {\n            return this.left()?.dataType();\n        }\n        return registry.DataType.fromJSON({ value: resultType.toUpperCase() });\n    }\n}", "import { BinaryExpr } from '../op/BinaryExpr.js';\n\nexport class ExtractExpr extends BinaryExpr {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', value: 'EXTRACT' },\n            {\n                type: 'paren_block',\n                syntax: [\n                    { type: 'Expr', as: 'left' },\n                    { type: 'keyword', value: 'FROM' },\n                    { type: 'Expr', as: 'right', assert: true },\n                ],\n                autoSpacing: false\n            }\n        ];\n    }\n    \n    /* AST API */\n\n    left() { return this._get('left'); }\n\n    right() { return this._get('right'); }\n}", "import { registry } from '../../registry.js';\nimport { AbstractClassicExpr } from '../AbstractClassicExpr.js';\n\nexport class PredicateExpr extends AbstractClassicExpr {\n\n    /* DEFS */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', as: 'predicate', value: ['EXISTS'] },\n            { type: 'ScalarSubquery', as: 'expr' },\n        ];\n    }\n\n    /* AST API */\n\n    predicate() { return this._get('predicate'); }\n\n    expr() { return this._get('expr'); }\n\n    /* TYPESYS API */\n\n    dataType() { return registry.DataType.fromJSON({ value: 'BOOLEAN' }); }\n}\n", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class QuantitativeExpr extends AbstractNode {\n\n    /* DEFS */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', as: 'quantifier', value: ['ALL', 'ANY', 'SOME'] },\n            { type: ['DerivedQuery', 'RowConstructor', 'TypedRowConstructor'], as: 'expr' },\n        ];\n    }\n\n    /* AST API */\n\n    quantifier() { return this._get('quantifier'); }\n\n    expr() { return this._get('expr'); }\n}\n", "import { AbstractClassicExpr } from '../AbstractClassicExpr.js';\n\nexport class AbstractLiteral extends AbstractClassicExpr {\n\n    /* SYNTAX RULES */\n\n    static get syntaxPriority() { return 49; }\n    \n    /* AST API */\n\n    value() { return this._get('value'); }\n}", "import { AbstractLiteral } from './AbstractLiteral.js';\nimport { registry } from '../../registry.js';\n\nexport class BitLiteral extends AbstractLiteral {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() { return { type: 'bit_literal', as: '.' }; }\n\n    /* TYPESYS API */\n\n    dataType() { return registry.DataType.fromJSON({ value: 'BINARY' }); }\n}", "import { AbstractLiteral } from './AbstractLiteral.js';\nimport { registry } from '../../registry.js';\n\nexport class BoolLiteral extends AbstractLiteral {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() { return { type: 'bool_literal', as: '.' }; }\n\n    /* TYPESYS API */\n\n    dataType() { return registry.DataType.fromJSON({ value: 'BOOLEAN' }); }\n}", "import { AbstractLiteral } from './AbstractLiteral.js';\n\nexport class DefaultLiteral extends AbstractLiteral {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() { return { type: 'keyword', as: '.', value: 'DEFAULT' }; }\n}", "import { AbstractLiteral } from './AbstractLiteral.js';\nimport { registry } from '../../registry.js';\n\nexport class HexLiteral extends AbstractLiteral {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() { return { type: 'hex_literal', as: '.' }; }\n\n    /* TYPESYS API */\n\n    dataType() { return registry.DataType.fromJSON({ value: 'BINARY' }); }\n}", "import { AbstractLiteral } from './AbstractLiteral.js';\n\nexport class NullLiteral extends AbstractLiteral {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() { return { type: 'null_literal', as: '.' }; }\n}", "import { AbstractLiteral } from './AbstractLiteral.js';\nimport { registry } from '../../registry.js';\n\nexport class NumberLiteral extends AbstractLiteral {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() { return { type: 'number_literal', as: '.' }; }\n\n    /* TYPESYS API */\n\n    dataType() { return registry.DataType.fromJSON({ value: 'INT' }); }\n}", "import { AbstractLiteral } from './AbstractLiteral.js';\nimport { registry } from '../../registry.js';\n\nexport class StringLiteral extends AbstractLiteral {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() { return { type: 'string_literal', as: '.' }; }\n    \n    /* AST API */\n\n    qualifier() { return this._get('qualifier'); }\n\n    /* TYPESYS API */\n\n    dataType() { return registry.DataType.fromJSON({ value: 'TEXT' }); }\n}", "import { AbstractClassicExpr } from '../AbstractClassicExpr.js';\nimport { registry } from '../../registry.js';\n\nexport class TypedLiteral extends AbstractClassicExpr {\n\n\t/* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'data_type', as: 'data_type' },\n            { type: 'string_literal', as: 'value' },\n        ];\n    }\n\n    static get syntaxPriority() { return 50; }\n\n    /* AST API */\n\n    dataType() { return registry.DataType.fromJSON({ value: this._get('data_type') }); }\n\n    value() { return this._get('value'); }\n}", "import { TypedLiteral } from './TypedLiteral.js';\n\nexport class TypedDateLiteral extends TypedLiteral {\n\n\t/* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'data_type', as: 'data_type', value: 'DATE' },\n            { type: 'string_literal', as: 'value' },\n        ];\n    }\n}", "import { TypedLiteral } from './TypedLiteral.js';\n\nexport class TypedIntervalLiteral extends TypedLiteral {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'data_type', as: 'data_type', value: 'INTERVAL' },\n            {\n                syntaxes: [\n                    { type: 'string_literal', as: 'value' },\n                    { type: 'number_literal', as: 'value', dialect: 'mysql' },\n                ]\n            },\n            {\n                optional: true,\n                syntax: [\n                    { type: 'keyword', as: 'unit', value: ['YEAR', 'MONTH', 'DAY', 'HOUR', 'MINUTE', 'SECOND'] },\n                    {\n                        optional: true,\n                        syntax: [\n                            { type: 'keyword', value: 'TO' },\n                            { type: 'keyword', as: 'to_unit', value: ['YEAR', 'MONTH', 'DAY', 'HOUR', 'MINUTE', 'SECOND'], assert: true },\n                        ]\n                    },\n                ]\n            },\n        ];\n    }\n\n    /* AST API */\n\n    unit() { return this._get('unit'); }\n\n    toUnit() { return this._get('to_unit'); }\n}", "import { TypedLiteral } from './TypedLiteral.js';\n\nexport class TypedTimeLiteral extends TypedLiteral {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'data_type', as: 'data_type', value: 'TIME' },\n            { type: 'string_literal', as: 'value' },\n            {\n                optional: true,\n                dialect: 'postgres',\n                syntax: [\n                    { type: 'keyword', as: 'pg_with_tz', value: ['WITH', 'WITHOUT'] },\n                    { type: 'keyword', value: 'TIME ZONE', assert: true },\n                ]\n            },\n        ];\n    }\n\n    /* AST API */\n\n    pgWithTZ() { return this._get('pg_with_tz'); }\n}", "import { TypedLiteral } from './TypedLiteral.js';\n\nexport class TypedTimestampLiteral extends TypedLiteral {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'data_type', as: 'data_type', value: 'TIMESTAMP', dialect: 'postgres' },\n            { type: 'data_type', as: 'data_type', value: ['TIMESTAMP', 'DATETIME'], dialect: 'mysql' },\n            { type: 'string_literal', as: 'value' },\n            {\n                optional: true,\n                dialect: 'postgres',\n                syntax: [\n                    { type: 'keyword', as: 'pg_with_tz', value: ['WITH', 'WITHOUT'] },\n                    { type: 'keyword', value: 'TIME ZONE', assert: true },\n                ]\n            }\n        ];\n    }\n\n    /* AST API */\n\n    pgWithTZ() { return this._get('pg_with_tz'); }\n}", "import { TypedLiteral } from './TypedLiteral.js';\nimport { registry } from '../../registry.js';\n\nexport class TypedTimeZoneLiteral extends TypedLiteral {\n\n\t/* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', value: 'TIME ZONE' },\n            { type: 'Expr', as: 'value' },\n        ];\n    }\n}", "import { AbstractLiteral } from './AbstractLiteral.js';\n\nexport class UnknownLiteral extends AbstractLiteral {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() { return { type: 'unknown_literal', as: '.' }; }\n }", "export const SugarMixin = Class => class extends Class {\n    get isSugar() { return true; }\n}", "import { SugarMixin } from '../../abstracts/SugarMixin.js';\nimport { TypeSysMixin } from '../../abstracts/TypeSysMixin.js';\nimport { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\nimport { registry } from '../../registry.js';\n\nexport class AbstractLQJsonLiteral extends SugarMixin(TypeSysMixin(AbstractNodeList)) {\n\n    dataType() { return registry.DataType.fromJSON({ value: 'JSON' }); }\n}", "import { AbstractLQJsonLiteral } from './AbstractLQJsonLiteral.js';\nimport { registry } from '../../registry.js';\n\nexport class LQArrayLiteral extends AbstractLQJsonLiteral {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return {\n            syntax: [\n                {\n                    type: 'bracket_block',\n                    syntax: { type: 'Expr', as: 'entries', arity: Infinity, itemSeparator, autoIndent: 2 },\n                },\n            ],\n        };\n    }\n\n    static morphsTo() { return registry.CallExpr; }\n\n    /* JSON API */\n\n    jsonfy(options = {}, transformer = null, linkedDb = null) {\n        let resultJson = super.jsonfy(options, transformer, linkedDb);\n        if (options.deSugar) {\n            const resultSchemas = [];\n\n            resultJson = {\n                nodeName: registry.CallExpr.NODE_NAME,\n                name: (options.toDialect || this.options.dialect) === 'mysql' ? 'JSON_ARRAY' : 'JSON_BUILD_ARRAY',\n                arguments: resultJson.entries.map((e, i) => {\n\n                    let resultSchema = e.result_schema;\n                    const schemaIdent = { value: i, nodeName: registry.Identifier.NODE_NAME };\n\n                    if (resultSchema instanceof registry.ColumnSchema) {\n                        resultSchema = resultSchema.clone({ renameTo: schemaIdent });\n                    } else {\n                        resultSchema = registry.ColumnSchema.fromJSON({\n                            name: schemaIdent,\n                            data_type: this.entries()[i].dataType().jsonfy(),\n                        });\n                    }\n                    resultSchemas.push(resultSchema);\n\n                    return e;\n                }),\n                result_schema: registry.JSONSchema.fromJSON({ entries: resultSchemas }, { assert: true })\n            };\n        }\n\n        return resultJson;\n    }\n}", "import { AbstractLQJsonLiteral } from './AbstractLQJsonLiteral.js';\nimport { registry } from '../../registry.js';\nimport { _eq } from '../../util.js';\n\nexport class LQObjectLiteral extends AbstractLQJsonLiteral {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return {\n            syntax: [\n                {\n                    type: 'brace_block',\n                    syntax: { type: 'LQObjectProperty', as: 'entries', arity: Infinity, itemSeparator, autoIndent: 3 },\n                },\n            ],\n        };\n    }\n\n    static morphsTo() { return registry.CallExpr; }\n\n    /* JSON API */\n\n    jsonfy(options = {}, transformer = null, linkedDb = null) {\n        let resultJson = super.jsonfy(options, transformer, linkedDb);\n        if (options.deSugar) {\n\n            const entries = resultJson.entries.reduce((result, propertyJson) => {\n                if (propertyJson.star_ref) {\n                    for (const ref of propertyJson.star_ref.result_schema) {\n                        const newPropertyJson = {\n                            key: { value: ref.value(), delim: ref._get('delim') },\n                            value: ref.jsonfy(),\n                        };\n                        result = result.reduce((result, existing) => {\n                            if (_eq(newPropertyJson.key.value, existing.key.value, newPropertyJson.key.delim || existing.key.delim)) {\n                                return result;\n                            }\n                            return result.concat(existing);\n                        }, []);\n                        result = result.concat(newPropertyJson);\n                    }\n                    return result;\n                }\n                return result.concat(propertyJson);\n            }, []);\n\n            const resultSchemas = [];\n\n            resultJson = {\n                nodeName: registry.CallExpr.NODE_NAME,\n                name: (options.toDialect || this.options.dialect) === 'mysql' ? 'JSON_OBJECT' : 'JSON_BUILD_OBJECT',\n                arguments: entries.reduce((args, propertyJson, i) => {\n\n                    let resultSchema = propertyJson.value.result_schema;\n                    const schemaIdent = { ...propertyJson.key, nodeName: registry.Identifier.NODE_NAME };\n\n                    if (resultSchema instanceof registry.ColumnSchema) {\n                        resultSchema = resultSchema.clone({ renameTo: schemaIdent });\n                    } else {\n                        resultSchema = registry.ColumnSchema.fromJSON({\n                            name: schemaIdent,\n                            data_type: this.entries()[i].value()?.dataType().jsonfy() || { nodeName: registry.DataType.NODE_NAME, value: 'TEXT' },\n                        });\n                    }\n                    \n                    resultSchemas.push(resultSchema);\n\n                    return args.concat(\n                        { ...propertyJson.key, nodeName: registry.StringLiteral.NODE_NAME },\n                        { ...propertyJson.value }\n                    );\n\n                }, []),\n                result_schema: registry.JSONSchema.fromJSON({ entries: resultSchemas }, { assert: true })\n            };\n        }\n\n        return resultJson;\n    }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\nimport { registry } from '../../registry.js';\n\nexport class LQObjectProperty extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            syntaxes: [\n                { type: 'ColumnRef0', as: 'star_ref' },\n                [\n                    { type: 'SelectItemAlias', as: 'key' },\n                    {\n                        optional: true,\n                        syntax: [\n                            { type: 'punctuation', value: ':' },\n                            { type: 'Expr', as: 'value', assert: true },\n                        ],\n                        autoSpacing: false,\n                    },\n                ]\n            ]\n        };\n    }\n\n    static get syntaxPriority() { return -1; }\n\n    get isProperty() { return true; }\n\n    /* AST API */\n\n    starRef() { return this._get('star_ref'); }\n\n    key() { return this._get('key'); }\n\n    value() { return this._get('value'); }\n\n    /* DESUGARING API */\n\n    jsonfy(options = {}, transformer = null, linkedDb = null) {\n        if (options.deSugar && !this.starRef()) {\n\n            const keyNode = this.key();\n            let asAggr, keyJson = transformer\n                ? transformer.transform(keyNode, ($options = options) => keyNode.jsonfy($options), 'key', options)\n                : keyNode.jsonfy(options);\n            if (keyJson.is_aggr) ({ is_aggr: asAggr, ...keyJson } = keyJson);\n\n            let valueNode = this.value();\n            if (!valueNode) {\n                valueNode = registry.ColumnRef1.fromJSON({ ...keyJson, nodeName: undefined });\n                this._adoptNodes(valueNode);\n            }\n\n            let defaultTransform;\n\n            if (asAggr && !(valueNode instanceof registry.LQDeepRef1)) {\n                // Note the below where we wrap value in an aggr call\n                defaultTransform = ($options = options, childTransformer = transformer) => ({\n                    nodeName: registry.AggrCallExpr.NODE_NAME,\n                    name: (options.toDialect || this.options.dialect) === 'mysql' ? 'JSON_ARRAYAGG' : 'JSON_AGG',\n                    arguments: [valueNode.jsonfy($options, childTransformer, linkedDb)],\n                });\n            } else {\n                // Note the below where we derive value, if not specified, from key\n                defaultTransform = ($options = options, childTransformer = transformer) => {\n                    return valueNode.jsonfy($options, childTransformer, linkedDb);\n                };\n            }\n\n            const valueJson = transformer\n                ? transformer.transform(valueNode, defaultTransform, 'value', { ...options, asAggr })\n                : defaultTransform();\n\n            // plus, we'll drop the is_aggr flag\n            return {\n                nodeName: LQObjectProperty.NODE_NAME,\n                key: keyJson,\n                value: valueJson\n            };\n        }\n        return super.jsonfy(options, transformer, linkedDb);\n    }\n}", "import { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\nimport { registry } from '../../registry.js';\n\nexport class PGTypedArrayLiteral extends AbstractNodeList {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return {\n            dialect: 'postgres',\n            syntax: [\n                { type: 'keyword', value: 'ARRAY' },\n                {\n                    type: 'bracket_block',\n                    syntax: { type: 'Expr', as: 'entries', arity: Infinity, itemSeparator, autoIndent: 2 },\n                    autoSpacing: false,\n                },\n            ],\n        };\n    }\n\n    static morphsTo() { return registry.CallExpr; }\n\n    /* TYPESYS API */\n\n    dataType() { return registry.DataType.fromJSON({ value: 'JSON' }); }\n\n    /* JSON API */\n\n    jsonfy(options = {}, transformer = null, linkedDb = null) {\n        let resultJson = super.jsonfy(options, transformer, linkedDb);\n        if ((options.toDialect || this.options.dialect) === 'mysql') {\n            resultJson = {\n                nodeName: registry.CallExpr.NODE_NAME,\n                name: 'JSON_ARRAY',\n                arguments: resultJson.entries,\n            };\n        }\n        return resultJson;\n    }\n}", "import { BinaryExpr } from './BinaryExpr.js';\nimport { registry } from '../../registry.js';\n\nexport class AtTimeZoneExpr extends BinaryExpr {\n\n    /* DEFS */\n\n    static get syntaxRules() {\n        return [\n            { type: 'Expr', as: 'left', peek: [1, 'operator', 'AT'] },\n            { type: 'operator', as: 'operator', value: 'AT' },\n            {\n                syntaxes: [\n                    { type: 'TypedTimeZoneLiteral', as: 'right' },\n                    { type: 'keyword', as: 'right', value: 'LOCAL' }\n                ]\n            }\n        ];\n    }\n\n    static get syntaxPriority() { return 0; }\n\n    /* AST API */\n\n    left() { return this._get('left'); }\n\n    right() { return this._get('right'); }\n\n    /* TYPESYS API */\n\n    dataType() { return registry.DataType.fromJSON({ value: 'TIME ZONE' }); }\n}", "import { BinaryExpr } from './BinaryExpr.js';\n\nexport class BetweenExpr extends BinaryExpr {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'operator', value: 'AND' };\n        return [\n            { type: 'Expr', as: 'left', peek: [1, 'operator', ['NOT', 'BETWEEN']] },\n            { type: 'operator', as: 'negation', value: 'NOT', booleanfy: true, optional: true },\n            { type: 'operator', as: 'operator', value: 'BETWEEN' },\n            { type: 'Expr', as: 'right', arity: { min: 2, max: 2, eager: false }, itemSeparator, assert: true },\n        ];\n    }\n}", "import { BinaryExpr } from './BinaryExpr.js';\n\nexport class DistinctFromExpr extends BinaryExpr {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'Expr', as: 'left', peek: [1, 'operator', ['IS', 'IS NOT']] },\n            { type: 'operator', as: 'logic', value: ['IS', 'IS NOT'] },\n            { type: 'operator', as: 'operator', value: 'DISTINCT FROM' },\n            { type: 'Expr', as: 'right', assert: true },\n        ];\n    }\n\n    /* AST API */\n\n    logic() { return this._get('logic'); }\n}", "import { BinaryExpr } from './BinaryExpr.js';\n\nexport class InExpr extends BinaryExpr {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'Expr', as: 'left', peek: [1, 'operator', ['NOT', 'IN']] },\n            { type: 'operator', as: 'negation', value: 'NOT', booleanfy: true, optional: true },\n            { type: 'operator', as: 'operator', value: 'IN' },\n            { type: ['DerivedQuery', 'RowConstructor', 'TypedRowConstructor'], as: 'right', assert: true },\n        ];\n    }\n}", "import { BinaryExpr } from './BinaryExpr.js';\n\nexport class PGCastExpr2 extends BinaryExpr {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            dialect: 'postgres',\n            syntax: [\n                { type: 'Expr', as: 'left', peek: [1, 'operator', '::'] },\n                { type: 'operator', as: 'operator', value: '::', autoSpacing: false },\n                { type: 'DataType', as: 'right', assert: true, autoSpacing: false },\n            ]\n        };\n    }\n\n    /* TYPESYS API */\n\n    expr() { return this.left(); }\n\n    dataType() { return this.right(); }\n}", "import { AbstractClassicExpr } from '../AbstractClassicExpr.js';\nimport { registry } from '../../registry.js';\n\nexport class UnaryExpr extends AbstractClassicExpr {\n\n    /* DEFS */\n\n    static get syntaxRules() {\n        return [\n            { type: 'operator', as: 'operator', value: ['-', '+', 'NOT'] },\n            { type: 'Expr', as: 'operand', autoSpacing: ['NOT'] },\n        ];\n    }\n\n    static get syntaxPriority() { return 1;/* higher than BinaryExpr */ }\n\n    /* AST API */\n\n    operator() { return this._get('operator'); }\n\n    operand() { return this._get('operand'); }\n\n    /* TYPESYS API */\n\n    dataType() {\n        const operator = this.operator();\n        if (!operator) return super.dataType();\n        return registry.DataType.fromJSON({ value: operator === 'NOT' ? 'BOOLEAN' : 'NUMBER' });\n    }\n}", "export class ErrorRefUnknown extends Error {}", "export class ErrorRefAmbiguous extends Error {}", "import { ErrorRefUnknown } from './ErrorRefUnknown.js';\nimport { ErrorRefAmbiguous } from './ErrorRefAmbiguous.js';\nimport { DDLSchemaMixin } from '../../../abstracts/DDLSchemaMixin.js';\nimport { TypeSysMixin } from '../../../abstracts/TypeSysMixin.js';\nimport { Identifier } from '../Identifier.js';\n\nexport class AbstractClassicRef extends DDLSchemaMixin(TypeSysMixin(Identifier)) {\n\n    lookup(transformer, linkedDb) { return []; }\n\n    resolve(transformer, linkedDb) {\n        const resultSet = this.lookup(null, transformer, linkedDb) || [];\n        const objectType = this.constructor.name.match(/schema/i) ? 'Schema' : (this.constructor.name.match(/table/i) ? 'Table' : 'Column');\n        if (resultSet.length > 1) {\n            throw new ErrorRefAmbiguous(`[${this.parentNode?.parentNode || this.parentNode || this}] ${objectType} ${this} is ambiguous. (Is it ${resultSet.join(' or ')}?)`);\n        } else if (!resultSet.length) {\n            throw new ErrorRefUnknown(`[${this.parentNode?.parentNode || this.parentNode || this}] ${objectType} ${this} does not exist.`);\n        }\n        return resultSet[0];\n    }\n}", "import { AbstractClassicRef } from './abstracts/AbstractClassicRef.js';\nimport { AbstractNode } from '../../abstracts/AbstractNode.js';\nimport { PathMixin } from '../../abstracts/PathMixin.js';\nimport { registry } from '../../registry.js';\n\nexport class ColumnRef1 extends PathMixin(AbstractClassicRef) {\n\n    /* SYNTAX RULES */\n\n    static get _qualifierType() {\n        return [\n            'TableRef1'/* must come first being primary */,\n            'LQBackRefAbstraction'\n        ];\n    }\n\n    static get syntaxRules() {\n        return this.buildSyntaxRules({ type: 'identifier', as: '.', autoSpacing: false });\n    }\n\n    static get syntaxPriority() { return 51; } // above LQBackRefAbstraction\n\n    static morphsTo() { return registry.ColumnRef2; }\n\n    /* API */\n\n    dataType() { return this.resultSchema()?.dataType() || super.dataType(); }\n\n    canReferenceOutputColumns() {\n        return this.climbTree((parentNode, up) => {\n            if (parentNode instanceof registry.SelectStmt) return false;\n            if (parentNode instanceof registry.GroupByClause) return parentNode;\n            if (parentNode instanceof registry.HavingClause) return parentNode;\n            if (parentNode instanceof registry.OrderByClause) return parentNode;\n            return up();\n        });\n    }\n\n    lookup(deepMatchCallback = null, transformer = null, linkedDb = null) {\n        if (!transformer && !linkedDb) return [];\n\n        const name = this._get('value');\n        const inGrepMode = (!name || name === '*') && !deepMatchCallback;\n        let resultSet = [];\n\n        const resolve = (columnSchema, qualifierJson = undefined) => {\n\n            if (!(columnSchema instanceof registry.ColumnSchema)) return false;\n            if (name && name !== '*' && !columnSchema.identifiesAs(this)) return false;\n\n            let result;\n            if (deepMatchCallback && !(result = deepMatchCallback(columnSchema, qualifierJson))) return false;\n            if (result instanceof AbstractNode || Array.isArray(result)) return result;\n\n            const resultSchema = columnSchema.clone({ normalized: true });\n            columnSchema.parentNode?._adoptNodes(resultSchema);\n\n            const resolvedColumnRef1 = ColumnRef1.fromJSON({\n                ...columnSchema.name().jsonfy({ nodeNames: false }),\n                result_schema: resultSchema,\n                qualifier: qualifierJson\n            });\n\n            this.parentNode._adoptNodes(resolvedColumnRef1);\n\n            return resolvedColumnRef1;\n        };\n\n        // 1. Resolve system refs statically\n        const systemColumns = (this.options.dialect || 'postgres') === 'postgres'\n            ? ['CTID', 'OID', 'XMIN', 'XMAX', 'TABLEOID']\n            : [];\n        if (systemColumns.includes(name?.toUpperCase())) {\n            const columnSchema = registry.ColumnSchema.fromJSON({\n                name: { nodeName: registry.Identifier.NODE_NAME, value: name },\n                data_type: { nodeName: registry.DataType.NODE_NAME, value: 'INT' },\n            }, { assert: true });\n            return [].concat(resolve(columnSchema) || []);\n        }\n\n        // 2. Resolve from outputSchemas first?\n        if (this.canReferenceOutputColumns() && transformer) {\n            // Resolve from outputSchemas first\n            let statementContext = transformer.statementContext\n            for (const columnSchema of statementContext.artifacts.get('outputSchemas')) {\n                resultSet = resultSet.concat(resolve(columnSchema) || []);\n                if (!inGrepMode && resultSet.length) break; // Matching current instance only\n            }\n        }\n\n        // 3. Resolve normally\n        if (inGrepMode || !resultSet.length) {\n            // Resolve normally\n            resultSet = resultSet.concat((new registry.TableRef1(this.qualifier()?.jsonfy() || {})).lookup(\n                (tableSchema, qualifierJson = undefined) => {\n\n                    return tableSchema._get('entries').reduce((prev, columnSchema) => {\n                        if (tableSchema instanceof registry.JSONSchema) {\n                            // An unaliased derived query\n                            return prev.concat(resolve(columnSchema) || []);\n                        }\n                        const newQualifierJson = {\n                            ...tableSchema.name().jsonfy({ nodeNames: false }),\n                            result_schema: tableSchema,\n                            qualifier: qualifierJson\n                        };\n                        return prev.concat(resolve(columnSchema, newQualifierJson) || []);\n                    }, []);\n\n                },\n                transformer,\n                linkedDb,\n            ));\n        }\n\n        if (name === '*') {\n            const compositeResult = registry.ColumnRef0.fromJSON({\n                value: this.value(),\n                result_schema: registry.JSONSchema.fromJSON({ entries: resultSet.map((s) => s.clone()) }, { assert: true }),\n            });\n            this.parentNode._adoptNodes(compositeResult);\n            resultSet = [compositeResult];\n        }\n\n        return resultSet;\n    }\n\n    jsonfy({ toKind = 1, ...options } = {}, transformer = null, linkedDb = null) {\n        if (options.deSugar\n            && ((!this.qualifier() && Number(options.deSugar) > 1)\n                || !this.resultSchema())\n            && (transformer || linkedDb)) {\n            const resolvedJson = this.resolve(transformer, linkedDb).jsonfy(/* IMPORTANT */);\n            if (Number(options.deSugar) < 2 && !this.qualifier()) {\n                return { ...resolvedJson, qualifier: undefined };\n            }\n            return resolvedJson;\n        }\n        let resultJson = super.jsonfy(options, transformer, linkedDb);\n        if (toKind === 2) {\n            resultJson = {\n                ...resultJson,\n                nodeName: registry.ColumnRef2.NODE_NAME,\n            };\n            delete resultJson.qualifier;\n        }\n        return resultJson;\n    }\n}", "import { ColumnRef1 } from './ColumnRef1.js';\nimport { registry } from '../../registry.js';\n\nexport class ColumnRef0 extends ColumnRef1 {\n\n    /* SYNTAX RULES */\n\n    static get _qualifierType() { return ['TableRef1']; }\n\n    static get syntaxRules() {\n        return this.buildSyntaxRules({ type: 'operator', as: '.', value: '*', autoSpacing: false });\n    }\n\n    static get syntaxPriority() { return -1; }\n\n    /* API */\n\n    dataType() { return registry.DataType.fromJSON({ value: 'SET' }); }\n}", "export class ErrorFKInvalid extends Error {\n\n    constructor(message) {\n        super(message);\n        this.name = 'ErrorFKInvalid';\n    }\n\n}", "import { ErrorFKInvalid } from './ErrorFKInvalid.js';\nimport { SugarMixin } from '../../../abstracts/SugarMixin.js';\nimport { BinaryExpr } from '../../op/BinaryExpr.js';\n\nexport class AbstractMagicRef extends SugarMixin(BinaryExpr) {\n\n    rhsTable(transformer, linkedDb) {\n        const resolveOperand = this.operand()?.resolve(transformer, linkedDb);\n        const fk = resolveOperand.resultSchema()/* ColumnSchema */?.fkConstraint(true);\n        if (!fk) {\n            throw new ErrorFKInvalid(`[${this.parentNode || this}] Column ${this.operand()} is not a foreign key.`);\n        }\n        return fk.targetTable()?.resolve(null/*transformer*/, linkedDb);\n    }\n\n\trhsSchema(transformer, linkedDb) { return this.rhsTable(transformer, linkedDb)?.resultSchema(); }\n}", "import { AbstractClassicRef } from './abstracts/AbstractClassicRef.js';\nimport { AbstractMagicRef } from './abstracts/AbstractMagicRef.js';\nimport { AbstractNode } from '../../abstracts/AbstractNode.js';\nimport { registry } from '../../registry.js';\n\nexport class ColumnRef2 extends AbstractClassicRef {\n\n    /* SYNTAX RULES */\n\n    static get syntaxPriority() { return -1; }\n\n    static morphsTo() { return registry.ColumnRef1; }\n\n    /* SCHEMA API */\n\n    dataType() { return this.resultSchema()?.dataType() || super.dataType(); }\n\n    lookup(deepMatchCallback, transformer = null, linkedDb = null) {\n        if (!transformer && !linkedDb) return [];\n\n        const name = this._get('value');\n        const inGrepMode = !name && !deepMatchCallback;\n        let resultSet = [];\n\n        const resolve = (columnSchema) => {\n            if (!(columnSchema instanceof registry.ColumnSchema)) return false;\n            if (name && !columnSchema.identifiesAs(this)) return false;\n            let result;\n            if (deepMatchCallback && !(result = deepMatchCallback(columnSchema))) return false;\n            if (result instanceof AbstractNode || Array.isArray(result)) return result;\n\n            const resultSchema = columnSchema.clone({ normalized: true });\n            columnSchema.parentNode._adoptNodes(resultSchema);\n\n            const resolvedColumnRef2 = ColumnRef2.fromJSON({\n                ...columnSchema.name().jsonfy({ nodeNames: false }),\n                result_schema: resultSchema\n            });\n            this.parentNode._adoptNodes(resolvedColumnRef2);\n\n            return resolvedColumnRef2;\n        };\n\n        let tableSchemasInScope;\n        if (this.parentNode instanceof AbstractMagicRef) {\n            if (this === this.parentNode.operand()) {\n                tableSchemasInScope = [this.parentNode.parentNode.rhsSchema(transformer, linkedDb)];\n            } else {\n                tableSchemasInScope = [this.parentNode.rhsSchema(transformer, linkedDb)];\n            }\n        } else {\n            tableSchemasInScope = this.climbTree((superParentNode, up) => {\n                if (superParentNode instanceof registry.InsertStmt || superParentNode instanceof registry.UpdateStmt) {\n                    let tableSchemas = [...transformer.statementContext.artifacts.get('tableSchemas')].map((t) => t.resultSchema);\n                    // For UPDATEs, and of cos INSERTs, postgres target columns are resolved from just the target table\n                    if (this.options.dialect !== 'mysql') {\n                        tableSchemas = tableSchemas.slice(0, 1);\n                    }\n                    return tableSchemas;\n                }\n                if (superParentNode instanceof registry.TableSchema) {\n                    return [superParentNode];\n                }\n                return up();\n            });\n        }\n\n        outer: for (const tableSchema of tableSchemasInScope || []) {\n            for (const columnSchema of tableSchema) {\n                resultSet = resultSet.concat(resolve(columnSchema) || []);\n                if (!inGrepMode && resultSet.length) break outer; // Matching current instance only\n            }\n        }\n\n        return resultSet;\n    }\n\n    jsonfy({ toKind = 2, ...options } = {}, transformer = null, linkedDb = null) {\n        if (options.deSugar\n            && !this.resultSchema()\n            && (transformer || linkedDb)) {\n            return this.resolve(transformer, linkedDb).jsonfy(/* IMPORTANT */);\n        }\n        let resultJson = super.jsonfy(options, transformer, linkedDb);\n        if (toKind === 1) {\n            resultJson = {\n                ...resultJson,\n                nodeName: registry.ColumnRef1.NODE_NAME,\n            };\n            delete resultJson.qualifier; // by LQ_BACK_REF_ENDPOINT\n        }\n        return resultJson;\n    }\n}", "import { AbstractMagicRef } from './abstracts/AbstractMagicRef.js';\nimport { registry } from '../../registry.js';\n\nexport class LQBackBackRef extends AbstractMagicRef {\n\n\t/* SYNTAX RULES */\n\n\tstatic get _leftType() {\n\t\treturn [\n\t\t\t'LQBackRefEndpoint'/* must come first to prevent left-recursion */,\n\t\t\t'LQBackBackRef'\n\t\t];\n\t} // for inheritance\n\n\tstatic get syntaxRules() {\n\t\treturn [\n\t\t\t{ type: this._leftType, as: 'left', peek: [1, 'operator', '<~'] },\n\t\t\t{ type: 'operator', value: '<~' },\n\t\t\t{ type: 'ColumnRef2', as: 'right', peek: [1, 'operator', '<~'] },\n\t\t];\n\t}\n\n\tstatic get syntaxPriority() { return 1; }\n\n\tstatic morphsTo() { return [registry.LQDeepRef1, registry.LQDeepRef2, registry.LQDeepDeepRef1, registry.LQDeepDeepRef2]; }\n\n\t/* API */\n\n\toperand() { return this.right(); }\n\n\tendpoint() { return this.left() instanceof LQBackBackRef ? this.left().endpoint() : this.left(); }\n\n\t/* JSON API */\n\n\tjsonfy({ reverseRef = false, toKind = 1, ...options } = {}, transformer = null, linkedDb = null) {\n\t\tif (reverseRef) {\n\t\t\treturn {\n\t\t\t\tnodeName: toKind === 2 \n\t\t\t\t\t? (reverseRef === Infinity ? registry.LQDeepDeepRef2.NODE_NAME : registry.LQDeepRef2.NODE_NAME)\n\t\t\t\t\t: (reverseRef === Infinity ? registry.LQDeepDeepRef1.NODE_NAME : registry.LQDeepRef1.NODE_NAME),\n\t\t\t\tleft: this.right().jsonfy({ toKind: reverseRef !== Infinity ? 1 : 2, ...options }),\n\t\t\t\tright: this.left() instanceof registry.LQBackRefEndpoint\n\t\t\t\t\t? { nodeName: registry.ColumnRef2.NODE_NAME, value: this.left().value(), delim: this.left()._get('delim') }\n\t\t\t\t\t: this.left().jsonfy({ reverseRef: Infinity, toKind, ...options }),\n\t\t\t};\n\t\t}\n\t\treturn super.jsonfy(options, transformer, linkedDb);\n\t}\n}", "import { LQBackBackRef } from './LQBackBackRef.js';\nimport { ErrorFKInvalid } from './abstracts/ErrorFKInvalid.js';\nimport { ErrorRefAmbiguous } from './abstracts/ErrorRefAmbiguous.js';\nimport { ErrorRefUnknown } from './abstracts/ErrorRefUnknown.js';\nimport { registry } from '../../registry.js';\n\nexport class LQBackRef extends LQBackBackRef {\n\n\t/* SYNTAX RULES */\n\n\tstatic get syntaxRules() {\n\t\treturn [\n\t\t\t{ type: this._leftType, as: 'left', peek: [1, 'operator', '<~'] },\n\t\t\t{ type: 'operator', value: '<~' },\n\t\t\t{ type: 'TableRef2', as: 'right' }\n\t\t];\n\t}\n\n\tstatic get syntaxPriority() { return 0; }\n\n\t/* SCHEMA API */\n\n\trhsTable(transformer, linkedDb) {\n\t\tif (!linkedDb) return;\n\t\tconst tableRefs = this.right()?.lookup(null, null/*transformer*/, linkedDb) || [];\n\t\tif (!tableRefs.length) {\n\t\t\tthrow new ErrorRefUnknown(`[${this.parentNode || this}] Implied RHS table ${this.right()} does not exist.`);\n\t\t}\n\t\treturn tableRefs[0];\n\t}\n\n\tresolve(transformer, linkedDb, toKind = 1) {\n\t\tif (!transformer || !linkedDb) return;\n\t\tconst left = this.left();\n\n\t\tconst qualifiedLeftEndpoint = left instanceof LQBackBackRef\n\t\t\t? left.endpoint()\n\t\t\t: left;\n\t\tconst leftEndpointQualifier = qualifiedLeftEndpoint.qualifier();\n\n\t\tconst unqualifiedLeftEndpoint = registry.ColumnRef2.fromJSON({\n\t\t\t...qualifiedLeftEndpoint.jsonfy({ nodeNames: false }),\n\t\t\tqualifier: undefined\n\t\t});\n\n\t\tconst resolvedLeftEndpoint = qualifiedLeftEndpoint/* original */.resolve(transformer, linkedDb);\n\n\t\tconst leftFk = resolvedLeftEndpoint.resultSchema()/* ColumnSchema */.fkConstraint(true);\n\t\tif (!leftFk) throw new ErrorFKInvalid(`[${this.parentNode || this}] Endpoint column ${unqualifiedLeftEndpoint} is not a foreign key.`);\n\t\tconst leftEndpointTable = leftFk.targetTable();\n\n\t\tlet qualifiedLeftOperand;\n\t\tconst resolve = (ddlName, tableSchema) => {\n\t\t\tconst pkColumnRef2 = tableSchema.pkConstraint(true)?.columns()[0]?.resolve(transformer, linkedDb);\n\t\t\tif (!pkColumnRef2) throw new ErrorFKInvalid(`[${this.parentNode || this}] The referenced LHS table ${ddlName} does not have a primary key.`);\n\n\t\t\tconst $qualifiedLeftOperand = registry.ColumnRef1.fromJSON({\n\t\t\t\tqualifier: { ...tableSchema.name().jsonfy({ nodeNames: false }), result_schema: tableSchema },\n\t\t\t\tvalue: pkColumnRef2.value(),\n\t\t\t\tdelim: pkColumnRef2._get('delim'),\n\t\t\t\tresult_schema: pkColumnRef2.resultSchema()\n\t\t\t});\n\n\t\t\tif (qualifiedLeftOperand) throw new ErrorRefAmbiguous(`[${this.parentNode || this}]: The referenced endpoint for foreign key ${unqualifiedLeftEndpoint} is ambiguous. (Is it ${qualifiedLeftOperand} or ${$qualifiedLeftOperand}?)`);\n\t\t\tqualifiedLeftOperand = $qualifiedLeftOperand;\n\t\t};\n\n\t\tlet statementContext = transformer.statementContext\n\t\touter: do {\n\t\t\tfor (const { type, resultSchema: tableSchema } of statementContext.artifacts.get('tableSchemas')) {\n\t\t\t\tif (type === 'CTEItem') continue;\n\t\t\t\tconst ddlName = tableSchema._get('ddl_name') || tableSchema.name(); // Must match leftEndpointTable\n\t\t\t\tif (leftEndpointQualifier) {\n\t\t\t\t\tif (!tableSchema.identifiesAs(leftEndpointQualifier)) continue;\n\t\t\t\t\tif (!leftEndpointTable.identifiesAs(ddlName)) {\n\t\t\t\t\t\tthrow new ErrorFKInvalid(`[${this.parentNode || this}] The endpoint table implied by ${leftEndpointQualifier} (${ddlName}) is not the actual target (${leftEndpointTable}) of the foreign key column ${unqualifiedLeftEndpoint}.`);\n\t\t\t\t\t}\n\t\t\t\t\tresolve(ddlName, tableSchema);\n\t\t\t\t\tbreak outer;\n\t\t\t\t} else if (leftEndpointTable.identifiesAs(ddlName)) {\n\t\t\t\t\tresolve(ddlName, tableSchema);\n\t\t\t\t}\n\t\t\t}\n\t\t} while (!qualifiedLeftOperand && (statementContext = statementContext.parentTransformer?.statementContext))\n\n\t\tif (!qualifiedLeftOperand) {\n\t\t\tthrow new ErrorRefUnknown(`[${this.parentNode || this}] Ref does not correlate with current query.`);\n\t\t}\n\n\t\tconst qualifiedRightTable = this.rhsTable(transformer, linkedDb);\n\t\tconst unqualifiedRightOperand = left instanceof LQBackBackRef\n\t\t\t? left.clone({ reverseRef: true, toKind })\n\t\t\t: unqualifiedLeftEndpoint.constructor.fromJSON({\n\t\t\t\t...unqualifiedLeftEndpoint.jsonfy(),\n\t\t\t\tresult_schema: qualifiedRightTable.resultSchema()._get('entries', unqualifiedLeftEndpoint)\n\t\t\t});\n\n\t\treturn {\n\t\t\tlhsOperand: qualifiedLeftOperand, // ColumnRef1\n\t\t\trhsOperand: unqualifiedRightOperand.clone({ toKind }), // ColumnRef2\n\t\t\trhsTable: qualifiedRightTable, // TableRef2\n\t\t};\n\t}\n}\n", "import { ParenExpr } from '../abstraction/ParenExpr.js';\n\nexport class LQBackRefAbstraction extends ParenExpr {\n\n\t/* SYNTAX RULES */\n\n\tstatic get syntaxRules() {\n\t\treturn {\n\t\t\ttype: 'paren_block',\n\t\t\tsyntaxes: [\n\t\t\t\t{ type: 'Expr', as: 'expr', peek: [1, 'operator', '<~'] }, // (fk <~ fk2 <~ tbl)\n\t\t\t\t{ type: 'Expr', as: 'expr', peek: [2, 'operator', '<~'] }, // ((alias) fk <~ fk2 <~ tbl)\n\t\t\t],\n\t\t};\n\t}\n\n\tstatic get syntaxPriority() { return 51; } // Above RowConstructor\n\n\t/* AST API */\n\n\texpr() { return this._get('expr'); }\n}", "import { ColumnRef2 } from './ColumnRef2.js';\n\nexport class LQBackRefEndpoint extends ColumnRef2 {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n\t\t\t{\n\t\t\t\toptional: true,\n                type: 'paren_block',\n\t\t\t\tsyntax: { type: 'Identifier', as: 'qualifier' },\n\t\t\t},\n\t\t\t{ ...[].concat(super.syntaxRules)[0], peek: [1, 'operator', '<~'] },\n\t\t];\n    }\n\n    static get syntaxPriority() { return 52; } // Above ColumnRef1\n\n    static morphsTo() { return ColumnRef2; }\n    \n    /* API */\n\n    qualifier() { return this._get('qualifier'); }\n}", "import { AbstractMagicRef } from './abstracts/AbstractMagicRef.js';\nimport { registry } from '../../registry.js';\n\nexport class LQDeepDeepRef1 extends AbstractMagicRef {\n\n\t/* SYNTAX RULES */\n\n\tstatic get _rightType() { return ['LQDeepDeepRef1', 'LQObjectLiteral', 'LQArrayLiteral', 'RowConstructor', 'ColumnRef2']; } // for inheritance\n\n\tstatic get syntaxRules() {\n\t\treturn [\n\t\t\t{ type: ['ColumnRef2', 'LQBackRefAbstraction'], as: 'left', peek: [1, 'operator', '~>'] },\n\t\t\t{ type: 'operator', value: '~>' },\n\t\t\t{ type: this._rightType, as: 'right' },\n\t\t];\n\t}\n\n\tstatic get syntaxPriority() { return -1; }\n\n\tstatic morphsTo() { return [registry.LQDeepRef1, registry.LQDeepRef2, registry.LQDeepDeepRef1, registry.LQDeepDeepRef2]; }\n\n\t/* API */\n\n\toperand() { return this.left(); }\n\n\tendpoint() { return this.right() instanceof LQDeepDeepRef1 ? this.right().endpoint() : this.right(); }\n\n\t/* JSON API */\n\n\tjsonfy({ toDeepRef = false, toKind = 1, ...options } = {}, transformer = null, linkedDb = null) {\n\t\tif (toDeepRef || toKind === 1 || toKind === 2) {\n\t\t\tconst altsMap = [\n\t\t\t\tregistry.LQDeepRef1.NODE_NAME, registry.LQDeepRef2.NODE_NAME,\n\t\t\t\tregistry.LQDeepDeepRef1.NODE_NAME, registry.LQDeepDeepRef2.NODE_NAME\n\t\t\t];\n\n\t\t\tlet currentIndex = altsMap.indexOf(this.NODE_NAME);\n\t\t\tif (toDeepRef && currentIndex > 1) {\n\t\t\t\tcurrentIndex -= 2;\n\t\t\t}\n\n\t\t\tconst NODE_NAME = altsMap[(currentIndex + 1) % 2 === toKind % 2\n\t\t\t\t? currentIndex\n\t\t\t\t: (toKind % 2 // its 1 or 3\n\t\t\t\t\t? currentIndex - 1\n\t\t\t\t\t: currentIndex + 1)];\n\n\t\t\treturn {\n\t\t\t\tnodeName: NODE_NAME,\n\t\t\t\tleft: this.left().jsonfy({ toKind: currentIndex > 1 ? 2 : 1 }), // Left is always ColumnRef1 for DeepRef, but ColumnRef2 for DeepDeepRef\n\t\t\t\tright: this.right().jsonfy({ toKind: this.right() instanceof LQDeepDeepRef1 ? toKind : undefined }),\n\t\t\t};\n\t\t}\n\n\t\treturn super.jsonfy(options, transformer, linkedDb);\n\t}\n}", "import { LQDeepDeepRef1 } from './LQDeepDeepRef1.js';\nimport { registry } from '../../registry.js';\n\nexport class LQDeepDeepRef2 extends LQDeepDeepRef1 {\n\n\t/* SYNTAX RULES */\n\n\tstatic get _rightType() { return ['LQDeepDeepRef2', 'ColumnRef2', 'ColumnsConstructor']; } // for inheritance\n\n\t/* JSON API */\n\n\tjsonfy({ toDeepRef = false, toKind = 2, ...options } = {}, transformer = null, linkedDb = null) {\n\t\treturn super.jsonfy({ toDeepRef, toKind, ...options }, transformer = null, linkedDb);\n\t}\n}", "import { LQDeepDeepRef1 } from './LQDeepDeepRef1.js';\nimport { registry } from '../../registry.js';\n\nexport class LQDeepRef1 extends LQDeepDeepRef1 {\n\n\t/* SYNTAX RULES */\n\n\tstatic get syntaxRules() {\n\t\treturn [\n\t\t\t{\n\t\t\t\tsyntaxes: [\n\t\t\t\t\t[\n\t\t\t\t\t\t{ type: ['ColumnRef1', 'LQBackRefAbstraction'], as: 'left', peek: [1, 'operator', '~>'] }, // fk ~> col | (fk2 <~ fk1 <~ tbl) ~> col\n\t\t\t\t\t\t{ type: 'operator', value: '~>' },\n\t\t\t\t\t],\n\t\t\t\t\t[\n\t\t\t\t\t\t{ type: 'ColumnRef1', as: 'left', peek: [3, 'operator', '~>'] }, // tbl.fk ~> col | (fk2 <~ fk1 <~ tbl).fk ~> col\n\t\t\t\t\t\t{ type: 'operator', value: '~>' },\n\t\t\t\t\t]\n\t\t\t\t]\n\t\t\t},\n\t\t\t{ type: this._rightType, as: 'right' },\n\t\t];\n\t}\n\n\tstatic get syntaxPriority() { return 1; }\n\n\t/* API */\n\n\trhsTable(transformer, linkedDb) {\n\t\tif (this.left()?.qualifier?.() instanceof registry.LQBackRefAbstraction) {\n\t\t\treturn this._normalize().rhsTable(transformer, linkedDb);\n\t\t}\n\t\tif (this.left() instanceof registry.LQBackRefAbstraction) {\n\t\t\treturn this.left().expr()/* LQBackRef */.rhsTable(transformer, linkedDb);\n\t\t}\n\t\treturn super.rhsTable(transformer, linkedDb);\n\t}\n\n\t_normalize() {\n\t\tconst left = this.left();\n\t\tconst right = this.right();\n\t\tconst lhsOperandJson = left.qualifier().jsonfy();\n\t\tconst rhsOperandJson = { ...left.jsonfy(), qualifier: undefined, nodeName: registry.ColumnRef2.NODE_NAME };\n\t\tconst deepRef = LQDeepRef1.fromJSON({\n\t\t\tleft: lhsOperandJson,\n\t\t\tright: { nodeName: LQDeepDeepRef1.NODE_NAME, left: rhsOperandJson, right: right.jsonfy() }\n\t\t});\n\t\tthis._adoptNodes(deepRef);\n\t\treturn deepRef;\n\t}\n\n\tresolve(transformer, linkedDb, toKind = 1) {\n\t\tif (!transformer || !linkedDb) return;\n\t\tif (this.left()?.qualifier?.() instanceof registry.LQBackRefAbstraction) {\n\t\t\treturn this._normalize().resolve(transformer, linkedDb, toKind);\n\t\t}\n\n\t\tlet detail;\n\t\tif (this.right() instanceof registry.ColumnRef2) {\n\t\t\tdetail = this.right().clone({ toKind });\n\t\t} else if (this.right() instanceof registry.LQDeepDeepRef1) {\n\t\t\tdetail = this.right().clone({ toDeepRef: true, toKind });\n\t\t} else {\n\t\t\tdetail = this.right();\n\t\t}\n\n\t\tif (this.left() instanceof registry.LQBackRefAbstraction) {\n\t\t\tconst resolution = this.left().expr().resolve(transformer, linkedDb, toKind);\n\t\t\treturn { ...resolution, detail };\n\t\t}\n\n\t\tconst qualifiedLeftOperand = this.left().resolve(transformer, linkedDb);\n\n\t\tconst qualifiedRightTable = this.rhsTable(transformer, linkedDb);\n\n\t\tconst unqualifiedRightOperand = qualifiedRightTable.resultSchema().pkConstraint(true)?.columns()[0]?.resolve(transformer, linkedDb);\n\t\tif (!unqualifiedRightOperand) throw new Error(`[${this.parentNode || this}] The referenced RHS table ${qualifiedRightTable} does not have a primary key.`);\n\n\t\treturn {\n\t\t\tlhsOperand: qualifiedLeftOperand, // ColumnRef1\n\t\t\trhsOperand: unqualifiedRightOperand.clone({ toKind }), // ColumnRef2\n\t\t\trhsTable: qualifiedRightTable, // TableRef2\n\t\t\tdetail,\n\t\t};\n\t}\n}", "import { LQDeepRef1 } from './LQDeepRef1.js';\n\nexport class LQDeepRef2 extends LQDeepRef1 {\n\n\t/* SYNTAX RULES */\n\t\n\tstatic get _rightType() { return ['LQDeepDeepRef2', 'ColumnRef2', 'ColumnsConstructor']; } // for inheritance\n\n\tstatic get syntaxPriority() { return -1; }\n\n\t/* JSON API */\n\n\tresolve(transformer, linkedDb, toKind = 2) {\n\t\treturn super.resolve(transformer, linkedDb, toKind);\n\t}\n\n\tjsonfy({ toDeepRef = false, toKind = 2, ...options } = {}, transformer = null, linkedDb = null) {\n\t\treturn super.jsonfy({ toDeepRef, toKind, ...options }, transformer, linkedDb);\n\t}\n}", "import { AbstractClassicRef } from './abstracts/AbstractClassicRef.js';\nimport { AbstractNode } from '../../abstracts/AbstractNode.js';\nimport { registry } from '../../registry.js';\n\nexport class SchemaRef extends AbstractClassicRef {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'identifier', as: '.' },\n            { type: 'LQVersionSpec', as: 'version_spec', optional: true, autoSpacing: false }\n        ];\n    }\n\n    static get syntaxPriority() { return -1; }\n\n    /* AST API */\n\n    versionSpec() { return this._get('version_spec'); }\n\n    /* API */\n\n    lookup(deepMatchCallback = null, transformer = null, linkedDb = null) {\n        if (!linkedDb) return [];\n\n        const name = this._get('value');\n        const inGrepMode = !name && !deepMatchCallback;\n        let resultSet = [];\n\n        const resolve = (schemaSchema) => {\n            if (!(schemaSchema instanceof registry.SchemaSchema)) return false;\n            if (name && !schemaSchema.identifiesAs(this)) return false;\n            let result;\n            if (deepMatchCallback && !(result = deepMatchCallback(schemaSchema))) return false;\n\t\t\tif (result instanceof AbstractNode || Array.isArray(result)) return result;\n            \n            const resolvedSchemaRef1 = ColumnRef2.fromJSON({\n                ...schemaSchema.name().jsonfy({ nodeNames: false }),\n                ddl_schema: schemaSchema\n            });\n            this.parentNode._adoptNodes(resolvedSchemaRef1);\n\n            return resolvedSchemaRef1;\n        };\n\n        for (const schemaSchema of linkedDb.catalog) {\n            resultSet = resultSet.concat(resolve(schemaSchema) || []);\n            if (!inGrepMode && resultSet.length) break; // Matching current instance only\n        }\n\n        return resultSet;\n    }\n\n    jsonfy(options = {}, transformer = null, linkedDb = null) {\n        let resultJson;\n\n        if (options.deSugar\n            && !this.resultSchema()\n            && linkedDb) {\n            resultJson = this.resolve(transformer, linkedDb).jsonfy(/* IMPORTANT */);\n        } else {\n            resultJson = super.jsonfy(options, transformer, linkedDb);\n        }\n\n        if (options.deSugar && resultJson.version_spec) {\n\t\t\tresultJson = { ...resultJson, version_spec: undefined };\n\t\t}\n        return resultJson;\n    }\n}\n", "import { AbstractClassicRef } from './abstracts/AbstractClassicRef.js';\nimport { AbstractNode } from '../../abstracts/AbstractNode.js';\nimport { PathMixin } from '../../abstracts/PathMixin.js';\nimport { registry } from '../../registry.js';\n\nexport class TableRef1 extends PathMixin(AbstractClassicRef) {\n\n\t/* SYNTAX RULES */\n\n\tstatic get _qualifierType() { return 'SchemaRef'; }\n\n\tstatic get syntaxRules() {\n\t\treturn this.buildSyntaxRules({\n\t\t\tsyntax: [\n\t\t\t\t{ type: 'identifier', as: '.' },\n\t\t\t\t{ type: 'LQVersionSpec', as: 'version_spec', optional: true, autoSpacing: false }\n\t\t\t],\n\t\t\tautoSpacing: false,\n\t\t});\n\t}\n\n\t/* AST API */\n\n\tversionSpec() { return this._get('version_spec'); }\n\n\t/* API */\n\n\tdataType() { return registry.DataType.fromJSON({ value: 'SET' }); }\n\n\tcanReferenceInlineTables() { return true; }\n\n\tlookup(deepMatchCallback = null, transformer = null, linkedDb = null) {\n\t\tif (!transformer && !linkedDb) return [];\n\n\t\tconst name = this._get('value');\n\t\tconst inGrepMode = (!name || name === '*') && !deepMatchCallback;\n\t\tlet resultSet = [];\n\n\t\tconst resolve = (tableSchema, qualifierJson = undefined) => {\n\t\t\tif (tableSchema instanceof registry.JSONSchema && (!name || name === '*') && deepMatchCallback) {\n\t\t\t\t// We're trying to resolve a column,\n\t\t\t\t// and this is an \"unaliased\" derived query coming from statementContext.artifacts.get('tableSchemas')\n\t\t\t\treturn deepMatchCallback(tableSchema, qualifierJson);\n\t\t\t}\n\t\t\tif (!(tableSchema instanceof registry.TableSchema)) return false;\n\t\t\tif (name && name !== '*' && !tableSchema.identifiesAs(this)) return false;\n\t\t\t\n\t\t\tlet result;\n\t\t\tif (deepMatchCallback && !(result = deepMatchCallback(tableSchema, qualifierJson))) return false;\n\t\t\tif (result instanceof AbstractNode || Array.isArray(result)) return result;\n\n\t\t\tconst resolvedTableRef = this.constructor.fromJSON({\n\t\t\t\t...tableSchema.name().jsonfy({ nodeNames: false }),\n\t\t\t\tresult_schema: tableSchema,\n\t\t\t\tqualifier: qualifierJson,\n\t\t\t});\n\t\t\tthis.parentNode?._adoptNodes(resolvedTableRef);\n\n\t\t\treturn resolvedTableRef;\n\t\t};\n\n\t\t// 1. Resolve system refs statically\n\t\tconst systemTableRefs = (this.options.dialect || 'postgres') === 'postgres'\n            ? ['EXCLUDED']\n            : [];\n        if (systemTableRefs.includes(name?.toUpperCase()) && transformer) {\n            const tableSchema = [...transformer.statementContext.artifacts.get('tableSchemas')][0].resultSchema.clone({\n\t\t\t\trenameTo: { nodeName: registry.Identifier.NODE_NAME, value: name },\n\t\t\t});\n            return [].concat(resolve(tableSchema) || []);\n        }\n\n\t\t// 2. Resolve from InlineTables first?\n\t\tif (this.canReferenceInlineTables() && transformer) {\n\t\t\tlet statementContext = transformer.statementContext;\n\t\t\tlet originalType;\n\t\t\tdo {\n\t\t\t\tfor (const { type, resultSchema: tableSchema } of statementContext.artifacts.get('tableSchemas')) {\n\t\t\t\t\tif (originalType && originalType !== 'dml' && type === 'dml') {\n\t\t\t\t\t\t// The nested SELECT in an \"INSERT ... SELECT\" shouldn't see the INSERT\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (!originalType) {\n\t\t\t\t\t\toriginalType = type;\n\t\t\t\t\t}\n\t\t\t\t\tif (type === 'CTEItem' && deepMatchCallback) {\n\t\t\t\t\t\t// columns can't directly reference CTE output columns\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tresultSet = resultSet.concat(resolve(tableSchema) || []);\n\t\t\t\t\tif (!inGrepMode && resultSet.length) break; // Matching current instance only\n\t\t\t\t}\n\t\t\t} while ((inGrepMode || !resultSet.length) && (statementContext = statementContext.parentTransformer?.statementContext))\n\t\t}\n\n\t\t// 3. Resolve normally\n\t\tif (!deepMatchCallback/* we're not trying to qualify a column */ && (inGrepMode || !resultSet.length)) {\n\t\t\tresultSet = resultSet.concat((new registry.SchemaRef(this.qualifier()?.jsonfy() || {})).lookup(\n\t\t\t\t(schemaSchema) => {\n\n\t\t\t\t\treturn schemaSchema._get('entries').reduce((prev, tableSchema) => {\n\t\t\t\t\t\t//if (prev.length && !inGrepMode) return prev;\n\t\t\t\t\t\tconst newQualifierJson = {\n\t\t\t\t\t\t\t...schemaSchema.name().jsonfy({ nodeNames: false }),\n\t\t\t\t\t\t\tresult_schema: schemaSchema\n\t\t\t\t\t\t};\n\t\t\t\t\t\treturn prev.concat(resolve(tableSchema, newQualifierJson) || []);\n\t\t\t\t\t}, []);\n\n\t\t\t\t},\n\t\t\t\ttransformer,\n\t\t\t\tlinkedDb,\n\t\t\t));\n\t\t}\n\n\t\tif (name === '*') {\n            const compositeResult = registry.TableRef0.fromJSON({\n                value: this.value(),\n                result_schema: registry.JSONSchema.fromJSON({ entries: resultSet.map((s) => s.clone()) }, { assert: true }),\n            });\n            this.parentNode._adoptNodes(compositeResult);\n            resultSet = [compositeResult];\n        }\n\n\t\treturn resultSet;\n\t}\n\n\tjsonfy(options = {}, transformer = null, linkedDb = null) {\n\t\tlet resultJson;\n\n\t\tif (options.deSugar\n\t\t\t&& ((!this.qualifier() && Number(options.deSugar) > 1)\n\t\t\t\t|| !this.resultSchema())\n\t\t\t&& (transformer || linkedDb)) {\n\t\t\tresultJson = this.resolve(transformer, linkedDb).jsonfy(/* IMPORTANT */);\n\t\t\tif (Number(options.deSugar) < 2 && !this.qualifier()) {\n\t\t\t\tresultJson = { ...resultJson, qualifier: undefined };\n\t\t\t}\n\t\t} else {\n\t\t\tresultJson = super.jsonfy(options, transformer, linkedDb);\n\t\t}\n\n\t\tif (options.deSugar && resultJson.version_spec) {\n\t\t\tresultJson = { ...resultJson, version_spec: undefined };\n\t\t}\n\n\t\treturn resultJson;\n\t}\n}", "import { TableRef1 } from './TableRef1.js';\nimport { registry } from '../../registry.js';\n\nexport class TableRef0 extends TableRef1 {\n\n    /* SYNTAX RULES */\n\n    static get _qualifierType() { return ['SchemaRef']; }\n\n    static get syntaxRules() {\n        return this.buildSyntaxRules({ type: 'operator', as: '.', value: '*', autoSpacing: false });\n    }\n\n    static get syntaxPriority() { return -1; }\n\n    /* API */\n\n    dataType() { return registry.DataType.fromJSON({ value: 'SET' }); }\n}", "import { TableRef1 } from './TableRef1.js';\n\nexport class TableRef2 extends TableRef1 {\n\n    canReferenceInlineTables() { return false; }\n}", "import { Identifier } from './Identifier.js';\n\nexport class WindowRef extends Identifier {\n    \n    /* SYNTAX RULES */\n\n    static get syntaxPriority() { return -1; }\n}", "import { AbstractClassicExpr } from '../AbstractClassicExpr.js';\n\nexport class BindVar extends AbstractClassicExpr {\n\n\t/* SYNTAX RULES */\n\n    static get syntaxRules() { return { type: 'bind_var', as: '.' }; }\n\n    /* AST API */\n\n    value() { return this._get('value'); }\n}", "import { AbstractClassicExpr } from '../AbstractClassicExpr.js';\n\nexport class SystemVar extends AbstractClassicExpr {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() { return { type: 'system_var', as: '.' }; }\n\n    /* AST API */\n\n    value() { return this._get('value'); }\n}", "import { AbstractClassicExpr } from '../AbstractClassicExpr.js';\n\nexport class UserVar extends AbstractClassicExpr {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() { return { type: 'user_var', as: '.' }; }\n\n    /* AST API */\n\n    value() { return this._get('value'); }\n}", "import { AbstractClassicExpr } from './AbstractClassicExpr.js';\nimport * as exprs from './index.js';\n\nexport class Expr extends AbstractClassicExpr {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return { type: ExprNamesInOrder, expression: true };\n    }\n\n    /* API */\n\n    static [Symbol.hasInstance](instance) {\n        return instance instanceof AbstractClassicExpr || instance.constructor.name in exprs;\n    }\n}\n\nconst ExprNames = Object.keys(exprs);\nconst ExprNamesInOrder = ExprNames.filter((k) => {\n    return exprs[k] !== Expr && exprs[k].syntaxPriority !== -1;\n}).sort((a, b) => {\n    const comp = (exprs[b].syntaxPriority ?? 100) - (exprs[a].syntaxPriority ?? 100);\n    if (comp === 0) return exprs[b].prototype.isPrototypeOf(exprs[a].prototype) ? -1 : 1;\n    return comp;\n});\n", "import { PathMixin } from '../../abstracts/PathMixin.js';\nimport { Identifier } from '../../expr/index.js';\n\nexport class ColumnIdent extends PathMixin(Identifier) {\n\n    /* SYNTAX RULES */\n\n    static get _qualifierType() { return 'TableRef2'; }\n}", "import { Identifier } from '../../expr/ref/Identifier.js';\n\nexport class SchemaIdent extends Identifier {}\n", "import { PathMixin } from '../../abstracts/PathMixin.js';\nimport { Identifier } from '../../expr/index.js';\n\nexport class TableIdent extends PathMixin(Identifier) {\n\n\t/* SYNTAX RULES */\n\t\n\tstatic get _qualifierType() { return 'SchemaRef'; }\n}", "import { AbstractDiff } from '../../abstracts/AbstractDiff.js';\n\nexport class IndexDiff extends AbstractDiff {}", "import { AbstractSchema } from '../../abstracts/AbstractSchema.js';\n\nexport class IndexSchema extends AbstractSchema {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'Identifier', as: 'name', assert: true },\n        ];\n    }\n}", "import { AbstractDiff } from '../../abstracts/AbstractDiff.js';\n\nexport class SchemaDiff extends AbstractDiff {}", "import { AbstractSchema } from '../../abstracts/AbstractSchema.js';\nimport { registry } from '../../registry.js';\n\nexport class SchemaSchema extends AbstractSchema {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'SchemaIdent', as: 'name', assert: true },\n            {\n                type: 'paren_block',\n                syntax: { type: 'TableSchema', as: 'entries', arity: { min: 1 }, itemSeparator, singletons: 'BY_KEY', autoIndent: true },\n            },\n        ];\n    }\n\n    /* API */\n\n    tables() {\n        const result = [];\n        for (const entry of this) {\n            if (!(entry instanceof registry.TableSchema)) continue;\n            result.push(entry);\n        }\n        return result;\n    }\n}", "import { AbstractDiff } from '../../abstracts/AbstractDiff.js';\n\nexport class TableDiff extends AbstractDiff {}", "import { AbstractSchema } from '../../abstracts/AbstractSchema.js';\nimport { Transformer } from '../../Transformer.js';\nimport { registry } from '../../registry.js';\n\nexport class TableSchema extends AbstractSchema {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        const type = ['TablePKConstraint', 'TableFKConstraint', 'TableUKConstraint', 'PGTableEXConstraint', 'CheckConstraint', 'ColumnSchema'/* must come last */, 'IndexSchema'];\n        return [\n            { type: ['TableIdent', 'Identifier'/* to support mock names */], as: 'name' },\n            {\n                type: 'paren_block',\n                syntaxes: [\n                    { type, as: 'entries', arity: Infinity, itemSeparator, singletons: 'BY_KEY', optional: true, dialect: 'postgres', autoIndent: true },\n                    { type, as: 'entries', arity: { min: 1 }, itemSeparator, singletons: 'BY_KEY', dialect: 'mysql', autoIndent: true },\n                ],\n            },\n        ];\n    }\n\n    /* API */\n\n    columns() {\n        const result = [];\n        for (const entry of this) {\n            if (!(entry instanceof registry.ColumnSchema)) continue;\n            result.push(entry);\n        }\n        return result;\n    }\n\n    pkConstraint(normalized = false) {\n        for (const entry of this) {\n            if (entry instanceof registry.TablePKConstraint) return entry;\n            let pk;\n            if (normalized\n                && entry instanceof registry.ColumnSchema\n                && (pk = entry.pkConstraint())) {\n                const instance = registry.TablePKConstraint.fromJSON({\n                    ...pk.jsonfy(),\n                    nodeName: undefined,\n                    columns: [registry.ColumnRef2.fromJSON({ value: entry.name().value() })]\n                });\n                this._adoptNodes(instance);\n                return instance;\n            }\n        }\n    }\n\n    fkConstraints(normalized = false) {\n        const result = [];\n        for (const entry of this) {\n            if (entry instanceof registry.TableFKConstraint) {\n                result.push(entry);\n            }\n            let fk;\n            if (normalized\n                && entry instanceof registry.ColumnSchema\n                && (fk = entry.fkConstraint())) {\n                const instance = registry.TableFKConstraint.fromJSON({\n                    ...fk.jsonfy(),\n                    nodeName: undefined,\n                    columns: [registry.ColumnRef2.fromJSON({ value: entry.name().value() })]\n                });\n                this._adoptNodes(instance);\n                result.push(instance);\n            }\n        }\n        return result;\n    }\n\n    ukConstraints(normalized = false) {\n        const result = [];\n        for (const entry of this) {\n            if (entry instanceof registry.TableUKConstraint) {\n                result.push(entry);\n            }\n            let uk;\n            if (normalized\n                && entry instanceof registry.ColumnSchema\n                && (uk = entry.ukConstraint())) {\n                const instance = registry.TableUKConstraint.fromJSON({\n                    ...uk.jsonfy(),\n                    nodeName: undefined,\n                    columns: [registry.ColumnRef2.fromJSON({ value: entry.name().value() })]\n                });\n                this._adoptNodes(instance);\n                result.push(instance);\n            }\n        }\n        return result;\n    }\n\n    ckConstraints(normalized = false) {\n        const result = [];\n        for (const entry of this) {\n            if (entry instanceof registry.CheckConstraint) {\n                result.push(entry);\n            }\n            let ck;\n            if (normalized\n                && entry instanceof registry.ColumnSchema\n                && (ck = entry.ckConstraint()?.clone())) {\n                this._adoptNodes(ck);\n                result.push(ck);\n            }\n        }\n        return result;\n    }\n\n    jsonfy({ normalized = false, ...options } = {}, transformer = null, linkedDb = null) {\n        const columnLockedConstraints = [];\n\n        const consMap = {\n            [registry.ColumnPKConstraint.NODE_NAME]: registry.TablePKConstraint.NODE_NAME,\n            [registry.ColumnFKConstraint.NODE_NAME]: registry.TableFKConstraint.NODE_NAME,\n            [registry.ColumnUKConstraint.NODE_NAME]: registry.TableUKConstraint.NODE_NAME,\n            [registry.CheckConstraint.NODE_NAME]: registry.CheckConstraint.NODE_NAME,\n        };\n\n        if (normalized) {\n            transformer = new Transformer((node, defaultTransform) => {\n                if (node?.NODE_NAME in consMap && node.parentNode instanceof registry.ColumnSchema) {\n                    columnLockedConstraints.push({\n                        ...node.jsonfy(),\n                        nodeName: consMap[node.NODE_NAME],\n                        ...(!(node instanceof registry.CheckConstraint) ? { columns: [registry.ColumnRef2.fromJSON({ value: node.parentNode.name().value() })] } : {})\n                    });\n                    return; // Exclude from original column\n                }\n                return defaultTransform();\n            }, transformer);\n        }\n\n        let resultJson = super.jsonfy(options, transformer, linkedDb);\n\n        if (normalized) {\n            resultJson = {\n                ...resultJson,\n                entries: resultJson.entries.concat(columnLockedConstraints)\n            }\n        }\n\n        return resultJson;\n    }\n}", "import { AbstractStmt } from '../abstracts/AbstractStmt.js';\r\n\r\nexport class DDLStmt extends AbstractStmt {\r\n    \r\n\r\n    /* SYNTAX RULES */\r\n\r\n    static get syntaxRules() { return { type: ['CreateTableStmt'] }; }\r\n}\r\n", "import { DDLStmt } from './DDLStmt.js';\n\nexport class CreateTableStmt extends DDLStmt {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', value: 'CREATE' },\n            {\n                optional: true,\n                syntaxes: [\n                    { type: 'keyword', as: 'temporary_kw', value: 'TEMPORARY', booleanfy: true },\n                    { type: 'keyword', as: 'temporary_kw', value: 'TEMP', booleanfy: true, dialect: 'postgres' },\n                ],\n            },\n            { type: 'keyword', value: 'TABLE' },\n            {\n                optional: true,\n                syntax: [\n                    { type: 'keyword', as: 'if_not_exists', value: 'IF', booleanfy: true },\n                    { type: 'operator', value: 'NOT' },\n                    { type: 'keyword', value: 'EXISTS' },\n                ],\n            },\n            { type: 'TableSchema', as: 'argument' },\n            { type: ['ConfigAssignmentExprAlt1', 'ConfigAssignmentExprAlt2'], as: 'my_create_options', arity: Infinity, dialect: 'mysql' }\n        ];\n    }\n\n    /* AST API */\n\n    temporaryKW() { return this._get('temporary_kw'); }\n\n    ifNotExists() { return this._get('if_not_exists'); }\n\n    argument() { return this._get('argument'); }\n\n    myCreateOptions() { return this._get('my_create_options'); }\n}", "export * from './clauses/index.js';\nexport * from './constructors/index.js';\nexport * from './expr/index.js';\nexport * from './TA/index.js';\nexport { DeleteStmt } from './DeleteStmt.js';\nexport { InsertStmt } from './InsertStmt.js';\nexport { MYSetStmt } from './MYSetStmt.js';\nexport { UpdateStmt } from './UpdateStmt.js';\nexport { UpsertStmt } from './UpsertStmt.js';\n", "import { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\n\nexport class MYOnDuplicateKeyUpdateClause extends AbstractNodeList {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return {\n            dialect: 'mysql',\n            syntax: [\n                { type: 'keyword', value: 'ON' },\n                { type: 'keyword', value: 'DUPLICATE' },\n                { type: 'keyword', value: 'KEY' },\n                { type: 'keyword', value: 'UPDATE' },\n                { type: 'AssignmentExpr', as: 'entries', arity: { min: 1 }, itemSeparator, assert: true, autoIndent: true },\n            ]\n        };\n    }\n}", "import { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\n\nexport class MYPartitionClause extends AbstractNodeList {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return {\n            dialect: 'mysql',\n            syntax: [\n                { type: 'keyword', value: 'PARTITION' },\n                { type: 'Identifier', as: 'entries', arity: { min: 1 }, itemSeparator, assert: true }\n            ],\n        };\n    }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class PGConflictTarget extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return {\n            syntaxes: [\n                [\n                    { type: 'keyword', value: 'ON' },\n                    { type: 'keyword', value: 'CONSTRAINT' },\n                    { type: 'Identifier', as: 'constraint_name', assert: true }\n                ],\n                [\n                    {\n                        type: 'paren_block',\n                        syntax: { type: 'PGConflictTargetIndexSpec', as: 'index_list', arity: { min: 1 }, itemSeparator, assert: true },\n                        autoIndent: true,\n                    },\n                    { type: 'WhereClause', as: 'where_clause', optional: true, autoIndent: true },\n                ],\n            ],\n        };\n    }\n\n    /* AST API */\n\n    constraintName() { return this._get('constraint_name'); }\n\n    indexList() { return this._get('index_list'); }\n\n    whereClause() { return this._get('where_clause'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class PGConflictTargetIndexSpec extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            {\n                syntaxes: [\n                    { type: 'ColumnRef2', as: 'column_name' },\n                    { type: 'paren_block', syntax: { type: 'Expr', as: 'expr', assert: true }, autoIndent: true },\n                    { type: 'CallExpr', as: 'expr' }, // Must come after the parens option\n                ],\n            },\n            {\n                optional: true,\n                syntax: [\n                    { type: 'operator', value: 'COLLATE' },\n                    { type: 'string_literal', as: 'collation', assert: true },\n                ],\n            },\n            { type: 'Identifier', as: 'opclass', optional: true },\n        ];\n    }\n\n    /* AST API */\n\n    columnName() { return this._get('column_name'); }\n\n    expr() { return this._get('expr'); }\n\n    collation() { return this._get('collation'); }\n\n    opclass() { return this._get('opclass'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class PGDefaultValuesClause extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            dialect: 'postgres',\n            syntax: [\n                { type: 'keyword', as: '.', value: 'DEFAULT' },\n                { type: 'keyword', value: 'VALUES' },\n            ]\n        };\n    }\n}", "import { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\n\nexport class PGOnConflictClause extends AbstractNodeList {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return {\n            dialect: 'postgres',\n            syntax: [\n                { type: 'keyword', value: 'ON' },\n                { type: 'keyword', value: 'CONFLICT' },\n                {\n                    syntaxes: [\n                        [\n                            { type: 'PGConflictTarget', as: 'conflict_target', optional: true },\n                            { type: 'keyword', as: 'do_nothing', value: 'DO' },\n                            { type: 'keyword', value: 'NOTHING' },\n                        ],\n                        [\n                            { type: 'PGConflictTarget', as: 'conflict_target' },\n                            { type: 'keyword', value: 'DO' },\n                            { type: 'keyword', value: 'UPDATE' },\n                            { type: 'keyword', value: 'SET' },\n                            { type: 'AssignmentExpr', as: 'entries', arity: { min: 1 }, itemSeparator, assert: true, autoIndent: true },\n                            { type: 'WhereClause', as: 'where_clause', optional: true, autoIndent: true },\n                        ],\n                    ],\n                }\n            ],\n        };\n    }\n\n    /* AST API */\n\n    conflictTarget() { return this._get('conflict_target'); }\n\n    doNothing() { return this._get('do_nothing'); }\n\n    whereClause() { return this._get('where_clause'); }\n}", "import { DDLSchemaMixin } from '../../abstracts/DDLSchemaMixin.js';\nimport { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\nimport { registry } from '../../registry.js';\nimport { _eq } from '../../util.js';\n\nexport class SelectList extends DDLSchemaMixin(AbstractNodeList) {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return { type: 'SelectItem', as: 'entries', arity: { min: 1 }, itemSeparator, assert: true, autoIndent: 2 };\n    }\n\n    /* JSON API */\n\n    jsonfy(options = {}, transformer = null, linkedDb = null) {\n        let resultJson = super.jsonfy(options, transformer, linkedDb);\n        if (!options.deSugar) return resultJson;\n\n        let resolvedOutputList = [];\n\n        const shouldFlattenUnaliasedRootObjects = Number(options.deSugar) > 2;\n        const shouldDedupe = false;\n\n        const addOutputItem = (itemJson) => {\n            if (shouldDedupe) {\n                resolvedOutputList = resolvedOutputList.reduce((result, existing) => {\n                    if (itemJson.alias && existing.alias && _eq(itemJson.alias.value, existing.alias.value, itemJson.alias.delim || existing.alias.delim)) {\n                        return result;\n                    }\n                    return result.concat(existing);\n                }, []);\n            }\n            resolvedOutputList = resolvedOutputList.concat(itemJson);\n        };\n\n        for (const [i, selectItemJson] of resultJson.entries.entries()) {\n\n            if (selectItemJson.expr.value === '*') {\n                for (const columnRef of selectItemJson.result_schema) {\n                    const exprJson = columnRef.jsonfy();\n                    const aliasJson = { nodeName: registry.SelectItemAlias.NODE_NAME, as_kw: true, value: exprJson.value, delim: exprJson.delim };\n                    addOutputItem({\n                        nodeName: registry.SelectItem.NODE_NAME,\n                        expr: exprJson,\n                        alias: aliasJson,\n                        result_schema: exprJson.result_schema.clone(),\n                        _originalStarJson: selectItemJson\n                    });\n                }\n            } else if (shouldFlattenUnaliasedRootObjects\n                && this.entries()[i]/* original */.expr() instanceof registry.LQObjectLiteral\n                && !this.entries()[i]/* original */.alias()) {\n                // Start by making pairs of arguments\n                const [argPairs] = selectItemJson.expr.arguments.reduce(([argPairs, key], value) => {\n                    if (!key) return [argPairs, value];\n                    return [[...argPairs, [key, value]]];\n                }, [[]]);\n\n                const resultSchemas = selectItemJson.expr.result_schema.entries();\n\n                for (let i = 0; i < argPairs.length; i++) {\n                    addOutputItem({\n                        nodeName: registry.SelectItem.NODE_NAME,\n                        expr: argPairs[i][1],\n                        alias: { ...argPairs[i][0], nodeName: registry.SelectItemAlias.NODE_NAME, as_kw: true },\n                        result_schema: resultSchemas[i],\n                    });\n                }\n            } else {\n                addOutputItem(selectItemJson);\n            }\n        }\n\n        return {\n            ...resultJson,\n            entries: resolvedOutputList,\n        };\n    }\n\n    finalizeJSON(resultJson, transformer, linkedDb, options) {\n        const shouldDeSugarStars = Number(options.deSugar) > 1;\n        let starsFound;\n\n        const [\n            selectItems,\n            outputSchemas\n        ] = resultJson.entries.reduce(([a, b], { _originalStarJson, ...fieldJson }) => {\n\n            if (_originalStarJson) {\n                starsFound = true;\n            }\n\n            if (_originalStarJson && !shouldDeSugarStars) {\n                if (!_originalStarJson.result_schema) {\n                    _originalStarJson.result_schema = registry.JSONSchema.fromJSON({ entries: [] }, { assert: true });\n                }\n                _originalStarJson.result_schema._add('entries', fieldJson.result_schema);\n                return [\n                    a.concat(_originalStarJson),\n                    b.concat(fieldJson.result_schema.clone())\n                ];\n            }\n\n            if (!fieldJson.result_schema) {\n                const fieldNode = registry.SelectItem.fromJSON(fieldJson, this.options);\n                this._adoptNodes(fieldNode);\n                fieldJson = fieldNode.jsonfy(options, transformer, linkedDb);\n            }\n\n            return [\n                a.concat(fieldJson),\n                b.concat(fieldJson.result_schema.clone())\n            ];\n        }, [[], []]);\n\n        // Apply now\n        resultJson = {\n            ...resultJson,\n            entries: starsFound && !shouldDeSugarStars ? [...new Set(selectItems)] : selectItems,\n            result_schema: registry.JSONSchema.fromJSON({ entries: outputSchemas }, { assert: true }),\n        };\n        transformer.statementContext.artifacts.set('outputSchemas', new Set(outputSchemas));\n\n        return resultJson;\n    }\n}", "import { SelectList } from '../../dql/clauses/SelectList.js';\n\nexport class ReturningClause extends SelectList {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', value: 'RETURNING' },\n            ...[].concat(super.syntaxRules),\n        ];\n    }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class PGWhereCurrentClause extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            dialect: 'postgres',\n            syntax: [\n                { type: 'keyword', value: 'WHERE' },\n                { type: 'keyword', value: 'CURRENT OF' },\n                { type: 'identifier', as: 'cursor_name', assert: true }\n            ]\n        };\n    }\n\n    /* AST API */\n\n    cursorName() { return this._get('cursor_name'); }\n}", "import { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\n\nexport class SetClause extends AbstractNodeList {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'keyword', value: 'SET' },\n            { type: 'AssignmentExpr', as: 'entries', arity: { min: 1 }, itemSeparator, assert: true, autoIndent: 2 },\n        ];\n    }\n}", "import { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\n\nexport class UsingFromClause extends AbstractNodeList {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'keyword', value: 'USING' },\n            { type: 'FromItem', as: 'entries', arity: { min: 1 }, itemSeparator, assert: true }\n        ];\n    }\n}", "import { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\n\nexport class ColumnsConstructor extends AbstractNodeList {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return {\n            syntax: [\n                {\n                    type: 'paren_block',\n                    syntax: { type: ['LQDeepRef2', 'ColumnRef2'], as: 'entries', arity: Infinity, itemSeparator, autoIndent: 10 },\n                },\n            ],\n        };\n    }\n\n    static get syntaxPriority() { return -1; }\n}", "import { DDLSchemaMixin } from '../../abstracts/DDLSchemaMixin.js';\nimport { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\n\nexport class ValuesConstructor extends DDLSchemaMixin(AbstractNodeList) {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return {\n            syntaxes: [\n                [\n                    { type: 'keyword', value: 'VALUES' },\n                    { type: ['TypedRowConstructor', 'RowConstructor'], as: 'entries', arity: { min: 1 }, itemSeparator, assert: true, autoIndent: 2 }\n                ],\n                {\n                    dialect: 'mysql',\n                    syntax: [\n                        { type: 'keyword', value: ['VALUES', 'VALUE'] },\n                        { type: ['TypedRowConstructor', 'RowConstructor'], as: 'entries', arity: { min: 1 }, itemSeparator, assert: true, autoIndent: 2 }\n                    ]\n                },\n            ],\n        };\n    }\n\n    static get syntaxPriority() { return -1; }\n\n    /* JSON API */\n\n    jsonfy(options = {}, transformer = null, linkedDb = null) {\n        let resultJson = super.jsonfy({ ...options, forceDeSugar: options.deSugar }, transformer, linkedDb);\n        if (options.deSugar) {\n            const row1_resultSchema = resultJson.entries?.[0]?.result_schema;\n            resultJson = {\n                ...resultJson,\n                result_schema: row1_resultSchema?.clone()\n            }\n        }\n        return resultJson;\n    }\n}", "import { BinaryExpr } from '../../expr/op/BinaryExpr.js';\n\nexport class AssignmentExpr extends BinaryExpr {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: ['LQDeepRef2', 'ColumnsConstructor', 'ColumnRef2'], as: 'left', dialect: 'postgres' },\n            { type: ['LQDeepRef2', 'ColumnRef1'], as: 'left', dialect: 'mysql' },\n            { type: 'operator', as: 'operator', value: '=' },\n            { type: ['ValuesTableLiteral', 'DerivedQuery', 'Expr'], as: 'right' },\n        ];\n    }\n}", "import { BinaryExpr } from '../../expr/op/BinaryExpr.js';\n\nexport class ConfigAssignmentExpr extends BinaryExpr {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', as: 'my_default_kw', value: 'DEFAULT', booleanfy: true, dialect: 'mysql', optional: true },\n            {\n                syntaxes: [\n                    { type: 'keyword', as: 'left' },\n                    { type: 'identifier', as: 'left' },\n                ],\n            },\n            { type: 'operator', as: 'operator', value: '=' },\n            {\n                syntaxes: [\n                    { type: 'Expr', as: 'right' },\n                    { type: 'keyword', as: 'right' },\n                ],\n            }\n        ];\n    }\n\n    /* API */\n\n    myDefaultKW() { return this._get('my_default_kw'); }\n}", "import { BinaryExpr } from '../../expr/op/BinaryExpr.js';\n\nexport class ConfigAssignmentExprAlt1 extends BinaryExpr {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', as: 'my_default_kw', value: 'DEFAULT', booleanfy: true, dialect: 'mysql', optional: true },\n            {\n                syntaxes: [\n                    { type: 'keyword', as: 'left' },\n                    { type: 'identifier', as: 'left' },\n                ],\n            },\n            { type: 'operator', as: 'operator', value: '=', optional: true },\n            {\n                syntaxes: [\n                    { type: 'Expr', as: 'right' },\n                    { type: 'keyword', as: 'right' },\n                ],\n            }\n        ];\n    }\n\n    /* API */\n\n    myDefaultKW() { return this._get('my_default_kw'); }\n}", "import { BinaryExpr } from '../../expr/op/BinaryExpr.js';\n\nexport class ConfigAssignmentExprAlt2 extends BinaryExpr {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', as: 'default_kw', value: 'DEFAULT', booleanfy: true, optional: true },\n            {\n                syntaxes: [\n                    { type: 'keyword', as: 'left' },\n                    { type: 'identifier', as: 'left' },\n                ],\n            },\n            {\n                optional: true,\n                syntax: [\n                    { type: 'operator', as: 'operator', value: '=' },\n                    {\n                        syntaxes: [\n                            { type: 'Expr', as: 'right' },\n                            { type: 'keyword', as: 'right' },\n                        ],\n                    },\n                ],\n            }\n        ];\n    }\n\n    /* API */\n\n    myDefaultKW() { return this._get('my_default_kw'); }\n}", "import { BinaryExpr } from '../../expr/op/BinaryExpr.js';\n\nexport class MYVarAssignmentExpr extends BinaryExpr {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            dialect: 'mysql',\n            syntax: [\n                { type: ['UserVar', 'SystemVar'], as: 'left' },\n                { type: 'operator', as: 'operator', value: ['=', ':='] },\n                { type: 'Expr', as: 'right' },\n            ],\n        };\n    }\n}", "import { DDLSchemaMixin } from '../../abstracts/DDLSchemaMixin.js';\nimport { AbstractNode } from '../../abstracts/AbstractNode.js';\nimport { registry } from '../../registry.js';\n\nexport class TableAbstraction2 extends DDLSchemaMixin(AbstractNode) {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', as: 'pg_only_kw', value: 'ONLY', optional: true, dialect: 'postgres' },\n            { type: 'TableRef1', as: 'table_ref', assert: true },\n            { type: 'operator', as: 'pg_star_ref', value: '*', booleanfy: true, optional: true, dialect: 'postgres' },\n            { type: 'SelectItemAlias', as: 'alias', optional: true },\n        ];\n    }\n\n    /* AST API */\n\n    tableRef() { return this._get('table_ref'); }\n\n    alias() { return this._get('alias'); }\n\n    // -- Postgres\n\n    pgOnlyKW() { return this._get('pg_only_kw'); }\n\n    pgStarRef() { return this._get('pg_star_ref'); }\n\n    /* SCHEMA API */\n\n    deriveAlias() {\n        let derivedAlias;\n        if (this.alias()) {\n            derivedAlias = this.alias();\n        } else {\n            derivedAlias = registry.SelectItemAlias.fromJSON({\n                as_kw: true,\n                value: this.tableRef().value(),\n                delim: this.tableRef()._get('delim'),\n            });\n        }\n        return derivedAlias;\n    }\n\n    jsonfy(options = {}, transformer = null, linkedDb = null) {\n        let resultJson = super.jsonfy(options, transformer, linkedDb);\n        if (options.deSugar) {\n\n            const derivedAliasJson = resultJson.alias || this.deriveAlias().jsonfy();\n\n            const schemaIdent = {\n                nodeName: registry.Identifier.NODE_NAME,\n                value: derivedAliasJson.value,\n                delim: derivedAliasJson.delim,\n            };\n\n            let resultSchema = resultJson.table_ref.result_schema.clone({ renameTo: schemaIdent });\n            if (resultJson.alias) {\n                resultSchema = resultSchema.clone({ renameTo: { nodeName: registry.Identifier.NODE_NAME, value: resultJson.alias.value, delim: resultJson.alias.delim } });\n            }\n\n            transformer.statementContext.artifacts.get('tableSchemas').add({ resultSchema });\n\n            const applicableAliasJson = Number(options.deSugar) > 1\n                && derivedAliasJson\n                || resultJson.alias;\n            resultJson = {\n                ...resultJson,\n                alias: applicableAliasJson,\n                result_schema: resultSchema,\n            };\n        }\n\n        return resultJson;\n    }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class TableAbstraction1 extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'TableRef1', as: 'table_ref' },\n            {\n                optional: true,\n                dialect: 'mysql',\n                syntax: [\n                    { type: 'punctuation', value: '.', autoSpacing: false },\n                    { type: 'operator', as: 'my_star_ref', value: '*', booleanfy: true, autoSpacing: false },\n                ],\n            },\n        ];\n    }\n\n    /* AST API */\n\n    tableRef() { return this._get('table_ref'); }\n\n    myStarRef() { return this._get('my_star_ref'); }\n}", "import { Transformer } from '../Transformer.js';\nimport { registry } from '../registry.js';\nimport { _eq } from '../util.js';\n\nexport const SelectorStmtMixin = (Class) => class extends Class {\n\n    get isSelectorStmt() { return true; }\n\n    /* DESUGARING API */\n\n    jsonfy(options = {}, transformer = null, linkedDb = null) {\n        if (!options.deSugar) return super.jsonfy(options, transformer, linkedDb);\n\n        const {\n            ColumnRef1,\n            ColumnRef2,\n            AggrCallExpr,\n            LQBackRefAbstraction,\n            LQDeepRef1,\n            LQBackRef,\n        } = registry;\n\n        transformer = new Transformer((node, defaultTransform, keyHint, { deSugar/* EXCLUSION */, asAggr/* EXCLUSION */, ...$options }) => {\n\n            const isSpecialColumnRef1 = (node) => {\n                return node instanceof ColumnRef1\n                    && node.qualifier() instanceof LQBackRefAbstraction;\n            };\n\n            const specialColumnRef1ToDeepRef = (columnRef) => {\n                const lhsOperandJson = columnRef.qualifier().jsonfy();\n                const rhsOperandJson = { ...columnRef.jsonfy(), qualifier: undefined, nodeName: ColumnRef2.NODE_NAME };\n                const deepRef = LQDeepRef1.fromJSON({\n                    left: lhsOperandJson,\n                    right: rhsOperandJson\n                });\n                columnRef.parentNode._adoptNodes(deepRef);\n                return deepRef;\n            };\n\n            const toAggr = (nodeJson) => {\n                return {\n                    nodeName: AggrCallExpr.NODE_NAME,\n                    name: ($options.toDialect || this.options.dialect) === 'mysql' ? 'JSON_ARRAYAGG' : 'JSON_AGG',\n                    arguments: [nodeJson],\n                };\n            };\n\n            // 1. DeSugar special column refs \"(fk <~ tbl).col\" to deep refs\n            if (isSpecialColumnRef1(node)) {\n                node = specialColumnRef1ToDeepRef(node);\n            }\n\n            // 2. DeSugar deep refs to bare column refs\n            if (node instanceof LQDeepRef1) {\n                let { select, detail } = this.createSelectorDimension(node, transformer, linkedDb, { ...$options, asAggr });\n                const detailJson = asAggr\n                    ? toAggr(detail.jsonfy())\n                    : detail.jsonfy();\n                return select(detailJson);\n            }\n\n            // ...and for when we still hit back refs \"fk <~ tbl\"\n            if (node instanceof LQBackRef || node instanceof LQBackRefAbstraction) {\n                if (node instanceof LQBackRefAbstraction) {\n                    node = node.expr();\n                }\n                const { alias } = this.createSelectorDimension(node, transformer, linkedDb, $options);\n                return alias();\n            }\n\n            // Other\n            return defaultTransform();\n        }, transformer, this/* IMPORTANT */);\n\n        return super.jsonfy(options, transformer, linkedDb);\n    }\n\n    createSelectorDimension(LQRef, transformer, linkedDb, { asAggr = false, ...$options } = {}) {\n        const { lhsOperand, rhsOperand, rhsTable, detail } = LQRef.resolve(transformer, linkedDb);\n        const selectorDimensions = transformer.statementContext.artifacts.get('selectorDimensions');\n\n        const {\n            CompleteSelectStmt,\n            DerivedQuery,\n            FromClause,\n            JoinClause,\n            OnClause,\n            GroupByClause,\n            GroupingElement,\n            FromItem,\n            SelectList,\n            SelectItem,\n            FromItemAlias,\n            SelectItemAlias,\n            TableRef1,\n            ColumnRef1,\n            BinaryExpr,\n        } = registry;\n\n        const $dimensionID = `dimension${asAggr ? '/g' : ''}|${[lhsOperand, rhsOperand, rhsTable].join('|')}`;\n        const dimensionID = transformer.statementContext.hash($dimensionID, 'join');\n\n        if (selectorDimensions?.has(dimensionID)) {\n            return { ...selectorDimensions.get(dimensionID), detail };\n        }\n\n        const rands = new Map;\n\n        // Mask \"rhsOperand\"\n        const rhsOperandMask = transformer.rand('key', rands);\n        const rhsOperandJson = rhsOperand.jsonfy();\n        const fieldSpec = {\n            nodeName: SelectItem.NODE_NAME,\n            expr: rhsOperandJson,\n            alias: { nodeName: SelectItemAlias.NODE_NAME, as_kw: true, value: rhsOperandMask },\n        };\n\n        // Compose:\n        // - LEFT JOIN ( SELECT [fieldSpec] FROM <rhsTable> [GROUP BY]? )\n        // - AS <dimensionID>\n        // - ON <dimensionID>.<rhsOperandMask> = <lhsOperand>\n        const joinJson = {\n            nodeName: JoinClause.NODE_NAME,\n            join_type: 'LEFT',\n            expr: {\n                nodeName: DerivedQuery.NODE_NAME,\n                // SELECT <fieldSpec>\n                expr: {\n                    nodeName: CompleteSelectStmt.NODE_NAME,\n                    select_list: { nodeName: SelectList.NODE_NAME, entries: [fieldSpec] },\n                    // FROM <rhsTable>\n                    from_clause: {\n                        nodeName: FromClause.NODE_NAME,\n                        entries: [{ nodeName: FromItem.NODE_NAME, expr: rhsTable.jsonfy({ ...$options, deSugar: 0 }) }]\n                    },\n                    // GROUP BY <rhsOperandMask>\n                    group_by_clause: asAggr ? {\n                        nodeName: GroupByClause.NODE_NAME,\n                        entries: [{ nodeName: GroupingElement.NODE_NAME, expr: { nodeName: ColumnRef1.NODE_NAME, value: rhsOperandMask } }]\n                    } : undefined,\n                }\n            },\n            // AS <dimensionID>\n            alias: { nodeName: FromItemAlias.NODE_NAME, as_kw: true, value: dimensionID },\n            // ON <dimensionID>.<rhsOperandMask> = <lhsOperand>\n            condition_clause: {\n                nodeName: OnClause.NODE_NAME,\n                expr: {\n                    nodeName: BinaryExpr.NODE_NAME,\n                    operator: '=',\n                    left: lhsOperand.jsonfy({ ...$options, deSugar: 0 }, transformer, linkedDb),\n                    right: {\n                        nodeName: ColumnRef1.NODE_NAME,\n                        qualifier: { nodeName: TableRef1.NODE_NAME, value: dimensionID },\n                        value: rhsOperandMask\n                    },\n                }\n            },\n        };\n\n        // Join ALias as Table ref...\n        const alias = () => ({ nodeName: TableRef1.NODE_NAME, value: dimensionID });\n\n        // Add entry...\n        const select = (detail) => {\n            const selectAlias = transformer.rand('ref', rands);\n\n            // Compose:\n            // - [...detail] AS <selectAlias>\n            joinJson.expr.expr.select_list.entries.push({\n                nodeName: SelectItem.NODE_NAME,\n                expr: detail,\n                alias: { nodeName: SelectItemAlias.NODE_NAME, as_kw: true, value: selectAlias },\n            });\n\n            return {\n                nodeName: ColumnRef1.NODE_NAME,\n                qualifier: { nodeName: TableRef1.NODE_NAME, value: dimensionID },\n                value: selectAlias,\n            };\n        };\n\n        const selectorDimension = { id: dimensionID, type: 'join', query: joinJson, alias, select, detail };\n\n        selectorDimensions.set(dimensionID, selectorDimension);\n\n        return selectorDimension;\n    }\n\n    finalizeSelectorJSON(resultJson, transformer, linkedDb, options) {\n        let rewrittenJoinEntries;\n        [\n            resultJson,\n            rewrittenJoinEntries,\n        ] = this.preprocessSelectorDimensions(resultJson, transformer, linkedDb, options);\n        \n        resultJson = {\n            ...resultJson,\n            join_clauses: resultJson.join_clauses?.slice(0) || [],\n        };\n\n        for (const joinJson of rewrittenJoinEntries) {\n            const joinNode = registry.JoinClause.fromJSON(joinJson, this.options);\n            this._adoptNodes(joinNode);\n\n            const joinJson2 = transformer.transform(joinNode, ($options = options, childTransformer = transformer) => {\n                return joinNode.jsonfy({ ...$options, deSugar: 2 }, childTransformer, linkedDb);\n            }, null, options);\n\n            resultJson.join_clauses.push(joinJson2);\n        }\n\n        return resultJson;\n    }\n\n    preprocessSelectorDimensions(resultJson, transformer, linkedDb, options) {\n\n        const selectorDimensions = transformer.statementContext.artifacts.get('selectorDimensions');\n        if (!selectorDimensions.size) {\n            return [resultJson, []];\n        }\n        \n        if (this.options.dialect === 'postgres' && (this instanceof registry.DeleteStmt || this instanceof registry.UpdateStmt)) {\n            if (resultJson.where_clause?.cursor_name) {\n                throw new Error(`Deep/Back Refs are currently not supported with a \"WHERE CURRENT OF...\" statement`);\n            }\n\n            const {\n                DerivedQuery,\n                CompleteSelectStmt,\n                SelectList,\n                SelectItem,\n                FromItemAlias,\n                FromClause,\n                WhereClause,\n                TableRef1,\n                BinaryExpr,\n                FromItem,\n            } = registry;\n\n            const rand = transformer.rand('join');\n\n            // Each table involved in a Deep/BackRef should have a corresponding entry\n            // in the \"FROM\" list where we have the chance to establish our JOIN\n            // with a corresponding extra \"WHERE\" clause that correlates the generated table with the original table\n\n            const tableExpr = resultJson.table_expr;\n\n            const tblAliasOriginal = tableExpr.alias.value;\n            const tblAliasOriginal_delim = tableExpr.alias.delim;\n            const tblAliasRewrite = `${rand}:${tblAliasOriginal}`;\n\n            const pkConstraint = tableExpr.result_schema.pkConstraint(true);\n            const pkColumnRef = pkConstraint?.columns()[0].jsonfy({ toKind: 1 });\n\n            let pgGeneratedFromItem;\n            let pgGeneratedWhereClause\n\n            const createCorrelationExpr = (columnRef) => {\n                return {\n                    nodeName: BinaryExpr.NODE_NAME,\n                    left: {\n                        ...columnRef, qualifier: {\n                            nodeName: TableRef1.NODE_NAME,\n                            value: tblAliasOriginal,\n                            delim: tblAliasOriginal_delim\n                        },\n                    },\n                    operator: '=',\n                    right: {\n                        ...columnRef, qualifier: {\n                            nodeName: TableRef1.NODE_NAME,\n                            value: tblAliasRewrite\n                        },\n                    },\n                };\n            };\n\n            let selectItems;\n            const createOrPatchAFromEntry = (columnRef) => {\n                if (!_eq(columnRef.qualifier.value, tblAliasOriginal, columnRef.qualifier.delim || tblAliasOriginal_delim)) {\n                    return columnRef;\n                }\n\n                if (!pgGeneratedFromItem) {\n                    // Compose:\n                    // - ( SELECT [] FROM <tblRefOriginal> )\n                    // - AS <tblAliasRewrite>\n                    const fromItem = {\n                        nodeName: FromItem.NODE_NAME,\n                        expr: {\n                            nodeName: DerivedQuery.NODE_NAME,\n                            expr: {\n                                // SELECT <...>\n                                nodeName: CompleteSelectStmt.NODE_NAME,\n                                select_list: { nodeName: SelectList.NODE_NAME, entries: [] },\n                                from_clause: {\n                                    // FROM <tblRefOriginal>\n                                    nodeName: FromClause.NODE_NAME,\n                                    entries: [{\n                                        nodeName: FromItem.NODE_NAME,\n                                        expr: tableExpr.table_ref,\n                                    }],\n                                },\n                            },\n                        },\n                        // AS <tblAliasRewrite>\n                        alias: { nodeName: FromItemAlias.NODE_NAME, as_kw: true, value: tblAliasRewrite },\n                    };\n\n                    selectItems = fromItem.expr.expr.select_list.entries;\n\n                    // Compose:\n                    // - WHERE <tblAliasOriginal.colRefOriginal> = <tblAliasRewrite.colRefRewrite>\n                    if (pkColumnRef) {\n                        selectItems.push({\n                            nodeName: SelectItem.NODE_NAME,\n                            expr: pkColumnRef,\n                        });\n                        pgGeneratedWhereClause = {\n                            nodeName: WhereClause.NODE_NAME,\n                            expr: createCorrelationExpr(pkColumnRef),\n                        };\n                    }\n                    // Declare entry...\n                    pgGeneratedFromItem = fromItem;\n                }\n\n                // 1. Select the rewritten ref\n                if (!selectItems.find((fieldJson) => _eq(fieldJson.expr.value, columnRef.value, fieldJson.expr.delim || columnRef.delim))) {\n                    selectItems.push({ nodeName: SelectItem.NODE_NAME, expr: columnRef });\n                }\n\n                // 2. Use ewritten ref for correlation in the absence of a primary key\n                if (!pkColumnRef) {\n                    let whereExpr = createCorrelationExpr(columnRef);\n                    if (pgGeneratedWhereClause) {\n                        whereExpr = {\n                            nodeName: BinaryExpr.NODE_NAME,\n                            left: pgGeneratedWhereClause.expr,\n                            operator: 'AND',\n                            right: whereExpr\n                        };\n                    }\n                    pgGeneratedWhereClause = {\n                        nodeName: WhereClause.NODE_NAME,\n                        expr: whereExpr,\n                    };\n                }\n\n                return {\n                    ...columnRef,\n                    qualifier: { nodeName: TableRef1.NODE_NAME, value: tblAliasRewrite },\n                };\n            };\n\n            // (1)\n            // Rewrite original references to FROM entry references\n            const rewrittenJoinEntries = [];\n            for (const [, { query: joinJson }] of selectorDimensions) {\n                rewrittenJoinEntries.push({\n                    ...joinJson,\n                    condition_clause: {\n                        ...joinJson.condition_clause,\n                        expr: {\n                            ...joinJson.condition_clause.expr,\n                            left: createOrPatchAFromEntry(joinJson.condition_clause.expr.left)\n                        },\n                    },\n                });\n            }\n\n            // (2)\n            // Inject the \"FROM\" list generated by createOrPatchAFromEntry()\n            const [fromClause, fromClauseClass] = this instanceof registry.DeleteStmt\n                ? ['using_clause', 'UsingFromClause']\n                : ['pg_from_clause', 'FromClause'];\n\n            if (pgGeneratedFromItem) {\n                const fromItemNode = FromItem.fromJSON(pgGeneratedFromItem, this.options);\n                this._adoptNodes(fromItemNode);\n\n                resultJson = {\n                    ...resultJson,\n                    [fromClause]: {\n                        nodeName: registry[fromClauseClass].NODE_NAME,\n                        entries: (resultJson[fromClause]?.entries || []).concat(\n                            fromItemNode.jsonfy(options, transformer, linkedDb)\n                        ),\n                    },\n                    where_clause: !resultJson.where_clause ? pgGeneratedWhereClause : {\n                        nodeName: WhereClause.NODE_NAME,\n                        expr: {\n                            nodeName: BinaryExpr.NODE_NAME,\n                            left: pgGeneratedWhereClause.expr,\n                            operator: 'AND',\n                            right: resultJson.where_clause.expr,\n                        },\n                    },\n                };\n            }\n\n            return [\n                resultJson,\n                rewrittenJoinEntries,\n            ];\n        }\n\n        return [\n            resultJson,\n            [...selectorDimensions].map(([, { query: joinJson }]) => joinJson),\n        ];\n    }\n}\n", "import { AbstractNonDDLStmt } from '../abstracts/AbstractNonDDLStmt.js';\r\nimport { registry } from '../registry.js';\r\n\r\nexport class DMLStmt extends AbstractNonDDLStmt {\r\n\r\n    /* SYNTAX RULES */\r\n\r\n    static get syntaxRules() { return { type: ['InsertStmt', 'UpsertStmt', 'UpdateStmt', 'DeleteStmt'] }; }\r\n\r\n    finalizeOutputJSON(resultJson, transformer, linkedDb, options) {\r\n\r\n        if (resultJson.returning_clause) {\r\n            // 1. Re-resolve output list for cases of just-added deep refs in returning_clause\r\n            // wherein schemas wouldn't have been resolvable at the time\r\n            // 2. Finalize output list for the last time, honouring given deSugaring level with regards to star selects \"*\"\r\n            // and ofcos finalize output schemas\r\n            const returningClauseJson = this.returningClause().finalizeJSON(resultJson.returning_clause, transformer, linkedDb, options);\r\n            // Apply now\r\n            resultJson = {\r\n                ...resultJson,\r\n                returning_clause: returningClauseJson,\r\n                result_schema: returningClauseJson.result_schema,\r\n            };\r\n        } else {\r\n            resultJson = {\r\n                ...resultJson,\r\n                result_schema: registry.JSONSchema.fromJSON({ entries: [] }, this.options),\r\n            };\r\n        }\r\n\r\n        return resultJson;\r\n    }\r\n}\r\n", "import { SelectorStmtMixin } from '../abstracts/SelectorStmtMixin.js';\nimport { Transformer } from '../Transformer.js';\nimport { DMLStmt } from './DMLStmt.js';\n\nexport class DeleteStmt extends SelectorStmtMixin(DMLStmt) {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'keyword', value: 'DELETE' },\n            {\n                assert: true,\n                syntaxes: [\n                    {\n                        dialect: 'postgres',\n                        syntax: [\n                            { type: 'keyword', value: 'FROM' },\n                            { type: 'TableAbstraction2', as: 'table_expr' },\n                            { type: 'UsingFromClause', as: 'using_clause', optional: true, autoIndent: true },\n                            { type: 'JoinClause', as: 'join_clauses', arity: Infinity, optional: true, autoIndent: true },\n                            { type: ['PGWhereCurrentClause', 'WhereClause'], as: 'where_clause', optional: true, autoIndent: true },\n                            { type: 'ReturningClause', as: 'returning_clause', optional: true, autoIndent: true },\n                        ],\n                    },\n                    {\n                        dialect: 'mysql',\n                        syntax: [\n                            { type: 'TableAbstraction1', as: 'my_delete_list', arity: { min: 1 }, itemSeparator },\n                            { type: 'FromClause', as: 'my_from_clause', autoIndent: true },\n                            { type: 'JoinClause', as: 'join_clauses', arity: Infinity, optional: true, autoIndent: true },\n                            { type: 'WhereClause', as: 'where_clause', optional: true, autoIndent: true },\n                        ],\n                    },\n                    {\n                        dialect: 'mysql',\n                        syntax: [\n                            { type: 'keyword', value: 'FROM' },\n                            { type: 'TableAbstraction1', as: 'my_delete_list', arity: { min: 1 }, itemSeparator },\n                            { type: 'UsingFromClause', as: 'using_clause', autoIndent: true },\n                            { type: 'JoinClause', as: 'join_clauses', arity: Infinity, optional: true, autoIndent: true },\n                            { type: 'WhereClause', as: 'where_clause', optional: true, autoIndent: true },\n                        ],\n                    },\n                    {\n                        dialect: 'mysql',\n                        syntax: [\n                            { type: 'keyword', value: 'FROM' },\n                            { type: 'TableAbstraction2', as: 'table_expr' },\n                            { type: 'MYPartitionClause', as: 'my_partition_clause', optional: true, autoIndent: true },\n                            { type: 'WhereClause', as: 'where_clause', optional: true, autoIndent: true },\n                            { type: 'OrderByClause', as: 'my_order_by_clause', optional: true, dialect: 'mysql', autoIndent: true },\n                            { type: 'LimitClause', as: 'my_limit_clause', optional: true, dialect: 'mysql', autoIndent: true },\n                        ],\n                    }\n                ],\n            },\n        ];\n    }\n\n    /* AST API */\n\n    tableExpr() { return this._get('table_expr'); }\n\n    usingClause() { return this._get('using_clause'); }\n\n    joinClauses() { return this._get('join_clauses'); }\n\n    whereClause() { return this._get('where_clause'); }\n\n    // -- Postgres\n\n    returningClause() { return this._get('returning_clause'); }\n\n    // -- MySQL\n\n    myPartitionClause() { return this._get('my_partition_clause'); }\n\n    myDeleteList() { return this._get('my_delete_list'); }\n\n    myFromClause() { return this._get('my_from_clause'); }\n\n    myOrderByClause() { return this._get('my_order_by_clause'); }\n\n    myLimitClause() { return this._get('my_limit_clause'); }\n\n    /* JSON API */\n\n    jsonfy(options = {}, transformer = null, linkedDb = null) {\n        if (!options.deSugar) return super.jsonfy(options, transformer, linkedDb);\n\n        transformer = new Transformer((node, defaultTransform) => {\n            return defaultTransform();\n        }, transformer, this/* IMPORTANT */);\n\n        let resultJson = super.jsonfy(options, transformer, linkedDb);\n\n        // Order ouput JSON\n        if ((options.toDialect || this.options.dialect) === 'mysql') {\n            resultJson = {\n                uuid: resultJson.uuid,\n                nodeName: resultJson.nodeName,\n                my_delete_list: resultJson.my_delete_list,\n                my_from_clause: resultJson.my_from_clause,\n                using_clause: resultJson.using_clause,\n                join_clauses: resultJson.join_clauses,\n                where_clause: resultJson.where_clause,\n                // last syntax\n                table_expr: resultJson.table_expr,\n                my_partition_clause: resultJson.my_partition_clause,\n                my_order_by_clause: resultJson.my_order_by_clause,\n                my_limit_clause: resultJson.my_limit_clause,\n            };\n        } else {\n            resultJson = {\n                uuid: resultJson.uuid,\n                nodeName: resultJson.nodeName,\n                table_expr: resultJson.table_expr,\n                using_clause: resultJson.using_clause,\n                join_clauses: resultJson.join_clauses,\n                where_clause: resultJson.where_clause,\n                returning_clause: resultJson.returning_clause,\n                result_schema: resultJson.result_schema,\n            };\n        }\n\n        // 1. Finalize output JSON\n\t\tresultJson = this.finalizeOutputJSON(resultJson, transformer, linkedDb, options);\n        // 2. Finalize generated JOINS\n        resultJson = this.finalizeSelectorJSON(resultJson, transformer, linkedDb, options);\n        \n        return resultJson;\n    }\n}", "import { Transformer } from '../Transformer.js';\nimport { registry } from '../registry.js';\nimport { _eq } from '../util.js';\n\nexport const PayloadStmtMixin = (Class) => class extends Class {\n\n\tget isPayloadStmt() { return true; }\n\n\tstatic morphsTo() { return registry.CTE; }\n\n\t/* DESUGARING API */\n\n\tjsonfy(options = {}, transformer = null, linkedDb = null) {\n\t\tif (!options.deSugar) return super.jsonfy(options, transformer, linkedDb);\n\n\t\tconst {\n\t\t\tLQDeepRef2,\n\t\t\tAssignmentExpr,\n\t\t\tDerivedQuery,\n\t\t\tColumnsConstructor,\n\t\t\tValuesConstructor,\n\t\t\tTypedRowConstructor,\n\t\t\tRowConstructor,\n\t\t} = registry;\n\n\t\tconst specials = ['column_list', 'pg_default_values_clause', 'values_clause', 'select_clause'].map((s) => this._get(s));\n\t\tconst [columnList, pgDefaultValuesClause, valuesClause, selectClause] = specials;\n\t\tconst hasTopLevelDeepRefs = columnList?.entries().some((c) => c instanceof LQDeepRef2);\n\n\t\t// --- ASSIGNMENT EXPRS ---------------\n\n\t\tconst ignoreList = hasTopLevelDeepRefs ? new Set(specials) : new Set;\n\t\ttransformer = new Transformer((node, defaultTransform, keyHint, { deSugar/* EXCLUSION */, ...$options }) => {\n\n\t\t\t// IMPORTANT!!! The bellow tells the default jsonfier to ignore the nodes we'll handle manually\n\t\t\tif (ignoreList.has(node)) {\n\t\t\t\treturn; // Exclude in output\n\t\t\t}\n\n\t\t\t// We want to only desugar AssignmentExpr\n\t\t\tif (!(node instanceof AssignmentExpr)) {\n\t\t\t\treturn defaultTransform();\n\t\t\t}\n\n\t\t\t// Is this assignment expr from within \"conflict_handling_clause\"?\n\t\t\tconst conflictHandlingClauseContext = !!this._get('conflict_handling_clause')?.containsNode(node);\n\t\t\tif (conflictHandlingClauseContext && this.options.dialect !== 'postgres') {\n\t\t\t\treturn defaultTransform();\n\t\t\t}\n\n\t\t\tconst $$options = { ...$options, conflictHandlingClauseContext };\n\n\t\t\t// Handle bare assignment exoressions\n\t\t\tif (node.left() instanceof LQDeepRef2) {\n\t\t\t\tconst [[deSugaredLhs], [[deSugaredRhs]]] = this.deSugarPayload(\n\t\t\t\t\tColumnsConstructor.fromJSON({ entries: [node.left().jsonfy()] }),\n\t\t\t\t\t[[node.right()]],\n\t\t\t\t\ttransformer,\n\t\t\t\t\tlinkedDb,\n\t\t\t\t\t$$options,\n\t\t\t\t);\n\t\t\t\tif (!deSugaredLhs) return; // Exclude in output\n\t\t\t\treturn {\n\t\t\t\t\tnodeName: AssignmentExpr.NODE_NAME,\n\t\t\t\t\toperator: '=',\n\t\t\t\t\tleft: deSugaredLhs,\n\t\t\t\t\tright: deSugaredRhs,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Handle compound assignment exoressions\n\t\t\tif (node.left() instanceof ColumnsConstructor // Postgres\n\t\t\t\t&& node.left().entries().some((c) => c instanceof LQDeepRef2)) {\n\n\t\t\t\tconst columnList = node.left();\n\t\t\t\tlet deSugaredLhs,\n\t\t\t\t\tdeSugaredRhs;\n\n\t\t\t\tif (node.right() instanceof RowConstructor/* Still passes even for TypedRowConstructor */) {\n\t\t\t\t\t[deSugaredLhs, [deSugaredRhs]] = this.deSugarPayload(\n\t\t\t\t\t\tcolumnList,\n\t\t\t\t\t\t[node.right().entries()],\n\t\t\t\t\t\ttransformer,\n\t\t\t\t\t\tlinkedDb,\n\t\t\t\t\t\t$$options,\n\t\t\t\t\t);\n\t\t\t\t\tdeSugaredRhs = { nodeName: TypedRowConstructor.NODE_NAME/* To be really formal */, entries: deSugaredRhs };\n\t\t\t\t} else if (node.right() instanceof DerivedQuery) {\n\t\t\t\t\t[deSugaredLhs, deSugaredRhs] = this.deSugarPayload(\n\t\t\t\t\t\tcolumnList,\n\t\t\t\t\t\tnode.right().expr(),\n\t\t\t\t\t\ttransformer,\n\t\t\t\t\t\tlinkedDb,\n\t\t\t\t\t\t$$options,\n\t\t\t\t\t);\n\t\t\t\t\tdeSugaredRhs = { nodeName: DerivedQuery.NODE_NAME, expr: deSugaredRhs };\n\t\t\t\t} else {\n\t\t\t\t\t[deSugaredLhs, [deSugaredRhs]] = this.deSugarPayload(\n\t\t\t\t\t\tcolumnList,\n\t\t\t\t\t\t[[node.right()]],\n\t\t\t\t\t\ttransformer,\n\t\t\t\t\t\tlinkedDb,\n\t\t\t\t\t\t$$options,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif (!deSugaredLhs.length) return; // Exclude in output\n\t\t\t\treturn {\n\t\t\t\t\tnodeName: AssignmentExpr.NODE_NAME,\n\t\t\t\t\toperator: '=',\n\t\t\t\t\tleft: { nodeName: ColumnsConstructor.NODE_NAME, entries: deSugaredLhs },\n\t\t\t\t\tright: deSugaredRhs,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn defaultTransform();\n\t\t}, transformer, this/* IMPORTANT */);\n\n\t\t// Base JSON\n\t\tlet resultJson = super.jsonfy(options, transformer, linkedDb);\n\n\t\t// --- TOP-LEVEL COLUMNS:VALUES/SELECT ---------------\n\n\t\t// Manually jsonfy these\n\t\tif (hasTopLevelDeepRefs) {\n\t\t\tconst [deSugaredLhs, deSugaredRhs] = this.deSugarPayload(\n\t\t\t\tcolumnList,\n\t\t\t\tpgDefaultValuesClause || valuesClause?.entries().map((rowSet) => rowSet.entries()) || selectClause,\n\t\t\t\ttransformer,\n\t\t\t\tlinkedDb,\n\t\t\t\toptions,\n\t\t\t);\n\n\t\t\tresultJson = {\n\t\t\t\t...resultJson,\n\t\t\t\tcolumn_list: { nodeName: ColumnsConstructor.NODE_NAME, entries: deSugaredLhs },\n\t\t\t};\n\n\t\t\tif (pgDefaultValuesClause && Array.isArray(deSugaredRhs) || valuesClause) {\n\t\t\t\tconst rowsJson = deSugaredRhs.map((rowSetJson) => ({ nodeName: TypedRowConstructor.NODE_NAME/* Most cross-dialect */, entries: rowSetJson }));\n\t\t\t\tresultJson = {\n\t\t\t\t\t...resultJson,\n\t\t\t\t\tvalues_clause: { nodeName: ValuesConstructor.NODE_NAME, entries: rowsJson },\n\t\t\t\t};\n\t\t\t} else if (pgDefaultValuesClause) {\n\t\t\t\tresultJson = { ...resultJson, pg_default_values_clause: deSugaredRhs };\n\t\t\t} else {\n\t\t\t\tresultJson = { ...resultJson, select_clause: deSugaredRhs };\n\t\t\t}\n\t\t}\n\n\t\treturn resultJson;\n\t}\n\n\tdeSugarPayload(columns, values, transformer, linkedDb, { conflictHandlingClauseContext = false, deSugar, ...$options } = {}) {\n\t\tconst payloadDimensions = transformer.statementContext.artifacts.get('payloadDimensions');\n\n\t\tconst {\n\t\t\tLQDeepRef2,\n\t\t\tTableRef1,\n\t\t\tColumnRef1,\n\t\t\tSelectItemAlias,\n\t\t\tColumnRef2,\n\t\t\tColumnsConstructor,\n\t\t\tTypedRowConstructor,\n\t\t\tRowConstructor,\n\t\t\tDefaultLiteral,\n\t\t\tSelectStmt,\n\t\t\tCompleteSelectStmt,\n\t\t\tPGDefaultValuesClause,\n\t\t\tSelectList,\n\t\t\tSelectItem,\n\t\t\tFromClause,\n\t\t\tFromItem,\n\t\t} = registry;\n\n\t\tconst jsonfy = (node, _deSugar = deSugar) => {\n\t\t\treturn node.jsonfy({ deSugar: _deSugar, ...$options }, transformer, linkedDb);\n\t\t};\n\n\t\t// (1): Columns\n\t\tconst deSugarColumnsList = (columnList, dimensionsMap) => {\n\t\t\treturn columnList.entries().reduce((columnList, columnRef, columnOffset) => {\n\t\t\t\tif (columnRef instanceof LQDeepRef2) {\n\n\t\t\t\t\tconst dimension = this.createPayloadDimension(columnRef, transformer, linkedDb, { conflictHandlingClauseContext, ...$options });\n\t\t\t\t\tdimensionsMap.set(columnOffset, dimension);\n\n\t\t\t\t\tif (dimension.refMode === 'dependency' && dimension.lhsOperandJson) {\n\t\t\t\t\t\treturn columnList.concat({\n\t\t\t\t\t\t\tnodeName: ColumnRef2.NODE_NAME,\n\t\t\t\t\t\t\tvalue: dimension.lhsOperandJson.value,\n\t\t\t\t\t\t\tdelim: dimension.lhsOperandJson.delim,\n\t\t\t\t\t\t\tresult_schema: dimension.lhsOperandJson.result_schema,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\treturn columnList;\n\t\t\t\t}\n\n\t\t\t\treturn columnList.concat(jsonfy(columnRef));\n\t\t\t}, []);\n\t\t};\n\n\t\t// (2.a): Default Values\n\t\tconst deSugarValuesFromDefaultValues = (pgDefaultValuesClause, dimensionsMap) => {\n\t\t\tconst valuesRow = columns.entries().reduce((valuesRow, columnRef, columnOffset) => {\n\t\t\t\tconst valueJson = dimensionsMap.has(columnOffset)\n\t\t\t\t\t? dimensionsMap.get(columnOffset).offload(pgDefaultValuesClause)\n\t\t\t\t\t: { nodeName: DefaultLiteral.NODE_NAME, value: 'DEFAULT' };\n\t\t\t\treturn valueJson\n\t\t\t\t\t? valuesRow.concat(valueJson)\n\t\t\t\t\t: valuesRow;\n\t\t\t}, []);\n\n\t\t\tif (columns.length - valuesRow.length === dimensionsMap.size) {\n\t\t\t\t// There were no depencies; only dependents\n\t\t\t\treturn pgDefaultValuesClause.jsonfy();\n\t\t\t}\n\n\t\t\t// There were depencies\n\t\t\treturn [valuesRow];\n\t\t};\n\n\t\t// (2.b): Values\n\t\tconst deSugarValuesFromValues = (valuesEntries, dimensionsMap) => {\n\t\t\treturn valuesEntries.map((valuesRow, rowOffset) => {\n\t\t\t\treturn valuesRow.reduce((valuesRow, valueNode, columnOffset) => {\n\t\t\t\t\tlet valueJson;\n\t\t\t\t\tif (columns.get(columnOffset) instanceof LQDeepRef2 && valueNode instanceof DefaultLiteral) {\n\t\t\t\t\t\tvalueJson = dimensionsMap.get(columnOffset).offload(\n\t\t\t\t\t\t\tPGDefaultValuesClause.fromJSON({ value: 'DEFAULT' }, this.options),\n\t\t\t\t\t\t\trowOffset\n\t\t\t\t\t\t);\n\t\t\t\t\t} else if (dimensionsMap.has(columnOffset)) {\n\t\t\t\t\t\tvalueJson = dimensionsMap.get(columnOffset).offload(valueNode, rowOffset);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalueJson = jsonfy(valueNode);\n\t\t\t\t\t}\n\t\t\t\t\treturn valueJson\n\t\t\t\t\t\t? valuesRow.concat(valueJson)\n\t\t\t\t\t\t: valuesRow;\n\t\t\t\t}, []);\n\t\t\t});\n\t\t};\n\n\t\t// (2.c): Select\n\t\tconst deSugarValuesFromSelect = (selectStmt, dimensionsMap) => {\n\t\t\t// Declare base SELECT and select list\n\t\t\tlet baseSelect = { ...jsonfy(selectStmt, 2), result_schema: undefined };\n\t\t\tlet baseSelectItems = baseSelect.select_list.entries;\n\n\t\t\tif (baseSelectItems.length !== columns.length) {\n\t\t\t\tthrow new Error(`Select list (${baseSelectItems.length}) does not match columns length (${columns.length})`);\n\t\t\t}\n\n\t\t\t// Create a CTE entry?\n\t\t\tlet memoSelect;\n\t\t\tif (!conflictHandlingClauseContext\n\t\t\t\t&& baseSelect.from_clause\n\t\t\t\t&& !/^[`\"]\\$memo~.+[`\"]$/.test(selectStmt.fromClause().entries()[0].expr() + '')) {\n\t\t\t\tconst memoSelectAlias = transformer.rootContext.rand('memo');\n\t\t\t\tmemoSelect = {\n\t\t\t\t\t...baseSelect,\n\t\t\t\t\tuuid: memoSelectAlias,\n\t\t\t\t\tselect_list: { nodeName: SelectList.NODE_NAME, entries: [rowNumberExpr('$row_number~a')] },\n\t\t\t\t};\n\t\t\t\tpayloadDimensions.add({ refMode: 'memo', query: memoSelect });\n\n\t\t\t\tconst newBaseSelectFromItem = { nodeName: FromItem.NODE_NAME, expr: { nodeName: TableRef1.NODE_NAME, value: memoSelectAlias } };\n\t\t\t\tbaseSelect = {\n\t\t\t\t\tnodeName: CompleteSelectStmt.NODE_NAME,\n\t\t\t\t\tselect_list: { nodeName: SelectList.NODE_NAME, entries: [] },\n\t\t\t\t\tfrom_clause: { nodeName: FromClause.NODE_NAME, entries: [newBaseSelectFromItem] },\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Resolve base select list\n\t\t\tconst rewriteAgainstMemoSelect = (fieldJson, obfuscateAlias = false) => {\n\t\t\t\tif (!memoSelect) return fieldJson;\n\t\t\t\tif (fieldJson.alias && obfuscateAlias) {\n\t\t\t\t\tfieldJson = {\n\t\t\t\t\t\t...fieldJson,\n\t\t\t\t\t\talias: { ...fieldJson.alias, value: fieldJson.alias.value + transformer.rand('rand', { asSalt: true }) },\n\t\t\t\t\t};\n\t\t\t\t} else if (!fieldJson.alias) {\n\t\t\t\t\tfieldJson.alias = { nodeName: SelectItemAlias.NODE_NAME, as_kw: true, value: transformer.rand('value') };\n\t\t\t\t}\n\t\t\t\tmemoSelect.select_list.entries.push(fieldJson);\n\t\t\t\treturn {\n\t\t\t\t\tnodeName: SelectItem.NODE_NAME,\n\t\t\t\t\texpr: { nodeName: ColumnRef1.NODE_NAME, value: fieldJson.alias.value, delim: fieldJson.alias.delim },\n\t\t\t\t};\n\t\t\t};\n\n\t\t\tconst newBaseSelectList = baseSelectItems.reduce((selectList, fieldJson, columnOffset) => {\n\t\t\t\tif (dimensionsMap.has(columnOffset)) {\n\t\t\t\t\tlet subSelectItems;\n\n\t\t\t\t\tif ([TypedRowConstructor.NODE_NAME, RowConstructor.NODE_NAME].includes(fieldJson.expr.nodeName)) {\n\t\t\t\t\t\tsubSelectItems = fieldJson.expr.entries.map((entryJson) => {\n\t\t\t\t\t\t\treturn rewriteAgainstMemoSelect({\n\t\t\t\t\t\t\t\tnodeName: SelectItem.NODE_NAME,\n\t\t\t\t\t\t\t\texpr: entryJson,\n\t\t\t\t\t\t\t\talias: fieldJson.alias,\n\t\t\t\t\t\t\t}, true);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (!(columns.get(columnOffset).right() instanceof ColumnsConstructor)) {\n\t\t\t\t\t\t\tsubSelectItems = [{\n\t\t\t\t\t\t\t\tnodeName: SelectItem.NODE_NAME,\n\t\t\t\t\t\t\t\texpr: { nodeName: TypedRowConstructor.NODE_NAME, entries: subSelectItems.map((s) => s.expr) },\n\t\t\t\t\t\t\t}];\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsubSelectItems = [rewriteAgainstMemoSelect(fieldJson)];\n\t\t\t\t\t}\n\n\t\t\t\t\tconst valueNode = SelectStmt.fromJSON({\n\t\t\t\t\t\t...baseSelect,\n\t\t\t\t\t\tselect_list: { nodeName: SelectList.NODE_NAME, entries: subSelectItems },\n\t\t\t\t\t}, this.options);\n\n\t\t\t\t\tfieldJson = dimensionsMap.get(columnOffset).offload(valueNode);\n\n\t\t\t\t\tif (fieldJson) {\n\t\t\t\t\t\tconst lhsOperandJson = dimensionsMap.get(columnOffset).lhsOperandJson;\n\t\t\t\t\t\treturn selectList.concat({\n\t\t\t\t\t\t\tnodeName: SelectItem.NODE_NAME,\n\t\t\t\t\t\t\texpr: fieldJson,\n\t\t\t\t\t\t\talias: { nodeName: SelectItemAlias.NODE_NAME, as_kw: true, value: lhsOperandJson.value, delim: lhsOperandJson.delim }\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\treturn selectList;\n\t\t\t\t}\n\n\t\t\t\tif (!fieldJson.alias) {\n\t\t\t\t\tconst correspondingColumn = columns.get(columnOffset);\n\t\t\t\t\tfieldJson = {\n\t\t\t\t\t\t...fieldJson,\n\t\t\t\t\t\talias: { nodeName: SelectItemAlias.NODE_NAME, as_kw: true, value: correspondingColumn.value(), delim: correspondingColumn._get('delim') },\n\t\t\t\t\t};\n\t\t\t\t};\n\n\t\t\t\treturn selectList.concat(rewriteAgainstMemoSelect(fieldJson));\n\t\t\t}, []);\n\n\t\t\tbaseSelect = {\n\t\t\t\t...baseSelect,\n\t\t\t\tselect_list: {\n\t\t\t\t\tnodeName: SelectList.NODE_NAME,\n\t\t\t\t\tentries: newBaseSelectList,\n\t\t\t\t},\n\t\t\t}\n\n\t\t\treturn baseSelect;\n\t\t};\n\n\t\t// Process...\n\t\tconst dimensionsMap = new Map;\n\t\tconst deSugaredLhs = deSugarColumnsList(columns, dimensionsMap);\n\n\t\tconst deSugaredRhs = values instanceof PGDefaultValuesClause\n\t\t\t? deSugarValuesFromDefaultValues(values, dimensionsMap)\n\t\t\t: (values instanceof SelectStmt\n\t\t\t\t? deSugarValuesFromSelect(values, dimensionsMap)\n\t\t\t\t: deSugarValuesFromValues(values, dimensionsMap));\n\n\t\tdimensionsMap.clear();\n\n\t\treturn [deSugaredLhs, deSugaredRhs];\n\t}\n\n\tcreatePayloadDimension(LQRefColumn, transformer, linkedDb, { conflictHandlingClauseContext = false, ...$options } = {}) {\n\t\tconst { lhsOperand, rhsOperand, rhsTable, detail } = LQRefColumn.resolve(transformer, linkedDb, 2);\n\t\tconst payloadDimensions = transformer.statementContext.artifacts.get('payloadDimensions');\n\n\t\tconst {\n\t\t\tLQDeepRef2,\n\t\t\tLQBackRefAbstraction,\n\t\t\tReturningClause,\n\t\t\tColumnRef2,\n\t\t\tColumnRef1,\n\t\t\tTableRef1,\n\t\t\tSelectList,\n\t\t\tSelectItem,\n\t\t\tSelectItemAlias,\n\t\t\tAssignmentExpr,\n\t\t\tColumnsConstructor,\n\t\t\tTypedRowConstructor,\n\t\t\tRowConstructor,\n\t\t\tPGDefaultValuesClause,\n\t\t\tValuesConstructor,\n\t\t\tValuesTableLiteral,\n\t\t\tDefaultLiteral,\n\t\t\tSelectStmt,\n\t\t\tWhereClause,\n\t\t\tCompleteSelectStmt,\n\t\t\tScalarSubquery,\n\t\t\tDerivedQuery,\n\t\t\tFromItem,\n\t\t\tFromClause,\n\t\t\tSetClause,\n\t\t\tBinaryExpr,\n\t\t\tBoolLiteral,\n\t\t\tNumberLiteral,\n\t\t\tUpdateStmt,\n\t\t\tTableAbstraction2,\n\t\t} = registry;\n\n\t\tconst baseUUID = transformer.rootContext.hash(this, 'main');\n\t\tconst jsonfy = (node) => {\n\t\t\treturn node.jsonfy($options, transformer, linkedDb);\n\t\t};\n\n\t\tconst lhsOperandJson = jsonfy(lhsOperand);\n\t\tconst rhsOperandJson = jsonfy(rhsOperand);\n\t\tconst rhsTableJson = jsonfy(rhsTable);\n\n\t\tconst lhsOperand1Json = lhsOperand.jsonfy({ toKind: 1 });\n\t\tconst rhsOperand1Json = rhsOperand.jsonfy({ toKind: 1 });\n\t\tconst rhsTable1Json = { ...rhsTableJson, nodeName: TableRef1.NODE_NAME };\n\t\tconst refMode = LQRefColumn.left() instanceof LQBackRefAbstraction\n\t\t\t? 'dependent'\n\t\t\t: 'dependency';\n\t\tconst isDeepRef = detail instanceof LQDeepRef2;\n\n\t\t// Figure the expected payload structure\n\t\tlet columnsConstructorJson;\n\t\tif (detail instanceof ColumnsConstructor) {\n\t\t\tcolumnsConstructorJson = jsonfy(detail);\n\t\t} else if (detail instanceof ColumnRef2 || detail instanceof LQDeepRef2) {\n\t\t\tcolumnsConstructorJson = { nodeName: ColumnsConstructor.NODE_NAME, entries: [jsonfy(detail)] };\n\t\t} else {\n\t\t\tthrow new Error(`Invalid columns spec: ${LQRefColumn}`);\n\t\t}\n\n\t\t// Payload structure length validity\n\t\tconst columnsLength = columnsConstructorJson.entries.length;\n\t\tconst dimensionValidateRowLength = (rowNode, result_schema = null) => {\n\t\t\tif (isDeepRef) return rowNode;\n\t\t\tlet rowLength = 1;\n\t\t\tif (result_schema) {\n\t\t\t\trowLength = result_schema.length;\n\t\t\t} else if (rowNode instanceof RowConstructor || rowNode instanceof SelectStmt) {\n\t\t\t\trowLength = rowNode.length;\n\t\t\t} else if (rowNode instanceof SelectStmt) {\n\t\t\t\trowLength = rowNode.length;\n\t\t\t} else if (rowNode instanceof DerivedQuery) {\n\t\t\t\trowLength = rowNode.expr().length;\n\t\t\t}\n\t\t\tif (rowLength > columnsLength) throw new Error(`[${rowNode}] Payload has more columns than target columns: ${detail}.`);\n\t\t\tif (rowLength < columnsLength) throw new Error(`[${rowNode}] Payload has fewer columns than target columns: ${detail}.`);\n\t\t\treturn rowNode;\n\t\t};\n\n\t\t// Compose:\n\t\t// - (SELECT <sourceCol> FROM <sourceUuid> WHERE <rand> = <sourceRowIndex>)\n\t\tconst createForeignBinding = (sourceUuid, sourceCol, sourceRowIndex = null, innerFilter = null) => {\n\t\t\tlet whereExpr;\n\t\t\tlet whereExprRhs;\n\n\t\t\tif (typeof sourceRowIndex === 'number') {\n\t\t\t\twhereExprRhs = { nodeName: NumberLiteral.NODE_NAME, value: sourceRowIndex + 1 };\n\t\t\t} else if (sourceRowIndex) {\n\t\t\t\twhereExprRhs = sourceRowIndex;\n\t\t\t}\n\n\t\t\tif (whereExprRhs) {\n\t\t\t\twhereExpr = {\n\t\t\t\t\tnodeName: BinaryExpr.NODE_NAME,\n\t\t\t\t\tleft: { nodeName: ColumnRef1.NODE_NAME, value: '$row_number~b' },\n\t\t\t\t\toperator: '=',\n\t\t\t\t\tright: whereExprRhs,\n\t\t\t\t};\n\t\t\t} else if (innerFilter) {\n\t\t\t\twhereExpr = {\n\t\t\t\t\tnodeName: BinaryExpr.NODE_NAME,\n\t\t\t\t\tleft: { nodeName: ColumnRef1.NODE_NAME, value: innerFilter },\n\t\t\t\t\toperator: 'IS',\n\t\t\t\t\tright: { nodeName: BoolLiteral.NODE_NAME, value: 'TRUE' },\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tconst tableSpec = {\n\t\t\t\tnodeName: FromItem.NODE_NAME,\n\t\t\t\texpr: { nodeName: TableRef1.NODE_NAME, value: whereExprRhs ? `${sourceUuid}~indices` : sourceUuid },\n\t\t\t};\n\n\t\t\tconst selectStmt = {\n\t\t\t\tnodeName: CompleteSelectStmt.NODE_NAME,\n\t\t\t\tselect_list: { nodeName: SelectList.NODE_NAME, entries: [{ nodeName: SelectItem.NODE_NAME, expr: { ...sourceCol, qualifier: undefined } }] },\n\t\t\t\tfrom_clause: { nodeName: FromClause.NODE_NAME, entries: [tableSpec] },\n\t\t\t\twhere_clause: whereExpr && { nodeName: WhereClause.NODE_NAME, expr: whereExpr },\n\t\t\t};\n\n\t\t\treturn { nodeName: ScalarSubquery.NODE_NAME, expr: selectStmt };\n\t\t};\n\n\t\t// --- UPDATE -------------\n\n\t\tif (this instanceof UpdateStmt || conflictHandlingClauseContext) {\n\n\t\t\t// UPDATE t1 SET (a, (fk <~ fk <~ t2) ~> (a, b)) = ROW(2, ROW(44, 33))\n\t\t\t// UPDATE t1 SET (a, (fk <~ fk <~ t2) ~> a) = ROW(2, ROW(44, 33))\n\t\t\t// UPDATE t1 SET (a, (fk <~ fk <~ t2) ~> a) = (SELECT a, b FROM t3)\n\t\t\t// UPDATE t1 SET (a, fk ~> fk ~> (a, b)) = ROW(2, ROW(44, 33))\n\t\t\t// UPDATE t1 SET (a, fk ~> fk ~> a) = ROW(2, ROW(44, 33))\n\t\t\t// UPDATE t1 SET (a, fk ~> fk ~> a) = (SELECT a, b FROM t3)\n\n\t\t\t// Here we want to compose:\n\t\t\t// - WHERE <rhsOperandJson> IN (SELECT <lhsOperandJson> FROM <baseUUID> [WHERE <conflict_based_update> IS TRUE]? )\n\t\t\tconst onConflictUpdatedStatusAlias = conflictHandlingClauseContext\n\t\t\t\t? `${baseUUID}_conflict_based_update` : null;\n\n\t\t\tconst whereClause = {\n\t\t\t\tnodeName: BinaryExpr.NODE_NAME,\n\t\t\t\tleft: rhsOperand1Json,\n\t\t\t\toperator: 'IN',\n\t\t\t\tright: createForeignBinding(baseUUID, lhsOperandJson, null, onConflictUpdatedStatusAlias),\n\t\t\t};\n\n\t\t\tconst query = {\n\t\t\t\tuuid: transformer.rootContext.rand(refMode),\n\t\t\t\tnodeName: UpdateStmt.NODE_NAME,\n\t\t\t\ttable_expr: { nodeName: TableAbstraction2.NODE_NAME, table_ref: rhsTable1Json },\n\t\t\t\tset_clause: { nodeName: SetClause.NODE_NAME, entries: [] },\n\t\t\t\twhere_clause: { nodeName: WhereClause.NODE_NAME, expr: whereClause },\n\t\t\t};\n\n\t\t\tconst offload = (payload) => {\n\t\t\t\tif (payload instanceof ValuesTableLiteral) {\n\t\t\t\t\tthrow new Error(`Single-row payload structure expected for column structure: ${detail}. Recieved ${payload.NODE_NAME}.`);\n\t\t\t\t}\n\t\t\t\tif (query.set_clause.entries.length) {\n\t\t\t\t\tthrow new Error(`Unexpected multiple offload() call on ${LQRefColumn}`);\n\t\t\t\t}\n\n\t\t\t\t// Carry deep values forward\n\t\t\t\tlet payloadJson = jsonfy(payload);\n\t\t\t\tif (isDeepRef && !(payload instanceof PGDefaultValuesClause)) {\n\t\t\t\t\tpayload = TypedRowConstructor.fromJSON({ entries: [payloadJson] }, this.options);\n\t\t\t\t\tpayloadJson = jsonfy(payload);\n\t\t\t\t}\n\n\t\t\t\tif (payload instanceof SelectStmt) {\n\t\t\t\t\tpayloadJson = { nodeName: DerivedQuery.NODE_NAME, expr: payloadJson, result_schema: payloadJson.result_schema };\n\t\t\t\t\tdimensionValidateRowLength(payload, payloadJson.result_schema);\n\t\t\t\t} else if (payload instanceof DerivedQuery) {\n\t\t\t\t\tdimensionValidateRowLength(payload, payloadJson.result_schema);\n\t\t\t\t} else if (payload instanceof RowConstructor) {\n\t\t\t\t\tdimensionValidateRowLength(payload);\n\t\t\t\t} else if (!(payload instanceof PGDefaultValuesClause)) {\n\t\t\t\t\tpayloadJson = { nodeName: TypedRowConstructor.NODE_NAME/* most formal */, entries: [payloadJson] };\n\t\t\t\t}\n\n\t\t\t\tquery.set_clause.entries.push({\n\t\t\t\t\tnodeName: AssignmentExpr.NODE_NAME,\n\t\t\t\t\tleft: columnsConstructorJson,\n\t\t\t\t\toperator: '=',\n\t\t\t\t\tright: payloadJson,\n\t\t\t\t});\n\n\t\t\t\tif (refMode === 'dependency') {\n\t\t\t\t\treturn lhsOperand1Json;\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tconst payloadDimension = {\n\t\t\t\trefMode,\n\t\t\t\tquery,\n\t\t\t\toffload,\n\t\t\t\tlhsOperandJson,\n\t\t\t\tconflictHandlingClauseContext\n\t\t\t};\n\t\t\tpayloadDimensions.add(payloadDimension);\n\n\t\t\treturn payloadDimension;\n\t\t}\n\n\t\t// --- INSERT/UPSERT -------------\n\n\t\tconst queries = [];\n\n\t\t// This is for all INSERT types\n\t\tconst dimensionPushRow = (query, payload, fKBindingJson = null) => {\n\t\t\tif (payload instanceof PGDefaultValuesClause) {\n\t\t\t\tif (fKBindingJson) {\n\t\t\t\t\tconst lastIndex = query.column_list.entries.length - 1;\n\t\t\t\t\tquery.values_clause.entries.push({\n\t\t\t\t\t\tnodeName: TypedRowConstructor.NODE_NAME/* most formal */,\n\t\t\t\t\t\tentries: query.column_list.entries.map((c, i) => {\n\t\t\t\t\t\t\treturn i === lastIndex\n\t\t\t\t\t\t\t\t? fKBindingJson\n\t\t\t\t\t\t\t\t: { nodeName: DefaultLiteral.NODE_NAME, value: 'DEFAULT' };\n\t\t\t\t\t\t}),\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tdelete query.values_clause;\n\t\t\t\t\tquery.pg_default_values_clause = jsonfy(payload);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdimensionValidateRowLength(payload);\n\t\t\t\tlet rowJson = jsonfy(payload);\n\t\t\t\tif (!(payload instanceof RowConstructor)) {\n\t\t\t\t\trowJson = { nodeName: TypedRowConstructor.NODE_NAME/* most formal */, entries: [rowJson] };\n\t\t\t\t}\n\t\t\t\tif (fKBindingJson) {\n\t\t\t\t\trowJson = { ...rowJson, entries: rowJson.entries.concat(fKBindingJson) };\n\t\t\t\t}\n\t\t\t\tquery.values_clause.entries.push(rowJson);\n\t\t\t}\n\t\t};\n\n\t\t// BackRefing INSERTS\n\t\tif (refMode === 'dependent') {\n\n\t\t\t// INSERT INTO t1 (a, (fk <~ fk <~ t2) ~> (a, b)) VALUES (2, ROW(44, 33)), (3, ROW(11, 22))\n\t\t\t// INSERT INTO t1 (a, (fk <~ fk <~ t2) ~> a) VALUES (2, 44), (3, 11)\n\t\t\t// INSERT INTO t1 (a, (fk <~ fk <~ t2) ~> a) SELECT a, b FROM t3\n\n\t\t\tconst queryTemplate = () => ({\n\t\t\t\tuuid: transformer.rootContext.rand(refMode),\n\t\t\t\tnodeName: this.NODE_NAME,\n\t\t\t\ttable_ref: rhsTableJson,\n\t\t\t\tcolumn_list: ColumnsConstructor.fromJSON({ entries: columnsConstructorJson.entries.concat(rhsOperandJson) }).jsonfy(),\n\t\t\t});\n\n\t\t\tconst selectForeignBinding = (selectJson, fKBindingJson) => {\n\t\t\t\tconst fkField = {\n\t\t\t\t\tnodeName: SelectItem.NODE_NAME,\n\t\t\t\t\texpr: fKBindingJson,\n\t\t\t\t\talias: rhsOperand instanceof ColumnRef2\n\t\t\t\t\t\t? { nodeName: SelectItemAlias.NODE_NAME, as_kw: true, value: rhsOperand.value(), delim: rhsOperand._get('delim') }\n\t\t\t\t\t\t: undefined,\n\t\t\t\t};\n\t\t\t\treturn {\n\t\t\t\t\t...selectJson,\n\t\t\t\t\tselect_list: { ...selectJson.select_list, entries: selectJson.select_list.entries.concat(fkField) },\n\t\t\t\t};\n\t\t\t};\n\n\t\t\tconst offload = (payload, correlationRhs = null) => {\n\n\t\t\t\tif (!queries.length) {\n\t\t\t\t\tqueries.push(queryTemplate());\n\t\t\t\t}\n\t\t\t\tlet currentQuery = queries[queries.length - 1];\n\n\t\t\t\tif (payload instanceof SelectStmt) {\n\t\t\t\t\t// Meaning we're from a literal INSERT ... SELECT statement, not an INSERT ... VALUES (+SELECT) statement\n\t\t\t\t\t// and this time, we want to correlate with base query's row number\n\t\t\t\t\tcorrelationRhs = {\n\t\t\t\t\t\tnodeName: ColumnRef1.NODE_NAME,\n\t\t\t\t\t\tvalue: '$row_number~a',\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tconst fKBindingJson = createForeignBinding(baseUUID, lhsOperandJson, correlationRhs);\n\n\t\t\t\t// Scenario 2:\n\t\t\t\t// When the base query is an INSERT ... VALUES (+DerivedQuery)\n\t\t\t\tlet isDerivedQuery;\n\t\t\t\tif (payload instanceof DerivedQuery) {\n\t\t\t\t\tpayload = payload.expr();\n\t\t\t\t\t// For when preceding offload() was scenario 2 or 3\n\t\t\t\t\tif (currentQuery.select_clause || currentQuery.values_clause) {\n\t\t\t\t\t\tcurrentQuery = queryTemplate();\n\t\t\t\t\t\tqueries.push(currentQuery);\n\t\t\t\t\t}\n\t\t\t\t\tisDerivedQuery = true;\n\t\t\t\t}\n\n\t\t\t\t// Scenario 1 or 2:\n\t\t\t\t// When the base query is an INSERT ... SELECT\n\t\t\t\t// or when the preceding scenario is the case\n\t\t\t\tif (payload instanceof SelectStmt) {\n\t\t\t\t\tlet selectJson = jsonfy(payload);\n\t\t\t\t\tif (!isDerivedQuery && !isDeepRef) {\n\t\t\t\t\t\t// Fully qualify output names to match target column names. Not necessary at the LinkedQL level\n\t\t\t\t\t\tselectJson = deriveSelectAliasesFromColumns(selectJson, columnsConstructorJson);\n\t\t\t\t\t}\n\t\t\t\t\tdimensionValidateRowLength(payload, selectJson.result_schema);\n\t\t\t\t\tcurrentQuery.select_clause = selectForeignBinding(selectJson, fKBindingJson);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Scenario 3:\n\t\t\t\t// When base query is INSERT ... VALUES\n\n\t\t\t\t// For when preceding offload() was scenario 2\n\t\t\t\tif (currentQuery.select_clause) {\n\t\t\t\t\tcurrentQuery = queryTemplate();\n\t\t\t\t\tqueries.push(currentQuery);\n\t\t\t\t}\n\t\t\t\tif (!currentQuery.values_clause) {\n\t\t\t\t\tcurrentQuery.values_clause = { nodeName: ValuesConstructor.NODE_NAME, entries: [] };\n\t\t\t\t}\n\n\t\t\t\t// Carry deep values forward\n\t\t\t\tif (isDeepRef && !(payload instanceof PGDefaultValuesClause)) {\n\t\t\t\t\tpayload = TypedRowConstructor.fromJSON({ entries: [jsonfy(payload)] });\n\t\t\t\t}\n\n\t\t\t\tif (payload instanceof ValuesTableLiteral) {\n\t\t\t\t\tfor (const rowNode of payload.entries()) {\n\t\t\t\t\t\tdimensionPushRow(currentQuery, rowNode, fKBindingJson);\n\t\t\t\t\t}\n\t\t\t\t} else dimensionPushRow(currentQuery, payload, fKBindingJson);\n\t\t\t};\n\n\t\t\tconst payloadDimension = {\n\t\t\t\trefMode,\n\t\t\t\tqueries,\n\t\t\t\toffload,\n\t\t\t\tlhsOperandJson,\n\t\t\t};\n\n\t\t\tpayloadDimensions.add(payloadDimension);\n\n\t\t\treturn payloadDimension;\n\t\t}\n\n\t\t// INSERT INTO t1 (a, t2 ~> fk ~> (a, b)) VALUES (2, ROW(44, 33)), (3, ROW(11, 22))\n\t\t// INSERT INTO t1 (a, t2 ~> fk ~> a) VALUES (2, 44), (3, 11)\n\t\t// INSERT INTO t1 (a, t2 ~> fk ~> a) SELECT a, b FROM t3\n\n\t\t// The binding elements...\n\t\tconst rhsOperandPKJson = { nodeName: ColumnRef1.NODE_NAME, value: rhsOperand.value(), delim: rhsOperand._get('delim') };\n\n\t\tconst queryTemplate = () => ({\n\t\t\tuuid: transformer.rootContext.rand(refMode),\n\t\t\tnodeName: this.NODE_NAME,\n\t\t\ttable_ref: rhsTableJson,\n\t\t\tcolumn_list: columnsConstructorJson,\n\t\t\treturning_clause: {\n\t\t\t\tnodeName: ReturningClause.NODE_NAME,\n\t\t\t\tentries: [{ nodeName: SelectItem.NODE_NAME, expr: rhsOperand1Json }],\n\t\t\t},\n\t\t});\n\n\t\tconst offload = (payload) => {\n\n\t\t\tif (payload instanceof ValuesTableLiteral) {\n\t\t\t\tthrow new Error(`Single-row payload structure expected for column structure: ${LQRefColumn.right()}. Recieved ${payload.NODE_NAME}.`);\n\t\t\t}\n\n\t\t\tif (!queries.length) {\n\t\t\t\tqueries.push(queryTemplate());\n\t\t\t}\n\t\t\tlet currentQuery = queries[queries.length - 1];\n\n\t\t\tlet isDerivedQuery = false;\n\n\t\t\t// Scenario 2:\n\t\t\t// When the base query is an INSERT ... VALUES (+DerivedQuery)\n\t\t\tif (payload instanceof DerivedQuery) {\n\t\t\t\tpayload = payload.expr();\n\t\t\t\t// For when preceding offload() was scenario 2 or 3\n\t\t\t\tif (currentQuery.select_clause || currentQuery.values_clause) {\n\t\t\t\t\tcurrentQuery = queryTemplate();\n\t\t\t\t\tqueries.push(currentQuery);\n\t\t\t\t}\n\t\t\t\tisDerivedQuery = true;\n\t\t\t}\n\n\t\t\t// Scenario 1 or 2:\n\t\t\t// When the base query is an INSERT ... SELECT\n\t\t\t// or when the preceding scenario is the case\n\t\t\tif (payload instanceof SelectStmt) {\n\n\t\t\t\tlet selectJson = jsonfy(payload);\n\t\t\t\tlet correlationRhs;\n\n\t\t\t\tif (!isDerivedQuery) {\n\t\t\t\t\tif (!isDeepRef) {\n\t\t\t\t\t\t// Fully qualify output names to match target column names. Not necessary at the LinkedQL level\n\t\t\t\t\t\tselectJson = deriveSelectAliasesFromColumns(selectJson, columnsConstructorJson);\n\t\t\t\t\t}\n\t\t\t\t\t// Meaning we're from a literal INSERT ... SELECT statement, not an INSERT ... VALUES (+SELECT) statement\n\t\t\t\t\t// and this time, we want to correlate with base query's row number\n\t\t\t\t\tcorrelationRhs = { nodeName: ColumnRef1.NODE_NAME, value: '$row_number~a' };\n\t\t\t\t}\n\n\t\t\t\tdimensionValidateRowLength(payload, selectJson.result_schema);\n\t\t\t\tcurrentQuery.select_clause = selectJson;\n\n\t\t\t\treturn createForeignBinding(currentQuery.uuid, rhsOperandPKJson, correlationRhs);\n\t\t\t}\n\n\t\t\t// Scenario 3:\n\t\t\t// When base query is INSERT ... VALUES\n\n\t\t\t// For when preceding offload() was scenario 2\n\t\t\tif (currentQuery.select_clause) {\n\t\t\t\tcurrentQuery = queryTemplate();\n\t\t\t\tqueries.push(currentQuery);\n\t\t\t}\n\t\t\tif (!currentQuery.values_clause) {\n\t\t\t\tcurrentQuery.values_clause = { nodeName: ValuesConstructor.NODE_NAME, entries: [] };\n\t\t\t}\n\n\t\t\t// Carry deep values forward\n\t\t\tif (isDeepRef && !(payload instanceof PGDefaultValuesClause)) {\n\t\t\t\tpayload = TypedRowConstructor.fromJSON({ entries: [jsonfy(payload)] });\n\t\t\t}\n\n\t\t\tdimensionPushRow(currentQuery, payload);\n\n\t\t\tlet correlationRhs;\n\t\t\tif (currentQuery.values_clause) {\n\t\t\t\t// Meaning we're from an INSERT ... VALUES statement, not an INSERT ... DEFAULT VALUES statement\n\t\t\t\t// and this this time, currentQuery's row offset is what we use\n\t\t\t\tcorrelationRhs = currentQuery.values_clause.entries.length - 1;\n\t\t\t}\n\n\t\t\treturn createForeignBinding(currentQuery.uuid, rhsOperandPKJson, correlationRhs);\n\t\t};\n\n\t\tconst payloadDimension = {\n\t\t\trefMode,\n\t\t\tqueries,\n\t\t\toffload,\n\t\t\tlhsOperandJson,\n\t\t\trhsOperandJson: rhsOperand1Json\n\t\t};\n\n\t\tpayloadDimensions.add(payloadDimension);\n\n\t\treturn payloadDimension;\n\t}\n\n\tfinalizePayloadJSON(resultJson, transformer, linkedDb, options) {\n\n\t\tconst payloadDimensions = transformer.statementContext.artifacts.get('payloadDimensions');\n\t\tif (!payloadDimensions.size) {\n\t\t\treturn resultJson;\n\t\t}\n\n\t\tconst {\n\t\t\tColumnRef0,\n\t\t\tColumnRef1,\n\t\t\tTableRef1,\n\t\t\tFromItem,\n\t\t\tFromClause,\n\t\t\tAggrCallExpr,\n\t\t\tReturningClause,\n\t\t\tSelectList,\n\t\t\tSelectItem,\n\t\t\tSelectItemAlias,\n\t\t\tNumberLiteral,\n\t\t\tBinaryExpr,\n\t\t\tCTE,\n\t\t\tCTEItem,\n\t\t\tCTEItemAlias,\n\t\t\tCompleteSelectStmt,\n\t\t\tUpdateStmt,\n\t\t} = registry;\n\n\t\tconst baseUUID = transformer.rootContext.hash(this, 'main');\n\t\tconst cte = { nodeName: CTE.NODE_NAME, declarations: [], body: null };\n\t\tconst $transformer = transformer;//new Transformer((node, defaultTransform) => defaultTransform(), null, this);\n\n\t\t// Promote a query to a CTEItem\n\t\tconst toCTEItem = (dimensionID, queryJson, indices = [], transformer = $transformer) => {\n\n\t\t\tlet cteItemJson = CTEItem.fromJSON({\n\t\t\t\tnodeName: CTEItem.NODE_NAME,\n\t\t\t\talias: { nodeName: CTEItemAlias.NODE_NAME, value: dimensionID },\n\t\t\t\texpr: queryJson,\n\t\t\t}, this.options).jsonfy(options, transformer, linkedDb);\n\n\t\t\t// Desugar query and flatten if itself a CTE\n\t\t\tif (cteItemJson.expr?.nodeName === CTE.NODE_NAME) {\n\t\t\t\tcte.declarations.push(...cteItemJson.expr.declarations);\n\n\t\t\t\tif (this instanceof UpdateStmt && cteItemJson.expr.body.nodeName === CompleteSelectStmt.NODE_NAME) {\n\t\t\t\t\t// This is a stray \"SELECT COUNT(*)\" statement owing to how dependencies are rendered in the CTE as dependents\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tcteItemJson = {\n\t\t\t\t\tnodeName: CTEItem.NODE_NAME,\n\t\t\t\t\talias: { nodeName: CTEItemAlias.NODE_NAME, value: dimensionID },\n\t\t\t\t\texpr: cteItemJson.expr.body,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Compose declaration and add...\n\t\t\tcte.declarations.push(cteItemJson);\n\n\t\t\tif (!indices.length) return;\n\n\t\t\tcte.declarations.push(CTEItem.fromJSON({\n\t\t\t\tnodeName: CTEItem.NODE_NAME,\n\t\t\t\talias: { nodeName: CTEItemAlias.NODE_NAME, value: `${dimensionID}~indices` },\n\t\t\t\texpr: flipSelectFromWithRowNumbers(indices, dimensionID),\n\t\t\t}, this.options).jsonfy(options, transformer, linkedDb));\n\t\t};\n\n\t\t// Process entries in stringent order\n\t\tconst dependents = [],\n\t\t\tdeferedDependencies = [],\n\t\t\tlefts = [];\n\n\t\tlet onConflictUpdatedStatusRequired = false;\n\t\tconst originalReturningList = resultJson.returning_clause?.entries || [];\n\n\t\tfor (const { refMode, query: $query, queries, lhsOperandJson, rhsOperandJson, conflictHandlingClauseContext } of payloadDimensions) {\n\t\t\tfor (const { uuid, ...query } of ($query && [$query] || queries)) {\n\t\t\t\tif (refMode === 'dependent' || (this instanceof UpdateStmt && refMode === 'dependency') || conflictHandlingClauseContext) { // Defer dependents\n\n\t\t\t\t\tif (!lefts.find((existing) => _eq(existing.expr.value, lhsOperandJson.value))) {\n\t\t\t\t\t\tconst fieldExpr = { nodeName: SelectItem.NODE_NAME, expr: lhsOperandJson };\n\t\t\t\t\t\tif (originalReturningList.find((existing) => _eq((existing.alias || existing.expr).value, lhsOperandJson.value))) {\n\t\t\t\t\t\t\tfieldExpr.alias = { nodeName: SelectItemAlias.NODE_NAME, as_kw: true, value: transformer.rand('key') };\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlefts.push(fieldExpr);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (conflictHandlingClauseContext) {\n\t\t\t\t\t\tonConflictUpdatedStatusRequired = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tdependents.push({ uuid, ...query });\n\t\t\t\t} else if (refMode === 'dependency') {\n\t\t\t\t\tconst wherePredicate = [{ nodeName: SelectItem.NODE_NAME, expr: rhsOperandJson }];\n\n\t\t\t\t\tif (resultJson.select_clause) {\n\t\t\t\t\t\tdeferedDependencies.push({ uuid, wherePredicate, ...query }); // Dependencies that themselves depend on memo\n\t\t\t\t\t} else if (query.pg_default_values_clause || query.select_clause) {\n\t\t\t\t\t\ttoCTEItem(uuid, query);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttoCTEItem(uuid, query, wherePredicate);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ttoCTEItem(uuid, query);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// (1): Process dependencies with memo\n\t\tfor (const { uuid, wherePredicate, ...query } of deferedDependencies) {\n\t\t\ttoCTEItem(uuid, query, wherePredicate);\n\t\t}\n\n\t\t// (2): Process dependents\n\t\tif (dependents.length) {\n\n\t\t\t// Rewrite returning clause\n\t\t\tconst cteReturningList = [];\n\t\t\tconst newOuterReturningList = [];\n\t\t\tfor (let fieldExpr of originalReturningList) {\n\t\t\t\tif (!fieldExpr.alias) {\n\t\t\t\t\tfieldExpr = {\n\t\t\t\t\t\t...fieldExpr,\n\t\t\t\t\t\talias: { nodeName: SelectItemAlias.NODE_NAME, as_kw: true, value: transformer.rand('key') },\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tcteReturningList.push(fieldExpr);\n\t\t\t\tnewOuterReturningList.push({ ...fieldExpr, expr: { nodeName: ColumnRef1.NODE_NAME, value: fieldExpr.alias.value, delim: fieldExpr.alias.delim } });\n\t\t\t}\n\n\t\t\t// Add conflict_based_update?\n\t\t\tif (onConflictUpdatedStatusRequired) {\n\t\t\t\tconst onConflictUpdatedStatusAlias = `${baseUUID}_conflict_based_update`;\n\t\t\t\tcteReturningList.push({\n\t\t\t\t\tnodeName: SelectItem.NODE_NAME,\n\t\t\t\t\texpr: {\n\t\t\t\t\t\tnodeName: BinaryExpr.NODE_NAME,\n\t\t\t\t\t\tleft: { nodeName: ColumnRef1.NODE_NAME, value: 'XMAX' },\n\t\t\t\t\t\toperator: '!=',\n\t\t\t\t\t\tright: { nodeName: NumberLiteral.NODE_NAME, value: '0' },\n\t\t\t\t\t},\n\t\t\t\t\talias: { nodeName: SelectItemAlias.NODE_NAME, as_kw: true, value: onConflictUpdatedStatusAlias },\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Compose binding and add...\n\t\t\tconst cteReturningClause = { nodeName: ReturningClause.NODE_NAME, entries: [...cteReturningList, ...lefts/* NOTE: cteReturningList may contain \"*\" */] };\n\n\t\t\t// Base query as CTE item\n\t\t\t// If UpdateStmt or onConflictUpdatedStatusRequired, we do not pass lefts\n\t\t\tif (this instanceof UpdateStmt || onConflictUpdatedStatusRequired) {\n\t\t\t\ttoCTEItem(baseUUID, { ...resultJson, returning_clause: cteReturningClause });\n\t\t\t} else if (resultJson.pg_default_values_clause) {\n\t\t\t\ttoCTEItem(baseUUID, { ...resultJson, returning_clause: cteReturningClause });\n\t\t\t} else {\n\t\t\t\ttoCTEItem(baseUUID, { ...resultJson, returning_clause: cteReturningClause }, lefts);\n\t\t\t}\n\n\t\t\t// Process dependents... after having done the above\n\t\t\tfor (const { uuid, ...query } of dependents) {\n\t\t\t\ttoCTEItem(uuid, query);\n\t\t\t}\n\n\t\t\t// Derive final body...\n\t\t\tlet selectItems = newOuterReturningList;\n\n\t\t\tif (!selectItems.length) {\n\t\t\t\tselectItems = [{\n\t\t\t\t\tnodeName: SelectItem.NODE_NAME,\n\t\t\t\t\texpr: { nodeName: AggrCallExpr.NODE_NAME, name: 'COUNT', arguments: [{ nodeName: ColumnRef0.NODE_NAME, value: '*' }] },\n\t\t\t\t\talias: { nodeName: SelectItemAlias.NODE_NAME, as_kw: true, value: 'COUNT' },\n\t\t\t\t}];\n\t\t\t}\n\n\t\t\tconst tableSpec = { nodeName: FromItem.NODE_NAME, expr: { nodeName: TableRef1.NODE_NAME, value: baseUUID } };\n\n\t\t\tcte.body = CompleteSelectStmt.fromJSON({\n\t\t\t\tnodeName: CompleteSelectStmt.NODE_NAME,\n\t\t\t\tselect_list: { nodeName: SelectList.NODE_NAME, entries: selectItems },\n\t\t\t\tfrom_clause: { nodeName: FromClause.NODE_NAME, entries: [tableSpec] },\n\t\t\t}, this.options).jsonfy(options, $transformer, linkedDb);\n\t\t} else {\n\t\t\t// Use resultJson as-is\n\t\t\tconst Classes = [this.constructor].concat(this.constructor.morphsTo()); // InsertStmt/UpsertStmt\n\t\t\tconst instance = Classes.reduce((prev, C) => prev || C.fromJSON(resultJson, this.options), undefined);\n\t\t\tcte.body = instance.jsonfy(options, $transformer, linkedDb);\n\t\t}\n\n\t\treturn { ...cte, result_schema: cte.body.result_schema };\n\t}\n}\n\nconst deriveSelectAliasesFromColumns = (selectJson, columnsConstructorJson) => {\n\tconst newSelectList = selectJson.select_list.entries.reduce((selectList, fieldJson, columnOffset) => {\n\t\tif (!fieldJson.alias) {\n\t\t\tconst correspondingColumn = columnsConstructorJson.entries[columnOffset];\n\t\t\tfieldJson = {\n\t\t\t\t...fieldJson,\n\t\t\t\talias: { nodeName: registry.SelectItemAlias.NODE_NAME, as_kw: true, value: correspondingColumn.value, delim: correspondingColumn.delim },\n\t\t\t}\n\t\t}\n\t\treturn selectList.concat(fieldJson);\n\t}, []);\n\treturn {\n\t\t...selectJson,\n\t\tselect_list: {\n\t\t\t...selectJson.select_list,\n\t\t\tentries: newSelectList,\n\t\t},\n\t};\n};\n\nconst flipSelectFromWithRowNumbers = (selectItems, fromName) => {\n\tconst rowNumberJson = rowNumberExpr('$row_number~b');\n\n\tselectItems = selectItems.map((fieldJson) => {\n\t\tif (fieldJson.alias) {\n\t\t\t// Flip expr/alias\n\t\t\treturn {\n\t\t\t\t...fieldJson,\n\t\t\t\texpr: { ...fieldJson.expr, value: fieldJson.alias.value, delim: fieldJson.alias.delim, qualifier: undefined },\n\t\t\t\talias: { ...fieldJson.alias, value: fieldJson.expr.value, delim: fieldJson.expr.delim },\n\t\t\t};\n\t\t}\n\t\treturn fieldJson.expr.nodeName === registry.ColumnRef0.NODE_NAME ? i : {\n\t\t\t...fieldJson,\n\t\t\texpr: { ...fieldJson.expr, qualifier: undefined },\n\t\t\talias: { nodeName: registry.SelectItemAlias.NODE_NAME, as_kw: true, value: fieldJson.expr.value, delim: fieldJson.expr.delim },\n\t\t};\n\t}).concat(rowNumberJson);\n\n\tconst fromItemJson = {\n\t\tnodeName: registry.FromItem.NODE_NAME,\n\t\texpr: { nodeName: registry.TableRef1.NODE_NAME, value: fromName },\n\t};\n\n\treturn {\n\t\tnodeName: registry.CompleteSelectStmt.NODE_NAME,\n\t\tselect_list: { nodeName: registry.SelectList.NODE_NAME, entries: selectItems },\n\t\tfrom_clause: { nodeName: registry.FromClause.NODE_NAME, entries: [fromItemJson] },\n\t};\n};\n\nconst rowNumberExpr = (alias) => ({\n\tnodeName: registry.SelectItem.NODE_NAME,\n\texpr: { nodeName: registry.AggrCallExpr.NODE_NAME, name: 'ROW_NUMBER', arguments: [], over_clause: { nodeName: registry.WindowSpec.NODE_NAME } },\n\talias: { nodeName: registry.SelectItemAlias.NODE_NAME, as_kw: true, value: alias || 3 },\n});", "import { PayloadStmtMixin } from '../abstracts/PayloadStmtMixin.js';\nimport { DMLStmt } from './DMLStmt.js';\nimport { Transformer } from '../Transformer.js';\nimport { registry } from '../registry.js';\n\nexport class InsertStmt extends PayloadStmtMixin(DMLStmt) {\n\n\t/* SYNTAX RULES */\n\n\tstatic get _clause() { return 'INSERT'; }\n\n\tstatic get syntaxRules() {\n\t\tconst optional_alias_postgres = {\n\t\t\toptional: true,\n\t\t\tsyntax: [\n\t\t\t\t{ type: 'keyword', value: 'AS', booleanfy: true },\n\t\t\t\t{ type: 'Identifier', as: 'pg_table_alias', assert: true }\n\t\t\t]\n\t\t};\n\n\t\tconst optional_alias_mysql = {\n\t\t\toptional: true,\n\t\t\tdialect: 'mysql',\n\t\t\tif: ['!select_clause', '!my_table_clause'],\n\t\t\tsyntax: [\n\t\t\t\t{ type: 'keyword', value: 'AS' },\n\t\t\t\t{ type: 'FromItemAlias', as: 'my_row_alias', assert: true }\n\t\t\t]\n\t\t};\n\n\t\treturn [\n\t\t\t{ type: 'keyword', value: this._clause },\n\t\t\t{ type: 'keyword', value: 'INTO' },\n\t\t\t{\n\t\t\t\tassert: true,\n\t\t\t\tsyntax: [\n\t\t\t\t\t{\n\t\t\t\t\t\tdialect: 'postgres',\n\t\t\t\t\t\tsyntax: [\n\t\t\t\t\t\t\t{ type: 'TableRef2', as: 'table_ref' },\n\t\t\t\t\t\t\t{ ...optional_alias_postgres },\n\t\t\t\t\t\t\t{ type: 'ColumnsConstructor', as: 'column_list', optional: true, autoIndent: true, },\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tsyntaxes: [\n\t\t\t\t\t\t\t\t\t{ type: 'PGDefaultValuesClause', as: 'pg_default_values_clause' },\n\t\t\t\t\t\t\t\t\t{ type: 'ValuesConstructor', as: 'values_clause' },\n\t\t\t\t\t\t\t\t\t{ type: 'SelectStmt', as: 'select_clause' },\n\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\tautoSpacing: '\\n'\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t...(this._clause === 'INSERT' ? [{ type: 'PGOnConflictClause', as: 'conflict_handling_clause', optional: true, autoSpacing: '\\n' }] : []),\n\t\t\t\t\t\t\t{ type: 'ReturningClause', as: 'returning_clause', optional: true, autoSpacing: '\\n' },\n\t\t\t\t\t\t],\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tdialect: 'mysql',\n\t\t\t\t\t\tsyntax: [\n\t\t\t\t\t\t\t{ type: 'TableRef2', as: 'table_ref' },\n\t\t\t\t\t\t\t{ type: 'MYPartitionClause', as: 'my_partition_clause', optional: true, autoIndent: true },\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tsyntaxes: [\n\t\t\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t\t{ type: 'ColumnsConstructor', as: 'column_list', optional: true, autoIndent: true },\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tsyntaxes: [\n\t\t\t\t\t\t\t\t\t\t\t\t{ type: 'ValuesConstructor', as: 'values_clause' },\n\t\t\t\t\t\t\t\t\t\t\t\t{ type: 'SelectStmt', as: 'select_clause' },\n\t\t\t\t\t\t\t\t\t\t\t\t{ type: 'TableStmt', as: 'my_table_clause' },\n\t\t\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\t\t\tautoSpacing: '\\n'\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\t{ type: 'SetClause', as: 'my_set_clause', autoSpacing: '\\n' },\n\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{ ...optional_alias_mysql },\n\t\t\t\t\t\t\t...(this._clause === 'INSERT' ? [{ type: 'MYOnDuplicateKeyUpdateClause', as: 'conflict_handling_clause', optional: true, autoSpacing: '\\n' }] : []),\n\t\t\t\t\t\t],\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t}\n\t\t];\n\t}\n\n\t/* AST API */\n\n\ttableRef() { return this._get('table_ref'); }\n\n\tcolumnList() { return this._get('column_list'); }\n\n\tvaluesClause() { return this._get('values_clause'); }\n\n\tselectClause() { return this._get('select_clause'); }\n\n\tconflictHandlingClause() { return this._get('conflict_handling_clause'); }\n\n\t// -- Postgres\n\n\tpgTableAlias() { return this._get('pg_table_alias'); }\n\n\tpgDefaultValuesClause() { return this._get('pg_default_values_clause'); }\n\n\treturningClause() { return this._get('returning_clause'); }\n\n\t// -- MySQL\n\n\tmyRowAlias() { return this._get('my_row_alias'); }\n\n\tmyPartitionClause() { return this._get('my_partition_clause'); }\n\n\tmySetClause() { return this._get('my_set_clause'); }\n\n\tmyTableClause() { return this._get('my_table_clause'); }\n\n\t/* JSON API */\n\n\tjsonfy(options = {}, transformer = null, linkedDb = null) {\n\t\tif (!options.deSugar) return super.jsonfy(options, transformer, linkedDb);\n\n\t\ttransformer = new Transformer((node, defaultTransform) => {\n\t\t\t// Process table abstraction nodes\n\t\t\tif (node instanceof registry.TableRef2) {\n\t\t\t\tlet subResultJson = defaultTransform();\n\n\t\t\t\tlet resultSchema = subResultJson.result_schema;\n\t\t\t\tif (subResultJson.pg_table_alias) {\n\t\t\t\t\tresultSchema = resultSchema.clone({ renameTo: subResultJson.pg_table_alias });\n\t\t\t\t}\n\n\t\t\t\ttransformer.statementContext.artifacts.get('tableSchemas').add({ type: 'dml', resultSchema });\n\n\t\t\t\treturn subResultJson;\n\t\t\t}\n\t\t\treturn defaultTransform();\n\t\t}, transformer, this/* IMPORTANT */);\n\n\t\tlet resultJson = super.jsonfy(options, transformer, linkedDb);\n\t\tconst toDialect = options.toDialect || this.options.dialect;\n\n\t\t// Order ouput JSON\n\t\tif (toDialect === 'mysql') {\n\t\t\tresultJson = {\n\t\t\t\tuuid: resultJson.uuid,\n\t\t\t\tnodeName: resultJson.nodeName,\n\t\t\t\ttable_ref: resultJson.table_ref,\n\t\t\t\tmy_partition_clause: resultJson.my_partition_clause,\n\t\t\t\tcolumn_list: resultJson.column_list,\n\t\t\t\tvalues_clause: resultJson.values_clause,\n\t\t\t\tselect_clause: resultJson.select_clause,\n\t\t\t\tmy_table_clause: resultJson.my_table_clause,\n\t\t\t\tmy_set_clause: resultJson.my_set_clause,\n\t\t\t\tmy_row_alias: resultJson.my_row_alias,\n\t\t\t\tconflict_handling_clause: resultJson.conflict_handling_clause,\n\t\t\t};\n\t\t} else {\n\t\t\tresultJson = {\n\t\t\t\tuuid: resultJson.uuid,\n\t\t\t\tnodeName: resultJson.nodeName,\n\t\t\t\ttable_ref: resultJson.table_ref,\n\t\t\t\tpg_table_alias: resultJson.pg_table_alias,\n\t\t\t\tcolumn_list: resultJson.column_list,\n\t\t\t\tpg_default_values_clause: resultJson.pg_default_values_clause,\n\t\t\t\tvalues_clause: resultJson.values_clause,\n\t\t\t\tselect_clause: resultJson.select_clause,\n\t\t\t\tconflict_handling_clause: resultJson.conflict_handling_clause,\n\t\t\t\treturning_clause: resultJson.returning_clause,\n\t\t\t\tresult_schema: resultJson.result_schema,\n\t\t\t};\n\t\t}\n\n        if (resultJson.conflict_handling_clause?.entries\n\t\t\t&& !resultJson.conflict_handling_clause.entries.length) {\n            // All assignments were BackRefs and have been offloaded\n            const pkConstraint = resultJson.table_ref.result_schema.pkConstraint(true);\n            const pkColumn = pkConstraint.columns()[0];\n            resultJson = {\n                ...resultJson,\n                conflict_handling_clause: {\n                    ...resultJson.conflict_handling_clause,\n                    entries: [{\n                        nodeName: registry.AssignmentExpr.NODE_NAME,\n                        left: pkColumn.jsonfy(),\n                        operator: '=',\n                        right: pkColumn.jsonfy({ toKind: 1 })\n                    }],\n                },\n            };\n        }\n\n\t\tif (toDialect === 'postgres'\n\t\t\t&& !resultJson.pg_table_alias\n\t\t\t&& Number(options.deSugar) > 2) {\n\t\t\tresultJson = {\n\t\t\t\t...resultJson,\n\t\t\t\tpg_table_alias: {\n\t\t\t\t\tnodeName: registry.Identifier.NODE_NAME,\n\t\t\t\t\tvalue: resultJson.table_ref.value,\n\t\t\t\t\tdelim: resultJson.table_ref.delim\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\n\t\t// 1. Finalize output JSON\n\t\tresultJson = this.finalizeOutputJSON(resultJson, transformer, linkedDb, options);\n\t\t// 2. Finalize generated JOINS. Must come last\n\t\tresultJson = this.finalizePayloadJSON(resultJson, transformer, linkedDb, options);\n\n\t\treturn resultJson;\n\t}\n}", "import { AbstractNodeList } from '../abstracts/AbstractNodeList.js';\n\nexport class MYSetStmt extends AbstractNodeList {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'keyword', value: 'SET' },\n            { type: 'MYVarAssignmentExpr', as: 'entries', arity: { min: 1 }, itemSeparator, assert: true, autoIndent: 2 },\n        ];\n    }\n}", "import { SelectorStmtMixin } from '../abstracts/SelectorStmtMixin.js';\nimport { PayloadStmtMixin } from '../abstracts/PayloadStmtMixin.js';\nimport { DMLStmt } from './DMLStmt.js';\nimport { Transformer } from '../Transformer.js';\nimport { registry } from '../registry.js';\n\nexport class UpdateStmt extends PayloadStmtMixin/* Must be outer as can morph to a CTE */(SelectorStmtMixin(DMLStmt)) {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'keyword', value: 'UPDATE' },\n            {\n                assert: true,\n                syntaxes: [\n                    {\n                        dialect: 'postgres',\n                        syntax: [\n                            { type: 'TableAbstraction2', as: 'table_expr' },\n                            { type: 'SetClause', as: 'set_clause', autoSpacing: '\\n' },\n                            { type: 'FromClause', as: 'pg_from_clause', optional: true, dialect: 'postgres', autoSpacing: '\\n' },\n                            { type: 'JoinClause', as: 'join_clauses', arity: Infinity, optional: true, autoSpacing: '\\n' },\n                            { type: ['PGWhereCurrentClause', 'WhereClause'], as: 'where_clause', optional: true, autoSpacing: '\\n' },\n                            { type: 'ReturningClause', as: 'returning_clause', optional: true, autoSpacing: '\\n' },\n                        ],\n                    },\n                    {\n                        dialect: 'mysql',\n                        syntax: [\n                            { type: 'TableAbstraction2', as: 'table_expr' },\n                            { type: 'SetClause', as: 'set_clause', autoSpacing: '\\n' },\n                            { type: 'WhereClause', as: 'where_clause', optional: true, autoSpacing: '\\n' },\n                            { type: 'OrderByClause', as: 'my_order_by_clause', optional: true, autoSpacing: '\\n' },\n                            { type: 'LimitClause', as: 'my_limit_clause', optional: true, autoSpacing: '\\n' },\n                        ],\n                    },\n                    {\n                        dialect: 'mysql',\n                        syntax: [\n                            { type: 'TableAbstraction1', as: 'my_update_list', arity: { min: 1 }, itemSeparator },\n                            { type: 'JoinClause', as: 'join_clauses', arity: Infinity, optional: true, autoSpacing: '\\n' },\n                            { type: 'SetClause', as: 'set_clause', autoSpacing: '\\n' },\n                            { type: 'WhereClause', as: 'where_clause', optional: true, autoSpacing: '\\n' },\n                        ],\n                    },\n                ]\n            }\n        ];\n    }\n\n    /* AST API */\n\n    tableExpr() { return this._get('table_expr'); }\n\n    joinClauses() { return this._get('join_clauses'); }\n\n    setClause() { return this._get('set_clause'); }\n\n    whereClause() { return this._get('where_clause'); }\n\n    // Postgres\n\n    pgFromClause() { return this._get('pg_from_clause'); }\n\n    returningClause() { return this._get('returning_clause'); }\n\n    // MySQL\n\n    myUpdateList() { return this._get('my_update_list'); }\n\n    myOrderByClause() { return this._get('my_order_by_clause'); }\n\n    myLimitClause() { return this._get('my_limit_clause'); }\n\n    /* JSON API */\n\n    jsonfy(options = {}, transformer = null, linkedDb = null) {\n        if (!options.deSugar) return super.jsonfy(options, transformer, linkedDb);\n\n        transformer = new Transformer((node, defaultTransform) => {\n            return defaultTransform();\n        }, transformer, this/* IMPORTANT */);\n\n        let resultJson = super.jsonfy(options, transformer, linkedDb);\n\n        // Order ouput JSON\n        if ((options.toDialect || this.options.dialect) === 'mysql') {\n            resultJson = {\n                uuid: resultJson.uuid,\n                nodeName: resultJson.nodeName,\n                table_expr: resultJson.table_expr,\n                my_update_list: resultJson.my_update_list,\n                join_clauses: resultJson.join_clauses,\n                set_clause: resultJson.set_clause,\n                where_clause: resultJson.where_clause,\n                my_order_by_clause: resultJson.my_order_by_clause,\n                my_limit_clause: resultJson.my_limit_clause,\n            };\n        } else {\n            resultJson = {\n                uuid: resultJson.uuid,\n                nodeName: resultJson.nodeName,\n                table_expr: resultJson.table_expr,\n                set_clause: resultJson.set_clause,\n                pg_from_clause: resultJson.pg_from_clause,\n                join_clauses: resultJson.join_clauses,\n                where_clause: resultJson.where_clause,\n                returning_clause: resultJson.returning_clause,\n                result_schema: resultJson.result_schema,\n            };\n        }\n\n        if (!resultJson.set_clause?.entries.length) {\n            // All assignments were BackRefs and have been offloaded\n            const pkConstraint = resultJson.table_expr.result_schema.pkConstraint(true);\n            const pkColumn = pkConstraint.columns()[0];\n            resultJson = {\n                ...resultJson,\n                set_clause: {\n                    ...resultJson.set_clause,\n                    entries: [{\n                        nodeName: registry.AssignmentExpr.NODE_NAME,\n                        left: pkColumn.jsonfy(),\n                        operator: '=',\n                        right: pkColumn.jsonfy({ toKind: 1 })\n                    }],\n                },\n            };\n        }\n\n        // 1. Finalize output JSON\n\t\tresultJson = this.finalizeOutputJSON(resultJson, transformer, linkedDb, options);\n        // 2. Finalize generated JOINS. Must come first\n        resultJson = this.finalizeSelectorJSON(resultJson, transformer, linkedDb, options);\n        // 3. Finalize entire query rewrite - returning a CTE\n        resultJson = this.finalizePayloadJSON(resultJson, transformer, linkedDb, options);\n\n        return resultJson;\n    }\n}", "import { SugarMixin } from '../abstracts/SugarMixin.js';\nimport { InsertStmt } from './InsertStmt.js';\nimport { registry } from '../registry.js';\nimport { _eq } from '../util.js';\n\nexport class UpsertStmt extends SugarMixin(InsertStmt) {\n\n\t/* SYNTAX RULES */\n\n\tstatic get _clause() { return 'UPSERT'; }\n\n\tstatic morphsTo() { return [InsertStmt].concat(super.morphsTo()); }\n\n\t/* DESUGARING API */\n\n\tfinalizePayloadJSON(resultJson, transformer, linkedDb, options) {\n\t\tif (resultJson.conflict_handling_clause) {\n\t\t\tthrow new Error(`An explicit conflict handling clause is forbidden on the UPSERT statement.`);\n\t\t}\n\n\t\tconst tableSchema = [...transformer.statementContext.artifacts.get('tableSchemas')].map((t) => t.resultSchema)[0];\n\t\tconst toDialect = options.toDialect || this.options.dialect;\n\n\t\tlet columnNamesJson;\n\t\tif (resultJson.my_set_clause) {\n\t\t\tcolumnNamesJson = resultJson.my_set_clause.entries.map((e) => ({ value: e.left.value, delim: e.left.delim }));\n\t\t} else if (resultJson.column_list) {\n\t\t\tcolumnNamesJson = resultJson.column_list.entries.map((e) => ({ value: e.value, delim: e.delim }));\n\t\t} else {\n\t\t\tcolumnNamesJson = tableSchema.columns().map((c) => c.name().jsonfy({ nodeNames: false }));\n\t\t}\n\n\t\tconst conflictHandlingClause = {\n\t\t\tnodeName: toDialect === 'mysql'\n\t\t\t\t? registry.MYOnDuplicateKeyUpdateClause.NODE_NAME\n\t\t\t\t: registry.PGOnConflictClause.NODE_NAME,\n\t\t\tentries: columnNamesJson.map((c) => ({\n\t\t\t\tnodeName: registry.AssignmentExpr.NODE_NAME,\n\t\t\t\tleft: {\n\t\t\t\t\tnodeName: toDialect === 'mysql'\n\t\t\t\t\t\t? registry.ColumnRef1.NODE_NAME\n\t\t\t\t\t\t: registry.ColumnRef2.NODE_NAME,\n\t\t\t\t\t...c,\n\t\t\t\t},\n\t\t\t\toperator: '=',\n\t\t\t\tright: {\n\t\t\t\t\t...c,\n\t\t\t\t\tnodeName: registry.ColumnRef1.NODE_NAME,\n\t\t\t\t\tqualifier: { value: toDialect === 'mysql' ? 'VALUES' : 'EXCLUDED' },\n\t\t\t\t}\n\t\t\t})),\n\t\t};\n\n\t\tif (toDialect === 'postgres') {\n\t\t\tconst uniqueKeysColumnSets = [].concat(tableSchema.pkConstraint(true) || []).concat(tableSchema.ukConstraints(true)).map((k) => k.columns().map((c) => c.jsonfy()));\n\t\t\tif (!uniqueKeysColumnSets.length) {\n\t\t\t\tthrow new Error(`Table ${this.tableRef()} has no unique keys defined to process an UPSERT operation. You may want to perform a direct INSERT operation.`);\n\t\t\t}\n\n\t\t\tconst firstUniqueKeysColumnSet = uniqueKeysColumnSets.find((colSet) => colSet.find((k) => columnNamesJson.find((c) => _eq(k.value, c.value, k.delim || c.delim)))) || uniqueKeysColumnSets[0];\n\n\t\t\tconflictHandlingClause.conflict_target = {\n\t\t\t\tnodeName: registry.PGConflictTarget.NODE_NAME,\n\t\t\t\tindex_list: firstUniqueKeysColumnSet.map((c) => ({\n\t\t\t\t\tnodeName: registry.PGConflictTargetIndexSpec.NODE_NAME,\n\t\t\t\t\tcolumn_name: c\n\t\t\t\t})),\n\t\t\t};\n\t\t}\n\t\t\n\t\treturn super.finalizePayloadJSON({\n\t\t\t...resultJson,\n\t\t\tnodeName: InsertStmt.NODE_NAME,\n\t\t\tconflict_handling_clause: conflictHandlingClause\n\t\t}, transformer, linkedDb, options);\n\t}\n}", "export * from './clauses/index.js';\nexport * from './TA/index.js';\nexport { CompleteSelectStmt } from './CompleteSelectStmt.js';\nexport { BasicSelectStmt } from './BasicSelectStmt.js';\nexport { CompositeSelectStmt } from './CompositeSelectStmt.js';\nexport { SelectStmt } from './SelectStmt.js';\nexport { TableStmt } from './TableStmt.js';\n", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class DistinctClause extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return {\n            syntaxes: [\n                {\n                    dialect: 'postgres',\n                    syntax: [\n                        { type: 'keyword', value: 'DISTINCT' },\n                        { type: 'keyword', value: 'ON' },\n                        {\n                            type: 'paren_block',\n                            syntax: { type: 'Expr', as: 'pg_distinct_on_list', arity: { min: 1 }, itemSeparator, assert: true }\n                        },\n                    ],\n                },\n                { type: 'keyword', as: 'all_or_distinct', value: ['ALL', 'DISTINCT'] },\n            ]\n        };\n    }\n\n    /* AST API */\n\n    allOrDistinct() { return this._get('all_or_distinct'); }\n\n    // -- Postgres\n\n    pgDistinctOnList() { return this._get('pg_distinct_on_list'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class ForClause extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'keyword', value: 'FOR' },\n            {\n                optional: true,\n                dialect: 'postgres',\n                syntaxes: [\n                    [\n                        { type: 'keyword', as: 'pg_no_key_kw', value: 'NO', booleanfy: true },\n                        { type: 'keyword', value: 'KEY', if: 'pg_no_key_kw', assert: true }\n                    ],\n                    { type: 'keyword', as: 'pg_key_kw', value: 'KEY', booleanfy: true },\n                ],\n            },\n            { type: 'keyword', as: 'intent_kw', value: ['UPDATE', 'SHARE'], assert: true },\n            {\n                optional: true,\n                syntax: [\n                    { type: 'keyword', value: 'OF' },\n                    { type: 'TableRef2', as: 'table_names', arity: { min: 1 }, itemSeparator, assert: true }\n                ],\n            },\n            {\n                optional: true,\n                syntaxes: [\n                    [\n                        { type: 'keyword', as: 'skip_locked_kw', value: 'SKIP', booleanfy: true },\n                        { type: 'keyword', value: 'LOCKED', assert: true }\n                    ],\n                    { type: 'keyword', as: 'nowait_kw', value: 'NOWAIT', booleanfy: true },\n                    {\n                        dialect: 'mysql',\n                        syntax: [\n                            { type: 'keyword', as: 'my_lock_in_share_mode', value: 'LOCK', booleanfy: true },\n                            { type: 'operator', value: 'IN', assert: true },\n                            { type: 'keyword', value: 'SHARE', assert: true },\n                            { type: 'keyword', value: 'MODE', assert: true },\n                        ],\n                    },\n                ],\n            }\n        ];\n    }\n\n    /* AST API */\n\n    intentKW() { return this._get('intent_kw'); }\n\n    tableNames() { return this._get('table_names'); }\n\n    skipLockedKW() { return this._get('skip_locked_kw'); }\n\n    nowaitKW() { return this._get('nowait_kw'); }\n\n    // -- Postgres\n\n    pgKeyKW() { return this._get('pg_key_kw'); }\n\n    pgNoKeyKW() { return this._get('pg_no_key_kw'); }\n\n    // -- MySQL\n\n    myLockInShareMode() { return this._get('my_lock_in_share_mode'); }\n}", "import { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\n\nexport class FromClause extends AbstractNodeList {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'keyword', value: 'FROM' },\n            { type: 'FromItem', as: 'entries', arity: { min: 1 }, itemSeparator, assert: true }\n        ];\n    }\n}", "import { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\n\nexport class GroupByClause extends AbstractNodeList {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'keyword', value: 'GROUP' },\n            { type: 'keyword', value: 'BY', assert: true },\n            { type: 'keyword', as: 'all_or_distinct', value: ['ALL', 'DISTINCT'], optional: true },\n            { type: 'GroupingElement', as: 'entries', arity: { min: 1 }, itemSeparator, assert: true, autoIndent: 2 },\n            {\n                optional: true,\n                autoIndent: true,\n                syntax: [\n                    { type: 'keyword', as: 'with_rollup', value: 'WITH', booleanfy: true },\n                    { type: 'keyword', value: 'ROLLUP', assert: true },\n                ]\n            },\n        ];\n    }\n\n    /* AST API */\n\n    allOrDistinct() { return this._get('all_or_distinct'); }\n\n    withRollup() { return this._get('with_rollup'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class GroupingElement extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return {\n            syntaxes: [\n                [\n                    { type: 'keyword', value: 'GROUPING SETS' },\n                    {\n                        type: 'paren_block', syntax:\n                            { type: 'GroupingElement', as: 'grouping_sets', arity: { min: 1 }, itemSeparator, assert: true, autoIndent: 2 },\n                        autoIndent: true\n                    }\n                ],\n                [\n                    { type: 'keyword', value: 'ROLLUP' },\n                    { type: 'RowConstructor', as: 'rollup_set', assert: true },\n                ],\n                [\n                    { type: 'keyword', value: 'CUBE' },\n                    { type: 'RowConstructor', as: 'cube_set', assert: true },\n                ],\n                { type: ['Expr', 'ParenExpr'], as: 'expr' },\n            ]\n        };\n    }\n\n    /* AST API */\n\n    groupingSets() { return this._get('grouping_sets'); }\n\n    rollupSet() { return this._get('rollup_set'); }\n\n    cubeSet() { return this._get('cube_set'); }\n\n    expr() { return this._get('expr'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class HavingClause extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', value: 'HAVING' },\n            { type: 'Expr', as: 'expr', assert: true }\n        ];\n    }\n\n    static get syntaxPriority() { return -1; }\n\n    /* AST API */\n\n    expr() { return this._get('expr'); }\n}", "import { DDLSchemaMixin } from '../../abstracts/DDLSchemaMixin.js';\nimport { AbstractNode } from '../../abstracts/AbstractNode.js';\nimport { Transformer } from '../../Transformer.js';\nimport { registry } from '../../registry.js';\n\nexport class FromItem extends DDLSchemaMixin(AbstractNode) {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n\n        const optional_table_sample_clause_postgres = {\n            optional: true,\n            dialect: 'postgres',\n            syntax: [\n                { type: 'keyword', value: 'TABLESAMPLE' },\n                {\n                    syntaxes: [\n                        [\n                            { type: 'keyword', as: 'pg_sampling_method', value: ['BERNOULLI', 'SYSTEM'] },\n                            { type: 'paren_block', syntax: { type: 'Expr', as: 'pg_sampling_arguments', arity: 1, itemSeparator, assert: true } },\n                        ],\n                        [\n                            { type: 'identifier', as: 'pg_sampling_method' },\n                            { type: 'paren_block', syntax: { type: 'Expr', as: 'pg_sampling_arguments', arity: Infinity, itemSeparator, assert: true } },\n                        ],\n                    ],\n                    assert: true,\n                },\n                {\n                    optional: true,\n                    syntax: [\n                        { type: 'keyword', value: 'REPEATABLE' },\n                        { type: 'paren_block', syntax: { type: 'Expr', as: 'pg_repeatable_seed' }, assert: true },\n                    ]\n                }\n            ]\n        };\n\n        return {\n            syntaxes: [\n                // SRFTableDef1, SRFTableDef2, SRFTableDef3\n                [\n                    { type: 'keyword', as: 'lateral_kw', value: 'LATERAL', booleanfy: true, optional: true },\n                    { type: 'SRFExpr1', as: 'expr' },\n                ],\n                [\n                    { type: 'keyword', as: 'lateral_kw', value: 'LATERAL', booleanfy: true, optional: true },\n                    { type: ['SRFExpr2', 'SRFExpr4'], as: 'expr' },\n                    { type: 'FromItemAlias', as: 'alias', optional: true },\n                ],\n                // DerivedQuery, ValuesTableLiteral\n                [\n                    { type: 'keyword', as: 'lateral_kw', value: 'LATERAL', booleanfy: true, optional: true },\n                    { type: ['DerivedQuery', 'ValuesTableLiteral'], as: 'expr', dialect: 'postgres' },\n                    { type: 'DerivedQuery', as: 'expr', dialect: 'mysql' },\n                    { type: 'FromItemAlias', as: 'alias', optional: true },\n                ],\n                // TableRef1\n                [\n                    { type: 'keyword', as: 'pg_only_kw', value: 'ONLY', optional: true, dialect: 'postgres' },\n                    { type: ['TableRef1', 'TableRef2'], as: 'expr' },\n                    { type: 'operator', as: 'pg_star_ref', value: '*', booleanfy: true, optional: true, dialect: 'postgres' },\n                    { type: 'FromItemAlias', as: 'alias', optional: true },\n                    { ...optional_table_sample_clause_postgres },\n                ],\n            ],\n        };\n    }\n\n    /* AST API */\n\n    lateralKW() { return this._get('lateral_kw'); }\n\n    expr() { return this._get('expr'); }\n\n    alias() { return this._get('alias'); }\n\n    // -- Postgres\n\n    pgOnlyKW() { return this._get('pg_only_kw'); }\n\n    pgStarRef() { return this._get('pg_star_ref'); }\n\n    pgSamplingMethod() { return this._get('pg_sampling_method'); }\n\n    pgSamplingArguments() { return this._get('pg_sampling_arguments'); }\n\n    pgRepeatableSeed() { return this._get('pg_repeatable_seed'); }\n\n    /* SCHEMA API */\n\n    deriveAlias() {\n        let derivedAliasJson;\n        if (this.alias()?.value()) {\n            derivedAliasJson = { as_kw: true, value: this.alias().value(), delim: this.alias()._get('delim') };\n        } else if (this.expr() instanceof registry.TableRef1 || this.expr() instanceof registry.TableRef2) {\n            derivedAliasJson = { as_kw: true, value: this.expr().value(), delim: this.expr()._get('delim') };\n        } else if (this.expr() instanceof registry.SRFExpr1\n            && this.expr().qualif() instanceof registry.SRFExprDDL2) {\n            derivedAliasJson = { as_kw: true, value: this.expr().qualif().alias().value(), delim: this.expr().qualif().alias()._get('delim') };\n        }\n        if (derivedAliasJson) {\n            return registry.FromItemAlias.fromJSON(derivedAliasJson);\n        }\n    }\n\n    jsonfy(options = {}, transformer = null, linkedDb = null) {\n        let resultJson = super.jsonfy(options, transformer, linkedDb);\n        if (options.deSugar) {\n\n            const derivedAliasJson = resultJson.alias || this.deriveAlias()?.jsonfy();\n\n            const schemaIdent = derivedAliasJson?.value && {\n                nodeName: registry.Identifier.NODE_NAME,\n                value: derivedAliasJson.value,\n                delim: derivedAliasJson.delim,\n            };\n\n            let resultSchema = resultJson.expr.result_schema;\n\n            if (resultSchema instanceof registry.TableSchema) {\n                resultSchema = resultSchema.clone({ renameTo: schemaIdent });\n            } else if (schemaIdent) {\n                resultSchema = registry.TableSchema.fromJSON({\n                    name: schemaIdent,\n                    entries: resultSchema?.entries().map((s) => s.jsonfy()) || [],\n                });\n            }\n\n            if (resultJson.alias?.columns?.length) {\n                if (resultJson.alias.columns.length !== resultSchema.length) {\n                    throw new SyntaxError(`[${this}] Number of column aliases must match number of result columns.`);\n                }\n                resultSchema = resultSchema.clone({}, new Transformer((node, defaultTransform, key) => {\n                    if (typeof key === 'number' && node.parentNode === resultSchema) {\n                        if (node instanceof registry.ColumnSchema) {\n                            return node.jsonfy({ renameTo: resultJson.alias.columns[key] });\n                        }\n                        return {\n                            ...node.jsonfy(),\n                            nodeName: registry.ColumnSchema.NODE_NAME,\n                            name: resultJson.alias.columns[key],\n                        };\n                    }\n                    return defaultTransform();\n                }));\n            }\n\n            transformer.statementContext.artifacts.get('tableSchemas').add({ type: this.joinType?.() || 'dql', lateral: this.lateralKW(), resultSchema });\n\n            const applicableAliasJson = !(this.expr() instanceof registry.SRFExpr1) && (\n                Number(options.deSugar) > 2 || Number(options.deSugar) > 1 && (this.parentNode?.length || 0) > 1\n            ) && derivedAliasJson || resultJson.alias;\n            resultJson = {\n                ...resultJson,\n                alias: applicableAliasJson,\n                result_schema: resultSchema,\n            };\n        }\n\n        return resultJson;\n    }\n}", "import { Transformer } from '../../Transformer.js';\nimport { FromItem } from '../TA/FromItem.js';\n\nexport class JoinClause extends FromItem {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            syntaxes: [\n                [\n                    { type: 'keyword', as: 'join_type', value: 'CROSS' },\n                    { type: 'keyword', value: 'JOIN', assert: true },\n                    ...[].concat(super.syntaxRules),\n                ],\n                [\n                    { type: 'keyword', as: 'natural_kw', value: 'NATURAL', booleanfy: true, optional: true },\n                    {\n                        optional: true,\n                        syntaxes: [\n                            { type: 'keyword', as: 'join_type', value: 'INNER' },\n                            [\n                                { type: 'keyword', as: 'join_type', value: ['LEFT', 'RIGHT', 'FULL'], dialect: 'postgres' },\n                                { type: 'keyword', as: 'join_type', value: ['LEFT', 'RIGHT'], dialect: 'mysql' },\n                                { type: 'keyword', as: 'outer_kw', value: 'OUTER', booleanfy: true, optional: true },\n                            ],\n                        ],\n                    },\n                    { type: 'keyword', value: 'JOIN' },\n                    ...[].concat(super.syntaxRules),\n                    { type: ['OnClause', 'UsingClause'], as: 'condition_clause', if: '!natural_kw', assert: true, autoIndent: true },\n                ],\n            ],\n        };\n    }\n\n    /* AST API */\n\n    naturalKW() { return this._get('natural_kw'); }\n\n    joinType() { return this._get('join_type'); }\n\n    outerKW() { return this._get('outer_kw'); }\n\n    conditionClause() { return this._get('condition_clause'); }\n\n    /* JSON API */\n\n    jsonfy(options = {}, transformer = null, linkedDb = null) {\n        let conditionClauseTransform;\n\n        if (options.deSugar) {\n            transformer = new Transformer((node, defaultTransform, keyHint) => {\n                if (keyHint === 'condition_clause') {\n                    conditionClauseTransform = defaultTransform;\n                } else return defaultTransform();\n            }, transformer, this.statementNode/* IMPORTANT */);\n        }\n\n        let resultJson = super.jsonfy(options, transformer, linkedDb);\n\n        if (conditionClauseTransform) {\n            resultJson = {\n                ...resultJson,\n                condition_clause: conditionClauseTransform(),\n            };\n        }\n\n        return resultJson;\n    }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class LimitClause extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', value: 'LIMIT' },\n            {\n                dialect: 'mysql',\n                syntax: [\n                    {\n                        optional: true,\n                        syntax: [\n                            { type: 'Expr', as: 'my_offset' },\n                            { type: 'punctuation', value: ',', autoSpacing: false },\n                        ]\n                    },\n                    { type: 'Expr', as: 'expr', assert: true, },\n                ]\n            },\n            {\n                dialect: 'postgres',\n                syntaxes: [\n                    { type: 'keyword', as: 'pg_all_kw', value: 'ALL' },\n                    { type: 'Expr', as: 'expr', assert: true, },\n                ],\n            },\n        ];\n    }\n\n    /* AST API */\n\n    expr() { return this._get('expr'); }\n\n    // -- Postgres\n\n    pgAllKW() { return this._get('pg_all_kw'); }\n\n    // -- MySQL\n\n    myOffset() { return this._get('my_offset'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class OffsetClause extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', value: 'OFFSET' },\n            { type: 'Expr', as: 'expr', assert: true, },\n            { type: 'keyword', as: 'pg_row_kw', value: ['ROW', 'ROWS'], optional: true, dialect: 'postgres' },\n        ];\n    }\n\n    /* AST API */\n\n    expr() { return this._get('expr'); }\n\n    // -- Postgres\n\n    pgRowKW() { return this._get('pg_row_kw'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class OnClause extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', value: 'ON' },\n            { type: 'Expr', as: 'expr', assert: true }\n        ];\n    }\n\n    /* AST API */\n\n    expr() { return this._get('expr'); }\n}", "import { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\n\nexport class OrderByClause extends AbstractNodeList {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'keyword', value: 'ORDER' },\n            { type: 'keyword', value: 'BY', assert: true },\n            { type: 'OrderElement', as: 'entries', arity: { min: 1 }, itemSeparator, assert: true, autoIndent: 2 },\n            {\n                optional: true,\n                autoIndent: true,\n                syntax: [\n                    { type: 'keyword', as: 'with_rollup', value: 'WITH', booleanfy: true },\n                    { type: 'keyword', value: 'ROLLUP', assert: true },\n                ]\n            },\n        ];\n    }\n\n    /* AST API */\n\n    withRollup() { return this._get('with_rollup'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class OrderElement extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'Expr', as: 'expr' },\n            {\n                optional: true,\n                syntaxes: [\n                    { type: 'keyword', value: ['ASC', 'DESC'], as: 'dir' },\n                    { type: 'PGOrderOperator', as: 'dir' },\n                ]\n            },\n            {\n                optional: true,\n                syntax: [\n                    { type: 'keyword', value: 'NULLS' },\n                    { type: 'keyword', as: 'nulls_spec', value: ['FIRST', 'LAST'], assert: true },\n                ]\n            },\n        ];\n    }\n\n    /* AST API */\n\n    expr() { return this._get('expr'); }\n\n    dir() { return this._get('dir'); }\n\n    nullsSpec() { return this._get('nulls_spec'); }\n}", "import { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\n\nexport class PartitionByClause extends AbstractNodeList {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'keyword', value: 'PARTITION' },\n            { type: 'keyword', value: 'BY', assert: true },\n            { type: 'Expr', as: 'entries', arity: { min: 1 }, itemSeparator, assert: true, autoIndent: 2 }\n        ];\n    }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class PGFetchClause extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            dialect: 'postgres',\n            syntax: [\n                { type: 'keyword', value: 'FETCH' },\n                { type: 'keyword', as: 'rel_kw', value: ['FIRST', 'NEXT'] },\n                { type: 'Expr', as: 'expr', optional: true },\n                { type: 'keyword', as: 'row_kw', value: ['ROW', 'ROWS'], assert: true },\n                {\n                    syntaxes: [\n                        { type: 'keyword', value: 'ONLY' },\n                        [\n                            { type: 'keyword', as: 'with_ties', value: 'WITH' },\n                            { type: 'keyword', value: 'TIES', assert: true },\n                        ]\n                    ]\n                }\n            ]\n        };\n    }\n\n    /* AST API */\n\n    relKW() { return this._get('rel_kw'); }\n\n    expr() { return this._get('expr'); }\n\n    rowKW() { return this._get('row_kw'); }\n\n    withTies() { return this._get('with_ties'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class PGOrderOperator extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            dialect: 'postgres',\n            syntax: [\n                { type: 'keyword', value: 'USING' },\n                { type: 'operator', as: '.', assert: true },\n            ],\n        };\n    }\n\n    /* AST API */\n\n    value() { return this._get('value'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class UsingClause extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', value: 'USING' },\n            { type: ['ColumnRef2', 'ColumnsConstructor'], as: 'column', assert: true }\n        ];\n    }\n\n    /* AST API */\n\n    column() { return this._get('column'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class WhereClause extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', value: 'WHERE' },\n            { type: 'Expr', as: 'expr', assert: true }\n        ];\n    }\n\n    /* AST API */\n\n    expr() { return this._get('expr'); }\n}", "import { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\n\nexport class WindowClause extends AbstractNodeList {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'keyword', value: 'WINDOW' },\n            { type: 'WindowDeclaration', as: 'entries', arity: { min: 1 }, itemSeparator, assert: true, autoIndent: 2 }\n        ];\n    }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class WindowDeclaration extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'Identifier', as: 'name' },\n            { type: 'keyword', value: 'AS' },\n            { type: 'WindowSpec', as: 'spec', assert: true }\n        ];\n    }\n\n    /* AST API */\n\n    name() { return this._get('name'); }\n\n    spec() { return this._get('spec'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class WindowFrameSpec extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'operator', value: 'AND' };\n        return [\n            { type: 'keyword', as: 'specifier', value: ['ROWS', 'RANGE', 'GROUPS'] },\n            {\n                syntaxes: [\n                    [\n                        { type: 'operator', as: 'with_between_clause', value: 'BETWEEN', booleanfy: true },\n                        { type: 'WindowFrameBound', as: 'bounds', arity: 2, itemSeparator, assert: true },\n                    ],\n                    { type: 'WindowFrameBound', as: 'bounds', arity: 1, itemSeparator, assert: true },\n\n                ]\n            },\n            {\n                optional: true,\n                syntax: [\n                    { type: 'keyword', value: 'EXCLUDE' },\n                    { type: 'keyword', as: 'exclusion', value: ['CURRENT ROW', 'GROUP', 'TIES', 'NO OTHERS'], assert: true },\n                ]\n            },\n        ];\n    }\n\n    /* AST API */\n\n    specifier() { return this._get('specifier'); }\n\n    withBetweenClause() { return this._get('with_between_clause'); }\n\n    bounds() { return this._get('bounds'); }\n\n    exclusion() { return this._get('exclusion'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class WindowFrameBound extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            syntaxes: [\n                { type: 'keyword', as: 'specifier', value: 'CURRENT ROW' },\n                [\n                    { type: 'keyword', as: 'specifier', value: 'UNBOUNDED' },\n                    { type: 'keyword', as: 'dir', value: ['PRECEDING', 'FOLLOWING'] },\n                ],\n                [\n                    { type: 'number_literal', as: 'specifier' },\n                    { type: 'keyword', as: 'dir', value: ['PRECEDING', 'FOLLOWING'] },\n                ],\n                [\n                    { type: 'Expr'/* Ideally, Temporal types */, as: 'specifier' },\n                    { type: 'keyword', as: 'dir', value: ['PRECEDING', 'FOLLOWING'] },\n                ],\n            ]\n        };\n    }\n\n    /* AST API */\n\n    specifier() { return this._get('specifier'); }\n\n    dir() { return this._get('dir'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class WindowSpec extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            type: 'paren_block',\n            syntax: [\n                { type: 'WindowRef', as: 'super_window', optional: true },\n                { type: 'PartitionByClause', as: 'partition_by_clause', optional: true, autoIndent: true },\n                { type: 'OrderByClause', as: 'order_by_clause', optional: true, autoIndent: true },\n                { type: 'WindowFrameSpec', as: 'frame_spec', optional: true, autoIndent: true },\n            ],\n            autoIndent: true,\n            autoIndentAdjust: -1\n        };\n    }\n\n    /* AST API */\n\n    superWindow() { return this._get('super_window'); }\n\n    partitionByClause() { return this._get('partition_by_clause'); }\n\n    orderByClause() { return this._get('order_by_clause'); }\n\n    frameSpec() { return this._get('frame_spec'); }\n}", "import { Identifier } from '../../expr/ref/Identifier.js';\n\nexport class FromItemAlias extends Identifier {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            {\n                syntaxes: [\n                    { ...[].concat(super.syntaxRules)[0] },\n                    [\n                        { type: 'keyword', as: 'as_kw', value: 'AS', booleanfy: true },\n                        { ...[].concat(super.syntaxRules)[0], assert: true },\n                    ]\n                ]\n            },\n            {\n                type: 'paren_block',\n                syntax: { type: 'Identifier', as: 'columns', arity: { min: 1 }, itemSeparator, assert: true },\n                if: 'value',\n                optional: true,\n                optionalParens: true,\n            }\n        ];\n    }\n\n    /* AST API */\n\n    asKW() { return this._get('as_kw'); }\n\n    columns() { return this._get('columns'); }\n}", "import { DDLSchemaMixin } from '../../abstracts/DDLSchemaMixin.js';\nimport { AbstractNode } from '../../abstracts/AbstractNode.js';\nimport { registry } from '../../registry.js';\n\nexport class SelectItem extends DDLSchemaMixin(AbstractNode) {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: ['Expr', 'ColumnRef0', 'MYVarAssignmentExpr'], as: 'expr' },\n            { type: 'SelectItemAlias', as: 'alias', optional: true }\n        ];\n    }\n\n    /* AST API */\n\n    expr() { return this._get('expr'); }\n\n    alias() { return this._get('alias'); }\n\n    /* SCHEMA API */\n\n    deriveAlias() {\n\n        let derivedAliasJson = this.alias()?.jsonfy();\n\n        let exprNode = this.expr();\n        if (exprNode instanceof registry.ColumnRef0) return;\n\n        // Resolve RowConstructor\n        if (exprNode instanceof registry.RowConstructor) {\n            exprNode = exprNode.exprUnwrapped();\n        }\n\n        // Resolve CastExpr | PGCastExpr2\n        if (exprNode instanceof registry.CastExpr\n            || exprNode instanceof registry.PGCastExpr2) {\n            exprNode = exprNode.expr();\n        }\n\n        if (!derivedAliasJson) {\n            if (exprNode instanceof registry.ColumnRef1) {\n                derivedAliasJson = { as_kw: true, value: exprNode.value(), delim: exprNode._get('delim') };\n            } else if (exprNode instanceof registry.LQDeepRef1 && exprNode.endpoint() instanceof registry.ColumnRef2) {\n                const endpointNode = exprNode.endpoint();\n                derivedAliasJson = { as_kw: true, value: endpointNode.value(), delim: endpointNode._get('delim') };\n            } else {\n                const isToPG = this.options.dialect === 'postgres';\n                if (exprNode instanceof registry.CallExpr && isToPG) {\n                    derivedAliasJson = { as_kw: true, value: exprNode.name().toLowerCase() };\n                }\n            }\n        }\n\n        return registry.SelectItemAlias.fromJSON(derivedAliasJson);\n    }\n\n    jsonfy(options = {}, transformer = null, linkedDb = null) {\n        if (options.deSugar) {\n\n            const derivedAliasNode = this.deriveAlias();\n\n            let asAggr,\n                derivedAliasJson = derivedAliasNode && (transformer\n                    ? transformer.transform(derivedAliasNode, ($options = options) => derivedAliasNode.jsonfy($options), 'alias', options)\n                    : derivedAliasNode.jsonfy(options));\n            if (derivedAliasJson?.is_aggr) ({ is_aggr: asAggr, ...derivedAliasJson } = derivedAliasJson);\n\n            const exprNode = this.expr();\n\n            let defaultExprTransform;\n\n            if (asAggr && !(exprNode instanceof registry.LQDeepRef1)) {\n                // Note the below where we wrap value in an aggr call\n                defaultExprTransform = ($options = options, childTransformer = transformer) => ({\n                    nodeName: registry.AggrCallExpr.NODE_NAME,\n                    name: (options.toDialect || this.options.dialect) === 'mysql' ? 'JSON_ARRAYAGG' : 'JSON_AGG',\n                    arguments: [exprNode.jsonfy($options, childTransformer, linkedDb)],\n                });\n            } else {\n                // Note the below where we derive value, if not specified, from key\n                defaultExprTransform = ($options = options, childTransformer = transformer) => {\n                    return exprNode.jsonfy($options, childTransformer, linkedDb);\n                };\n            }\n\n            const exprJson = transformer\n                ? transformer.transform(exprNode, defaultExprTransform, 'expr', { ...options, asAggr })\n                : defaultExprTransform();\n\n            // ----------------\n\n            const schemaIdent = derivedAliasJson && {\n                nodeName: registry.Identifier.NODE_NAME,\n                value: derivedAliasJson.value,\n                delim: derivedAliasJson.delim\n            } || {\n                nodeName: registry.Identifier.NODE_NAME,\n                value: this.options.dialect === 'postgres' ? '?column?' : exprNode.stringify(),\n            };\n\n            let resultSchema = exprJson.result_schema;\n\n            if (resultSchema instanceof registry.ColumnSchema) {\n                const tableSchema = resultSchema.parentNode;\n                resultSchema = resultSchema.clone({ renameTo: schemaIdent });\n                tableSchema._adoptNodes(resultSchema);\n            } else if (!(exprNode instanceof registry.LQDeepRef1)\n                && !(exprNode instanceof registry.ColumnRef0)) {\n                resultSchema = registry.ColumnSchema.fromJSON({\n                    name: schemaIdent,\n                    data_type: this.expr().dataType().jsonfy(),\n                });\n                exprNode._adoptNodes(resultSchema);\n            }\n\n            const applicableAliasJson = (asAggr || Number(options.deSugar) > 2 || (\n                Number(options.deSugar) > 1 && (this.parentNode?.entries().length || 0) > 1\n            )) && derivedAliasJson || this.alias()?.jsonfy();\n\n            return {\n                nodeName: SelectItem.NODE_NAME,\n                expr: exprJson,\n                alias: applicableAliasJson,\n                result_schema: resultSchema,\n            };\n        }\n        return super.jsonfy(options, transformer, linkedDb);\n    }\n}", "import { Identifier } from '../../expr/ref/Identifier.js';\n\nexport class SelectItemAlias extends Identifier {\n    static get syntaxRules() {\n        return [\n            {\n                syntaxes: [\n                    { ...[].concat(super.syntaxRules)[0] },\n                    [\n                        { type: 'keyword', as: 'as_kw', value: 'AS', booleanfy: true },\n                        { ...[].concat(super.syntaxRules)[0], assert: true },\n                    ]\n                ]\n            },\n            { type: 'AggrNotation', as: 'is_aggr', autoSpacing: false, optional: true },\n        ];\n    }\n\n    /* AST API */\n\n    asKW() { return this._get('as_kw'); }\n\n    isAggr() { return this._get('is_aggr'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\nimport { DDLSchemaMixin } from '../../abstracts/DDLSchemaMixin.js';\nimport { registry } from '../../registry.js';\n\nexport class SRFExpr1 extends DDLSchemaMixin(AbstractNode) {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'CallExpr', as: 'call_expr' },\n            { type: ['SRFExprDDL1', 'SRFExprDDL2'], as: 'qualif' },\n        ];\n    }\n\n    /* AST API */\n\n    callExpr() { return this._get('call_expr'); }\n\n    qualif() { return this._get('qualif'); }\n\n    /* JSON API */\n\n    jsonfy(options = {}, transformer = null, linkedDb = null) {\n        let resultJson = super.jsonfy(options, transformer, linkedDb);\n        if (options.deSugar) {\n            \n            const columnDefsJson = resultJson.qualif?.column_defs || [];\n            const resultSchema = resultJson.qualif?.alias\n                // a. Compose from \"column_defs\" with explicit table alias\n                ? registry.TableSchema.fromJSON({\n                    name: resultJson.qualif.alias,\n                    entries: columnDefsJson,\n                })\n                // b. Compose from \"column_defs\" without explicit table alias\n                : registry.JSONSchema.fromJSON({\n                    entries: columnDefsJson,\n                });\n\n            resultJson = {\n                ...resultJson,\n                result_schema: resultSchema\n            };\n        }\n\n        return resultJson;\n    }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\nimport { DDLSchemaMixin } from '../../abstracts/DDLSchemaMixin.js';\nimport { registry } from '../../registry.js';\n\nexport class SRFExpr2 extends DDLSchemaMixin(AbstractNode) {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'CallExpr', as: 'call_expr' },\n            {\n                optional: true,\n                syntax: [\n                    { type: 'keyword', as: 'with_ordinality', value: 'WITH', booleanfy: true },\n                    { type: 'keyword', value: 'ORDINALITY', assert: true },\n                ]\n            },\n        ];\n    }\n\n    /* AST API */\n\n    callExpr() { return this._get('call_expr'); }\n\n    withOrdinality() { return this._get('with_ordinality'); }\n\n    /* JSON API */\n\n    jsonfy(options = {}, transformer = null, linkedDb = null) {\n        let resultJson = super.jsonfy(options, transformer, linkedDb);\n        if (options.deSugar) {\n\n            let resultSchema;\n\n            let ordinalityColumn;\n            if (resultJson.with_ordinality) {\n                ordinalityColumn = registry.ColumnSchema.fromJSON({\n                    name: { nodeName: registry.Identifier.NODE_NAME, value: 'ordinality' },\n                    data_type: { nodeName: registry.DataType.NODE_NAME, value: 'INT' },\n                });\n            }\n\n            const schemaIdentFromFuncName = { nodeName: registry.Identifier.NODE_NAME, value: resultJson.call_expr.name };\n\n            if (resultJson.call_expr?.result_schema) {\n                // a. Compose from existing\n                resultSchema = resultJson.call_expr.result_schema;\n\n                if (resultSchema instanceof registry.TableSchema\n                    || resultSchema instanceof registry.JSONSchema) {\n\n                    if (ordinalityColumn) {\n                        const resultSchema_json = resultSchema.jsonfy();\n                        resultSchema = resultSchema.constructor.fromJSON({\n                            name: schemaIdentFromFuncName,\n                            ...resultSchema_json, // overridingly\n                            entries: [\n                                ...resultSchema_json.entries, \n                                ordinalityColumn\n                            ],\n                        });\n                    } else {\n                        resultSchema = resultSchema.clone();\n                    }\n\n                } else {\n                    resultSchema = registry.JSONSchema.fromJSON({\n                        entries: [\n                            resultSchema.jsonfy()\n                        ].concat(ordinalityColumn || []),\n                    });\n                }\n            } else {\n                // b. Compose from Func expr\n                resultSchema = registry.JSONSchema.fromJSON({\n                    entries: [{\n                        nodeName: registry.ColumnSchema.NODE_NAME,\n                        name: schemaIdentFromFuncName,\n                        data_type: this.callExpr().dataType().jsonfy(),\n                    }].concat(ordinalityColumn || []),\n                });\n            }\n\n            resultJson = {\n                ...resultJson,\n                result_schema: resultSchema\n            };\n        }\n\n        return resultJson;\n    }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\nimport { DDLSchemaMixin } from '../../abstracts/DDLSchemaMixin.js';\nimport { registry } from '../../registry.js';\n\nexport class SRFExpr3 extends DDLSchemaMixin(AbstractNode) {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'CallExpr', as: 'call_expr' },\n            { type: 'SRFExprDDL1', as: 'qualif', optional: true },\n        ];\n    }\n\n    /* AST API */\n\n    callExpr() { return this._get('call_expr'); }\n\n    qualif() { return this._get('qualif'); }\n\n    /* JSON API */\n\n    jsonfy(options = {}, transformer = null, linkedDb = null) {\n        let resultJson = super.jsonfy(options, transformer, linkedDb);\n        if (options.deSugar) {\n\n            let resultSchema;\n            if (resultJson.qualif?.column_defs.length) {\n                // a. Compose from \"column_defs\"\n                resultSchema = registry.JSONSchema.fromJSON({\n                    entries: resultJson.qualif.column_defs,\n                });\n            } else if (resultJson.call_expr?.result_schema) {\n                // b. Compose from existing\n                const givenSchema = resultJson.call_expr.result_schema;\n                resultSchema = givenSchema instanceof registry.TableSchema || givenSchema instanceof registry.JSONSchema\n                    ? givenSchema.clone()\n                    : registry.JSONSchema.fromJSON({\n                        entries: [givenSchema.jsonfy()],\n                    });\n            } else {\n                // c. Compose from Func expr\n                const schemaIdentFromFuncName = { nodeName: registry.Identifier.NODE_NAME, value: resultJson.call_expr.name };\n                resultSchema = registry.JSONSchema.fromJSON({\n                    entries: [{\n                        nodeName: registry.ColumnSchema.NODE_NAME,\n                        name: schemaIdentFromFuncName,\n                        data_type: this.callExpr().dataType().jsonfy(),\n                    }],\n                });\n            }\n\n            resultJson = {\n                ...resultJson,\n                result_schema: resultSchema\n            };\n        }\n\n        return resultJson;\n    }\n}", "import { DDLSchemaMixin } from '../../abstracts/DDLSchemaMixin.js';\nimport { AbstractNodeList } from '../../abstracts/AbstractNodeList.js';\nimport { registry } from '../../registry.js';\n\nexport class SRFExpr4 extends DDLSchemaMixin(AbstractNodeList) {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'keyword', value: 'ROWS' },\n            { type: 'keyword', value: 'FROM' },\n            {\n                type: 'paren_block',\n                syntax: { type: 'SRFExpr3', as: 'entries', arity: { min: 1 }, itemSeparator, assert: true, autoIndent: 2 },\n                autoIndent: true\n            },\n            {\n                optional: true,\n                syntax: [\n                    { type: 'keyword', as: 'with_ordinality', value: 'WITH', booleanfy: true },\n                    { type: 'keyword', value: 'ORDINALITY', assert: true },\n                ]\n            }\n        ];\n    }\n\n    static get syntaxPriority() { return -1; }\n\n    /* AST API */\n\n    withOrdinality() { return this._get('with_ordinality'); }\n\n    /* JSON API */\n\n    jsonfy(options = {}, transformer = null, linkedDb = null) {\n        let resultJson = super.jsonfy(options, transformer, linkedDb);\n        if (options.deSugar) {\n\n            let ordinalityColumn;\n            if (resultJson.with_ordinality) {\n                ordinalityColumn = registry.ColumnSchema.fromJSON({\n                    name: { nodeName: registry.Identifier.NODE_NAME, value: 'ordinality' },\n                    data_type: { nodeName: registry.DataType.NODE_NAME, value: 'INT' },\n                });\n            }\n\n            const resultSchema = registry.JSONSchema.fromJSON({\n                entries: [\n                    ...resultJson.entries.reduce((entries, exprJson) => {\n                        const exprJsonEntries = exprJson.result_schema.jsonfy().entries;\n                        return entries.concat(exprJsonEntries);\n                    }, []),\n                ].concat(ordinalityColumn || []),\n            });\n\n            resultJson = {\n                ...resultJson,\n                result_schema: resultSchema\n            };\n        }\n\n        return resultJson;\n    }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class SRFExprDDL1 extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            { type: 'keyword', value: 'AS' },\n            {\n                type: 'paren_block',\n                syntax: { type: 'ColumnSchema', as: 'column_defs', arity: { min: 1 }, itemSeparator },\n            }\n        ];\n    }\n\n    /* AST API */\n\n    asKW() { return this._get('as_kw'); }\n\n    alias() { return this._get('alias'); }\n\n    columnDefs() { return this._get('column_defs'); }\n}", "import { AbstractNode } from '../../abstracts/AbstractNode.js';\n\nexport class SRFExprDDL2 extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            {\n                syntaxes: [\n                    { type: 'Identifier', as: 'alias' },\n                    [\n                        { type: 'keyword', value: 'AS', as: 'as_kw' },\n                        { type: 'Identifier', as: 'alias', assert: true }\n                    ]\n                ]\n            },\n            {\n                type: 'paren_block',\n                syntax: { type: 'ColumnSchema', as: 'column_defs', arity: { min: 1 }, itemSeparator },\n            }\n        ];\n    }\n\n    /* AST API */\n\n    alias() { return this._get('alias'); }\n\n    columnDefs() { return this._get('column_defs'); }\n}", "import { ValuesConstructor } from '../../dml/constructors/ValuesConstructor.js';\n\nexport class ValuesTableLiteral extends ValuesConstructor {\n    \n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return { type: 'paren_block', syntax: super.syntaxRules, autoIndent: true };\n    }\n}", "import { AbstractNonDDLStmt } from '../abstracts/AbstractNonDDLStmt.js';\nimport { registry } from '../registry.js';\n\nexport class SelectStmt extends AbstractNonDDLStmt {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() { return { type: ['CompleteSelectStmt', 'CompositeSelectStmt'], expression: true }; }\n\n    static buildSyntaxRules(part = null) {\n        const part1 = (extRules = []) => [\n            { type: 'keyword', value: 'SELECT' },\n            { type: 'DistinctClause', as: 'distinct_clause', optional: true },\n            { type: 'SelectList', as: 'select_list' },\n            {\n                optional: true,\n                syntax: [\n                    { type: 'FromClause', as: 'from_clause', autoSpacing: '\\n' },\n                    { type: 'JoinClause', as: 'join_clauses', arity: Infinity, optional: true, autoSpacing: '\\n' },\n\t\t\t\t\t{ type: 'MYPartitionClause', as: 'my_partition_clause', optional: true, autoSpacing: '\\n' },\n                    { type: 'WhereClause', as: 'where_clause', optional: true, autoSpacing: '\\n' },\n                    {\n                        optional: true,\n                        syntax: [\n                            { type: 'GroupByClause', as: 'group_by_clause', autoSpacing: '\\n' },\n                            { type: 'HavingClause', as: 'having_clause', optional: true, autoSpacing: '\\n' },\n                        ],\n                    },\n                    { type: 'WindowClause', as: 'window_clause', optional: true, autoSpacing: '\\n' },\n                    ...\n                    extRules\n                ], autoSpacing: '\\n',\n            },\n        ];\n        const part2 = () => [\n            { type: 'OrderByClause', as: 'order_by_clause', optional: true, autoSpacing: '\\n' },\n            { type: 'LimitClause', as: 'limit_clause', optional: true, autoSpacing: '\\n' },\n            { type: 'OffsetClause', as: 'offset_clause', optional: true, autoSpacing: '\\n' },\n            { type: 'PGFetchClause', as: 'pg_fetch_clause', optional: true, dialect: 'postgres', autoSpacing: '\\n' },\n            { type: 'ForClause', as: 'for_clause', optional: true, autoSpacing: '\\n' },\n        ];\n        if (part === 1) return part1();\n        if (part === 2) return part2();\n        return part1(part2());\n    }\n\n    dataType() { return registry.DataType.fromJSON({ value: 'SET' }); }\n}\n", "import { Transformer } from '../Transformer.js';\nimport { SelectorStmtMixin } from '../abstracts/SelectorStmtMixin.js';\nimport { ErrorRefUnknown } from '../expr/ref/abstracts/ErrorRefUnknown.js';\nimport { SelectStmt } from './SelectStmt.js';\nimport { registry } from '../registry.js';\n\nexport class BasicSelectStmt extends SelectorStmtMixin(\n    SelectStmt\n) {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() { return this.buildSyntaxRules(1); }\n\n    static get syntaxPriority() { return -1; }\n\n    /* Schema API */\n\n    distinctClause() { return this._get('distinct_clause'); }\n\n    selectList() { return this._get('select_list'); }\n\n    fromClause() { return this._get('from_clause'); }\n\n    joinClauses() { return this._get('join_clauses'); }\n\n    whereClause() { return this._get('where_clause'); }\n\n    groupByClause() { return this._get('group_by_clause'); }\n\n    havingClause() { return this._get('having_clause'); }\n\n    windowClause() { return this._get('window_clause'); }\n\n    // -- MySQL\n\n    myPartitionClause() { return this._get('my_partition_clause'); }\n\n    // --------\n\n    get length() { return this.selectList()?.length ?? 0; }\n\n    [Symbol.iterator]() { return (this.selectList() || [])[Symbol.iterator](); }\n\n    /* JSON API */\n\n    jsonfy(options = {}, transformer = null, linkedDb = null) {\n        if (!options.deSugar) return super.jsonfy(options, transformer, linkedDb);\n\n        const deferedTransforms = {\n            select_list: null,\n            group_by_clause: new Set,\n            having_clause: new Set,\n            order_by_clause: new Set,\n        };\n\n        transformer = new Transformer((node, defaultTransform, keyHint) => {\n\n            // Defer SelectItem resolution\n            if (node instanceof registry.SelectList) {\n                deferedTransforms.select_list = defaultTransform;\n                return; // Exclude for now\n            }\n\n            // Trigger fields resolution\n            if (node instanceof registry.GroupByClause\n                || node instanceof registry.HavingClause\n                || node instanceof registry.OrderByClause) {\n                // Try to capture Linked QL's native GROUP BY clause that's derived\n                // from a back ref, which won't resolve at this time because the relevant generated JOIN\n                // hasn't been add\n                return defaultTransform((childNode, defaultChildTransform, subKeyHint) => {\n                    if ((typeof subKeyHint === 'number' || subKeyHint === 'expr'/* For Having clause */) && childNode.parentNode === node) {\n                        try {\n                            deferedTransforms[keyHint].add(defaultChildTransform());\n                        } catch (e) {\n                            if (e instanceof ErrorRefUnknown) {\n                                deferedTransforms[keyHint].add(defaultChildTransform);\n                            } else throw e;\n                        }\n                        return; // Exclude for now\n                    }\n                    return defaultChildTransform();\n                });\n            }\n\n            // For all other things...\n            return defaultTransform();\n        }, transformer, this/* IMPORTANT */);\n\n        // --------------\n\n        // 0. Run transform\n        let resultJson = super.jsonfy(options, transformer, linkedDb);\n\n        // 1. Transform the defered selectList\n        let selectListJson = deferedTransforms.select_list();\n\n        // 2. Finalize generated JOINS\n        // Generated JOINs are injected into the query\n        resultJson = this.finalizeSelectorJSON(resultJson, transformer, linkedDb, options);\n\n        // 3. Re-resolve output list for cases of just-added deep refs in selectList\n        // wherein schemas wouldn't have been resolvable at the time\n        // 4. Finalize output list for the last time, honouring given deSugaring level with regards to star selects \"*\"\n        // and ofcos finalize output schemas\n        selectListJson = this.selectList().finalizeJSON(selectListJson, transformer, linkedDb, options);\n\n        // Apply now\n        resultJson = {\n            ...resultJson,\n            select_list: selectListJson,\n            result_schema: selectListJson.result_schema,\n        };\n\n        // --------------\n\n        // 5. Resolve deferred GROUP BYs and HAVINGs\n        // after having published artifacts.outputSchemas\n        for (const [fieldName, deferreds] of Object.entries(deferedTransforms)) {\n\n            if (fieldName === 'select_list' || !deferreds.size) continue;\n            const resolveds = [];\n\n            for (let deferred of deferreds) {\n                if (typeof deferred === 'function') {\n                    deferred = deferred();\n                }\n                resolveds.push(deferred);\n            }\n\n            if (fieldName === 'having_clause') {\n                resultJson = { ...resultJson, [fieldName]: resolveds[0] };\n            } else if (fieldName === 'group_by_clause') {\n                resultJson = { ...resultJson, [fieldName]: { entries: resolveds } };\n            }\n\n        }\n\n        return resultJson;\n    }\n}", "import { BasicSelectStmt } from './BasicSelectStmt.js';\n\nexport class CompleteSelectStmt extends BasicSelectStmt {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() { return this.buildSyntaxRules(); }\n\n    static get syntaxPriority() { return 99; }\n\n    /* AST API */\n\n    orderByClause() { return this._get('order_by_clause'); }\n\n    offsetClause() { return this._get('offset_clause'); }\n\n    limitClause() { return this._get('limit_clause'); }\n\n    forClause() { return this._get('for_clause'); }\n\n    // -- Postgres\n\n    pgFetchClause() { return this._get('pg_fetch_clause'); }\n\n    /* Custom parse */\n\n    static async parse(input, { left = undefined, minPrecedence = 0, trail = [], ...options } = {}) {\n        if (left) return;\n\n        const tokenStream = await this.toStream(input, options);\n\n        const result = await super.parse(tokenStream, { minPrecedence, trail, ...options });\n        if (await tokenStream.match('operator', ['INTERSECT', 'UNION', 'EXCEPT'])) {\n            if (result.order_by_clause || result.offset_clause || result.limit_clause || result.for_clause) {\n                const current = tokenStream.current();\n                const message = `[${this.NODE_NAME}] Unexpected ${current.type} token:${typeof current.value === 'string' ? ` \"${current.value}\"` : ''} at <line ${current.line}, column ${current.column}>`;\n                throw new SyntaxError(message);\n            }\n            return BasicSelectStmt.fromJSON({ ...result.jsonfy(), nodeName: undefined });\n        }\n\n        return result;\n    }\n}", "import { SelectStmt } from './SelectStmt.js';\n\nexport class CompositeSelectStmt extends SelectStmt {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const setTypes = ['DerivedQuery', 'ValuesTableLiteral', 'ParenExpr', 'BasicSelectStmt', 'CallExpr'];\n        return [\n            { type: setTypes, as: 'left' },\n            { type: 'operator', as: 'operator', value: ['INTERSECT', 'UNION', 'EXCEPT'], autoSpacing: '\\n' },\n            { type: 'keyword', as: 'all_or_distinct', value: ['ALL', 'DISTINCT'], optional: true },\n            { type: setTypes, as: 'right', assert: true, autoSpacing: '\\n' },\n            ...\n            this.buildSyntaxRules(2),\n        ];\n    }\n\n    static get syntaxPriority() { return 100; }\n\n    /* AST API */\n\n    left() { return this._get('left'); }\n\n    operator() { return this._get('operator'); }\n\n    allOrDistinct() { return this._get('all_or_distinct'); }\n\n    right() { return this._get('right'); }\n\n    // --------\n\n    orderByClause() { return this._get('order_by_clause'); }\n\n    offsetClause() { return this._get('offset_clause'); }\n\n    limitClause() { return this._get('limit_clause'); }\n\n    forClause() { return this._get('for_clause'); }\n\n    // -- Postgres\n\n    pgFetchClause() { return this._get('pg_fetch_clause'); }\n\n    // --------\n\n    get length() { return this.left()?.selectList()?.length ?? 0; }\n\n    [Symbol.iterator]() { return (this.left()?.selectList() || [])[Symbol.iterator](); }\n\n    /* JSON API */\n\n    jsonfy(options = {}, transformer = null, linkedDb = null) {\n        const resultJson = super.jsonfy(options, transformer, linkedDb);\n        return { ...resultJson, result_schema: resultJson.left?.result_schema };\n    }\n}", "import { AbstractStmt } from '../abstracts/AbstractStmt.js';\n\nexport class TableStmt extends AbstractStmt {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return [\n            { type: 'keyword', value: 'TABLE' },\n            { type: 'keyword', as: 'pg_only_kw', value: 'ONLY', optional: true, dialect: 'postgres' },\n            { type: 'TableRef2', as: 'table_ref', assert: true },\n            { type: 'operator', as: 'pg_star_ref', value: '*', booleanfy: true, optional: true, dialect: 'postgres' },\n        ];\n    }\n\n    /* AST API */\n\n    tableRef() { return this._get('table_ref'); }\n\n    // -- Postgres\n\n    pgOnlyKW() { return this._get('pg_only_kw'); }\n\n    pgStarRef() { return this._get('pg_star_ref'); }\n\n    /* SCHEMA API */\n\n    querySchemas() {\n        const tableRef = this.tableRef();\n\n        const alias = registry.Identifier.fromJSON({ value: tableRef.value() });\n        const tableSchema = tableRef.resultSchema(transformer).clone({ renameTo: alias });\n        \n        return new Set([tableSchema]);\n    }\n}", "export { AggrNotation } from './AggrNotation.js';\nexport { LQVersionSpec } from './LQVersionSpec.js';\n", "import { AbstractNode } from '../abstracts/AbstractNode.js';\n\nexport class AggrNotation extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return {\n            type: 'bracket_block', syntax: { type: 'Expr', as: '_', arity: 0, assert: true }\n        };\n    }\n\n    static get syntaxPriority() { return -1; }\n}", "import { AbstractNode } from '../abstracts/AbstractNode.js';\n\nexport class LQVersionSpec extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() { return { type: 'version_spec', as: '.' }; }\n\n    static get syntaxPriority() { return -1; }\n\n    /* AST API */\n\n    value() { return this._get('value'); }\n}", "export { DataType } from './DataType.js';\n", "import { AbstractNode } from '../abstracts/AbstractNode.js';\n\nexport class DataType extends AbstractNode {\n\n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ',' };\n        return [\n            {\n                syntaxes: [\n                    { type: 'data_type', as: '.' },\n                    { type: 'keyword', as: '.', value: ['SET'] },\n                ]\n            },\n            {\n                type: 'paren_block',\n                syntax: { type: 'Expr', as: 'specificity', arity: Infinity, itemSeparator, assert: true },\n                optional: true,\n                optionalParens: true,\n                autoSpacing: false\n            },\n            { type: 'AggrNotation', as: 'pg_is_aggr', autoSpacing: false, optional: true, dialect: 'postgres' },\n        ];\n    }\n\n    /* AST API */\n\n    value() { return this._get('value'); }\n\n    specificity() { return this._get('specificity'); }\n\n    // -- Postgres\n\n    pgIsAggr() { return this._get('pg_is_aggr'); }\n}", "import { AbstractNodeList } from './AbstractNodeList.js';\n\nexport class JSONSchema extends AbstractNodeList {\n    \n    /* SYNTAX RULES */\n\n    static get syntaxRules() {\n        return { type: ['JSONSchema', 'TableSchema', 'ColumnSchema', 'ColumnRef1'/* result of resolving ColumnRef0 */], as: 'entries', arity: Infinity };\n    }\n}", "import * as cte from './cte/index.js';\nimport * as ddl from './ddl/index.js';\nimport * as dml from './dml/index.js';\nimport * as dql from './dql/index.js';\nimport * as expr from './expr/index.js';\nimport * as qualif from './qualif/index.js';\nimport * as type from './type/index.js';\nimport { JSONSchema } from './abstracts/JSONSchema.js';\nimport { registry } from './registry.js';\n\nObject.assign(registry, { ...cte, ...ddl, ...dml, ...dql, ...expr, ...qualif, ...type, JSONSchema });\n", "import { AbstractNodeList } from './abstracts/AbstractNodeList.js';\n\nexport class Query extends AbstractNodeList {\n\n    /* SYNTAX RULES */\n\n    static get _contentTypes() {\n        return [\n            'SelectStmt',\n            'TableStmt',\n            'InsertStmt',\n            'UpsertStmt',\n            'UpdateStmt',\n            'DeleteStmt',\n            'MYSetStmt',\n            'CTE',\n            'CreateTableStmt',\n        ];\n    }\n\n    static get syntaxRules() {\n        const itemSeparator = { type: 'punctuation', value: ';' };\n        return { type: this._contentTypes, as: 'entries', arity: Infinity, itemSeparator, autoSpacing: '\\n' };\n    }\n\n    /* API */\n\n    static async parse(input, options = {}) {\n        const tokenStream = await this.toStream(input, options);\n        const result = await super.parse(tokenStream, options);\n        if (!tokenStream.done && tokenStream.current()) {\n            const current = tokenStream.current();\n\t\t\tconst message = `[${this.NODE_NAME}] Unexpected ${current.type} token:${typeof current.value === 'string' ? ` \"${current.value}\"` : ''} at <line ${current.line}, column ${current.column}>`;\n            throw new SyntaxError(message);\n        }\n        return result;\n    }\n\n    stringify(options = {}) { return `${super.stringify(options)};`; }\n}"],
  "mappings": "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",
  "names": ["cte_exports", "__export", "CTE", "CTEItem", "CTEItemAlias", "PGCycleClause", "PGSearchClause", "isObject_default", "val", "_eq", "a", "b", "cs", "ignoreList", "x", "i", "isObject_default", "temp", "$ignoreList", "k", "prev", "_toCapsSnake", "str", "result", "toktypes_exports", "__export", "TOK_TYPES", "aggrFunctionNames", "dataTypes", "functionNames", "keywords", "operators", "statements", "dialect", "mysqlAnsiQuotes", "value", "TokenStreamState", "by", "isLf", "TokenStream", "#iterator", "#options", "#locked", "#started", "#done", "#rootSavepoint", "#history", "#current", "#peeks", "iterator", "_", "options", "#assertNotLocked", "value", "done", "#historyPush", "#peeksShift", "$type", "$value", "peek", "type", "match", "tok", "i", "length", "$length", "next", "#peeksPush", "#historyPop", "#peeksUnshift", "method", "point", "toIndex", "input", "dialect", "state", "s", "normalizeOptions", "stream", "localState", "$finalizeToken", "token", "forceYield", "finalizeToken", "chunk", "char", "possiblyChunked", "charIsWhitespace", "whitespace", "$throw", "isEndQuote", "isEndTag", "isString", "isDelimitedIdent", "isBlockComment", "isLineComment", "prevChar", "nextChar", "strings_inBackslashEscapeMode", "strings_atEscapePosition", "tokenEndSteps", "cursor", "tokenStart", "tokenStartBacksteps", "tokenStartForwardsteps", "__", "restTok", "modifierPattern", "modifierMatch", "modifier", "groupToken", "previousChar", "addMultiWord", "targetMap", "prefix", "_tok", "tokenCategory", "$tokenCategory", "tokenRegistry", "tokenDialectBranch", "entries", "toktypes_exports", "entry", "finalizeComment", "finalToken", "identResolution", "line", "column", "finalizeIdentifier", "multiwordBufferLength", "wordSoFar", "findInBranch", "branch", "matchResult", "processExactMatch", "spaceBefore", "processPartialMatch", "multiwordMatched", "tokenCategory2", "matchResult2", "existing", "current", "registry", "AbstractNode", "_AbstractNode", "_toCapsSnake", "#ast", "#options", "#parentNode", "ast", "options", "node_s", "fieldName", "index", "cs", "n", "value", "indexOrValue", "valueOnIndex", "existing", "all", "i", "args", "nodes", "node", "activeTrailStr", "visitor", "visit", "key", "possibleChild", "_eq", "transformer", "linkedDb", "resultJson", "prev", "C", "toLevl", "dialect", "cacheKey", "result", "syntaxRules", "rulesArray", "trail", "schemaSet", "assertionTrail", "newDependencyTrail", "cloneSchemaSet", "sch", "rule", "type", "exposure", "inference", "arity", "singletons", "modifier", "booleanfy", "optional", "assert", "syntax", "syntaxes", "rest", "activeTrail", "unsupportedAttrs", "_getUnsupportedRuleAttrs", "isTokenRule", "TOK_TYPES", "t", "registry", "isObject_default", "keys", "k", "a", "fieldSchema", "schema", "newAssertionTrail", "newSchemaSet", "j", "schemaSetClone", "schemaSetCloneResult", "resultSchema", "schemasArray", "schemaA", "schemaAObj", "schemaB", "schemaBObj", "inputJson", "callback", "astSchema", "hardCodedNodeName", "lastAssertion", "$decideThrow", "message", "rulePath", "assertsGrep", "matchTokenRule", "fieldJson", "expectedValue", "resolveField", "fieldValue", "acquireField", "resultAST", "depField", "_inferenceMatch", "count", "resultArray", "entry", "resultLenth", "havingDuplicate", "e", "_e", "paths_loop", "$astSchema", "$inputJson", "rootRule", "tokSchema", "attr", "jsonfy", "relevantTransformer", "defaultTransform", "options1", "childTransformer", "entries", "resultEntries", "input", "tokenStream", "TokenStream", "left", "minPrecedence", "savepoint", "types", "operator", "prevLeft", "newLeft", "numSkippedRules_dialectWise", "newMinPrecedence", "requiredSpacing", "peek", "optionalParens", "itemSeparator", "supportsLeft", "acquireLeft", "peekToken", "name", "matchSpacing", "current", "adjustBy", "eatToken", "op", "tok", "parseNode", "activeTokenStream", "NodeClass", "tokenStreamPosition", "forceThrow", "proximityTerm", "_type", "line", "column", "spaceBefore", "prec", "assoc", "resultType", "itemMinPrecedence", "relevantOperatorDef", "currentAsUnexpected", "startingIndentLevel", "autoLineBreakThreshold", "renderingStats", "$space", "$lineBreak", "indentLevel", "resultTokens", "numSkippedRules_optionalWise", "autoSpacing", "autoIndent", "autoIndentAdjust", "$autoIndent", "activeOptions", "rendering", "highestRenderingScore", "newRenderingStats", "$rendering", "hasExpectedValue", "$rule", "shouldRender", "itemsRendering", "renderingsStr", "$autoItemSpacing", "$itemSeparator", "autoSpaceIgnore", "hitsAutoLineBreakThreshold", "blockAutoLineBreakMode", "delims", "precedingTok", "delimChars", "delimChar", "escChar", "defs", "match", "indent", "lines", "supportedRuleAttrs", "criteria", "exp", "PGCycleClause", "AbstractNode", "PGSearchClause", "AbstractNode", "DDLSchemaMixin", "Class", "#result_schema", "inputJson", "options", "callback", "AbstractNode", "result_schema", "restJson", "instance", "transformer", "linkedDb", "resultJson", "AbstractStmt", "AbstractNode", "#uuid", "inputJson", "options", "callback", "uuid", "restJson", "instance", "transformer", "linkedDb", "resultJson", "AbstractNonDDLStmt", "DDLSchemaMixin", "AbstractStmt", "values", "queryBindings", "i", "bindings", "b", "dedupe", "redundants", "$offset", "newOffset", "Transformer", "_Transformer", "#callback", "#rands", "#hashes", "#parentTransformer", "#statementNode", "#isStatementContext", "#artifacts", "callback", "parentTransformer", "statementNode", "type", "asSalt", "rands", "value", "hashes", "node", "defaultTransform", "key", "options0", "originatingContext", "$defaultTransform", "options1", "childTransformer", "options2", "CTE", "AbstractNonDDLStmt", "options", "transformer", "linkedDb", "outerResultSchema", "Transformer", "node", "defaultTransform", "keyHint", "bodyResultJson", "CTEItem", "AbstractNonDDLStmt", "options", "transformer", "linkedDb", "resultJson", "schemaIdent", "registry", "resultSchema", "s", "Transformer", "node", "defaultTransform", "key", "Identifier", "_Identifier", "AbstractNode", "ident", "cs", "_eq", "CTEItemAlias", "Identifier", "itemSeparator", "ddl_exports", "__export", "CheckConstraint", "ColumnDefaultConstraint", "ColumnDiff", "ColumnExpressionConstraint", "ColumnFKConstraint", "ColumnIdent", "ColumnIdentityConstraint", "ColumnNullConstraint", "ColumnPKConstraint", "ColumnSchema", "ColumnUKConstraint", "ConstraintSchema", "CreateTableStmt", "FKDeleteRule", "FKMatchRule", "FKUpdateRule", "IndexDiff", "IndexSchema", "MYColumnAutoIncrementModifier", "MYColumnCommentModifier", "MYColumnOnUpdateModifier", "MYColumnVisibilityModifier", "PGIndexParamInclude", "PGIndexParamUsing", "PGIndexParamWith", "PGIndexParameters", "PGTableEXConstraint", "PGTableEXConstraintItem", "ReferentialAction", "SchemaDiff", "SchemaIdent", "SchemaSchema", "TableDiff", "TableFKConstraint", "TableIdent", "TablePKConstraint", "TableSchema", "TableUKConstraint", "AbstractNodeList", "AbstractNode", "index", "value", "args", "AbstractDiff", "AbstractNodeList", "ColumnDiff", "AbstractDiff", "AbstractSchema", "_AbstractSchema", "AbstractNodeList", "value", "args", "inputJson", "options", "callback", "AbstractNode", "ddl_name", "restJson", "node", "iddlNameIdent", "registry", "prev", "Class", "renameTo", "transformer", "linkedDb", "resultJson", "ColumnSchema", "AbstractSchema", "cons", "registry", "normalized", "pkConstraint", "pkColumns", "nodeName", "columns", "cJson", "instance", "c", "options", "transformer", "linkedDb", "resultJson", "tableLevelConstraints", "x", "method", "s", "FKMatchRule", "AbstractNode", "FKDeleteRule", "AbstractNode", "FKUpdateRule", "AbstractNode", "PGIndexParameters", "AbstractNodeList", "PGIndexParamInclude", "AbstractNodeList", "PGIndexParamUsing", "AbstractNode", "PGIndexParamWith", "AbstractNodeList", "ConstraintSchema", "AbstractSchema", "rules", "registry", "PGTableEXConstraintItem", "ConstraintSchema", "ReferentialAction", "AbstractNode", "CheckConstraint", "ConstraintSchema", "columns", "node", "registry", "ColumnDefaultConstraint", "ConstraintSchema", "ColumnExpressionConstraint", "ConstraintSchema", "ColumnSchema", "ColumnRef2", "registry", "ColumnFKConstraint", "ConstraintSchema", "itemSeparator", "MYColumnAutoIncrementModifier", "AbstractNode", "options", "transformer", "linkedDb", "ColumnIdentityConstraint", "ColumnIdentityConstraint", "ConstraintSchema", "options", "transformer", "linkedDb", "MYColumnAutoIncrementModifier", "ColumnNullConstraint", "ConstraintSchema", "ColumnPKConstraint", "ConstraintSchema", "registry", "ColumnUKConstraint", "ConstraintSchema", "ColumnSchema", "ColumnRef2", "registry", "MYColumnCommentModifier", "AbstractNode", "MYColumnOnUpdateModifier", "AbstractNode", "MYColumnVisibilityModifier", "AbstractNode", "PGTableEXConstraint", "ConstraintSchema", "itemSeparator", "TableFKConstraint", "ConstraintSchema", "itemSeparator", "TablePKConstraint", "ConstraintSchema", "itemSeparator", "TableUKConstraint", "ConstraintSchema", "itemSeparator", "PathMixin", "Class", "baseRule", "ident", "cs", "result", "tokenStream", "syntaxRules", "left", "minPrecedence", "trail", "options", "resultAST", "qualifierTokens", "qualifierExposure", "qualifierTypes", "qualifierStream", "qualifierOptions", "expr_exports", "__export", "AggrCallExpr", "AtTimeZoneExpr", "BetweenExpr", "BinaryExpr", "BindVar", "BitLiteral", "BoolLiteral", "CallExpr", "CaseBranch", "CaseExpr", "CastExpr", "ColumnRef0", "ColumnRef1", "ColumnRef2", "DefaultLiteral", "DistinctFromExpr", "Expr", "ExtractExpr", "HexLiteral", "Identifier", "InExpr", "LQArrayLiteral", "LQBackBackRef", "LQBackRef", "LQBackRefAbstraction", "LQBackRefEndpoint", "LQDeepDeepRef1", "LQDeepDeepRef2", "LQDeepRef1", "LQDeepRef2", "LQObjectLiteral", "LQObjectProperty", "NullLiteral", "NumberLiteral", "PGCastExpr2", "PGFilterClause", "PGTypedArrayLiteral", "PGWithinGroupClause", "ParenExpr", "PredicateExpr", "QuantitativeExpr", "RowConstructor", "ScalarSubquery", "SchemaRef", "StringLiteral", "SystemVar", "TableRef0", "TableRef1", "TableRef2", "TypedDateLiteral", "TypedIntervalLiteral", "TypedLiteral", "TypedRowConstructor", "TypedTimeLiteral", "TypedTimeZoneLiteral", "TypedTimestampLiteral", "UnaryExpr", "UnknownLiteral", "UserVar", "WindowRef", "TypeSysMixin", "Class", "registry", "AbstractClassicExpr", "TypeSysMixin", "AbstractNode", "ParenExpr", "_ParenExpr", "AbstractClassicExpr", "expr", "RowConstructor", "_RowConstructor", "DDLSchemaMixin", "TypeSysMixin", "AbstractNodeList", "registry", "options", "transformer", "linkedDb", "resultJson", "entriesNode", "resultSchemas", "entry", "i", "ident", "DerivedQuery", "DDLSchemaMixin", "ParenExpr", "options", "transformer", "linkedDb", "resultJson", "resultSchema", "ScalarSubquery", "DerivedQuery", "registry", "options", "transformer", "linkedDb", "resultJson", "resultSchema", "TypedRowConstructor", "RowConstructor", "PGFilterClause", "AbstractNode", "PGWithinGroupClause", "AbstractNode", "CallExpr", "DDLSchemaMixin", "AbstractClassicExpr", "itemSeparator", "AggrCallExpr", "CallExpr", "itemSeparator", "optional_distinct_modifier", "optional_separator_arg", "optional_order_by_clause", "optional_filter_clause_postgres", "optional_within_group_clause_postgres", "optional_null_handling_directive", "optional_over_clause", "CaseExpr", "TypeSysMixin", "AbstractNodeList", "CaseBranch", "AbstractNode", "CastExpr", "AbstractClassicExpr", "BinaryExpr", "AbstractClassicExpr", "operator", "toDialect", "resultType", "operators", "registry", "ExtractExpr", "BinaryExpr", "PredicateExpr", "AbstractClassicExpr", "registry", "QuantitativeExpr", "AbstractNode", "AbstractLiteral", "AbstractClassicExpr", "BitLiteral", "AbstractLiteral", "registry", "BoolLiteral", "AbstractLiteral", "registry", "DefaultLiteral", "AbstractLiteral", "HexLiteral", "AbstractLiteral", "registry", "NullLiteral", "AbstractLiteral", "NumberLiteral", "AbstractLiteral", "registry", "StringLiteral", "AbstractLiteral", "registry", "TypedLiteral", "AbstractClassicExpr", "registry", "TypedDateLiteral", "TypedLiteral", "TypedIntervalLiteral", "TypedLiteral", "TypedTimeLiteral", "TypedLiteral", "TypedTimestampLiteral", "TypedLiteral", "TypedTimeZoneLiteral", "TypedLiteral", "UnknownLiteral", "AbstractLiteral", "SugarMixin", "Class", "AbstractLQJsonLiteral", "SugarMixin", "TypeSysMixin", "AbstractNodeList", "registry", "LQArrayLiteral", "AbstractLQJsonLiteral", "registry", "options", "transformer", "linkedDb", "resultJson", "resultSchemas", "e", "i", "resultSchema", "schemaIdent", "LQObjectLiteral", "AbstractLQJsonLiteral", "registry", "options", "transformer", "linkedDb", "resultJson", "entries", "result", "propertyJson", "ref", "newPropertyJson", "existing", "_eq", "resultSchemas", "args", "i", "resultSchema", "schemaIdent", "LQObjectProperty", "_LQObjectProperty", "AbstractNode", "options", "transformer", "linkedDb", "keyNode", "asAggr", "keyJson", "$options", "valueNode", "registry", "defaultTransform", "childTransformer", "valueJson", "PGTypedArrayLiteral", "AbstractNodeList", "registry", "options", "transformer", "linkedDb", "resultJson", "AtTimeZoneExpr", "BinaryExpr", "registry", "BetweenExpr", "BinaryExpr", "DistinctFromExpr", "BinaryExpr", "InExpr", "BinaryExpr", "PGCastExpr2", "BinaryExpr", "UnaryExpr", "AbstractClassicExpr", "operator", "registry", "ErrorRefUnknown", "ErrorRefAmbiguous", "AbstractClassicRef", "DDLSchemaMixin", "TypeSysMixin", "Identifier", "transformer", "linkedDb", "resultSet", "objectType", "ErrorRefAmbiguous", "ErrorRefUnknown", "ColumnRef1", "_ColumnRef1", "PathMixin", "AbstractClassicRef", "registry", "parentNode", "up", "deepMatchCallback", "transformer", "linkedDb", "name", "inGrepMode", "resultSet", "resolve", "columnSchema", "qualifierJson", "result", "AbstractNode", "resultSchema", "resolvedColumnRef1", "statementContext", "tableSchema", "prev", "newQualifierJson", "compositeResult", "s", "toKind", "options", "resolvedJson", "resultJson", "ColumnRef0", "ColumnRef1", "registry", "ErrorFKInvalid", "message", "AbstractMagicRef", "SugarMixin", "BinaryExpr", "transformer", "linkedDb", "fk", "ErrorFKInvalid", "ColumnRef2", "_ColumnRef2", "AbstractClassicRef", "registry", "deepMatchCallback", "transformer", "linkedDb", "name", "inGrepMode", "resultSet", "resolve", "columnSchema", "result", "AbstractNode", "resultSchema", "resolvedColumnRef2", "tableSchemasInScope", "AbstractMagicRef", "superParentNode", "up", "tableSchemas", "t", "outer", "tableSchema", "toKind", "options", "resultJson", "LQBackBackRef", "_LQBackBackRef", "AbstractMagicRef", "registry", "reverseRef", "toKind", "options", "transformer", "linkedDb", "LQBackRef", "LQBackBackRef", "transformer", "linkedDb", "tableRefs", "ErrorRefUnknown", "toKind", "left", "qualifiedLeftEndpoint", "leftEndpointQualifier", "unqualifiedLeftEndpoint", "registry", "leftFk", "ErrorFKInvalid", "leftEndpointTable", "qualifiedLeftOperand", "resolve", "ddlName", "tableSchema", "pkColumnRef2", "$qualifiedLeftOperand", "ErrorRefAmbiguous", "statementContext", "outer", "type", "qualifiedRightTable", "unqualifiedRightOperand", "LQBackRefAbstraction", "ParenExpr", "LQBackRefEndpoint", "ColumnRef2", "LQDeepDeepRef1", "_LQDeepDeepRef1", "AbstractMagicRef", "registry", "toDeepRef", "toKind", "options", "transformer", "linkedDb", "altsMap", "currentIndex", "LQDeepDeepRef2", "LQDeepDeepRef1", "toDeepRef", "toKind", "options", "transformer", "linkedDb", "LQDeepRef1", "_LQDeepRef1", "LQDeepDeepRef1", "transformer", "linkedDb", "registry", "left", "right", "lhsOperandJson", "rhsOperandJson", "deepRef", "toKind", "detail", "qualifiedLeftOperand", "qualifiedRightTable", "unqualifiedRightOperand", "LQDeepRef2", "LQDeepRef1", "transformer", "linkedDb", "toKind", "toDeepRef", "options", "SchemaRef", "AbstractClassicRef", "deepMatchCallback", "transformer", "linkedDb", "name", "inGrepMode", "resultSet", "resolve", "schemaSchema", "registry", "result", "AbstractNode", "resolvedSchemaRef1", "options", "resultJson", "TableRef1", "PathMixin", "AbstractClassicRef", "registry", "deepMatchCallback", "transformer", "linkedDb", "name", "inGrepMode", "resultSet", "resolve", "tableSchema", "qualifierJson", "result", "AbstractNode", "resolvedTableRef", "statementContext", "originalType", "type", "schemaSchema", "prev", "newQualifierJson", "compositeResult", "s", "options", "resultJson", "TableRef0", "TableRef1", "registry", "TableRef2", "TableRef1", "WindowRef", "Identifier", "BindVar", "AbstractClassicExpr", "SystemVar", "AbstractClassicExpr", "UserVar", "AbstractClassicExpr", "Expr", "AbstractClassicExpr", "ExprNamesInOrder", "instance", "expr_exports", "ExprNames", "k", "a", "b", "comp", "ColumnIdent", "PathMixin", "Identifier", "SchemaIdent", "Identifier", "TableIdent", "PathMixin", "Identifier", "IndexDiff", "AbstractDiff", "IndexSchema", "AbstractSchema", "SchemaDiff", "AbstractDiff", "SchemaSchema", "AbstractSchema", "result", "entry", "registry", "TableDiff", "AbstractDiff", "TableSchema", "AbstractSchema", "itemSeparator", "type", "result", "entry", "registry", "normalized", "pk", "instance", "fk", "uk", "ck", "options", "transformer", "linkedDb", "columnLockedConstraints", "consMap", "Transformer", "node", "defaultTransform", "resultJson", "DDLStmt", "AbstractStmt", "CreateTableStmt", "DDLStmt", "dml_exports", "__export", "AssignmentExpr", "ColumnsConstructor", "ConfigAssignmentExpr", "ConfigAssignmentExprAlt1", "ConfigAssignmentExprAlt2", "DeleteStmt", "InsertStmt", "MYOnDuplicateKeyUpdateClause", "MYPartitionClause", "MYSetStmt", "MYVarAssignmentExpr", "PGConflictTarget", "PGConflictTargetIndexSpec", "PGDefaultValuesClause", "PGOnConflictClause", "PGWhereCurrentClause", "ReturningClause", "SetClause", "TableAbstraction1", "TableAbstraction2", "UpdateStmt", "UpsertStmt", "UsingFromClause", "ValuesConstructor", "MYOnDuplicateKeyUpdateClause", "AbstractNodeList", "MYPartitionClause", "AbstractNodeList", "PGConflictTarget", "AbstractNode", "PGConflictTargetIndexSpec", "AbstractNode", "PGDefaultValuesClause", "AbstractNode", "PGOnConflictClause", "AbstractNodeList", "SelectList", "DDLSchemaMixin", "AbstractNodeList", "options", "transformer", "linkedDb", "resultJson", "resolvedOutputList", "shouldFlattenUnaliasedRootObjects", "shouldDedupe", "addOutputItem", "itemJson", "result", "existing", "_eq", "i", "selectItemJson", "columnRef", "exprJson", "aliasJson", "registry", "argPairs", "key", "value", "resultSchemas", "shouldDeSugarStars", "starsFound", "selectItems", "outputSchemas", "a", "b", "_originalStarJson", "fieldJson", "fieldNode", "ReturningClause", "SelectList", "PGWhereCurrentClause", "AbstractNode", "SetClause", "AbstractNodeList", "UsingFromClause", "AbstractNodeList", "ColumnsConstructor", "AbstractNodeList", "ValuesConstructor", "DDLSchemaMixin", "AbstractNodeList", "itemSeparator", "options", "transformer", "linkedDb", "resultJson", "row1_resultSchema", "AssignmentExpr", "BinaryExpr", "ConfigAssignmentExpr", "BinaryExpr", "ConfigAssignmentExprAlt1", "BinaryExpr", "ConfigAssignmentExprAlt2", "BinaryExpr", "MYVarAssignmentExpr", "BinaryExpr", "TableAbstraction2", "DDLSchemaMixin", "AbstractNode", "derivedAlias", "registry", "options", "transformer", "linkedDb", "resultJson", "derivedAliasJson", "schemaIdent", "resultSchema", "applicableAliasJson", "TableAbstraction1", "AbstractNode", "SelectorStmtMixin", "Class", "options", "transformer", "linkedDb", "ColumnRef1", "ColumnRef2", "AggrCallExpr", "LQBackRefAbstraction", "LQDeepRef1", "LQBackRef", "registry", "Transformer", "node", "defaultTransform", "keyHint", "deSugar", "asAggr", "$options", "isSpecialColumnRef1", "specialColumnRef1ToDeepRef", "columnRef", "lhsOperandJson", "rhsOperandJson", "deepRef", "toAggr", "nodeJson", "select", "detail", "detailJson", "alias", "LQRef", "lhsOperand", "rhsOperand", "rhsTable", "selectorDimensions", "CompleteSelectStmt", "DerivedQuery", "FromClause", "JoinClause", "OnClause", "GroupByClause", "GroupingElement", "FromItem", "SelectList", "SelectItem", "FromItemAlias", "SelectItemAlias", "TableRef1", "BinaryExpr", "$dimensionID", "dimensionID", "rands", "rhsOperandMask", "fieldSpec", "joinJson", "selectorDimension", "selectAlias", "resultJson", "rewrittenJoinEntries", "joinNode", "joinJson2", "childTransformer", "WhereClause", "rand", "tableExpr", "tblAliasOriginal", "tblAliasOriginal_delim", "tblAliasRewrite", "pkColumnRef", "pgGeneratedFromItem", "pgGeneratedWhereClause", "createCorrelationExpr", "selectItems", "createOrPatchAFromEntry", "_eq", "fromItem", "fieldJson", "whereExpr", "fromClause", "fromClauseClass", "fromItemNode", "DMLStmt", "AbstractNonDDLStmt", "resultJson", "transformer", "linkedDb", "options", "returningClauseJson", "registry", "DeleteStmt", "SelectorStmtMixin", "DMLStmt", "itemSeparator", "options", "transformer", "linkedDb", "Transformer", "node", "defaultTransform", "resultJson", "PayloadStmtMixin", "Class", "registry", "options", "transformer", "linkedDb", "LQDeepRef2", "AssignmentExpr", "DerivedQuery", "ColumnsConstructor", "ValuesConstructor", "TypedRowConstructor", "RowConstructor", "specials", "s", "columnList", "pgDefaultValuesClause", "valuesClause", "selectClause", "hasTopLevelDeepRefs", "c", "ignoreList", "Transformer", "node", "defaultTransform", "keyHint", "deSugar", "$options", "conflictHandlingClauseContext", "$$options", "deSugaredLhs", "deSugaredRhs", "resultJson", "rowSet", "rowsJson", "rowSetJson", "columns", "values", "payloadDimensions", "TableRef1", "ColumnRef1", "SelectItemAlias", "ColumnRef2", "DefaultLiteral", "SelectStmt", "CompleteSelectStmt", "PGDefaultValuesClause", "SelectList", "SelectItem", "FromClause", "FromItem", "jsonfy", "_deSugar", "deSugarColumnsList", "dimensionsMap", "columnRef", "columnOffset", "dimension", "deSugarValuesFromDefaultValues", "valuesRow", "valueJson", "deSugarValuesFromValues", "valuesEntries", "rowOffset", "valueNode", "deSugarValuesFromSelect", "selectStmt", "baseSelect", "baseSelectItems", "memoSelect", "memoSelectAlias", "rowNumberExpr", "newBaseSelectFromItem", "rewriteAgainstMemoSelect", "fieldJson", "obfuscateAlias", "newBaseSelectList", "selectList", "subSelectItems", "entryJson", "lhsOperandJson", "correspondingColumn", "LQRefColumn", "lhsOperand", "rhsOperand", "rhsTable", "detail", "LQBackRefAbstraction", "ReturningClause", "ValuesTableLiteral", "WhereClause", "ScalarSubquery", "SetClause", "BinaryExpr", "BoolLiteral", "NumberLiteral", "UpdateStmt", "TableAbstraction2", "baseUUID", "rhsOperandJson", "rhsTableJson", "lhsOperand1Json", "rhsOperand1Json", "rhsTable1Json", "refMode", "isDeepRef", "columnsConstructorJson", "columnsLength", "dimensionValidateRowLength", "rowNode", "result_schema", "rowLength", "createForeignBinding", "sourceUuid", "sourceCol", "sourceRowIndex", "innerFilter", "whereExpr", "whereExprRhs", "tableSpec", "onConflictUpdatedStatusAlias", "whereClause", "query", "payloadDimension", "payload", "payloadJson", "queries", "dimensionPushRow", "fKBindingJson", "lastIndex", "i", "rowJson", "queryTemplate", "selectForeignBinding", "selectJson", "fkField", "correlationRhs", "currentQuery", "isDerivedQuery", "deriveSelectAliasesFromColumns", "rhsOperandPKJson", "ColumnRef0", "AggrCallExpr", "CTE", "CTEItem", "CTEItemAlias", "cte", "$transformer", "toCTEItem", "dimensionID", "queryJson", "indices", "cteItemJson", "flipSelectFromWithRowNumbers", "dependents", "deferedDependencies", "lefts", "onConflictUpdatedStatusRequired", "originalReturningList", "$query", "uuid", "existing", "_eq", "fieldExpr", "wherePredicate", "cteReturningList", "newOuterReturningList", "cteReturningClause", "selectItems", "instance", "prev", "C", "newSelectList", "fromName", "rowNumberJson", "fromItemJson", "alias", "InsertStmt", "PayloadStmtMixin", "DMLStmt", "optional_alias_postgres", "optional_alias_mysql", "options", "transformer", "linkedDb", "Transformer", "node", "defaultTransform", "registry", "subResultJson", "resultSchema", "resultJson", "toDialect", "pkColumn", "MYSetStmt", "AbstractNodeList", "UpdateStmt", "PayloadStmtMixin", "SelectorStmtMixin", "DMLStmt", "options", "transformer", "linkedDb", "Transformer", "node", "defaultTransform", "resultJson", "pkColumn", "registry", "UpsertStmt", "SugarMixin", "InsertStmt", "resultJson", "transformer", "linkedDb", "options", "tableSchema", "t", "toDialect", "columnNamesJson", "e", "c", "conflictHandlingClause", "registry", "uniqueKeysColumnSets", "k", "firstUniqueKeysColumnSet", "colSet", "_eq", "dql_exports", "__export", "BasicSelectStmt", "CompleteSelectStmt", "CompositeSelectStmt", "DerivedQuery", "DistinctClause", "ForClause", "FromClause", "FromItem", "FromItemAlias", "GroupByClause", "GroupingElement", "HavingClause", "JoinClause", "LimitClause", "OffsetClause", "OnClause", "OrderByClause", "OrderElement", "PGFetchClause", "PGOrderOperator", "PartitionByClause", "SRFExpr1", "SRFExpr2", "SRFExpr3", "SRFExpr4", "SRFExprDDL1", "SRFExprDDL2", "SelectItem", "SelectItemAlias", "SelectList", "SelectStmt", "TableStmt", "UsingClause", "ValuesTableLiteral", "WhereClause", "WindowClause", "WindowDeclaration", "WindowFrameBound", "WindowFrameSpec", "WindowSpec", "DistinctClause", "AbstractNode", "ForClause", "AbstractNode", "FromClause", "AbstractNodeList", "GroupByClause", "AbstractNodeList", "GroupingElement", "AbstractNode", "HavingClause", "AbstractNode", "FromItem", "DDLSchemaMixin", "AbstractNode", "itemSeparator", "derivedAliasJson", "registry", "options", "transformer", "linkedDb", "resultJson", "schemaIdent", "resultSchema", "s", "Transformer", "node", "defaultTransform", "key", "applicableAliasJson", "JoinClause", "FromItem", "options", "transformer", "linkedDb", "conditionClauseTransform", "Transformer", "node", "defaultTransform", "keyHint", "resultJson", "LimitClause", "AbstractNode", "OffsetClause", "AbstractNode", "OnClause", "AbstractNode", "OrderByClause", "AbstractNodeList", "OrderElement", "AbstractNode", "PartitionByClause", "AbstractNodeList", "PGFetchClause", "AbstractNode", "PGOrderOperator", "AbstractNode", "UsingClause", "AbstractNode", "WhereClause", "AbstractNode", "WindowClause", "AbstractNodeList", "WindowDeclaration", "AbstractNode", "WindowFrameSpec", "AbstractNode", "itemSeparator", "WindowFrameBound", "AbstractNode", "WindowSpec", "AbstractNode", "FromItemAlias", "Identifier", "itemSeparator", "SelectItem", "_SelectItem", "DDLSchemaMixin", "AbstractNode", "derivedAliasJson", "exprNode", "registry", "endpointNode", "isToPG", "options", "transformer", "linkedDb", "derivedAliasNode", "asAggr", "$options", "defaultExprTransform", "childTransformer", "exprJson", "schemaIdent", "resultSchema", "tableSchema", "applicableAliasJson", "SelectItemAlias", "Identifier", "SRFExpr1", "DDLSchemaMixin", "AbstractNode", "options", "transformer", "linkedDb", "resultJson", "columnDefsJson", "resultSchema", "registry", "SRFExpr2", "DDLSchemaMixin", "AbstractNode", "options", "transformer", "linkedDb", "resultJson", "resultSchema", "ordinalityColumn", "registry", "schemaIdentFromFuncName", "resultSchema_json", "SRFExpr3", "DDLSchemaMixin", "AbstractNode", "options", "transformer", "linkedDb", "resultJson", "resultSchema", "registry", "givenSchema", "schemaIdentFromFuncName", "SRFExpr4", "DDLSchemaMixin", "AbstractNodeList", "options", "transformer", "linkedDb", "resultJson", "ordinalityColumn", "registry", "resultSchema", "entries", "exprJson", "exprJsonEntries", "SRFExprDDL1", "AbstractNode", "SRFExprDDL2", "AbstractNode", "ValuesTableLiteral", "ValuesConstructor", "SelectStmt", "AbstractNonDDLStmt", "part", "part1", "extRules", "part2", "registry", "BasicSelectStmt", "SelectorStmtMixin", "SelectStmt", "options", "transformer", "linkedDb", "deferedTransforms", "Transformer", "node", "defaultTransform", "keyHint", "registry", "childNode", "defaultChildTransform", "subKeyHint", "e", "ErrorRefUnknown", "resultJson", "selectListJson", "fieldName", "deferreds", "resolveds", "deferred", "CompleteSelectStmt", "BasicSelectStmt", "input", "left", "minPrecedence", "trail", "options", "tokenStream", "result", "current", "message", "CompositeSelectStmt", "SelectStmt", "setTypes", "options", "transformer", "linkedDb", "resultJson", "TableStmt", "AbstractStmt", "tableRef", "alias", "tableSchema", "qualif_exports", "__export", "AggrNotation", "LQVersionSpec", "AggrNotation", "AbstractNode", "LQVersionSpec", "AbstractNode", "type_exports", "__export", "DataType", "DataType", "AbstractNode", "JSONSchema", "AbstractNodeList", "registry", "cte_exports", "ddl_exports", "dml_exports", "dql_exports", "expr_exports", "qualif_exports", "type_exports", "JSONSchema", "Query", "AbstractNodeList", "itemSeparator", "input", "options", "tokenStream", "result", "current", "message"]
}
