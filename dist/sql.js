(()=>{function j(c){return c instanceof String||typeof c=="string"&&c!==null}function tt(c){return arguments.length&&(c===void 0||typeof c>"u")}function Bt(c){return typeof c=="function"}function W(c){return Bt(c)||c&&{}.toString.call(c)==="[object function]"}function R(c){return Array.isArray(c)}function be(c){return!j(c)&&!tt(c.length)}function gt(c){return c===null||c===""}function K(c){return Array.isArray(c)||typeof c=="object"&&c||Bt(c)}function vt(c){return gt(c)||tt(c)||c===!1||c===0||K(c)&&!Object.keys(c).length}function O(c){return!Array.isArray(c)&&typeof c=="object"&&c}function Ot(c,t=!0){return R(c)?c:!t&&O(c)?[c]:c!==!1&&c!==0&&vt(c)?[]:be(c)?Array.prototype.slice.call(c):O(c)?Object.values(c):[c]}function It(c){return c instanceof Number||typeof c=="number"}function Y(c){return It(c)||c!==!0&&c!==!1&&c!==null&&c!==""&&!isNaN(c*1)}var Qe=function(c,t=1,e=!0){return!Y(t)||t<=0||(!R(c)&&O(c)&&e&&(c=Object.values(c)),!R(c))?c:c.reduce((s,r)=>R(r)||O(r)&&e?s.concat(Qe(R(r)?r:Object.values(r),t-1,e)):s.concat(r),[])},Me=Qe;function Lt(c,t=1){var e=0;c.forEach(r=>{e++});var s=c.slice(c.length-e,t);return arguments.length>1?s:s[0]}function at(c,t=1){return arguments.length>1?Lt(c.slice().reverse(),t).reverse():Lt(c.slice().reverse())}function Oe(c,...t){return t.forEach(e=>{c.indexOf(e)<0&&c.push(e)}),c}function ze(s,t){t=t||Object.prototype,t=t&&!R(t)?[t]:t;for(var e=[],s=s;s&&(!t||t.indexOf(s)<0)&&s.name!=="default";)e.push(s),s=s?Object.getPrototypeOf(s):null;return e}function Ze(c,t){var e=[];return ze(c,t).forEach(s=>{Oe(e,...Object.getOwnPropertyNames(s))}),e}function yt(c,t,e=!1,s=!1,r=!1){var i=0,a=c.shift();if((Y(a)||a===!0||a===!1)&&(i=a,a=c.shift()),!c.length)throw new Error("_merge() requires two or more array/objects.");return c.forEach((n,o)=>{!K(n)&&!W(n)||(e?Ze(n):Object.keys(n)).forEach(u=>{if(t(u,a,n,o)){var l=a[u],h=n[u];if((R(l)&&R(h)||O(l)&&O(h))&&(i===!0||i>0))a[u]=R(l)&&R(h)?[]:{},yt([Y(i)?i-1:i,a[u],l,h],t,e,s,r);else if(R(a)&&R(n))s?a[u]=h:a.push(h);else try{r?Object.defineProperty(a,u,Object.getOwnPropertyDescriptor(n,u)):a[u]=n[u]}catch{}}})}),a}function Ie(...c){return yt(c,(t,e,s)=>!0,!1,!1,!1)}function Le(c){return O(c)&&Object.getPrototypeOf(c)===Object.prototype}function te(c){return c===!0||c===!1}function ye(c,t){var e=void 0;return K(c)&&Object.keys(c).forEach((s,r)=>{e!==!1&&(e=t(Y(s)?parseFloat(s):s,c[s],r))}),e}function je(c,t,e=!0,s=!0,r=!1,i=!1){if(R(c)&&R(t)){var a=[],n=!0;return c.forEach(o=>{if(n){var u=!1;ye(t,(l,h)=>{(!u||s&&K(o))&&(u=e(o,h),(R(u)&&!u.length||O(u)&&!Object.keys(u).length)&&(u=!1),K(u)&&s&&(o=u))}),K(u)?a.push(s?u:o):te(u)?r&&!u||!r&&u?a.push(o):i&&(n=!1):a.push(u)}}),a}if(O(c)&&O(t)){var a={},n=!0;return Object.keys(c).forEach(l=>{if(n){var h=e(c[l],t[l]);(R(h)&&!h.length||O(h)&&!Object.keys(h).length)&&(h=!1),K(h)?a[l]=s?h:c[l]:te(h)?r&&!h||!r&&h?a[l]=c[l]:i&&(n=!1):a[l]=h}}),a}}var xe=function(c,t,e=!0,s=1){if(R(c)&&R(t)&&c.length!==t.length)return!e;if(O(c)&&O(t)){var r=Object.keys(c),i=Object.keys(t);if(!r.length&&!i.length)return Le(c)&&Le(t)?e:c===t===e;if(!xe(r,i))return!e}if(s>0&&(R(c)&&R(t)||O(c)&&O(t))){var a=je(c,t,(n,o)=>xe(n,o,e,s-1),!1,!1,!0);return R(a)?a.length===c.length&&a.length===t.length:O(a)&&O(c)?Object.keys(a).length===Object.keys(c).length&&Object.keys(a).length===Object.keys(t).length:a}return W(e)?e(c,t):It(c)&&It(t)&&isNaN(c)&&isNaN(t)?e:c===t===e},ts=xe;function Pe(c,t=[]){return yt([{},c],(e,s,r)=>{if(!W(r[e]))return W(t)?t(e):R(t)&&t.length?t.indexOf(e)>-1:!0},!1,!1,!1)}function Gt(c,t,e=null){return R(t)?c.filter(s=>e?t.filter(r=>e(s,r)).length:t.indexOf(s)!==-1):[]}var ot=class c{static lex(t,e,s={}){if(!j(t=t+""))throw new Error("Argument1 must be a string!");var r=u=>({delims:u.delims.slice(),options:Pe(u.options),nesting:u.nesting.slice(),maxDepth:u.maxDepth,comments:u.comments.slice(),tokens:u.tokens.slice(),matches:u.matches.slice(),matchesi:Pe(u.matchesi)});if(c.$cache[t]&&s.cache!==!1)for(var i=0;i<c.$cache[t].length;i++){var a=c.$cache[t][i];if(ts(a.delims,e))return r(a)}var n=new c(t,s),o=n.lex(e);return s.cache!==!1&&(c.$cache[t]=c.$cache[t]||[],c.$cache[t].push(o)),r(o)}static split(t,e,s){return c.lex(t,e,s).tokens}static match(t,e,s){return c.lex(t,e,s).matches}constructor(t,e){if(!j(t))throw new Error("Lexer requires the first argument to be a string.");this.$str=t,this.$options=e||{},this.$options.blocks||(this.$options.blocks=c.$blocks),this.$options.quotes||(this.$options.quotes=c.$quotes),this.$options.comments||(this.$options.comments=c.$comments)}lex(t,e){for(var s={delims:Ot(t),options:Ie(!0,{},this.$options,e||{}),nesting:[],maxDepth:0,comments:[],tokens:[],matches:[],matchesi:{}},r=0;typeof r=="number";)r=this._evalCharsAt(s,r);if(s.nesting.length)throw new Error("Error parsing the string: "+this.$str+". Unterminated blocks: "+Me(s.nesting).join(", "));return s}_evalCharsAt(t,e){if(!(e>=this.$str.length)){var s=1,r={},i={},a={};if(t.openComment||(i=this._testQuotes(t,e)),t.openQuote||(r=this._testComments(t,e)),t.openComment||r.ending)if(!t.nesting.length&&!a.ending){var n=r.starting||r.ending||this.$str[e];s=n.length,this._push(t,n,"comments",r.starting)}else this._push(t,this.$str[e]);else if(t.openQuote||i.ending)this._push(t,this.$str[e]);else{if(t.options.limit&&t.matches.length===t.options.limit)return this._push(t,this.$str[e]),e+1;a=this._testNesting(t,e);var a=this._testNesting(t,e),o=this._testChars(t.options.stopChars||[],t,e);if(!t.nesting.length&&o!==!1){t.options.stopChar=o,t.options.stopCharForward=this.$str.substr(e);return}if(!t.delims.length)t.nesting.length===2&&a.starting?(t.matches.push(null),this._push(t,a.starting),s=a.starting.length):!t.nesting.length&&a.ending?(this._push(t,a.ending),s=a.ending.length,t.matches.push(null)):this._push(t,this.$str[e]);else if(!t.nesting.length&&!a.ending){this._push(t,"");var u=this._testChars(t.delims,t,e);if(u!==!1&&(t.matches.push(u),t.matchesi[e]=u,s=u.length||1,!t.options.preserveDelims)){var l=e+(u.length||1);return l===this.$str.length&&this._push(t,""),l}this._push(t,u||this.$str[e])}else{var n=a.starting||a.ending||this.$str[e];s=n.length,this._push(t,n)}}return e+s}}_testQuotes(t,e){var s={};return(t.options.quotes||[]).forEach(r=>{this.$str.substr(e,1)===r&&(t.openQuote?r===t.openQuote&&(t.openQuote=!1,s.ending=r):(t.openQuote=r,s.starting=r))}),s}_testComments(t,e){var s={};return(t.options.comments||[]).forEach(r=>{if(t.openComment){if(at(r)===at(t.openComment)){var a=at(r);this.$str.substr(e).startsWith(a)&&(t.openComment=!1,s.ending=a)}}else{var i=Lt(r);this.$str.substr(e).startsWith(i)&&(t.openComment=r,s.starting=i)}}),s}_testNesting(t,e){var s={};return(t.options.blocks||[]).forEach(r=>{let i=Lt(r),a;if(i instanceof RegExp?[a]=i.exec(this.$str.substr(e))||[]:this.$str.substr(e).startsWith(i)&&(a=i),a)t.nesting=t.nesting.concat([r]),s.starting=a;else if(t.nesting.length&&at(r)===at(at(t.nesting))){var n=at(r),o;n instanceof RegExp?[o]=n.exec(this.$str.substr(e))||[]:this.$str.substr(e).startsWith(n)&&(o=n),o&&(t.nesting=t.nesting.slice(0,-1),s.ending=o)}}),t.maxDepth=Math.max(t.maxDepth,t.nesting.length),s}_testChars(t,e,s){for(var r=0;r<t.length;r++){let n={useRegex:e.options.useRegex,ci:e.options.ci,...O(t[r])?t[r]:{test:t[r]}};if(W(n.test)){var i=n.test(this.$str.substr(0,s),this.$str.substr(s),e.tokens.slice());if(i!==!1)return i;continue}if(n.useRegex){let u=n.useRegex!==!0?n.useRegex:"";var a=this.$str.substr(s).match(new RegExp("^"+n.test,u));if(a&&(!n.backtest||this.$str.substr(0,s).match(new RegExp(n.backtest,u))))return a[0];continue}let o=(u,l)=>n.ci?u.toLowerCase()===l.toLowerCase():u===l;if(o(this.$str.substr(s,n.test.length),n.test)&&(!n.backtest||o(this.$str.substr(s-n.backtest.length,s),n.backtest)))return n.test}return!1}_push(t,e,s="tokens",r=!1){var i=t.matches.length;if(tt(t.tokens[i])&&(t.tokens[i]=""),s==="comments"){t.tokens[i].comments||(t.tokens[i]=new String(t.tokens[i]),t.tokens[i].comments=[]);var a=t.tokens[i].comments.length-(!t.tokens[i].comments.length||r?0:1);t.tokens[i].comments[a]=(t.tokens[i].comments[a]||"")+e}else{var n=t.tokens[i].comments;t.tokens[i]=t.tokens[i]+e}}split(t,e,s){return this.lex(e,s).tokens}match(t,e,s){return this.lex(e,s).matches}regParse(t,e){return this.lex(t,Ie({useRegex:!0},e||{}))}regSplit(t,e){return this.regParse(t,e).tokens}regMatch(t,e){return this.regParse(t,e).matches}};ot.$blocks=[["(",")"],["[","]"],["{","}"]];ot.$quotes=['"',"'","`"];ot.$comments=[["/*","*/"],["//",`
`]];ot.$cache=Object.create(null);var f=class extends ot{static $blocks=[...ot.$blocks,[new RegExp("^CASE ","i"),new RegExp("^ END","i")]]};var A=class c{CONTEXT;FLAGS=[];constructor(t){this.CONTEXT=t;let e=this.statementNode;e===this&&(e=e.CONTEXT?.statementNode),e?.connectedNodeCallback?.(this)}get params(){return this.CONTEXT?.params||{}}get rootNode(){return this.CONTEXT instanceof c?this.CONTEXT.rootNode:this}get statementNode(){return this.CONTEXT instanceof c?this.CONTEXT.statementNode:null}get quoteChars(){return this.constructor.getQuoteChars(this)}quote(t){let e=this.quoteChars[0];return`${e}${t.replace(new RegExp(e,"g"),e.repeat(2))}${e}`}static getQuoteChars(t,e=!1){return(e&&t?.params?.inputDialect||t?.params?.dialect)==="mysql"&&!t.params.ansiQuotes?["'",'"']:["'"]}get escChar(){return this.constructor.getEscChar(this)}autoEsc(t){let e=(Array.isArray(t)?t:[t]).map(s=>s&&!/^(\*|[\w]+)$/.test(s)?`${this.escChar}${s.replace(new RegExp(this.escChar,"g"),this.escChar.repeat(2))}${this.escChar}`:s);return Array.isArray(t)?e:e[0]}static autoUnesc(t,e,s=!1){let r=this.getEscChar(t,s);return(e||"").replace(new RegExp(r+r,"g"),r)}static getEscChar(t,e=!1){return(e&&t?.params?.inputDialect||t?.params?.dialect)==="mysql"&&!t.params.ansiQuotes?"`":'"'}static parseIdent(t,e,s=!1){let r=this.getEscChar(t,s),i=f.split(e,["."]),a=i.map(o=>new RegExp(`^(?:(\\*|[\\w]+)|(${r})((?:\\2\\2|[^\\2])+)\\2)$`).exec(o.trim())).filter(o=>o);if(a.length!==i.length)return;let n=o=>o?.[1]||this.autoUnesc(t,o?.[3]);return[n(a.pop()),n(a.pop())]}with(t){for(let e in t)this[e]=t[e];return this}withFlag(...t){return t=new Set(t.filter(e=>e)),this.FLAGS=this.FLAGS.reduce((e,s)=>{let r=s.split(":");for(let i of t){let a=i.split(":");a[0]===r[0]&&(s=[...new Set([...r,...a])].join(":"),t.delete(i))}return e.concat(s)},[]).concat(...t),this}getFlag(t){let e=t.toUpperCase().split(":");return this.FLAGS.find(s=>{let r=s.split(":");return e[0]===r[0]&&e.every(i=>r.includes(i))})}hasFlag(t){return!!this.getFlag(t)}build(t,e,s,r){let i=Array.isArray(s)?s:s?[s]:[];if(!i.length)throw new Error("At least one node type must be defined.");let a=o=>i.reduce((u,l)=>u||(o instanceof l?o:l.fromJson(this,o)),null),n=(...o)=>{for(let u of o)Array.isArray(this[t])?this[t].push(u):this[t]=u};if(e.length===1&&typeof e[0]!="function"){let o=a(e[0]);if(o)return n(o)}if(r){if(i.length!==1)throw new Error("To support argument delegation, number of node types must be 1.");let o=this[t]&&!Array.isArray(this[t])?this[t]:new i[0](this);return n(o),o[r](...e)}for(let o of e){if(typeof o=="function"){if(this[t]&&!Array.isArray(this[t])){o(this[t]);continue}if(i.length===1){let h=new i[0](this);n(h),o(h);continue}let l=h=>(...E)=>{let p=i.reduce((m,d)=>m||(d.factoryMethods?h in d.factoryMethods&&d.factoryMethods[h](this,...E):h in d.prototype&&new d(this)),null);if(!p)throw new Error(`Unknow method: ${h}()`);if(n(p),p[h])return p[h](...E);for(let m of E)m(p)};o(new Proxy({},{get:(h,E)=>l(E)}));continue}let u=a(o);if(u){n(u);continue}throw new Error(`Arguments must be of type ${i.map(l=>l.name).join(", ")} or a JSON equivalent. Recieved: ${typeof o=="object"&&o?o.constructor.name:typeof o}`)}}clone(){return this.constructor.fromJson(this.CONTEXT,this.toJson())}static parse(t,e,s=null){}toString(){return this.stringify()}static fromJson(t,e){}toJson(){return{}}};var N=class extends A{BASENAME;NAME;name(t){let e=Array.isArray(t)?[...t]:[t];if(this.NAME=e.pop(),this.BASENAME=e.pop(),e.length)throw new Error(`Idents can be maximum of two parts. Recieved: ${e.reverse().join(".")}.${this.BASENAME}.${this.NAME}`);return this}toJson(){let t=this.BASENAME?[this.BASENAME,this.NAME]:this.NAME;return this.FLAGS.length?{name:t,flags:this.FLAGS}:t}static fromJson(t,e){if(typeof e=="string"||Array.isArray(e))e={name:e};else if(typeof e?.name!="string"&&!Array.isArray(e?.name))return;let s=new this(t).withFlag(...e?.flags||[]);return s.name(e.name),s}stringify(){return this.autoEsc([this.BASENAME,this.NAME].filter(t=>t)).join(".")+""}static parse(t,e){let[s,r]=this.parseIdent(t,e,!0)||[];if(!s)return;let i=new this(t);return i.name(r?[r,s]:s),i}};function Ce(c,t,e=!1){if(t=="")return c;var s=e?c.lastIndexOf(t):c.indexOf(t);return s===-1?"":c.substr(s+t.length)}function De(c,t,e=!1){if(t=="")return c;var s=e?c.lastIndexOf(t):c.indexOf(t);return s===-1?c:c.substr(0,s)}function Fe(c,t){return De(c,t,!0)}function ee(c,t){return c===void 0?"":c.split(/(?=[A-Z])/).join(t||" ")}function Je(c,t){return typeof c!="string"?c:c.replace(/\w\S*/g,function(e){return e.charAt(0).toUpperCase()+(typeof t!==void 0&&t?e.substr(1).toLowerCase():e.substr(1))})}function Ye(c,t){return c=Je(c.replace(/-/g," ")).replace(/ /g,""),t?c:c[0].toLowerCase()+c.substr(1)}function L(c,t,e){return Fe(Ce(c,t),e)}function B(c,t,e){return c.startsWith(t)&&c.endsWith(e)}var v=class extends A{NAME;PRECISION;TZ;constructor(t,e,s,r){super(t),this.NAME=e,this.PRECISION=s,this.TZ=r}toJson(){return this.PRECISION?{name:this.NAME,precision:this.PRECISION,...this.TZ?{tz:this.TZ}:{}}:this.NAME}static fromJson(t,e){if(typeof e=="string"&&(e={name:e}),!(typeof e=="object"&&e)||typeof e.name!="string")return;let s=e.name+(e.precision?`(${e.precision})`:""),[r,i]=ss(s);if(r)return new this(t,r,i)}stringify(){return`${this.NAME}${this.PRECISION?`(${this.PRECISION})`:""}${this.TZ?` ${this.TZ}`:""}`}static parse(t,e){let[s,r,i=""]=ss(e);if(s)return new this(t,s.toUpperCase(),r,i.trim().replace(/\s+/," ").toUpperCase())}static pgFixedTypesRe=/(bigint|int8|bigserial|serial8|boolean|bool|box|bytea|cidr|circle|date|double\s+precision|float8|inet|integer|int|int4|jsonb|json|line|lseg|macaddr8|macaddr|money|path|pg_lsn|pg_snapshot|point|polygon|real|float4|smallint|int2|smallserial|serial2|serial4|serial|text|timetz|timestamptz|tsquery|tsvector|txid_snapshot|uuid|xml)/;static pgVariableTypesRe=/(bit\s+varying|bit|varbit|character\s+varying|character|char|varchar|interval|numeric|timestamp|time)(?:\s+)?(?:\(([\d, ]+)\))?(\s+(?:with|without)\s+time\s+zone)?/;static myFixedTypesRe=/(tinyint|smallint|mediumint|enum|set|tinyblob|mediumblob|longblob|geometry|longstring|geometrycollection|multilinestring|multipoint|multipolygon)/;static myVariableTypesRe=/(float|decimal|double|tinytext|mediumtext|longtext|binary|varbinary|blob)(?:\s+)?(?:\(([\d, ]+)\))?/},ss=c=>{let t,e,s;for(let r of["pgFixedTypesRe","pgVariableTypesRe","myFixedTypesRe","myVariableTypesRe"])if([,t,e,s]=c.match(new RegExp(v[r].source,"i"))||[],t)break;return[t,e,s]};var et=class extends A{NAME;$NAME;STATUS;static get TYPE(){return ee(this.name.replace(/\d/g,""),"_").toUpperCase()}get TYPE(){return this.constructor.TYPE}static get WRITABLE_PROPS(){return["NAME"]}static get SUBTREE_PROPS(){return[]}get WRITABLE_PROPS(){return this.constructor.WRITABLE_PROPS}get SUBTREE_PROPS(){return this.constructor.SUBTREE_PROPS}name(t){return arguments.length?(this[this.smartKey("NAME",!0)]=t,this):this[this.smartKey("NAME")]}smartKey(t,e=!1){if(this.status()==="UP")return e||Be(this[`$${t}`])?`$${t}`:t;if(this.status()==="DOWN"){let s=this.TYPE instanceof A?this.constructor.TYPE:this.TYPE;if(e)throw new Error(`Cannot alter ${s} after having been dropped.`);return t}return t}hardSet(...t){let e=t.pop();if(t.length){let i=t[0],a=()=>{if(this.status()==="DOWN"){let n=this.TYPE instanceof A?this.constructor.TYPE:this.TYPE;throw new Error(`Diffing cannot be done on a node ${n} after having been dropped.`)}else this.status()||this.status("UP");return e(i)};return typeof this.CONTEXT?.hardSet=="function"?this.CONTEXT.hardSet(i,a):Be(i)?a():void 0}let s=this.STATUS;this.STATUS=null;let r=e();return this.STATUS=s,r}status(t,e=!1){if(!arguments.length)return this.STATUS;if(t&&!["UP","DOWN"].includes(t))throw new Error(`Status can only be "UP" or "DOWN". Received: ${t}`);if(this.STATUS=t,e)for(let s of this.SUBTREE_PROPS.reduce((r,i)=>[...r,...this[i]],[]))t!=="UP"?s.status(void 0,!0):s.status(s.status()||(typeof e=="string"?e:void 0),e);return this}drop(){return this.status("DOWN")}dropped(){return this.status()==="DOWN"||this.CONTEXT?.dropped?.()}reverseAlt(t=!1){if(this.status()==="UP"){for(let e of this.WRITABLE_PROPS)if(Be(this[`$${e}`])){let s=this[e];this[e]=this[`$${e}`],this[`$${e}`]=s}}else this.status()==="DOWN"?this.status(void 0):this.status()||this.status("DOWN");if(t)for(let e of this.SUBTREE_PROPS.reduce((s,r)=>[...s,...this[r]],[]))e.reverseAlt(t)}toJson(){return{...this.NAME?{name:this.NAME}:{},...this.$NAME?{$name:this.$NAME}:{},...this.STATUS?{status:this.STATUS}:{},...this.FLAGS.length?{flags:[...this.FLAGS]}:{}}}static fromJson(t,e,s=null){if(e?.name&&typeof e.name!="string"||e.$name&&typeof e.$name!="string")return;let r=s?s():new this(t);return r.hardSet(()=>r.name(e.name)),r.hardSet(e.$name,i=>r.name(i)),e.status&&r.status(e.status),e.flags&&r.withFlag(...e.flags),r}},Be=c=>Array.isArray(c)?c.length:typeof c=="object"&&c?Object.keys(c).length:![void 0,null,""].includes(c);var b=class extends et{static get WRITABLE_PROPS(){return["TYPE"].concat(super.WRITABLE_PROPS)}toJson(){let t={type:this.TYPE,...super.toJson()};return!("name"in t)&&["PRIMARY_KEY","FOREIGN_KEY","UNIQUE_KEY","CHECK"].includes(t.type)&&(t={...t,name:void 0}),t}static fromJson(t,e,s=null){if(e?.type===this.TYPE)return!("name"in e)&&["PRIMARY_KEY","FOREIGN_KEY","UNIQUE_KEY","CHECK"].includes(e.type)&&(e={...e,name:`auto_name_${(0|Math.random()*9e6).toString(36)}`}),super.fromJson(t,e,s)}stringify(){return this.TYPE==="AUTO_INCREMENT"?this.TYPE:`${this.stringifyName()}${this.TYPE.replace("_"," ")}`}static parse(t,e){let{name:s,expr:r}=this.parseName(t,e,!0);if(!(!r||!new RegExp(`^${this.TYPE==="AUTO_INCREMENT"?this.TYPE:this.TYPE.replace("_","\\s+")}$`,"i").test(r)))return new this(t).name(s)}stringifyName(){return this.name()?`CONSTRAINT ${this.autoEsc(this.name())} `:""}static parseName(t,e,s=!1){let i=`(?:CONSTRAINT(?:\\s+(\\w+)|\\s+(${this.getEscChar(t,s)})((?:\\2\\2|[^\\2])+)\\2)\\s+)?`,[,a,,n,o=""]=e.match(new RegExp(`^${i}([\\s\\S]+)$`,"i"))||[];return{name:a||this.autoUnesc(t,n),expr:o.trim()}}static parseColumns(t,e,s=!1){return f.split(L(e,"(",")"),[","]).map(r=>this.parseIdent(t,r.trim(),s)[0])}};var Ct=class extends b{ALWAYS;$ALWAYS;static get WRITABLE_PROPS(){return["ALWAYS"].concat(super.WRITABLE_PROPS)}always(t){return arguments.length?(this[this.smartKey("ALWAYS",!0)]=!!t,this):this[this.smartKey("ALWAYS")]}toJson(){return{always:!!this.ALWAYS,...typeof this.$ALWAYS=="boolean"?{$always:this.$ALWAYS}:{},...super.toJson()}}static fromJson(t,e){return super.fromJson(t,e,()=>{let s=new this(t).always(e.always);return s.hardSet(e.$always,r=>s.always(r)),s})}stringify(){return this.params.dialect==="mysql"?new wt(this.CONTEXT).stringify():`GENERATED ${this.always()?"ALWAYS":"BY DEFAULT"} AS IDENTITY`}static parse(t,e){let{name:s,expr:r}=this.parseName(t,e,!0);if(!(!r||!(r=r.match(new RegExp("^GENERATED\\s+(ALWAYS|BY[ ]+DEFAULT)(?:\\s+AS\\s+IDENTITY)?$","i"))?.[1])))return new this(t).name(s).always(/^ALWAYS$/i.test(r))}};var wt=class extends b{static get TYPE(){return"AUTO_INCREMENT"}stringify(){return this.params.dialect!=="mysql"?new Ct(this.CONTEXT).stringify():"AUTO_INCREMENT"}};var Et=class extends b{EXPR;$EXPR;static get WRITABLE_PROPS(){return["EXPR"].concat(super.WRITABLE_PROPS)}expr(t){return arguments.length?(this[this.smartKey("EXPR",!0)]=t,this):this[this.smartKey("EXPR")]}toJson(){return{expr:this.EXPR,...[void 0,null].includes(this.$EXPR)?{}:{$expr:this.$EXPR},...super.toJson()}}static fromJson(t,e){if(![void 0,null].includes(e?.expr))return super.fromJson(t,e,()=>{let s=new this(t).expr(e.expr);return s.hardSet(e.$expr,r=>s.expr(r)),s})}stringify(){return`${super.stringify()} (${this.expr()})`}static parse(t,e){let{name:s,expr:r}=this.parseName(t,e,!0);return!r||!(r=r.match(new RegExp(`^${this.TYPE}\\s+([\\s\\S]+)$`,"i"))?.[1])?void 0:new this(t).expr(B(r.trim(),"(",")")?L(r.trim(),"(",")"):r).name(s)}};var se=class extends Et{stringify(){return`GENERATED ALWAYS AS (${this.expr()})${this.params.dialect!=="mysql"?" STORED":""}`}static parse(t,e){let{name:s,expr:r}=this.parseName(t,e,!0);if(!(!r||!(r=r.match(new RegExp("^GENERATED\\s+ALWAYS\\s+AS\\s+\\(([\\s\\S]+)\\)(?:\\s+STORED)?$","i"))?.[1])))return new this(t).name(s).expr(r)}};var re=class extends Et{};var ie=class extends b{};var $t=class extends b{};var st=class extends b{TARGET_TABLE;$TARGET_TABLE;TARGET_COLUMNS=[];$TARGET_COLUMNS=[];MATCH_RULE;$MATCH_RULE;UPDATE_RULE;$UPDATE_RULE;DELETE_RULE;$DELETE_RULE;static get WRITABLE_PROPS(){return["TARGET_TABLE","TARGET_COLUMNS","MATCH_RULE","UPDATE_RULE","DELETE_RULE"].concat(super.WRITABLE_PROPS)}targetTable(t){return arguments.length?(this.build(this.smartKey("TARGET_TABLE",!0),[t],N,"name"),this):this[this.smartKey("TARGET_TABLE")]}targetColumns(t){return arguments.length?(this[this.smartKey("TARGET_COLUMNS",!0)]=[].concat(t),this):this[this.smartKey("TARGET_COLUMNS")]}matchRule(t){return arguments.length?(this[this.smartKey("MATCH_RULE",!0)]=t,this):this[this.smartKey("MATCH_RULE")]}updateRule(t){return arguments.length?(this[this.smartKey("UPDATE_RULE",!0)]=t,this):this[this.smartKey("UPDATE_RULE")]}deleteRule(t){return arguments.length?(this[this.smartKey("DELETE_RULE",!0)]=t,this):this[this.smartKey("DELETE_RULE")]}toJson(){return{targetTable:this.TARGET_TABLE.toJson(),...this.$TARGET_TABLE?{$targetTable:this.$TARGET_TABLE.toJson()}:{},targetColumns:this.TARGET_COLUMNS,...this.$TARGET_COLUMNS.length?{$targetColumns:this.$TARGET_COLUMNS}:{},...this.MATCH_RULE?{matchRule:this.MATCH_RULE}:{},...this.$MATCH_RULE?{$matchRule:this.$MATCH_RULE}:{},...this.UPDATE_RULE?{updateRule:this.UPDATE_RULE}:{},...this.$UPDATE_RULE?{$updateRule:this.$UPDATE_RULE}:{},...this.DELETE_RULE?{deleteRule:this.DELETE_RULE}:{},...this.$DELETE_RULE?{$deleteRule:this.$DELETE_RULE}:{},...super.toJson()}}static fromJson(t,e,s=null){if(!(!e?.targetTable||!e.targetColumns?.length))return super.fromJson(t,e,()=>{let r=s?s():new this(t);return r.hardSet(()=>r.targetTable(e.targetTable)),r.hardSet(()=>r.targetColumns(e.targetColumns)),r.hardSet(()=>r.matchRule(e.matchRule)),r.hardSet(()=>r.updateRule(e.updateRule)),r.hardSet(()=>r.deleteRule(e.deleteRule)),r.hardSet(e.$targetTable,i=>r.targetTable(i)),r.hardSet(e.$targetColumns,i=>r.targetColumns(i)),r.hardSet(e.$matchRule,i=>r.matchRule(i)),r.hardSet(e.$updateRule,i=>r.updateRule(i)),r.hardSet(e.$deleteRule,i=>r.deleteRule(i)),r})}stringify(){let t=this.targetTable();if(!t.BASENAME){let r=this.statementNode.basename()||(this.statementNode.CONTEXT instanceof A?this.statementNode.CONTEXT.name():this.statementNode.CONTEXT?.name);t=t.clone().name([r,t.NAME])}let e=`${this.stringifyName()}REFERENCES ${t} (${this.autoEsc(this.targetColumns()).join(", ")})`,s=r=>typeof r=="object"&&r?`${r.rule} (${r.columns.join(", ")})`:r;return this.matchRule()&&(e+=` MATCH ${this.matchRule()}`),this.updateRule()&&(e+=` ON UPDATE ${s(this.updateRule())}`),this.deleteRule()&&(e+=` ON DELETE ${s(this.deleteRule())}`),e}static parse(t,e){let{name:s,expr:r}=this.parseName(t,e,!0);if(!r||!(r=r.match(/^REFERENCES\s+([\s\S]+)$/i)?.[1]))return;let[i,a,n=""]=f.split(r,[]),[o,u]=this.parseIdent(t,i.trim(),!0),l=f.split(L(a,"(",")"),[","]).map(E=>this.parseIdent(t,E.trim(),!0)[0]),h=(E,p)=>{if(p==="MATCH")return E.match(/MATCH\s+(\w+)/i)?.[1];let m=/(NO\s+ACTION|RESTRICT|CASCADE|(SET\s+NULL|SET\s+DEFAULT)(?:\s+\(([^\)]+)\))?)/,[,d,T,_]=E.match(new RegExp(`ON\\s+${p}\\s+${m.source}`,"i"))||[];return T?_?{rule:T,columns:_.split(",").map(S=>S.trim())}:T:d};return new this(t).name(s).targetTable(u?[u,o]:o).targetColumns(l).matchRule(h(n,"MATCH")).updateRule(h(n,"UPDATE")).deleteRule(h(n,"DELETE"))}};var Ut=class extends b{stringify(){return`${this.stringifyName()}UNIQUE`}static parse(t,e){let{name:s,expr:r}=this.parseName(t,e,!0);if(!(!r||!/^UNIQUE(\s+KEY)?$/i.test(r)))return new this(t).name(s)}};var pt=class extends Et{};var $=class extends et{TYPE;$TYPE;CONSTRAINTS=[];static get WRITABLE_PROPS(){return["TYPE"].concat(super.WRITABLE_PROPS)}static get SUBTREE_PROPS(){return["CONSTRAINTS"]}static CONSTRAINT_TYPES=[wt,Ct,se,re,ie,$t,st,Ut,pt];type(t){return arguments.length?(this.build(this.smartKey("TYPE",!0),[t],v),this):this[this.smartKey("TYPE")]}autoIncrement(t=null){return this.constraint("AUTO_INCREMENT",...arguments)}identity(t=null){return this.constraint("IDENTITY",...arguments)}expression(t=null){return this.constraint("EXPRESSION",...arguments)}default(t=null){return this.constraint("DEFAULT",...arguments)}notNull(t=null){return this.constraint("NOT_NULL",...arguments)}primaryKey(t=null){return this.constraint("PRIMARY_KEY",...arguments)}foreignKey(t=null){return this.constraint("FOREIGN_KEY",...arguments)}uniqueKey(t=null){return this.constraint("UNIQUE_KEY",...arguments)}check(t=null){return this.constraint("CHECK",...arguments)}constraint(t,e=null){let s=this.CONSTRAINTS.find(r=>r.TYPE===t);if(arguments.length===1)return s;if(e){if(s){if(e===!0||!Object.keys(e).length)return;throw new Error(`${t} already exists in column. Granular modification of a constraint must be done on an instance of the contraint itself.`)}return this.build("CONSTRAINTS",[{type:t,...typeof e=="object"?e:{}}],this.constructor.CONSTRAINT_TYPES),this.constraint(t)}return s&&s.status("DOWN"),this}toJson(){let t={type:this.TYPE.toJson(),...this.$TYPE?{$type:this.$TYPE.toJson()}:{}};for(let e of this.CONSTRAINTS){let{type:s,...r}=e.toJson(),i=s==="FOREIGN_KEY"?"references":Ye(s.toLowerCase().replace("_"," ")),a=Object.keys(r),n=a.length===1?r[a[0]]:null,o=a.length?n==="DOWN"?!1:a.length===1&&a[0]==="expr"?n:r:!0;t={...t,[i]:o}}return{...t,...super.toJson()}}static fromJson(t,e){let{type:s,$type:r,name:i,$name:a,status:n,...o}=e;if(v.fromJson({},s))return super.fromJson(t,e,()=>{let u=new this(t);u.type(v.fromJson(u,s)),u.hardSet(r,h=>u.type(v.fromJson(u,h)));let l=Object.entries(o).reduce((h,[E,p])=>{if(!["boolean","number","string"].includes(typeof p)&&!(typeof p=="object"&&p))throw new Error(`Invalid value for constraint "${E}"`);let m={...p===!1?{status:"DOWN"}:p===!0?{}:["number","string"].includes(typeof p)?{expr:p}:p};return E.startsWith("$")&&(m=Object.fromEntries(Object.entries(m).map(([d,T])=>[`$${d}`,T])),E=E.slice(1)),E==="references"&&(E="foreignKey"),E in h?Object.assign(h[E],m):h[E]=m,h},{});for(let h in l)u.constraint(ee(h,"_").toUpperCase(),l[h]);return u})}stringify(){let t=this.CONSTRAINTS;return this.params.dialect==="mysql"&&(t=t.filter(e=>e.TYPE!=="FOREIGN_KEY")),`${this.autoEsc(this.name())} ${this.type()}${t.length?` ${t.join(" ")}`:""}`}static parse(t,e,s){let[r,i]=f.split(e,["\\s+"],{useRegex:!0,limit:1}),[a]=this.parseIdent(t,r.trim(),!0)||[];if(!a)return;let n=new this(t).name(a),o="(CONSTRAINT\\s+.+?\\s+)?",u=[{test:`${o}(PRIMARY[ ]+KEY|NOT[ ]+NULL|GENERATED|REFERENCES|UNIQUE(?:[ ]+KEY)?|CHECK|AUTO_INCREMENT)`},{backtest:"^(?!.*\\s+(NOT|SET)\\s+$)",test:`${o}NULL`},{backtest:"^(?!.*\\s+BY\\s+$)",test:`${o}DEFAULT`}],[l,...h]=f.split(i,u,{useRegex:"i",preserveDelims:!0});n.type(s(n,l.trim(),[v]));for(let E of h){let p=s(n,E,this.CONSTRAINT_TYPES);n.build("CONSTRAINTS",[p],this.CONSTRAINT_TYPES)}return n}};var X=class extends et{TYPE;$TYPE;COLUMNS=[];$COLUMNS=[];static get WRITABLE_PROPS(){return["TYPE","COLUMNS"].concat(super.WRITABLE_PROPS)}type(t){return arguments.length?(this[this.smartKey("TYPE",!0)]=t,this):this[this.smartKey("TYPE")]}columns(t){return arguments.length?(this[this.smartKey("COLUMNS",!0)]=[].concat(t),this):this[this.smartKey("COLUMNS")]}toJson(){return{type:this.TYPE,...this.$TYPE?{$type:this.$TYPE}:{},columns:this.COLUMNS,...this.$COLUMNS.length?{$columns:this.$COLUMNS}:{},...super.toJson()}}static fromJson(t,e){if(!(typeof e?.type!="string"||!/^(INDEX|KEY|FULLTEXT)$/i.test(e.type)||!e.columns?.length))return super.fromJson(t,e,()=>{let s=new this(t).columns(e.columns).type(e.type);return s.hardSet(e.$columns,r=>s.columns(r)),s.hardSet(e.$type,r=>s.type(r)),s})}stringify(){return`${this.type()}${this.name()?` ${this.name()}`:""} (${this.columns().join(", ")})`}static parse(t,e){let[s,r,i]=/^((?:(?:FULLTEXT|SPATIAL)(?:\s+INDEX|\s+KEY)?)|(?:INDEX|KEY))([\s\S]+)$/i.exec(e)||[];if(!s)return;let[a,n]=f.split(i,[]),[o]=this.parseIdent(t,a.trim(),!0),u=f.split(L(n,"(",")"),[","]).map(l=>this.parseIdent(t,l.trim(),!0)[0]);return new this(t).type(r.replace(/\s+(INDEX|KEY)/i,"").toUpperCase()).columns(u).name(o)}};var H=class c extends A{TYPE="";REFERENCE=null;ARGUMENT=null;rename(t){return this.TYPE="RENAME",this.ARGUMENT=t,this}move(t){return this.TYPE="MOVE",this.ARGUMENT=t,this}drop(t){return this.TYPE="DROP",this.ARGUMENT=t,this}new(t){return this.TYPE="NEW",this.ARGUMENT=t,this}set(t){return this.TYPE="SET",this.ARGUMENT=t,this}alter(t,e){return this.TYPE="ALTER",this.REFERENCE=t,this.build("ARGUMENT",[e],c),this}change(t,e){return this.TYPE="CHANGE",this.REFERENCE=t,this.ARGUMENT=e,this}owner(t){return this.TYPE="OWNER",this.ARGUMENT=t,this}toJson(){return{type:this.TYPE,...this.REFERENCE?{reference:this.REFERENCE}:{},argument:typeof this.ARGUMENT?.toJson=="function"?this.ARGUMENT.toJson():this.ARGUMENT,...this.FLAGS.length?{flags:this.FLAGS}:{}}}static fromJson(t,e){if(typeof e?.type!="string"||!e.argument)return;let s=new this(t).withFlag(...e.flags||[]);if(["RENAME","MOVE"].includes(e.type))return s[e.type==="RENAME"?"rename":"move"](e.argument),s;if(["DROP","NEW","SET"].includes(e.type)){let r=[];["NEW","SET"].includes(e.type)&&(r=[...$.CONSTRAINT_TYPES,v]),e.type==="NEW"&&(r=[...M.CONSTRAINT_TYPES.concat(r),X,$]);let i=r.reduce((a,n)=>a||n.fromJson(t,e.argument),null)||e.argument;return s[e.type.toLowerCase()](i),s}if(e.type==="ALTER"){let{reference:r,argument:i}=e;return s.alter(r,this.fromJson(s,i)),s}if(e.type==="CHANGE"){let{reference:r,argument:i}=e;return s.change(r,$.fromJson(s,i)),s}}};var F=class extends A{get type(){return this.constructor.name.toUpperCase()}get statementNode(){return this}connectedNodeCallback(t){}static mySubstitutePlaceholders(t,e){return(t?.params?.inputDialect||t?.params?.dialect)!=="mysql"||e.indexOf("?")===-1?e:f.split(e,["?"],{blocks:[]}).reduce((s,r,i)=>s?s+"?"+i+r:r,null)}get expandable(){return!1}async expand(t=!1){return t?this:this.clone()}};var bt=class extends F{static Node=A;NAME;BASENAME;ACTIONS=[];name(t){return arguments.length?(this.NAME=t,this):this.NAME}basename(t){return arguments.length?(this.BASENAME=t,this):this.BASENAME}addRename(t){return this.build("ACTIONS",[t],H,"rename")}addMove(t){return this.build("ACTIONS",[t],H,"move")}addDrop(t){return this.build("ACTIONS",[t],H,"drop")}addNew(t){return this.build("ACTIONS",[t],H,"new")}addAlt(t,e){return this.build("ACTIONS",[t,e],H,"alter")}toJson(){return{name:this.NAME,...this.BASENAME?{basename:this.BASENAME}:{},actions:this.ACTIONS.map(t=>t.toJson()),...this.FLAGS.length?{flags:this.FLAGS}:{}}}static fromJson(t,e){if(typeof e?.name!="string"||!Array.isArray(e.actions))return;let s=new this(t).name(e.name).basename(e.basename).withFlag(...e.flags||[]);for(let r of e.actions)s.ACTIONS.push(H.fromJson(s,r));return s}};var ct=class extends bt{addChange(t,e){return this.build("ACTIONS",[t,e],H,"change")}stringify(){if(!this.ACTIONS.length)return"";let t=[],e,s;for(let n of this.ACTIONS){if(n.TYPE==="RENAME"){e=`RENAME TO ${this.autoEsc(n.ARGUMENT)}`;continue}if(n.TYPE==="MOVE"){s=`SET SCHEMA ${this.autoEsc(n.ARGUMENT)}`;continue}if(n.TYPE==="DROP"){let o=n.hasFlag("IF_EXISTS"),u=n.getFlag("RESTRICT")||n.getFlag("CASCADE");this.params.dialect==="mysql"&&["PRIMARY_KEY","FOREIGN_KEY"].includes(n.ARGUMENT.kind)?n.ARGUMENT.kind==="PRIMARY_KEY"?t.push("DROP PRIMARY KEY"):t.push(`DROP FOREIGN KEY ${this.autoEsc(n.ARGUMENT.name)}`):t.push(`DROP ${n.ARGUMENT.kind==="COLUMN"?"COLUMN":"CONSTRAINT"}${o?" IF EXISTS":""} ${this.autoEsc(n.ARGUMENT.name)}${u?` ${u}`:""}`);continue}if(n.TYPE==="NEW"){let o=n.hasFlag("IF_NOT_EXISTS"),u=n.hasFlag("FIRST"),l=n.getFlag("AFTER")?.replace("AFTER:","");if(t.push(`ADD ${n.ARGUMENT instanceof $?"COLUMN ":""}${o?"IF NOT EXISTS ":""}${n.ARGUMENT}${u?" FIRST":l?` AFTER ${this.autoEsc([l])}`:""}`),this.params.dialect==="mysql"&&n.ARGUMENT instanceof $){let h=n.ARGUMENT.foreignKey();h&&t.push(`ADD ${ForeignKey2.fromJson(instance,h.toJson()).columns([n.ARGUMENT.name()])}`)}continue}if(n.TYPE==="CHANGE"){let o=n.hasFlag("FIRST"),u=n.getFlag("AFTER")?.replace("AFTER:","");t.push(`CHANGE COLUMN ${this.autoEsc(n.REFERENCE.name)} ${n.ARGUMENT}${o?" FIRST":u?` AFTER ${this.autoEsc([u])}`:""}`);continue}if(n.TYPE==="ALTER"){let{REFERENCE:o,ARGUMENT:u}=n;if(u.TYPE==="RENAME"){t.push(`RENAME ${o.kind} ${this.autoEsc(o.name)} TO ${this.autoEsc(u.ARGUMENT)}`);continue}if(u.TYPE==="SET"&&u.ARGUMENT instanceof v)t.push(`ALTER COLUMN ${this.autoEsc(o.name)} SET DATA TYPE ${u.ARGUMENT}`);else if(u.TYPE==="DROP"){let l=["IDENTITY","EXPRESSION"].includes(u.ARGUMENT)&&n.hasFlag("IF_EXISTS");t.push(`ALTER COLUMN ${this.autoEsc(o.name)} DROP ${u.ARGUMENT.replace(/_/," ")}${l?" IF EXISTS":""}`)}else if(o.kind==="COLUMN"){let l=u.ARGUMENT.TYPE==="IDENTITY"?"ADD":"SET";t.push(`ALTER COLUMN ${this.autoEsc(o.name)} ${l} ${u.ARGUMENT}`)}["CONSTRAINT","INDEX"].includes(o.kind)&&t.push(`ALTER ${o.kind} ${this.autoEsc(o.name)} ${u.ARGUMENT}`)}}let r=[];this.params.dialect!=="mysql"&&([t,r]=t.reduce(([n,o],u)=>u.startsWith("RENAME")?[n,o.concat(u)]:[n.concat(u),o],[[],[]]));let i=[],a=this.BASENAME||(this.CONTEXT instanceof this.constructor.Node?this.CONTEXT.NAME:this.CONTEXT?.name);t.length&&i.push(`ALTER TABLE${this.hasFlag("IF_EXISTS")?" IF EXISTS":""} ${this.autoEsc([a,this.NAME].filter(n=>n)).join(".")}
	${t.join(`,
	`)}`);for(let n of r)i.push(`ALTER TABLE${this.hasFlag("IF_EXISTS")?" IF EXISTS":""} ${this.autoEsc([a,this.NAME].filter(o=>o)).join(".")}
	${n}`);return e&&i.push(`ALTER TABLE${this.hasFlag("IF_EXISTS")?" IF EXISTS":""} ${this.autoEsc([a,this.NAME].filter(n=>n)).join(".")}
	${e}`),s&&i.push(`ALTER TABLE${this.hasFlag("IF_EXISTS")?" IF EXISTS":""} ${this.autoEsc([a,e?this.ACTIONS.find(n=>n.TYPE==="RENAME").ARGUMENT:this.NAME].filter(n=>n)).join(".")}
	${s}`),i.join(`;
`)}static parse(t,e,s){let[r,i,a]=/^ALTER\s+TABLE\s+(IF\s+EXISTS\s+)?([\s\S]+)$/i.exec(e.trim())||[];if(!r)return;let[n,o]=f.split(a,["\\s+"],{useRegex:!0,limit:1}),[u,l]=this.parseIdent(t,n.trim(),!0)||[];if(!u)return;let h=new this(t).name(u).basename(l);i&&h.withFlag("IF_EXISTS");let E=m=>new RegExp(`${this[m].source}`,"i"),p=f.split(o,[","]).map(m=>m.trim());for(let m of p){let[d,T,_,,S,g,,C]=E("renameRe").exec(m)||[];if(d){let Q=_||this.autoUnesc(h,S),z=g||this.autoUnesc(h,C);if(Q){let Z={kind:/KEY|INDEX/i.test(T)?"INDEX":T.toUpperCase(),name:Q};h.addAlt(Z,Rt=>Rt.rename(z))}else h.addRename(z);continue}let[U,k,,us]=E("moveRe").exec(m)||[];if(U){h.addMove(k||this.autoUnesc(h,us));continue}let[ls,Ke="COLUMN",hs,fs,,ms,Es]=E("dropRe").exec(m)||[];if(ls){let Q=fs||this.autoUnesc(h,ms)||Ke.trim().replace(/\s+KEY/i,"").toUpperCase(),z=[hs,Es].filter(J=>J).map(J=>J.trim().replace(/\s+/g,"_").toUpperCase());h.addDrop({kind:Ke.trim().replace(/\s+/g,"_").toUpperCase(),name:Q}).withFlag(...z);continue}let[ps,As,He,Xe]=E("addRe").exec(m)||[];if(ps){let[,Q,z,J]=Xe.match(/([\s\S]+)\s+(?:(FIRST)|AFTER\s+(.+))$/i)||[,Xe],Z=s(h,Q.trim(),As?[$]:[...M.CONSTRAINT_TYPES,X,$]),Rt=[He,z].filter(dt=>dt).map(dt=>dt.trim().replace(/\s+/g,"_").toUpperCase()).concat(J?`AFTER:${J}`:[]);h.addNew(Z).withFlag(...Rt);continue}let[Ts,ds,Ss,,Ns,qe]=E("changeRe").exec(m)||[];if(Ts){let Q=Ss||this.autoUnesc(h,Ns),[,z,J,Z]=qe.match(/([\s\S]+)\s+(?:(FIRST)|AFTER\s+(.+))$/i)||[,qe],Rt=s(h,/MODIFY/i.test(ds)?`${Q} ${z}`:z,[$]),dt=[He,J].filter(jt=>jt).map(jt=>jt.trim().replace(/\s+/g,"_").toUpperCase()).concat(Z?`AFTER:${Z}`:[]);h.addChange({kind:"COLUMN",name:Q},Rt).withFlag(...dt);continue}let[_s,Ve,Rs,,gs,ke="",ge="",Os,Is]=E("alterRe").exec(m)||[];if(_s){let Q=Rs||this.autoUnesc(h,gs),z=/CONSTRAINT|CHECK/i.test(Ve)?"CONSTRAINT":/INDEX|KEY/i.test(Ve)?"INDEX":"COLUMN",J,Z=ke.toUpperCase()||"SET",Rt=Os?["IF_EXISTS"]:[],dt={};Z==="DROP"?J=ge:Z.endsWith("TYPE")?(J=s(h,ge,[v]),Z="SET"):(dt.argument=s(h,ge,$.CONSTRAINT_TYPES,{assert:!1}))?J=dt.argument:ke?J=ge:J=Is;let jt={kind:z,name:Q};h.addAlt(jt,Ls=>Ls[Z.toLowerCase()](J)).withFlag(...Rt);continue}throw new SyntaxError(m)}return h}static renameRe=/^RENAME\s+(?:(?:(COLUMN|CONSTRAINT|INDEX|KEY)\s+)?(?:(\w+)|([`"])((?:\3\3|[^\3])+)\3)\s+)?(?:TO|AS)\s+(?:(\w+)|([`"])((?:\6\6|[^\6])+)\6)$/;static moveRe=/^SET\s+SCHEMA\s+(?:(\w+)|([`"])((?:\2\2|[^\2])+)\2)$/;static dropRe=/^DROP\s+(COLUMN\s+|CONSTRAINT\s+|PRIMARY\s+KEY|FOREIGN\s+KEY\s+|CHECK\s+|INDEX\s+|KEY\s+)?(IF\s+EXISTS\s+)?(?:(\w+)|([`"])((?:\4\4|[^\3])+)\4)?(?:\s+(RESTRICT|CASCADE))?$/;static addRe=/^ADD\s+(COLUMN\s+)?(IF\s+NOT\s+EXISTS\s+)?([\s\S]+)$/;static changeRe=/^(CHANGE|MODIFY)\s+COLUMN\s+(?:(\w+)|([`"])((?:\3\3|[^\3])+?)\3)\s+([\s\S]+)$/;static alterRe=/^ALTER\s+(?:(COLUMN|CONSTRAINT|CHECK|INDEX|KEY)\s+)?(?:(\w+)|([`"])((?:\3\3|[^\3])+?)\3)\s+(?:(ADD|DROP|(?:SET\s+DATA\s+)?TYPE|SET)\s+(.+)(IF\s+EXISTS)?$|(VISIBLE|(?:NOT\s+)?INVISIBLE|NOT\s+ENFORCED|ENFORCED|DEFERRABLE|NOT\s+DEFERRABLE|INITIALLY\s+DEFERRED|INITIALLY\s+IMMEDIATE))/};var Mt=class extends et{static Node=A;BASENAME;$BASENAME;get statementNode(){return this}connectedNodeCallback(t){}basename(t){return arguments.length?(this[this.smartKey("BASENAME",!0)]=t,this):this[this.smartKey("BASENAME")]}toJson(){return{...this.BASENAME?{basename:this.BASENAME}:{},...this.$BASENAME?{$basename:this.$BASENAME}:{},...super.toJson()}}static fromJson(t,e,s=null){if(!(e?.basename&&typeof e.basename!="string"||e.$basename&&typeof e.$basename!="string"))return super.fromJson(t,e,()=>{let r=s?s():new this(t);return r.hardSet(()=>r.basename(e.basename)),r.hardSet(e.$basename,i=>r.basename(i)),r})}};var Wt=class extends $t{COLUMNS=[];$COLUMNS=[];static get WRITABLE_PROPS(){return["COLUMNS"].concat(super.WRITABLE_PROPS)}columns(t){return arguments.length?(this[this.smartKey("COLUMNS",!0)]=[].concat(t),this):this[this.smartKey("COLUMNS")]}toJson(){return{columns:this.COLUMNS,...this.$COLUMNS.length?{$columns:this.$COLUMNS}:{},...super.toJson()}}static fromJson(t,e){if(e?.columns?.length)return super.fromJson(t,e,()=>{let s=new this(t).columns(e.columns);return s.hardSet(e.$columns,r=>s.columns(r)),s})}stringify(){return`${super.stringify()} (${this.autoEsc(this.columns()).join(", ")})`}static parse(t,e,s){let[r,i]=f.split(e,[]),a=super.parse(t,r.trim(),s);if(a)return a.columns(this.parseColumns(t,i))}};var xt=class extends st{COLUMNS=[];$COLUMNS=[];static get WRITABLE_PROPS(){return["COLUMNS"].concat(super.WRITABLE_PROPS)}columns(t){return arguments.length?(this[this.smartKey("COLUMNS",!0)]=[].concat(t),this):this[this.smartKey("COLUMNS")]}toJson(){return{columns:this.COLUMNS,...this.$COLUMNS.length?{$columns:this.$COLUMNS}:{},...super.toJson()}}static fromJson(t,e){if(e?.columns?.length)return super.fromJson(t,e,()=>{let s=new this(t).columns(e.columns);return s.hardSet(e.$columns,r=>s.columns(r)),s})}stringify(){let t=this.stringifyName(),e=this.NAME,s=this.$NAME;this.NAME=null,this.$NAME=null;let r=`${t}FOREIGN KEY (${this.autoEsc(this.columns()).join(", ")}) ${super.stringify()}`;return this.NAME=e,this.$NAME=s,r}static parse(t,e,s){let{name:r="",expr:i}=this.parseName(t,e,!0);if(!i||!/^FOREIGN\s+KEY/i.test(i))return;let[,a,...n]=f.split(i,[]);return super.parse(t,n.join("").trim(),s).name(r).columns(this.parseColumns(t,a))}};var Kt=class extends Ut{COLUMNS=[];$COLUMNS=[];static get WRITABLE_PROPS(){return["COLUMNS"].concat(super.WRITABLE_PROPS)}columns(t){return arguments.length?(this[this.smartKey("COLUMNS",!0)]=[].concat(t),this):this[this.smartKey("COLUMNS")]}toJson(){return{columns:this.COLUMNS,...this.$COLUMNS.length?{$columns:this.$COLUMNS}:{},...super.toJson()}}static fromJson(t,e){if(e?.columns?.length)return super.fromJson(t,e,()=>{let s=new this(t).columns(e.columns);return s.hardSet(e.$columns,r=>s.columns(r)),s})}stringify(){return`${super.stringify()} (${this.autoEsc(this.columns()).join(", ")})`}static parse(t,e,s){let[r,i]=f.split(e,[]),a=super.parse(t,r.trim(),s);if(a)return a.columns(this.parseColumns(t,i))}};var M=class c extends Mt{COLUMNS=[];CONSTRAINTS=[];INDEXES=[];NODES=new Set;static get WRITABLE_PROPS(){return["BASENAME"].concat(super.WRITABLE_PROPS)}static get SUBTREE_PROPS(){return["COLUMNS","CONSTRAINTS","INDEXES"]}static CONSTRAINT_TYPES=[Wt,xt,Kt,pt];connectedNodeCallback(t){[$,b,X].some(e=>t instanceof e)&&this.NODES.add(t)}primaryKey(){return this.CONSTRAINTS.find(t=>t.TYPE==="PRIMARY_KEY")||this.COLUMNS.reduce((t,e)=>t||e.primaryKey(),null)}column(t){return typeof t=="string"?this.COLUMNS.find(e=>e.name()===t):(this.build("COLUMNS",[t],$),this)}constraint(t){return typeof t=="string"?this.CONSTRAINTS.find(e=>e.name()===t):(this.build("CONSTRAINTS",[t],this.constructor.CONSTRAINT_TYPES),this)}index(t){return typeof t=="string"?this.INDEXES.find(e=>e.name()===t):(this.build("INDEXES",[t],X),this)}alterWith(t){let e=(s,r=!1)=>{let i=this.NODES.find(a=>(s.kind==="COLUMN"?a instanceof $:s.kind==="CONSTRAINT"?a instanceof b:a.TYPE===s.kind)&&(s.name?a.NAME===s.name:s.kind==="PRIMARY_KEY"));if(!i&&!r)throw new Error(`${s.kind}${s.name?` "${s.name}"`:""} does not exist.`);return i};for(let s of t.ACTIONS)if(s.TYPE==="RENAME")this.name(s.ARGUMENT);else if(s.TYPE==="MOVE")this.basename(s.ARGUMENT);else if(s.TYPE==="DROP")e(s.ARGUMENT,s.hasFlag("IF_EXISTS"))?.status("DOWN");else if(s.TYPE==="NEW")s.ARGUMENT instanceof b?s.ARGUMENT.COLUMNS.length===1?e({kind:"COLUMN",name:s.ARGUMENT.COLUMNS[0]}).constraint(s.ARGUMENT.TYPE,s.ARGUMENT.toJson()):this.constraint(s.ARGUMENT.toJson()):s.ARGUMENT instanceof X?this.index(s.ARGUMENT.toJson()):(!s.hasFlag("IF_NOT_EXISTS")||!e({kind:"COLUMN",name:s.ARGUMENT.NAME},!0))&&this.column(s.ARGUMENT.toJson());else if(s.TYPE==="CHANGE"){let r=e(s.REFERENCE);r.status("UP",()=>{s.ARGUMENT.name()!==r.name()&&r.name(s.ARGUMENT.name()),r.type(s.ARGUMENT.type().toJson())});for(let i of s.ARGUMENT.CONSTRAINTS.filter(a=>!["PRIMARY_KEY","FOREIGN_KEY","UNIQUE_KEY","CHECK"].includes(a.TYPE))){let a=r.constraint(i.TYPE);a?a.detail(i.DETAIL):r.constraint(i.toJson())}}else if(s.TYPE==="ALTER"){let{REFERENCE:r,ARGUMENT:i}=s,a=e(r,s.hasFlag("IF_EXISTS"));if(!a)continue;if(i.TYPE==="RENAME")a.name(i.ARGUMENT);else if(i.TYPE==="SET"&&i.ARGUMENT instanceof DataType)a.type(i.ARGUMENT.toJson());else if($.CONSTRAINT_TYPES.some(n=>i.ARGUMENT instanceof n)){let n=a.constraint(i.ARGUMENT.TYPE);if(i.ARGUMENT.TYPE==="IDENTITY"){if(i.TYPE==="SET"&&!n)throw new Error(`IDENTITY constraint has not been created in ${a.NAME}`);if(i.TYPE==="NEW"&&n)throw new Error(`IDENTITY constraint already exists in ${a.NAME}`)}else if(i.ARGUMENT.TYPE==="EXPRESSION"&&i.TYPE!=="DROP")throw new Error("Cannot add EXPRESSION constraint after column creation");n?n.detail(i.ARGUMENT.DETAIL):a.constraint(i.ARGUMENT.toJson())}else if(i.TYPE==="DROP"&&["IDENTITY","EXPRESSION","DEFAULT","NOT_NULL"].includes(i.ARGUMENT)){let n=a.constraint(i.ARGUMENT);if(n)n.status("DOWN");else if(!s.hasFlag("IF_EXISTS"))throw new Error(`Cannot drop ${i.ARGUMENT}; does not exist.`)}else["CONSTRAINT","INDEX"].includes(r.kind)}}getAlt(){let t=new ct(this.CONTEXT).name(this.NAME).basename(this.BASENAME);this.$NAME&&this.NAME&&this.$NAME!==this.NAME&&t.addRename(this.$NAME),this.$BASENAME&&this.BASENAME&&this.$BASENAME!==this.BASENAME&&t.addMove(this.$BASENAME);let e=(r,i=!1)=>r.status()!=="UP"||["$EXPR","$ALWAYS","$TARGET_TABLE","$TARGET_COLUMNS","$MATCH_RULE","$UPDATE_RULE","$DELETE_RULE"].concat(i?"$NAME":[]).some(a=>a in r&&(Array.isArray(r[a])?r[a].length:![void 0,null].includes(r[a]))&&!Ht(r[a.slice(1)],r[a]));for(let r of this.COLUMNS){let i={kind:"COLUMN",name:r.NAME};if(r.status()==="UP"){if(this.params.dialect==="mysql")if(r.$TYPE&&!Ht(r.$TYPE.toJson(),r.TYPE.toJson())||r.CONSTRAINTS.some(n=>["AUTO_INCREMENT","EXPRESSION","NOT_NULL"].includes(n.TYPE)&&e(n,!0))){let n=r.clone();n.CONSTRAINTS=n.CONSTRAINTS.filter(o=>["AUTO_INCREMENT","EXPRESSION","NOT_NULL","DEFAULT"].includes(o.TYPE)),t.addChange(i,n)}else{let n=r.CONSTRAINTS.find(o=>o.TYPE==="DEFAULT"&&e(o,!0));n&&t.addAlt(i,o=>n.status()==="DOWN"?o.drop(n.TYPE):o.set(n)),r.$NAME&&r.$NAME!==r.NAME&&t.addAlt({kind:"COLUMN",name:r.NAME},o=>o.rename(r.$NAME))}else{r.$TYPE&&!Ht(r.$TYPE.toJson(),r.TYPE.toJson())&&t.addAlt(i,o=>o.set(r.$TYPE));let n=r.CONSTRAINTS.filter(o=>["IDENTITY","EXPRESSION","NOT_NULL","DEFAULT"].includes(o.TYPE)&&e(o,!0));for(let o of n){if(o.status()==="UP"&&o.TYPE==="IDENTITY"&&t.addAlt(i,u=>u.drop("IDENTITY")),o.status()!=="DOWN"&&o.TYPE==="EXPRESSION")throw new Error("EXPRESSION constraints cannot be added or modified after column creation.");t.addAlt(i,u=>o.status()==="DOWN"?u.drop(o.TYPE):u[o.TYPE==="IDENTITY"?"new":"set"](o))}r.$NAME&&r.$NAME!==r.NAME&&t.addAlt({kind:"COLUMN",name:r.NAME},o=>o.rename(r.$NAME))}let a=r.CONSTRAINTS.filter(n=>["PRIMARY_KEY","FOREIGN_KEY","UNIQUE_KEY","CHECK"].includes(n.TYPE));for(let n of a)e(n)?(["UP","DOWN"].includes(n.status())&&t.addDrop({kind:n.TYPE,name:n.NAME}),n.status()!=="DOWN"&&t.addNew(c.CONSTRAINT_TYPES.find(o=>o.TYPE===n.TYPE).fromJson(t,{...n.toJson(),columns:[r.statementNode.altsCascaded?r.name():r.NAME]}))):n.status()==="UP"&&n.$NAME&&n.$NAME!==n.NAME&&t.addAlt({kind:"CONSTRAINT",name:n.NAME},o=>o.rename(n.$NAME));continue}if(r.status()==="DOWN"){t.addDrop(i);continue}t.addNew($.fromJson(t,r.toJson()))}let s=r=>e(r)||r.$COLUMNS?.length&&!Ht(r.$COLUMNS,r.COLUMNS);for(let r of this.CONSTRAINTS)s(r)?(["UP","DOWN"].includes(r.status())&&t.addDrop({kind:r.TYPE,name:r.NAME}),r.status()!=="DOWN"&&t.addNew(c.CONSTRAINT_TYPES.find(i=>i.TYPE===r.TYPE).fromJson(t,r.toJson()))):r.status()==="UP"&&r.$NAME&&r.$NAME!==r.NAME&&t.addAlt({kind:"CONSTRAINT",name:r.NAME},i=>i.rename(r.$NAME));return t}cascadeAlt(){this.status(this.status(),!0);let t=s=>s.dropped()?"DOWN":s.$NAME&&s.$NAME!==s.NAME?"RENAME":null,e=t(this);for(let s of this.COLUMNS){let r=t(s);if(r)for(let i of this.CONSTRAINTS){if(i instanceof pt)continue;let a=i.$COLUMNS.length?i.$COLUMNS:i.COLUMNS,n=a.indexOf(s.NAME);n>-1&&(r==="DOWN"?a.splice(n,1):r==="RENAME"&&(a[n]=s.$NAME))}}return this.altsCascaded=!0,this}updateDatabaseReferences(t,e){for(let s of this.NODES)s instanceof st&&s.targetTable().basename()===t.NAME&&(e==="DOWN"?s.status("DOWN"):e==="RENAME"&&s.targetTable().basename(t.$NAME))}updateTableReferences(t,e){for(let s of this.NODES)s instanceof st&&(s.targetTable().basename()&&t.basename()&&s.targetTable().basename()!==t.basename()||s.targetTable().name()===t.NAME&&(e==="DOWN"?s.status("DOWN"):e==="RENAME"&&s.targetTable().name(t.$NAME)))}updateColumnReferences(t,e){for(let s of this.NODES){if(!(s instanceof st)||s.targetTable().basename()&&t.statementNode.basename()&&s.targetTable().basename()!==t.statementNode.basename()||s.targetTable().name()!==t.statementNode.name())continue;let r=cons.$TARGET_COLUMNS.length?cons.$TARGET_COLUMNS:cons.TARGET_COLUMNS,i=r.indexOf(t.NAME);i>-1&&(e==="DOWN"?r.splice(i,1):e==="RENAME"&&(r[i]=t.$NAME))}}toJson(){return{columns:this.COLUMNS.map(t=>t.toJson()),constraints:this.CONSTRAINTS.map(t=>t.toJson()),indexes:this.INDEXES.map(t=>t.toJson()),...super.toJson()}}static fromJson(t,e){if(!(!Array.isArray(e?.columns)||["constraints","indexes"].some(s=>s in e&&!Array.isArray(e[s]))))return super.fromJson(t,e,()=>{let s=new this(t);for(let r of e.columns)s.column(r);for(let r of e.constraints||[])s.constraint(r);for(let r of e.indexes||[])s.index(r);return s})}stringify(){let t=[this.COLUMNS.map(i=>i.stringify()).join(`,
	`)],e=this.CONSTRAINTS.slice(0),s=this.INDEXES.slice(0);this.params.dialect==="mysql"&&e.push(...this.COLUMNS.reduce((i,a)=>{let n=a.foreignKey();return n?i.concat(xt.fromJson(this,n.toJson()).columns([a.name()])):i},[])),e.length&&t.push(e.map(i=>i.stringify()).join(`,
	`)),s.length&&t.push(s.map(i=>i.stringify()).join(`,
	`));let r=this.basename()||(this.CONTEXT instanceof this.constructor.Node?this.CONTEXT.NAME:this.CONTEXT?.name);return`CREATE TABLE${this.hasFlag("IF_NOT_EXISTS")?" IF NOT EXISTS":""} ${this.autoEsc([r,this.name()].filter(i=>i)).join(".")} (
	${t.join(`,
	`)}
)`}static parse(t,e,s){let[r,i,a]=/^CREATE\s+TABLE\s+(IF\s+NOT\s+EXISTS\s+)?([\s\S]+)$/i.exec(e.trim())||[];if(!r)return;let[n,o]=f.split(a,[],{limit:2}),[u,l]=this.parseIdent(t,n.trim(),!0)||[];if(!u)return;let h=new this(t).name(u).basename(l);i&&h.withFlag("IF_NOT_EXISTS");let E=f.split(L(o,"(",")"),[","]).map(p=>s(h,p.trim(),[Wt,xt,Kt,pt,X,$]));for(let p of E)p instanceof $?h.column(p):p instanceof X?h.index(p):h.constraint(p);return h}};function Ht(c,t){if(c===t)return!0;if(Array.isArray(c)&&Array.isArray(t)&&c.length===t.length){let s=t.slice(0).sort();return c.slice(0).sort().every((r,i)=>Ht(r,s[i]))}let e={};return typeof c=="object"&&c&&typeof t=="object"&&t&&(e.keys_a=Object.keys(c)).length===(e.keys_b=Object.keys(t)).length?e.keys_a.reduce((s,r)=>s&&Ht(c[r],t[r]),!0):!1}var ut=class extends bt{addOwner(t){return this.build("ACTIONS",[t],H,"owner")}stringify(){if(!this.ACTIONS.length)return"";let t=[],e,s;for(let i of this.ACTIONS){if(i.TYPE==="RENAME"){e=`RENAME TO ${this.autoEsc(i.ARGUMENT)}`;continue}if(i.TYPE==="MOVE"){s=`SET TABLESPACE ${this.autoEsc(i.ARGUMENT)}`;continue}if(i.TYPE==="DROP"){let a=i.hasFlag("IF_EXISTS"),n=i.getFlag("RESTRICT")||i.getFlag("CASCADE");t.push(`DROP TABLE${a?" IF EXISTS":""} ${this.autoEsc([].concat(i.ARGUMENT.name)).join(".")}${n?` ${n}`:""}`);continue}if(i.TYPE==="NEW"){t.push(i.ARGUMENT+"");continue}if(i.TYPE==="ALTER"){let{REFERENCE:a,ARGUMENT:n}=i;t.push(n.ARGUMENT+"")}}let r=[...t];return e&&r.push(`ALTER SCHEMA ${this.autoEsc(this.NAME)}
	${e}`),s&&r.push(`ALTER SCHEMA ${this.autoEsc(e?this.ACTIONS.find(i=>i.TYPE==="RENAME").ARGUMENT:this.NAME)}
	${s}`),r.join(`;
`)}static parse(t,e){let[s,r]=/^ALTER\s+DATABASE\s+([\s\S]+)$/i.exec(e)||[];if(!s)return;let[i,a]=f.split(r,["\\s+"],{useRegex:!0,limit:1}),[n]=this.parseIdent(t,i.trim(),!0)||[];if(!n)return;let o=new this(t).name(n),u=g=>new RegExp(`${this[g].source}`,"i"),[l,h,,E]=u("renameRe").exec(a)||[];if(l){let g=h||this.autoUnesc(o,E);return o.addRename(g),o}let[p,m,,d]=u("moveRe").exec(a)||[];if(p)return o.addMove(m||this.autoUnesc(o,d)),o;let[T,_,,S]=u("ownerRe").exec(a)||[];return T&&o.addOwner(_||this.autoUnesc(o,S)),o}static renameRe=/^RENAME\s+TO\s+(?:(\w+)|([`"])((?:\2\2|[^\2])+)\2)$/;static moveRe=/^SET\s+TABLESPACE\s+(?:(\w+)|([`"])((?:\2\2|[^\2])+)\2)$/;static ownerRe=/^OWNER\s+TO\s+(?:(\w+)|([`"])((?:\2\2|[^\2])+)\2)$/};var G=class extends Mt{TABLES=[];static get SUBTREE_PROPS(){return["TABLES"]}table(t){return typeof t=="string"?this.TABLES.find(e=>e.name()===t):(this.build("TABLES",[t],M),this)}alterWith(t){let e=(s,r=!1)=>{let i=this.table(s);if(!i&&!r)throw new Error(`TABLE ${s} does not exist.`);return i};for(let s of t.ACTIONS)if(s.TYPE==="RENAME")this.name(s.ARGUMENT);else if(s.TYPE==="MOVE")this.basename(s.ARGUMENT);else if(s.TYPE==="DROP")e(s.ARGUMENT,s.hasFlag("IF_EXISTS"))?.status("DOWN");else if(s.TYPE==="NEW")(!s.hasFlag("IF_NOT_EXISTS")||!e(s.ARGUMENT.name(),!0))&&this.table(s.ARGUMENT.toJson());else if(s.TYPE==="ALTER"){let r=e(s.REFERENCE,s.hasFlag("IF_EXISTS"));if(!r)continue;r.alter(s.ARGUMENT)}}getAlt(){let t=new ut(this.CONTEXT).name(this.NAME).basename(this.BASENAME);this.$NAME&&this.NAME&&this.$NAME!==this.NAME&&t.addRename(this.$NAME),this.$BASENAME&&this.BASENAME&&this.$BASENAME!==this.BASENAME&&t.addMove(this.$BASENAME);for(let e of this.TABLES)e.status()==="UP"?t.addAlt({name:e.NAME,kind:"TABLE"},s=>s.set(e.getAlt())):e.status()==="DOWN"?t.addDrop({name:[e.BASENAME||this.NAME,e.NAME],kind:"TABLE"}):t.addNew(e.clone());return t}cascadeAlt(){this.status(this.status(),!0);let t=this.dropped()?"DOWN":this.$NAME&&this.$NAME!==this.NAME?"RENAME":null;for(let e of this.TABLES)e.cascadeAlt();return this.altsCascaded=!0,this}toJson(){return{...super.toJson(),tables:this.TABLES.map(t=>t.toJson())}}static fromJson(t,e){if(!["tables"].some(s=>s in e&&!Array.isArray(e[s])))return super.fromJson(t,e,()=>{let s=new this(t);for(let r of e.tables||[])s.table(r);return s})}stringify(){return[...[`CREATE SCHEMA${this.hasFlag("IF_NOT_EXISTS")?" IF NOT EXISTS":""} ${this.autoEsc(this.name())}`],...this.TABLES].join(`;
`)}static parse(t,e,s){let[r,i,a]=/^CREATE\s+DATABASE\s+(IF\s+NOT\s+EXISTS\s+)?(.+)$/i.exec(e)||[];if(!r)return;let[n]=this.parseIdent(t,a.trim(),!0)||[];if(!n)return;let o=new this(t).name(n);return i&&o.withFlag("IF_NOT_EXISTS"),o}};var lt=class extends F{NAME;BASENAME;name(t){return arguments.length?(this.NAME=t,this):this.NAME}basename(t){return arguments.length?(this.BASENAME=t,this):this.BASENAME}toJson(){return{name:this.NAME,basename:this.BASENAME,flags:this.FLAGS}}static fromJson(t,e){if(typeof e?.name=="string")return new this(t).name(e.name).basename(e.basename).withFlag(...e.flags||[])}stringify(){return`DROP TABLE${this.hasFlag("IF_EXISTS")?" IF EXISTS":""} ${this.autoEsc([this.BASENAME,this.NAME].filter(t=>t)).join(".")}${this.hasFlag("CASCADE")?" CASCADE":""}`}static parse(t,e){let[s,r,i,a,n]=/^DROP\s+TABLE\s+(IF\s+EXISTS\s+)?(?:(.+)\s+(CASCADE)$|(.+)$)/i.exec(e)||[];if(!s)return;let[o,u]=this.parseIdent(t,(i||n).trim(),!0)||[];if(!o)return;let l=new this(t).name(o).basename(u);return r&&l.withFlag("IF_EXISTS"),a&&l.withFlag("CASCADE"),l}};var At=class extends F{NAME;name(t){return arguments.length?(this.NAME=t,this):this.NAME}toJson(){return{name:this.NAME,flags:this.FLAGS}}static fromJson(t,e){if(typeof e?.name=="string")return new this(t).name(e.name).withFlag(...e.flags||[])}stringify(){return`DROP SCHEMA${this.hasFlag("IF_EXISTS")?" IF EXISTS":""} ${this.autoEsc(this.NAME)}${this.hasFlag("CASCADE")?" CASCADE":""}`}static parse(t,e){let[s,r,i,a,n]=/^DROP\s+DATABASE\s+(IF\s+EXISTS\s+)?(?:(.+)\s+(CASCADE)$|(.+)$)/i.exec(e)||[];if(!s)return;let[o]=this.parseIdent(t,(i||n).trim(),!0)||[];if(!o)return;let u=new this(t).name(o);return r&&u.withFlag("IF_EXISTS"),a&&u.withFlag("CASCADE"),u}};var Xt=class extends A{CONDITION=null;CONSEQUENCE=null;condition(t){return this.build("CONDITION",[t],I.Types),this}then_(t){return this.build("CONSEQUENCE",[t],I.Types)}toJson(){return{condition:this.CONDITION?.toJson(),consequence:this.CONSEQUENCE?.toJson()}}static fromJson(t,e){if(!(typeof e=="object"&&e&&"condition"in e))return;let s=new this(t);return s.condition(e.condition),s.then_(e.consequence),s}stringify(){return`${this.CONDITION} THEN ${this.CONSEQUENCE}`}static parse(t,e,s){let r=f.split(e,["\\s+THEN\\s+"],{useRegex:"i"});if(r.length!==2)return;let i=new this(t),[a,n]=r.map(o=>s(i,o.trim()));return i.condition(a).then_(n),i}};var Pt=class extends A{BASE_VALUE;WHEN_CLAUSES=[];ELSE_CLAUSE;compare(t){if(this.WHEN_CLAUSES.length||this.ELSE_CLAUSE)throw new Error('A "case" clause must come before any "when" or "else" clauses.');return this.build("BASE_VALUE",[t],I.Types)}when(t){if(this.ELSE_CLAUSE)throw new Error('A "when" clause cannot come after an "else" clause.');return this.build("WHEN_CLAUSES",[t],Xt,"condition"),this.WHEN_CLAUSES[this.WHEN_CLAUSES.length-1]}else(t){if(!this.WHEN_CLAUSES.length)throw new Error('An "else" clause cannot come before "when" clauses.');return this.build("ELSE_CLAUSE",[t],I.Types)}toJson(){return{base_value:this.BASE_VALUE?.toJson(),when_clauses:this.WHEN_CLAUSES.map(t=>t.toJson()),else_clause:this.ELSE_CLAUSE?.toJson(),flags:this.FLAGS}}static fromJson(t,e){if(!Array.isArray(e?.when_clauses))return;let s=new this(t).withFlag(...e.flags||[]);e.base_value&&s.compare(e.base_value);for(let r of e.when_clauses)s.when(r);return e.else_clause&&s.else(e.else_clause),s}stringify(){let t=[];return this.BASE_VALUE&&t.push(this.BASE_VALUE),t.push(`WHEN ${this.WHEN_CLAUSES.join(" WHEN ")}`),this.ELSE_CLAUSE&&t.push("ELSE",this.ELSE_CLAUSE),`CASE ${t.join(" ")} END${this.params.dialect==="mysql"?" CASE":""}`}static parse(t,e,s){let[r,i]=e.match(/^CASE\s+([\s\S]*)\s+END(\s+CASE)?$/i)||[];if(!r)return;let{tokens:[a,...n],matches:o}=f.lex(i,["WHEN","ELSE"],{useRegex:"i"}),u=new this(t);a.trim()&&u.compare(s(u,a.trim()));for(let l of o){let h=n.shift();if(/ELSE/i.test(l))u.else(s(u,h.trim()));else if(/WHEN/i.test(l))u.when(s(u,h.trim(),[Xt]));else throw new Error(`Can't have multiple "${l}" clauses in a CASE construct.`)}return u}static factoryMethods={case:t=>new this(t)}};var ne=class extends A{OPERAND=null;TYPE="";SYNTAX2=!1;cast(t,e,s=!1){return this.TYPE=e,this.SYNTAX2=s,this.build("OPERAND",[t],I.Types)}toJson(){return{operand:this.OPERAND?.toJson(),type:this.TYPE,syntax2:this.SYNTAX2,flags:this.FLAGS}}static fromJson(t,e){if(!e?.operand||!e?.type)return;let s=new this(t).withFlag(...e.flags||[]);return s.cast(e.operand,e.type,e.syntax2),s}stringify(){return this.SYNTAX2?`${this.OPERAND}::${this.TYPE}`:`CAST(${this.OPERAND} AS ${this.TYPE})`}static parse(t,e,s){let r,i,a=!1;if(/^CAST(?:\s+)?\([\s\S]+\)$/i.test(e)){let[,o]=f.split(e,[]);[r,i]=f.split(o.slice(1,-1),["AS"],{useRegex:"i"})}else{if((t?.params?.inputDialect||t?.params?.dialect)==="mysql"||([r,i]=f.split(e,["::"]),!i))return;a=!0}let n=new this(t);return n.cast(s(n,r.trim()),i.trim(),a),n}};var Dt=class extends A{OFFSET;constructor(t,e){super(t),this.OFFSET=parseInt(e)}toJson(){return{offset:this.OFFSET}}static fromJson(t,e){if(typeof e?.offset=="number")return new this(t,e.offset)}stringify(){return this.params.dialect==="mysql"?"?":"$"+this.OFFSET}static parse(t,e){let s=(t?.params?.inputDialect||t?.params?.dialect)==="mysql"?"?":"$",[r,i]=new RegExp(`^\\${s}(\\d)$`).exec(e)||[];if(r)return new this(t,parseInt(i))}};var ht=class extends A{VALUE="";QUOTE="";constructor(t,e,s="'"){super(t),this.VALUE=e,this.QUOTE=s}literal(t){this.VALUE=t}stringify(){let t=this.QUOTE||this.quoteChars[0];return`${t}${this.VALUE.replace(new RegExp(t,"g"),t.repeat(2))}${t}`}toJson(){return{value:this.VALUE}}static fromJson(t,e){if(typeof e?.value=="string")return new this(t,e.value,e.quote)}static parse(t,e){let[s,r]=this.parseText(t,e,!0)||[];if(r)return new this(t,s,r)}static parseText(t,e,s=!1){let r=this.getQuoteChars(t,s),i={};if(!(!(i.quote=r.find(a=>B(e,a,a)))||f.match(e,[" "]).length))return[L(e,i.quote,i.quote).replace(new RegExp(i.quote+i.quote,"g"),i.quote),i.quote]}};var ft=class extends ht{TYPE="";constructor(t,e,s,r){super(t,e,r),this.TYPE=s}object(t){this.VALUE=typeof t=="object"&&t?JSON.stringify(t):t,this.TYPE="OBJECT"}array(t){this.VALUE=Array.isArray(t)?JSON.stringify(t):t,this.TYPE="ARRAY"}toJson(){return{type:this.TYPE,...super.toJson()}}static fromJson(t,e){if(typeof e?.type!="string"||!/OBJECT|ARRAY/i.test(e.type)||!e.value)return;let s=new this(t);return s[e.type.toLowerCase()](e.value),s}stringify(){return`${super.stringify()}`}static parse(t,e){let s=[["{","}"],["[","]"]],r={},[i,a]=this.parseText(t,e)||[];if(a&&!(!(r.braces=s.find(n=>B(e,n[0],n[1])))||f.match(e,[" "]).length))return new this(t,i,r.braces[0]==="{"?"OBJECT":"ARRAY",a)}};var St=class extends A{VALUE=0;constructor(t,e){super(t),this.VALUE=e}toJson(){return{value:this.VALUE,flags:this.FLAGS}}static fromJson(t,e){if(typeof e=="number"||typeof e=="string"&&/^[.\d]+$/.test(e)&&(e=parseFloat(e)))e={value:e};else if(typeof e?.value!="number")return;return new this(t,e.value).withFlag(...e.flags||[])}stringify(){return`${this.VALUE}`}static parse(t,e){if(/^\d+$/.test(e))return new this(t,parseFloat(e))}};var rt=class extends A{static OPERATORS=["->","->>","#>","#>>"];OPERATOR="";LHS=null;RHS=null;path(t,e,s){if(!this.constructor.OPERATORS.includes(e))throw new Error(`Unknown operator: "${e}".`);this.build("LHS",[t],[ft,N]),this.build("RHS",[s],[ft,St,ht]),this.OPERATOR=e}toJson(){return{lhs:this.LHS?.toJson(),rhs:this.RHS?.toJson(),operator:this.OPERATOR,flags:this.FLAGS}}static fromJson(t,e){if(!this.OPERATORS.includes(e?.operator))return;let s=new this(t).withFlag(...e.flags||[]);return s.path(e.lhs,e.operator,e.rhs),s}stringify(){return`${this.LHS} ${this.OPERATOR} ${this.RHS}`}static parse(t,e,s){if((t?.params?.inputDialect||t?.params?.dialect)==="mysql")return;let{tokens:r,matches:i}=f.lex(e,this.OPERATORS,{limit:1});if(!i.length)return;let a=new this(t),n=s(a,r[0],[ft,N]),o=s(a,r[1].trim(),[ft,St,ht]);return a.path(n,i[0],o),a}static factoryMethods={path:(t,e,s,r)=>this.OPERATORS.includes(s)&&new this(t)}};var q=class c extends A{static ARR_RIGHT="~>";static ARR_LEFT="<~";OPERATOR="";LHS=null;RHS=null;UUID=null;get isOutgoing(){return this.OPERATOR===this.constructor.ARR_RIGHT}get isIncoming(){return this.OPERATOR===this.constructor.ARR_LEFT}get uuid(){return this.UUID||(this.UUID=`$path:${(0|Math.random()*9e6).toString(36)}`),this.UUID}path(t,e,s){let r=this.constructor;if(![r.ARR_LEFT,r.ARR_RIGHT].includes(e))throw new Error(`Unknown operator: "${e}".`);this.build("LHS",[t],N),this.build("RHS",[s],[r,rt,N]),this.OPERATOR=e}async eval(){let t=E=>E.columns.find(p=>p.primaryKey)?.name||E.constraints.find(p=>p.type==="PRIMARY_KEY")?.targetColumns[0],e=(E,p)=>E.columns.find(m=>m.name===p.NAME)?.references||E.constraints.find(m=>m.type==="FOREIGN_KEY"&&m.targetColumns.includes(p.NAME)),s=async(E,p)=>{let m=this.rootNode.CONTEXT,d=p||await m.basenameGet(E),T=m.database(d);if(await T.hasTable(E))return await T.describeTable(E)};if(!this.rootNode.CONTEXT)throw new Error("No client API in context.");if(this.isIncoming){if(!(this.RHS instanceof c))throw new Error(`Unterminated path: ${this.RHS}`);let E,p,m,d;if(this.RHS.isIncoming){if(!(this.RHS.RHS instanceof c))throw new Error(`Unterminated path: ${this.RHS.RHS}`);({LHS:E,RHS:d}=this),m=(await d.eval()).lhs.schema,p=N.fromJson(this,m)}else if({LHS:E,RHS:{LHS:p,RHS:d}}=this,m=await s(p.NAME,p.BASENAME),!m)throw new Error(`[${this}]: The implied table ${p} does not exist.`);let T=e(m,E);if(!T)throw new Error(`[${this}]: Table ${p} does not define the implied foreign key: ${E}.`);let _=N.fromJson(this,T.basename?[T.basename,T.targetTable]:T.targetTable),S=await s(_.NAME,_.BASENAME);if(!S)throw new Error(`[${this}]: The implied table ${_} does not exist.`);let g=t(S);if(!g)throw new Error(`[${this}]: Table ${S.name} does not define a primary key.`);return{lhs:{schema:S,primaryKey:g},rhs:{schema:m,foreignKey:E,path:d}}}let r=this.statementNode.TABLES[0]?.EXPR;if(!r)throw new Error("No tables in query.");if(!(r instanceof N))throw new Error(`[${this}]: Base query must not be derived.`);let i=await s(r.NAME,r.BASENAME);if(!i)throw new Error(`[${this}]: The implied table ${r} does not exist.`);let{LHS:a,RHS:n}=this,o=e(i,a);if(!o)throw new Error(`[${this}]: Table ${r} does not define the implied foreign key: ${a}.`);let u=N.fromJson(this,o.basename?[o.basename,o.targetTable]:o.targetTable),l=await s(u.NAME,u.BASENAME||r.BASENAME);if(!l)throw new Error(`[${this}]: The implied table ${u} does not exist.`);let h=t(l);if(!h)throw new Error(`[${this}]: Table ${u} does not define a primary key.`);return{lhs:{schema:i,foreignKey:a},rhs:{schema:l,primaryKey:h,path:n}}}async plot(){if(this.JOINT)return;let t=this.statementNode,e=t.TABLES[0];if(!e)throw new Error("No tables in query.");if(!(e.EXPR instanceof N))throw new Error(`[${this}]: Base query must not be derived.`);let{lhs:s,rhs:r}=await this.eval(),i=s.foreignKey||s.primaryKey,a=r.primaryKey||r.foreignKey;if(s.primaryKey&&s.schema.name.toLowerCase()!==e.EXPR.NAME.toLowerCase())throw new Error(`[${this}]: Cannot resolve incoming path to base table ${e.EXPR}.`);let n=`$view:${[i,r.schema.basename,r.schema.name,a].join(":")}`,o=()=>this.JOINT=t.JOIN_LIST.find(u=>u.ALIAS.NAME===n);if(!o()){let u=["ALIAS","EXPR"].reduce((h,E)=>h||e[E]?.NAME,null),l=`${a}:${(0|Math.random()*9e6).toString(36)}`;t.leftJoin(h=>h.query(E=>E.select(p=>p.name(a).as(l)),E=>E.from([r.schema.basename,r.schema.name]))).with({IS_SMART_JOIN:!0}).as(n).on(h=>h.equals([n,l],[u,i])),o()}this.JOINT.EXPR.select(u=>u.expr(r.path.toJson()).as(this.uuid))}toJson(){return{lhs:this.LHS?.toJson(),rhs:this.RHS?.toJson(),operator:this.OPERATOR,flags:this.FLAGS}}static fromJson(t,e){if(![this.ARR_LEFT,this.ARR_RIGHT].includes(e?.operator))return;let s=new this(t).withFlag(...e.flags||[]);return s.path(e.lhs,e.operator,e.rhs),s}stringify(){return this.JOINT?this.autoEsc([this.JOINT.ALIAS.NAME,this.uuid]).join("."):`${this.LHS} ${this.OPERATOR} ${this.RHS}`}static parse(t,e,s){let{tokens:r,matches:i}=f.lex(e,[this.ARR_LEFT,this.ARR_RIGHT],{limit:1});if(!i.length)return;let a=new this(t),n=s(a,r[0],[N]),o=s(a,r[1],i[0]===this.ARR_LEFT?[this]:[this,rt,N]);return a.path(n,i[0],o),a}static factoryMethods={path:(t,e,s,r)=>[this.ARR_LEFT,this.ARR_RIGHT].includes(s)&&new this(t)}};var Ft=class extends A{CRITERIA=[];criterion(...t){return this.build("CRITERIA",t,I.Types)}stringify(){return this.CRITERIA.map(t=>t.stringify()).join(",")}toJson(){return{criteria:this.CRITERIA.map(t=>t.toJson()),flags:this.FLAGS}}static fromJson(t,e){if(!Array.isArray(e?.criteria))return;let s=new this(t).withFlag(...e.flags||[]);return s.criterion(...e.criteria),s}static parse(t,e,s){let[r,i]=e.match(new RegExp(`^${this.regex}([\\s\\S]*)$`,"i"))||[];if(!r)return;let a=new this(t);for(let n of f.split(i.trim(),[","]))a.criterion(s(a,n));return a}static regex="GROUP\\s+BY"};var qt=class extends Ft{withRollup(){return this.withFlag("WITH_ROLLUP")}stringify(){return["GROUP BY",super.stringify(),...this.FLAGS.map(t=>t.replace(/_/g," "))].join(" ")}static parse(t,e,s){let{tokens:[r],matches:i}=Lexer.lex(e,["\\s+WITH\\s+ROLLUP$"],{useRegex:"i"}),a=super.parse(t,r,s);if(a)return i.length&&a.withFlag("WITH_ROLLUP"),a}};var ae=class extends A{CRITERIA=[];criterion(...t){return this.build("CRITERIA",t,I.Types)}toJson(){return{criteria:this.CRITERIA.map(t=>t.toJson()),flags:this.FLAGS}}static fromJson(t,e){if(!Array.isArray(e?.criteria))return;let s=new this(t).withFlag(...e.flags||[]);return s.criterion(...e.criteria),s}stringify(){return this.CRITERIA.map(t=>[t,...t.FLAGS].join(" ")).join(",")}static parse(t,e,s){let[r,i]=e.match(new RegExp(`^${this.regex}([\\s\\S]*)$`,"i"))||[];if(!r)return;let a=new this(t);for(let n of f.split(i.trim(),[","])){let[,o,u]=/([\s\S]+)\s+(ASC|DESC)$/i.exec(n)||[,n];a.criterion(s(a,o).withFlag(u))}return a}static regex="ORDER\\s+BY"};var P=class extends ae{withRollup(){return this.withFlag("WITH_ROLLUP")}stringify(){return["ORDER BY",super.stringify(),...this.FLAGS.map(t=>t.replace(/_/g," "))].join(" ")}static parse(t,e,s){let{tokens:[r],matches:i}=f.lex(e,["\\s+WITH\\s+ROLLUP$"],{useRegex:"i"}),a=super.parse(t,r.trim(),s);if(a)return i.length&&a.withFlag("WITH_ROLLUP"),a}};var Vt=class extends Ft{stringify(){return["PARTITION BY",super.stringify()].join(" ")}static regex="PARTITION\\s+BY"};var Nt=class extends A{NAME;WINDOW_REF;PARTITION_BY_CLAUSE;ORDER_BY_CLAUSE;name(t){return this.NAME=t,this}existing(t){return this.WINDOW_REF=t,this}extends(t){return this.WINDOW_REF=t,this}partitionBy(...t){if(this.WINDOW_REF)throw new Error("The PARTITION BY clause is not allowed when inheriting from a base window.");return this.build("PARTITION_BY_CLAUSE",t,Vt,"criterion")}orderBy(...t){return this.build("ORDER_BY_CLAUSE",t,P,"criterion")}toJson(){return{name:this.NAME,window_ref:this.WINDOW_REF,partition_by_clause:this.PARTITION_BY_CLAUSE?.toJson(),order_by_clause:this.ORDER_BY_CLAUSE?.toJson()}}static fromJson(t,e){if(typeof e=="string")e={window_ref:e};else if(!(typeof e=="object"&&e)||!["name","window_ref","partition_by_clause","order_by_clause"].some(r=>r in e))return;let s=new this(t);return e.name&&s.name(e.name),e.window_ref&&s.extends(e.window_ref),e.partition_by_clause&&s.partitionBy(e.partition_by_clause),e.order_by_clause&&s.orderBy(e.order_by_clause),s}stringify(){let t=[];return!this.NAME&&this.WINDOW_REF&&!this.PARTITION_BY_CLAUSE&&!this.ORDER_BY_CLAUSE?t.push(this.WINDOW_REF):(this.NAME&&t.push(`${this.NAME} AS `),t.push(`(${[this.WINDOW_REF,this.PARTITION_BY_CLAUSE,this.ORDER_BY_CLAUSE].filter(e=>e).join(" ")})`)),t.join("")}static parse(t,e,s){let r=new this(t),i=async o=>{let{tokens:[u,...l],matches:h}=f.split(L(o.trim(),"(",")"),["PARTITION\\s+BY","ORDER\\s+BY"],{useRegex:"i",preserveDelims:!0});u.trim()&&r.extends(u.trim());for(let E of h){if(/PARTITION\s+BY/i.test(E)){r.partitionBy(s(r,l.shift().trim(),[Vt]));continue}r.orderBy(s(r,l.shift().trim(),[P]))}},a=e.endsWith(")");if(a&&!e.startsWith("(")){let[o,u]=spec.split(new RegExp(" AS ","i"));r.name(o.trim()),i(u)}else a?i(e):r.existing(e);return r}static regex="WINDOW|OVER"};var kt=class extends A{WINDOWS_LIST=[];define(...t){return this.build("WINDOWS_LIST",t,Nt)}toJson(){return{window_list:this.WINDOWS_LIST.map(t=>t.toJson())}}static fromJson(t,e){if(!Array.isArray(e?.window_list))return;let s=new this(t);return s.define(...e.window_list),s}stringify(){return`WINDOW ${this.WINDOWS_LIST.join(",")}`}static parse(t,e,s){let[r,i]=e.match(new RegExp(`^${this.regex}([\\s\\S]*)$`,"i"))||[];if(!r)return;let a=new this(t);for(let n of f.split(i,[","]))a.define(s(a,n.trim(),[Window]));return a}static regex="WINDOW"};var Jt=class extends A{$EXPR;ALIAS;CLAUSED;get NAME(){return this.$EXPR?.NAME}get BASENAME(){return this.$EXPR?.BASENAME}get EXPR(){return this.$EXPR?.EXPR||this.$EXPR}name(t){return this.build("$EXPR",[t],N,"name"),this}query(...t){return this.build("$EXPR",t,V,"query"),this}expr(t){return this.build("$EXPR",[t],this.constructor.exprTypes),this}as(t,e=!0){return this.build("ALIAS",[t],N),this.CLAUSED=e,this}toJson(){return{expr:this.$EXPR?.toJson(),alias:this.ALIAS?.toJson(),claused:this.CLAUSED,flags:this.FLAGS}}static fromJson(t,e){let s=new this(t).withFlag(...e.flags||[]);return e?.expr?(s.expr(e.expr),e.alias&&s.as(e.alias,e.claused)):e&&s.expr(e),s}stringify(){let t=this.ALIAS||this.$EXPR instanceof q&&this.$EXPR.JOINT&&this.autoEsc(this.$EXPR.clone().stringify());return[this.$EXPR,this.CLAUSED?"AS":"",t].filter(e=>e).join(" ")}static parse(t,e,s){let r=new this(t),i=this.getEscChar(t,!0),[,a,n,o,,u]=new RegExp(`^([\\s\\S]+?)(?:(\\s+AS\\s+|(?<!(?:~>|<~))\\s+)(?:([\\w]+)|(${i})((?:\\4\\4|[^\\4])+)\\4))?$`,"i").exec(e.trim())||[],l,h=o||u;if(h&&!n?.trim()&&!a.trim().endsWith(")")){try{l=s(r,a,this.exprTypes)}catch{}l||(h=o=u=null,a=e)}if(l||(l=s(r,a,this.exprTypes)),r.expr(l),h){let E=o||this.autoUnesc(r,u),p=!!n?.trim();r.as(E,p)}return r}static get exprTypes(){return I.Types}};var Tt=class extends A{NAME="";ARGS=[];call(t,...e){return this.NAME=t,this.build("ARGS",e,I.Types)}toJson(){return{name:this.NAME,args:this.ARGS.map(t=>t.toJson()),flags:this.FLAGS}}static fromJson(t,e){if(typeof e?.name!="string"||!Array.isArray(e.args))return;let s=new this(t).withFlag(...e.flags||[]);return s.call(e.name,...e.args),s}stringify(){return`${this.NAME.toUpperCase()}(${this.ARGS.join(", ")})`}static parse(t,e,s){if(!e.endsWith(")")||f.match(e,[" "]).length)return;let[,r,i=""]=/^(\w+)\(([\s\S]+)?\)$/i.exec(e),a=new this(t);return a.call(r,...f.split(i,[","]).map(n=>s(a,n.trim()))),a}};var mt=class extends Tt{ORDER_BY_CLAUSE;OVER_CLAUSE;call(...t){return super.call(...t),this}orderBy(...t){return this.build("ORDER_BY_CLAUSE",t,P,"criterion"),this}over(t){return t||(t={name:""}),this.build("OVER_CLAUSE",[t],Nt),this.OVER_CLAUSE}toJson(){return{...super.toJson(),order_by_clause:this.ORDER_BY_CLAUSE?.toJson(),over_clause:this.OVER_CLAUSE?.toJson()}}static fromJson(t,e){let s=super.fromJson(t,e);if(s)return this.names.flat().includes(s.NAME.toUpperCase())&&(e.order_by_clause&&s.orderBy(e.order_by_clause),e.over_clause&&s.over(e.over_clause)),s}stringify(){return`${this.NAME.toUpperCase()}(${[...this.FLAGS,this.ARGS.join(","),this.ORDER_BY_CLAUSE].filter(e=>e).join(" ")})`+(this.OVER_CLAUSE?` OVER ${this.OVER_CLAUSE}`:"")}static parse(t,e,s){let[r,i]=f.split(e,["OVER\\s+"],{useRegex:"i"}).map(E=>E.trim());if(!r.endsWith(")")||f.match(r,[" "]).length)return;let[,a,n,o=""]=/^(\w+)\((?:\s+)?(?:(ALL|DISTINCT)\s+)?([\s\S]+)?\)$/i.exec(r);if(!this.names.flat().includes(a.toUpperCase()))return;let[,u,l]=/^([\s\S]+)(?:\s+(ORDER\s+BY\s+.+))$/i.exec(o)||[,o],h=super.parse(t,`${a}(${u})`,s);return n&&h.withFlag(n),l?h.orderBy(s(h,l,[P])):i&&h.over(s(h,i,[Nt])),h}static factoryMethods={call:(t,e,...s)=>this.names.flat().includes(e?.toUpperCase())&&new this(t)};static names=[["AVG","BIT_AND","BIT_OR","BIT_XOR","COUNT","JSON_ARRAYAGG","JSON_OBJECTAGG","MAX","MIN","STDDEV_POP","STDDEV","STD","STDDEV_SAMP","SUM","VAR_POP","VARIANCE","VAR_SAMP","GROUP_CONCAT","GROUP_CONCAT_WS"],["CUME_DIST","DENSE_RANK","FIRST_VALUE","LAG","LAST_VALUE","LEAD","NTH_VALUE","NTLE","PERCENT_RANK","RANK","ROW_NUMBER"],["ANY_VALUE","COLUMN","COLUMNS","GROUPING"]]};var Qt=class extends Jt{path(t,e,s){return this.build("$EXPR",[t,e,s],rt.OPERATORS.includes(e)?rt:q,"path"),this}call(t,...e){return this.build("$EXPR",[t,...e],mt.names.flat().includes(t.toUpperCase())?mt:Tt,"call"),this}case(...t){return this.build("$EXPR",t,Pt),this}};var x=class extends Jt{static get exprTypes(){return[V,N]}};var it=class c extends F{SELECT_LIST=[];FROM_LIST=[];JOIN_LIST=[];WHERE_CLAUSE=null;GROUP_BY_CLAUSE=null;HAVING_CLAUSE=null;WINDOW_CLAUSE=null;ORDER_BY_CLAUSE=null;OFFSET_CLAUSE=null;LIMIT_CLAUSE=null;get TABLES(){return this.FROM_LIST}AGGRS=[];PATHS=[];VARS=[];SUBQUERIES=[];select(...t){return this.build("SELECT_LIST",t,Qt)}from(...t){return this.build("FROM_LIST",t,x),this.FROM_LIST[this.FROM_LIST.length-1]}join(t){return this.build("JOIN_LIST",[t],w,"full")}leftJoin(t){return this.build("JOIN_LIST",[t],w,"left")}rightJoin(t){return this.build("JOIN_LIST",[t],w,"right")}innerJoin(t){return this.build("JOIN_LIST",[t],w,"inner")}crossJoin(t){return this.build("JOIN_LIST",[t],w,"cross")}where(...t){return this.build("WHERE_CLAUSE",t,y,"and")}groupBy(...t){return this.build("GROUP_BY_CLAUSE",t,qt,"criterion"),this.GROUP_BY_CLAUSE}having(...t){return this.build("HAVING_CLAUSE",t,y,"and")}window(...t){return this.build("WINDOW_CLAUSE",t,kt,"define")}orderBy(...t){return this.build("ORDER_BY_CLAUSE",t,P,"criterion"),this.ORDER_BY_CLAUSE}offset(t){if(typeof t!="number")throw new Error("Offsets must be of type number.");this.OFFSET_CLAUSE=t}limit(...t){if(!t.every(e=>typeof e=="number"))throw new Error("Limits must be of type number.");this.LIMIT_CLAUSE=t}connectedNodeCallback(t){t instanceof mt&&this.AGGRS.push(t),t instanceof q&&!(t.CONTEXT instanceof q)&&this.PATHS.push(t),t instanceof Dt&&this.VARS.push(t),t instanceof c&&this.SUBQUERIES.push(t)}get expandable(){return this.PATHS.length>0||this.SUBQUERIES.some(t=>t.expandable)}async expand(t=!1){let e=t?this:this.clone();if(!e.expandable)return e;for(let s of e.PATHS)await s.plot();for(let s of e.SUBQUERIES)await s.expand(!0);return e}toJson(){return{select_list:this.SELECT_LIST.map(t=>t.toJson()),from_list:this.FROM_LIST.map(t=>t.toJson()),join_list:this.JOIN_LIST.map(t=>t.toJson()),where_clause:this.WHERE_CLAUSE?.toJson(),group_by_clause:this.GROUP_BY_CLAUSE?.toJson(),having_clause:this.HAVING_CLAUSE?.toJson(),window_clause:this.WINDOW_CLAUSE?.toJson(),order_by_clause:this.ORDER_BY_CLAUSE?.toJson(),offset_clause:this.OFFSET_CLAUSE,limit_clause:this.LIMIT_CLAUSE,flags:this.FLAGS}}static fromJson(t,e){if(!Array.isArray(e?.select_list))return;let s=new this(t).withFlag(...e.flags||[]);return s.select(...e.select_list),e.from_list?.length&&s.from(...e.from_list),e.join_list?.length&&s.join(...e.join_list),e.where_clause&&s.where(e.where_clause),e.group_by_clause&&s.groupBy(e.group_by_clause),e.having_clause&&s.having(e.having_clause),e.window_clause&&s.window(e.window_clause),e.order_by_clause&&s.orderBy(e.order_by_clause),e.offset_clause&&s.offset(e.offset_clause),e.limit_clause&&s.limit(e.limit_clause),s}stringify(t={}){let e=["SELECT"];return this.FLAGS.length&&e.push(this.FLAGS.map(s=>s.replace(/_/g," "))),e.push(this.SELECT_LIST.join(", ")),this.FROM_LIST.length&&e.push("FROM",this.FROM_LIST.join(", ")),this.JOIN_LIST.length&&e.push(...this.JOIN_LIST),this.WHERE_CLAUSE&&e.push("WHERE",this.WHERE_CLAUSE),this.GROUP_BY_CLAUSE&&e.push(this.GROUP_BY_CLAUSE),this.HAVING_CLAUSE&&e.push("HAVING",this.HAVING_CLAUSE),this.WINDOW_CLAUSE&&e.push(this.WINDOW_CLAUSE),this.ORDER_BY_CLAUSE&&e.push(this.ORDER_BY_CLAUSE),this.OFFSET_CLAUSE&&e.push("OFFSET",this.OFFSET_CLAUSE),this.LIMIT_CLAUSE&&e.push("LIMIT",(Array.isArray(this.LIMIT_CLAUSE)?this.LIMIT_CLAUSE:[this.LIMIT_CLAUSE]).join(",")),e.join(" ")}static parse(t,e,s){let[r,i,a,n]=/^SELECT\s+(?:(WITH\s+UAC)\s+)?(ALL|DISTINCT)?([\s\S]+)$/i.exec(e)||[];if(!r)return;let o=new this(t);i&&o.withFlag("WITH_UAC"),a&&o.withFlag(a);let u=this.mySubstitutePlaceholders(o,n.trim()),l={from:{backtest:"^(?!.*\\s+DISTINCT\\s+$)",test:"FROM"},join:w,where:"WHERE",groupBy:qt,having:"HAVING",window:kt,orderBy:P,offset:"OFFSET",limit:"LIMIT"},{tokens:[h,...E],matches:p}=f.lex(u,Object.values(l).map(m=>typeof m=="string"||m.test?m:m.regex),{useRegex:"i"});for(let m of f.split(h,[","])){let d=s(o,m.trim(),[Qt]);o.select(d)}for(let m of p){let d=m.replace(/\s+/g,""),T=Object.keys(l).find(_=>new RegExp(_,"i").test(d));if(T==="from")for(let _ of f.split(E.shift(),[","])){let S=s(o,_.trim(),[x]);o.from(S)}else if(["where","having"].includes(T)){let _=s(o,E.shift().trim(),[y,D]);o[T](_)}else if(["offset","limit"].includes(T)){let _=E.shift().split(",").map(S=>parseInt(S.trim()));o[T](..._)}else{let _=s(o,`${m} ${E.shift().trim()}`,[l[T]]);o[T](_)}}return o}};var V=class extends A{$EXPR;constructor(t,e){super(t),this.$EXPR=e}get NAME(){return this.$EXPR?.NAME}get BASENAME(){return this.$EXPR?.BASENAME}get EXPR(){return this.$EXPR?.EXPR||this.$EXPR}query(...t){return this.build("$EXPR",t,it),this.$EXPR}expr(...t){return this.build("$EXPR",t,[it,...I.Types]),this.$EXPR}toJson(){return{expr:this.$EXPR?.toJson(),flags:this.FLAGS}}static fromJson(t,e){if(!e?.expr||Object.keys(e).length!==(e.flags?2:1))return;let s=new this(t).withFlag(...e.flags||[]);return s.expr(e.expr),s}stringify(){return"("+this.$EXPR.stringify()+")"}static parse(t,e,s){if(!(!B(e,"(",")")||f.match(e,[" "]).length&&f.split(e,[]).length===2))return new this(t,s(t,L(e,"(",")"),[it,...I.Types]))}};var oe=class extends A{OPERATOR="";OPERANDS=[];constructor(t,e,...s){super(t),this.OPERATOR=e,this.OPERANDS=s}calc(t,...e){return this.OPERATOR&&this.OPERATOR!==t?new this.constructor(this).calc(t,this,...e):(this.OPERATOR=t,this.build("OPERANDS",e,I.Types),this)}sum(...t){return this.calc("+",...t)}sub(...t){return this.calc("-",...t)}div(...t){return this.calc("/",...t)}times(...t){return this.calc("*",...t)}toJson(){return{operator:this.OPERATOR,operands:this.OPERANDS.map(t=>t.toJson()),flags:this.FLAGS}}static fromJson(t,e){if(typeof e?.operator!="string"||!/\+|\-|\*|\//.test(e.operator)||!Array.isArray(e.operands))return;let s=new this(t).withFlag(...e.flags||[]);return s.calc(e.operator,...e.operands),s}stringify(){return this.OPERANDS.join(` ${this.OPERATOR} `)}static parse(t,e,s){for(let r of["\\*","\\/","\\+","\\-"]){let{tokens:i,matches:a}=f.lex(e,[`(\\s+)?${r}(\\s+)?`],{useRegex:"i"});if(!(i.filter(n=>n.trim()).length<2))return new this(t,a.pop().trim(),...i.map(n=>s(t,n.trim())))}}};var ce=class extends A{STRINGS=[];join(...t){return this.build("STRINGS",t,I.Types)}toJson(){return{strings:this.STRINGS.map(t=>t.toJson()),flags:this.FLAGS}}static fromJson(t,e){if(!Array.isArray(e?.strings))return;let s=new this(t).withFlag(...e.flags||[]);return s.join(...e.strings),s}stringify(){return this.STRINGS.join(" || ")}static parse(t,e,s){if((t?.params?.inputDialect||t?.params?.dialect)==="mysql")return;let r=f.split(e,["||"]);if(r.length<2)return;let i=new this(t);return i.join(...r.map(a=>s(i,a.trim()))),i}};var ue=class extends A{VALUE;constructor(t,e){super(t),this.VALUE=e}true(){this.VALUE=!0}false(){this.VALUE=!1}null(){this.VALUE=null}toJson(){return this.VALUE}static fromJson(t,e){if([!0,!1,null].includes(e))return new this(t,e)}stringify(){return`${this.VALUE}`}static parse(t,e){if(/^(TRUE|FALSE|NULL)$/i.test(e))return new this(t,JSON.parse(e.toLowerCase()))}};var I=class{static cast(t,e,s=this.Types){if(typeof e=="function"){if(s.length===1){let a=new s[0](t);return e(a),a}let r,i=a=>(...n)=>{let o=s.reduce((u,l)=>u||(l.factoryMethods?a in l.factoryMethods&&l.factoryMethods[a](t,...n):a in l.prototype&&new l(t)),null);if(!o)throw new Error(`Unknow method: ${a}()`);if(r=o,o[a])return o[a](...n);for(let u of n)u(o)};return e(new Proxy({},{get:(a,n)=>i(n)})),r}return this.fromJson(t,e,s)}static fromJson(t,e,s=this.Types){let r=s.reduce((i,a)=>i||(e instanceof a?e:a.fromJson(t,e)),null);if(!r)throw new Error("");return r}static parse(t,e,s){return s(t,e,this.Types)}static get Types(){return[V,Pt,ce,y,q,rt,D,oe,ne,mt,Tt,ft,ht,St,ue,Dt,N]}};var D=class extends A{OPERATOR="";OPERANDS=[];constructor(t,e,...s){super(t),this.OPERATOR=e,this.OPERANDS=s}assert(t,...e){return this.OPERATOR&&this.OPERANDS.splice(0),this.OPERATOR=t,this.build("OPERANDS",e,I.Types),this}equals(...t){return this.assert("=",...t)}eq(...t){return this.equal(...t)}notEqual(...t){return this.assert("<>",...t)}notEq(...t){return this.notEqual(...t)}lesserThan(...t){return this.assert("<",...t)}lt(...t){return this.lesserThan(...t)}lessThanOrEqual(...t){return this.assert("<=",...t)}ltOrEq(...t){return this.lessThanOrEqual(...t)}greaterThan(...t){return this.assert(">",...t)}gt(...t){return this.greaterThan(...t)}greaterThanOrEqual(...t){return this.assert(">=",...t)}gtOrEq(...t){return this.greaterThanOrEqual(...t)}in(...t){return this.assert("IN",...t)}any(...t){return this.assert("ANY",...t)}like(...t){return this.assert("LIKE",...t)}isNull(...t){return this.assert("IS NULL",...t)}isNotNull(...t){return this.assert("IS NOT NULL",...t)}isTrue(...t){return this.assert("IS TRUE",...t)}isNotTrue(...t){return this.assert("IS NOT TRUE",...t)}isFalse(...t){return this.assert("IS FALSE",...t)}isNotFalse(...t){return this.assert("IS NOT FALSE",...t)}isUnknow(...t){return this.assert("IS UNKNOWN",...t)}isNotUnknow(...t){return this.assert("IS NOT UNKNOWN",...t)}isDistinctFrom(...t){return this.assert("IS DISTINCT FROM",...t)}isNotDistinctFrom(...t){return this.assert("IS NOT DISTINCT FROM",...t)}isBetween(...t){return this.assert("IS BETWEEN",...t)}isNotBetween(...t){return this.assert("IS NOT BETWEEN",...t)}isBetweenSymmetric(...t){return this.assert("IS BETWEEN SYMMETRIC",...t)}isNotBetweenSymmetric(...t){return this.assert("IS NOT BETWEEN SYMMETRIC",...t)}and(...t){return new y(this,"AND").and(this,...t)}or(...t){return new y(this,"OR").or(this,...t)}toJson(){return{operator:this.OPERATOR,operands:this.OPERANDS.map(t=>t.toJson()),flags:this.FLAGS}}static fromJson(t,e){if(!Array.isArray(e?.operands)||typeof e?.operator!="string"||!this.regexes.some(r=>new RegExp(r.regex||r.test||r).test(` ${e.operator} `)))return;let s=new this(t).withFlag(...e.flags||[]);return s.assert(e.operator,...e.operands),s}stringify(){let t=this.OPERANDS.slice(0),e=[t.shift(),this.OPERATOR.toUpperCase()],s=t;return this.OPERATOR==="IN"?e.push(`(${s.join(",")})`):/BETWEEN/i.test(this.OPERATOR)?e.push(`(${s.join(" AND ")})`):e.push(`${s.join(" ")}`),e.filter(r=>r).join(" ")}static parse(t,e,s){let{tokens:[r,i=""],matches:[a]}=f.lex(e,this.regexes,{useRegex:"i"});if(!a)return;let n=a.trim().toUpperCase(),o=[r];return n==="IN"?o.push(...f.split(L(i.trim(),"(",")"),[","])):/BETWEEN/.test(n)?o.push(...f.split(i,[" AND "])):i&&o.push(i),new this(t,n,...o.map(u=>s(t,u.trim())))}static regexes=[{test:"<(?!~)"},{backtest:"^(?!.*~$)",test:">",regex:"(?<!~)>"},"((\\s+(?:NOT\\s+)?IS\\s+(?:NOT\\s+)?(TRUE|FALSE|NULL|UNKNOWN|DISTINCT\\s+FROM\\s+))|\\s+(ISNULL|NOTNULL|IN|ANY|LIKE|(?:NOT\\s+)?BETWEEN(?:\\s+SYMMETRIC)?)\\s+|(?:\\s+)?(=|<=|>=|!=|<>)(?:\\s+)?)"]};var y=class c extends A{LOGIC="";ASSERTIONS=[];constructor(t,e){super(t),this.LOGIC=e}and(...t){return this.LOGIC==="OR"?new this.constructor(this).and(this,...t):(this.LOGIC="AND",this.build("ASSERTIONS",t,[c,D,V]),this)}or(...t){return this.LOGIC==="AND"?new this.constructor(this).or(this,...t):(this.LOGIC="OR",this.build("ASSERTIONS",t,[c,D,V]),this)}toJson(){return{logic:this.LOGIC,assertions:this.ASSERTIONS.map(t=>t.toJson()),flags:this.FLAGS}}static fromJson(t,e){if(typeof e?.logic!="string"||!/AND|OR/i.test(e.logic)||!Array.isArray(e.assertions))return;let s=new this(t).withFlag(...e.flags||[]);return s[e.logic.toLowerCase()](...e.assertions),s}stringify(){return this.ASSERTIONS.map(t=>t instanceof c?`(${t.stringify()})`:t.stringify()).join(" "+this.LOGIC+" ")}static parse(t,e,s){for(let r of["AND","OR"]){let i=f.split(e,[`\\s+${r}\\s+`],{useRegex:"i"});if(i.length>1){let a=new this(t,r);for(let n of i)a[r.toLowerCase()](s(a,n));return a}}}};var w=class extends x{TYPE="";CORRELATION=null;full(t){return this.TYPE="JOIN",this.expr(t),this}left(t){return this.TYPE="LEFT_JOIN",this.expr(t),this}right(t){return this.TYPE="RIGHT_JOIN",this.expr(t),this}inner(t){return this.TYPE="INNER_JOIN",this.expr(t),this}cross(t){return this.TYPE="CROSS_JOIN",this.expr(t),this}on(...t){return this.build("CORRELATION",t,y,"and")}using(t){return this.build("CORRELATION",[t],N)}toJson(){return{type:this.TYPE,correlation:this.CORRELATION?.toJson(),...super.toJson()}}static fromJson(t,e){let s=super.fromJson(t,e);if(!(!s||!e.type))return e?.expr&&e.type&&(s.TYPE=e.type),e?.expr&&e.correlation&&s.build("CORRELATION",[e.correlation],[N,y]),s}stringify(){return[this.TYPE?.replace(/_/," ").toUpperCase()||"JOIN",super.stringify(),this.CORRELATION instanceof N?`USING ${this.CORRELATION}`:`ON ${this.CORRELATION}`].filter(t=>t).join(" ")}static parse(t,e,s){let[r,i,a]=e.match(new RegExp(`^${this.regex}([\\s\\S]*)$`,"i"))||[];if(!r)return;let{tokens:[n,o],matches:u}=f.lex(a,["\\s+(?:ON|USING)\\s+"],{useRegex:"i"}),l=super.parse(t,n.trim(),s);return l.TYPE=i.trim().toUpperCase()+"_JOIN",/USING/i.test(u[0])?l.using(s(l,o.trim(),[N])):/ON/i.test(u[0])&&l.on(s(l,o.trim(),[y,D])),l}static regex="(INNER\\s+|CROSS\\s+|(?:LEFT|RIGHT)(?:\\s+OUTER)?\\s+)?JOIN"};var le=class extends F{DELETE_LIST=[];FROM_LIST=[];USING_LIST=[];JOIN_LIST=[];WHERE_CLAUSE=null;ORDER_BY_CLAUSE=null;LIMIT_CLAUSE=null;get TABLES(){return this.USING_LIST.length?this.USING_LIST:this.FROM_LIST}delete(...t){return this.build("DELETE_LIST",t,N)}from(...t){return this.build("FROM_LIST",t,[N,x])}using(...t){return this.build("USING_LIST",t,x)}join(t){return this.build("JOIN_LIST",[t],w,"full")}leftJoin(t){return this.build("JOIN_LIST",[t],w,"left")}rightJoin(t){return this.build("JOIN_LIST",[t],w,"right")}innerJoin(t){return this.build("JOIN_LIST",[t],w,"inner")}crossJoin(t){return this.build("JOIN_LIST",[t],w,"cross")}where(...t){return this.build("WHERE_CLAUSE",t,y,"and")}orderBy(...t){return this.build("ORDER_BY_CLAUSE",t,P,"criterion"),this.ORDER_BY_CLAUSE}limit(...t){if(!t.every(e=>typeof e=="number"))throw new Error("Limits must be of type number.");this.LIMIT_CLAUSE=t}toJson(){return{delete_list:this.DELETE_LIST.map(t=>t.toJson()),from_list:this.FROM_LIST.map(t=>t.toJson()),using_list:this.USING_LIST.map(t=>t.toJson()),join_list:this.JOIN_LIST.map(t=>t.toJson()),where_clause:this.WHERE_CLAUSE?.toJson(),order_by_clause:this.ORDER_BY_CLAUSE?.toJson(),limit_clause:this.LIMIT_CLAUSE,flags:this.FLAGS}}static fromJson(t,e){if(!Array.isArray(e?.from_list))return;let s=new this(t).withFlag(...e.flags||[]);return e.delete_list?.length&&s.delete(...e.delete_list),s.from(...e.from_list),e.using_list?.length&&s.using(...e.using_list),e.join_list?.length&&s.join(...e.join_list),e.where_clause&&s.where(e.where_clause),e.order_by_clause&&s.orderBy(e.order_by_clause),e.limit_clause&&s.limit(e.limit_clause),s}stringify(){let t=["DELETE"];return this.FLAGS.length&&t.push(this.FLAGS.map(e=>e.replace(/_/g," "))),this.DELETE_LIST.length&&t.push(this.DELETE_LIST.join(", ")),t.push("FROM",this.FROM_LIST.join(", ")),this.USING_LIST.length&&t.push("USING",this.USING_LIST.join(", ")),this.JOIN_LIST.length&&t.push(...this.JOIN_LIST),this.WHERE_CLAUSE&&t.push("WHERE",this.WHERE_CLAUSE),this.ORDER_BY_CLAUSE&&t.push(this.ORDER_BY_CLAUSE),this.LIMIT_CLAUSE&&t.push("LIMIT",this.LIMIT_CLAUSE),t.join(" ")}static parse(t,e,s){let[r,i,a,n]=/^DELETE(\s+WITH\s+UAC)?(?:\s+(IGNORE))?([\s\S]+)$/i.exec(e.trim())||[];if(!r)return;let o=new this(t);i&&o.withFlag("WITH_UAC"),a&&o.withFlag(a);let u=this.mySubstitutePlaceholders(o,n.trim()),l={from:{backtest:"^(?!.*\\s+DISTINCT\\s+$)",test:"FROM"},using:{backtest:"^(?!.*\\s+JOIN\\s+)",test:"USING"},join:w,where:"WHERE",orderBy:P,limit:"LIMIT"},{tokens:[h,...E],matches:p}=f.lex(u,Object.values(l).map(m=>typeof m=="string"||m.test?m:m.regex),{useRegex:"i"});for(let m of f.split(h,[","])){let d=s(o,m.trim(),[N]);o.delete(d)}for(let m of p){let d=m.replace(/\s+/g,""),T=Object.keys(l).find(_=>new RegExp(_,"i").test(d));if(["from","using"].includes(T))for(let _ of f.split(E.shift(),[","])){let S=T==="from"&&p.some(C=>C.toLowerCase()==="using")?N:x,g=s(o,_.trim(),[S]);o[T](g)}else if(T==="where"){let _=s(o,E.shift().trim(),[y,D]);o.where(_)}else if(T==="limit")o.limit(parseInt(E.shift().trim()));else{let _=s(o,`${m} ${E.shift().trim()}`,[l[T]]);o[T](_)}}return o}};var nt=class extends A{ENTRIES=[];set(t,e){return Array.isArray(t)?t=t.map(s=>s instanceof A?s:N.fromJson(this,s)):t instanceof A||(t=N.fromJson(this,t)),Array.isArray(e)?e=e.map(s=>s instanceof A?s:I.cast(this,s)):e instanceof A||(e=I.cast(this,e)),this.ENTRIES.push([t,e]),this}toJson(){return{entries:this.ENTRIES.map(([t,e])=>(Array.isArray(t)?t=t.map(s=>s.toJson()):t=t.toJson(),Array.isArray(e)?e=e.map(s=>s.toJson()):e=e.toJson(),[t,e]))}}static fromJson(t,e){if(!Array.isArray(e?.entries))return;let s=new this(t);for(let[r,i]of e.entries)s.set(r,i);return s}stringify(){return`
	${this.ENTRIES.map(([t,e])=>(Array.isArray(t)&&(t=`(${t.join(", ")})`),Array.isArray(e)&&(e=`(${e.join(", ")})`),`${t} = ${e}`)).join(`,
	`)}`}static parse(t,e,s){let r=new this(t);for(let i of f.split(e,[","])){let[a,n]=f.split(i,["="]).map(o=>o.trim()).filter(o=>o);if(!n)return;if(B(a,"(",")")){let o=f.split(L(a,"(",")"),[","]).map(l=>s(r,l.trim(),[N]));if(!B(n,"(",")"))return;let u=/^\((\s+)?SELECT\s+/i.test(n)?s(r,n):f.split(L(n,"(",")"),[","]).map(l=>s(r,l.trim()));r.set(o,u)}else{let o=s(r,a),u=s(r,n);r.set(o,u)}}return r}};var zt=class extends nt{WHERE_CLAUSE=null;where(...t){return this.build("WHERE_CLAUSE",t,y,"and")}toJson(){return{...super.toJson(),where_clause:this.WHERE_CLAUSE?.toJson()}}static fromJson(t,e){let s=super.fromJson(t,e);if(s)return e.where_clause&&s.where(e.where_clause),s}stringify(){let t=[];return this.params.dialect==="mysql"?t.push("ON DUPLICATE KEY UPDATE"):t.push(`ON CONFLICT ${this.ENTRIES.length?"DO UPDATE SET":"DO NOTHING"}`),t.push(super.stringify()),this.WHERE_CLAUSE&&t.push("WHERE",this.WHERE_CLAUSE),t.join(" ")}static parse(t,e,s){let[r,i,a,n]=e.match(new RegExp(`^${this.regex}([\\s\\S]*)$`,"i"))||[];if(!r)return;if(/DO\s+NOTHING/i.test(a))return new this(t);let[o,u]=f.split(n,["WHERE"],{ci:!0}),l=super.parse(t,o,s);return u&&l.where(s(l,u.trim(),[y,D])),l}static regex="ON\\s+(?:DUPLICATE\\s+KEY|CONFLICT(?:\\s+([\\s\\S]+))?)\\s+(UPDATE|DO\\s+NOTHING|DO\\s+UPDATE\\s+SET\\s+)"};var he=class extends F{TABLE=null;COLUMNS_LIST=[];VALUES_LIST=[];SET_CLAUSE=null;SELECT_CLAUSE=null;ON_CONFLICT_CLAUSE=null;get TABLES(){return this.TABLE?[this.TABLE]:[]}into(t){return this.build("TABLE",[t],x)}columns(...t){return this.build("COLUMNS_LIST",t,N)}values(...t){return this.VALUES_LIST.push(t)}set(...t){return this.build("SET_CLAUSE",t,nt,"set")}select(t){return this.build("SELECT_CLAUSE",[t],it)}onConflict(...t){return this.build("ON_CONFLICT_CLAUSE",t,zt)}toJson(){return{table:this.TABLE.toJson(),columns_list:this.COLUMNS_LIST.map(t=>t.toJson()),values_list:this.VALUES_LIST.map(t=>t),set_clause:this.SET_CLAUSE?.toJson(),select_clause:this.SELECT_CLAUSE?.toJson(),on_conflict_clause:this.ON_CONFLICT_CLAUSE?.toJson(),flags:this.FLAGS}}static fromJson(t,e){if(!e?.table)return;let s=new this(t).withFlag(...e.flags||[]);s.into(e.table),e.columns_list?.length&&s.columns(...e.columns_list);for(let r of e.values_list||[])s.values(...r);return e.set_clause&&s.set(e.set_clause),e.select_clause&&s.select(e.select_clause),e.on_conflict_clause&&s.onConflict(e.on_conflict_clause),s}stringify(){let t=["INSERT"];return this.FLAGS.length&&t.push(this.FLAGS.map(e=>e.replace(/_/g," "))),t.push("INTO",this.TABLE),this.SET_CLAUSE?t.push("SET",this.SET_CLAUSE):(this.COLUMNS_LIST.length&&t.push(`(${this.COLUMNS_LIST.join(", ")})`),this.SELECT_CLAUSE?t.push(this.SELECT_CLAUSE):t.push("VALUES",`
	(${this.VALUES_LIST.map(e=>e.join(", ")).join(`),
	(`)})`)),this.ON_CONFLICT_CLAUSE&&t.push(this.ON_CONFLICT_CLAUSE),t.join(" ")}static parse(t,e,s){let[r,i,a,n]=/^INSERT(\s+WITH\s+UAC)?(?:\s+(IGNORE))?(?:\s+INTO)?([\s\S]+)$/i.exec(e)||[];if(!r)return;let o=this.mySubstitutePlaceholders(t,n.trim()),{tokens:[u,l,h],matches:[E,p]}=f.lex(o,["(VALUES|VALUE|SET|SELECT)","ON\\s+(DUPLICATE\\s+KEY|CONFLICT)"],{useRegex:"i"}),m=new this(t);if(i&&m.withFlag("WITH_UAC"),a&&m.withFlag(a),/^SET$/i.test(E))m.into(s(m,u,[x])),m.set(s(m,l.trim(),[nt]));else{let d=f.split(u,[]);if(m.into(s(m,d.shift().trim(),[x])),d.length){let T=f.split(L(d.shift().trim(),"(",")"),[","]).map(_=>s(m,_.trim(),[N]));m.columns(...T)}if(/^SELECT$/i.test(E))m.select(s(m,`SELECT ${l}`));else for(let T of f.split(l,[","])){let _=f.split(L(T.trim(),"(",")"),[","]).map(S=>s(m,S.trim()));m.values(..._)}}return p&&m.onConflict(s(m,`${p} ${h}`,[zt])),m}};var fe=class extends F{TABLE_LIST=[];JOIN_LIST=[];SET_CLAUSE=null;WHERE_CLAUSE=null;ORDER_BY_CLAUSE=null;LIMIT_CLAUSE=null;get TABLES(){return this.TABLE_LIST}table(...t){return this.build("TABLE_LIST",t,x)}join(t){return this.build("JOIN_LIST",[t],w,"full")}leftJoin(t){return this.build("JOIN_LIST",[t],w,"left")}rightJoin(t){return this.build("JOIN_LIST",[t],w,"right")}innerJoin(t){return this.build("JOIN_LIST",[t],w,"inner")}crossJoin(t){return this.build("JOIN_LIST",[t],w,"cross")}set(...t){return this.build("SET_CLAUSE",t,nt,"set")}where(...t){return this.build("WHERE_CLAUSE",t,y,"and")}orderBy(...t){return this.build("ORDER_BY_CLAUSE",t,P,"criterion"),this.ORDER_BY_CLAUSE}limit(...t){if(!t.every(e=>typeof e=="number"))throw new Error("Limits must be of type number.");this.LIMIT_CLAUSE=t}toJson(){return{table_list:this.TABLE_LIST.map(t=>t.toJson()),join_list:this.JOIN_LIST.map(t=>t.toJson()),set_clause:this.SET_CLAUSE?.toJson(),where_clause:this.WHERE_CLAUSE?.toJson(),order_by_clause:this.ORDER_BY_CLAUSE?.toJson(),limit_clause:this.LIMIT_CLAUSE,flags:this.FLAGS}}static fromJson(t,e){if(!Array.isArray(e?.table_list))return;let s=new this(t).withFlag(...e.flags||[]);return s.table(...e.table_list),e.join_list?.length&&s.join(...e.join_list),e.set_clause&&s.set(e.set_clause),e.where_clause&&s.where(e.where_clause),e.order_by_clause&&s.orderBy(e.order_by_clause),e.limit_clause&&s.limit(e.limit_clause),s}stringify(){let t=["UPDATE"];return this.FLAGS.length&&t.push(this.FLAGS.map(e=>e.replace(/_/g," "))),t.push(this.TABLE_LIST.join(", ")),this.JOIN_LIST.length&&t.push(...this.JOIN_LIST),t.push("SET",this.SET_CLAUSE),this.WHERE_CLAUSE&&t.push("WHERE",this.WHERE_CLAUSE),this.ORDER_BY_CLAUSE&&t.push(this.ORDER_BY_CLAUSE),this.LIMIT_CLAUSE&&t.push("LIMIT",this.LIMIT_CLAUSE),t.join(" ")}static parse(t,e,s){let[r,i,a,n]=/^UPDATE(\s+WITH\s+UAC)?(?:\s+(IGNORE))?([\s\S]+)$/i.exec(e)||[];if(!r)return;let o=new this(t);i&&o.withFlag("WITH_UAC"),a&&o.withFlag(a);let u=this.mySubstitutePlaceholders(o,n.trim()),l={join:w,set:"SET",where:"WHERE",orderBy:P,limit:"LIMIT"},{tokens:[h,...E],matches:p}=f.lex(u,Object.values(l).map(m=>typeof m=="string"||m.test?m:m.regex),{useRegex:"i"});for(let m of f.split(h,[","])){let d=s(o,m.trim(),[x]);o.table(d)}for(let m of p){let d=m.replace(/\s+/g,""),T=Object.keys(l).find(_=>new RegExp(_,"i").test(d));if(T==="set"){let _=s(o,E.shift().trim(),[nt]);o.set(_)}else if(T==="where"){let _=s(o,E.shift().trim(),[y,D]);o.where(_)}else if(T==="limit")o.limit(parseInt(E.shift().trim()));else{let _=s(o,`${m} ${E.shift().trim()}`,[l[T]]);o[T](_)}}return o}};var rs=[G,ut,At,M,ct,lt,he,fe,le,it,...I.Types];var me=class{static grammar=rs;static parse(t,e,s,r={}){if(!e?.length)return;let i=s?.length?s:this.grammar;for(let a of i){let n=this.parseOne(t,e,a,r);if(n)return r.log&&console.log(".................",e,".................>",n.constructor.name),n}if(r.assert!==!1)throw new SyntaxError(e)}static parseOne(t,e,s,r={}){return s.parse(t,e,(i,a,n,o={})=>this.parse(i,a,n,{...r,...o}))}};var Yt=class{constructor(t,e,s="backward"){Object.defineProperty(this,"$",{value:{client:t,json:e,direction:s}})}get client(){return this.$.client}get direction(){return this.$.direction}get id(){return this.$.json.id}get description(){return this.$.json.savepoint_description}get databaseTag(){return this.$.json.database_tag}get versionTag(){return this.$.json.version_tag}get savepointDate(){return this.$.json.savepoint_date}get rollbackDate(){return this.$.json.rollback_date}schema(){let{name:t,$name:e,tables:s=[],status:r}=this.$.json;return{name:t,...e?{$name:e}:{},tables:s,status:r}}toJson(){return{...this.$.json}}async canRollback(){let t=this.$.json.rollback_date?this.$.json.name:this.$.json.$name||this.$.json.name;return(await this.client.database(t).savepoint({direction:this.direction})||{}).id===this.$.json.id}async rollback(){if(!await this.canRollback())throw new Error("Invalid rollback order.");let t=G.fromJson(this.client,this.schema());if(this.$.json.rollback_date||(t.reverseAlt(!0),t.status(t.status(),!0)),t.status()==="DOWN")this.client.dropDatabase(t.name(),{cascade:!0,noCreateSavepoint:!0});else if(t.status()==="UP"){let s=t.getAlt().with({resultSchema:t});this.client.query(s,{noCreateSavepoint:!0})}else this.client.query(t,{noCreateSavepoint:!0});let e=[this.client.constructor.OBJ_INFOSCHEMA_DB,"database_savepoints"].join(".");return await this.client.query(`UPDATE ${e} SET rollback_date = ${this.$.json.rollback_date?"NULL":"now()"} WHERE id = '${this.$.json.id}'`),this.$.json.rollback_date=this.$.json.rollback_date?null:Date.now(),!0}};var Ee=class{static get OBJ_INFOSCHEMA_DB(){return"obj_information_schema"}constructor(t,e={}){Object.defineProperty(this,"$",{value:{driver:t,params:e}})}get driver(){return this.$.driver}get params(){return this.$.params}database(t,e={}){return new this.constructor.Database(this,...arguments)}async databases(){return[]}async hasDatabase(t){return(await this.databases()).includes(t)}async describeDatabase(t,e=[],s={}){return{name:t,tables:await this.database(t).describeTable(e,s)}}async createDatabase(t,e={}){if(typeof t=="string")t={name:t};else if(typeof t?.name!="string")throw new Error("createDatabase() called with invalid arguments.");let s=G.fromJson(this,t);return e.ifNotExists&&s.withFlag("IF_NOT_EXISTS"),await this.query(s,e)}async alterDatabase(t,e,s={}){if(typeof e!="function")throw new Error("alterDatabase() called with invalid arguments.");if(typeof t=="string")t={name:t};else if(typeof t?.name!="string")throw new Error("alterDatabase() called with invalid arguments.");let r=await this.describeDatabase(t.name,t.tables),i=G.fromJson(this,r).status("UP","UP");await e(i);let a=i.getAlt().with({resultSchema:i});if(a.ACTIONS.length)return await this.query(a,s)}async dropDatabase(t,e={}){if(typeof t!="string")throw new Error(`dropDatabase() called with an invalid name: ${t}.`);let s=At.fromJson(this,{name:t});return e.ifExists&&s.withFlag("IF_EXISTS"),e.cascade&&s.withFlag("CASCADE"),await this.query(s,e)}async queryCallback(t,e,s={}){if(typeof e=="string")e=me.parse(this,e.trim(),null,{log:!1});else if(!(e instanceof A))throw new Error("query() called with invalid arguments.");let r=(o,u)=>u.some(l=>o instanceof l),i={},a=o=>o&&!new RegExp(o,"i").test(this.constructor.OBJ_INFOSCHEMA_DB)&&(!s.noCreateSavepoint||s.$resultSchema==="always");if(r(e,[G,ut,At])&&a(e.name())){if(e instanceof At){let o=G.fromJson(this,await this.describeDatabase(e.name(),"*")).status("DOWN");e.with({resultSchema:o})}else if(e instanceof ut&&!e.resultSchema){let o=e.ACTIONS.filter(l=>["ALTER","DROP"].includes(l.TYPE)).map(l=>l.NAME),u=G.fromJson(this,await this.describeDatabase(e.name(),o)).status("UP","UP").alterWith(e);e.with({resultSchema:u})}else e instanceof G&&e.with({resultSchema:e});i.savepoint=e.resultSchema}else if(r(e,[M,ct,lt])){let o=e.basename()||await this.basenameGet(e.name(),!0);if(a(o)){let u=this.database(o);if(e instanceof lt&&o){let l=M.fromJson(u,await u.describeTable(e.name())).status("DOWN");e.with({resultSchema:l})}else if(e instanceof ct&&!e.resultSchema&&o){let l=M.fromJson(u,await u.describeTable(e.name())).status("UP","UP").alterWith(e);e.with({resultSchema:l})}else e instanceof M&&o&&e.with({resultSchema:e});!s.noCreateSavepoint&&o&&(i.savepoint=G.fromJson(this,{name:u.name,tables:[e.resultSchema]}).status("UP"))}}let n=await t(e,s);return!s.noCreateSavepoint&&i.savepoint?(i.savepoint.status(i.savepoint.status(),!0),await this.createSavepoint(i.savepoint,s.savepointDesc)):n}async basenameResolution(t=[]){return arguments.length?(this.$.resolutionPath=[].concat(t),this):new BasenameResolutor(this.$.basenameResolution)}async basenameGet(t,e=!1){let s=await this.basenameResolution();return await s.reduce(async(r,i)=>await r||await this.database(i).hasTable(t)?i:null,null)||(e?s.find(r=>!r.startsWith("$"))||s[0]:null)}async createSavepoint(t,e=null){let s=this.constructor.OBJ_INFOSCHEMA_DB;await this.hasDatabase(s)||await this.createDatabase({name:s,tables:[{name:"database_savepoints",columns:[{name:"id",type:"uuid",primaryKey:!0,default:{expr:"gen_random_uuid()"}},{name:"name",type:"varchar",notNull:!0},{name:"$name",type:"varchar"},{name:"tables",type:"json"},{name:"status",type:"varchar"},{name:"savepoint_description",type:"varchar"},{name:"database_tag",type:"varchar",notNull:!0},{name:"version_tag",type:"int",notNull:!0},{name:"savepoint_date",type:"timestamp",notNull:!0},{name:"rollback_date",type:"timestamp"}]}]},{noCreateSavepoint:!0});let r={database_tag:null,...t.toJson(),savepoint_description:e,version_tag:null,savepoint_date:new String("now()")},i=await this.database(t.name()).savepoint();if(i){let n=[s,"database_savepoints"].join(".");r.database_tag=i.databaseTag,r.version_tag=(await this.query(`SELECT max(version_tag) + 1 AS next_tag FROM ${n} WHERE database_tag = '${i.databaseTag}'`))[0].next_tag,r.version_tag-1!==i.versionTag&&await this.query(`DELETE FROM ${n} WHERE database_tag = '${i.databaseTag}' AND rollback_date IS NOT NULL`)}else r.database_tag=`db:${(0|Math.random()*9e6).toString(36)}`,r.version_tag=1;let a=await this.database(s).table("database_savepoints").add(r);return new Yt(this,{...a.toJson(),id_following:null})}};function we(c,t){return c.reduce((e,s,r)=>e&&t(s,r),!0)}function $e(c,t){return c.reduce((e,s,r)=>e||t(s,r),!1)}function Ge(c){let t=(e,s,r)=>r.indexOf(e)===s;return c.filter(t)}var pe=class{constructor(t,e,s={}){Object.defineProperty(this,"$",{value:{client:t,name:e,params:s}})}get client(){return this.$.client}get name(){return this.$.name}get params(){return this.$.params}table(t,e={}){return new this.constructor.Table(this,...arguments)}async tables(){return[]}async hasTable(t){return(await this.tables()).includes(t)}async describeTable(t,e={}){let s=[].concat(t),r=!Array.isArray(t)&&t!=="*",i=s.length===1&&s[0]==="*";return r?null:[]}async createTable(t,e={}){if(typeof t?.name!="string")throw new Error("createTable() called with invalid arguments.");let s=M.fromJson(this,t);return e.ifNotExists&&s.withFlag("IF_NOT_EXISTS"),this.client.query(s,e)}async alterTable(t,e,s={}){if(typeof e!="function"||typeof t!="string")throw new Error("alterTable() called with invalid arguments.");let r=await this.describeTable(t),i=M.fromJson(this,r).status("UP","UP");await e(i);let a=i.getAlt().with({resultSchema:i});if(a.ACTIONS.length)return s.ifExists&&a.withFlag("IF_EXISTS"),this.client.query(a,s)}async dropTable(t,e={}){if(typeof t!="string")throw new Error("dropTable() called with invalid arguments.");let s=lt.fromJson(this,{name:t});return e.ifExists&&s.withFlag("IF_EXISTS"),e.cascade&&s.withFlag("CASCADE"),this.client.query(s,e)}async savepoint(t={}){let e=this.client.constructor.OBJ_INFOSCHEMA_DB;if(!await this.client.hasDatabase(e))return;let s=[e,"database_savepoints"].join("."),r=t.direction==="forward"?await this.client.query(`
                SELECT savepoint.*, preceding.id AS id_preceding FROM ${s} AS savepoint
                LEFT JOIN ${s} AS preceding ON preceding.database_tag = savepoint.database_tag AND COALESCE(preceding."$name", preceding.name) = savepoint.name AND preceding.version_tag < savepoint.version_tag
                WHERE COALESCE(savepoint.name, savepoint."$name") = '${this.name}' AND savepoint.rollback_date IS NOT NULL AND (preceding.id IS NULL OR preceding.rollback_date IS NULL)
                ORDER BY savepoint.version_tag ASC LIMIT 1
            `):await this.client.query(`
                SELECT savepoint.*, following.id AS id_following FROM ${s} AS savepoint
                LEFT JOIN ${s} AS following ON following.database_tag = savepoint.database_tag AND following.name = COALESCE(savepoint."$name", savepoint.name) AND following.version_tag > savepoint.version_tag
                WHERE COALESCE(savepoint."$name", savepoint.name) = '${this.name}' AND savepoint.rollback_date IS NULL AND (following.id IS NULL OR following.rollback_date IS NOT NULL)
                ORDER BY savepoint.version_tag DESC LIMIT 1
            `);return r[0]&&new Yt(this.client,r[0],t.direction)}};var Ae=class{constructor(t,e,s,r,i={}){this.table=t,this.rawResultMeta=e,this.columns=s,this.entries=r,this.duplicateKeyUpdateObj=i}toJson(){return(this.rawResultMeta.rows||this.rawResultMeta)[0]}lastInsertID(){return(this.rawResultMeta.rows||this.rawResultMeta)[0]?.id}async getAffectedRowsPointers(){if(!(!R(this.columns)||!R(this.entries))){var t=[],e={all:{},each:[]},s=await this.table.primaryKeyColumns();if($e(s,n=>this.columns.includes(n)))t=[s],e.by="primaryKey";else{var r=this.table.columnsForConstraint("UNIQUE_KEY");t=r.filter(n=>$e(n,o=>this.columns.includes(o))),e.by="uniqueKeys"}if(t.length){var i={};Ge(t.reduce((n,o)=>n.concat(o),[])).forEach(n=>{var o=this.columns.indexOf(n);o===-1?e.all[n]=this.table.def.schema.columns[n].default:i[n]=o});var a=Object.keys(i);a.length&&this.entries.forEach(n=>{var o={};a.forEach(u=>{R(n)?o[u]=n[i[u]]:o[u]=n[u],this.duplicateKeyUpdateObj&&u in this.duplicateKeyUpdateObj&&(o[u]=[o[u],this.duplicateKeyUpdateObj[u]])}),e.each.push(o)})}return e}}};var _t=class extends Ae{info(){var t,e=(this.rawResultMeta.info||"").replace(/ /g,"").match(/Records:([0-9]*)Duplicates:([0-9]*)Warnings:([0-9]*)/);return e?t=e.slice(1).map(s=>parseInt(s)):t=[0,0,0],{records:t[0],duplicates:t[1],warnings:t[2]}}async getAffectedRows(t=!1){var e=this.getAffectedRowsPointers();if(e.by==="primaryKey"){var s=Object.keys(e.each[0]);if(s.length===1){var r=e.each.map(h=>h[s[0]]);if(we(r,h=>Y(h)))return t?r.map(h=>parseInt(h)):r.length}}var i="id";let a=h=>{var E=Object.keys(h),p=E.reduce((m,d)=>m.concat(R(h[d])?`${d} IN ("${h[d].join('", "')}")`:`${d} = "${h[d]}"`),[]).join(" AND ");return E.length>1?`(${p})`:p};var n="",o="";if(vt(e.all)||(n=a(e.all)),!vt(e.each)){var u=Object.keys(e.each[0]);u.length===1&&!R(e.each[0][u[0]])?o=`${u[0]} IN (${e.each.map(h=>h[u[0]]).join(", ")})`:o=e.each.map(h=>a(h)).join(" OR ")}if(n||o){var l=this.table.database.client.params.driver;return new Promise((h,E)=>{var p=n&&o?`${n} AND (${o})`:n||o,m=`SELECT ${t?i:"COUNT(*) AS count"} FROM ${this.table.name} WHERE ${p} ORDER BY ${i} ASC`;l.query(m,(d,T)=>{if(d)return E(d);if(!t)return h(T[0].count);h(T.map(_=>_[i]))})})}return this.rawResultMeta.insertId?t?this.entries.map((h,E)=>this.rawResultMeta.insertId+1):this.entries.length:t?[]:0}};var Te=class{constructor(t,e,s){this.table=t,this.rawResultMeta=e,this.whereObj=s}};var Zt=class extends Te{async getAffectedRows(t=!1){if(t)throw new Error('The "withIDs" argument is not supported for delete queries.');return this.rawResultMeta.affectedRows}};var de=class{constructor(t,e,s={}){this.$={database:t,name:e,params:s}}get name(){return this.$.name}get database(){return this.$.database}get params(){return this.$.params}get dropped(){return this.$.schema.hiddenAs==="dropped"}async schema(){return await this.database.describeTable(this.name)}async primaryKeyColumns(){return(await this.columnsForConstraint("PRIMARY_KEY"))[0]}async columnsForConstraint(t){let e=await this.database.describeTable(this.name),s={PRIMARY_KEY:"primaryKey",UNIQUE_KEY:"uniqueKey",CHECK:"check",FOREIGN_KEY:"references"},r=t in s?e.columns.filter(i=>i[s[t]]).map(i=>[i.name]):[];return e.constraints.length&&(r=r.concat(e.constraints.filter(i=>i.type===t).reduce((i,a)=>i.concat([a.columns])))),r}async columnsForIndex(t){let e=await this.database.describeTable(this.name);return e.indexes.length?e.indexes.filter(s=>s.type===t).reduce((s,r)=>s.concat([r.columns])):[]}async syncCursor(t){return await this.putAll(t.cache)}async match(t){let e,s;if(this.def.schema.primaryKey&&(e=Ue(t,this.def.schema.primaryKey))&&(s=await this.get(e)))return{matchingKey:"PRIMARY_KEY",primaryKey:e,row:s};let r=await this.primaryKeyColumns(),i=await this.columnsForConstraint("UNIQUE_KEY");r.concat(i).map(o=>`(${o.map(u=>`${this.quote(obj[u])} IN (${o.join(",")})`).join(" AND ")})`).join(" OR ");var a,n=Object.keys(this.def.schema.indexes).filter(o=>this.def.schema.indexes[o].type==="unique");return n.length&&(await this.getAll()).forEach((o,u)=>{a||n.forEach(l=>{var h=this.def.schema.indexes[l].keyPath;o&&Ue(t,h)===Ue(o,h)&&(a={matchingKey:l,primaryKey:this.def.schema.primaryKey?Ue(o,this.def.schema.primaryKey):u,row:{...o}})})}),a}async addAll(t,e=[],s=null,r=!1){let i=[],a=[];for(let n of t){let o=n;if(Array.isArray(n)){let u=e.length?e:(await this.schema()).columns.map(l=>l.name);if(u.length&&u.length!==n.length)throw new Error(`Column/values count mismatch at line ${t.indexOf(n)}.`);o=u.reduce((l,h,E)=>({...l,[h]:n[E]}),{})}if(await this.handleInput(o,!0),await this.shouldMatchInput(o)||s){let u=await this.match(o);if(u&&s){let l={...u.row};s(l,o)&&a.push(l),i.push("0");continue}await this.beforeAdd(o,u),i.push(await this.add(o));continue}await this.beforeAdd(o),i.push(await this.add(o))}return a.length&&i.push(...await this.putAll(a)),i.filter((n,o)=>n!==0&&i.indexOf(n)===o)}async beforeAdd(t,e){let s=new Date().toISOString();for(let r of(await this.schema()).columns){let i=O(r.type)?r.type.name:r.type;(i==="datetime"||i==="timestamp")&&r.default.expr==="CURRENT_TIMESTAMP"&&(t[r.name]=s)}}async putAll(t){let e=[];for(let s of t){if(await this.handleInput(s),await this.shouldMatchInput(s)){await this.beforePut(s,await this.match(s)),e.push(await this.put(s));continue}await this.beforePut(s),e.push(await this.put(s))}return e}async beforePut(t,e){if(e&&!Object.keys(t).every(s=>t[s]===e.row[s])){let s=new Date().toISOString();for(let r of(await this.schema()).columns){let i=O(r.type)?r.type.name:r.type;(i==="datetime"||i==="timestamp")&&r.onupdate==="CURRENT_TIMESTAMP"&&(t[r.name]=s)}}}async deleteAll(t){let e=[];for(let s of t)e.push(this.delete(await this.beforeDelete(s)));return e}async beforeDelete(t){return t}async handleInput(t,e=!1){let s=Object.keys(t),r=await this.schema(),i=r.columns.map(n=>n.name),a=s.filter(n=>i.indexOf(n)===-1);if(a.length)throw new Error(`Unknown column: ${a[0]}`);for(let n of i){let o=t[n],u=r.columns.find(l=>l.name===n)||{};if(s.includes(n)){let l=O(u.type)?u.type.name:u.type;l==="json"?!K(o)&&(!j(o)||!B(o,"[","]")&&B(o,"{","}")):["char","tinytext","smalltext","text","bigtext","varchar"].includes(l)?j(o):["bit","tinyint","smallint","int","bigint","decimal","number","float","real"].includes(l)?Y(o):["enum","set"].includes(l)?Y(o):["date","datetime","timestamp"].includes(l)&&j(o)}else e&&!Gt([n],await this.primaryKeyColumns()).length&&(t[n]="default"in u&&!(["date","datetime","timestamp"].includes(columnType)&&u.default.expr==="CURRENT_TIMESTAMP")?u.default.value:null);if(u.notNull&&(gt(t[n])||tt(t[n])))throw new Error(`Inserting NULL on non-nullable column: ${n}.`)}}async shouldMatchInput(t){return(await this.schema()).columns.some(e=>{let s=O(e.type)?e.type.name:e.type;return["datetime","timestamp"].includes(s)&&(e.default.expr==="CURRENT_TIMESTAMP"||e.onupdate==="CURRENT_TIMESTAMP")})}},Ue=(c,t)=>Ot(t).map(e=>c[e]).filter(e=>e).join("-");var Se=class{_pos=0;_eof=!1;_onfinish=[];constructor(t){this._cache=t}get eof(){return!this._cache.length||this._pos===this._cache.length-1}onfinish(t){this._onfinish.push(t)}next(){if(this.eof){this._onfinish.forEach(t=>t()),this._pos=0;return}this._pos++}async fetch(){if(!this.eof)return this._cache[this._pos]}};var Ne=class extends Se{constructor(t){super([]),this._store=t,this._storeFetch=new Promise(async e=>{this.cache=await this._store.getAll(),e()})}async fetch(){return await this._storeFetch,super.fetch()}};var _e=class extends de{getCursor(){return new Ne(this)}async getAll(){return new Promise((t,e)=>{this.database.client.driver.query(`SELECT * FROM ${this.database.name}.${this.name}`,(s,r)=>{if(s)return e(s);t(r.rows||r)})})}async get(t){let e=await this.primaryKeyColumns();if(!e.length)throw new Error("Table has no primary key defined.");return new Promise((s,r)=>{this.database.client.driver.query(`SELECT * FROM ${this.database.name}.${this.name} WHERE '${t}' IN (${e.join(",")})`,[],(i,a)=>{if(i)return r(i);s((a.rows||a)[0])})})}async count(t="*"){return new Promise((e,s)=>{this.database.client.driver.query(`SELECT COUNT(${t}) AS c FROM ${this.database.name}.${this.name}`,(r,i)=>{if(r)return s(r);e((i.rows||i)[0].c)})})}async addAll(t,e=[],s=null){if(!t.length)return;let r={};return e.length||(O(t[0])?e=Object.keys(t[0]):e=(await this.database.describeTable(this.name)).columns.map(a=>a.name)),new Promise((i,a)=>{let n=`INSERT INTO ${this.database.name}.${this.name}
	${e.length?`(${e.join(",")})
	`:""}`;n+=`VALUES
	${t.map(o=>as(Object.values(o),this.database.client.params.dialect)).join(`,
	`)}`,s&&(s(r),n+=` ${this.database.client.params.dialect==="mysql"?"ON DUPLICATE KEY UPDATE":"ON CONFLICT DO UPDATE SET"} ${cs(r,this.database.client.params.dialect)}`),this.database.client.driver.query(n,(o,u)=>{if(o)return a(o);i(new _t(this,u,e,t,r))})})}async add(t){return new Promise((e,s)=>{let r=`INSERT INTO ${this.database.name}.${this.name}
	(${Object.keys(t).map(i=>N.fromJson(this,i)).join(", ")})
	`;r+=`VALUES
	${as(Object.values(t),this.database.client.params.dialect)}
	`,r+="RETURNING *",this.database.client.driver.query(r,(i,a)=>{if(i)return s(i);e(new _t(this,a,Object.keys(t),Object.values(t)))})})}async putAll(t){return await Promise.all(t.map(e=>this.put(e))),new _t(this,{},Object.keys(t[0]),t)}async put(t){return new Promise((e,s)=>{let r=`INSERT INTO ${this.database.name}.${this.name}
	${Ps(t,this.database.client.params.dialect)}`;this.database.client.driver.query(r,(i,a)=>{if(i)return s(i);e(new _t(this,a,Object.keys(t),Object.values(t)))})})}async deleteAll(t=[]){let e=await this.primaryKeyColumns();if(!e.length)throw new Error("Table has no primary key defined.");return new Promise((s,r)=>{let i=`DELETE FROM ${this.database.name}.${this.name}${t.length?` WHERE ${t.map(a=>`'${a}' in (${e.join(",")})`).join(" OR ")}`:""}`;this.database.client.driver.query(i,[],(a,n)=>{if(a)return r(a);s(new Zt(this,n))})})}async delete(t){let e=await this.primaryKeyColumns();if(!e.length)throw new Error("Table has no primary key defined.");return new Promise((s,r)=>{let i=`DELETE FROM ${this.database.name}.${this.name} WHERE ${t} IN (${e.join(",")})`;this.database.client.driver.query(i,[],(a,n)=>{if(a)return r(a);s(new Zt(this,n))})})}},os=(c,t)=>{if(c instanceof Date)try{return`'${c.toISOString().split(".")[0]}'`}catch{return"NULL"}if(c instanceof String)return c+"";if(Y(c))return c;if(gt(c))return"NULL";if((Array.isArray(c)||O(c))&&(c=JSON.stringify(c)),typeof c=="string")return`'${c.replace(/'/g,"''")}'`;throw new Error("Couldn't serialize payload.")},as=(c,t)=>"("+c.map(e=>os(e,t)).join(",")+")",cs=(c,t)=>Object.keys(c).map(e=>`${N.fromJson(void 0,e)} = ${os(c[e],t)}`).join(","),Ps=(c,t)=>{let e=cs(c,t);return`SET ${e} ${t==="mysql"?"ON DUPLICATE KEY UPDATE":"ON CONFLICT DO UPDATE SET"} ${e}`};var Re=class extends pe{static Table=_e;async tables(){let t=`SELECT table_name FROM information_schema.tables WHERE table_schema = '${this.name}'`,e=await this.client.driver.query(t);return(e.rows||e).map(s=>s.table_name)}async describeTable(t,e={}){let s=!Array.isArray(t)&&t!=="*",r=[].concat(t),[i,a]=this.getDescribeTableSql(r),n=await this.client.driver.query(i),o=await this.client.driver.query(a),u=this.formatDescribeTableResult(r,n.rows||n,o.rows||o,[]);return s?u[0]:u}getDescribeTableSql(t){let e=`
        SELECT
            COLUMNS.column_name,
            COLUMNS.table_name,
            COLUMNS.ordinal_position,
            COLUMNS.column_default,
            COLUMNS.is_nullable,
            COLUMNS.data_type,
            COLUMNS.character_maximum_length,
            ${this.client.params.dialect==="mysql"?"":`
            COLUMNS.is_identity,
            COLUMNS.identity_generation,
            COLUMNS.identity_start,
            COLUMNS.identity_increment,
            COLUMNS.identity_maximum,
            COLUMNS.identity_minimum,
            COLUMNS.identity_cycle,
            `}
            COLUMNS.is_generated,
            COLUMNS.generation_expression

        FROM INFORMATION_SCHEMA.COLUMNS AS COLUMNS

        WHERE COLUMNS.TABLE_SCHEMA='${this.name}'
            ${t.length&&t[0]!=="*"?`AND COLUMNS.TABLE_NAME IN ('${t.join("','")}')`:""}
        ORDER BY COLUMNS.ordinal_position
        `,s=a=>this.client.params.dialect==="mysql"?a:`ANY_VALUE(${a})`,r=(a,n)=>this.client.params.dialect==="mysql"?`GROUP_CONCAT(${a}${n?` ORDER BY ${n}`:""} SEPARATOR ',')`:`STRING_AGG(${a}, ','${n?` ORDER BY ${n}`:""})`,i=`
        SELECT
            ${s("TABLE_CONSTRAINTS.table_name")} AS table_name,
            ${r("TABLE_CONSTRAINTS_DETAILS.column_name","TABLE_CONSTRAINTS_DETAILS.ordinal_position")} AS column_name,
            TABLE_CONSTRAINTS.constraint_name AS constraint_name,
            ${s("TABLE_CONSTRAINTS.constraint_type")} AS constraint_type,
            ${s("CHECK_CONSTRAINTS_DETAILS.check_clause")} AS check_clause,
                
            ${this.client.params.dialect==="mysql"?`
            ${s("CHECK_CONSTRAINTS_DETAILS.level")} AS check_constraint_level,
            ${r("TABLE_CONSTRAINTS_DETAILS.referenced_column_name")} AS referenced_column_name,
            ${s("TABLE_CONSTRAINTS_DETAILS.referenced_table_name")} AS referenced_table_name,
            ${s("TABLE_CONSTRAINTS_DETAILS.referenced_table_schema")} AS referenced_table_schema,
            `:`
            ${r("RELATION_DETAILS.column_name")} AS referenced_column_name,
            ${s("RELATION_DETAILS.table_name")} AS referenced_table_name,
            ${s("RELATION_DETAILS.table_schema")} AS referenced_table_schema,
            `}
            --${r("RELATION.unique_constraint_name")} AS referenced_constraint_name,
            ${s("RELATION.match_option")} AS match_rule,
            ${s("RELATION.update_rule")} AS update_rule,
            ${s("RELATION.delete_rule")} AS delete_rule

        FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS AS TABLE_CONSTRAINTS

        LEFT JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE AS TABLE_CONSTRAINTS_DETAILS
            ON TABLE_CONSTRAINTS_DETAILS.CONSTRAINT_NAME = TABLE_CONSTRAINTS.CONSTRAINT_NAME
            AND TABLE_CONSTRAINTS_DETAILS.TABLE_NAME = TABLE_CONSTRAINTS.TABLE_NAME
            AND TABLE_CONSTRAINTS_DETAILS.CONSTRAINT_SCHEMA = TABLE_CONSTRAINTS.CONSTRAINT_SCHEMA
            AND TABLE_CONSTRAINTS_DETAILS.CONSTRAINT_CATALOG = TABLE_CONSTRAINTS.CONSTRAINT_CATALOG
        LEFT JOIN INFORMATION_SCHEMA.CHECK_CONSTRAINTS AS CHECK_CONSTRAINTS_DETAILS
            ON CHECK_CONSTRAINTS_DETAILS.CONSTRAINT_NAME = TABLE_CONSTRAINTS.CONSTRAINT_NAME
            AND CHECK_CONSTRAINTS_DETAILS.CONSTRAINT_SCHEMA = TABLE_CONSTRAINTS.CONSTRAINT_SCHEMA
            AND CHECK_CONSTRAINTS_DETAILS.CONSTRAINT_CATALOG = TABLE_CONSTRAINTS.CONSTRAINT_CATALOG

        LEFT JOIN INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS AS RELATION
            ON RELATION.CONSTRAINT_NAME = TABLE_CONSTRAINTS.CONSTRAINT_NAME
            AND RELATION.CONSTRAINT_SCHEMA = TABLE_CONSTRAINTS.CONSTRAINT_SCHEMA
            AND RELATION.CONSTRAINT_CATALOG = TABLE_CONSTRAINTS.CONSTRAINT_CATALOG
        ${this.client.params.dialect==="mysql"?"":`
        LEFT JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE AS RELATION_DETAILS
            ON RELATION_DETAILS.CONSTRAINT_NAME = RELATION.UNIQUE_CONSTRAINT_NAME
            AND RELATION_DETAILS.CONSTRAINT_SCHEMA = RELATION.UNIQUE_CONSTRAINT_SCHEMA
            AND RELATION_DETAILS.CONSTRAINT_CATALOG = RELATION.UNIQUE_CONSTRAINT_CATALOG
            `}

        WHERE TABLE_CONSTRAINTS.CONSTRAINT_SCHEMA = '${this.name}'
            ${t.length&&t[0]!=="*"?`AND TABLE_CONSTRAINTS.TABLE_NAME IN ('${t.join("','")}')`:""}
        GROUP BY (TABLE_CONSTRAINTS.constraint_name)
        `;return[e,i]}formatDescribeTableResult(t,e,s,r){let i=n=>n==="character varying"?"varchar":n==="integer"?"int":n,a=(n,o=!1)=>({...o?{}:{name:n.constraint_name},targetTable:[n.referenced_table_schema,n.referenced_table_name],targetColumns:n.referenced_column_name.split(",").map(u=>u.trim()),...n.match_rule!=="NONE"?{matchRule:n.match_rule}:{},updateRule:n.update_rule,deleteRule:n.delete_rule});return(t.length&&t[0]!=="*"?t:[...new Set(e.map(n=>n.table_name))]).map(n=>{let o=e.filter(S=>S.table_name===n),u=s.filter(S=>S.table_name===n),l=r.filter(S=>S.table_name===n),h=o.map(S=>S.column_name),E=S=>{let g=(S.check_clause.replace(/(["'])(?:(?=(\\?))\2.)*?\1/g,"").match(/\w+/g)||[]).map(C=>C.toLowerCase());return S.columns=Gt(h,g),S},[p,m,d,T]=u.reduce(([S,g,C,U],k)=>k.constraint_type==="PRIMARY KEY"?[S.concat(k),g,C,U]:k.constraint_type==="UNIQUE"?[S,g.concat(k),C,U]:k.constraint_type==="FOREIGN KEY"?[S,g,C.concat(k),U]:k.constraint_type==="CHECK"&&!(this.client.params.dialect==="postgres"&&/^[\d_]+not_null/.test(k.constraint_name))?[S,g,C,U.concat(E(k))]:[S,g,C,U],[[],[],[],[]]),_={name:n,columns:o.reduce((S,g)=>{let C={};return S.concat({name:g.column_name,type:g.character_maximum_length?{name:i(g.data_type),maxLen:g.character_maximum_length}:i(g.data_type),...p.length===1&&p[0].column_name===g.column_name&&(C.pKeys=p.pop())?{primaryKey:{name:C.pKeys.constraint_name}}:{},...(C.uKeys=m.filter(U=>U.column_name===g.column_name)).length===1&&(m=m.filter(U=>U!==C.uKeys[0]))?{uniqueKey:{name:C.uKeys[0].constraint_name}}:{},...(C.fKeys=d.filter(U=>U.column_name===g.column_name)).length===1&&(d=d.filter(U=>U!==C.fKeys[0]))?{references:a(C.fKeys[0])}:{},...(C.cKeys=T.filter(U=>U.check_constraint_level!=="Table"&&U.columns.length===1&&U.columns[0]===g.column_name)).length===1&&(T=T.filter(U=>U!==C.cKeys[0]))?{check:{name:C.cKeys[0].constraint_name,expr:C.cKeys[0].check_clause}}:{},...g.is_identity!=="NO"?{identity:{always:g.identity_generation==="ALWAYS"}}:{},...g.is_generated!=="NEVER"?{generated:{always:g.is_generated==="ALWAYS",expr:g.generation_expression}}:{},...g.is_nullable==="NO"?{notNull:!0}:{},...g.default?{default:{expr:g.default}}:{}})},[]),constraints:[],indexes:[]};return _.constraints.push(...[...p,...m,...d].map(S=>({name:S.constraint_name,type:S.constraint_type==="UNIQUE"?"UNIQUE_KEY":S.constraint_type,columns:S.column_name.split(",").map(g=>g.trim()),...S.constraint_type==="FOREIGN KEY"?{references:a(S,!0)}:{}}))),_.constraints.push(...T.map(S=>({name:S.constraint_name,type:S.constraint_type,columns:S.columns,expr:S.check_clause}))),_})}};var We=class extends Ee{constructor(t,e={}){if(typeof t!="object")throw new Error("The options.driver parameter is required and must be an object.");if(typeof t.query!="function")throw new Error("The provided driver must expose a .query() function.");super(t,e)}static kind="sql";static Database=Re;async databases(){let e=await this.driver.query("SELECT schema_name FROM information_schema.schemata");return(e.rows||e).map(s=>s.schema_name)}async query(t,e={}){return await this.queryCallback(async(s,r)=>{s.expandable&&await s.expand(!0);let i=await this.driver.query(s.toString(),r.params||[]);return i.rows||i},...arguments)}async basenameResolution(t=[]){if(arguments.length){t=[].concat(t).map(n=>N.fromJson(this,n));let a=this.params.dialect==="mysql"?`USE ${t[0]}`:`SET SEARCH_PATH TO ${t.join(",")}`;return await this.driver.query(a)}let e,s;this.params.dialect==="mysql"?(e="SELECT database() AS default_db",s="default_db"):(e="SHOW SEARCH_PATH",s="search_path",e="SELECT current_setting('SEARCH_PATH')",s="current_setting");let r=await this.driver.query(e),i=((r.rows||r)[0]||{})[s];return f.split(i,[","]).map(a=>N.parseIdent(this,a.trim())[0])}};})();
//# sourceMappingURL=sql.js.map
