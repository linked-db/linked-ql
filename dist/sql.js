(()=>{function Qt(a){return a instanceof String||typeof a=="string"&&a!==null}function At(a){return arguments.length&&(a===void 0||typeof a>"u")}function pe(a){return typeof a=="function"}function F(a){return pe(a)||a&&{}.toString.call(a)==="[object function]"}function $(a){return Array.isArray(a)}function Kr(a){return!Qt(a)&&!At(a.length)}function Xr(a){return a===null||a===""}function et(a){return Array.isArray(a)||typeof a=="object"&&a||pe(a)}function Br(a){return Xr(a)||At(a)||a===!1||a===0||et(a)&&!Object.keys(a).length}function N(a){return!Array.isArray(a)&&typeof a=="object"&&a}function It(a,t=!0){return $(a)?a:!t&&N(a)?[a]:a!==!1&&a!==0&&Br(a)?[]:Kr(a)?Array.prototype.slice.call(a):N(a)?Object.values(a):[a]}function zt(a){return a instanceof Number||typeof a=="number"}function Lt(a){return zt(a)||a!==!0&&a!==!1&&a!==null&&a!==""&&!isNaN(a*1)}var Zr=function(a,t=1,e=!0){return!Lt(t)||t<=0||(!$(a)&&N(a)&&e&&(a=Object.values(a)),!$(a))?a:a.reduce((r,s)=>$(s)||N(s)&&e?r.concat(Zr($(s)?s:Object.values(s),t-1,e)):r.concat(s),[])},Hr=Zr;function Zt(a,t=1){var e=0;a.forEach(s=>{e++});var r=a.slice(a.length-e,t);return arguments.length>1?r:r[0]}function ct(a,t=1){return arguments.length>1?Zt(a.slice().reverse(),t).reverse():Zt(a.slice().reverse())}function rr(a,...t){return t.forEach(e=>{a.indexOf(e)<0&&a.push(e)}),a}function ts(r,t){t=t||Object.prototype,t=t&&!$(t)?[t]:t;for(var e=[],r=r;r&&(!t||t.indexOf(r)<0)&&r.name!=="default";)e.push(r),r=r?Object.getPrototypeOf(r):null;return e}function es(a,t){var e=[];return ts(a,t).forEach(r=>{rr(e,...Object.getOwnPropertyNames(r))}),e}function te(a,t,e=!1,r=!1,s=!1){var i=0,o=a.shift();if((Lt(o)||o===!0||o===!1)&&(i=o,o=a.shift()),!a.length)throw new Error("_merge() requires two or more array/objects.");return a.forEach((n,u)=>{!et(n)&&!F(n)||(e?es(n):Object.keys(n)).forEach(f=>{if(t(f,o,n,u)){var c=o[f],h=n[f];if(($(c)&&$(h)||N(c)&&N(h))&&(i===!0||i>0))o[f]=$(c)&&$(h)?[]:{},te([Lt(i)?i-1:i,o[f],c,h],t,e,r,s);else if($(o)&&$(n))r?o[f]=h:o.push(h);else try{s?Object.defineProperty(o,f,Object.getOwnPropertyDescriptor(n,f)):o[f]=n[f]}catch{}}})}),o}function sr(...a){return te(a,(t,e,r)=>!0,!1,!1,!1)}function ir(a){return N(a)&&Object.getPrototypeOf(a)===Object.prototype}function Xe(a){return a===!0||a===!1}function nr(a,t){var e=void 0;return et(a)&&Object.keys(a).forEach((r,s)=>{e!==!1&&(e=t(Lt(r)?parseFloat(r):r,a[r],s))}),e}function rs(a,t,e=!0,r=!0,s=!1,i=!1){if($(a)&&$(t)){var o=[],n=!0;return a.forEach(u=>{if(n){var f=!1;nr(t,(c,h)=>{(!f||r&&et(u))&&(f=e(u,h),($(f)&&!f.length||N(f)&&!Object.keys(f).length)&&(f=!1),et(f)&&r&&(u=f))}),et(f)?o.push(r?f:u):Xe(f)?s&&!f||!s&&f?o.push(u):i&&(n=!1):o.push(f)}}),o}if(N(a)&&N(t)){var o={},n=!0;return Object.keys(a).forEach(c=>{if(n){var h=e(a[c],t[c]);($(h)&&!h.length||N(h)&&!Object.keys(h).length)&&(h=!1),et(h)?o[c]=r?h:a[c]:Xe(h)?s&&!h||!s&&h?o[c]=a[c]:i&&(n=!1):o[c]=h}}),o}}var Gr=function(a,t,e=!0,r=1){if($(a)&&$(t)&&a.length!==t.length)return!e;if(N(a)&&N(t)){var s=Object.keys(a),i=Object.keys(t);if(!s.length&&!i.length)return ir(a)&&ir(t)?e:a===t===e;if(!Gr(s,i))return!e}if(r>0&&($(a)&&$(t)||N(a)&&N(t))){var o=rs(a,t,(n,u)=>Gr(n,u,e,r-1),!1,!1,!0);return $(o)?o.length===a.length&&o.length===t.length:N(o)&&N(a)?Object.keys(o).length===Object.keys(a).length&&Object.keys(o).length===Object.keys(t).length:o}return F(e)?e(a,t):zt(a)&&zt(t)&&isNaN(a)&&isNaN(t)?e:a===t===e},ss=Gr;function qr(a,t=[]){return te([{},a],(e,r,s)=>{if(!F(s[e]))return F(t)?t(e):$(t)&&t.length?t.indexOf(e)>-1:!0},!1,!1,!1)}function lt(a,t,e=null){return $(t)?a.filter(r=>e?t.filter(s=>e(r,s)).length:t.indexOf(r)!==-1):[]}var ht=class a{static lex(t,e,r={}){if(!Qt(t=t+""))throw new Error("Argument1 must be a string!");var s=f=>({delims:f.delims.slice(),options:qr(f.options),nesting:f.nesting.slice(),maxDepth:f.maxDepth,comments:f.comments.slice(),tokens:f.tokens.slice(),matches:f.matches.slice(),matchesi:qr(f.matchesi)});if(a.$cache[t]&&r.cache!==!1)for(var i=0;i<a.$cache[t].length;i++){var o=a.$cache[t][i];if(ss(o.delims,e))return s(o)}var n=new a(t,r),u=n.lex(e);return r.cache!==!1&&(a.$cache[t]=a.$cache[t]||[],a.$cache[t].push(u)),s(u)}static split(t,e,r){return a.lex(t,e,r).tokens}static match(t,e,r){return a.lex(t,e,r).matches}constructor(t,e){if(!Qt(t))throw new Error("Lexer requires the first argument to be a string.");this.$str=t,this.$options=e||{},this.$options.blocks||(this.$options.blocks=a.$blocks),this.$options.quotes||(this.$options.quotes=a.$quotes),this.$options.comments||(this.$options.comments=a.$comments)}lex(t,e){for(var r={delims:It(t),options:sr(!0,{},this.$options,e||{}),nesting:[],maxDepth:0,comments:[],tokens:[],matches:[],matchesi:{}},s=0;typeof s=="number";)s=this._evalCharsAt(r,s);if(r.nesting.length)throw new Error("Error parsing the string: "+this.$str+". Unterminated blocks: "+Hr(r.nesting).join(", "));return r}_evalCharsAt(t,e){if(!(e>=this.$str.length)){var r=1,s={},i={},o={};if(t.openComment||(i=this._testQuotes(t,e)),t.openQuote||(s=this._testComments(t,e)),t.openComment||s.ending)if(!t.nesting.length&&!o.ending){var n=s.starting||s.ending||this.$str[e];r=n.length,this._push(t,n,"comments",s.starting)}else this._push(t,this.$str[e]);else if(t.openQuote||i.ending)this._push(t,this.$str[e]);else{if(t.options.limit&&t.matches.length===t.options.limit)return this._push(t,this.$str[e]),e+1;o=this._testNesting(t,e);var o=this._testNesting(t,e),u=this._testChars(t.options.stopChars||[],t,e);if(!t.nesting.length&&u!==!1){t.options.stopChar=u,t.options.stopCharForward=this.$str.substr(e);return}if(!t.delims.length)t.nesting.length===2&&o.starting?(t.matches.push(null),this._push(t,o.starting),r=o.starting.length):!t.nesting.length&&o.ending?(this._push(t,o.ending),r=o.ending.length,t.matches.push(null)):this._push(t,this.$str[e]);else if(!t.nesting.length&&!o.ending){this._push(t,"");var f=this._testChars(t.delims,t,e);if(f!==!1&&(t.matches.push(f),t.matchesi[e]=f,r=f.length||1,!t.options.preserveDelims)){var c=e+(f.length||1);return c===this.$str.length&&this._push(t,""),c}this._push(t,f||this.$str[e])}else{var n=o.starting||o.ending||this.$str[e];r=n.length,this._push(t,n)}}return e+r}}_testQuotes(t,e){var r={};return(t.options.quotes||[]).forEach(s=>{this.$str.substr(e,1)===s&&(t.openQuote?s===t.openQuote&&(t.openQuote=!1,r.ending=s):(t.openQuote=s,r.starting=s))}),r}_testComments(t,e){var r={};return(t.options.comments||[]).forEach(s=>{if(t.openComment){if(ct(s)===ct(t.openComment)){var o=ct(s);this.$str.substr(e).startsWith(o)&&(t.openComment=!1,r.ending=o)}}else{var i=Zt(s);this.$str.substr(e).startsWith(i)&&(t.openComment=s,r.starting=i)}}),r}_testNesting(t,e){var r={};return(t.options.blocks||[]).forEach(s=>{let i=Zt(s),o;if(i instanceof RegExp?[o]=i.exec(this.$str.substr(e))||[]:this.$str.substr(e).startsWith(i)&&(o=i),o)t.nesting=t.nesting.concat([s]),r.starting=o;else if(t.nesting.length&&ct(s)===ct(ct(t.nesting))){var n=ct(s),u;n instanceof RegExp?[u]=n.exec(this.$str.substr(e))||[]:this.$str.substr(e).startsWith(n)&&(u=n),u&&(t.nesting=t.nesting.slice(0,-1),r.ending=u)}}),t.maxDepth=Math.max(t.maxDepth,t.nesting.length),r}_testChars(t,e,r){for(var s=0;s<t.length;s++){let n={useRegex:e.options.useRegex,ci:e.options.ci,...N(t[s])?t[s]:{test:t[s]}};if(F(n.test)){var i=n.test(this.$str.substr(0,r),this.$str.substr(r),e.tokens.slice());if(i!==!1)return i;continue}if(n.useRegex){let f=n.useRegex!==!0?n.useRegex:"";var o=this.$str.substr(r).match(new RegExp("^"+n.test,f));if(o&&(!n.backtest||this.$str.substr(0,r).match(new RegExp(n.backtest,f))))return o[0];continue}let u=(f,c)=>n.ci?f.toLowerCase()===c.toLowerCase():f===c;if(u(this.$str.substr(r,n.test.length),n.test)&&(!n.backtest||u(this.$str.substr(r-n.backtest.length,r),n.backtest)))return n.test}return!1}_push(t,e,r="tokens",s=!1){var i=t.matches.length;if(At(t.tokens[i])&&(t.tokens[i]=""),r==="comments"){t.tokens[i].comments||(t.tokens[i]=new String(t.tokens[i]),t.tokens[i].comments=[]);var o=t.tokens[i].comments.length-(!t.tokens[i].comments.length||s?0:1);t.tokens[i].comments[o]=(t.tokens[i].comments[o]||"")+e}else{var n=t.tokens[i].comments;t.tokens[i]=t.tokens[i]+e}}split(t,e,r){return this.lex(e,r).tokens}match(t,e,r){return this.lex(e,r).matches}regParse(t,e){return this.lex(t,sr({useRegex:!0},e||{}))}regSplit(t,e){return this.regParse(t,e).tokens}regMatch(t,e){return this.regParse(t,e).matches}};ht.$blocks=[["(",")"],["[","]"],["{","}"]];ht.$quotes=['"',"'","`"];ht.$comments=[["/*","*/"],["//",`
`]];ht.$cache=Object.create(null);var S=class extends ht{static $blocks=[...ht.$blocks,[new RegExp("^CASE ","i"),new RegExp("^ END","i")]]};function or(a,t,e=!1){if(t=="")return a;var r=e?a.lastIndexOf(t):a.indexOf(t);return r===-1?"":a.substr(r+t.length)}function Vr(a,t,e=!1){if(t=="")return a;var r=e?a.lastIndexOf(t):a.indexOf(t);return r===-1?a:a.substr(0,r)}function Be(a,t,e=null){return $(t)?a.filter(r=>e?t.filter(s=>e(r,s)).length:t.indexOf(r)===-1):[]}function Qr(a,t){return Vr(a,t,!0)}function He(a,t){return a===void 0?"":a.split(/(?=[A-Z])/).join(t||" ")}function Ge(a,t){return typeof a!="string"?a:a.replace(/\w\S*/g,function(e){return e.charAt(0).toUpperCase()+(typeof t!==void 0&&t?e.substr(1).toLowerCase():e.substr(1))})}function qe(a,t){return a=Ge(a.replace(/-/g," ")).replace(/ /g,""),t?a:a[0].toLowerCase()+a.substr(1)}function Q(a,t,e){return Qr(or(a,t),e)}function xt(a,t,e){return a.startsWith(t)&&a.endsWith(e)}var T=class a{#t;#e=[];#r;constructor(t){this.#t=t,this.#r=new Map}static get NODE_NAME(){return He(this.name,"_").toUpperCase()}get NODE_NAME(){return this.constructor.NODE_NAME}get baseClient(){return this.#t?.baseClient||this.#t}get params(){return this.#t?.params||{}}get additionalDetails(){return this.#r}get rootNode(){return this.#t?.contextNode||this}get statementNode(){return this.#t?.statementNode}get contextNode(){return this.#t}capture(t){if(arguments.length!==1)throw new Error("capture() expects exactly 1 parameter.");return this.#t?.$capture(t,this)}bubble(t){if(arguments.length!==1)throw new Error("bubble() expects exactly 1 parameter.");return this.#t?.$bubble?.(t,this)}$capture(t,e){if(arguments.length!==2)throw new Error("$capture() expects exactly 2 parameters.");return this.#t?.$capture?.(t,e)}$bubble(t,e){if(arguments.length!==2)throw new Error("$bubble() expects exactly 2 parameters.");this.#t?.$bubble?.(t,e),e===this&&t==="DISCONNECTED"&&(this.#t=null)}$castInputs(t,e,r,s,i=null,o=null){let n=[].concat(e||[]);if(!n.length)throw new Error("At least one node type must be defined.");if(i&&n.length!==1)throw new Error("Only one Type expected for delegatable operations.");let u={result:r},f=m=>{let l=n.reduce((p,y)=>p||m instanceof y&&m,null);return l||n.reduce((p,y)=>p||y.fromJSON(this,m),null)},c=({returnPairs:m=!1,autoThrow:l=!1})=>{let p=(y,..._)=>n.reduce((E,A)=>E||(()=>{if(A.expose){let g=Object.keys(A.expose).find(L=>L.split("|").includes(y)),C=g&&A.expose[g](this,..._);return C&&[C,C]}if(typeof A.prototype[y]=="function"){let g=new A(this);return[g,g[y](..._)]}})(),null);return new Proxy({},{get:(y,_)=>(...E)=>{let A=p(_,...E);if(A)return u.result=h(u.result,A[0]),m?A:A[1];if(l)throw new Error(`[${this.NODE_NAME}::${s}]: The ${_}(${E}) method is undefined in any of ${n.map(g=>g.name).join(", ")}.`)}})},h=(m,l)=>{if(l?.bubble("CONNECTED"),l&&typeof this.params.nodeCallback=="function"&&this.params.nodeCallback(l),Array.isArray(m)&&l){let p=o?.(l);return p?(p.bubble("DISCONNECTED"),m.map(y=>y===p?l:y)):m.concat(l)}return m&&l!==m&&m.bubble("DISCONNECTED"),l};if(t.length===1&&t[0]===void 0){if(Array.isArray(u.result))throw new Error(`[${this.NODE_NAME}::${s}]: Cannot unset array property.`);return h(u.result,void 0)}let d=new Set;for(let m=0;m<t.length;m++){let l=t[m];if(typeof l=="function"){i?d.add(l):l(c({returnPairs:!1,autoThrow:!0}));continue}if(u.instance=f(l)){u.result=h(u.result,u.instance);continue}let p={};if(N(l)&&!l.nodeName&&(p.keys=Object.keys(l)).length){let _=c({returnPairs:!0,autoThrow:!i}),E=p.keys.shift(),A,[g,C]=_[E](...[].concat(l[E]))||[];if(g){for(;A=p.keys.shift();){let L=C?.[A];if(typeof L!="function")throw new Error(`[${this.NODE_NAME}::${s}][${m+1}/${t.length}]: The implied chaining: ${C.NODE_NAME}.${E}().${A}() is invalid.`);C=L.call(C,...[].concat(l[A])),E=A}continue}}if(i){d.add(l);continue}let y;if(N(l))try{y=JSON.stringify(l)}catch{y=l.constructor.name}else y=l+"";throw new Error(`[${this.NODE_NAME}::${s}][${m+1}/${t.length}]: Arguments must be of type ${n.map(_=>_.name).join(", ")} or a JSON equivalent. Recieved: ${y}`)}if(d.size){let m;return Array.isArray(u.result)?(m=new n[0](this),u.result=h(u.result,m)):(u.result=u.result||new n[0](this),m=u.result),m[i](...d),u.result}return u.result}static getQuoteChars(t,e=!1){return(e&&t?.params?.inputDialect||t?.params?.dialect)==="mysql"&&!t.params.ansiQuotes?["'",'"']:["'"]}static getEscChar(t,e=!1){return(e&&t?.params?.inputDialect||t?.params?.dialect)==="mysql"&&!t.params.ansiQuotes?"`":'"'}get quoteChars(){return this.constructor.getQuoteChars(this)}get escChar(){return this.constructor.getEscChar(this)}static esc(t,e,r=!1){return r||!/^(\*|[\w]+)$/.test(e)?`${t}${(e||"").replace(new RegExp(t,"g"),t.repeat(2))}${t}`:e}static unesc(t,e,r=!1){return(!r||new RegExp(`^${t}.*${t}$`).test(e)&&(e=e.slice(1,-1)))&&e.replace(new RegExp(t.repeat(2),"g"),t)}static parseIdent(t,e,r=!1,s=!0){let i=this.getEscChar(t,s),o=S.split(e,["."]),n=o.map(u=>new RegExp(`^(?:(\\*|[\\w]+)|(${i})((?:\\2\\2|[^\\2])+)\\2)$`).exec(u.trim())).filter(u=>u);return n.length<o.length?[]:n.map(u=>u?.[1]||this.unesc(i,u?.[3],r))}stringifyIdent(t,e=!1){let r=s=>this.constructor.esc(this.escChar,s,e);return Array.isArray(t)?t.filter(s=>s).map(r).join("."):r(t)}static parseString(t,e,r=!1,s=!0){let i=this.getQuoteChars(t,s),o={};for(;(o.quoteChar=i.pop())&&(o.resultString=this.unesc(o.quoteChar,e,r))!==!1;)return[o.resultString,o.quoteChar];return[]}stringifyString(t,e=!1){return this.constructor.esc(this.quoteChars[0],t,e)}withDetail(t,e){return this.#r.set(t,e),this}hasDetail(t){return this.#r.has(t)}getDetail(t){return this.#r.get(t)}withFlag(...t){return t=new Set(t.filter(e=>e)),this.#e=this.#e.reduce((e,r)=>{let s=r.split(":");for(let i of t){let o=i.split(":");o[0]===s[0]&&(r=[...new Set([...s,...o])].join(":"),t.delete(i))}return e.concat(r)},[]).concat(...t),this}hasFlag(t){return!!this.getFlag(t)}getFlag(t){if(!arguments.length)return this.#e;let e=t.toUpperCase().split(":");return this.#e.find(r=>{let s=r.split(":");return e[0]===s[0]&&e.every(i=>s.includes(i))})}$eq(t,e,r=null){if(Array.isArray(t)&&Array.isArray(e))return t.length===e.length&&(e=e.slice(0).sort())&&t.slice(0).sort().every((s,i)=>this.$eq(s,e[i],r));if(t instanceof a&&(t=t.jsonfy()),e instanceof a&&(e=e.jsonfy()),N(t)&&N(e)){let s={};return(s.keys_a=Object.keys(t)).length===(s.keys_b=Object.keys(e)).length&&s.keys_a.reduce((i,o)=>i&&this.$eq(t[o],e[o],r),!0)}return typeof t=="string"&&typeof e=="string"&&r==="ci"?t.toLowerCase()===e.toLowerCase():t===e}identifiesAs(t){if(typeof t>"u")return!1;if(typeof t?.toJSON=="function")return this.$eq(this.jsonfy(),t.jsonfy(),"ci")}contains(t){return t?this===t.contextNode||this.contains(t.contextNode):!1}static fromJSON(t,e,r=null){if(e instanceof a)throw new Error(`Illegal instance passed as JSON: ${e.NODE_NAME}`);if(N(e)&&"nodeName"in e&&e.nodeName!==this.NODE_NAME)return;let s=new this(t).withFlag(...e?.flags||[]);return typeof r=="function"&&r(s),s}jsonfy(t={},e={}){return{...t.nodeNames!==!1?{nodeName:this.NODE_NAME}:{},...typeof e=="function"?e():e,...this.#e.length?{flags:this.#e.slice(0)}:{}}}static parse(t,e,r=null){}toString(){return this.stringify()}toJSON(t=null,e={}){return this.jsonfy(e)}clone(t={}){let e=this.jsonfy(t);return[this.constructor].concat(this.constructor.DESUGARS_TO||[]).reduce((s,i)=>s||i.fromJSON(this.#t,e),void 0)}deSugar(t={}){return t={...t,deSugar:!0},this.clone(t)}};var w=class extends T{#t;name(t){if(!arguments.length)return this.#t;if(typeof t!="string")throw new TypeError(`Invalid argument as identifier name: ${t}.`);return this.#t=t,this}identifiesAs(t){return typeof t=="string"?this.$eq(this.#t,t,"ci"):super.identifiesAs(t)}static fromJSON(t,e,r=null){if(typeof e=="string")e={name:e};else if(typeof e?.name!="string")return;return super.fromJSON(t,e,s=>{s.name(e.name),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,{name:this.#t,...e})}static parse(t,e){if(/^(TRUE|FALSE|NULL)$/i.test(e))return;let[r]=this.parseIdent(t,e).reverse();if(r)return new this(t).name(r)}stringify(){return this.stringifyIdent(this.#t)}};var I=class extends T{static get EXPECTED_TYPES(){return[]}static get TAGS(){return[]}#t=[];[Symbol.iterator](){return this.#t[Symbol.iterator]()}get length(){return this.#t.length}entries(){return this.#t.slice()}add(...t){return this.#t=this.$castInputs(t,this.constructor.EXPECTED_TYPES,this.#t,"add",this.constructor.ARGS_DELEGATION),this}has(t){return!!this.get(t)}get(t){return typeof t=="number"?this.#t[t]:this.#t.find(e=>e.identifiesAs(t))}static fromJSON(t,e,r=null){if(Array.isArray(e?.entries))return super.fromJSON(t,e,s=>{for(let i of e.entries)s.add(i);r?.(s)})}jsonfy(t={},e={},r=null){return super.jsonfy(t,{entries:this.#t.reduce((s,i,o)=>{if(r){let n=r(i,o);if(!n)return s;if(![i,!0].includes(n)){if(n instanceof T)throw new Error("A JSON object not a node instance expected from reducer");return s.concat(n)}}return s.concat(i.jsonfy(t))},[]),...e})}static parse(t,e,r){if(this.CLAUSE){let[n,u]=e.match(new RegExp(`^${this.CLAUSE}([\\s\\S]*)$`,"i"))||[];if(!n)return;e=u.trim()}if(this.TAGS.length){if(!xt(e,...this.TAGS)||S.split(e,[" "]).length>1)return;e=Q(e,...this.TAGS)}let s=S.split(e,[","]);if(this.MIN_ENTRIES&&s.length<this.MIN_ENTRIES)return;let i=new this(t),o=s.map(n=>r(i,n.trim(),this.EXPECTED_TYPES)).filter(n=>n);for(let n of o)i.add(n);return i}stringify(){let t=this.#t.join(", ");if(this.constructor.TAGS.length&&(t=this.constructor.TAGS.join(t)),this.constructor.CLAUSE){if(!this.#t.length&&!this.constructor.TAGS.length)return"";t=`
${this.constructor.CLAUSE} ${t}`}return t}};var ar=class extends Error{};var ur=class extends Error{};var nt=class a extends w{static get PREFIX_TYPE(){return[]}#t;#e;#r;get autoPrefixed(){return this.#e}name(t){return arguments.length&&t!==this.name()&&(this.#r=null),super.name(...arguments)}prefix(t){return t===!0&&!this.#t&&(this.prefix("").schema(),this.#e=!0),!arguments.length||typeof t=="boolean"?this.#t:(this.#t=this.$castInputs([t],this.constructor.PREFIX_TYPE,this.#t,"prefix_spec"),this)}identifiesAs(t){return t instanceof a?this.$eq(this.name(),t.name(),"ci")&&(!t.prefix()||!!this.prefix()?.identifiesAs(t.prefix())):super.identifiesAs(t)}schema(t=null){if(this.#r)return t?t(this.#r)&&[this.#r]||[]:this.#r;let e=f=>{if(f)return this.#r=f,this.#r.name()&&!this.name()&&this.name(this.#r.name()),this.#r},r=this.name(),s=this.constructor.KIND,i=s.toLowerCase(),o=[],n=[];if(!(/(TABLE|DATABASE)/.test(s)&&!this.global)||!(n=[].concat(this.contextNode?.capture(`${s}_SCHEMA`)?.clone()||[])).length){if(!t&&!r)return;let f=c=>c?.[i](r);o=/DATABASE$/.test(s)?[this.capture("ROOT_SCHEMA")]:this.prefix(!0).schema(c=>r?f(c):!0),n=o.reduce((c,h)=>c.concat(r?f(h)||[]:h[`${i}s`]()),[])}if(t){let f=n.filter(t);return f.length===1&&e(f[0]),f}if(n.length>1)throw new ar(`[${this.contextNode?.clone({fullyQualified:!0})}]: ${Ge(i)} ${this.stringifyIdent(r)} is ambiguous. (Is it ${o.map(f=>this.stringifyIdent([f.name(),r])).join(" or ")}?)`);if(!e(n[0]))throw new ur(`[${this.clone({fullyQualified:!0})}]: Unknown ${i}: ${this.stringifyIdent(r)}`);return this.#r}static fromJSON(t,e,r=null){if(typeof e=="string")e={name:e};else if(Array.isArray(e)&&e.some(s=>typeof s=="string")&&(e=e.slice()))e={name:e.pop(),prefix:e.pop()};else if(typeof e?.name!="string")return;return super.fromJSON(t,e,s=>{e.prefix&&s.prefix(e.prefix),r?.(s)})}jsonfy(t={},e={}){let r=((!this.#e||t.deSugar||t.fullyQualified)&&this.#t)?.jsonfy?.(t);return super.jsonfy(t,{...r?.name?{prefix:r}:{},...e})}static parse(t,e,r){if(/^(TRUE|FALSE|NULL)$/i.test(e))return;let[s,...i]=this.parseIdent(t,e).reverse();if(!s)return;let o=new this(t).name(s);return i.length&&o.prefix(i),o}stringify(){return[].concat(!this.#e&&this.#t?.stringify()||[],this.stringifyIdent(this.name())).join(".")}};var Pt=class extends T{static get EXPECTED_TYPES(){return[]}#t;#e;#r;expr(t){return arguments.length?(this.#t=this.$castInputs([t],this.constructor.EXPECTED_TYPES,this.#t,"expr"),this):this.#t}alias(t,e=!0){return!arguments.length||typeof t=="boolean"?this.#e||!t?this.#e:typeof this.#t.prettyName=="function"&&this.#t.prettyName()?this.#t.prettyName():typeof this.#t.name=="function"&&this.#t.name()!=="*"?this.#t.name():void 0:(this.#r=e,this.#e=t,this)}as(...t){return this.alias(...t)}identifiesAs(t){return this.#t?.identifiesAs(t)}schema(){let t=this.expr()?.schema?.()?.clone({fullyQualified:!0});return t&&this.#e?t.name(this.#e):t}static fromJSON(t,e,r=null){return super.fromJSON(t,e,s=>{if(e?.expr?(s.expr(e.expr),(e.alias||e.as)&&s.as(e.alias||e.as,e.claused)):e&&s.expr(e),![nt].some(i=>s.expr()instanceof i)&&!s.expr().isPath&&!s.alias()&&this.requireAliasForNoneIdents)throw new Error(`[${this}]: An alias is required for a non-path properties.`);r?.(s)})}jsonfy(t={},e={}){let r=this.#e||t.deSugar&&this.#t.prettyName?.();return super.jsonfy(t,{expr:this.#t?.jsonfy(t),...r?{alias:r,claused:this.#r}:{},...e})}static parse(t,e,r){let s=new this(t),i=this.getEscChar(t,!0),[,o,n,u,,f]=new RegExp(`^([\\s\\S]+?)(?:(\\s+AS\\s+|(?<!(?:~>|<~|\\:))\\s+)(?:([\\w]+)|(${i})((?:\\4\\4|[^\\4])+)\\4))?$`,"i").exec(e.trim())||[],c,h=u||f;if(h&&!n?.trim()&&!["]","}",")"].includes(o.trim().slice(-1))){try{c=r(s,o,this.EXPECTED_TYPES)}catch{}c||(h=u=f=null,o=e)}if(c||(c=r(s,o,this.EXPECTED_TYPES)),!h&&![nt].some(d=>c instanceof d)&&!c.isPath&&this.requireAliasForNoneIdents)throw new Error(`[${this}]: An alias is required for a non-path properties.`);if(s.expr(c),h){let d=u||this.unesc(i,f),m=!!n?.trim();s.as(d,m)}return s}stringify(){return[this.#t,this.#r?"AS":"",this.#e?this.stringifyIdent(this.#e):null].filter(t=>t).join(" ")}};var de=class extends T{#t;#e=[];status(){return this.#t||"existing"}CDLIgnoreList(){return this.#e.slice()}alterWith(t,e={}){return this.constructor.fromJSON(this,this.renderCDL(t,e))}diffWith(t,e={}){return this.constructor.fromJSON(this,this.generateDiff(t,e))}dirtyCheck(t=!1){return["new","obsolete"].includes(this.#t)?["status"]:[]}dirtyCheckProperties(t){return t.filter(e=>!this.$eq(this[e](),this[`$${e}`](),"ci"))}diffMergeJsons(t,e,r){for(let s of Object.keys(e))if(!["nodeName","flags","CDLIgnoreList","status"].includes(s)&&!(!this.$isDirty(e[s])||this.$eq(t[s],e[s],"ci")))if(r.diff==="reverse"){if(r.honourCDLIgnoreList&&t.CDLIgnoreList?.includes(s))continue;t={...t,[s]:e[s],[`$${s}`]:t[s]}}else t={...t,[r.diff===!1?s:`$${s}`]:e[s]};return t}diffMergeTrees(t,e,r,s){Array.isArray(t)&&(t=new Map(t.map(u=>[u.name().toLowerCase(),u])),e=new Map(e.map(u=>[u.name().toLowerCase(),u])));let[i,o,n]=[new Set,new Set,new Set];for(let u of new Set([...t.keys(),...e.keys()]))!e.has(u)&&t.has(u)?i.add(t.get(u)):e.has(u)&&!t.has(u)?n.add(e.get(u)):o.add(t.get(u));return[...t.entries()].reduce((u,[f,c])=>{if(i.has(c))return u.concat({...c.jsonfy(s),status:"obsolete"});if(o.has(c)){let h=r(c,e.get(f));return Object.keys(h).length?u.concat(h):u}return u},[]).concat([...n].map(u=>({...u.jsonfy(s),status:"new"})))}reverseDiff(t={}){return this.constructor.fromJSON(this.contextNode,this.jsonfy({...t,diff:"reverse"}))}#r=!1;$diffTagHydrate(...t){if(!arguments.length)return this.#r;if(this.$isDirty(t[0])){let e=this.#r;this.#r=!0,t[1](t[0]),this.#r=e}return this}$isDirty(t){return Array.isArray(t)?!!t.length:typeof t<"u"}static fromJSON(t,e,r=null){return super.fromJSON(t,e,s=>{s.#t=e.status,Array.isArray(e.CDLIgnoreList)&&s.#e.push(...e.CDLIgnoreList),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,{...e,...this.#t&&t.diff!==!1?{status:t.diff==="reverse"&&["new","obsolete"].includes(this.#t)?this.#t==="new"?"obsolete":"new":this.#t}:{},...this.#e.length&&t.diff!==!1?{CDLIgnoreList:this.#e.slice()}:{}})}};var ot=class extends de{#t;#e;name(t){return arguments.length?(this.$diffTagHydrate()||this.$nameLock()&&this.#t?this.#e=t:this.#t=t,this):this.#t}$name(){return this.#e||this.#t}identifiesAs(t){return typeof t=="string"?this.$eq(this.#t,t,"ci"):super.identifiesAs(t)}dirtyCheck(t=!1){return super.dirtyCheck(t).concat(this.dirtyCheckProperties(["name"]))}generateDiff(t,e){return this.diffMergeJsons({name:this.$name()},{name:t.$name()},e)}#r=!1;$nameLock(t){if(!arguments.length)return this.#r||!!this.contextNode?.$nameLock?.();if(typeof t=="function"){let e=this.#r;this.#r=!0,t(),this.#r=e}else this.#r=!!t;return this}static fromJSON(t,e,r=null){if(!(e?.name&&typeof e.name!="string")&&!(e?.$name&&typeof e.$name!="string"))return super.fromJSON(t,e,s=>{s.name(e.name),s.$diffTagHydrate(e.$name,i=>s.name(i)),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,this.diffMergeJsons({name:this.#t,...e},{name:this.#e},t))}};var ge=class a extends ot{#t;#e;prefix(t){if(!arguments.length||typeof t=="boolean"){let e=this.#t;if(!e&&t===!0){let r=this.constructor.PREFIX_TYPE[0],s=[];this.contextNode instanceof a&&s.push(this.contextNode.prefix(!0).jsonfy()),this.contextNode instanceof ot?(s.push(this.contextNode.name()),e=r?.fromJSON(this,s)):e=r?.fromJSON(this,"")}return e}return this.$diffTagHydrate()?this.#e=this.$castInputs([t],this.constructor.PREFIX_TYPE,this.#e,"$prefix"):this.#t=this.$castInputs([t],this.constructor.PREFIX_TYPE,this.#t,"prefix"),this}$prefix(...t){return this.#e||this.prefix(...t)}identifiesAs(t){return super.identifiesAs(t)&&(!t?.prefix?.()||!!this.prefix()?.identifiesAs(t.prefix()))}dirtyCheck(t=!1){return super.dirtyCheck(t).concat(this.dirtyCheckProperties(["prefix"]))}generateDiff(t,e){return this.diffMergeJsons({...super.generateDiff(t,e),prefix:this.$prefix(!!t.$prefix())?.jsonfy()},{prefix:t.$prefix()?.jsonfy()},e)}static fromJSON(t,e,r=null){return super.fromJSON(t,e,s=>{e.prefix&&s.prefix(e.prefix),s.$diffTagHydrate(e.$prefix,i=>s.prefix(i)),r?.(s)})}jsonfy(t={},e={}){let r=this.#t||t.fullyQualified?(this.#t||this.prefix(!0)).jsonfy(t):{};return super.jsonfy(t,this.diffMergeJsons({...r.name?{prefix:r}:{},...e},{prefix:this.#e?.jsonfy(t)},t))}};var $t=class extends nt{static get KIND(){return"DATABASE"}prefix(t){}};var U=class extends $t{static get NODE_NAME(){return $t.NODE_NAME}get global(){return!0}};var ee=class extends nt{static get PREFIX_TYPE(){return $t}static get KIND(){return"TABLE"}};var O=class extends ee{static get NODE_NAME(){return ee.NODE_NAME}static get PREFIX_TYPE(){return U}get global(){return!0}};var G=class extends T{#t=[];[Symbol.iterator](){return this.#t[Symbol.iterator]()}get length(){return this.#t.length}actions(){return this.#t}add(...t){if(typeof t[0]=="string"){let e=t.shift(),r=typeof t[t.length-1]=="function"?t.pop():null,s=this.constructor.EXPECTED_TYPES.find(o=>o.CLAUSE===e);if(!s)throw new Error(`Unsupported clause: ${e}`);let i=new s(this,...t);if(this.#t=this.$castInputs([i],this.constructor.EXPECTED_TYPES,this.#t,"actions"),r)r(i);else return i}else this.#t=this.$castInputs(t,this.constructor.EXPECTED_TYPES,this.#t,"actions");return this}static fromJSON(t,e,r=null){if(Array.isArray(e?.actions))return super.fromJSON(t,e,s=>{s.add(...e.actions),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,{actions:this.#t.map(r=>r.jsonfy(t)),...e})}static parse(t,e,r){let s=new this(t);return s.add(...S.split(e,[","]).map(i=>r(s,i.trim(),this.EXPECTED_TYPES)))}stringify(){return this.actions().join(`,
`)}};var D=class extends T{static get CLAUSE(){return this.NODE_NAME}#t;#e;get CLAUSE(){return this.constructor.CLAUSE}get KIND(){return this.#t}get $KIND(){return this.#e||this.KIND}constructor(t,e=null,r=null){super(t),this.#t=e,this.#e=r}static fromJSON(t,e,r=null){if(!(e.clause&&e.clause!==this.CLAUSE))return super.fromJSON(t,e,s=>{s.#t=e.kind,s.#e=e.$kind,r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,{clause:this.CLAUSE,kind:this.#t,...this.#e?{$kind:this.#e}:{},...e})}};var fr=class extends D{#t;value(t){return arguments.length?(this.#t=t,this):this.#t}static fromJSON(t,e,r=null){if(e?.value)return super.fromJSON(t,e,s=>{s.value(e.value),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,{value:this.#t,...e})}static parse(t,e){let[r]=e.match(/DEFERRABLE|NOT\s+DEFERRABLE|INITIALLY\s+DEFERRED|INITIALLY\s+IMMEDIATE|VISIBLE|INVISIBLE/i)||[];if(r)return new this(t).value(r.replace(/\s+/,"_").toUpperCase())}stringify(){return this.#t?.replace(/_/," ")||""}};var Ee=class extends G{static get EXPECTED_TYPES(){return[fr]}};var Se=class extends ot{static get TYPE(){return this.NODE_NAME.replace(/TABLE_|COLUMN_|_CONSTRAINT|_CLAUSE/ig,"")}get TYPE(){return this.constructor.TYPE}renderCDL(t,e){return this.jsonfy(e)}generateCDL(){return Ee.fromJSON(this,{actions:[]})}generateDiff(t,e){return{type:this.TYPE,...super.generateDiff(t,e)}}static fromJSON(t,e,r=null){if(e?.type===this.TYPE)return super.fromJSON(t,e,r)}jsonfy(t={},e={}){return super.jsonfy(t,{type:this.TYPE,...e})}static parse(t,e){let{name:r,expr:s}=this.parseName(t,e,!0);if(!(!s||!new RegExp(`^${this.TYPE==="AUTO_INCREMENT"?this.TYPE:this.TYPE.replace("_","\\s+")}$`,"i").test(s)))return new this(t).name(r)}stringify(){return this.TYPE==="AUTO_INCREMENT"?this.TYPE:`${this.stringifyName()}${this.TYPE.replace("_"," ")}`}static parseName(t,e,r=!1){let s=this.getEscChar(t,r),i=`(?:CONSTRAINT(?:\\s+(\\w+)|\\s+(${s})((?:\\2\\2|[^\\2])+)\\2)\\s+)?`,[,o,,n="",u=""]=e.match(new RegExp(`^${i}([\\s\\S]+)$`,"i"))||[];return{name:o||this.unesc(s,n),expr:u.trim()}}stringifyName(){return this.$name()?`CONSTRAINT ${this.stringifyIdent(this.$name())} `:""}};var Y=class extends Se{get constraintLevel(){return 2}get isColumnLevel(){return this.constructor.checkIsColumn(this.contextNode)}static checkIsColumn(t){return t?.constructor?.NODE_NAME==="COLUMN_SCHEMA"}static fromJSON(t,e,r=null){if(e?.type===this.TYPE)return!("name"in e)&&t?.params?.dialect!=="mysql"&&(e={name:`auto_name_${(0|Math.random()*9e6).toString(36)}`,...e}),super.fromJSON(t,e,r)}jsonfy(t={},e={}){let r=super.jsonfy(t,e);return!("name"in r)&&this.params.dialect!=="mysql"&&(r={name:void 0,...r}),r}};var vt=a=>class extends a{#t=[];#e=[];columns(t){if(this.isColumnLevel){if(arguments.length)throw new Error('The "columns" attributes for column-level constraints is implicit.');return[this.contextNode.name()]}if(!arguments.length)return this.#t;if(!Array.isArray(t)||!t.length)throw new Error("Columns list must be a non-empty array");return this.$diffTagHydrate()?this.#e=t:this.#t=t,this}$columns(){return this.#e.length?this.#e:this.columns()}dirtyCheck(t=!1){return super.dirtyCheck(t).concat(this.dirtyCheckProperties(["columns"]))}generateDiff(t,e){return this.isColumnLevel?super.generateDiff(t,e):this.diffMergeJsons({...super.generateDiff(t,e),columns:this.$columns()},{columns:t.$columns()},e)}resolveColumnReferences(t,e,r=!1){return t.reduce((s,i)=>{let o=e.filter(n=>["DROP","RENAME"].includes(n.CLAUSE)&&n.KIND==="COLUMN"&&n.reference().identifiesAs(i)).reduce((n,u)=>u.CLAUSE==="DROP"?[u].concat(n):n.concat(u),[]);if(!o.length)return s.concat(i);if(o[0].CLAUSE==="DROP"){if(!o[0].hasFlag("CASCADE")&&r)throw new Error(`Cannot drop column ${o[0].reference()} because other objects depend on it.`);return s}if(o[0].CLAUSE==="RENAME")return s.concat(o[0].argument().name())},[])}static fromJSON(t,e,r=null){if(!(!this.checkIsColumn(t)&&!Array.isArray(e.columns)))return super.fromJSON(t,e,s=>{!this.checkIsColumn(t)&&Array.isArray(e.columns)&&s.columns(e.columns),this.checkIsColumn(t)||s.$diffTagHydrate(e.$columns,i=>s.columns(i)),r?.(s)})}jsonfy(t={},e={}){if(this.isColumnLevel&&!t.withColumns)return super.jsonfy(t,e);let r=super.jsonfy(t,this.diffMergeJsons({columns:this.columns().slice(),...e},{columns:this.#e.slice()},t));if(!t.tableCDL)return r;let s=this.resolveColumnReferences(r.columns,t.tableCDL.actions());return s.length!==r.columns.length?t.diff?{...r,status:"obsolete"}:void 0:(lt(s,r.columns).length!==r.columns.length&&(r=this.diffMergeJsons(r,{columns:s},t),t.diff!==!1&&(r.CDLIgnoreList||(r.CDLIgnoreList=[]),r.CDLIgnoreList.push("columns"))),r)}static parseColumns(t,e,r=!0){return S.split(Q(e,"(",")"),[","]).map(s=>this.parseIdent(t,s.trim(),!1,r)[0])}stringifyColumns(){return` (${this.$columns().map(t=>this.stringifyIdent(t)).join(", ")})`}};var Ut=class extends vt(Y){static parse(t,e,r){let{name:s,expr:i}=this.parseName(t,e,!0);if(!i||!/^PRIMARY\s+KEY/i.test(i))return;let o=new this(t).name(s);if(this.checkIsColumn(t))return o;let[,n]=S.split(e,[]);return o.columns(this.parseColumns(o,n))}stringify(){return`${this.stringifyName()}PRIMARY KEY${this.isColumnLevel?"":this.stringifyColumns()}`}};var q=a=>class extends a{#t;get REF_TYPES(){return this.constructor.REF_TYPES[this.KIND]}reference(t){return arguments.length?(this.#t=this.$castInputs([t],this.REF_TYPES,this.#t,"reference"),this):this.#t}static fromJSON(t,e,r=null){return super.fromJSON(t,e,s=>{e.reference&&s.reference(e.reference),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,{reference:this.#t?.jsonfy(t),...e})}};var P=a=>class extends a{#t;get EXPECTED_TYPES(){return this.constructor.EXPECTED_TYPES[this.KIND]}argument(t){return arguments.length?(this.#t=this.$castInputs([t],this.EXPECTED_TYPES,this.#t,"argument"),this):this.#t}static fromJSON(t,e,r=null){if(e?.argument)return super.fromJSON(t,e,s=>{s.argument(e.argument),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,{argument:this.#t?.jsonfy(t),...e})}};var ye=class extends q(P(D)){static parse(t,e,r){let[,s,i,o]=e.match(new RegExp(`^ALTER\\s+(${Object.keys(this.EXPECTED_TYPES).join("|")})\\s+([\\s\\S]+?)\\s+([\\s\\S]+)$`,"i"))||[];if(!i)return;let n=new this(t,s.toUpperCase());return n.reference(r(n,i,this.REF_TYPES[n.KIND])),n.argument(r(n,o,this.EXPECTED_TYPES[n.KIND])),n}};var cr=a=>class extends a{#t=new Set;get statementNode(){return this}get querySugars(){return this.#t}get hasSugars(){return this.isSugar||!!this.#t.size}$bubble(t,e){if(["CONNECTED","DISCONNECTED"].includes(t)&&e.isSugar){t==="DISCONNECTED"?this.#t.delete(e):this.#t.add(e);return}return super.$bubble(t,e)}};var rt=a=>class extends a{get isSugar(){return!0}};var k=a=>class extends cr(rt(a)){static get CLAUSE(){return this.NODE_NAME.replace(/_DATABASE|_TABLE/gi,"")}#t;get statementType(){return"DDL"}returning(t){if(!arguments.length)return this.#t;if(!/^SCHEMA|SAVEPOINT$/i.test(t))throw new Error("Unsupported value for a RETURNING clause.");return this.#t=t.toUpperCase(),this}static fromJSON(t,e,r=null){let[s]=this.NODE_NAME.match(/DATABASE|TABLE/);return super.fromJSON(t,{...e,kind:e.kind||(s==="DATABASE"?"SCHEMA":s)},i=>{e.returningClause&&i.returning(e.returningClause),r?.(i)})}jsonfy(t,e){return super.jsonfy(t,()=>({...this.#t&&!t.deSugar?{returningClause:this.#t}:{},...e()}))}static parse(t,e,r){let s;/^CREATE|ALTER|DROP|RENAME/.test(e)&&([e,s]=S.split(e,["RETURNING"],{useRegex:"i"}).map(o=>o.trim()));let i=super.parse(t,e,r);return s&&i?.returning(s),i}stringify(){let t=super.stringify();return this.#t?`${t} RETURNING ${this.#t}`:t}};var Mt=class extends vt(Y){static parse(t,e,r){let{name:s,expr:i}=this.parseName(t,e,!0);if(!i||!/^UNIQUE(\s+KEY)?/i.test(i))return;let o=new this(t).name(s);if(this.checkIsColumn(t))return o;let[,n]=S.split(e,[]);return o.columns(this.parseColumns(o,n))}stringify(){return`${this.stringifyName()}UNIQUE${this.isColumnLevel?"":this.stringifyColumns()}`}};var b=class extends nt{static get PREFIX_TYPE(){return ee}static get KIND(){return"COLUMN"}#t;prettyName(t){if(!arguments.length)return this.#t;if(typeof t!="string")throw new TypeError(`Invalid argument as prettyName: ${t}.`);return this.#t=t,this}identifiesAs(t){return super.identifiesAs(t)||this.$eq(this.#t,t,"ci")}static fromJSON(t,e,r=null){return super.fromJSON(t,e,s=>{typeof e?.prettyName=="string"&&s.prettyName(e.prettyName),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,{...this.#t?{prettyName:this.#t}:{},...e})}};var Jt=a=>class extends a{#t;#e;#r=new Set;$bubble(t,e){return["CONNECTED","DISCONNECTED"].includes(t)&&e instanceof b&&(t==="DISCONNECTED"?this.#r.delete(e.name().toLowerCase()):this.#r.add(e.name().toLowerCase())),super.$bubble(t,e)}expr(t){return arguments.length?(this.$diffTagHydrate()?this.#e=this.$castInputs([t],x,this.#e,"$expr"):this.#t=this.$castInputs([t],x,this.#t,"expr"),this):this.#t}$expr(){return this.#e??this.#t}columns(){if(arguments.length)throw new Error('The "columns" attributes for CHECK constraints is implicit.');return[...this.#r]}dirtyCheck(t=!1){return super.dirtyCheck(t).concat(this.dirtyCheckProperties(["expr"]))}generateDiff(t,e){return this.diffMergeJsons({...super.generateDiff(t,e),expr:this.$expr()?.jsonfy(e)},{expr:t.$expr()?.jsonfy(e)},e)}static fromJSON(t,e,r=null){if(!(typeof e?.expr>"u"))return super.fromJSON(t,e,s=>{s.expr(e.expr),s.$diffTagHydrate(e.$expr,i=>s.expr(i)),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,this.diffMergeJsons({expr:this.#t?.jsonfy(t),...e},{expr:this.#e?.jsonfy(t)},t))}static parse(t,e,r){let{name:s,expr:i}=this.parseName(t,e,!0);if(!i||!(i=i.match(new RegExp(`^${this.TYPE.replace(/_/g,"\\s+")}\\s+([\\s\\S]+)$`,"i"))?.[1]))return;let o=new this(t);return o.expr(r(o,i)).name(s)}stringify(){return`${super.stringify()} ${this.$expr()}`}};var Ft=class extends Jt(Y){$columns(){return this.columns()}stringify(){return`${super.stringifyName()}CHECK (${this.$expr()})`}};var K=class extends Se{get constraintLevel(){return 1}};var mt=class extends K{#t;#e;always(t){if(!arguments.length)return this.#t;if(typeof t!="boolean")throw new Error('The "always" directive must be of type boolean');return this.$diffTagHydrate()?this.#e=t:this.#t=t,this}$always(){return this.#e??this.#t}dirtyCheck(t=!1){return super.dirtyCheck(t).concat(this.dirtyCheckProperties(["always"]))}generateDiff(t,e){return this.diffMergeJsons({...super.generateDiff(t,e),always:this.$always()},{always:t.$always()},e)}static fromJSON(t,e,r=null){return super.fromJSON(t,e,s=>{s.always(!!e.always),s.$diffTagHydrate(e.$always,i=>s.always(i)),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,this.diffMergeJsons({always:this.#t,...e},{always:this.#e},t))}static parse(t,e){let{name:r,expr:s}=this.parseName(t,e,!0);if(!(!s||!(s=s.match(new RegExp("^GENERATED\\s+(ALWAYS|BY[ ]+DEFAULT)(?:\\s+AS\\s+IDENTITY)?$","i"))?.[1])))return new this(t).name(r).always(/^ALWAYS$/i.test(s))}stringify(){return this.params.dialect==="mysql"?new Ne(this.CONTEXT).stringify():`GENERATED ${this.$always()?"ALWAYS":"BY DEFAULT"} AS IDENTITY`}};var Ne=class extends K{static get TYPE(){return"AUTO_INCREMENT"}stringify(){return this.params.dialect!=="mysql"?new mt(this.contextNode).stringify():"AUTO_INCREMENT"}};var Te=class extends Jt(K){#t;#e;stored(t){if(!arguments.length)return this.#t;if(typeof t!="boolean")throw new Error('The "stored" directive must be of type boolean');return this.$diffTagHydrate()?this.#e=t:this.#t=t,this}$stored(){return this.#e??this.#t}dirtyCheck(t=!1){return super.dirtyCheck(t).concat(this.dirtyCheckProperties(["stored"]))}generateDiff(t,e){return this.diffMergeJsons({...super.generateDiff(t,e),stored:this.$stored()},{stored:t.$stored()},e)}static fromJSON(t,e,r=null){return super.fromJSON(t,e,s=>{s.stored(!!e.stored),s.$diffTagHydrate(e.$stored,i=>s.stored(i)),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,this.diffMergeJsons({stored:this.#t,...e},{stored:this.#e},t))}static parse(t,e,r){let s,{name:i,expr:o}=this.parseName(t,e,!0);if([,o,s=""]=o.match(new RegExp("^GENERATED\\s+ALWAYS\\s+AS\\s+\\(([\\s\\S]+)\\)(?:\\s+(VIRTUAL|STORED))?$","i"))||[],!o)return;let n=new this(t);return n.expr(r(n,o)).stored(/^STORED$/i.test(s)).name(i)}stringify(){return`GENERATED ALWAYS AS (${this.$expr()})${this.$stored()?" STORED":""}`}};var _e=class extends Jt(K){};var Ce=class extends K{};var lr=class extends Jt(K){};var hr=class extends K{};var mr=class extends P(D){static get EXPECTED_TYPES(){return{CONSTRAINT:[mt]}}get $KIND(){return this.argument()?.TYPE}static parse(t,e,r){let[,s]=e.match(/^ADD\s+([\s\S]+)$/i)||[];if(s){let i=new this(t,"CONSTRAINT");return i.argument(r(i,s,this.EXPECTED_TYPES.CONSTRAINT))}}};var pr=class extends D{static get EXPECTED_KINDS(){return{CONSTRAINT:["IDENTITY","EXPRESSION","DEFAULT","NOT_NULL"]}}static parse(t,e){let[,r]=e.match(new RegExp(`^DROP\\s+(${this.EXPECTED_KINDS.CONSTRAINT.map(s=>s.replace(/(?<!AUTO)_/gi,"\\s+")).join("|")})$`,"i"))||[];if(r)return new this(t,"CONSTRAINT",r.replace(/\s+/,"_").toUpperCase())}stringify(){return`DROP ${this.$KIND.replace(/(?<!AUTO)_/gi," ")}`}};var Ae=class extends T{#t;value(t){return arguments.length?(this.#t=t,this):this.#t}identifiesAs(t){return t===this.#t||super.identifiesAs(t)}static get expose(){return{null:t=>this.fromJSON(t,{value:null}),literal:(t,e)=>this.fromJSON(t,{value:e})}}static fromJSON(t,e,r=null){if(!(typeof e?.value!="string"&&![null].includes(e?.value)||Object.keys(e).filter(s=>s!=="nodeName").length>1))return super.fromJSON(t,e,s=>{s.value(e.value),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,{value:this.#t,...e})}static parse(t,e){let r=new this(t);return/^NULL$/i.test(e)?r.value(null):r.value(e)}stringify(){return`${this.#t}`}};var Ot=class extends T{#t=[];constructor(t,e){super(t),this.#t=e}name(){return this.#t}static fromJSON(t,e){let r=[].concat(e);if(typeof r[0]!="string")return;let[s,i,o]=as.call(this,r[0]);return s?new this(t,zr(s,...i.split(","),...o,...r.slice(1))):new this(t,zr(...[].concat(e)))}jsonfy(){return this.#t.length===1?this.#t[0]:this.#t}static parse(t,e){let[r,s,i]=as.call(this,e);if(r)return new this(t,zr(r,...s.split(","),...i))}stringify(){let[t,e]=this.#t.slice(1).reduce(([r,s],i)=>/^\d+$/.test(i)?[r.concat(i),s]:[r,s.concat(i)],[[],[]]);return`${this.#t[0]}${t.length?`(${t.join(",")})`:""}${e.length?` ${e.join(" ")}`:""}`}static pgFixedTypesRe=/^(bigint|int8|bigserial|serial8|boolean|bool|box|bytea|cidr|circle|date|double\s+precision|float8|inet|integer|int|int4|jsonb|json|line|lseg|macaddr8|macaddr|money|path|pg_lsn|pg_snapshot|point|polygon|real|float4|smallint|int2|smallserial|serial2|serial4|serial|text|timetz|timestamptz|tsquery|tsvector|txid_snapshot|uuid|xml)$/;static pgVariableTypesRe=/^(bit\s+varying|bit|varbit|character\s+varying|character|char|varchar|interval|numeric|timestamp|time)(?:\s+)?(?:\(([\d, ]+)\))?(\s+(?:with|without)\s+time\s+zone)?$/;static myFixedTypesRe=/^(tinyint|smallint|mediumint|enum|set|tinyblob|mediumblob|longblob|geometry|longstring|geometrycollection|multilinestring|multipoint|multipolygon)$/;static myVariableTypesRe=/^(float|decimal|double|tinytext|mediumtext|longtext|binary|varbinary|blob)(?:\s+)?(?:\(([\d, ]+)\))?$/},zr=(...a)=>a.map(t=>/^\d+$/.test(t)?parseFloat(t):t?.trim().replace(/\s+/," ").toUpperCase()).filter(t=>t);function as(a){let t,e,r;for(let s of["pgFixedTypesRe","pgVariableTypesRe","myFixedTypesRe","myVariableTypesRe"])if([,t,e="",...r]=a.match(new RegExp(this[s].source,"i"))||[],t)break;return[t,e,r]}var dr=class extends P(D){static get EXPECTED_TYPES(){return{FLAG:[Ae],DATA_TYPE:[Ot],CONSTRAINT:[mt,Te,_e,Ce]}}static parse(t,e,r){let[,s,i]=new RegExp("^(SET|TYPE)\\s+([\\s\\S]+)$","i").exec(e)||[];if(!s)return;let o,n,u;if(o=i.match(/^DATA\s+TYPE\s+([\s\S]+)$/i))n="DATA_TYPE",u=o[1];else if(/^TYPE$/i.test(s))n="DATA_TYPE",u=i;else if(o=i.match(/^GENERATED\s+([\s\S]+)$/i))n="IDENTITY",u=`GENERATED ${o[1]} AS IDENTITY`;else if(o=i.match(/^EXPRESSION\s+AS\s+([\s\S]+)$/i))n="EXPRESSION",u=`GENERATED ALWAYS AS ${o[1]} STORED`;else if(o=i.match(/^(DEFAULT|NOT\s+NULL)[\s\S]+$/i))n=o[1].replace(/\s+/g,"_").toUpperCase(),u=i;else{let[,c,h]=i.match(/(\w+)(?:\s+)?(.+)/);return new this(t,"FLAG",c.toUpperCase()).argument(m=>m.literal(h))}let f=new this(t,n==="DATA_TYPE"?n:"CONSTRAINT",n);return f.argument(r(f,u,this.EXPECTED_TYPES[f.KIND]))}stringify(){let t=this.$KIND.replace(/(?<!AUTO)_/gi," "),e=this.argument();return this.KIND==="DATA_TYPE"?e=`${t} ${e}`:this.$KIND==="EXPRESSION"?e=`${t} AS ${this.argument().$expr()}`:this.$KIND==="IDENTITY"&&(e=`GENERATED ${this.argument().$always()?"ALWAYS":"BY DEFAULT"}`),`SET ${e}`}};var xe=class extends G{static get EXPECTED_TYPES(){return[mr,pr,dr]}};var W=class extends ge{static get CONSTRAINT_TYPES(){return[Ne,mt,Te,_e,Ce,hr,lr,Ut,bt,Mt,Ft]}static get PREFIX_TYPE(){return[O]}#t;#e;#r=[];type(t){return arguments.length?(this.$diffTagHydrate()?this.#e=this.$castInputs([t],Ot,this.#e,"$type"):this.#t=this.$castInputs([t],Ot,this.#t,"type"),this):this.#t}$type(){return this.#e||this.#t}autoIncrement(...t){return this.constraint("AUTO_INCREMENT",...t)}identity(...t){return this.constraint("IDENTITY",...t)}expression(...t){return this.constraint("EXPRESSION",...t)}default(...t){return this.constraint("DEFAULT",...t)}notNull(...t){return this.constraint("NOT_NULL",...t)}null(...t){return this.constraint("NULL",...t)}onUpdate(...t){return this.constraint("ON_UPDATE",...t)}primaryKey(...t){return this.constraint("PRIMARY_KEY",...t)}foreignKey(...t){return this.constraint("FOREIGN_KEY",...t)}uniqueKey(...t){return this.constraint("UNIQUE_KEY",...t)}check(...t){return this.constraint("CHECK",...t)}constraint(t,...e){if(typeof t=="string"){let r=this.#r.find(s=>s.TYPE===t);if(!e.length)return r;if(e[0]===!1)return this.#r=this.#r.filter(s=>s!==r),r?.bubble("DISCONNECTED"),this;t={type:t,...["CHECK","DEFAULT","EXPRESSION","ON_UPDATE"].includes(t)&&!(N(e[0])&&e[0].expr)?{expr:e[0]}:typeof e[0]=="object"?e[0]:{}}}return this.#r=this.$castInputs([t],this.constructor.CONSTRAINT_TYPES,this.#r,"constraint",null,r=>this.#r.find(s=>s.TYPE===r.TYPE)),this}constraints(t=!0,e=0){let r=e?this.#r.filter(s=>s instanceof Y==(e===2)):this.#r;return t?r:r.map(s=>s.TYPE)}dirtyCheck(t=!1){let e=super.dirtyCheck(t).concat(this.dirtyCheckProperties(["type"]));return t?e.concat(["constraints"].filter(r=>this[r]().some(s=>s.dirtyCheck(t).length))):e}renderCDL(t,e){let r=this.jsonfy(e);for(let s of t)s.CLAUSE==="ADD"?s.$KIND==="IDENTITY"&&(r=this.diffMergeJsons(r,{identity:{always:s.argument().always(),...e.diff!==!1?{status:"new"}:{}}})):s.CLAUSE==="SET"?s.KIND==="DATA_TYPE"?r=this.diffMergeJsons(r,{type:s.argument().jsonfy(e)}):s.$KIND==="IDENTITY"?r=this.diffMergeJsons(r,{identity:{always:s.argument().always()}}):s.$KIND==="EXPRESSION"?r=this.diffMergeJsons(r,{expression:{expr:s.argument().expr().jsonfy(e)}}):s.$KIND==="DEFAULT"&&(r=this.diffMergeJsons(r,{default:{expr:s.argument().expr().jsonfy(e)}})):s.CLAUSE==="DROP"&&(r=e.diff===!1?r:this.diffMergeJsons(r,{[s.$KIND.toLowerCase()]:{status:"obsolete"}}));return r}generateCDL(t={}){let e=xe.fromJSON(this,{actions:[]});this.#e&&!this.$eq(this.#e,this.#t,"ci")&&e.add("SET","DATA_TYPE",r=>r.argument(this.#e.jsonfy(t)));for(let r of this.#r)if(r.constraintLevel!==2)if(r.status()==="obsolete")e.add("DROP",r.TYPE);else if(r.status()==="new")e.add("ADD",r.TYPE,s=>s.argument(r.jsonfy({...t,diff:!1})));else{if(!r.dirtyCheck().length)continue;e.add("SET","CONSTRAINT",r.TYPE,i=>i.argument(r.jsonfy({...t,diff:!1})))}return e}generateDiff(t,e){let r=this.diffMergeJsons({...super.generateDiff(t,e),type:this.$type()?.jsonfy(e)},{type:t.$type()?.jsonfy(e)},e),s=this.flattenConstraintJsons(this.diffMergeTrees(new Map(this.#r.map(i=>[i.TYPE,i])),new Map(t.constraints().map(i=>[i.TYPE,i])),(i,o)=>i.generateDiff(o,e)),e);return{...r,...s}}flattenConstraintJsons(t){let e={};for(let r of t){let{type:s,...i}=r,o=qe(s.toLowerCase().replace("_"," "));e={...e,[o]:Object.keys(i).filter(n=>i[n]!==void 0).length?i:!0}}return e}static unflattenConstraintJsons(t){return Object.entries(t).map(([e,r])=>{let s=i=>{throw new Error(`Invalid ${i?`or missing attribute "${i}"`:"format"} for constraint "${e}"`)};if(e=He(e+"","_").toUpperCase(),r=r===!0?{}:r===!1?{status:"obsolete"}:r,["CHECK","EXPRESSION","DEFAULT","ON_UPDATE"].includes(e))(!N(r)||!r.expr)&&(r={expr:r});else if(e==="FOREIGN_KEY")O.fromJSON({},r?.targetTable)||s("targetTable"),Array.isArray(r?.targetColumns)||s("targetColumns");else if(["PRIMARY_KEY","UNIQUE_KEY","IDENTITY","NOT_NULL","NULL","AUTO_INCREMENT"].includes(e))N(r)||s();else throw new Error(`Unknown attribute or constraint: ${e}`);return{type:e,...r}})}static fromJSON(t,e,r=null){let{nodeName:s,name:i,$name:o,prefix:n,$prefix:u,type:f,$type:c,status:h,CDLIgnoreList:d,...m}=e;if(Ot.fromJSON({},f))return super.fromJSON(t,e,l=>{l.type(f),l.$diffTagHydrate(c,p=>l.type(p));for(let p of this.unflattenConstraintJsons(m))l.constraint(p);r?.(l)})}jsonfy(t={},e={},r=null){let s=this.#r.reduce((i,o,n)=>{if(r){let u=r(o,n);if(!u)return i;if(![o,!0].includes(u)){if(u instanceof T)throw new Error("A JSON object not a node instance expected from reducer");return i.concat(u)}}return i.concat(o.jsonfy(t)||[])},[]);return super.jsonfy(t,{type:this.#t?.jsonfy(t),...this.#e?{$type:this.#e.jsonfy(t)}:{},...this.flattenConstraintJsons(s),...e})}static parse(t,e,r){let[s,i]=S.split(e,["\\s+"],{useRegex:!0,limit:1}),[o]=this.parseIdent(t,s.trim());if(!o)return;let n=new this(t).name(o),u="(CONSTRAINT\\s+.+?\\s+)?",f=[{test:`${u}(PRIMARY[ ]+KEY|NOT[ ]+NULL|GENERATED|REFERENCES|UNIQUE(?:[ ]+KEY)?|CHECK|AUTO_INCREMENT)`},{backtest:"^(?!.*\\s+(NOT|SET)\\s+$)",test:`${u}NULL`},{backtest:"^(?!.*\\s+BY\\s+$)",test:`${u}DEFAULT`},{backtest:"^(?!.*\\s+REFERENCES\\s+)",test:"ON\\s+UPDATE"}],[c,...h]=S.split(i,f,{useRegex:"i",preserveDelims:!0});n.type(r(n,c.trim(),[Ot]));for(let d of h){let m=r(n,d,this.CONSTRAINT_TYPES);n.constraint(m)}return n}stringify(){let t=this.#r;return this.params.dialect==="mysql"&&(t=t.filter(e=>e.TYPE!=="FOREIGN_KEY")),`${this.stringifyIdent(this.$name())} ${this.$type()}${t.length?` ${t.join(" ")}`:""}`}};var gr=class extends D{#t;value(t){return arguments.length?(this.#t=t,this):this.#t}static fromJSON(t,e,r=null){if(e?.value)return super.fromJSON(t,e,s=>{s.value(e.value),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,{value:this.#t,...e})}static parse(t,e){let[r]=e.match(/TODO/i)||[];if(r)return new this(t).value(r.replace(/\s+/,"_").toUpperCase())}stringify(){return this.#t?.replace(/_/," ")||""}};var $e=class extends G{static get EXPECTED_TYPES(){return[gr]}};var at=class extends vt(ot){#t;#e;type(t){if(!arguments.length)return this.#t;if(typeof t!="string")throw new Error(`The "type" directive must be of type string. Recieved ${t}`);return this.$diffTagHydrate()?this.#e=t:this.#t=t,this}$type(){return this.#e??this.#t}dirtyCheck(t=!1){return super.dirtyCheck(t).concat(this.dirtyCheckProperties(["type"]))}renderCDL(t,e){return this.jsonfy(e)}generateCDL(){return $e.fromJSON(this,{actions:[]})}generateDiff(t,e){return this.diffMergeJsons({...super.generateDiff(t,e),type:this.$type()},{type:t.$type()},e)}static fromJSON(t,e,r=null){if(/^(INDEX|KEY|FULLTEXT)$/i.test(e.type))return super.fromJSON(t,e,s=>{s.type(e.type),s.$diffTagHydrate(e.$type,i=>s.type(i)),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,{type:this.#t,...this.#e?{$type:this.#e}:{},...e})}static checkIsColumn(t){return!1}static parse(t,e){let[r,s,i]=/^((?:(?:FULLTEXT|SPATIAL)(?:\s+INDEX|\s+KEY)?)|(?:INDEX|KEY))([\s\S]+)$/i.exec(e)||[];if(!r)return;let o=new this(t),[n,u]=S.split(i,[]),[f]=this.parseIdent(t,n.trim());return o.type(s.replace(/\s+(INDEX|KEY)/i,"").toUpperCase()).columns(this.parseColumns(o,u)).name(f)}stringify(){return`${this.$type()}${this.$name()?` ${this.stringifyIdent(this.$name())}`:""}${this.stringifyColumns()}`}};var Oe=class extends P(D){static get EXPECTED_TYPES(){return{COLUMN:[W],CONSTRAINT:[Ut,bt,Mt,Ft],INDEX:[at]}}static get REF_TYPES(){return{COLUMN:[b],CONSTRAINT:[w],INDEX:[w]}}get $KIND(){return this.KIND==="COLUMN"?this.argument()?.type()?.name():this.argument()?.TYPE}#t;#e;first(t){return arguments.length?(this.#t=!!t,this):this.#t}after(t){return arguments.length?(this.#e=this.$castInputs([t],this.constructor.REF_TYPES[this.KIND],this.#e,"ref"),this):this.#e}static fromJSON(t,e,r=null){return super.fromJSON(t,e,s=>{e.first&&s.first(!0),e.after&&s.after(e.after),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,{...this.#t?{first:!0}:{},...this.#e?{after:this.#e.jsonfy(t)}:{},...e})}static parse(t,e,r,s=null){let i,[,o,n,u,f]=e.match(new RegExp(`^${this.CLAUSE}\\s+(?:(${Object.keys(this.EXPECTED_TYPES).join("|")})\\s+)?([\\s\\S]+?)(?:\\s+AFTER\\s+(.+)|\\s+(FIRST))?$`,"i"))||[];if(o||(/^(PRIMARY|FOREIGN|UNIQUE|CHECK)/i.test(n)?(o="CONSTRAINT",i=!0):/^(FULLTEXT|SPATIAL)/i.test(n)?(o="INDEX",i=!0):n&&(o="COLUMN")),!o)return;let c=new this(t,o.toUpperCase());if(c.CLAUSE==="ADD"){let[,d,m]=n.match(/(IF\s+NOT\s+EXISTS\s+)?([\s\S]+)$/i);d&&c.withFlag("IF_NOT_EXISTS"),n=m}u?c.after(r(c,u,this.REF_TYPES[c.KIND])):f&&c.first();let h=(s||r)(c,c.KIND==="COLUMN"||i?n:`${c.KIND} ${n}`,this.EXPECTED_TYPES[c.KIND]);return c.argument(h)}stringify(){let t=[this.CLAUSE];return this.hasFlag("IF_NOT_EXISTS")&&t.push("IF NOT EXISTS"),t.push(this.argument()),this.#t?t.push("FIRST"):this.#e&&t.push("AFTER",this.#e),t.join(" ")}};var be=class extends Oe{};var Er=class extends q(be){static parse(t,e,r){return super.parse(t,e,r,(s,i,o)=>{let[n,u]=Lexer.split(i,["\\s+"],{useRegex:!0,limit:1});return s.reference(r(s,n,this.REF_TYPES[s.KIND])),r(s,u,o)})}stringify(){return super.stringify().replace(this.KIND,`${this.KIND} ${this.reference()}`)}};var Sr=class extends q(D){static get EXPECTED_KINDS(){return{COLUMN:["COLUMN"],CONSTRAINT:["PRIMARY_KEY","FOREIGN_KEY","UNIQUE_KEY","CHECK"],INDEX:["INDEX"]}}static get REF_TYPES(){return{COLUMN:[b],CONSTRAINT:[w],INDEX:[w]}}static parse(t,e,r){let s=Object.keys(this.EXPECTED_KINDS),i=t?.params?.dialect==="mysql"?[...new Set(s.reduce((l,p)=>l.concat(p,this.EXPECTED_KINDS[p]),[]))]:s,[o,n="COLUMN",u,f,c]=e.match(new RegExp(`^DROP(?:\\s+(${i.map(l=>l.replace(/_/gi,"\\s+")).join("|")})(\\s+IF\\s+EXISTS)?)?(?:\\s+([\\s\\S]+?)(?:\\s+(RESTRICT|CASCADE|FORCE))?)?$`,"i"))||[];if(!o)return;let h=n.replace(/\s+/g,"_").toUpperCase(),d=s.includes(h)?h:s.find(l=>this.EXPECTED_KINDS[l].includes(h));if(!d)return;let m=new this(t,d,h);return u&&m.withFlag("IF_EXISTS"),c&&m.withFlag(c),f&&m.reference(r(m,f,this.REF_TYPES[d])),m}stringify(){let t=["DROP",this.params.dialect==="mysql"?this.$KIND.replace(/_/g," "):this.KIND];return this.hasFlag("IF_EXISTS")&&t.push("IF EXISTS"),this.reference()&&t.push(this.reference()),this.hasFlag("RESTRICT")?t.push("RESTRICT"):this.hasFlag("CASCADE")?t.push("CASCADE"):this.hasFlag("FORCE")&&t.push("FORCE"),t.join(" ")}};var yr=class extends P(D){static get EXPECTED_TYPES(){return{SCHEMA:[$t]}}static parse(t,e,r){let[,s,i]=new RegExp(`^SET\\s+(${Object.keys(this.EXPECTED_TYPES).map(n=>n.replace(/_/g,"\\s+")).join("|")})\\s+([\\s\\S]+)$`,"i").exec(e)||[];if(!s)return;let o=new this(t,s.replace(/s+/g,"_").toUpperCase());return o.argument(r(o,i,this.EXPECTED_TYPES[o.KIND]))}stringify(){return`SET ${this.KIND.replace(/_/g," ")} ${this.argument()}`}};var Nr=class extends q(P(D)){static get EXPECTED_TYPES(){return{COLUMN:[xe],CONSTRAINT:[Ee],INDEX:[$e]}}static get REF_TYPES(){return{COLUMN:[b],CONSTRAINT:[w],INDEX:[w]}}static parse(t,e,r){let[,s="COLUMN",i]=e.match(new RegExp(`^ALTER\\s+(?:(${Object.keys(this.EXPECTED_TYPES).join("|")})\\s+)?([\\s\\S]+)$`,"i"))||[],[o,n]=S.split(i,[" "],{limit:1}).map(f=>f.trim());if(!n)return;let u=new this(t,s.toUpperCase());return u.reference(r(u,o,this.REF_TYPES[u.KIND])),u.argument(r(u,n,this.EXPECTED_TYPES[u.KIND])),u}stringify(){return[...this.argument()].map(t=>`ALTER ${this.KIND} ${this.reference()} ${t}`).join(`
`)}};var Tr=class extends q(P(D)){static get REF_TYPES(){return{COLUMN:[b],CONSTRAINT:[w],INDEX:[w]}}static get EXPECTED_TYPES(){return this.REF_TYPES}static get OWN_REF_TYPE(){return O}get EXPECTED_TYPES(){return this.KIND?this.constructor.EXPECTED_TYPES[this.KIND]:this.constructor.OWN_REF_TYPE}static parse(t,e,r){let[,s="COLUMN",i,o]=e.match(new RegExp(`^RENAME\\s+(?:(${Object.keys(this.REF_TYPES).join("|")})\\s+)?(?:([\\s\\S]+?)\\s+)?(?:TO|AS)\\s+([\\s\\S]+)$`,"i"))||[];if(!o)return;let n=new this(t,i&&s.toUpperCase());return i?(n.reference(r(n,i,this.REF_TYPES[n.KIND])),n.argument(r(n,o,this.EXPECTED_TYPES[n.KIND]))):n.argument(r(n,o,[this.OWN_REF_TYPE])),n}stringify(){return["RENAME",this.KIND,this.reference(),"TO",this.argument()].filter(t=>t).join(" ")}};var re=class extends G{static get EXPECTED_TYPES(){return[Oe,be,Er,Sr,yr,Nr,Tr]}};var pt=class extends k(ye){static get EXPECTED_TYPES(){return{TABLE:[re],VIEW:[re]}}static get REF_TYPES(){return{TABLE:[O],VIEW:[O]}}stringify(){let[t,e,r,s]=this.argument().actions().reduce(([n,u,f,c],h)=>h.CLAUSE==="SET"&&h.KIND==="SCHEMA"?[h,u,f,c]:h.CLAUSE==="RENAME"&&!h.KIND?[n,h,f,c]:h.CLAUSE==="RENAME"?[n,u,f.concat(h),c]:[n,u,f,c.concat(h)],[null,null,[],[]]),i=[],o=`ALTER ${this.KIND}${this.hasFlag("IF_EXISTS")?" IF EXISTS":""}`;s.length&&i.push(`${o} ${this.reference()}
	${s.join(`,
	`)}`);for(let n of r.concat(e||[]))i.push(`${o} ${this.reference()} ${n}`);return t&&i.push(`${o} ${e?.argument()||this.reference()} ${t}`),i.join(`;
`)}};var De=class extends P(D){static parse(t,e,r){let[,s,i,o]=e.match(new RegExp(`^${this.CLAUSE}\\s+(${Object.keys(this.EXPECTED_TYPES).join("|")})\\s+(IF\\s+NOT\\s+EXISTS\\s+)?([\\s\\S]+)$`,"i"))||[];if(!s)return;let n=new this(t,s.toUpperCase());i&&n.withFlag("IF_NOT_EXISTS");let u=r(n,o,this.EXPECTED_TYPES[n.KIND]);return n.argument(u)}stringify(){let t=["CREATE",this.KIND];return this.hasFlag("IF_NOT_EXISTS")&&t.push("IF NOT EXISTS"),t.push(this.argument()),t.join(" ")}};var dt=class extends k(De){static get EXPECTED_TYPES(){return{TABLE:[Dt],VIEW:[Dt]}}};var we=class extends q(D){static parse(t,e,r){let s=Object.keys(this.EXPECTED_KINDS),[,i,o,n,u]=e.match(new RegExp(`^DROP\\s+(?:(${s.map(c=>c.replace(/_/gi,"\\s+")).join("|")})\\s+(IF\\s+EXISTS\\s+)?)?([\\s\\S]+?)(?:\\s+(RESTRICT|CASCADE|FORCE))?$`,"i"))||[];if(!i)return;let f=new this(t,i.replace(/\s+/g,"_").toUpperCase());return o&&f.withFlag("IF_EXISTS"),u&&f.withFlag(u),n&&f.reference(r(f,n,this.REF_TYPES[f.KIND])),f}stringify(){let t=["DROP",this.KIND];return this.hasFlag("IF_EXISTS")&&t.push("IF EXISTS"),this.reference()&&t.push(this.reference()),this.hasFlag("RESTRICT")?t.push("RESTRICT"):this.hasFlag("CASCADE")?t.push("CASCADE"):this.hasFlag("FORCE")&&t.push("FORCE"),t.join(" ")}};var Yt=class extends k(we){static get EXPECTED_KINDS(){return{TABLE:!0,VIEW:!0}}static get REF_TYPES(){return{TABLE:[O],VIEW:[O]}}};var Re=class extends q(P(D)){static get EXPECTED_TYPES(){return this.REF_TYPES}static parse(t,e,r){let[,s,i,o]=e.match(new RegExp(`^RENAME\\s+(?:(${Object.keys(this.REF_TYPES).join("|")})\\s+)?(?:([\\s\\S]+?)\\s+)?(?:TO|AS)\\s+([\\s\\S]+)$`,"i"))||[];if(!o)return;let n=new this(t,i&&s.toUpperCase());return i?(n.reference(r(n,i,this.REF_TYPES[n.KIND])),n.argument(r(n,o,this.EXPECTED_TYPES[n.KIND]))):n.argument(r(n,o,[this.OWN_REF_TYPE])),n}stringify(){return["RENAME",this.KIND,this.reference(),"TO",this.argument()].filter(t=>t).join(" ")}};var Ie=class extends Re{static get REF_TYPES(){return{TABLE:[O],VIEW:[O]}}static get OWN_REF_TYPE(){return U}get EXPECTED_TYPES(){return this.KIND?this.constructor.EXPECTED_TYPES[this.KIND]:this.constructor.OWN_REF_TYPE}};var _r=class extends P(D){static get EXPECTED_TYPES(){return{TABLESPACE:[w]}}static parse(t,e,r){let[,s,i]=new RegExp(`^SET\\s+(${Object.keys(this.EXPECTED_TYPES).map(n=>n.replace(/_/g,"\\s+")).join("|")})\\s+([\\s\\S]+)$`,"i").exec(e)||[];if(!s)return;let o=new this(t,s.replace(/s+/g,"_").toUpperCase());return o.argument(r(o,i,this.EXPECTED_TYPES[o.KIND]))}stringify(){return`SET ${this.KIND.replace(/_/g," ")} ${this.argument()}`}};var se=class extends G{static get EXPECTED_TYPES(){return[pt,dt,Yt,Ie,_r]}};var gt=class extends k(ye){static get EXPECTED_TYPES(){return{DATABASE:[se],SCHEMA:[se]}}static get REF_TYPES(){return{DATABASE:[U],SCHEMA:[U]}}stringify(){let[t,e,r,s]=this.argument().actions().reduce(([o,n,u,f],c)=>c.CLAUSE==="RENAME"&&!c.KIND?[c,n,u,f]:c.CLAUSE==="RENAME"?[o,n.concat(c),u,f]:c.CLAUSE==="SET"?[o,n,u.concat(c),f]:[o,n,u,f.concat(c)],[null,[],[],[]]),i=[];i.push(...s,...e);for(let o of r)i.push(`ALTER ${this.KIND} ${this.reference()} ${o}`);return t&&i.push(`ALTER ${this.KIND} ${this.reference()} ${t}`),i.join(`;
`)}};var jt=class extends k(De){static get EXPECTED_TYPES(){return{DATABASE:[z],SCHEMA:[z]}}stringify(){let t=[super.stringify()];return t.push(...this.argument().tables().map(e=>{let r=dt.fromJSON(this,{argument:e});return this.hasFlag("IF_NOT_EXISTS")&&r.withFlag("IF_NOT_EXISTS"),r})),t.join(`;
`)}};var kt=class extends k(we){static get EXPECTED_KINDS(){return{DATABASE:!0,SCHEMA:!0}}static get REF_TYPES(){return{DATABASE:[U],SCHEMA:[U]}}};var Kt=class extends k(Re){static get REF_TYPES(){return{DATABASE:[U],SCHEMA:[U]}}};var wt=class extends G{static get EXPECTED_TYPES(){return[gt,jt,kt,Kt]}};var bt=class extends vt(Y){#t;#e;#r=[];#s=[];#n;#i;#o;#u;#a;#f;targetTable(t){return arguments.length?(this.$diffTagHydrate()?this.#e=this.$castInputs([t],O,this.#e,"target_table"):this.#t=this.$castInputs([t],O,this.#t,"target_table"),this):this.#t}$targetTable(){return this.#e||this.targetTable()}targetColumns(t){if(!arguments.length)return this.#r;if(!Array.isArray(t)||!t.length)throw new Error("Columns list must be a non-empty array");return this.$diffTagHydrate()?this.#s=t:this.#r=t,this}$targetColumns(){return this.#s.length?this.#s:this.targetColumns()}matchRule(t){return arguments.length?(this.$diffTagHydrate()?this.#i=t:this.#n=t,this):this.#n}$matchRule(){return this.#i||this.matchRule()}updateRule(t){return arguments.length?(this.$diffTagHydrate()?this.#u=t:this.#o=t,this):this.#o}$updateRule(){return this.#u||this.updateRule()}deleteRule(t){return arguments.length?(this.$diffTagHydrate()?this.#f=t:this.#a=t,this):this.#a}$deleteRule(){return this.#f||this.deleteRule()}dirtyCheck(t=!1){return super.dirtyCheck(t).concat(this.dirtyCheckProperties(["targetTable","targetColumns","matchRule","updateRule","deleteRule"]))}generateDiff(t,e){return this.diffMergeJsons({...super.generateDiff(t,e),targetTable:this.$targetTable()?.jsonfy(e),targetColumns:this.$targetColumns().slice(),matchRule:this.$matchRule(),updateRule:this.$updateRule(),deleteRule:this.$deleteRule()},{targetTable:t.$targetTable()?.jsonfy(e),targetColumns:t.$targetColumns().slice(),matchRule:t.$matchRule(),updateRule:t.$updateRule(),deleteRule:t.$deleteRule()},e)}static fromJSON(t,e,r=null){if(Array.isArray(e?.targetColumns))return super.fromJSON(t,e,s=>{s.targetTable(e.targetTable),s.$diffTagHydrate(e.$targetTable,i=>s.targetTable(i)),s.targetColumns(e.targetColumns),s.$diffTagHydrate(e.$targetColumns,i=>s.targetColumns(i)),e.matchRule&&s.matchRule(e.matchRule),s.$diffTagHydrate(e.$matchRule,i=>s.matchRule(i)),e.updateRule&&s.updateRule(e.updateRule),s.$diffTagHydrate(e.$updateRule,i=>s.updateRule(i)),e.deleteRule&&s.deleteRule(e.deleteRule),s.$diffTagHydrate(e.$deleteRule,i=>s.deleteRule(i)),r?.(s)})}jsonfy(t={},e={}){let r=super.jsonfy(t,this.diffMergeJsons({targetTable:this.#t?.jsonfy(t),targetColumns:this.#r.slice(),...this.#n?{matchRule:this.#n}:{},...this.#o?{updateRule:this.#o}:{},...this.#a?{deleteRule:this.#a}:{},...e},{targetTable:this.#e?.jsonfy(t),targetColumns:this.#s.slice(),matchRule:this.#i,updateRule:this.#u,deleteRule:this.#f},t));if(!(t.rootCDL instanceof wt))return r;if(!r)return;let s={columnMutes:[],dropped:!1},i=l=>{if(l&&!l.hasFlag("CASCADE"))throw new Error(`Cannot drop ${l.KIND} ${l.reference()} because other objects depend on it.`);s.dropped=!0,t.diff&&(r={...r,status:"obsolete"})},o=l=>{let p=l.jsonfy(t);r=this.diffMergeJsons(r,{targetTable:{...r.targetTable,prefix:p}},t),t.diff!==!1&&(r.CDLIgnoreList||(r.CDLIgnoreList=[]),r.CDLIgnoreList.push("targetTable"))},n=l=>{let p=l.jsonfy(t);r=this.diffMergeJsons(r,{targetTable:{...r.targetTable,...p}},t),t.diff!==!1&&(r.CDLIgnoreList||(r.CDLIgnoreList=[]),r.CDLIgnoreList.push("targetTable"))},u=()=>{let l=this.resolveColumnReferences(r.targetColumns,s.columnMutes,!0);l.length!==r.targetColumns.length?i():lt(l,r.targetColumns).length!==r.targetColumns.length&&(r=this.diffMergeJsons(r,{targetColumns:l},t),t.diff!==!1&&(r.CDLIgnoreList||(r.CDLIgnoreList=[]),r.CDLIgnoreList.push("targetColumns")))},f=l=>l?.identifiesAs(this.$targetTable().prefix(!0)),c=l=>l?.identifiesAs(this.$targetTable().name()),h=l=>{for(let p of l)p.CLAUSE==="RENAME"?p.KIND?p.KIND==="COLUMN"&&s.columnMutes.push(p):n(p.argument()):p.CLAUSE==="SET"?p.KIND==="SCHEMA"&&o(p.argument()):p.CLAUSE==="DROP"&&p.KIND==="COLUMN"&&s.columnMutes.push(p)},d=l=>{for(let p of l){if(p.CLAUSE==="RENAME")p.KIND?c(p.reference())&&n(p.argument()):o(p.argument());else if(!c(p.reference?.()))continue;p.CLAUSE==="ALTER"?h(p.argument()):p.CLAUSE==="DROP"&&i(p)}};if((l=>{for(let p of l)f(p.reference?.())&&(p.CLAUSE==="RENAME"?o(p.argument()):p.CLAUSE==="ALTER"?d(p.argument()):p.CLAUSE==="DROP"&&i(p))})(t.rootCDL),u(),!(s.dropped&&!t.diff))return r}static parse(t,e,r){let{name:s,expr:i=""}=this.parseName(t,e,!0),o;if(this.checkIsColumn(t)){if(!(i=i.match(/^REFERENCES\s+([\s\S]+)$/i)?.[1]))return;o=new this(t)}else{if(!/^FOREIGN\s+KEY/i.test(i))return;o=new this(t);let[,m,...l]=S.split(i,[]);o.columns(this.parseColumns(t,m)),i=l.join("").trim()}let[n,u,f=""]=S.split(i,[]),c=r(o,n.trim(),[O]),h=S.split(Q(u,"(",")"),[","]).map(m=>this.parseIdent(t,m.trim())[0]),d=(m,l)=>{if(l==="MATCH")return m.match(/MATCH\s+(\w+)/i)?.[1];let p=/(NO\s+ACTION|RESTRICT|CASCADE|(SET\s+NULL|SET\s+DEFAULT)(?:\s+\(([^\)]+)\))?)/,[,y,_,E]=m.match(new RegExp(`ON\\s+${l}\\s+${p.source}`,"i"))||[];return _?E?{rule:_,targetColumns:E.split(",").map(A=>A.trim())}:_:y};return o.name(s).targetTable(c).targetColumns(h).matchRule(d(f,"MATCH")).updateRule(d(f,"UPDATE")).deleteRule(d(f,"DELETE"))}stringify(){let t=this.isColumnLevel?this.stringifyName():`${this.stringifyName()}FOREIGN KEY${this.stringifyColumns()} `;t+=`REFERENCES ${this.$targetTable()} (${this.$targetColumns().map(r=>this.stringifyIdent(r)).join(", ")})`;let e=r=>typeof r=="object"&&r?`${r.rule} (${r.targetColumns.join(", ")})`:r;return this.$matchRule()&&(t+=` MATCH ${this.$matchRule()}`),this.$updateRule()&&(t+=` ON UPDATE ${e(this.$updateRule())}`),this.$deleteRule()&&(t+=` ON DELETE ${e(this.$deleteRule())}`),t}};var Dt=class extends ge{static get CONSTRAINT_TYPES(){return[Ut,bt,Mt,Ft]}static get PREFIX_TYPE(){return[U]}#t=[];#e=[];#r=[];#s=new Set;[Symbol.iterator](){return this.#t[Symbol.iterator]()}get length(){return this.#t.length}$capture(t,e){return["TABLE_SCHEMA"].includes(t)?this:super.$capture(t,e)}$bubble(t,e){return["CONNECTED","DISCONNECTED"].includes(t)&&[W,Y,at].some(r=>e instanceof r&&(e.contextNode===this||e.contextNode instanceof W&&e.contextNode.contextNode===this))&&(t==="DISCONNECTED"?this.#s.delete(e):this.#s.add(e)),super.$bubble(t,e)}column(t,...e){if(typeof t=="string"){let r=this.#t.find(s=>s.identifiesAs(t));if(!e.length)return r;if(e[0]===!1)return this.#t=this.#t.filter(s=>s!==r),r?.bubble("DISCONNECTED"),this;t={name:t,...typeof e[0]=="object"?e[0]:{type:e[0]}}}return this.#t=this.$castInputs([t],W,this.#t,"columns",null,r=>this.#t.find(s=>s.identifiesAs(r.name()))),this}constraint(t,...e){if(typeof t=="string"){let r=[...this.#s].find(s=>s.identifiesAs(t));if(!e.length)return r;if(e[0]===!1)return this.#e.includes(r)?(this.#e=this.#e.filter(s=>s!==r),r?.bubble("DISCONNECTED")):r&&this.column(r.columns()[0]).constraint(r.TYPE,!1),this;t={name:t,...typeof e[0]=="object"?e[0]:{type:e[0],columns:e[1]}}}return this.#e=this.$castInputs([t],this.constructor.CONSTRAINT_TYPES,this.#e,"constraints",null,r=>{let s=this.#e.find(i=>i.identifiesAs(r.name()));return!s&&r.columns().length===1&&this.column(r.columns()[0]).constraint(r.TYPE,!1),s}),this}index(t,...e){if(typeof t=="string"){let r=this.#r.find(s=>s.identifiesAs(t));if(!e.length)return r;if(e[0]===!1)return this.#r=this.#r.filter(s=>s!==r),r?.bubble("DISCONNECTED"),this;t={name:t,...typeof e[0]=="object"?e[0]:{type:e[0],columns:e[1]}}}return this.#r=this.$castInputs([t],at,this.#r,"indexes",null,r=>this.#r.find(s=>s.identifiesAs(r.name()))),this}columns(t=!0){let e=this.#t;return t?e:e.map(r=>r.name())}constraints(t=!0,e=!0){let r=e?[...this.#s].filter(s=>s instanceof Y):this.#e;return t?r:r.map(s=>s.columns())}indexes(t=!0){let e=this.#r;return t?e:e.map(r=>r.columns())}primaryKey(t=!0,e=!0){let r=(e?[...this.#s]:this.#e).find(s=>s.TYPE==="PRIMARY_KEY");return t?r:r.columns()}foreignKeys(t=!0,e=!0){let r=(e?[...this.#s]:this.#e).filter(s=>s.TYPE==="FOREIGN_KEY");return t?r:r.map(s=>s.columns())}uniqueKeys(t=!0,e=!0){let r=(e?[...this.#s]:this.#e).filter(s=>s.TYPE==="UNIQUE_KEY");return t?r:r.map(s=>s.columns())}checks(t=!0,e=!0){let r=(e?[...this.#s]:this.#e).filter(s=>s.TYPE==="CHECK");return t?r:r.map(s=>s.expr())}dirtyCheck(t=!1){let e=super.dirtyCheck(t);return t?e.concat(["columns","constraints","indexes"].filter(r=>this[r]().some(s=>s.dirtyCheck(t).length))):e}renderCDL(t,e={}){let{rootCDL:r,...s}=e,i=new Map,o=new Map,n=(g,C,L=!0,M=!0)=>{let R=[].concat(g),Ct=R.includes("COLUMN")?W:R.includes("INDEX")?at:Y,J=[...this.#s].find(er=>er instanceof Ct&&(er.identifiesAs(C)||!C&&this.params.dialect==="mysql"&&R.includes("PRIMARY_KEY")));if((!J||i.has(J)&&!i.get(J))&&L)throw new Error(`${R[0]}${C?` "${C}"`:""} does not exist.`);return M&&i.has(J)?[J,J.constructor.fromJSON(J.contextNode.clone(),i.get(J))]:[J]},u=g=>{let C=`${g.KIND}:LAST`;if(g.after()?[C]=n(g.KIND,g.after().name(),!0,!1):g.first()&&(C=`${g.KIND}:FIRST`),o.has(C)||o.set(C,[]),["MODIFY","CHANGE"].includes(g.CLAUSE)){let[R,Ct]=n(g.KIND,g.CLAUSE==="CHANGE"?g.reference().name():g.argument().name()),J=(Ct||R).generateDiff(g.argument(),s);o.get(C).unshift(J);return}let[L]=n(g.KIND,g.argument().name(),!1,!1);if(L){if(i.has(L)&&(!i.get(L)||i.get(L).status==="obsolete")){i.set(L,g.argument().jsonfy(s));return}if(g.hasFlag("IF_NOT_EXISTS"))return;throw new Error(`${g.KIND} ${g.argument()?.name()||g.$KIND} already exists`)}let M=g.argument().jsonfy(s);if(s.diff!==!1&&(M={...M,status:"new"}),g.KIND==="CONSTRAINT"&&g.argument().$columns().length===1){let[R,Ct]=n("COLUMN",g.argument().$columns()[0],!1)||[];if(R){let er=(Ct||W.fromJSON(this.clone(),R.jsonfy(s))).constraint(M).jsonfy(s);i.set(R,er)}else o.get(C).unshift(M)}else o.get(C).unshift(M)},f=g=>{let[C,L]=n([g.KIND,g.$KIND],g.reference().name(),!g.hasFlag("IF_EXISTS"),s.diff!==!1);C&&i.set(C,s.diff===!1?void 0:{...(L||C).jsonfy(s),status:"obsolete"})},c=g=>{},h=g=>{let[C,L]=n([g.KIND,g.$KIND],g.reference().name()),M=this.diffMergeJsons((L||C).jsonfy(s),g.argument().jsonfy(s),s);i.set(C,M)},d=g=>{let[C,L]=n(g.KIND,g.reference().name()),M=(L||C).renderCDL(g.argument(),s);i.set(C,M)},m=g=>{let C=R=>{if(!i.get(R))return;let Ct=R.constructor.fromJSON(R.contextNode.clone(),i.get(R));for(let J of R.constraints())i.has(J)&&(i.get(J)?Ct.constraint(i.get(J)):Ct.constraint(J.TYPE,!1));return Ct.jsonfy({tableCDL:t,...e})},L=R=>!e.rootCDL||!i.get(R)?i.get(R):R.constructor.fromJSON(R.contextNode.clone(),i.get(R)).jsonfy({tableCDL:t,...e}),M;return i.has(g)?M=g instanceof W?C(g):L(g):g instanceof W?M=g.jsonfy(s,{},R=>i.has(R)?L(R):R.jsonfy({tableCDL:t,...e})):M=g.jsonfy({tableCDL:t,...e}),M},l=(g,C)=>g.reduce((M,R)=>M.concat(m(R)||[],o.get(R)||[]),o.get(`${C}:FIRST`)||[]).concat((o.get(`${C}:LAST`)||[]).reverse()),p=super.jsonfy(s),y=g=>(g.prefix||(g={...g,prefix:this.prefix(!0).jsonfy(s)}),g);for(let g of t)if(["ADD","MODIFY","CHANGE"].includes(g.CLAUSE))u(g);else if(g.CLAUSE==="DROP")f(g);else if(g.CLAUSE==="SET")if(g.KIND==="SCHEMA"){let C=g.argument().jsonfy(s);p=this.diffMergeJsons(y(p),{prefix:C},s)}else c(g);else if(g.CLAUSE==="RENAME")if(g.KIND)h(g);else{let C=g.argument().jsonfy(s);p=this.diffMergeJsons(y(p),C,s)}else if(g.CLAUSE==="ALTER")d(g);else throw new Error(`Unsupported operation: ${g.CLAUSE} ${g.KIND}`);let _=l(this.#t,"COLUMN"),E=l(this.#e,"CONSTRAINT"),A=l(this.#r,"INDEX");return{...p,columns:_,constraints:E,indexes:A}}generateCDL(t={}){let e=re.fromJSON(this,{actions:[]}),r=this.dirtyCheck();r.includes("name")&&e.add("RENAME",null,s=>s.argument(this.$name())),r.includes("prefix")&&e.add("SET","SCHEMA",s=>s.argument(this.$prefix().jsonfy()));for(let s of this.#s){let i=s instanceof Y?"CONSTRAINT":s instanceof at?"INDEX":"COLUMN",o=i!=="COLUMN"&&s.TYPE,n=Be(s.dirtyCheck(),s.CDLIgnoreList());if(s.status()==="new")e.add("ADD",i,o,u=>{u.argument(s.jsonfy({withColumns:i!=="COLUMN",diff:!1})),i==="COLUMN"&&t.existsChecks&&u.withFlag("IF_NOT_EXISTS")});else if(s.status()==="obsolete")e.add("DROP",i,o,u=>{u.reference(s.name()),t.cascadeRule&&u.withFlag(t.cascadeRule),t.existsChecks&&u.withFlag("IF_EXISTS")});else{let u=s.generateCDL();i==="COLUMN"&&this.params.dialect==="mysql"&&!(u.length===1&&u.actions()[0].KIND==="DEFAULT")?e.add("MODIFY","COLUMN",f=>f.argument(s.jsonfy(t,{},c=>c.constraintLevel===1?c:!1))):u.length?e.add("ALTER",i,o,f=>{f.reference(s.name()),f.argument(u)}):i!=="COLUMN"&&(n.length>1||n.length===1&&n[0]!=="name")&&(e.add("DROP",i,o,f=>f.reference(s.name())),e.add("ADD",i,o,f=>f.argument(s.jsonfy({withColumns:!0}))),n=n.filter(f=>f!=="name"))}n.includes("name")&&e.add("RENAME",i,o,u=>{u.reference(s.name()),u.argument(s.$name())})}return e}generateDiff(t,e){let r=super.generateDiff(t,e),s=new Map,[i,o]=[new Map,new Map];for(let[c,h,d]of[[this,i,t],[t,o,this]])for(let m of c.constraints(!0,!1)){let l;if(!d.constraint(m.name())&&m.columns().length===1&&(l=c.column(m.columns()[0]))){let p=s.get(l)||l.clone();p.constraint(m.jsonfy(e)),s.set(l,p)}else h.set(m.name().toLowerCase(),m)}let n=this.diffMergeTrees(this.#t,t.columns(),(c,h)=>(s.get(c)||c).generateDiff(s.get(h)||h,e),e),u=this.diffMergeTrees(i,o,(c,h)=>c.generateDiff(h,e),e),f=this.diffMergeTrees(this.#r,t.indexes(),(c,h)=>c.generateDiff(h,e),e);return{...r,columns:n,constraints:u,indexes:f}}static fromJSON(t,e,r=null){if(!(!Array.isArray(e?.columns)||["constraints","indexes"].some(s=>s in e&&!Array.isArray(e[s]))))return super.fromJSON(t,e,s=>{for(let i of e.columns)s.column(i);for(let i of e.constraints||[])s.constraint(i);for(let i of e.indexes||[])s.index(i);r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,{columns:this.#t.map(r=>r.jsonfy(t)),constraints:this.#e.map(r=>r.jsonfy(t)).filter(r=>r),indexes:this.#r.map(r=>r.jsonfy(t)).filter(r=>r),...e})}static parse(t,e,r){let[s,i,...o]=S.split(e,[],{limit:2});if(!s||!xt(i||"","(",")"))return;let n=new this(t),[u,f]=this.parseIdent(n,s.trim()).reverse();n.name(u),f&&n.prefix(f);let c=S.split(Q(i,"(",")"),[","]).map(h=>r(n,h.trim(),[...this.CONSTRAINT_TYPES,at,W]));for(let h of c)h instanceof W?n.column(h):h instanceof at?n.index(h):n.constraint(h);return n}stringify(){let t=[this.#t.map(s=>s.stringify()).join(`,
	`)],e=this.#e.slice(0),r=this.#r.slice(0);return this.params.dialect==="mysql"&&e.push(...this.#t.reduce((s,i)=>{let o=i.foreignKey();return o?s.concat(bt.fromJSON(this.clone(),{...o.jsonfy(),columns:[i.name()]})):s},[])),e.length&&t.push(e.map(s=>s.stringify()).join(`,
	`)),r.length&&t.push(r.map(s=>s.stringify()).join(`,
	`)),`${O.fromJSON(this,[this.$prefix(!0),this.$name()])} (
	${t.join(`,
	`)}
)`}};var z=class extends ot{#t;#e=[];[Symbol.iterator](){return this.#e[Symbol.iterator]()}get length(){return this.#e.length}$capture(t,e){return["DATABASE_SCHEMA"].includes(t)?this:super.$capture(t,e)}version(){return this.#t}table(t,...e){if(typeof t=="string"){let r=this.#e.find(s=>s.identifiesAs(t));if(!e.length)return r;if(e[0]===!1)return this.#e=this.#e.filter(s=>s!==r),r?.bubble("DISCONNECTED"),this;t={name:t,...typeof e[0]=="object"?e[0]:{columns:e[0]}}}return this.#e=this.$castInputs([t],Dt,this.#e,"tables",null,r=>this.#e.find(s=>s.identifiesAs(r.name()))),this}tables(t=!0){return t?this.#e:this.#e.reduce((e,r)=>e.concat(r.name()),[])}columns(t=!0){return this.#e.reduce((e,r)=>e.concat(t?r.columns():r.columns(!1).map(s=>[r.name(),s])),[])}primaryKeys(t=!0,e=!0){return this.#e.reduce((r,s)=>r.concat(t?s.primaryKey(!0,e):[[s.name(),s.primaryKeys(!1,e)]]),[])}foreignKeys(t=!0,e=!0){return this.#e.reduce((r,s)=>r.concat(t?s.foreignKeys(!0,e):s.foreignKeys(!1,e).map(i=>[s.name(),i])),[])}uniqueKeys(t=!0,e=!0){return this.#e.reduce((r,s)=>r.concat(t?s.uniqueKeys(!0,e):s.uniqueKeys(!1,e).map(i=>[s.name(),i])),[])}checks(t=!0,e=!0){return this.#e.reduce((r,s)=>r.concat(t?s.checks(!0,e):s.checks(!1,e).map(i=>[s.name(),i])),[])}dirtyCheck(t=!1){let e=super.dirtyCheck(t);return t?e.concat(["tables"].filter(r=>this[r]().some(s=>s.dirtyCheck(t).length))):e}renderCDL(t,e){let{rootCDL:r,...s}=e,i=new Set,o=new Map,n=[],u=(E,A=!0,g=!0)=>{let C=this.table(E);if((!C||o.has(C)&&!o.get(C))&&A)throw new Error(`Table "${this.name()}"."${E}" does not exist.`);return g&&o.has(C)?[C,C.constructor.fromJSON(C.contextNode.clone(),o.get(C))]:[C]},f=E=>{let A={...s,rootCDL:!i.has(E)&&r};return i.has(E)||i.add(E),A},c=E=>{if(u(E.argument().name(),!1,!1)[0]){if(E.hasFlag("IF_NOT_EXISTS"))return;throw new Error(`Table "${E.argument()?.name()}" already exists`)}let A=E.argument().jsonfy(s);s.diff&&(A={...A,status:"new"}),n.push(A)},h=E=>{let[A,g]=u(E.reference().name(),!E.hasFlag("IF_EXISTS"),!!s.diff);A&&o.set(A,s.diff?{...(g||A).jsonfy(s),status:"obsolete"}:void 0)},d=E=>{},m=E=>{let[A,g]=u(E.reference().name()),C=this.diffMergeJsons((g||A).jsonfy(f(A)),E.argument().jsonfy(s),s);o.set(A,C)},l=E=>{let[A,g]=u(E.reference().name()),C=(g||A).renderCDL(E.argument(),f(A));o.set(A,C)},p=E=>{let A,g=f(E);if(o.has(E)){if(!o.get(E))return;g.rootCDL?A=E.constructor.fromJSON(this.clone(),o.get(E)).jsonfy(g):A=o.get(E)}else A=E.jsonfy(g);return A},y=E=>E.reduce((A,g)=>A.concat(p(g)||[]),[]).concat(n),_=super.jsonfy(s);for(let E of t)if(E.CLAUSE==="CREATE")c(E);else if(E.CLAUSE==="DROP")h(E);else if(E.CLAUSE==="SET")d(E);else if(E.CLAUSE==="RENAME")if(E.KIND)m(E);else{let A=E.argument().jsonfy(s);_=this.diffMergeJsons(_,A,s)}else if(E.CLAUSE==="ALTER")l(E);else throw new Error(`Unsupported operation: ${E.CLAUSE} ${E.KIND}`);return{..._,tables:y(this.#e)}}generateCDL(t={},e="TABLE"){let r=se.fromJSON(this,{actions:[]});this.dirtyCheck().includes("name")&&r.add("RENAME",null,i=>i.argument(this.$name()));for(let i of this.#e)if(i.status()==="new")r.add("CREATE",e,o=>{o.argument({prefix:this.name(),...i.jsonfy({...t,diff:!1})}),t.existsChecks&&o.withFlag("IF_NOT_EXISTS")});else if(i.status()==="obsolete")r.add("DROP",e,o=>{o.reference([this.name(),i.name()]),t.cascadeRule&&o.withFlag(t.cascadeRule),t.existsChecks&&o.withFlag("IF_EXISTS")});else{let o=i.generateCDL(t);o.length&&r.add("ALTER",e,n=>{n.reference([this.name(),i.name()]),n.argument(o)})}return r}generateDiff(t,e){let r=super.generateDiff(t,e),s=this.diffMergeTrees(this.#e,t.tables(),(i,o)=>i.generateDiff(o,e),e);return{...r,tables:s}}findPrefix(t){return this.tables().find(e=>e.column(t))?.name()}static fromJSON(t,e,r=null){if(!("tables"in(e||{})&&!Array.isArray(e.tables)))return super.fromJSON(t,e,s=>{for(let i of e.tables||[])s.table(i);typeof e.version=="number"&&(s.#t=e.version),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,{...typeof this.#t=="number"?{version:this.#t}:{},tables:this.#e.map(r=>r.jsonfy(t)),...e})}static parse(t,e,r){let[s]=this.parseIdent(t,e);if(s)return new this(t).name(s)}stringify(){return this.stringifyIdent(this.$name())}};var Cr=class extends T{#t;#e;expr(t){return arguments.length?(this.#t=this.$castInputs([t],x,this.#t,"order_by_expr"),this):this.#t}direction(t){if(!arguments.length)return this.#e;if(!["ASC","DESC"].includes(t=t.toUpperCase()))throw new Error(`Invalid sort direction: ${t}`);return this.#e=t,this}desc(){return this.direction("DESC")}asc(){return this.direction("ASC")}identifiesAs(t){return this.#t?.identifiesAs(t)||super.identifiesAs(t)}static fromJSON(t,e,r=null){return super.fromJSON(t,e,s=>{e.expr&&s.expr(e.expr),e.direction&&s.direction(e.direction),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,{expr:this.#t?.jsonfy(t),...this.#e?{direction:this.#e}:{},...e})}static parse(t,e,r){let[,s,i]=e.match(new RegExp("^([\\s\\S]+?)(?:\\s+(ASC|DESC))?$","i"))||[],o=new this(t);return o.expr(r(o,s,x)),i&&o.direction(i.toUpperCase()),o}stringify(){return[this.#t.stringify(),this.#e].filter(t=>t).join(" ")}};var V=class extends I{static get EXPECTED_TYPES(){return[Cr]}static get REGEX(){return"ORDER\\s+BY"}withRollup(){return this.withFlag("WITH_ROLLUP")}static parse(t,e,r){let[s,i,o]=e.match(new RegExp(`^${this.REGEX}([\\s\\S]*)(\\s+WITH\\s+ROLLUP)?$`,"i"))||[];if(!s)return;let n=super.parse(t,i,r);if(n)return o&&n.withFlag("WITH_ROLLUP"),n}stringify(){return this.entries().length?["ORDER BY",super.stringify()].concat(this.hasFlag("WITH_ROLLUP")?"WITH ROLLUP":[]).join(" "):""}};var ie=class extends T{static get CLAUSE(){return"OFFSET"}#t;value(t){if(!arguments.length)return this.#t;if(!1!=="number")throw new SyntaxError(`Invalid OFFSET/LIMIT value: ${t}`);return this.#t=t,this}static fromJSON(t,e,r=null){if(!(!e?.value||Object.keys(e).filter(s=>s!=="nodeName").length>1))return super.fromJSON(t,e,s=>{s.value(e.value),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,{value:this.#t,...e})}static parse(t,e){let[r,s]=e.match(new RegExp(`^${this.CLAUSE}([\\s\\S]*)$`,"i"))||[];if(r)return new this(t).value(parseInt(s))}stringify(){return`${this.constructor.CLAUSE} ${this.#t}`}};var Et=class extends ie{static get CLAUSE(){return"LIMIT"}};var Xt=class extends I{static get EXPECTED_TYPES(){return x}static get OPERATORS(){return[]}#t;operator(t){if(!arguments.length)return this.#t;if(!this.constructor.OPERATORS.includes(t))throw new Error(`Unknown operator: ${t}.`);return this.#t=t,this}static fromJSON(t,e,r=null){if(this.OPERATORS.includes(e?.operator))return super.fromJSON(t,e,s=>{s.operator(e.operator),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,{operator:this.#t,...e})}static parse(t,e,r){if(this.CLAUSE){let[s,i]=e.match(new RegExp(`^${this.CLAUSE}([\\s\\S]*)$`,"i"))||[];if(!s)return;e=i}for(let s of this.OPERATORS){let i=S.split(e,[/^\w+$/.test(s)?`\\s+${s}\\s+`:s.split("").map(n=>`\\${n}`).join("")],{useRegex:"i"});if(i.length<(this.minEntries||2))return;let o=new this(t).operator(s);return o.add(...i.map(n=>r(o,n.trim())))}}stringify(){let t=this.entries().join(` ${this.#t} `);if(this.constructor.CLAUSE){if(!this.entries().length)return"";t=`${this.constructor.CLAUSE} ${t}`}else this.contextNode instanceof this.constructor&&(t=`(${t})`);return t}};var St=class extends Xt{static get OPERATORS(){return["AND","OR"]}static get CLAUSE(){}every(...t){return this.operator("AND").add(...t)}some(...t){return this.operator("OR").add(...t)}static get expose(){return{every:(t,...e)=>e.length>1&&this.fromJSON(t,{operator:"AND",entries:e}),some:(t,...e)=>this.fromJSON(t,{operator:"OR",entries:e})}}};var Z=class extends St{static get CLAUSE(){return"WHERE"}static get minEntries(){return 1}};var j=class extends Pt{static get EXPECTED_TYPES(){return[O,Le]}};var We=class extends St{static get CLAUSE(){return"ON"}static get minEntries(){return 1}};var H=class extends j{static get REGEX(){return"(INNER\\s+|CROSS\\s+|(?:LEFT|RIGHT)(?:\\s+OUTER)?\\s+)?JOIN(?!\\w)"}#t;#e;#r;type(t){return arguments.length?(this.#t=t,this):this.#t}full(t){return this.type("JOIN").expr(t)}left(t){return this.type("LEFT_JOIN").expr(t)}right(t){return this.type("RIGHT_JOIN").expr(t)}inner(t){return this.type("INNER_JOIN").expr(t)}cross(t){return this.type("CROSS_JOIN").expr(t)}on(...t){return arguments.length?(this.#r=this.$castInputs(t,We,this.#r,"on_clause","every"),this):this.#r}using(t){return arguments.length?(this.#e=this.$castInputs([t],w,this.#e,"using_clause"),this):this.#e}static fromJSON(t,e,r=null){if(e.type)return super.fromJSON(t,e,s=>{s.type(e.type),e.usingClause&&s.using(e.usingClause),e.onClause&&s.on(e.onClause),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,{type:this.#t,...this.#e?{usingClause:this.#e.jsonfy(t)}:{},...this.#r?{onClause:this.#r.jsonfy(t)}:{},...e})}static parse(t,e,r){let[s,i,o]=e.match(new RegExp(`^${this.REGEX}([\\s\\S]*)$`,"i"))||[];if(!s)return;let[n,u]=S.split(o,["\\s+(?:ON|USING)\\s+"],{useRegex:"i",preserveDelims:!0}).map(c=>c.trim()),f=super.parse(t,n,r);return f.type(i.trim().toUpperCase()+"_JOIN"),/^USING/i.test(u)?f.using(r(f,u.replace(/^USING\s+/i,""),[w])):/^ON/i.test(u)&&f.on(r(f,u,[We])),f}stringify(){return[this.#t?.replace(/_/," ").toUpperCase()||"JOIN",super.stringify(),this.#e?`USING ${this.#e}`:`${this.#r}`].filter(t=>t).join(" ")}};var yt=class extends T{static get OPERATORS(){return[]}static get LHS_TYPES(){return[]}static get RHS_TYPES(){return[]}#t;#e;#r;operator(t){if(!arguments.length)return this.#t;if(!us(this.constructor.OPERATORS,t))throw new Error(`Invalid operator: ${t}`);return this.#t=t,this}operands(t,e){if(!arguments.length)return[this.#e,this.#r];let r=this.constructor.OPERATORS[0];return this.lhs(t).rhs(e).operator(N(r)?r.operator:r)}lhs(t){return arguments.length?(this.#e=this.$castInputs([t],this.constructor.LHS_TYPES,this.#e,"lhs_expr"),this):this.#e}rhs(t){return arguments.length?(this.#r=this.$castInputs([t],this.constructor.RHS_TYPES,this.#r,"rhs_expr"),this):this.#r}static fromJSON(t,e,r=null){if(!(!e?.operator||!us(this.OPERATORS,e.operator)||!e.lhs||"rhs"in e&&!e.rhs))return super.fromJSON(t,e,s=>{s.operator(e.operator).lhs(e.lhs),e.rhs&&s.rhs(e.rhs),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,{operator:this.#t,lhs:this.#e?.jsonfy(t),...this.#r?{rhs:this.#r.jsonfy(t)}:{},...e})}stringify(){return[this.#e,this.#t].concat(this.#r||[]).join(" ")}},us=(a,t)=>a.some(e=>N(e)?t===e.operator||new RegExp(e.test).test(` ${t} `):t===e);var Pe=class extends rt(yt){get isPath(){return!0}static get expose(){return{path:(t,e,r,s)=>this.fromJSON(t,{lhs:e,operator:r,rhs:s})}}plot(t=!1){let e=this.schema(),r,s;if(this.lhs()instanceof Rt){let o=this.lhs().endpoint(),n=o.schema().foreignKey();if(!n)throw new Error(`[${this}]: Column ${o.clone({fullyQualified:!0})} is not a foreign key.`);let u=n.targetTable(),f=this.capture("DATABASE_SCHEMA");for(let h of f.columns())if(h.primaryKey()&&h.prefix(!0).identifiesAs(u)){let d=b.fromJSON(this,[h.contextNode.name(),h.name()]);if(r)throw new Error(`[${this}]: Target primary key for foreign key ${o.clone({fullyQualified:!0})} is ambiguous. (Is it ${r} or ${d}?)`);r=d}if(!r)throw new Error(`Path ${this} could not be resolved against base query.`);let c=this.lhs().lhs();s=c instanceof ve?c.clone({reverse:!0}):c.clone({fullyQualified:t})}else r=this.lhs().clone({fullyQualified:t}),s=b.fromJSON(this,[e.name(),e.primaryKey().columns()[0]]);let i=O.fromJSON(this,[e.prefix(!0).name(),e.name()]);return[r,i,s]}jsonfy(t={},e={}){return!t.deSugar||!this.statementNode?super.jsonfy(t,e):this.statementNode.resolvePath(this,t)}};var ve=class a extends Pe{static get OPERATORS(){return["<~"]}static get LHS_TYPES(){return[a,b]}static get RHS_TYPES(){return[b]}static get DESUGARS_TO(){return[X]}$capture(t,e){if(t==="TABLE_SCHEMA"){if(e===this.lhs())return this.schema();if(e===this.rhs()&&this.contextNode instanceof a)return this.contextNode.schema()}return super.$capture(t,e)}schema(){let t=this.rhs().schema().foreignKey();if(!t)throw new Error(`[${this}]: Column ${this.rhs().clone({fullyQualified:!0})} is not a foreign key.`);return t.targetTable().schema()}endpoint(){return this.lhs()instanceof a?this.lhs().endpoint():this.lhs()}jsonfy(t={},e={}){return t.reverse?{nodeName:X.NODE_NAME,lhs:this.rhs()?.jsonfy(t),rhs:this.lhs()?.jsonfy(t),operator:"~>"}:super.jsonfy(t,e)}static parse(t,e,r){let s=S.split(e,this.OPERATORS,{useRegex:!0});if(s.length<2)return;let i=this.OPERATORS[0],o=new this(t).operator(i);return o.rhs(r(o,s.pop().trim(),this.RHS_TYPES)),o.lhs(r(o,s.join(i).trim(),this.LHS_TYPES))}};var Rt=class extends ve{static get RHS_TYPES(){return[O]}$capture(t,e){return t==="TABLE_SCHEMA"?this.rhs().schema():super.$capture(t,e)}schema(){return this.rhs().schema()}};var Ar=class extends Pt{static get EXPECTED_TYPES(){return x}static get requireAliasForNoneIdents(){return!0}static get expose(){return{prop:(t,e,r)=>this.fromJSON(t,{expr:e,alias:r})}}};var st=class extends T{#t="";#e="'";value(t){if(!arguments.length)return this.#t;if(typeof t!="string")throw new Error(`Invalid argument as string: ${t}`);return this.#t=t,this}quote(t=this.#e){if(!arguments.length)return this.#e;if(!['"',"'"].includes(t))throw new Error(`Invalid argument as quote: ${t}`);return this.#e=t,this}identifiesAs(t){return typeof t=="string"?this.$eq(this.#t,t,"ci"):super.identifiesAs(t)}static get expose(){return{"string|str":(t,e,r)=>this.fromJSON(t,{value:e,quote:r}),value:(t,e)=>typeof e=="string"&&this.fromJSON(t,{value:e})}}static fromJSON(t,e,r=null){if(!(typeof e?.value!="string"||Object.keys(e).filter(s=>!["nodeName","quote"].includes(s)).length>1||e.quote&&!['"',"'"].includes(e.quote)))return super.fromJSON(t,e,s=>{s.value(e.value).quote(e.quote),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,{quote:this.#e,value:this.#t,...e})}static parse(t,e){let[r,s]=this.parseString(t,e,!0)||[];if(s)return new this(t).value(r).quote(s)}stringify(){return this.stringifyString(this.#t,!0)}};var it=class extends T{#t;#e=[];name(t){if(!arguments.length)return this.#t;if(typeof t!="string")throw new TypeError("Invalid argument as function name.");return this.#t=t,this}args(...t){return arguments.length?(this.#e=this.$castInputs(t,x,this.#e,"function_args"),this):this.#e}identifiesAs(t){return t===this.#t||super.identifiesAs(t)}static get expose(){return{now:(t,...e)=>this.fromJSON(t,{name:"NOW",args:e}),concat:(t,...e)=>this.fromJSON(t,{name:"CONCAT",args:e}),count:(t,...e)=>this.fromJSON(t,{name:"COUNT",args:e}),fn:(t,e,...r)=>this.fromJSON(t,{name:e,args:r})}}static fromJSON(t,e,r=null){if(!(typeof e?.name!="string"||!Array.isArray(e.args)))return super.fromJSON(t,e,s=>{s.name(e.name);for(let i of e.args)s.args(i);r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,{name:this.#t,args:this.#e.map(r=>r.jsonfy(t)),...e})}static parse(t,e,r){let[,s,i=""]=/^(\w+)(?:\s+)?\(([\s\S]+)?\)$/i.exec(e)||[];if(!s||S.match(e.replace(s,"").trim(),[" "]).length)return;let o=new this(t).name(s),n=S.split(i,[","]).map(u=>r(o,u.trim()));for(let u of n)o.args(u);return o}stringify(){return`${this.#t.toUpperCase()}(${this.#e.join(", ")})`}};var ne=class extends rt(I){static get EXPECTED_TYPES(){return[Ar]}static get TAGS(){return["{","}"]}static get DESUGARS_TO(){return[it]}static get expose(){return{fields:(t,...e)=>this.fromJSON(t,{entries:e})}}jsonfy(t={},e={},r=null){return t.deSugar?{nodeName:it.NODE_NAME,name:this.params.dialect==="mysql"?"JSON_OBJECT":"JSON_BUILD_OBJECT",args:this.entries().reduce((s,i)=>{let o={nodeName:st.NODE_NAME,value:i.alias(!0)},n=i.expr().jsonfy(t);return s.concat(o,n)},[])}:super.jsonfy(t,e,r)}};var oe=class extends rt(I){static get EXPECTED_TYPES(){return x}static get TAGS(){return["[","]"]}static get DESUGARS_TO(){return[it]}static get expose(){return{items:(t,...e)=>this.fromJSON(t,{entries:e})}}jsonfy(t={},e={},r=null){return t.deSugar?{nodeName:it.NODE_NAME,name:this.params.dialect==="mysql"?"JSON_ARRAY":"JSON_BUILD_ARRAY",args:this.entries().map(s=>s.jsonfy(t)),originalSugar:this.stringify()}:super.jsonfy(t,e,r)}};var v=class extends I{static get EXPECTED_TYPES(){return[X,b]}static get TAGS(){return["(",")"]}static get expose(){return{columns:(t,...e)=>this.fromJSON(t,{entries:e})}}};var B=class extends I{static get EXPECTED_TYPES(){return x}static get MIN_ENTRIES(){return 2}static get TAGS(){return["(",")"]}static get expose(){return{row:(t,...e)=>this.fromJSON(t,{entries:e})}}};var Ve=class extends I{static get EXPECTED_TYPES(){return x}static get REGEX(){return"PARTITION\\s+BY"}static parse(t,e,r){let[s,i]=e.match(new RegExp(`^${this.REGEX}([\\s\\S]*)$`,"i"))||[];if(s)return super.parse(t,i,r)}stringify(){return this.entries().length?["PARTITION BY",super.stringify()].join(" "):""}};var ae=class extends T{#t;#e;#r;#s;name(t){return arguments.length?(this.#t=t,this):this.#t}existing(t){return arguments.length?(this.#e=t,this):this.#e}extends(t){return this.existing(...arguments)}partitionBy(...t){if(!arguments.length)return this.#r;if(this.#e)throw new Error("The PARTITION BY clause is not allowed when inheriting from a base window.");return this.#r=this.$castInputs(t,Ve,this.#r,"partition_by_clause","add"),this}orderBy(...t){return arguments.length?(this.#s=this.$castInputs(t,V,this.#s,"order_by_clause","add"),this):this.#s}static fromJSON(t,e,r=null){if(typeof e=="string")e={windowRef:e};else if(!(typeof e=="object"&&e)||!["name","windowRef","partitionByClause","orderByClause"].some(s=>s in e))return;return super.fromJSON(t,e,s=>{e.name&&s.name(e.name),e.windowRef&&s.extends(e.windowRef),e.partitionByClause&&s.partitionBy(e.partitionByClause),e.orderByClause&&s.orderBy(e.orderByClause),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,{...this.#t||!this.#e?{name:this.#t}:{},...this.#e||!this.#t?{windowRef:this.#e}:{},...this.#r?{partitionByClause:this.#r.jsonfy(t)}:{},...this.#s?{orderByClause:this.#s.jsonfy(t)}:{},...e})}static parse(t,e,r){let s=new this(t),i=async u=>{let{tokens:[f,...c],matches:h}=S.lex(Q(u.trim(),"(",")"),["PARTITION\\s+BY","ORDER\\s+BY"],{useRegex:"i",preserveDelims:!0});f.trim()&&s.extends(f.trim());for(let d of h){if(/PARTITION\s+BY/i.test(d)){s.partitionBy(r(s,c.shift().trim(),[Ve]));continue}s.orderBy(r(s,c.shift().trim(),[V]))}},o=e.endsWith(")");if(o&&!e.startsWith("(")){let[u,f]=spec.split(new RegExp(" AS ","i"));s.name(u.trim()),i(f)}else o?i(e):s.existing(e);return s}stringify(){let t=[];return!this.#t&&this.#e&&!this.#r&&!this.#s?t.push(this.#e):(this.#t&&t.push(`${this.#t} AS `),t.push(`(${[this.#e,this.#r,this.#s].filter(e=>e).join(" ")})`)),t.join("")}};var ue=class extends it{#t;#e;over(t){return arguments.length?(t||(t={name:""}),this.#t=this.$castInputs([t],ae,this.#t,"over_clause"),this):this.#t}orderBy(...t){return arguments.length?(this.#e=this.$castInputs(t,V,this.#e,"order_by_clause","add"),this):this.#e}static get expose(){return{fn:(t,e,...r)=>this.names.flat().includes(e?.toUpperCase())&&this.fromJSON(t,{name:e,args:r}),...Object.fromEntries(this.names.flat().map(t=>[qe(t.toLowerCase().replace(/_/g," ")),(e,...r)=>this.fromJSON(e,{name:t,args:r})]))}}static fromJSON(t,e,r=null){if(this.names.flat().includes(e?.name?.toUpperCase?.()))return super.fromJSON(t,e,s=>{e.orderByClause&&s.orderBy(e.orderByClause),e.overClause&&s.over(e.overClause),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,{...this.#e?{orderByClause:this.#e.jsonfy(t)}:{},...this.#t?{overClause:this.#t.jsonfy(t)}:{},...e})}static parse(t,e,r){let[s,i]=S.split(e,["OVER\\s*"],{useRegex:"i"}).map(d=>d.trim()),[,o,n,u=""]=/^(\w+)\((?:\s+)?(?:(ALL|DISTINCT|FILTER)\s+)?([\s\S]+?)?\)$/i.exec(s)||[];if(!this.names.flat().includes(o?.toUpperCase()))return;let[,f,c]=/^([\s\S]+)(?:\s+(ORDER\s+BY\s+.+))$/i.exec(u)||[,u],h=super.parse(t,`${o}(${f})`,r);return n&&h.withFlag(n.toUpperCase()),c?h.orderBy(r(h,c,[V])):i&&h.over(r(h,i.trim(),[ae])),h}stringify(){return`${this.name().toUpperCase()}(${[...this.getFlag(),this.args().join(", "),this.#e].filter(e=>e).join(" ")})`+(this.#t?` OVER ${this.#t}`:"")}static names=[["AVG","BIT_AND","BIT_OR","BIT_XOR","COUNT","JSON_AGG","JSON_ARRAYAGG","JSON_OBJECTAGG","MAX","MIN","STDDEV_POP","STDDEV","STD","STDDEV_SAMP","SUM","VAR_POP","VARIANCE","VAR_SAMP","GROUP_CONCAT","GROUP_CONCAT_WS"],["CUME_DIST","DENSE_RANK","FIRST_VALUE","LAG","LAST_VALUE","LEAD","NTH_VALUE","NTLE","PERCENT_RANK","RANK","ROW_NUMBER"],["ANY_VALUE","COLUMN","COLUMNS","GROUPING"]]};var Nt=class extends rt(T){static get DESUGARS_TO(){return[ue]}static get EXPECTED_TYPES(){return x.map(t=>t===B?v:t)}#t;expr(t){return arguments.length?(this.#t=this.$castInputs([t],this.constructor.EXPECTED_TYPES,this.#t,"json_aggr_expr"),this):this.#t}static fromJSON(t,e,r=null){if(e?.expr)return super.fromJSON(t,e,s=>{s.expr(e.expr),r?.(s)})}jsonfy(t={},e={}){return t.deSugar?{nodeName:ue.NODE_NAME,name:this.params.dialect==="mysql"?"JSON_ARRAYAGG":"JSON_AGG",args:[this.#t?.jsonfy(t)],prettyName:this.stringify()}:super.jsonfy(t,{expr:this.#t?.jsonfy(t),...e})}static parse(t,e,r){if((e=e.split(/(?=\[\s*\]$)/)).length!==2)return;let s=new this(t);return s.expr(r(s,e.shift().trim(),this.EXPECTED_TYPES))}stringify(){return`${this.#t}[]`}};var fe=class extends st{static get expose(){return{json:(t,e)=>this.fromJSON(t,{value:Array.isArray(e)||N(e)?JSON.stringify(e):e})}}static fromJSON(t,e,r=null){if(!(!N(e)||Object.keys(e).filter(s=>s!=="nodeName").length>1)){try{typeof e?.value=="string"&&JSON.parse(e.value)}catch{return}return super.fromJSON(t,e,s=>{r?.(s)})}}static parse(t,e){let r=[["{","}"],["[","]"]],s={},[i,o]=this.parseString(t,e,!0)||[];if(o&&!(!(s.braces=r.find(n=>xt(e,n[0],n[1])))||S.match(e,[" "]).length)){try{JSON.parse(i)}catch{return}return new this(t,o).value(i)}}};var Ue=class extends T{#t;value(t){if(!arguments.length)return this.#t;if(typeof t!="number")throw new Error(`Cannot use ${typeof t} as number.`);return this.#t=t,this}identifiesAs(t){return t===this.#t||super.identifiesAs(t)}static get expose(){return{"num|int|float":(t,e)=>this.fromJSON(t,{value:parseFloat(e)}),value:(t,e)=>/^\d+$/.test(e)&&this.fromJSON(t,{value:parseFloat(e)})}}static fromJSON(t,e,r=null){if(typeof e=="number")e={value:e};else if(typeof e?.value!="number"||Object.keys(e).filter(s=>s!=="nodeName").length>1)return;return super.fromJSON(t,e,s=>{s.value(e.value),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,{value:this.#t,...e})}static parse(t,e){if(/^\d+$/.test(e))return new this(t).value(parseFloat(e))}stringify(){return`${this.#t}`}};var Me=class extends yt{static get OPERATORS(){return["->","->>","#>","#>>"]}static get LHS_TYPES(){return[fe,b]}static get RHS_TYPES(){return[fe,Ue,st]}static get expose(){return{path:(t,e,r,s)=>this.fromJSON(t,{lhs:e,operator:r,rhs:s})}}static parse(t,e,r){if((t?.params?.inputDialect||t?.params?.dialect)==="mysql")return;let{tokens:[s,i],matches:[o]}=S.lex(e,this.OPERATORS,{limit:1});if(!s||!o||!i)return;let n=new this(t).operator(o);return n.lhs(r(n,s.trim(),this.LHS_TYPES)),n.rhs(r(n,i.trim(),this.RHS_TYPES)),n}};var X=class a extends Pe{static get OPERATORS(){return["~>",{test:":(?=\\s*[{([])",operator:":"}]}static get LHS_TYPES(){return[Rt,b]}static get RHS_TYPES(){return[this,Me,Nt,ne,oe,v,b]}static get DESUGARS_TO(){return this.LHS_TYPES}$capture(t,e){if(t==="TABLE_SCHEMA"){if(e===this.rhs())return this.schema();if(e===this.lhs()&&this.contextNode instanceof a)return this.contextNode.schema()}return super.$capture(t,e)}static get expose(){return{path:(t,e,...r)=>r.length===1?this.fromJSON(t,{lhs:e,operator:"~>",rhs:r[0]}):super.expose.path(t,e,...r)}}schema(){if(this.lhs()instanceof Rt)return this.lhs().schema();let t=this.lhs().schema().foreignKey();if(!t)throw new Error(`[${this}]: Column ${this.lhs().clone({fullyQualified:!0})} is not a foreign key.`);return t.targetTable().schema()}endpoint(){return this.rhs()instanceof a?this.rhs().endpoint():this.rhs()}prettyName(){return this.clone({asProperty:!0}).stringify()}jsonfy(t={},e={}){return t.asProperty&&[ne,oe,Nt,v].some(r=>this.rhs()instanceof r)?this.lhs().jsonfy({...t,asProperty:!1},e):super.jsonfy(t)}static parse(t,e,r){let{tokens:[s,i],matches:[o]}=S.lex(e,this.OPERATORS,{limit:1,useRegex:!0});if(!s||!o||!i)return;let n=new this(t).operator(o);return n.lhs(r(n,s.trim(),this.LHS_TYPES)),n.rhs(r(n,i.trim(),this.RHS_TYPES)),n}stringify(){return this.operator()===":"?`${this.lhs()}: ${this.rhs()}`:super.stringify()}};var Je=a=>class extends a{#t=[];#e;#r;#s;joins(){return this.#t}join(t){return this.#t=this.$castInputs([t],H,this.#t,"join_clause","full"),this.#t[this.#t.length-1]}leftJoin(t){return this.#t=this.$castInputs([t],H,this.#t,"join_clause","left"),this.#t[this.#t.length-1]}rightJoin(t){return this.#t=this.$castInputs([t],H,this.#t,"join_clause","right"),this.#t[this.#t.length-1]}innerJoin(t){return this.#t=this.$castInputs([t],H,this.#t,"join_clause","inner"),this.#t[this.#t.length-1]}crossJoin(t){return this.#t=this.$castInputs([t],H,this.#t,"join_clause","cross"),this.#t[this.#t.length-1]}where(...t){return arguments.length?(this.#e=this.$castInputs(t,Z,this.#e,"where_clause","every"),this):this.#e}orderBy(...t){return arguments.length?(this.#r=this.$castInputs(t,V,this.#r,"order_by_clause","add"),this.#r):this.#r}limit(t){return arguments.length?(this.#s=this.$castInputs([t],Et,this.#s,"limit_clause","value"),this):this.#s}schema({derivationLevel:t=!1}={}){let e=z.fromJSON(this,{name:"",tables:[]}),r=[];if(t){let s=t==="SELECT_LIST_ONLY";for(let i of this.fields?.()||[]){if(i.expr().name?.()==="*"){s&&r.push(i.expr().prefix()?.name());continue}let o=i.schema();if(!o)continue;let n=o.contextNode.name();if(!e.table(n)){let u=o.contextNode.jsonfy();e.table({...u,columns:[]})}e.table(n).column(o.jsonfy())}if(s&&!r.length)return e}for(let s of[...this.tables(),...this.joins()].map(i=>i.schema())){let i=s.name();if(r.length&&!r.includes(i)&&!r.includes(void 0))continue;let o=s.jsonfy();if(e.table(i))for(let n of o.columns)e.table(i).column(n);else e.table(o)}return e}#n=new Map;$capture(t,e){if(t!=="TABLE_SCHEMA"){if(t==="DATABASE_SCHEMA"){let r=this.orderBy()?.contains(e)?1:0;return this.#n.has(r)||this.#n.set(r,this.schema({derivationLevel:r})),this.#n.get(r)}return super.$capture(t,e)}}#i=new Map;resolvePath(t,e){if(!(t instanceof X))throw new Error(`Can't desugar path: ${t}. Must be instance of PathRight.`);let[r,s,i]=t.plot(!0),o=`$relation::${[r,s,i].join(":")}${t.rhs()instanceof Nt?"/g":""}`;if(!this.#i.has(o)){let f=`$key::${(0|Math.random()*9e6).toString(36)}`,c=new H(this);c.left(h=>h.select(d=>d.expr(i.jsonfy()).as(f)).from([s.prefix(),s.name()])).as(o).on(h=>h.equals([o,f],r.jsonfy())),t.rhs()instanceof Nt&&c.expr().expr().groupBy(f),this.#i.set(o,c)}let n=`$path::${(0|Math.random()*9e6).toString(36)}`,u=f=>f.expr(t.rhs().jsonfy()).as(n);return this.#i.get(o).expr().expr().fields().add(u),{nodeName:b.NODE_NAME,name:n,prefix:o,prettyName:t.prettyName()}}static fromJSON(t,e,r=null){return super.fromJSON(t,e,s=>{if(e.joinClauses?.length)for(let i of e.joinClauses)s.join(i);e.whereClause&&s.where(e.whereClause),e.orderByClause&&s.orderBy(e.orderByClause),e.limitClause&&s.limit(e.limitClause),r?.(s)})}jsonfy(t,e){return super.jsonfy(t,()=>({...this.#t.length?{joinClauses:this.#t.map(r=>r.jsonfy(t))}:{},...this.#e?{whereClause:this.#e.jsonfy(t)}:{},...this.#r?{orderByClause:this.#r.jsonfy(t)}:{},...this.#s?{limitClause:this.#s.jsonfy(t)}:{},...e()}))}finalizeJSON(t,e){t.joinClauses||(t.joinClauses=[]);for(let[,r]of this.#i)t.joinClauses.push(r.jsonfy(e));return this.#i.clear(),super.finalizeJSON(t,e)}};var Bt=class extends de{#t=[];[Symbol.iterator](){return this.#t[Symbol.iterator]()}get length(){return this.#t.length}$capture(t,e){return t==="ROOT_SCHEMA"?this:super.$capture(t,e)}database(t,...e){if(typeof t=="string"){let r=this.#t.find(s=>s.identifiesAs(t));if(!e.length)return r;if(e[0]===!1)return this.#t=this.#t.filter(s=>s!==r),r?.bubble("DISCONNECTED"),this;t={name:t,...typeof e[0]=="object"?e[0]:{tables:e[0]}}}return this.#t=this.$castInputs([t],z,this.#t,"databases",null,r=>this.#t.find(s=>s.identifiesAs(r.name()))),this}databases(t=!0){return t?this.#t:this.#t.map(e=>e.name())}tables(t=!0){return this.#t.reduce((e,r)=>e.concat(t?r.tables():r.tables(!1).map(s=>[r.name(),...s])),[])}columns(t=!0){return this.#t.reduce((e,r)=>e.concat(t?r.columns():r.columns(!1).map(s=>[r.name(),...s])),[])}primaryKeys(t=!0,e=!0){return this.#t.reduce((r,s)=>r.concat(t?s.primaryKeys(!0,e):s.primaryKeys(!1,e).map(i=>[s.name(),...i])),[])}foreignKeys(t=!0,e=!0){return this.#t.reduce((r,s)=>r.concat(t?s.foreignKeys(!0,e):s.foreignKeys(!1,e).map(i=>[s.name(),...i])),[])}uniqueKeys(t=!0,e=!0){return this.#t.reduce((r,s)=>r.concat(t?s.uniqueKeys(!0,e):s.uniqueKeys(!1,e).map(i=>[s.name(),...i])),[])}checks(t=!0,e=!0){return this.#t.reduce((r,s)=>r.concat(t?s.checks(!0,e):s.checks(!1,e).map(i=>[s.name(),...i])),[])}renderCDL(t,e){let r=e,s=new Set,i=new Map,o=[],n=(l,p=!0,y=!0)=>{let _=this.database(l);if((!_||i.has(_)&&!i.get(_))&&p)throw new Error(`Database "${l}" does not exist.`);return y&&i.has(_)?[_,_.constructor.fromJSON(_.contextNode.clone(),i.get(_))]:[_]},u=l=>{let p={...r,rootCDL:!s.has(l)&&t};return s.has(l)||s.add(l),p},f=l=>{if(n(l.argument().name(),!1,!1)[0]){if(l.hasFlag("IF_NOT_EXISTS"))return;throw new Error(`Database "${l.argument()?.name()}" already exists`)}let p=l.argument().jsonfy(r);r.diff!==!1&&(p={...p,status:"new"}),o.push(p)},c=l=>{let[p,y]=n(l.reference().name(),!l.hasFlag("IF_EXISTS"),r.diff!==!1);p&&i.set(p,r.diff===!1?void 0:{...(y||p).jsonfy(r),status:"obsolete"})},h=l=>{let[p,y]=n(l.reference().name()),_=this.diffMergeJsons((y||p).jsonfy(u(p)),l.argument().jsonfy(r),r);i.set(p,_)},d=l=>{let[p,y]=n(l.reference().name()),_=(y||p).renderCDL(l.argument(),u(p));i.set(p,_)},m=l=>{let p,y=u(l);if(i.has(l)){if(!i.get(l))return;y.rootCDL?p=l.constructor.fromJSON(this,i.get(l)).jsonfy(y):p=i.get(l)}else p=l.jsonfy(y);return p};for(let l of t)if(l.CLAUSE==="CREATE")f(l);else if(l.CLAUSE==="DROP")c(l);else if(l.CLAUSE==="RENAME")h(l);else if(l.CLAUSE==="ALTER")d(l);else throw new Error(`Unsupported operation: ${l.CLAUSE} ${l.KIND}`);return this.renderNormalized(this.#t,m).concat(o)}renderNormalized(t,e,r=!1){let s=(n,u)=>this.$eq(n,u?.name||u,"ci"),[i,o]=t.reduce(([n,u],f)=>{let c=e(f);if(c){let h;c={...c,tables:c.tables.reduce((d,m)=>{if(m.prefix)if(s(f.name(),m.prefix))m.$prefix||({prefix:h,...m}=m);else{let l=n.find(p=>s(p.name,m.prefix));return l?(m.$prefix||({prefix:h,...m}=m),l.tables.push(m)):u.push({db:f,tbl:m}),d}return d.concat(m)},[])},u=u.reduce((d,m)=>{let l=m.tbl;return s(f.name(),l.prefix)?(l.$prefix||({prefix:h,...l}=l),c.tables.push(l),d):d.concat(m)},[])}return[n.concat(c||[]),u]},[[],[]]);if(o.length)if(r)for(let{tbl:n}of o){let u=n,f;u.$prefix||({prefix:f,...u}=u);let c=i.find(h=>s(h.name,n.prefix));c?c.tables.push(u):i.push({name:n.prefix.name||n.prefix,tables:[u]})}else throw new Error(`The following tables could not be moved to the implied target database: ${o.map(n=>`"${n.db.name()}"."${n.tbl.name}" -> "${n.tbl.prefix.name||n.tbl.prefix}"."${n.tbl.name}"`).join('", "')}`);return i}generateCDL(t={},e="SCHEMA"){let r=wt.fromJSON(this,{actions:[]});for(let s of this.#t)if(s.status()==="new")r.add("CREATE",e,i=>{i.argument(s.jsonfy({...t,diff:!1})),t.existsChecks&&i.withFlag("IF_NOT_EXISTS")});else if(s.status()==="obsolete")r.add("DROP",e,i=>{i.reference(s.name()),t.cascadeRule&&i.withFlag(t.cascadeRule),t.existsChecks&&i.withFlag("IF_EXISTS")});else{let i=s.generateCDL(t);i.length&&r.add("ALTER",e,o=>{o.reference(s.name()),o.argument(i)})}return r}generateDiff(t,e){return this.diffMergeTrees(this.#t,t.databases(),(r,s)=>r.generateDiff(s,e),e)}defaultDB(){return this.databases(!1)[0]}findPrefix(t,e=!1){let r=this.tables(!1).find(s=>s[1].toLowerCase()===t.toLowerCase())?.[0];return!r&&e?this.defaultDB():r}static fromJSON(t,e,r=null){if(Array.isArray(e))return super.fromJSON(t,e,s=>{for(let i of e)s.database(i);r?.(s)})}jsonfy(t={},e={}){return this.renderNormalized(this.#t,r=>r.jsonfy(t),t.forceNormalize)}};var Ht=class extends T{#t=0;#e;offset(t){if(!arguments.length)return this.#t;if(typeof t!="number")throw new Error("Offset must be a number");return this.#t=t,this}value(t){return arguments.length?(this.#e=t,this):this.#e}static get expose(){return{binding:(t,e)=>new this(t).value(e)}}static fromJSON(t,e,r=null){if(!(!e?.nodeName&&typeof e?.offset!="number"))return super.fromJSON(t,e,s=>{e.offset&&s.offset(e.offset),e.value!==void 0&&s.value(e.value),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,{offset:this.#t,...this.#e!==void 0?{value:this.#e}:{},...e})}static parse(t,e){let r=(t?.params?.inputDialect||t?.params?.dialect)==="mysql"?"?":"$",[s,i]=new RegExp(`^\\${r}(\\d)$`).exec(e)||[];if(s)return new this(t).offset(parseInt(i))}stringify(){return this.params.dialect==="mysql"?"?":`$${this.#t}`}};var xr=a=>class extends cr(a){#t;#e=new Set;get uuid(){return this.#t||(this.#t=`scope_${(0|Math.random()*9e6).toString(36)}`),this.#t}get queryBindings(){return[...this.#e].sort((t,e)=>e.offset()===0||e.offset()>t.offset()?-1:1)}get hasPaths(){return[...this.querySugars].some(t=>t.isPath)}$bubble(t,e){if(["CONNECTED","DISCONNECTED"].includes(t)&&[Ht].some(r=>e instanceof r)){t==="DISCONNECTED"?this.#e.delete(e):this.#e.add(e);return}return super.$bubble(t,e)}$capture(t,e){let r=super.$capture(t,e);return t==="ROOT_SCHEMA"&&!r?Bt.fromJSON(this,[]):r}renderBindings(t){if(!Array.isArray(t))throw new Error("Values must be an array");let e=[...this.#e];for(let r=0;r<t.length;r++){let s=e.filter(i=>i.offset()===r+1);if(!s.length)throw new Error(`No bindings exists at offset #${r}`);s.forEach(i=>i.value(t[r]))}}normalizeBindings(t=!1){let e=[...this.#e];if(!t)return e.forEach((i,o)=>i.offset(o+1)),e;let r=new Map,s=1;for(let i of e)if(i.offset()===0||!r.has(i.offset())){let o=s++;r.set(i.offset(),o),i.offset(o)}else i.offset(r.get(i.offset())).withDetail("redundant",!0);return e.filter(i=>!i.getDetail("redundant"))}static mySubstitutePlaceholders(t,e){return(t?.params?.inputDialect||t?.params?.dialect)!=="mysql"||e.indexOf("?")===-1?e:S.split(e,["?"],{blocks:[]}).reduce((r,s,i)=>r?r+"?"+i+s:s,null)}static fromJSON(t,e,r=null){return super.fromJSON(t,e,s=>{e.uuid&&(s.#t=e.uuid),r?.(s)})}jsonfy(t,e){let r=super.jsonfy(t,e);return this.finalizeJSON(r,t)}finalizeJSON(t,e){return{...this.#t?{uuid:this.#t}:{},...t}}};var Qe=class extends I{static get EXPECTED_TYPES(){return x}static get REGEX(){return"GROUP\\s+BY"}withRollup(){return this.withFlag("WITH_ROLLUP")}static parse(t,e,r){let[s,i,o]=e.match(new RegExp(`^${this.REGEX}([\\s\\S]*)(\\s+WITH\\s+ROLLUP)?$`,"i"))||[];if(!s)return;let n=super.parse(t,i,r);if(n)return o&&n.withFlag("WITH_ROLLUP"),n}stringify(){return this.entries().length?["GROUP BY",super.stringify()].concat(this.hasFlag("WITH_ROLLUP")?"WITH ROLLUP":[]).join(" "):""}};var ze=class extends St{static get CLAUSE(){return"HAVING"}static get minEntries(){return 1}};var Ze=class extends I{static get EXPECTED_TYPES(){return[ae]}static get CLAUSE(){return"WINDOW"}};var ut=class extends Je(xr(T)){static get CLAUSE(){return"SELECT"}#t;#e=[];#r;#s;#n;#i;#o;get statementType(){return"DQL"}fields(...t){return arguments.length?(this.#t=this.$castInputs(t,ce,this.#t,"fields_list","add"),this):this.#t}from(...t){return arguments.length?(this.#e=this.$castInputs(t,j,this.#e,"from_clause"),this):this.#e}tables(){return this.#e}groupBy(...t){return arguments.length?(this.#r=this.$castInputs(t,Qe,this.#r,"group_by_clause","add"),this):this.#r}having(...t){return arguments.length?(this.#s=this.$castInputs(t,ze,this.#s,"having_clause","add"),this):this.#s}window(...t){return arguments.length?(this.#n=this.$castInputs(t,Ze,this.#n,"window_clause","add"),this):this.#n}offset(t){return arguments.length?(this.#i=this.$castInputs([t],ie,this.#i,"offset_clause"),this):this.#i}union(...t){return arguments.length?(this.#o=this.$castInputs(t,this.constructor,this.#o,"union_clause","fields"),this):this.#o}static fromJSON(t,e,r=null){if(e?.fieldsSpec)return super.fromJSON(t,e,s=>{if(s.fields(...[].concat(e.fieldsSpec)),e.fromList?.length)for(let i of e.fromList)s.from(i);e.groupByClause&&s.groupBy(e.groupByClause),e.havingClause&&s.having(e.havingClause),e.windowClause&&s.window(e.windowClause),e.offsetClause&&s.offset(e.offsetClause),e.unionClause&&s.union(e.unionClause),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,()=>({fieldsSpec:this.#t?.jsonfy(t),...this.#e.length?{fromList:this.#e.map(r=>r.jsonfy(t))}:{},...this.#r?{groupByClause:this.#r.jsonfy(t)}:{},...this.#s?{havingClause:this.#s.jsonfy(t)}:{},...this.#n?{windowClause:this.#n.jsonfy(t)}:{},...this.#i?{offsetClause:this.#i.jsonfy(t)}:{},...this.#o?{unionClause:this.#o.jsonfy(t)}:{},...e}))}static parse(t,e,r){let[s,i,o]=/^SELECT\s+(ALL|DISTINCT)?([\s\S]+)$/i.exec(e.trim())||[];if(!s)return;let n=new this(t),u=this.mySubstitutePlaceholders(n,o.trim()),f={from:{backtest:"^(?!.*\\s+DISTINCT\\s+$)",test:"FROM"},join:H,where:Z,groupBy:Qe,having:ze,window:Ze,orderBy:V,limit:Et,offset:ie,union:"UNION"},[c,...h]=S.split(u,Object.values(f).map(d=>d.REGEX||d.CLAUSE||d),{useRegex:"i",preserveDelims:!0});n.fields(r(n,c.trim(),[ce]));t:for(let d of h){if(/^FROM/i.test(d)){let m=S.split(d.replace(/FROM/i,""),[","]).map(l=>r(n,l.trim(),[j]));for(let l of m)n.from(l);continue}if(/^UNION/i.test(d)){n.union(r(n,d.replace(/UNION/i,"").trim(),[this]));continue}if(/^LIMIT.*,(?:\s+)?\d$/i.test(d)){let[m,l]=d.match(/(\d+)(?:\s+)?,(?:\s+)?(\d+)$/);h.push(`LIMIT ${l}`,`OFFSET ${m}`);continue}for(let m in f){let l=f[m].parse?.(n,d.trim(),r);if(l){n[m](l);continue t}}}return i&&n.withFlag(i),n}stringify(){let t=["SELECT"];return this.getFlag().length&&t.push(this.getFlag().map(e=>e.replace(/_/g," "))),t.push(this.#t),this.#e.length&&t.push("FROM",this.#e.join(", ")),t.push(...this.joins(),this.where(),this.#r,this.#s,this.#n,this.orderBy(),this.limit(),this.#i),this.#o&&t.push(this.#o),t.filter(e=>e).join(" ")}};var Gt=class a extends T{static get EXPECTED_TYPES(){return x}#t;expr(...t){return arguments.length?(this.#t=this.$castInputs(t,this.constructor.EXPECTED_TYPES,this.#t,"parens_expr"),this):this.#t}exprUnwrapped(){return this.#t instanceof a?this.#t.exprUnwrapped():this.#t}static get expose(){return{parens:(t,e)=>this.fromJSON(t,{expr:e})}}static fromJSON(t,e,r=null){if(e?.expr)return super.fromJSON(t,e,s=>{s.expr(e.expr),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,{expr:this.#t?.jsonfy(t),...e})}static parse(t,e,r){if(!xt(e,"(",")")||S.match(e,[" "]).length&&S.split(e,[]).length===2)return;let s=new this(t),i=r(s,Q(e,"(",")"),this.constructor.EXPECTED_TYPES);return s.expr(i)}stringify(){return"("+this.#t.stringify()+")"}};var Le=class extends Gt{static get EXPECTED_TYPES(){return[ut]}select(...t){return this.expr({fieldsSpec:t}).expr()}static get expose(){}schema(){let t=Dt.fromJSON(this,{name:"",columns:[]}),e=this.expr().schema({derivationLevel:"SELECT_LIST_ONLY"}).columns()||[];for(let r of e)t.column({...r.jsonfy()});return t}static fromJSON(t,e,r=null){if(!(!e?.expr||!e?.expr?.fieldsSpec))return super.fromJSON(t,e,r)}static parse(t,e,r){if(/\(\s*SELECT\s+/i.test(e))return super.parse(t,e,r)}};var tr=class extends T{#t;#e;when(t){return arguments.length?(this.#t=this.$castInputs([t],x,this.#t,"when_clause"),this):this.#t}then(t){return arguments.length?(this.#e=this.$castInputs([t],x,this.#e,"then_clause"),this):this.#e}static get expose(){return{when:(t,e)=>this.fromJSON(t,{when:e})}}static fromJSON(t,e,r=null){if(e?.when)return super.fromJSON(t,e,s=>{s.when(e.when).then(e.then),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,{when:this.#t?.jsonfy(t),then:this.#e?.jsonfy(t),...e})}static parse(t,e,r){let[s,i]=e.match(new RegExp("^WHEN([\\s\\S]*)$","i"))||[];if(!s)return;let o=S.split(i,["\\s+THEN\\s+"],{useRegex:"i"});if(o.length!==2)return;let n=new this(t),[u,f]=o.map(c=>r(n,c.trim()));return n.when(u).then(f)}stringify(){return`WHEN ${this.#t} THEN ${this.#e}`}};var $r=class extends T{#t;#e=[];#r;switchExpr(t){return arguments.length?(this.#t=this.$castInputs([t],x,this.#t,"switchExpr"),this):this.#t}cases(...t){return arguments.length?(this.#e=this.$castInputs(t,tr,this.#e,"cases"),this):this.#e.slice()}default(t){if(!arguments.length)return this.#r;if(!this.#e.length)throw new Error('A "default" expression cannot come before "case" clauses.');return this.#r=this.$castInputs([t],x,this.#r,"defaultExpr"),this}static get expose(){return{switch:(t,e)=>this.fromJSON(t,{switchExpr:e,cases:[]}),cases:(t,...e)=>this.fromJSON(t,{cases:e})}}static fromJSON(t,e,r=null){if(Array.isArray(e?.cases))return super.fromJSON(t,e,s=>{e.switchExpr&&s.switchExpr(e.switchExpr),s.cases(...e.cases),e.defaultExpr&&s.default(e.defaultExpr),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,{switchExpr:this.#t?.jsonfy(t),cases:this.#e.map(r=>r.jsonfy(t)),defaultExpr:this.#r?.jsonfy(t),...e})}static parse(t,e,r){let[s,i]=e.match(/^CASE\s+([\s\S]*)\s+END(\s+CASE)?$/i)||[];if(!s)return;let{tokens:[o,...n],matches:u}=S.lex(i,["WHEN","ELSE"],{useRegex:"i",preserveDelims:!0}),f=new this(t);o.trim()&&f.switchExpr(r(f,o.trim()));for(let c of u){let h=n.shift();if(/ELSE/i.test(c))f.default(r(f,h.replace(/ELSE/i,"").trim()));else if(/WHEN/i.test(c))f.cases(r(f,h.trim(),[tr]));else throw new Error(`Can't have multiple "${c}" clauses in a CASE construct.`)}return f}stringify(){let t=[];return this.#t&&t.push(this.#t),t.push(...this.#e),this.#r&&t.push("ELSE",this.#r),`CASE ${t.join(" ")} END${this.params.dialect==="mysql"?" CASE":""}`}};var Or=class extends yt{static get LHS_TYPES(){return x}static get RHS_TYPES(){return x}static get OPERATORS(){return[{test:"<(?!~)"},{test:"(?<!~)>",backtest:"^(?!.*~$)"},{test:"(?<!<)(?:\\!)?~(?:\\*)?(?!>)",backtest:"^(?!.*<$)"},{test:"(\\s+(?:IS\\s+(?:NOT\\s+)?(TRUE|FALSE|NULL|UNKNOWN|DISTINCT\\s+FROM)|ANY|ALL|(?:NOT\\s+)?(?:IN|LIKE|EXISTS|SIMILAR\\s+TO|BETWEEN(?:\\s+SYMMETRIC)?))\\s+|(?:\\s+)?(=|<=|>=|!=|<>)(?:\\s+)?)"}]}static get expose(){return{"equals|eq":(t,e,r)=>this.fromJSON(t,{operator:"=",lhs:e,rhs:r}),"notEqual|notEq":(t,e,r)=>this.fromJSON(t,{operator:"<>",lhs:e,rhs:r}),"lesserThan|lt":(t,e,r)=>this.fromJSON(t,{operator:"<",lhs:e,rhs:r}),"lessThanOrEqual|ltOrEq":(t,e,r)=>this.fromJSON(t,{operator:"<=",lhs:e,rhs:r}),"greaterThan|gt":(t,e,r)=>this.fromJSON(t,{operator:">",lhs:e,rhs:r}),"greaterThanOrEqual|gtOrEq":(t,e,r)=>this.fromJSON(t,{operator:">=",lhs:e,rhs:r}),any:(t,e,...r)=>this.fromJSON(t,{operator:"ANY",lhs:e,rhs:{row:r}}),all:(t,e,...r)=>this.fromJSON(t,{operator:"ALL",lhs:e,rhs:{row:r}}),in:(t,e,...r)=>this.fromJSON(t,{operator:"IN",lhs:e,rhs:{row:r}}),notIn:(t,e,...r)=>this.fromJSON(t,{operator:"NOT IN",lhs:e,rhs:{row:r}}),exists:(t,e,r)=>this.fromJSON(t,{operator:"EXISTS",lhs:e,rhs:r}),notExists:(t,e,r)=>this.fromJSON(t,{operator:"NOT EXISTS",lhs:e,rhs:r}),like:(t,e,r)=>this.fromJSON(t,{operator:"LIKE",lhs:e,rhs:r}),notLike:(t,e,r)=>this.fromJSON(t,{operator:"NOT LIKE",lhs:e,rhs:r}),similarTo:(t,e,r)=>this.fromJSON(t,{operator:"SIMILAR TO",lhs:e,rhs:r}),notSimilarTo:(t,e,r)=>this.fromJSON(t,{operator:"NOT SIMILAR TO",lhs:e,rhs:r}),matches:(t,e,r)=>this.fromJSON(t,{operator:"~",lhs:e,rhs:r}),matchesi:(t,e,r)=>this.fromJSON(t,{operator:"~*",lhs:e,rhs:r}),notMatches:(t,e,r)=>this.fromJSON(t,{operator:"!~",lhs:e,rhs:r}),notMatchesi:(t,e,r)=>this.fromJSON(t,{operator:"!~*",lhs:e,rhs:r}),between:(t,e,r)=>this.fromJSON(t,{operator:"BETWEEN",lhs:e,rhs:r}),notBetween:(t,e,r)=>this.fromJSON(t,{operator:"NOT BETWEEN",lhs:e,rhs:r}),betweenSymmetric:(t,e,r)=>this.fromJSON(t,{operator:"BETWEEN SYMMETRIC",lhs:e,rhs:r}),notBetweenSymmetric:(t,e,r)=>this.fromJSON(t,{operator:"NOT BETWEEN SYMMETRIC",lhs:e,rhs:r}),isNull:(t,e)=>this.fromJSON(t,{operator:"IS NULL",lhs:e}),isNotNull:(t,e)=>this.fromJSON(t,{operator:"IS NOT NULL",lhs:e}),isTrue:(t,e)=>this.fromJSON(t,{operator:"IS TRUE",lhs:e}),isNotTrue:(t,e)=>this.fromJSON(t,{operator:"IS NOT TRUE",lhs:e}),isFalse:(t,e)=>this.fromJSON(t,{operator:"IS FALSE",lhs:e}),isNotFalse:(t,e)=>this.fromJSON(t,{operator:"IS NOT FALSE",lhs:e}),isUnknow:(t,e)=>this.fromJSON(t,{operator:"IS UNKNOWN",lhs:e}),isNotUnknow:(t,e)=>this.fromJSON(t,{operator:"IS NOT UNKNOWN",lhs:e}),isDistinctFrom:(t,e,r)=>this.fromJSON(t,{operator:"IS DISTINCT FROM",lhs:e,rhs:r}),isNotDistinctFrom:(t,e,r)=>this.fromJSON(t,{operator:"IS NOT DISTINCT FROM",lhs:e,rhs:r})}}static parse(t,e,r){let{tokens:[s,i=""],matches:[o]}=S.lex(e,this.OPERATORS,{useRegex:"i"});if(!o)return;let n=new this(t).operator(o.trim().replace(/\s+/," ").toUpperCase());return n.lhs(r(n,s)),i&&n.rhs(r(n,i)),n}};var br=class extends I{static get EXPECTED_TYPES(){return x}static get CLAUSE(){return"ARRAY"}static get TAGS(){return["[","]"]}static get expose(){return{array:(t,...e)=>this.fromJSON(t,{entries:e})}}};var Dr=class extends Xt{static get OPERATORS(){return["||"]}static get expose(){return{join:(t,...e)=>this.fromJSON(t,{operator:"||",entries:e})}}};var wr=class extends Xt{static get OPERATORS(){return["+","-","*","/"]}static get expose(){return{sum:(t,...e)=>e.length>1&&this.fromJSON(t,{operator:"+",entries:e}),sub:(t,...e)=>this.fromJSON(t,{operator:"-",entries:e}),"times|tms":(t,...e)=>this.fromJSON(t,{operator:"*",entries:e}),div:(t,...e)=>this.fromJSON(t,{operator:"/",entries:e})}}};var Rr=class extends T{#t;value(t){return arguments.length?(this.#t=t,this):this.#t}identifiesAs(t){return t===this.#t||super.identifiesAs(t)}static get expose(){return{true:t=>this.fromJSON(t,{value:!0}),false:t=>this.fromJSON(t,{value:!1}),value:(t,e)=>/^(TRUE|FALSE)$/i.test(e)&&this.fromJSON(t,{value:/^TRUE$/i.test(e)})}}static fromJSON(t,e,r=null){if(!(![!0,!1].includes(e?.value)||Object.keys(e).filter(s=>s!=="nodeName").length>1))return super.fromJSON(t,e,s=>{s.value(e.value),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,{value:this.#t,...e})}static parse(t,e){if(/^TRUE$/i.test(e))return new this(t).value(!0);if(/^FALSE$/i.test(e))return new this(t).value(!1)}stringify(){return`${this.#t}`}};var Ir=class extends T{#t;#e;#r=!1;value(t){return arguments.length?(this.#t=this.$castInputs([t],x,this.#t,"type_cast"),this):this.#t}type(t){return arguments.length?(this.#e=t,this):this.#e}compact(t=this.#r){return arguments.length?(this.#r=t,this):this.#r}static get expose(){return{cast:(t,e,r,s)=>this.fromJSON(t,{value:e,type:r,compact:s})}}static fromJSON(t,e,r=null){if(!(!e?.value||!e.type||Object.keys(e).filter(s=>!["nodeName","type","compact"].includes(s)).length>1))return super.fromJSON(t,e,s=>{s.value(e.value).type(e.type).compact(e.compact),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,{value:this.#t?.jsonfy(t),type:this.#e,compact:this.#r,...e})}static parse(t,e,r){let s,i,o=!1;if(/^CAST(?:\s+)?\([\s\S]+\)$/i.test(e)){let[,u]=S.split(e,[]);[s,i]=S.split(u.slice(1,-1),["AS"],{useRegex:"i"})}else{if((t?.params?.inputDialect||t?.params?.dialect)==="mysql"||([s,i]=S.split(e,["::"]),!i))return;o=!0}let n=new this(t).type(i.trim()).compact(o);return n.value(r(n,s.trim()))}stringify(){return this.#r&&this.params.dialect!=="mysql"?`${this.#t}::${this.#e}`:`CAST(${this.#t} AS ${this.#e})`}};var Tt=class extends I{static get EXPECTED_TYPES(){return[B]}static get ARGS_DELEGATION(){return"add"}static get CLAUSE(){return"VALUES"}static get expose(){return{values:(t,...e)=>this.fromJSON(t,{entries:e})}}};var Lr=class extends B{static get MIN_ENTRIES(){return 0}static get CLAUSE(){return"ROW"}stringify(){let t=super.stringify();return this.contextNode instanceof Tt?`(${t})`:t}};var le=class extends Tt{static get TAGS(){return["(",")"]}};var he=class extends Ht{#t=[];get resolutionPath(){return this.#t.slice()}get isForeign(){return!0}static get expose(){return{}}resolve(t,e){if(!["INSERT_STATEMENT","UPSERT_STATEMENT"].includes(t?.NODE_NAME))throw new Error("Source query must be an INSERT or UPSERT statement");if(this.#t[0]!==t.uuid)return;if(!Array.isArray(e))throw new Error("Input source must be an array");if(!N(e[this.#t[1]]))throw new Error(`Input source does not have an object at: #${this.resolutionPath[1]}`);let r=e[this.#t[1]][this.#t[2]];if(!r)throw new Error(`Input source does not have a value at: [${this.resolutionPath}]`);return this.value(r)}static fromJSON(t,e,r=null){if(!(!Array.isArray(e?.resolutionPath)||e.resolutionPath.length!==3))return super.fromJSON(t,{offset:0,...e},s=>{s.#t=e.resolutionPath.slice(),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,{resolutionPath:this.#t.slice(),...e})}stringify(){return this.value()?super.stringify():this.params.dialect==="mysql"?`$${this.#t.join(".")}`:`$${this.#t.join(".")}`}};var x=[Le,$r,Dr,St,X,Me,Or,wr,B,br,Gt,Lr,le,Nt,Ir,ue,it,Rr,fe,Ue,st,oe,ne,Ht,he,b,Ae];var Pr=class extends Pt{static get EXPECTED_TYPES(){return x}};var ce=class extends I{static get EXPECTED_TYPES(){return[Pr]}};var _t=class extends ce{static get CLAUSE(){return"RETURNING"}};var qt=class extends xr(T){#t;get statementType(){return"DML"}returning(...t){return arguments.length?(this.#t=this.$castInputs(t,_t,this.#t,"returning_clause","add"),this):this.#t}static fromJSON(t,e,r=null){return super.fromJSON(t,e,s=>{e.returningClause&&s.returning(e.returningClause),r?.(s)})}jsonfy(t,e){return super.jsonfy(t,()=>({...this.#t?{returningClause:this.#t.jsonfy(t)}:{},...e()}))}};var Wt=class extends Je(qt){static get CLAUSE(){return"DELETE"}#t=[];#e;#r=[];delete(...t){return arguments.length?(this.#t=this.$castInputs(t,w,this.#t,"delete_list"),this):this.#t}from(t){return arguments.length?(this.#e=this.$castInputs([t],j,this.#e,"from_clause","expr"),this):this.#e}using(...t){return arguments.length?(this.#r=this.$castInputs(t,j,this.#r,"using_clause","expr"),this):this.#r}tables(){let t=this.#e&&[this.#e]||[];return this.#e&&this.#r.length&&t.push(...this.#r.filter(e=>!e.expr().identifiesAs(this.#e.expr().name())||e.alias()&&this.#e.alias()&&!this.$eq(e.alias(),this.#e.alias(),"ci"))),t}static fromJSON(t,e,r=null){if(e?.table)return super.fromJSON(t,e,s=>{e.mysqlDeleteList?.length&&s.delete(...e.mysqlDeleteList),s.from(e.table),e.postgresUsingList?.length&&s.using(...e.postgresUsingList),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,()=>({...this.#t.length?{mysqlDeleteList:this.#t.map(r=>r.jsonfy(t))}:{},table:this.#e?.jsonfy(t),...this.#r.length?{postgresUsingList:this.#r.map(r=>r.jsonfy(t))}:{},...e}))}static parse(t,e,r){let[s,i,o]=/^DELETE(?:\s+(IGNORE))?([\s\S]+)$/i.exec(e.trim())||[];if(!s)return;let n=new this(t),u=this.mySubstitutePlaceholders(n,o.trim()),f=t?.params?.dialect||"postgres",c={from:{backtest:"^(?!.*\\s+DISTINCT\\s+$)",test:"FROM"},...f==="postgres"?{using:{backtest:"^(?!.*\\s+JOIN\\s+)",test:"USING"}}:{},...f==="mysql"?{join:H}:{},where:Z,...f==="mysql"?{orderBy:V}:{},limit:Et,returning:_t},[h="",...d]=S.split(u,Object.values(c).map(m=>m.REGEX||m.CLAUSE||m),{useRegex:"i",preserveDelims:!0});h.trim()&&n.delete(...S.split(h,[","]).map(m=>r(n,m.trim(),[w])));t:for(let m of d){if(/^FROM/i.test(m)){n.from(r(n,m.replace(/FROM/i,"").trim(),[j]));continue}if(/^USING/i.test(m)){n.using(...S.split(m.replace(/USING/i,""),[","]).map(l=>r(n,l.trim(),[j])));continue}for(let l in c){let p=c[l].parse?.(n,m.trim(),r);if(p){n[l](p);continue t}}}return i&&n.withFlag(i),n}stringify(){let t=["DELETE"];return t.push(...this.getFlag().map(e=>e.replace(/_/g," "))),this.params.dialect==="mysql"?(t.push(this.#t.join(", ")),t.push(`FROM ${this.#e}`),t.push(...this.joins(),this.where(),this.orderBy(),this.limit(),this.returning())):(t.push(`FROM ${this.#e}`),this.#r.length&&t.push(`USING ${this.#r.join(", ")}`),t.push(this.where(),this.limit(),this.returning())),t.filter(e=>e).join(" ")}};var Fe=class extends yt{static get OPERATORS(){return["="]}static get LHS_TYPES(){return[v,b]}static get RHS_TYPES(){return[B,...x]}static parse(t,e,r){let[s,i]=S.split(e,this.OPERATORS);if(!i)return;let o=new this(t).operator("=");return o.lhs(r(o,s.trim(),this.LHS_TYPES)),o.rhs(r(o,i.trim(),this.RHS_TYPES)),o}};var ft=class extends I{static get EXPECTED_TYPES(){return[Fe]}static get CLAUSE(){return"SET"}columns(){return this.entries().reduce((t,e)=>e.lhs()instanceof v?t.concat(e.lhs().entries()):t.concat(e.lhs()),[])}values(){return this.entries().reduce((t,e)=>e.rhs()instanceof B?t.concat(e.rhs().entries()):t.concat(e.rhs()),[])}assignment(t,e){return this.add(this.$castInputs([t,e],this.constructor.EXPECTED_TYPES,null,"assignment","operands"))}jsonfy(t={},e={},r=null){return!t.deSugar||!this.statementNode?super.jsonfy(t,e,r):super.jsonfy(t,e,s=>{if(s.lhs()instanceof X){let[i,o]=this.statementNode.createDimension(s.lhs(),t),n=i.offlaod(0,s.rhs());return o?{nodeName:Fe.NODE_NAME,lhs:o,rhs:n,operator:"="}:void 0}if(s.lhs()instanceof v){let i={...t,explicitRowOffset:0},[o,[n]]=this.statementNode.filterPayload(s.lhs(),[s.rhs()],i);return o.entries.length?void 0:{nodeName:Fe.NODE_NAME,lhs:o,rhs:n,operator:"="}}return!0})}};var vr=a=>class extends a{#t=[];#e=[];#r;get dependencies(){return this.#t}get dependents(){return this.#e}get localBindings(){return this.queryBindings.filter(t=>!t.isForeign)}get foreignBindings(){return this.queryBindings.filter(t=>t.isForeign)}get isPayloadStatement(){return!0}set(...t){return arguments.length?(this.#r=this.$castInputs(t,ft,this.#r,"set","assignment"),this):this.#r}renderForeignBindings(t,e){return this.foreignBindings.filter(s=>s.resolve(t,e))}createExecutionPlan(t){return[async()=>{if(this.#t.length)for(let s of this.#t){let i=await t(s);this.renderForeignBindings(s,i)}},async s=>{if(!this.#e.length)return s;for(let i of this.#e){let o=i.renderForeignBindings(this,s),n=await t(i)}return s}]}filterPayload(t,e,r={}){let s=new Map,i=t.jsonfy(r,{},(n,u)=>{if(n instanceof X){let[f,c]=this.createDimension(n,r);if(s.set(u,f),c)return c}else return n.jsonfy(r)}),o=e.map((n,u)=>n.jsonfy(r,{},(f,c)=>s.has(c)?s.get(c).offload(r.explicitRowOffset??u,f):f.jsonfy(r)));return s.clear(),[i,o]}#s=new Set;#n=new Set;#i=new Set;createDimension(t,e={}){if(![v,b,X].some(m=>t.rhs()instanceof m))throw new Error(`Invalid columns spec: ${t}`);let r={...e,deSugar:!1},[s,i,o]=t.plot(),n=new([].concat(this.constructor.DIMENSIONS_TO))[0](this.baseClient);n.into(i.jsonfy());let u=t.rhs();n.columns(u.jsonfy(r));let f=(m,l=!1)=>{if(m instanceof Gt&&(m=m.exprUnwrapped()),!l&&m instanceof le)throw new Error(`Single-row payload structure expected for column structure: ${t.rhs()}. Recieved ${m.NODE_NAME}.`);return l&&!(m instanceof le)&&(m=[m]),m},c=(m,l=0)=>{let p=(m instanceof B?m.length:1)+l;if(p>n.columns().length)throw new Error("INSERT has more expressions than target columns");if(p<n.columns().length)throw new Error("INSERT has more target columns than expressions");return m};if(t.lhs()instanceof Rt){n.columns().add(o.name());let m=s.name();this.returning()?.has(m)||this.#i.add(m);let p={query:n,offload:(y,_)=>{_=f(_,!0);let E=he.fromJSON(n,{resolutionPath:[this.uuid,y,m]});for(let A of _){let g=c(A,1).jsonfy(e);g.entries.push(E.jsonfy()),n.values(g)}}};return this.#n.add(p),[p]}n.returning("*");let d={query:n,offload:(m,l)=>{let p=f(l,!1);return n.values(c(p).jsonfy(e)),he.fromJSON(this,{resolutionPath:[n.uuid,m,o.name()]}).jsonfy()}};return this.#s.add(d),[d,s.jsonfy()]}static fromJSON(t,e,r=null){if(e?.table)return super.fromJSON(t,e,s=>{e.setClause&&s.set(e.setClause),e.dependencies?.length&&(s.#t=s.$castInputs(e.dependencies,this.DIMENSIONS_TO,[])),e.dependents?.length&&(s.#e=s.$castInputs(e.dependents,this.DIMENSIONS_TO,[])),r?.(s)})}jsonfy(t,e){return super.jsonfy(t,()=>({...this.#r?{setClause:this.#r?.jsonfy(t)}:{},...e()}))}finalizeJSON(t,e){return(this.#s.size||this.#n.size)&&(t.dependencies=[...this.#s].map(r=>r.query.jsonfy(e)),t.dependents=[...this.#n].map(r=>r.query.jsonfy(e)),this.#s.clear(),this.#n.clear()),super.finalizeJSON(t,e)}};var me=class extends ft{static get CLAUSE(){}#t;#e;columnsSpec(...t){return arguments.length?(this.#e=this.$castInputs(t,v,this.#e,"columns_spec","add"),this):this.#e}where(...t){return arguments.length?(this.#t=this.$castInputs(t,Z,this.#t,"where_clause","every"),this):this.#t}static fromJSON(t,e,r=null){return super.fromJSON(t,e,s=>{e.columnsSpec&&s.columnsSpec(e.columnsSpec),e.whereClause&&s.where(e.whereClause),r?.(s)})}jsonfy(t={},e={},r=null){return super.jsonfy(t,{...this.#e?{columnsSpec:this.#e.jsonfy(t)}:{},...this.#t?{whereClause:this.#t.jsonfy(t)}:{},...e},r)}static get REGEX(){return"ON\\s+(?:DUPLICATE\\s+KEY|CONFLICT(?:\\s+([\\s\\S]+))?)\\s+(UPDATE|DO\\s+NOTHING|DO\\s+UPDATE\\s+SET\\s+)"}static parse(t,e,r){let[s,i,o,n]=e.match(new RegExp(`^${this.REGEX}([\\s\\S]*)$`,"i"))||[];if(!s)return;if(/DO\s+NOTHING/i.test(o))return new this(t);let[u,f]=S.split(n,["WHERE"],{useRegex:"i",preserveDelims:!0}),c=super.parse(t,u,r);return i&&c.columnsSpec(r(c,i,[v])),f&&c.where(r(c,f.trim(),[Z])),c}stringify(){let t=[];return this.params.dialect==="mysql"?t.push("ON DUPLICATE KEY UPDATE"):t.push(`ON CONFLICT ${this.#e?`${this.#e} `:""}${this.entries().length?"DO UPDATE SET":"DO NOTHING"}`),t.push(super.stringify()),this.#t&&t.push(this.#t),t.join(" ")}};var tt=class a extends vr(qt){static get CLAUSE(){return"INSERT"}static get DIMENSIONS_TO(){return[a]}#t;#e;#r;#s;#n;into(t){return arguments.length?(this.#t=this.$castInputs([t],O,this.#t,"table_spec","expr"),this):this.#t}columns(...t){return arguments.length?(this.#e=this.$castInputs(t,v,this.#e,"columns_spec","add"),this):this.#e}values(...t){return arguments.length?(this.#r=this.$castInputs(t,Tt,this.#r,"values_clause","add"),this):this.#r}select(...t){return arguments.length?(this.#s=this.$castInputs(t,ut,this.#s,"select_clause","fields"),this):this.#s}onConflict(...t){return arguments.length?(this.#n=this.$castInputs(t,me,this.#n,"on_conflict_clause","assignment"),this):this.#n}schema(){let t=z.fromJSON(this,{name:"",tables:[]});return t.table(this.#t.schema().jsonfy()),t}#i;$capture(t,e){if(t!=="TABLE_SCHEMA")return t==="DATABASE_SCHEMA"?(this.#i||(this.#i=this.schema()),this.#i):super.$capture(t,e)}static fromJSON(t,e,r=null){if(e?.table)return super.fromJSON(t,e,s=>{s.into(e.table),e.columnsSpec&&s.columns(e.columnsSpec),e.valuesClause&&s.values(e.valuesClause),e.selectClause&&s.select(e.selectClause),e.onConflictClause&&s.onConflict(e.onConflictClause),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,()=>{let r,s,i;if(t.deSugar&&this.#e&&this.#r){let[n,u]=this.filterPayload(this.#e,this.#r.entries(),t);r=n,s={nodeName:Tt.NODE_NAME,entries:u}}else r=this.#e?.jsonfy(t),s=this.#r?.jsonfy(t),i=this.#s?.jsonfy(t);let o=this.#n?.jsonfy(t);return{table:this.#t?.jsonfy(t),...r?{columnsSpec:r}:{},...s?{valuesClause:s}:{},...i?{selectClause:i}:{},...o?{onConflictClause:o}:{},...e}})}static parse(t,e,r){let[s,i,o]=new RegExp(`^${this.CLAUSE}(?:\\s+(IGNORE))?(?:\\s+INTO)?([\\s\\S]+)$`,"i").exec(e.trim())||[];if(!s)return;let n=new this(t),u=this.mySubstitutePlaceholders(n,o.trim()),f=t?.params?.dialect||"postgres",c={values:Tt,...f==="mysql"?{set:ft}:{},select:ut,onConflict:me,returning:_t},[h,...d]=S.split(u,Object.values(c).map(p=>p.REGEX||p.CLAUSE||p),{useRegex:"i",preserveDelims:!0}),[m,l=""]=S.split(h,[]);n.into(r(n,m.trim(),[O])),l.trim()&&n.columns(r(n,l.trim(),[v]));t:for(let p of d)for(let y in c){let _=c[y].parse?.(n,p.trim(),r);if(_){n[y](_);continue t}}return i&&n.withFlag(i),n}stringify(){let t=[this.constructor.CLAUSE];return t.push(...this.getFlag().map(e=>e.replace(/_/g," "))),t.push("INTO",this.#t),this.params.dialect==="mysql"&&this.set()?t.push(this.set()):(t.push(this.#e),this.#r?t.push(this.#r):t.push(this.#s)),t.push(this.#n),t.push(this.returning()),t.filter(e=>e).join(" ")}};var Ye=class a{constructor(t,e){Object.defineProperty(this,"$",{value:{client:t,json:e}})}get client(){return this.$.client}id(){return this.$.json.id}masterSavepoint(){return this.$.json.master_savepoint}name(t=!1){return t?this.versionState()==="rollback"&&this.$.json.$name||this.$.json.name:this.versionState()==="commit"&&this.$.json.$name||this.$.json.name}schema(){let{name:t,$name:e,tables:r=[],status:s}=this.$.json;return z.fromJSON(this.client,{name:t,...e?{$name:e}:{},tables:r,status:s})}cascades(){return this.$._cascades=this.$._cascades||(this.$.json.cascades||[]).map(t=>new a(this.client,t)),this.$._cascades}databaseTag(){return this.$.json.database_tag}versionTag(){return this.$.json.version_tag}versionTags(){return this.$.json.version_tags||[this.$.json.version_tag]}versionUp(){return this.versionTags().reduce((t,e)=>t||(e>this.versionTag()?e:0),0)}versionDown(){return[...this.versionTags()].reverse().reduce((t,e)=>t||(e<this.versionTag()?e:0),0)}versionMax(){return Math.max(...this.versionTags())}versionState(){return this.$.json.version_state}commitDate(){return this.$.json.commit_date}commitDesc(){return this.$.json.commit_desc}commitClientID(){return this.$.json.commit_client_id}commitClientPID(){return this.$.json.commit_client_pid}rollbackDate(){return this.$.json.rollback_date}rollbackDesc(){return this.$.json.rollback_desc}rollbackClientID(){return this.$.json.rollback_client_id}rollbackClientPID(){return this.$.json.rollback_client_pid}restoreEffect(){let t=this.$.json.status==="new"?["DROP","RECREATE"]:this.$.json.status==="obsolete"?["RECREATE","DROP"]:["ALTER"];return this.versionState()==="rollback"?t.reverse()[0]:t[0]}reverseSQL(){return this.versionState()==="rollback"?this.querify(!0):[this.querify(!0),...this.cascades().map(t=>t.reverseSQL())].join(`
`)}static fromJSON(t,e){return new this(t,e)}jsonfy(){return this.$.json}querify(t=!1){let e=Bt.fromJSON(this.client,[this.schema()]),r=this.versionState()==="rollback";return t&&(r=!r),r&&(e=e.reverseDiff({forceNormalize:!0,honourCDLIgnoreList:this.versionState()==="rollback"})),e.generateCDL({cascadeRule:"CASCADE"}).actions()[0]}async isNextRestorePoint(){return(await this.client.database(this.name()).savepoint({lookAhead:this.versionState()==="rollback",withCascades:!1})||{}).id?.()===this.$.json.id}async rollback(t={}){if(this.versionState()==="rollback")throw new Error("Already in rollback state.");return await this.restore(t)}async recommit(t={}){if(this.versionState()==="commit")throw new Error("Already in commit state.");return await this.restore(t)}async restore(t={}){if(this.masterSavepoint()){if(this.versionState()==="commit"){let i=this.querify(!0);i&&await this.client.withMode("restore",()=>this.client.query(i))}}else{if(!await this.isNextRestorePoint())throw new Error("Invalid restore order.");await this.client.withMode("restore",()=>this.client.query(this.querify(!0)))}let e=await this.client.linkedDB(),r=this.versionState()==="rollback"?"commit":"rollback",s=await e.table("savepoints").update({version_state:r,[`${r}_date`]:i=>i.now(),[`${r}_desc`]:t.desc||this[`${r}Desc`](),[`${r}_client_id`]:this.client.params.clientID||this[`${r}ClientID`](),[`${r}_client_pid`]:i=>i.fn(this.client.params.dialect==="mysql"?"connection_id":"pg_backend_pid")},{where:i=>i.eq("id",o=>o.value(this.$.json.id)),returning:["*"]});for(let i of this.cascades())await i.restore(t);return this.$.json=s[0],!0}};var je=class extends k(Ie){};var Vt=class a extends rt(tt){static get CLAUSE(){return"UPSERT"}static get DIMENSIONS_TO(){return[a]}static get DESUGARS_TO(){return[tt]}jsonfy(t={},e={}){if(!t.deSugar)return super.jsonfy(t,e);let{nodeName:r,flags:s,...i}=super.jsonfy(t,e);if(this.onConflict())throw new Error('A redundanct "ON CONFLICT" clause in query.');let o=(this.set()?this.set().columns():this.columns().entries()).map(f=>f.name()),n=this.params.dialect==="mysql"?f=>c=>c.fn("VALUES",f):f=>["EXCLUDED",f],u=me.fromJSON(this,{entries:[]});for(let f of o)u.assignment(f,n(f));if(this.params.dialect!=="mysql"){let f=this.into().schema(),c=[].concat(f.primaryKey()||[]).concat(f.uniqueKeys()).map(d=>d.columns());if(!c.length)throw new Error(`Table ${this.into().clone({fullyQualified:!0})} has no unique keys defined to process an UPSERT operation. You may want to perform a direct INSERT operation.`);let h=c.find(d=>lt(d,o).length)||c[0];u.columnsSpec(...h)}return{nodeName:tt.NODE_NAME,...i,onConflictClause:u.jsonfy(t),...s?{flags:s}:{}}}};var ke=class extends vr(Je(qt)){static get CLAUSE(){return"UPDATE"}static get DIMENSIONS_TO(){return[Vt]}#t=[];#e=[];table(...t){return arguments.length?(this.#t=this.$castInputs(t,j,this.#t,"table_spec","expr"),this):this.#t}from(...t){return arguments.length?(this.#e=this.$castInputs(t,j,this.#e,"from_clause","expr"),this):this.#e}tables(){return this.#t.concat(this.#e)}static fromJSON(t,e,r=null){if(Array.isArray(e?.tables))return super.fromJSON(t,e,s=>{s.table(...e.tables),e.postgresFromList?.length&&s.from(...e.postgresFromList),r?.(s)})}jsonfy(t={},e={}){return super.jsonfy(t,()=>({tables:this.#t.map(r=>r.jsonfy(t)),...this.#e.length?{postgresFromList:this.#e.map(r=>r.jsonfy(t))}:{},...e}))}static parse(t,e,r){let[s,i,o]=/^UPDATE(?:\s+(IGNORE))?([\s\S]+)$/i.exec(e.trim())||[];if(!s)return;let n=new this(t),u=this.mySubstitutePlaceholders(n,o.trim()),f=t?.params?.dialect||"postgres",c={...f==="postgres"?{set:ft,from:{backtest:"^(?!.*\\s+DISTINCT\\s+$)",test:"FROM"}}:{},join:H,...f==="mysql"?{set:ft}:{},where:Z,...f==="mysql"?{limit:Et}:{},returning:_t},[h,...d]=S.split(u,Object.values(c).map(m=>m.REGEX||m.CLAUSE||m),{useRegex:"i",preserveDelims:!0});n.table(...S.split(h,[","]).map(m=>r(n,m.trim(),[j])));t:for(let m of d){if(/^FROM/i.test(m)){n.from(...S.split(m.replace(/FROM/i,""),[","]).map(l=>r(n,l.trim(),[j])));continue}for(let l in c){let p=c[l].parse?.(n,m.trim(),r);if(p){n[l](p);continue t}}}return i&&n.withFlag(i),n}stringify(){let t=["UPDATE"];return t.push(...this.getFlag().map(e=>e.replace(/_/g," "))),t.push(this.#t.join(", ")),this.params.dialect==="mysql"?t.push(...this.joins(),this.set(),this.where(),this.limit(),this.returning()):(t.push(this.set()),this.#e.length&&t.push(`FROM ${this.#e.join(", ")}`),t.push(...this.joins(),this.where(),this.returning())),t.filter(e=>e).join(" ")}};var fs=[gt,jt,kt,Kt,pt,dt,Yt,je,ut,tt,Vt,ke,Wt,...x];var Ke=class{static grammar=fs;static parse(t,e,r,s={}){if(!e?.length)return;let i=r?.length?r:this.grammar;for(let o of i){let n=this.parseOne(t,e,o,s);if(n)return s.inspect&&console.log(".................",e,".................>",n.constructor.name),n}if(s.assert!==!1)throw new SyntaxError(e)}static parseOne(t,e,r,s={}){return r.parse(t,e,(i,o,n,u={})=>this.parse(i,o,n,{...s,...u}))}};var Ur=class{constructor(t={}){Object.defineProperty(this,"$",{value:{params:{schemaCacheInvalidation:1,schemaSelector:["!information_schema","!linked_db%",...t.dialect==="postgres"?["!pg_%"]:[]],...t}}})}get params(){return this.$.params||{}}async withSchema(...t){let e=t.pop();if(t[0]===!1)return e();let r=Array.isArray(t[0])||N(t[0])?t.pop():{depth:2};return await this.schema(r,e)}#t=[];async withMode(t,e){this.#t.unshift(t);let r=await e();return this.#t.shift(),r}async schema(t,e={},...r){let s=typeof r[0]=="boolean"?r.shift():!0,i=typeof r[0]=="function"?r.shift():h=>h,n=N(e)&&e.depth===2&&!(e.selector||[]).length?this.params.schemaCacheInvalidation:2,u,f=this.#n(e,s);if(!f){let h=Promise.resolve(t(N(e)?{...e,selector:(e.selector||[]).length?e.selector:this.params.schemaSelector}:e)).then(d=>(Array.isArray(e)&&(d=d.reduce((m,l)=>{let p=e.find(_=>_.name===l.name),y=[].concat(p?.tables||[]);return y.length&&y[0]!=="*"&&(l={...l,tables:l.tables.filter(_=>y.includes(_.name))}),m.concat(p&&l||[])},[])),Bt.fromJSON(this,d)));f={params:e,schemaPromise:h},this.#s.add(f),h.then(d=>{f.resolvedSchema=d,delete f.schemaPromise,n===1&&this.listen("savepoints",m=>{let l=JSON.parse(m.payload);if(l.action==="DELETE")return;let p=new Ye(this,l.body),y=wt.fromJSON(this,{actions:[p.querify()]});f.resolvedSchema=f.resolvedSchema.alterWith(y,{diff:!1})})}),u=!0}let c=await i(f.resolvedSchema||await f.schemaPromise);return u&&n===2&&this.#s.delete(f),c}async query(...t){let e,r={};return N(t[0])&&!(t[0]instanceof T)?{query:e,...r}=t[0]:(e=t.shift(),Array.isArray(t[0])&&(r.values=t.shift()),N(t[0])&&(r={...r,...t.shift()})),typeof e=="string"&&(e=Ke.parse(this,e,null,{inspect:r.inspect})),await this.execQuery(e,r)}async createDatabase(t,e={}){typeof t=="string"&&(t={name:t,tables:[]});let r=jt.fromJSON(this,{kind:e.kind,argument:t});e.ifNotExists&&r.withFlag("IF_NOT_EXISTS"),e.returning&&r.returning(e.returning);let s=await this.execQuery(r,e);return s===!0?this.database(r.argument().name()):s}async renameDatabase(t,e,r={}){let s=Kt.fromJSON(this,{kind:r.kind,reference:t,argument:e});if(!s)throw new Error("renameDatabase() called with invalid arguments.");r.returning&&s.returning(r.returning);let i=await this.execQuery(s,r);return i===!0?this.database(e):i}async alterDatabase(t,e,r={}){if(typeof e!="function")throw new Error("alterDatabase() called with invalid arguments.");return typeof t=="string"&&(t={name:t}),await this.withSchema(async()=>{let s=(await this.schema([{name:t.name,tables:t.tables||["*"]}])).database(t.name);if(!s)throw new Error(`Database "${t.name}" does not exist.`);let i=s.clone();await e(i.$nameLock(!0));let o=s.diffWith(i).generateCDL({cascadeRule:r.cascadeRule,existsChecks:r.existsChecks});if(!o.length)return;let n=gt.fromJSON(this,{kind:r.kind,reference:s.name(),argument:o});r.returning&&n.returning(r.returning);let u=await this.execQuery(n,r);return u===!0?this.database(this.extractPostExecName(n)):u})}async dropDatabase(t,e={}){let r=kt.fromJSON(this,{kind:e.kind,reference:t});if(!r)throw new Error("dropDatabase() called with invalid arguments.");return e.ifExists&&r.withFlag("IF_EXISTS"),e.restrict?r.withFlag("RESTRICT"):e.cascade&&r.withFlag("CASCADE"),e.returning&&r.returning(e.returning),await this.execQuery(r,e)}async hasDatabase(t){return(await this.databases()).includes(t)}async databases(){return(await this.schema()).databases(!1)}database(t,e={}){return new this.constructor.Database(this,...arguments)}async execQuery(t,e={}){if(!(t instanceof T))throw new Error("execQuery() called with invalid arguments.");let r=t.statementType==="DDL"||t.hasPaths;return await this.withSchema(r,async s=>{if(t.statementType==="DDL")return await this.execDDL(t,s,e);let i={};t.renderBindings?.(e.values||[]),t.hasSugars&&(t=t.deSugar()),t.isPayloadStatement&&([i.preHook,i.postHook]=t.createExecutionPlan(u=>this.execQuery(u,{inspect:e.inspect})),await i.preHook());let n=(t.normalizeBindings?.(!0).map(u=>u.value())||[]).map(u=>Array.isArray(u)||typeof u=="object"&&u?JSON.stringify(u):u);return e.inspect&&console.log({guery:t.stringify(),values:n}),t.statementType==="DML"?i.returnValue=await this.execDML(t,n,e):t.statementType==="DQL"?i.returnValue=await this.execDQL(t,n,e):i.returnValue=await this.execSQL(t,n,e),t.isPayloadStatement&&(i.returnValue=await i.postHook(i.returnValue)),i.returnValue})}async execDDL(t,e,r,s){let i={dbAction:e,mainSavepointData:null,cascadeSavepointsData:[],returning:e.returning(),inNativeMode:["restore","replication","install","uninstall"].includes(this.#t[0])},o=await this.linkedDB();if(!i.inNativeMode&&await o.config("database_role")==="master")throw new Error("Operation rejected! Direct DDL operations on a master database not allowed.");if(!this.params.clientID&&parseInt(await o.config("require_client_ids")))throw new Error('Operation rejected! Your DB requires all client instances to have a "clientID".');if(!s.desc&&parseInt(await o.config("require_commit_descs")))throw new Error('Operation rejected! Your DB requires all DDL operations to have a "desc".');if(e.hasSugars&&(e=e.deSugar()),["TABLE","VIEW"].includes(e.KIND)){if(e.CLAUSE==="RENAME"){let[u,f]=[e.reference().jsonfy(),e.argument().jsonfy()];e=pt.fromJSON(this,{kind:e.KIND,reference:u,argument:{actions:[]}}),e.add("RENAME",null,c=>c.argument(f))}else e.CLAUSE==="CREATE"&&!e.argument().prefix()&&e.argument().prefix(r.defaultDB());i.dbAction=gt.fromJSON(this,{reference:(e.reference?.()||e.argument()).prefix(!0).name(),argument:{actions:[e]}})}else if(e.CLAUSE==="RENAME"){let[u,f]=[e.reference().jsonfy(),e.argument().jsonfy()];e=gt.fromJSON(this,{kind:e.KIND,reference:u,argument:{actions:[]}}),e.add("RENAME",null,c=>c.argument(f)),i.dbAction=e}if(i.rootCDL=wt.fromJSON(this,{actions:[i.dbAction]}),!i.inNativeMode&&parseInt(await o.config("auto_savepoints"))!==0){let u=r.alterWith(i.rootCDL,{diff:!0});i.dbReference=(i.dbAction.reference?.()||i.dbAction.argument()).name(),[i.mainSavepointData,i.cascadeSavepointsData]=u.databases().reduce(([f,c],h)=>h.identifiesAs(i.dbReference)?[h,c]:[f,c.concat(h.dirtyCheck(!0).length?h:[])],[null,[]])}if(s.inspect&&console.log({guery:e.stringify()}),await t(e,r,s),i.returnValue=!0,i.mainSavepointData){i.savepointInstance=await this.createSavepoint(i.mainSavepointData,{...s,masterSavepoint:null}),i.savepointInstance.$._cascades=[];for(let u of i.cascadeSavepointsData)i.savepointInstance.$._cascades.push(await this.createSavepoint(u,{...s,masterSavepoint:i.savepointInstance.id()}))}let n=this.#n({depth:2});if(n.resolvedSchema=n.resolvedSchema.alterWith(i.rootCDL,{diff:!1}),i.returning==="SCHEMA"){let u=(e.CLAUSE==="DROP"?r:n.resolvedSchema).database(this.extractPostExecName(i.dbAction));return["TABLE","VIEW"].includes(e.KIND)?u.table(this.extractPostExecName(e)):u}return i.returning==="SAVEPOINT"?i.savepointInstance||null:i.returnValue}async createSavepoint(t,e={}){let s=(await this.linkedDB()).table("savepoints"),{name:i,$name:o,version:n,...u}=t.jsonfy({nodeNames:!1}),f={master_savepoint:e.masterSavepoint,name:i,$name:o,database_tag:null,...u,version_tag:null,version_state:"commit",commit_date:m=>m.now(),commit_desc:e.desc,commit_client_id:this.params.clientID,commit_client_pid:m=>m.literal(this.params.dialect==="mysql"?"connection_id()":"pg_backend_pid()")},c=t.name(),h=await this.database(c).savepoint({lookAhead:!0,withCascades:!1})||await this.database(c).savepoint({withCascades:!1});h?(f.database_tag=h.databaseTag(),f.version_tag=e.masterSavepoint?0:h.versionMax()+1,!e.masterSavepoint&&h.versionState()==="rollback"&&await s.delete(m=>m.where(l=>l.eq("database_tag",p=>p.value(h.databaseTag())),l=>l.eq("version_state",p=>p.value("rollback"))))):(f.database_tag=`db.${Date.now()}`,f.version_tag=e.masterSavepoint?0:1);let d=await s.insert(f,{returning:"*"});return new Ye(this,d)}async getSavepoints(t={}){let r=(await this.linkedDB()).table("savepoints").ident,s=this.createCommonSQLUtils(),i=[`COALESCE(${s.ident("$name")}, name) AS name`,"database_tag","version_tag"],o=["master_savepoint","id","database_tag","name",s.ident("$name"),"status","version_tag","tables","version_state","commit_date","commit_desc","commit_client_id","rollback_date","rollback_desc","rollback_client_id"],n=`(SELECT ${s.jsonAgg("version_tag")} FROM ${r}
            WHERE database_tag = main_savepoint.database_tag
        ) AS version_tags`,u=`(SELECT ${s.jsonAgg("cascade")} FROM (
            SELECT ${s.jsonBuildObject(o.reduce((m,l)=>m.concat(`'${l}'`,l),[]))} AS cascade
            FROM ${r}
            WHERE master_savepoint = main_savepoint.id
        )) AS cascades`,f=m=>({...m,version_tags:m.version_tags.filter(l=>l!==0).sort(),cascades:m.cascades||[]});if(t.histories)return(await this.query(`
                SELECT ${[...o,n,u].join(", ")} 
                FROM ${r} AS main_savepoint 
                WHERE master_savepoint IS NULL
            `)).map(f);let c=t.lite?[...i,n]:[...o,n,...t.withCascades!==!1?[u]:[]],h=[].concat(t.selector||[]),d=await this.query(`
            SELECT ${c.join(", ")} FROM (
                SELECT *,
                ROW_NUMBER() OVER (PARTITION BY database_tag ORDER BY version_state = ${t.lookAhead?"'rollback'":"'commit'"} DESC, version_tag ${t.lookAhead?"ASC":"DESC"}) AS rank_for_target,
                FROM ${r}
                WHERE master_savepoint IS NULL
            ) AS main_savepoint WHERE version_state = ${t.lookAhead?"'rollback'":"'commit'"} AND rank_for_target = 1${t.selector?t.lookAhead?` AND ${s.matchSelector("name",h)}`:` AND ${s.matchSelector(`COALESCE(${s.ident("$name")}, name)`,h)}`:""}
        `);return t.lite?d:d.map(m=>new Ye(this,f(m)))}#e;async getPID(t){return this.#e||(this.#e=await t()),this.#e}#r=new Map;listen(t,e,r,s=!1){return this.#r.has(e)||(this.#r.set(e,new Set),t(e,async i=>{let o=await this.getPID();for(let[n,u]of this.#r.get(e))!u&&i.processId&&i.processId===o||n(i)})),this.#r.get(e).add([r,s]),this}#s=new Set;#n(t,e=!1){return[...this.#s].find(r=>{if(N(r.params)&&N(t))return Object.keys(t).every(s=>{if(s==="depth"){let[i,o]=[r.params[s]||0,t[s]||0];return e?i===o:i>=o}return r.params[s]===t[s]});if(Array.isArray(r.params)&&Array.isArray(t))return t.every(s=>r.params.find(i=>s.name===i.name&&((o,n)=>e?lt(o,n).length===o.length:!Be(o,n).length)(It(s.tables),It(i.tables))));if(N(r.params)&&r.params.depth&&Array.isArray(t)){let s=t.reduce((i,o)=>Math.max(i,[].concat(o.tables||[]).length),0)?2:1;return r.params.depth>=s}})}$capture(t,e){if(t==="ROOT_SCHEMA")return this.#n({depth:2})?.resolvedSchema}extractPostExecName(t){return t.CLAUSE==="CREATE"?t.argument().name():t.CLAUSE==="ALTER"&&t.argument().actions().find(e=>e.CLAUSE==="RENAME"&&!e.KIND)?.argument().name()||t.reference().name()}createCommonSQLUtils(){let t={ident:e=>w.fromJSON(this,e),str:e=>st.fromJSON(this,{value:e}),jsonBuildObject:e=>this.params.dialect==="mysql"?`JSON_OBJECT(${e.join(", ")})`:`JSON_BUILD_OBJECT(${e.join(", ")})`,jsonAgg:e=>this.params.dialect==="mysql"?`JSON_ARRAYAGG(${e})`:`JSON_AGG(${e})`,anyValue:e=>this.params.dialect==="mysql"?e:`MAX(${e})`,groupConcat:(e,r)=>this.params.dialect==="mysql"?`GROUP_CONCAT(${e}${r?` ORDER BY ${r}`:""} SEPARATOR ',')`:`STRING_AGG(${e}, ','${r?` ORDER BY ${r}`:""})`,matchSelector:(e,r)=>{let[s,i,o]=r.reduce(([c,h,d],m)=>/^%|^!%|%$/.test(m)?[c,h,d.concat(m)]:/^!/.test(m)?[c,h.concat(m.slice(1)),d]:[c.concat(m),h,d],[[],[],[]]),n=s.length&&!(s.length===1&&s[0]==="*")?`${e} IN (${s.map(t.str).join(", ")})`:null,u=i.length?`${e} NOT IN (${i.map(t.str).join(", ")})`:null,f=o.length?o.map(c=>/^!/.test(c)?`${e} NOT LIKE ${t.str(c.slice(1))}`:`${e} LIKE ${t.str(c)}`).join(" AND "):null;return[n,u,f].filter(c=>c).join(" AND ")}};return t}#i;async linkedDB(){let t=[async u=>{await this.withMode("install",()=>this.createDatabase({name:u,tables:[{name:"savepoints",columns:[{name:"id",...this.params.dialect==="mysql"?{type:"char(36)",default:{expr:f=>f.fn("uuid")}}:{type:"uuid",default:{expr:f=>f.fn("gen_random_uuid")}},primaryKey:!0},{name:"master_savepoint",...this.params.dialect==="mysql"?{type:"char(36)"}:{type:"uuid"},foreignKey:{targetTable:[u,"savepoints"],targetColumns:["id"],deleteRule:"CASCADE"}},{name:"name",type:["varchar",255],notNull:!0},{name:"$name",type:["varchar",255]},{name:"tables",type:"json"},{name:"status",type:["varchar",8],check:{in:["status",{value:null},{value:"new"},{value:"obsolete"}]}},{name:"database_tag",type:["varchar",30],notNull:!0},{name:"version_tag",type:"int",notNull:!0},{name:"version_state",type:["varchar",8],notNull:!0,check:{in:["version_state",{value:"commit"},{value:"rollback"}]}},{name:"commit_date",type:["timestamp",3],notNull:!0},{name:"commit_desc",type:["varchar",255]},{name:"commit_client_id",type:["varchar",255]},{name:"commit_client_pid",type:["varchar",50]},{name:"rollback_date",type:["timestamp",3]},{name:"rollback_desc",type:["varchar",255]},{name:"rollback_client_id",type:["varchar",255]},{name:"rollback_client_pid",type:["varchar",50]}]},{name:"config",columns:[{name:"id",...this.params.dialect==="mysql"?{type:"int",autoIncrement:!0}:{type:"int",identity:!0},primaryKey:!0},{name:"name",type:["varchar",100],notNull:!0,uniqueKey:!0},{name:"value",type:["varchar",255]}]}]})),this.params.dialect==="postgres"&&await this.driver.query(`
                        -- The Function
                        CREATE OR REPLACE FUNCTION fire_linked_db_event1() RETURNS trigger AS $$
                        BEGIN
                            PERFORM pg_notify('savepoints', json_build_object(
                                'action', TG_OP,
                                'body', CASE WHEN TG_OP = 'DELETE' THEN row_to_json(OLD) ELSE row_to_json(NEW) END
                            )::text);
                            RETURN NEW;
                        END;
                        $$ LANGUAGE plpgsql;
                        CREATE OR REPLACE FUNCTION fire_linked_db_event2() RETURNS trigger AS $$
                        BEGIN
                            PERFORM pg_notify('config', json_build_object(
                                'action', TG_OP,
                                'body', CASE WHEN TG_OP = 'DELETE' THEN row_to_json(OLD) ELSE row_to_json(NEW) END
                            )::text);
                            RETURN NEW;
                        END;
                        $$ LANGUAGE plpgsql;
                        -- The triggers
                        DROP TRIGGER IF EXISTS savepoints_event_trigger ON "${u}"."savepoints";
                        CREATE TRIGGER savepoints_event_trigger
                            AFTER INSERT OR UPDATE OR DELETE ON "${u}"."savepoints"
                            FOR EACH ROW EXECUTE FUNCTION fire_linked_db_event1();
                        DROP TRIGGER IF EXISTS config_event_trigger ON "${u}"."config";
                        CREATE TRIGGER config_event_trigger
                            AFTER INSERT OR UPDATE OR DELETE ON "${u}"."config"
                            FOR EACH ROW EXECUTE FUNCTION fire_linked_db_event2();
                    `)}],e=t.length,r=u=>"linked_db"+(u&&`_v${u}`||""),s=this.database(r(e));if(Object.defineProperty(s,"uninstall",{value:async u=>{let f=await this.withMode("uninstall",()=>this.dropDatabase(s.name,{cascade:u}));return this.installed=!1,f}}),Object.defineProperty(s,"config",{value:async(...u)=>{if(u.length>1||N(u[0])){let f=N(u[0])?Object.keys(u[0]).map(c=>({name:c,value:u[0][c]})):{name:u[0],value:u[1]};if(this.#i)for(let c of[].concat(f))this.#i.set(c.name,c.value);return this.withSchema({depth:2,selector:"linked_db%"},async()=>await s.table("config").upsert(f))}if(!this.#i)try{let f=await s.table("config").select();this.#i=new Map(f.map(c=>[c.name,c.value])),this.listen("config",c=>{let h=JSON.parse(c.payload);h.action==="DELETE"?this.#i.delete(h.body.name):this.#i.set(h.body.name,h.body.value)})}catch{this.#i=new Map}return u.length?Array.isArray(u[0])?Object.fromEntries(u[0].map(f=>[f,this.#i.get(f)])):this.#i.get(u[0]):Object.fromEntries(this.#i)}}),this.installed)return s;this.installed=!0;let o=(await this.schema({depth:1,selector:"linked_db%"})).databases(!1).find(u=>u.startsWith(r())||u==="obj_information_schema"),n=o&&/^.+?([\d]+)$/.exec(o)?.[1]||-1;if(o&&n===-1&&console.warn("Your database has a old version of Linked DB that is no longer supported. Any savepoint record in there will be retained but won't be migrated to the new Linked DB version you have now. You may file an issue on github for any assistance."),e<n)throw new Error(`Your database has a higher version of Linked DB "${n}" than this query client is designed to support "${e}". Consider upgrading this client to latest version.`);for(let u=1;u<=t.length;u++){if(u<=n)continue;let f=r(u-1),c=r(u);try{u>1&&await this.withMode("install",()=>this.alterDatabase(f,h=>h.name(c))),await t[u-1](c)}catch(h){throw console.log(!o&&u===1?`Error installing ${c}.`:`Error upgrading your Linked DB version from ${f} to ${c}. Consider filing an issue on github.`),h}}return s}};var Mr=class{constructor(t,e,r={}){this.$={database:t,name:e,params:r}}get database(){return this.$.database}get name(){return this.$.name}get ident(){return O.fromJSON(this,[this.database.name,this.name])}get params(){return Object.assign({},this.database.params,this.$.params)}async schema(){return(await this.database.schema(this.name)).table(this.name)}async count(...t){let e=[].concat(Array.isArray(t[0])?t.shift():"*");if(e.length!==1)throw new Error("Count expects exactly one field.");let r=await this.select([{expr:{count:e},as:"c"}],...t);return Array.isArray(r)?r[0].c:r.c}async select(...t){let e=new ut(this.database.client);e.from([this.database.name,this.name]);let s={fields:Array.isArray(t[0])?t.shift():["*"],...t.shift()||{}};return e.fields(...s.fields),await this.#t(e,s,async()=>{let i=await this.database.client.execQuery(e);return["string","number"].includes(typeof s.where)?i[0]:i})}async insert(...t){let e,r=[],s=[],i,o;if(typeof t[0]=="boolean"&&(e=t.shift()),Array.isArray(t[0])&&t[0].every(h=>typeof h=="string")&&Array.isArray(t[1])){if(!t[1].every(h=>Array.isArray(h)))throw new TypeError("Invalid payload format.");[r,s,i]=t.splice(0,3)}else{let h=N(t[0]),d=[].concat(t.shift());if(!N(d[0]))throw new TypeError("Invalid payload format.");r=Object.keys(d[0]),s=d.map(m=>Object.values(m)),i=t.shift(),o=h&&i?.returning}let n,u,f=new(e?Vt:tt)(this.database.client);f.into([this.database.name,this.name]),r.length&&f.columns(...r);for(let h of s)f.values(...h.map(d=>cs(d,this.params.autoBindings)));N(i)&&i.returning?f.returning(...[].concat(i.returning)):F(i)&&i(f);let c=e&&this.params.dialect==="postgres";return await this.database.client.withSchema(c,async()=>{let h=await this.database.client.execQuery(f);return o&&(h=h[0]),h})}async upsert(...t){return await this.insert(!0,...t)}async update(t,e){if(!e)throw new Error('The "modifiers" parameter cannot be ommitted.');let r=["string","number"].includes(typeof e.where)&&e.returning,s=Object.keys(t),i=Object.values(t),o=new ke(this.database.client);return o.table([this.database.name,this.name]),s.forEach((n,u)=>o.set(n,cs(i[u],this.params.autoBindings))),await this.#t(o,e,async()=>{let n=await this.database.client.execQuery(o);return r&&(n=n[0]),n})}async delete(t){if(!t)throw new Error('The "modifiers" parameter cannot be ommitted.');let e=new Wt(this.database.client);return e.from([this.database.name,this.name]),await this.#t(e,t,async()=>{let r=await this.database.client.execQuery(e);return["string","number"].includes(typeof t.where)&&t.returning&&(r=r[0]),r})}async#t(t,e,r){if(e===!0)return await r();if(N(e)){if(e.limit&&t.limit(e.limit),e.returning&&t.returning(...[].concat(e.returning)),["string","number"].includes(typeof e.where))return await this.database.client.withSchema(async()=>{let s=await this.schema();return t.where(i=>i.eq(Ts(s),e.where)),await r()});if($(e.where))t.where(...[].concat(e.where));else if(typeof e.where=="function")t.where(e.where);else if(e.where&&e.where!==!0)throw new Error(`Invalid "where" format: ${e.where}. An array expected, or and ID value (string|number), or the boolean true.`)}else F(e)?e(t):/^\d+$/.test(e)&&t.limit(e);return await r()}$capture(t,e){return this.database.$capture(t,e)}},cs=(a,t)=>typeof a=="function"?a:a instanceof Date?e=>e.value(a.toISOString().split(".")[0]):Array.isArray(a)||N(a)?e=>e.json(a):[null,void 0].includes(a)?e=>e.literal(null):e=>e.value(a),Ts=a=>{let t=a.primaryKey()?.columns()[0];if(!t)throw new Error("Cannot resolve primary key name for implied record.");return t};var Jr=class{_pos=0;_eof=!1;_onfinish=[];constructor(t){this._cache=t}get eof(){return!this._cache.length||this._pos===this._cache.length-1}onfinish(t){this._onfinish.push(t)}next(){if(this.eof){this._onfinish.forEach(t=>t()),this._pos=0;return}this._pos++}async fetch(){if(!this.eof)return this._cache[this._pos]}};var Fr=class extends Jr{constructor(t){super([]),this._store=t,this._storeFetch=new Promise(async e=>{this.cache=await this._store.select(),e()})}async fetch(){return await this._storeFetch,super.fetch()}};var Yr=class extends Mr{getCursor(){return new Fr(this)}};var jr=class{constructor(t,e,r={}){Object.defineProperty(this,"$",{value:{client:t,name:e,params:r}})}get client(){return this.$.client}get name(){return this.$.name}get ident(){return U.fromJSON(this,this.name)}get params(){return Object.assign({},this.client.params,this.$.params)}async savepoint(t={}){return(await this.client.getSavepoints({...t,selector:this.name}))[0]}async version(){return(await this.savepoint())?.versionTag()||0}async versions(){return(await this.savepoint())?.versionTags()||[]}async schema(t=["*"]){return(await this.client.schema([{name:this.name,tables:t}])).database(this.name)}async createTable(t,e={}){typeof t=="string"&&(t={name:t,columns:[]});let r=dt.fromJSON(this,{kind:e.kind,argument:t});r.argument().prefix(this.name),e.ifNotExists&&r.withFlag("IF_NOT_EXISTS"),e.returning&&r.returning(e.returning);let s=await this.client.execQuery(r,e);return s===!0?this.table(r.argument().name()):s}async renameTable(t,e,r={}){let s=je.fromJSON(this,{kind:r.kind,reference:t,argument:e});if(!s)throw new Error("renameTable() called with invalid arguments.");s.reference().prefix(this.name),r.returning&&s.returning(r.returning);let i=await this.client.execQuery(s,r);return i===!0?this.table(e):i}async alterTable(t,e,r={}){if(typeof e!="function")throw new Error("alterTable() called with invalid arguments.");return await this.client.withSchema(async()=>{let s=await this.table(t).schema();if(!s)throw new Error(`Table "${t}" does not exist.`);let i=s.clone();await e(i.$nameLock(!0));let o=s.diffWith(i).generateCDL({cascadeRule:r.cascadeRule,existsChecks:r.existsChecks});if(!o.length)return;let n=pt.fromJSON(this,{kind:r.kind,reference:s.name(),argument:o});n.reference().prefix(this.name),r.ifExists&&n.withFlag("IF_EXISTS"),r.returning&&n.returning(r.returning);let u=await this.client.execQuery(n,r);return u===!0?this.table(this.client.extractPostExecName(n)):u})}async dropTable(t,e={}){let r=Yt.fromJSON(this,{kind:e.kind,reference:t});if(!r)throw new Error("dropTable() called with invalid arguments.");return r.reference().prefix(this.name),e.ifExists&&r.withFlag("IF_EXISTS"),e.restrict?r.withFlag("RESTRICT"):e.cascade&&r.withFlag("CASCADE"),e.returning&&r.returning(e.returning),this.client.execQuery(r,e)}async hasTable(t){return(await this.tables()).includes(t)}async tables(){return(await this.schema()).tables(!1)}table(t,e={}){return new this.constructor.Table(this,...arguments)}$capture(t,e){return this.client.$capture(t,e)}};var kr=class extends jr{static Table=Yr};var ls=class extends Ur{constructor(t,e={}){if(typeof t!="object")throw new Error("The options.driver parameter is required and must be an object.");if(typeof t.query!="function")throw new Error("The provided driver must expose a .query() function.");super(e),this.$.driver=t}get driver(){return this.$.driver}static kind="sql";static Database=kr;async schema(t){return super.schema(async e=>{let r=this.#e(e),s=await this.driver.query(r);return this.#r(s.rows||s)},...arguments)}async searchPath(t=[]){if(arguments.length){t=[].concat(t).map(n=>w.fromJSON(this,n));let o=this.params.dialect==="mysql"?`USE ${t[0]}`:`SET SEARCH_PATH TO ${t.join(",")}`;return await this.driver.query(o)}let e,r;this.params.dialect==="mysql"?(e="SELECT database() AS default_db",r="default_db"):(e="SHOW SEARCH_PATH",r="search_path",e="SELECT current_setting('SEARCH_PATH')",r="current_setting");let s=await this.driver.query(e),i=((s.rows||s)[0]||{})[r];return S.split(i,[","]).map(o=>w.parseIdent(this,o.trim())[0])}async execDQL(t,e=[],r={}){return await this.execSQL(t,e,r)}async execDML(t,e=[]){let r={hasReturnList:!!t.returning()};return this.params.dialect==="mysql"&&r.hasReturnList&&([t,r.mysqlPostHook]=await this.#t(t)),r.returnValue=await this.driver.query(t.toString(),e),r.mysqlPostHook&&(r.returnValue=await r.mysqlPostHook(r.returnValue)),r.hasReturnList?r.returnValue.rows||r.returnValue:"rowCount"in r.returnValue?r.returnValue.rowCount:r.returnValue.affectedRows}async execDDL(t,e,r={}){return super.execDDL(async s=>await this.driver.query(s.toString()),...arguments)}async execSQL(t,e=[]){let r=await this.driver.query(t.toString(),e);return r.rows||r}async getPID(){return super.getPID(async()=>{let t=await this.driver.query(`SELECT ${this.params.dialect==="mysql"?"connection_id()":"pg_backend_pid()"} AS pid`);return(t.rows||t)[0]?.pid})}listen(t,e,r=!1){return super.listen((s,i)=>{this.driver.query(`LISTEN ${s}`),this.driver.on("notification",async o=>{o.channel===s&&i(o)})},...arguments)}async#t(t){if(t.tables().length>1)throw new Error(`The support for a "RETURNING" clause for mysql does'nt yet support muilt-table statements.`);t=t.clone();let e=t.tables()[0].expr().clone(),r=t.returning();if(t.returning(void 0),t instanceof Wt){let u=await this.driver.query(`SELECT ${r} FROM ${e}${t.where()||""}`);return[t,()=>u]}let s="obj_column_for_returning_clause_support",i=w.fromJSON(this,s);e.schema().column(s)||await this.driver.query(`ALTER TABLE ${e} ADD COLUMN ${i} char(36) INVISIBLE`);let n=(0|Math.random()*9e6).toString(36);if(t.set())t.set().assignment(s,u=>u.value(n));else if(t instanceof tt){if(!t.columns()&&(t.select()||t.values()?.length))throw new Error('The support for a "RETURNING" clause for mysql currently requires explicit column list in INSERT statements.');if(t.columns().add(s),t.select())t.select().fields().add(u=>u.value(n));else if(t.values()?.length)for(let u of t.values())u.add(f=>f.value(n));else t.values(n)}return t instanceof tt&&t.onConflict()&&t.onConflict().assignment(s,u=>u.value(n)),[t,async()=>{let u=await this.driver.query(`SELECT ${r} FROM ${target} WHERE ${i} = '${n}'`);return this.params.mysqlReturningClause==="WITH_AUTO_CLEANUP"&&await this.driver.query(`ALTER TABLE ${target} DROP COLUMN ${i}`),u}]}#e(t={}){let e=this.createCommonSQLUtils(),r={fields:[],dbWhere:"",tblWhere:"",orderBy:"",depth:0};if(Array.isArray(t)){r.dbWhere=`
WHERE db.schema_name IN ('${t.map(f=>f.name).join("', '")}')`;let u=t.reduce((f,c)=>{let h=[].concat(c.tables||[]);return!h.length||h.includes("*")?f:f.concat(`WHEN '${c.name}' THEN ${e.matchSelector("tbl.table_name",h)}`)},[]);r.tblWhere=u.length?` AND CASE db.schema_name ${u.join(" ")} END`:"",r.depth=2}else{let u=[].concat(t.selector||[]);if(u.length){let f=e.matchSelector("db.schema_name",u);r.dbWhere=f?`
WHERE ${f}`:""}r.orderBy=`
ORDER BY array_position(current_schemas(false), db.schema_name)`,r.depth=t.depth||0}let s=()=>{let u={table_schema:"cols.table_schema",table_name:"cols.table_name",column_name:"cols.column_name",ordinal_position:"cols.ordinal_position",column_default:"cols.column_default",is_nullable:"cols.is_nullable",data_type:"cols.data_type",character_maximum_length:"cols.character_maximum_length",...this.params.dialect==="mysql"?{extra:"cols.extra"}:{is_identity:"cols.is_identity",identity_generation:"cols.identity_generation",identity_start:"cols.identity_start",identity_increment:"cols.identity_increment",identity_maximum:"cols.identity_maximum",identity_minimum:"cols.identity_minimum",identity_cycle:"cols.identity_cycle"},is_generated:"cols.is_generated",generation_expression:"cols.generation_expression"},f=`
                SELECT ${Object.entries(u).map(([c,h])=>`${h} AS ${c}`).join(", ")}
                FROM information_schema.columns AS cols
                WHERE cols.table_schema = tbl.table_schema AND cols.table_name = tbl.table_name
                ORDER BY cols.ordinal_position
            `;return`SELECT ${e.jsonAgg(e.jsonBuildObject(Object.keys(u).reduce((c,h)=>c.concat(`'${h}'`,`cols.${h}`),[])))} FROM (${f}) AS cols`},i=()=>{let u={table_schema:e.anyValue("cons.constraint_schema"),table_name:e.anyValue("cons.table_name"),column_name:e.groupConcat("cons_details.column_name","cons_details.ordinal_position"),constraint_name:"cons.constraint_name",constraint_type:e.anyValue("cons.constraint_type"),check_clause:e.anyValue("check_constraints_details.check_clause"),...this.params.dialect==="mysql"?{check_constraint_level:e.anyValue("check_constraints_details.level"),referenced_column_name:e.groupConcat("cons_details.referenced_column_name"),referenced_table_name:e.anyValue("cons_details.referenced_table_name"),referenced_table_schema:e.anyValue("cons_details.referenced_table_schema")}:{referenced_column_name:e.groupConcat("relation_details.column_name"),referenced_table_name:e.anyValue("relation_details.table_name"),referenced_table_schema:e.anyValue("relation_details.table_schema")},referenced_constraint_name:e.groupConcat("relation.unique_constraint_name"),match_rule:e.anyValue("relation.match_option"),update_rule:e.anyValue("relation.update_rule"),delete_rule:e.anyValue("relation.delete_rule")},f=`
                SELECT ${Object.entries(u).map(([c,h])=>`${h} AS ${c}`).join(", ")}
                FROM information_schema.table_constraints AS cons
                LEFT JOIN information_schema.key_column_usage AS cons_details
                    ON cons_details.constraint_name = cons.constraint_name
                    AND cons_details.table_name = cons.table_name
                    AND cons_details.constraint_schema = cons.constraint_schema
                    AND cons_details.constraint_catalog = cons.constraint_catalog
                LEFT JOIN information_schema.check_constraints AS check_constraints_details
                    ON check_constraints_details.constraint_name = cons.constraint_name
                    AND check_constraints_details.constraint_schema = cons.constraint_schema
                    AND check_constraints_details.constraint_catalog = cons.constraint_catalog
                LEFT JOIN information_schema.referential_constraints AS relation
                    ON relation.constraint_name = cons.constraint_name
                    AND relation.constraint_schema = cons.constraint_schema
                    AND relation.constraint_catalog = cons.constraint_catalog
                ${this.params.dialect==="mysql"?"":`
                LEFT JOIN information_schema.key_column_usage AS relation_details
                    ON relation_details.constraint_name = relation.unique_constraint_name
                    AND relation_details.constraint_schema = relation.unique_constraint_schema
                    AND relation_details.constraint_catalog = relation.unique_constraint_catalog
                    `}
                WHERE cons.table_schema = tbl.table_schema AND cons.table_name = tbl.table_name
                GROUP BY cons.constraint_name
            `;return`SELECT ${e.jsonAgg(e.jsonBuildObject(Object.keys(u).reduce((c,h)=>c.concat(`'${h}'`,`cons.${h}`),[])))} FROM (${f}) AS cons`},o=(u=!1)=>{let f={table_name:"tbl.table_name",table_schema:"tbl.table_schema"},c=`
                SELECT ${Object.entries(f).map(([d,m])=>`${m} AS ${d}`).join(", ")}
                FROM information_schema.tables AS tbl
                WHERE tbl.table_schema = db.schema_name AND tbl.table_type = 'BASE TABLE'${r.tblWhere}
            `,h=u?["'columns'",`(${s()})`,"'constraints'",`(${i()})`]:[];return`SELECT ${e.jsonAgg(e.jsonBuildObject(Object.keys(f).reduce((d,m)=>d.concat(`'${m}'`,`tbl.${m}`),[]).concat(h)))} FROM (${c}) AS tbl`};return r.fields.push("db.schema_name"),r.depth&&r.fields.push(`(${o(r.depth>1)}) AS tables`),`SELECT ${r.fields.join(", ")}
        FROM information_schema.schemata AS db
        ${r.dbWhere}${r.orderBy};`}#r(t){let e=i=>i==="character varying"?"varchar":i==="integer"?"int":i,r=(i,o=!1)=>({...o?{}:{name:i.constraint_name},targetTable:[i.referenced_table_schema,i.referenced_table_name],targetColumns:i.referenced_column_name.split(",").map(n=>n.trim()),...i.match_rule!=="NONE"?{matchRule:i.match_rule}:{},updateRule:i.update_rule,deleteRule:i.delete_rule}),s=(i,o=!1)=>{let n=new Set,u=Ke.parse({params:o?{...this.params,nodeCallback:c=>c.NODE_NAME==="COLUMN_REF"?n.add(c.name().toLowerCase()):null}:this.params},i,null,{inspect:!1}),f=u.NODE_NAME==="PARENS"?u.exprUnwrapped().jsonfy({nodeNames:!1}):u.jsonfy({nodeNames:!1});return o?{columns:[...n],json:f}:f};return t.map(i=>({name:i.schema_name,tables:(i.tables||[]).map(n=>{let u=l=>(l.check_clause||(l.check_clause=""),{...l,...s(l.check_clause,!0)}),[f,c,h,d]=(n.constraints||[]).reduce(([l,p,y,_],E)=>E.constraint_type==="PRIMARY KEY"?[l.concat(E),p,y,_]:E.constraint_type==="UNIQUE"?[l,p.concat(E),y,_]:E.constraint_type==="FOREIGN KEY"?[l,p,y.concat(E),_]:E.constraint_type==="CHECK"&&!(this.params.dialect==="postgres"&&/^[\d_]+not_null/.test(E.constraint_name))?[l,p,y,_.concat(u(E))]:[l,p,y,_],[[],[],[],[]]),m={name:n.table_name,columns:(n.columns||[]).reduce((l,p)=>{let y={},_=p.extra?.split(",").map(E=>E.trim())||[];return l.concat({name:p.column_name,type:p.character_maximum_length?[e(p.data_type),p.character_maximum_length]:e(p.data_type),...f.length===1&&f[0].column_name===p.column_name&&(y.pKeys=f.pop())?{primaryKey:{name:y.pKeys.constraint_name}}:{},...(y.uKeys=c.filter(E=>E.column_name===p.column_name)).length===1&&(c=c.filter(E=>E!==y.uKeys[0]))?{uniqueKey:{name:y.uKeys[0].constraint_name}}:{},...(y.fKeys=h.filter(E=>E.column_name===p.column_name)).length===1&&(h=h.filter(E=>E!==y.fKeys[0]))?{foreignKey:r(y.fKeys[0])}:{},...(y.cKeys=d.filter(E=>E.check_constraint_level!=="Table"&&E.columns.length===1&&E.columns[0]===p.column_name)).length===1&&(d=d.filter(E=>E!==y.cKeys[0]))?{check:{name:y.cKeys[0].constraint_name,expr:y.cKeys[0].json}}:{},...p.is_identity==="YES"?{identity:{always:p.identity_generation==="ALWAYS"}}:{},...p.is_generated!=="NEVER"?{expression:{always:p.is_generated==="ALWAYS",expr:s(p.generation_expression)}}:{},..._.includes("auto_increment")?{autoIncrement:!0}:{},...p.is_nullable==="NO"?{notNull:!0}:{},...p.column_default&&p.column_default!=="NULL"?{default:{expr:s(p.column_default)}}:{},..._.includes("INVISIBLE")?{flags:["INVISIBLE"]}:{}})},[]),constraints:[],indexes:[]};return m.constraints.push(...[...f,...c,...h].map(l=>({name:l.constraint_name,type:l.constraint_type==="UNIQUE"?"UNIQUE_KEY":l.constraint_type.replace(" ","_"),columns:l.column_name.split(",").map(p=>p.trim()),...l.constraint_type==="FOREIGN KEY"?r(l,!0):{}}))),m.constraints.push(...d.map(l=>({name:l.constraint_name,type:l.constraint_type,columns:l.columns,expr:l.json}))),m})}))}};})();
//# sourceMappingURL=sql.js.map
