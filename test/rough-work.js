
import pg from 'pg';
import mysql from 'mysql2';
import Parser from '../src/Parser.js';
import CreateTable from '../src/statements/schema/CreateTable.js';
import AlterTable from '../src/statements/schema/AlterTable.js';
import SQLClient from '../src/databases/sql/SQLClient.js';

// PG Client
const pgClient = new pg.Client({
    host: 'localhost',
    port: 5432,
    //user: 'oxharris',
    //password: '',
    //database: 'oxharris',
});
await pgClient.connect();

/*
// MySQL Client
const mysqlClient = await mysql.createConnection({
	host: 'localhost',
    port: 3306,
	//user: 'root',
    //password: '',
    database: 'public',
});
*/

const globalParams = {};
const client = {
    query(sql, ...args) {
        if (globalParams.showSql) {
            console.log('SQL:', sql);
        }
        return pgClient.query(sql, ...args);
    }
};
const dialect = 'postgres';

//if (dialect === 'mysql') { await client.query(`CREATE DATABASE IF NOT EXISTS public`); }
//console.log(await client.query(`SELECT * FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS`));
console.log(await client.query(`DROP SCHEMA IF EXISTS obj_information_schema CASCADE`));

const createTableSql = `
CREATE TABLE IF NOT EXISTS test0 (
    id int PRIMARY    KEY CONSTRAINT genn generated by default as identity,
    ref int CONSTRAINT nn not    null CONSTRAINT uni_q unique CONSTRAINT fk REFERENCES pretest (id) MATCH FULL ON DELETE RESTRICT ON UPDATE SET NULL,
    ref2 int,
    rand VARCHAR (11) CHECK (rand IS NOT NULL),
    rand2 text,
    CONSTRAINT ck CHECK (ref > 10),
    CONSTRAINT fk2 FOREIGN    KEY (ref2) REFERENCES pretest2 (id),
    UNIQUE (rand2,rand)
)`;

const alterTableSql = `
ALTER TABLE IF EXISTS public.test
    RENAME AS new_tbl_name,
    RENAME constraint constraint_name1 TO new_constraint_name,

    ADD constraint constraint_name2 PRIMARY KEY (col_name1),
    ADD constraint fruit_type UNIQUE (hhh),
    ADD PRIMARY KEY (col_name2),
    ADD CHECK (check_expr),

    ADD FULLTEXT INDEX (ft_name),

    ADD column new_col varchar(10) FIRST,
    ADD column new_col2 int AFTER refColumn,

    DROP constraint if    exists constraint_name3 cascade,
    DROP PRIMARY KEY,
    DROP FOREIGN KEY fk_name,
    DROP COLUMN if exists col_name,
    DROP col_name,

    ALTER column column_name set data type varchar(60),
    ALTER constraint constraint_name4 INVISIBLE,
    ALTER COLUMN column_name8 SET COMPRESSION compression_method,
    ALTER constraint constraint_name8 DEFERRABLE
`;
//    ALTER column column_name2 set AUTO_INCREMENT,

/*
console.log('');
console.log('');
console.log('Create TABLE pretest');
console.log('');

const sql0 = `
CREATE TABLE IF NOT EXISTS pretest (
    id int primary key,
    desc0 text not null
)`;

const result0 = await client.query(sql0);
console.log(result0);

// --------------------------------------------

console.log('');
console.log('');
console.log('Create TABLE pretest2');
console.log('');

const sql1 = `
CREATE TABLE IF NOT EXISTS pretest2 (
    id int primary key,
    desc0 text not null
)`;

const result1 = await client.query(sql1);
console.log(result1);

// --------------------------------------------

console.log('');
console.log('');
console.log('Create TABLE test0');
console.log('');

const result2 = await client.query(createTableSql);
console.log(result2);

// --------------------------------------------

console.log('');
console.log('');
console.log('Parse CREATE TABLE');
console.log('');

const result5 = await Parser.parse(createTableSql);
console.log(JSON.stringify(result5.toJson(), null, 3));

console.log(result5 + '');
console.log(CreateTable.fromJson(result5.toJson()) + '');

*/
// --------------------------------------------

console.log('');
console.log('');
console.log('Show CREATE TABLE');
console.log('');

const sqlClient = new SQLClient(client, { dialect });

const dbName = 'public2', dbName2 = 'public';
const savepoint = await sqlClient.alterDatabase(dbName, dbSchema => {
    dbSchema.name = dbName2;
}, { savepointDesc: 'To public2' });

console.log('............../////////////// alter public db', savepoint.toJson());

console.log('ALTER DATABASE public', await savepoint.rollback());





const publicDb = sqlClient.database(dbName);
console.log('public@', (await publicDb.savepoint({ direction: 'forward' }))?.toJson());

const booksTbl = {
    name: 'books',
    columns: [
        { name: 'id', type: 'int', primaryKey: true },
        { name: 'author1', type: 'int', references: { table: 'test0', columns: ['id'] }, },
        { name: 'author2', type: 'int', },
        { name: 'content', type: { name: 'varchar', maxLen: 30 }, default: '\'Hello world\'', },
        { name: 'isbn', type: 'int', identity: { always: false }, notNull: true },
    ],
    constraints: [
        { type: 'FOREIGN KEY', columns: ['author2'], references: { table: 'test0', columns: ['id'] } },
        { type: 'UNIQUE KEY', columns: ['author2', 'author1'] },
    ],
    indexes: []
};

await publicDb.dropTable(booksTbl.name, { ifExists: true });

console.log('CREATE TABLE books IF NOT EXISTS, then DESCRIBE');

await publicDb.createTable(booksTbl, { ifNotExists: true });
const booksSchema = await publicDb.describeTable('books');
console.log(CreateTable.fromJson(booksSchema) + '');

const tt = await publicDb.alterTable('books', tblSchema => {
    const isbn = tblSchema.columns.find(col => col.name === 'isbn');
    delete isbn.identity;
});


/*
await sqlClient.dropDatabase('some_db', { ifExists: true, cascade: true });
await sqlClient.dropDatabase('some_new_db', { ifExists: true, cascade: true });
await sqlClient.dropDatabase('new_db_name', { ifExists: true, cascade: true });
*/
await client.query(`DROP SCHEMA IF EXISTS some_db CASCADE`);
await client.query(`DROP SCHEMA IF EXISTS new_db_name CASCADE`);
await client.query(`DROP SCHEMA IF EXISTS some_new_db CASCADE`);

console.log('----------------------------------------------------------------');

// ----------------
// Create database
const dbCreateRequest = {
    name: 'some_db',
    tables: [{
        name: 'test0',
        columns: [
            { name: 'id', type: 'int', primaryKey: true },
        ]
    },
    booksTbl,
]};

const dbApi = await sqlClient.createDatabase(dbCreateRequest);
const savepoint0 = await dbApi.savepoint();
//const savepoint0 = await sqlClient.alterDatabase(dbCreateRequest.name, dbSchema => dbSchema.name = 'some_new_db');
globalParams.showSql = true;
console.log('---------------------------------------rolling back to CREATION POINT (DROP DB):', savepoint0.toJson());
console.log('---------------------------------------rollback done:', await savepoint0.rollback({ allowMutateDB: true }));

//console.log('\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\', savepoint0.toJson());
console.log((await dbApi.savepoint({ direction: 'forward' }))?.toJson(), (await client.query(`SELECT * FROM obj_information_schema.database_savepoints ORDER BY savepoint_date ASC`)).rows);

const savepoint1 = await dbApi.savepoint({ direction: 'forward' });
console.log('\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ rolling forward to DROP POINT (RECREATE DB)', savepoint1.toJson());
console.log('--------------------------------------- rollback forward to recreate', await savepoint1.rollback({ allowMutateDB: true }));

console.log((await dbApi.savepoint({force: true}))?.toJson(), (await client.query(`SELECT * FROM obj_information_schema.database_savepoints ORDER BY savepoint_date ASC`)).rows);

// ----------------
// Create table test1
const tblCreateRequest = {
    name: 'test1',
    columns: [
        { name: 'id', type: 'int', primaryKey: true },
    ]
};
const savepoint2 = await dbApi.createTable(tblCreateRequest);

// ----------------
// Alter database (batch)
const dbAlterRequest = {
    name: 'some_db',
    tables: ['test0', 'test1', 'books'],
};
const savepoint3 = await sqlClient.alterDatabase(dbAlterRequest, dbSchema => {
    // Rename DB
    dbSchema.name = 'new_db_name';
    // Modify column
    dbSchema.tables.get('test0').columns.get('id').uniqueKey = true;
    // Remove test1 table
    dbSchema.tables.delete('test1');
    /// Add table test2
    dbSchema.tables.push({
        name: 'test2',
        columns: [
            { name: 'id', type: 'int', primaryKey: true },
        ]
    });
});

await savepoint3.rollback();

/*
console.log('ALTER TABLE books', tt);
console.log(await publicDb.table('books').savepoint());

// --------------------------------------------

console.log('');
console.log('');
console.log('Parse ALTER TABLE');
console.log('');

const result6 = await Parser.parse(alterTableSql);
console.log(JSON.stringify(result6.toJson(), null, 3));

console.log(result6 + '');
console.log(AlterTable.fromJson(result6.toJson(), result6.params) + '');

// --------------------------------------------


console.log('');
console.log('');
console.log('DIFF >>> ALTER TABLE');
console.log('');

const schemaA = {
    name: 'testt',
    database: 'public',
    columns: [
        { name: 'id', type: { name: 'VARCHAR', maxLen: 30 }, default: 20 },
        { name: 'author', type: { name: 'INT' }, references: { constraintName: 'fkk', table: 'table1', columns: ['col3', 'col4']} },
    ],
    constraints: [
        { type: 'FOREIGN KEY', columns: ['col1', 'col2'], references: { table: 'table1', columns: ['col3', 'col4']} },
        { type: 'PRIMARY KEY', columns: 'col5' },
    ],
    indexes: []
};

const schemaB = {
    name: 'testt',
    database: 'public2',
    columns: [
        { name: 'id3', $name: 'id', notNull: true, type: { name: 'vARCHAR', maxLen: 70 }, default: 20 },
        { name: 'author', type: { name: 'INT' }, references: { constraintName: 'fkk222', $constraintName: 'fkk', table: 'table1', columns: ['col3', 'col5']} },
    ],
    constraints: [
        { type: 'FOREIGN KEY', columns: ['col1', 'col2'], references: { table: 'table1', columns: ['col3', 'col4']} },
        { type: 'PRIMARY KEY', columns: 'col5' },
    ],
    indexes: []
};

const result7 = AlterTable.fromDiffing(schemaA, schemaB);
console.log(JSON.stringify(result7.toJson(), null, 3));

console.log(result7 + '');
console.log(AlterTable.fromJson(result7.toJson(), result7.params) + '');
*/

process.exit();