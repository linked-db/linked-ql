

  DeSugaring Setup
    ✔ should establish the linkedDb object with test catalog (52ms)
      ∟ SchemaSchema .parse(`
			public (
			  users (
			    id SERIAL PRIMARY KEY,
			    parent_user INTEGER,
			    metadata INTEGER,
			    username VARCHAR(50) NOT NULL UNIQUE,
			    email VARCHAR(100) NOT NULL UNIQUE CHECK (email LIKE '%@%'),
			    password_hash TEXT NOT NULL,
			    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
			    updated_at TIMESTAMP,
			    CHECK (password_hash LIKE '3...'),
			    status VARCHAR(10) NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'inactive', 'banned')),
			    CONSTRAINT fk_meta FOREIGN KEY (metadata) REFERENCES public2.user_metadata (id) ON DELETE CASCADE,
			    CONSTRAINT fk_parent_user FOREIGN KEY (parent_user) REFERENCES users (id) ON DELETE CASCADE
			  ),
			  orders (
			    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
			    parent_order UUID,
			    user INTEGER NOT NULL,
			    order_total NUMERIC(10, 2) NOT NULL CHECK (order_total >= 0),
			    status TEXT NOT NULL CHECK (status IN ('pending', 'paid', 'cancelled', 'shipped')),
			    placed_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
			    CONSTRAINT fk_parent_order FOREIGN KEY (parent_order) REFERENCES orders (id) ON DELETE CASCADE,
			    CONSTRAINT fk_user FOREIGN KEY (user) REFERENCES users (id) ON DELETE CASCADE
			  ),
			  products (
			    id SERIAL PRIMARY KEY,
			    name VARCHAR(100) NOT NULL,
			    sku VARCHAR(30) UNIQUE NOT NULL,
			    price NUMERIC(8, 2) NOT NULL CHECK (price > 0),
			    stock_quantity INTEGER NOT NULL CHECK (stock_quantity >= 0),
			    is_active BOOLEAN NOT NULL DEFAULT TRUE
			  ),
			  order_items (
			    "order" UUID NOT NULL,
			    product INTEGER NOT NULL,
			    quantity INTEGER NOT NULL CHECK (quantity > 0),
			    unit_price NUMERIC(8, 2) NOT NULL CHECK (unit_price >= 0),
			    PRIMARY KEY ("order", product),
			    CONSTRAINT fk_order FOREIGN KEY ("order") REFERENCES orders (id) ON DELETE CASCADE,
			    CONSTRAINT fk_product FOREIGN KEY (product) REFERENCES products (id)
			  )
			)
			`) 
			--> SchemaSchema:
			 
			public (
			  users (
			    id SERIAL PRIMARY KEY,
			    parent_user INTEGER,
			    metadata INTEGER,
			    username VARCHAR(50) NOT NULL UNIQUE,
			    email VARCHAR(100) NOT NULL UNIQUE CHECK (email LIKE '%@%'),
			    password_hash TEXT NOT NULL,
			    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
			    updated_at TIMESTAMP,
			    CHECK (password_hash LIKE '3...'),
			    status VARCHAR(10) NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'inactive', 'banned')),
			    CONSTRAINT fk_meta FOREIGN KEY (metadata) REFERENCES public2.user_metadata (id) ON DELETE CASCADE,
			    CONSTRAINT fk_parent_user FOREIGN KEY (parent_user) REFERENCES users (id) ON DELETE CASCADE
			  ),
			  orders (
			    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
			    parent_order UUID,
			    user INTEGER NOT NULL,
			    order_total NUMERIC(10, 2) NOT NULL CHECK (order_total >= 0),
			    status TEXT NOT NULL CHECK (status IN ('pending', 'paid', 'cancelled', 'shipped')),
			    placed_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
			    CONSTRAINT fk_parent_order FOREIGN KEY (parent_order) REFERENCES orders (id) ON DELETE CASCADE,
			    CONSTRAINT fk_user FOREIGN KEY (user) REFERENCES users (id) ON DELETE CASCADE
			  ),
			  products (
			    id SERIAL PRIMARY KEY,
			    name VARCHAR(100) NOT NULL,
			    sku VARCHAR(30) UNIQUE NOT NULL,
			    price NUMERIC(8, 2) NOT NULL CHECK (price > 0),
			    stock_quantity INTEGER NOT NULL CHECK (stock_quantity >= 0),
			    is_active BOOLEAN NOT NULL DEFAULT TRUE
			  ),
			  order_items (
			    "order" UUID NOT NULL,
			    product INTEGER NOT NULL,
			    quantity INTEGER NOT NULL CHECK (quantity > 0),
			    unit_price NUMERIC(8, 2) NOT NULL CHECK (unit_price >= 0),
			    PRIMARY KEY ("order", product),
			    CONSTRAINT fk_order FOREIGN KEY ("order") REFERENCES orders (id) ON DELETE CASCADE,
			    CONSTRAINT fk_product FOREIGN KEY (product) REFERENCES products (id)
			  )
			)
			
      ∟ SchemaSchema .parse(`
			public2 (
			  inventory_adjustments (
			    id SERIAL PRIMARY KEY,
			    product INTEGER NOT NULL,
			    adjustment_quantity INTEGER NOT NULL CHECK (adjustment_quantity != 0),
			    reason TEXT NOT NULL CHECK (reason IN ('restock', 'return', 'damage', 'manual')),
			    adjusted_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
			    CONSTRAINT fk_adjusted_product FOREIGN KEY (product) REFERENCES products (id)
			  ),
			  system_logs (
			    id BIGSERIAL PRIMARY KEY,
			    log_level TEXT NOT NULL CHECK (log_level IN ('info', 'warning', 'error')),
			    message TEXT NOT NULL,
			    source_module TEXT,
			    logged_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
			  ),
			  user_metadata (
			    id BIGSERIAL PRIMARY KEY,
			    data JSON NOT NULL
			  )
			)
			`) 
			--> SchemaSchema:
			 
			public2 (
			  inventory_adjustments (
			    id SERIAL PRIMARY KEY,
			    product INTEGER NOT NULL,
			    adjustment_quantity INTEGER NOT NULL CHECK (adjustment_quantity != 0),
			    reason TEXT NOT NULL CHECK (reason IN ('restock', 'return', 'damage', 'manual')),
			    adjusted_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
			    CONSTRAINT fk_adjusted_product FOREIGN KEY (product) REFERENCES products (id)
			  ),
			  system_logs (
			    id BIGSERIAL PRIMARY KEY,
			    log_level TEXT NOT NULL CHECK (log_level IN ('info', 'warning', 'error')),
			    message TEXT NOT NULL,
			    source_module TEXT,
			    logged_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
			  ),
			  user_metadata (id BIGSERIAL PRIMARY KEY, data JSON NOT NULL)
			)
			

  DeSugaring - Expr DeSugaring
    LQObjectLiteral
      ✔ should parse an "LQObjectLiteral" expr with formal fields and desugar it - Postgres
        ∟ LQObjectLiteral.parse(`{ key1: 'value1', key2: 'value2' }`) --> LQObjectLiteral: { key1: 'value1', key2: 'value2' } --> CallExpr: JSON_BUILD_OBJECT('key1', 'value1', 'key2', 'value2')
      ✔ should parse an "LQObjectLiteral" expr with formal fields and desugar it - MySQL
        ∟ LQObjectLiteral.parse(`{ key1: 'value1', key2: 'value2' }`) --> LQObjectLiteral: { key1: 'value1', key2: 'value2' } --> CallExpr: JSON_OBJECT('key1', 'value1', 'key2', 'value2')
      ✔ should parse an "LQObjectLiteral" expr with shorthand fields and desugar it - Postgres
        ∟ LQObjectLiteral.parse(`{ key1, key2: 'value2' }`) --> LQObjectLiteral: { key1, key2: 'value2' } --> CallExpr: JSON_BUILD_OBJECT('key1', key1, 'key2', 'value2')
      ✔ should parse an "LQObjectLiteral" expr with shorthand fields and desugar it - MySQL
        ∟ LQObjectLiteral.parse(`{ key1, key2: 'value2' }`) --> LQObjectLiteral: { key1, key2: 'value2' } --> CallExpr: JSON_OBJECT('key1', key1, 'key2', 'value2')
      ✔ should parse an "LQObjectLiteral" expr with aggregation syntax and desugar it - Postgres
        ∟ LQObjectLiteral.parse(`{ key1, key2[]: expr }`) --> LQObjectLiteral: { key1, key2[]: expr } --> CallExpr: JSON_BUILD_OBJECT('key1', key1, 'key2', JSON_AGG(expr))
      ✔ should parse an "LQObjectLiteral" expr with aggregation syntax and desugar it - MySQL
        ∟ LQObjectLiteral.parse(`{ key1, key2[]: expr }`) --> LQObjectLiteral: { key1, key2[]: expr } --> CallExpr: JSON_OBJECT('key1', key1, 'key2', JSON_ARRAYAGG(expr))
    LQArrayLiteral
      ✔ should parse an "LQArrayLiteral" expr and desugar it - Postgres
        ∟ LQArrayLiteral.parse(`['value1', 'value2']`) --> LQArrayLiteral: ['value1', 'value2'] --> CallExpr: JSON_BUILD_ARRAY('value1', 'value2')
      ✔ should parse an "LQArrayLiteral" expr and desugar it - MySQL
        ∟ LQArrayLiteral.parse(`['value1', 'value2']`) --> LQArrayLiteral: ['value1', 'value2'] --> CallExpr: JSON_ARRAY('value1', 'value2')
    PGTypedArrayLiteral
      ✔ should parse an "PGTypedArrayLiteral" expr toDialect: mysql
        ∟ PGTypedArrayLiteral.parse(`ARRAY['value1', 'value2']`) --> PGTypedArrayLiteral: ARRAY['value1', 'value2'] --> CallExpr: JSON_ARRAY('value1', 'value2')
    SelectElement
      ✔ should parse an "SelectElement" expr with an aggregation syntax - Postgres
        ∟ BasicSelectStmt.parse(`SELECT email AS alias[] FROM users`) --> BasicSelectStmt: SELECT email AS alias[] FROM users --> BasicSelectStmt: SELECT JSON_AGG(users.email) AS alias FROM public.users
      ✔ should parse an "SelectElement" expr with an aggregation syntax - MySQL
        ∟ BasicSelectStmt.parse(`SELECT email AS alias[] FROM users`) --> BasicSelectStmt: SELECT email AS alias[] FROM users --> BasicSelectStmt: SELECT JSON_ARRAYAGG(users.email) AS alias FROM public.users
      ✔ should parse an "SelectElement" expr with an aggregation syntax - Postgres
        ∟ BasicSelectStmt.parse(`SELECT email + 1 - 3 alias[] FROM users`) --> BasicSelectStmt: SELECT email + 1 - 3 alias[] FROM users --> BasicSelectStmt: SELECT JSON_AGG(users.email + 1 - 3) alias FROM public.users
      ✔ should parse an "SelectElement" expr with an aggregation syntax - MySQL
        ∟ BasicSelectStmt.parse(`SELECT email + 1 - 3 alias[] FROM public.users`) --> BasicSelectStmt: SELECT email + 1 - 3 alias[] FROM public.users --> BasicSelectStmt: SELECT JSON_ARRAYAGG(users.email + 1 - 3) alias FROM public.users
    VersionSpec
      ✔ should parse an "SchemaRef" with version spec to just the SchemaRef - Postgres
        ∟ SchemaRef    .parse(`schema1@3_3`) --> SchemaRef: schema1@3_3 --> SchemaRef: schema1
      ✔ should parse an "TableRef1" with version spec to just the TableRef1 - Postgres
        ∟ TableRef1    .parse(`tbl@3_3`) --> TableRef1: tbl@3_3 --> TableRef1: tbl
    LQObjectLiteral As Root Select List
      ✔ should parse an "SelectStmt" with un-aliased LQObjectLiteral as root select list - Postgres
        ∟ SelectStmt   .parse(`SELECT { id, username, emails[]: email + 4 } FROM users`) --> SelectStmt: SELECT { id, username, emails[]: email + 4 } FROM users --> CompleteSelectStmt: SELECT JSON_BUILD_OBJECT('id', users.id, 'username', users.username, 'emails', JSON_AGG(users.email + 4)) FROM public.users
      ✔ should parse an "SelectStmt" with un-aliased LQObjectLiteral as root select list - MySQL
        ∟ SelectStmt   .parse(`SELECT { id, username, emails[]: email + 4 } FROM users`) --> SelectStmt: SELECT { id, username, emails[]: email + 4 } FROM users --> CompleteSelectStmt: SELECT JSON_OBJECT('id', users.id, 'username', users.username, 'emails', JSON_ARRAYAGG(users.email + 4)) FROM public.users

  DeSugaring - Refs Resolution
    TableRef1
      ✔ should parse a bare "TableRef1" to a fully-qualified TableRef1
        ∟ TableRef1    .parse(`users`) --> TableRef1: users --> TableRef1: public.users
    ColumnRef1
      ✔ should parse and fully-qualify a bare "ColumnRef1"
        ∟ BasicSelectStmt.parse(`SELECT username FROM users`) --> BasicSelectStmt: SELECT username FROM users --> BasicSelectStmt: SELECT users.username FROM public.users
      ✔ should parse and fully-qualify a bare "ColumnRef1"
        ∟ BasicSelectStmt.parse(`SELECT id FROM orders AS o`) --> BasicSelectStmt: SELECT id FROM orders AS o --> BasicSelectStmt: SELECT o.id FROM public.orders AS o
      ✔ should parse a "star" ref
        ∟ BasicSelectStmt.parse(`SELECT * FROM users`) --> BasicSelectStmt: SELECT * FROM users --> BasicSelectStmt: SELECT * FROM public.users
      ✔ should parse and deSugar/expand a "star" ref
        ∟ BasicSelectStmt.parse(`
				SELECT *
				FROM users
				`) 
				--> BasicSelectStmt:
				 
				SELECT *
				FROM users
				 
				--> BasicSelectStmt:
				 
				SELECT 
				  users.id AS id,
				  users.parent_user AS parent_user,
				  users.metadata AS metadata,
				  users.username AS username,
				  users.email AS email,
				  users.password_hash AS password_hash,
				  users.created_at AS created_at,
				  users.updated_at AS updated_at,
				  users.status AS status
				FROM public.users AS users
				

  DeSugaring - Multi-dimensional SELECT Statements
    Deep Refs
      ✔ should parse and deSugar a basic Deep Ref
        ∟ BasicSelectStmt.parse(`
				SELECT id, user ~> email 
				FROM orders AS o
				`) 
				--> BasicSelectStmt:
				 
				SELECT id, user ~> email
				FROM orders AS o
				 
				--> BasicSelectStmt:
				 
				SELECT o.id AS id, "$join~0"."$ref~0" AS email
				FROM public.orders AS o
				LEFT JOIN (
				  SELECT users.id AS "$key~0", users.email AS "$ref~0"
				  FROM public.users
				) AS "$join~0"
				  ON o.user = "$join~0"."$key~0"
				
      ✔ should parse and deSugar a multi-level Deep Ref
        ∟ BasicSelectStmt.parse(`
				SELECT id, parent_order ~> parent_order ~> status
				FROM orders AS o
				`) 
				--> BasicSelectStmt:
				 
				SELECT id, parent_order ~> parent_order ~> status
				FROM orders AS o
				 
				--> BasicSelectStmt:
				 
				SELECT o.id AS id, "$join~0"."$ref~0" AS status
				FROM public.orders AS o
				LEFT JOIN (
				  SELECT orders.id AS "$key~0", "$join~0"."$ref~0" AS "$ref~0"
				  FROM public.orders
				  LEFT JOIN (
				    SELECT orders.id AS "$key~0", orders.status AS "$ref~0"
				    FROM public.orders
				  ) AS "$join~0"
				    ON orders.parent_order = "$join~0"."$key~0"
				) AS "$join~0"
				  ON o.parent_order = "$join~0"."$key~0"
				
      ✔ should parse and deSugar into a single JOIN multiple Deep Refs (127ms)
        ∟ BasicSelectStmt.parse(`
				SELECT
				  id,
				  parent_order ~> parent_order ~> status,
				  parent_order ~> parent_order
				FROM orders AS o
				`) 
				--> BasicSelectStmt:
				 
				SELECT 
				  id,
				  parent_order ~> parent_order ~> status,
				  parent_order ~> parent_order
				FROM orders AS o
				 
				--> BasicSelectStmt:
				 
				SELECT 
				  o.id AS id,
				  "$join~0"."$ref~0" AS status,
				  "$join~0"."$ref~1" AS parent_order
				FROM public.orders AS o
				LEFT JOIN (
				  SELECT 
				    orders.id AS "$key~0",
				    "$join~0"."$ref~0" AS "$ref~0",
				    orders.parent_order AS "$ref~1"
				  FROM public.orders
				  LEFT JOIN (
				    SELECT orders.id AS "$key~0", orders.status AS "$ref~0"
				    FROM public.orders
				  ) AS "$join~0"
				    ON orders.parent_order = "$join~0"."$key~0"
				) AS "$join~0"
				  ON o.parent_order = "$join~0"."$key~0"
				
      ✔ should parse and deSugar a subquery-level Deep Ref (72ms)
        ∟ BasicSelectStmt.parse(`
				SELECT 
				  id,
				  u.parent_user ~> email AS outerParentEmail,
				  innerParentEmail
				FROM orders AS o
				CROSS JOIN (
				  SELECT parent_user, parent_user ~> email AS innerParentEmail
				  FROM users
				) AS u
				`) 
				--> BasicSelectStmt:
				 
				SELECT 
				  id,
				  u.parent_user ~> email AS outerParentEmail,
				  innerParentEmail
				FROM orders AS o
				CROSS JOIN (
				  SELECT parent_user, parent_user ~> email AS innerParentEmail
				  FROM users
				) AS u
				 
				--> BasicSelectStmt:
				 
				SELECT 
				  o.id AS id,
				  "$join~0"."$ref~0" AS outerParentEmail,
				  u.innerParentEmail AS innerParentEmail
				FROM public.orders AS o
				CROSS JOIN (
				  SELECT 
				    users.parent_user AS parent_user,
				    "$join~0"."$ref~0" AS innerParentEmail
				  FROM public.users
				  LEFT JOIN (
				    SELECT users.id AS "$key~0", users.email AS "$ref~0"
				    FROM public.users
				  ) AS "$join~0"
				    ON users.parent_user = "$join~0"."$key~0"
				) AS u
				LEFT JOIN (
				  SELECT users.id AS "$key~0", users.email AS "$ref~0"
				  FROM public.users
				) AS "$join~0"
				  ON u.parent_user = "$join~0"."$key~0"
				
      ✔ should "expose" a foreign key from subquery to outer query and plot a Deep Ref from off it (43ms)
        ∟ BasicSelectStmt.parse(`
				SELECT id, u.parent ~> email AS outerParentEmail, innerParentEmail
				FROM orders AS o
				CROSS JOIN (
				  SELECT
				    parent_user AS parent,
				    parent_user ~> email AS innerParentEmail
				  FROM users
				) AS u
				`) 
				--> BasicSelectStmt:
				 
				SELECT id, u.parent ~> email AS outerParentEmail, innerParentEmail
				FROM orders AS o
				CROSS JOIN (
				  SELECT 
				    parent_user AS parent,
				    parent_user ~> email AS innerParentEmail
				  FROM users
				) AS u
				 
				--> BasicSelectStmt:
				 
				SELECT 
				  o.id AS id,
				  "$join~0"."$ref~0" AS outerParentEmail,
				  u.innerParentEmail AS innerParentEmail
				FROM public.orders AS o
				CROSS JOIN (
				  SELECT 
				    users.parent_user AS parent,
				    "$join~0"."$ref~0" AS innerParentEmail
				  FROM public.users
				  LEFT JOIN (
				    SELECT users.id AS "$key~0", users.email AS "$ref~0"
				    FROM public.users
				  ) AS "$join~0"
				    ON users.parent_user = "$join~0"."$key~0"
				) AS u
				LEFT JOIN (
				  SELECT users.id AS "$key~0", users.email AS "$ref~0"
				  FROM public.users
				) AS "$join~0"
				  ON u.parent = "$join~0"."$key~0"
				
      ✔ should "inherit" a foreign key from outer query at subquery and plot a Deep Ref from off it
        ∟ BasicSelectStmt.parse(`
				SELECT
				  id,
				  parent_user ~> email AS outerParentEmail,
				  parent_order,
				  innerParentEmail
				FROM users AS u
				CROSS JOIN LATERAL (
				  SELECT parent_order, parent_user ~> id AS innerParentEmail
				  FROM orders
				) AS o
				`) 
				--> BasicSelectStmt:
				 
				SELECT 
				  id,
				  parent_user ~> email AS outerParentEmail,
				  parent_order,
				  innerParentEmail
				FROM users AS u
				CROSS JOIN LATERAL (
				  SELECT parent_order, parent_user ~> id AS innerParentEmail
				  FROM orders
				) AS o
				 
				--> BasicSelectStmt:
				 
				SELECT 
				  u.id AS id,
				  "$join~0"."$ref~0" AS outerParentEmail,
				  o.parent_order AS parent_order,
				  o.innerParentEmail AS innerParentEmail
				FROM public.users AS u
				CROSS JOIN LATERAL (
				  SELECT 
				    orders.parent_order AS parent_order,
				    "$join~0"."$ref~0" AS innerParentEmail
				  FROM public.orders
				  LEFT JOIN (
				    SELECT users.id AS "$key~0", users.id AS "$ref~0"
				    FROM public.users
				  ) AS "$join~0"
				    ON u.parent_user = "$join~0"."$key~0"
				) AS o
				LEFT JOIN (
				  SELECT users.id AS "$key~0", users.email AS "$ref~0"
				  FROM public.users
				) AS "$join~0"
				  ON u.parent_user = "$join~0"."$key~0"
				
    Back Referencing Deep Refs
      ✔ should parse and deSugar a basic "back-referencing" Deep Ref
        ∟ BasicSelectStmt.parse(`
				SELECT id, (parent_order <~ orders) ~> status
				FROM orders AS o
				`) 
				--> BasicSelectStmt:
				 
				SELECT id, (parent_order <~ orders) ~> status
				FROM orders AS o
				 
				--> BasicSelectStmt:
				 
				SELECT o.id AS id, "$join~0"."$ref~0" AS status
				FROM public.orders AS o
				LEFT JOIN (
				  SELECT orders.parent_order AS "$key~0", orders.status AS "$ref~0"
				  FROM public.orders
				) AS "$join~0"
				  ON o.id = "$join~0"."$key~0"
				
      ✔ should parse and deSugar a basic "back-referencing" Deep Ref as an aggregated output field
        ∟ BasicSelectStmt.parse(`
				SELECT id, (parent_order <~ orders) ~> status AS status[]
				FROM orders AS o
				`) 
				--> BasicSelectStmt:
				 
				SELECT id, (parent_order <~ orders) ~> status AS status[]
				FROM orders AS o
				 
				--> BasicSelectStmt:
				 
				SELECT o.id AS id, "$join~0"."$ref~0" AS status
				FROM public.orders AS o
				LEFT JOIN (
				  SELECT 
				    orders.parent_order AS "$key~0",
				    JSON_AGG(orders.status) AS "$ref~0"
				  FROM public.orders GROUP BY "$key~0"
				) AS "$join~0"
				  ON o.id = "$join~0"."$key~0"
				
      ✔ should parse and deSugar a "back-referencing" Deep Ref with an explicit base "From Item" specifier
        ∟ BasicSelectStmt.parse(`
				SELECT
				  email,
				  ((u) parent_user <~ parent_user <~ users).metadata ~> id AS m[]
				FROM users u
				`) 
				--> BasicSelectStmt:
				 
				SELECT 
				  email,
				  ((u) parent_user <~ parent_user <~ users).metadata ~> id AS m[]
				FROM users u
				 
				--> BasicSelectStmt:
				 
				SELECT u.email AS email, "$join~0"."$ref~0" AS m
				FROM public.users u
				LEFT JOIN (
				  SELECT 
				    "$join~0"."$ref~0" AS "$key~0",
				    JSON_AGG("$join~1"."$ref~1") AS "$ref~0"
				  FROM public.users
				  LEFT JOIN (
				    SELECT users.id AS "$key~0", users.parent_user AS "$ref~0"
				    FROM public.users
				  ) AS "$join~0"
				    ON users.parent_user = "$join~0"."$key~0"
				  LEFT JOIN (
				    SELECT user_metadata.id AS "$key~1", user_metadata.id AS "$ref~1"
				    FROM public2.user_metadata
				  ) AS "$join~1"
				    ON users.metadata = "$join~1"."$key~1" GROUP BY "$key~0"
				) AS "$join~0"
				  ON u.id = "$join~0"."$key~0"
				
      ✔ should parse and deSugar a "back-referencing" Deep Ref with an explicit base "From Item" specifier among multiple
        ∟ BasicSelectStmt.parse(`
				SELECT
				  email,
				  ((u2) parent_user <~ parent_user <~ users).metadata ~> id AS m[]
				FROM users u1
				LEFT JOIN users u2
				  ON u1.id = u2.id
				`) 
				--> BasicSelectStmt:
				 
				SELECT 
				  email,
				  ((u2) parent_user <~ parent_user <~ users).metadata ~> id AS m[]
				FROM users u1
				LEFT JOIN users u2
				  ON u1.id = u2.id
				 
				--> BasicSelectStmt:
				 
				SELECT u1.email AS email, "$join~0"."$ref~0" AS m
				FROM public.users u1
				LEFT JOIN public.users u2
				  ON u1.id = u2.id
				LEFT JOIN (
				  SELECT 
				    "$join~0"."$ref~0" AS "$key~0",
				    JSON_AGG("$join~1"."$ref~1") AS "$ref~0"
				  FROM public.users
				  LEFT JOIN (
				    SELECT users.id AS "$key~0", users.parent_user AS "$ref~0"
				    FROM public.users
				  ) AS "$join~0"
				    ON users.parent_user = "$join~0"."$key~0"
				  LEFT JOIN (
				    SELECT user_metadata.id AS "$key~1", user_metadata.id AS "$ref~1"
				    FROM public2.user_metadata
				  ) AS "$join~1"
				    ON users.metadata = "$join~1"."$key~1" GROUP BY "$key~0"
				) AS "$join~0"
				  ON u2.id = "$join~0"."$key~0"
				
      ✔ should parse and deSugar a "back-back-referencing" Deep Ref
        ∟ BasicSelectStmt.parse(`
				SELECT id, (parent_order <~ parent_order <~ orders) ~> status
				FROM orders AS o
				`) 
				--> BasicSelectStmt:
				 
				SELECT id, (parent_order <~ parent_order <~ orders) ~> status
				FROM orders AS o
				 
				--> BasicSelectStmt:
				 
				SELECT o.id AS id, "$join~0"."$ref~0" AS status
				FROM public.orders AS o
				LEFT JOIN (
				  SELECT "$join~0"."$ref~0" AS "$key~0", orders.status AS "$ref~0"
				  FROM public.orders
				  LEFT JOIN (
				    SELECT orders.id AS "$key~0", orders.parent_order AS "$ref~0"
				    FROM public.orders
				  ) AS "$join~0"
				    ON orders.parent_order = "$join~0"."$key~0"
				) AS "$join~0"
				  ON o.id = "$join~0"."$key~0"
				
      ✔ should parse and deSugar a back-back Ref as column qualifier
        ∟ BasicSelectStmt.parse(`
				SELECT id, (parent_order <~ orders).status
				FROM orders AS o
				`) 
				--> BasicSelectStmt:
				 
				SELECT id, (parent_order <~ orders).status
				FROM orders AS o
				 
				--> BasicSelectStmt:
				 
				SELECT o.id AS id, "$join~0"."$ref~0" AS status
				FROM public.orders AS o
				LEFT JOIN (
				  SELECT orders.parent_order AS "$key~0", orders.status AS "$ref~0"
				  FROM public.orders
				) AS "$join~0"
				  ON o.id = "$join~0"."$key~0"
				
      ✔ should parse and deSugar a back-back Ref as column qualifier
        ∟ BasicSelectStmt.parse(`
				SELECT id, (parent_order <~ parent_order <~ orders).status
				FROM orders AS o
				`) 
				--> BasicSelectStmt:
				 
				SELECT id, (parent_order <~ parent_order <~ orders).status
				FROM orders AS o
				 
				--> BasicSelectStmt:
				 
				SELECT o.id AS id, "$join~0"."$ref~0" AS status
				FROM public.orders AS o
				LEFT JOIN (
				  SELECT "$join~0"."$ref~0" AS "$key~0", orders.status AS "$ref~0"
				  FROM public.orders
				  LEFT JOIN (
				    SELECT orders.id AS "$key~0", orders.parent_order AS "$ref~0"
				    FROM public.orders
				  ) AS "$join~0"
				    ON orders.parent_order = "$join~0"."$key~0"
				) AS "$join~0"
				  ON o.id = "$join~0"."$key~0"
				
      ✔ should parse and deSugar into a single JOIN multiple "back-back-referencing" Deep Refs as column qualifier
        ∟ BasicSelectStmt.parse(`
				SELECT
				  id,
				  (parent_order <~ parent_order <~ orders).status AS status,
				  (parent_order <~ parent_order <~ orders).status
				FROM orders AS o
				`) 
				--> BasicSelectStmt:
				 
				SELECT 
				  id,
				  (parent_order <~ parent_order <~ orders).status AS status,
				  (parent_order <~ parent_order <~ orders).status
				FROM orders AS o
				 
				--> BasicSelectStmt:
				 
				SELECT 
				  o.id AS id,
				  "$join~0"."$ref~0" AS status,
				  "$join~0"."$ref~1" AS status
				FROM public.orders AS o
				LEFT JOIN (
				  SELECT 
				    "$join~0"."$ref~0" AS "$key~0",
				    orders.status AS "$ref~0",
				    orders.status AS "$ref~1"
				  FROM public.orders
				  LEFT JOIN (
				    SELECT orders.id AS "$key~0", orders.parent_order AS "$ref~0"
				    FROM public.orders
				  ) AS "$join~0"
				    ON orders.parent_order = "$join~0"."$key~0"
				) AS "$join~0"
				  ON o.id = "$join~0"."$key~0"
				
      ✔ should parse and deSugar into distinct JOINS multiple "back-back-referencing" Deep Refs as column qualifier
        ∟ BasicSelectStmt.parse(`
				SELECT
				  id,
				  (parent_order <~ parent_order <~ orders).status AS status[],
				  (parent_order <~ parent_order <~ orders).status
				FROM orders AS o
				`) 
				--> BasicSelectStmt:
				 
				SELECT 
				  id,
				  (parent_order <~ parent_order <~ orders).status AS status[],
				  (parent_order <~ parent_order <~ orders).status
				FROM orders AS o
				 
				--> BasicSelectStmt:
				 
				SELECT 
				  o.id AS id,
				  "$join~0"."$ref~0" AS status,
				  "$join~1"."$ref~1" AS status
				FROM public.orders AS o
				LEFT JOIN (
				  SELECT 
				    "$join~0"."$ref~0" AS "$key~0",
				    JSON_AGG(orders.status) AS "$ref~0"
				  FROM public.orders
				  LEFT JOIN (
				    SELECT orders.id AS "$key~0", orders.parent_order AS "$ref~0"
				    FROM public.orders
				  ) AS "$join~0"
				    ON orders.parent_order = "$join~0"."$key~0" GROUP BY "$key~0"
				) AS "$join~0"
				  ON o.id = "$join~0"."$key~0"
				LEFT JOIN (
				  SELECT "$join~0"."$ref~0" AS "$key~1", orders.status AS "$ref~1"
				  FROM public.orders
				  LEFT JOIN (
				    SELECT orders.id AS "$key~0", orders.parent_order AS "$ref~0"
				    FROM public.orders
				  ) AS "$join~0"
				    ON orders.parent_order = "$join~0"."$key~0"
				) AS "$join~1"
				  ON o.id = "$join~1"."$key~1"
				
      ✔ should parse and deSugar into distinct JOINS multiple "back-back-referencing" Deep Refs as column qualifier
        ∟ BasicSelectStmt.parse(`
				SELECT
				  id,
				  (parent_order <~ parent_order <~ orders).status AS status[],
				  (parent_order <~ parent_order <~ orders).order_total as order_total[],
				  (parent_order <~ parent_order <~ orders).status
				FROM orders AS o
				`) 
				--> BasicSelectStmt:
				 
				SELECT 
				  id,
				  (parent_order <~ parent_order <~ orders).status AS status[],
				  (parent_order <~ parent_order <~ orders).order_total AS order_total[],
				  (parent_order <~ parent_order <~ orders).status
				FROM orders AS o
				 
				--> BasicSelectStmt:
				 
				SELECT 
				  o.id AS id,
				  "$join~0"."$ref~0" AS status,
				  "$join~0"."$ref~1" AS order_total,
				  "$join~1"."$ref~2" AS status
				FROM public.orders AS o
				LEFT JOIN (
				  SELECT 
				    "$join~0"."$ref~0" AS "$key~0",
				    JSON_AGG(orders.status) AS "$ref~0",
				    JSON_AGG(orders.order_total) AS "$ref~1"
				  FROM public.orders
				  LEFT JOIN (
				    SELECT orders.id AS "$key~0", orders.parent_order AS "$ref~0"
				    FROM public.orders
				  ) AS "$join~0"
				    ON orders.parent_order = "$join~0"."$key~0" GROUP BY "$key~0"
				) AS "$join~0"
				  ON o.id = "$join~0"."$key~0"
				LEFT JOIN (
				  SELECT "$join~0"."$ref~0" AS "$key~1", orders.status AS "$ref~2"
				  FROM public.orders
				  LEFT JOIN (
				    SELECT orders.id AS "$key~0", orders.parent_order AS "$ref~0"
				    FROM public.orders
				  ) AS "$join~0"
				    ON orders.parent_order = "$join~0"."$key~0"
				) AS "$join~1"
				  ON o.id = "$join~1"."$key~1"
				

  DeSugaring - Multi-dimensional INSERT Statements
    INSERT ... VALUES
      ✔ should parse a basic deep INSERT ... VALUES statement
        ∟ InsertStmt   .parse(`
				INSERT INTO users
				  (email, parent_user ~> (id, email))
				VALUES
				  ('dd', ROW (50, 20)),
				  ('dffff', ROW (5, 2000))
				`) 
				--> InsertStmt:
				 
				INSERT INTO users
				  (email, parent_user ~> (id, email))
				VALUES
				  ('dd', ROW (50, 20)), ('dffff', ROW (5, 2000))
				 
				--> CTE:
				 
				WITH
				  "$dependency~0" AS (
				    INSERT INTO public.users
				      (id, email)
				    VALUES
				      ROW (50, 20), ROW (5, 2000)
				    RETURNING users.id
				  ),
				  "$dependency~0~indices" AS (
				    SELECT 
				      "$dependency~0".id AS id,
				      ROW_NUMBER() OVER () AS "$row_number~b"
				    FROM "$dependency~0"
				  )
				INSERT INTO public.users
				  (email, parent_user)
				VALUES
				  ROW ('dd', (
				    SELECT "$dependency~0~indices".id
				    FROM "$dependency~0~indices"
				    WHERE "$dependency~0~indices"."$row_number~b" = 1
				  )),
				  ROW ('dffff', (
				    SELECT "$dependency~0~indices".id
				    FROM "$dependency~0~indices"
				    WHERE "$dependency~0~indices"."$row_number~b" = 2
				  ))
				
      ✔ should parse a "deep-deep" INSERT ... VALUES statement
        ∟ InsertStmt   .parse(`
				INSERT INTO users
				  (email, parent_user ~> parent_user ~> (id, email))
				VALUES
				  ('dd', ROW (50, 2100)),
				  ('dffff', ROW (5, 2000))
				`) 
				--> InsertStmt:
				 
				INSERT INTO users
				  (email, parent_user ~> parent_user ~> (id, email))
				VALUES
				  ('dd', ROW (50, 2100)), ('dffff', ROW (5, 2000))
				 
				--> CTE:
				 
				WITH
				  "$dependency~1" AS (
				    INSERT INTO public.users
				      (id, email)
				    VALUES
				      ROW (50, 2100), ROW (5, 2000)
				    RETURNING users.id
				  ),
				  "$dependency~1~indices" AS (
				    SELECT 
				      "$dependency~1".id AS id,
				      ROW_NUMBER() OVER () AS "$row_number~b"
				    FROM "$dependency~1"
				  ),
				  "$dependency~0" AS (
				    INSERT INTO public.users
				      (parent_user)
				    VALUES
				      ROW ((
				        SELECT "$dependency~1~indices".id
				        FROM "$dependency~1~indices"
				        WHERE "$dependency~1~indices"."$row_number~b" = 1
				      )),
				      ROW ((
				        SELECT "$dependency~1~indices".id
				        FROM "$dependency~1~indices"
				        WHERE "$dependency~1~indices"."$row_number~b" = 2
				      ))
				    RETURNING users.id
				  ),
				  "$dependency~0~indices" AS (
				    SELECT 
				      "$dependency~0".id AS id,
				      ROW_NUMBER() OVER () AS "$row_number~b"
				    FROM "$dependency~0"
				  )
				INSERT INTO public.users
				  (email, parent_user)
				VALUES
				  ROW ('dd', (
				    SELECT "$dependency~0~indices".id
				    FROM "$dependency~0~indices"
				    WHERE "$dependency~0~indices"."$row_number~b" = 1
				  )),
				  ROW ('dffff', (
				    SELECT "$dependency~0~indices".id
				    FROM "$dependency~0~indices"
				    WHERE "$dependency~0~indices"."$row_number~b" = 2
				  ))
				
      ✔ should parse a "back-referencing" deep INSERT ... VALUES statement
        ∟ InsertStmt   .parse(`
				INSERT INTO users
				  (email, (parent_user <~ users) ~> (id, email))
				VALUES
				  ('dd', ROW (50, 2100)),
				  ('dffff', ROW (5, 2000))
				`) 
				--> InsertStmt:
				 
				INSERT INTO users
				  (email, (parent_user <~ users) ~> (id, email))
				VALUES
				  ('dd', ROW (50, 2100)), ('dffff', ROW (5, 2000))
				 
				--> CTE:
				 
				WITH
				  "$main~0" AS (
				    INSERT INTO public.users
				      (email)
				    VALUES
				      ROW ('dd'), ROW ('dffff')
				    RETURNING users.id
				  ),
				  "$main~0~indices" AS (
				    SELECT "$main~0".id AS id, ROW_NUMBER() OVER () AS "$row_number~b"
				    FROM "$main~0"
				  ),
				  "$dependent~0" AS (
				    INSERT INTO public.users
				      (id, email, parent_user)
				    VALUES
				      ROW (50, 2100, (
				        SELECT "$main~0~indices".id
				        FROM "$main~0~indices"
				        WHERE "$main~0~indices"."$row_number~b" = 1
				      )),
				      ROW (5, 2000, (
				        SELECT "$main~0~indices".id
				        FROM "$main~0~indices"
				        WHERE "$main~0~indices"."$row_number~b" = 2
				      ))
				  )
				SELECT COUNT(*) AS COUNT
				FROM "$main~0"
				
      ✔ should parse a "back-back-referencing" deep INSERT ... VALUES statement
        ∟ InsertStmt   .parse(`
				INSERT INTO users
				  (email, (parent_user <~ parent_user <~ users) ~> (id, email))
				VALUES
				  ('dd', ROW (50, 2100)),
				  ('dffff', ROW (5, 2000))
				`) 
				--> InsertStmt:
				 
				INSERT INTO users
				  (email, (parent_user <~ parent_user <~ users) ~> (id, email))
				VALUES
				  ('dd', ROW (50, 2100)), ('dffff', ROW (5, 2000))
				 
				--> CTE:
				 
				WITH
				  "$main~0" AS (
				    INSERT INTO public.users
				      (email)
				    VALUES
				      ROW ('dd'), ROW ('dffff')
				    RETURNING users.id
				  ),
				  "$main~0~indices" AS (
				    SELECT "$main~0".id AS id, ROW_NUMBER() OVER () AS "$row_number~b"
				    FROM "$main~0"
				  ),
				  "$dependency~0" AS (
				    INSERT INTO public.users
				      (parent_user)
				    SELECT "$main~0~indices".id
				    FROM "$main~0~indices"
				    WHERE "$main~0~indices"."$row_number~b" = 1
				    RETURNING users.id
				  ),
				  "$dependency~1" AS (
				    INSERT INTO public.users
				      (parent_user)
				    SELECT "$main~0~indices".id
				    FROM "$main~0~indices"
				    WHERE "$main~0~indices"."$row_number~b" = 2
				    RETURNING users.id
				  ),
				  "$dependent~0" AS (
				    INSERT INTO public.users
				      (id, email, parent_user)
				    VALUES
				      ROW (50, 2100, (
				        SELECT "$dependency~0".id
				        FROM "$dependency~0"
				      )),
				      ROW (5, 2000, (
				        SELECT "$dependency~1".id
				        FROM "$dependency~1"
				      ))
				  )
				SELECT COUNT(*) AS COUNT
				FROM "$main~0"
				
      ✔ should parse a "back-referencing" "deep-deep" INSERT ... VALUES statement
        ∟ InsertStmt   .parse(`
				INSERT INTO users
				  (email, (parent_user <~ parent_user <~ users) ~> parent_user ~> (id, email))
				VALUES
				  ('dd', ROW (50, 2100)),
				  ('dffff', ROW (5, 2000))
				`) 
				--> InsertStmt:
				 
				INSERT INTO users
				  (email, (parent_user <~ parent_user <~ users) ~> parent_user ~> (id, email))
				VALUES
				  ('dd', ROW (50, 2100)), ('dffff', ROW (5, 2000))
				 
				--> CTE:
				 
				WITH
				  "$main~0" AS (
				    INSERT INTO public.users
				      (email)
				    VALUES
				      ROW ('dd'), ROW ('dffff')
				    RETURNING users.id
				  ),
				  "$main~0~indices" AS (
				    SELECT "$main~0".id AS id, ROW_NUMBER() OVER () AS "$row_number~b"
				    FROM "$main~0"
				  ),
				  "$dependency~0" AS (
				    INSERT INTO public.users
				      (id, email)
				    VALUES
				      ROW (50, 2100), ROW (5, 2000)
				    RETURNING users.id
				  ),
				  "$dependency~0~indices" AS (
				    SELECT 
				      "$dependency~0".id AS id,
				      ROW_NUMBER() OVER () AS "$row_number~b"
				    FROM "$dependency~0"
				  ),
				  "$dependency~1" AS (
				    INSERT INTO public.users
				      (parent_user)
				    SELECT "$main~0~indices".id
				    FROM "$main~0~indices"
				    WHERE "$main~0~indices"."$row_number~b" = 1
				    RETURNING users.id
				  ),
				  "$dependency~2" AS (
				    INSERT INTO public.users
				      (parent_user)
				    SELECT "$main~0~indices".id
				    FROM "$main~0~indices"
				    WHERE "$main~0~indices"."$row_number~b" = 2
				    RETURNING users.id
				  ),
				  "$dependent~0" AS (
				    INSERT INTO public.users
				      (parent_user, parent_user)
				    VALUES
				      ROW ((
				        SELECT "$dependency~0~indices".id
				        FROM "$dependency~0~indices"
				        WHERE "$dependency~0~indices"."$row_number~b" = 1
				      ), (
				        SELECT "$dependency~1".id
				        FROM "$dependency~1"
				      )),
				      ROW ((
				        SELECT "$dependency~0~indices".id
				        FROM "$dependency~0~indices"
				        WHERE "$dependency~0~indices"."$row_number~b" = 2
				      ), (
				        SELECT "$dependency~2".id
				        FROM "$dependency~2"
				      ))
				  )
				SELECT COUNT(*) AS COUNT
				FROM "$main~0"
				
    INSERT ... DEFAULT VALUES
      ✔ should parse a basic deep INSERT ... DEFAULT VALUES statement
        ∟ InsertStmt   .parse(`
				INSERT INTO users
				  (email, parent_user ~> (username, email))
				DEFAULT VALUES
				`) 
				--> InsertStmt:
				 
				INSERT INTO users
				  (email, parent_user ~> (username, email))
				DEFAULT VALUES
				 
				--> CTE:
				 
				WITH "$dependency~0" AS (
				  INSERT INTO public.users
				    (username, email)
				  DEFAULT VALUES
				  RETURNING users.id
				)
				INSERT INTO public.users
				  (email, parent_user)
				VALUES ROW (DEFAULT, (
				  SELECT "$dependency~0".id
				  FROM "$dependency~0"
				))
				
      ✔ should parse a "deep-deep" INSERT ... DEFAULT VALUES statement
        ∟ InsertStmt   .parse(`
				INSERT INTO users
				  (email, parent_user ~> parent_user ~> (username, email))
				DEFAULT VALUES
				`) 
				--> InsertStmt:
				 
				INSERT INTO users
				  (email, parent_user ~> parent_user ~> (username, email))
				DEFAULT VALUES
				 
				--> CTE:
				 
				WITH
				  "$dependency~1" AS (
				    INSERT INTO public.users
				      (username, email)
				    DEFAULT VALUES
				    RETURNING users.id
				  ),
				  "$dependency~0" AS (
				    INSERT INTO public.users
				      (parent_user)
				    VALUES ROW ((
				      SELECT "$dependency~1".id
				      FROM "$dependency~1"
				    ))
				    RETURNING users.id
				  )
				INSERT INTO public.users
				  (email, parent_user)
				VALUES ROW (DEFAULT, (
				  SELECT "$dependency~0".id
				  FROM "$dependency~0"
				))
				
      ✔ should parse a "back-referencing" deep INSERT ... DEFAULT VALUES statement
        ∟ InsertStmt   .parse(`
				INSERT INTO users
				  (email, (parent_user <~ users) ~> (username, email))
				DEFAULT VALUES
				`) 
				--> InsertStmt:
				 
				INSERT INTO users
				  (email, (parent_user <~ users) ~> (username, email))
				DEFAULT VALUES
				 
				--> CTE:
				 
				WITH
				  "$main~0" AS (
				    INSERT INTO public.users
				      (email)
				    DEFAULT VALUES
				    RETURNING users.id
				  ),
				  "$dependent~0" AS (
				    INSERT INTO public.users
				      (username, email, parent_user)
				    VALUES ROW (DEFAULT, DEFAULT, (
				      SELECT "$main~0".id
				      FROM "$main~0"
				    ))
				  )
				SELECT COUNT(*) AS COUNT
				FROM "$main~0"
				
      ✔ should parse a "back-referencing" "deep-deep" INSERT ... DEFAULT VALUES statement
        ∟ InsertStmt   .parse(`
				INSERT INTO users
				  (email, (parent_user <~ users) ~> parent_user ~> (username, email))
				DEFAULT VALUES
				`) 
				--> InsertStmt:
				 
				INSERT INTO users
				  (email, (parent_user <~ users) ~> parent_user ~> (username, email))
				DEFAULT VALUES
				 
				--> CTE:
				 
				WITH
				  "$main~0" AS (
				    INSERT INTO public.users
				      (email)
				    DEFAULT VALUES
				    RETURNING users.id
				  ),
				  "$dependency~0" AS (
				    INSERT INTO public.users
				      (username, email)
				    DEFAULT VALUES
				    RETURNING users.id
				  ),
				  "$dependent~0" AS (
				    INSERT INTO public.users
				      (parent_user, parent_user)
				    VALUES ROW ((
				      SELECT "$dependency~0".id
				      FROM "$dependency~0"
				    ), (
				      SELECT "$main~0".id
				      FROM "$main~0"
				    ))
				  )
				SELECT COUNT(*) AS COUNT
				FROM "$main~0"
				
      ✔ should parse a "back-back-referencing" "deep-deep" INSERT ... DEFAULT VALUES statement
        ∟ InsertStmt   .parse(`
				INSERT INTO users
				  (email, (parent_user <~ parent_user <~ users) ~> parent_user ~> (username, email))
				DEFAULT VALUES
				`) 
				--> InsertStmt:
				 
				INSERT INTO users
				  (email, (parent_user <~ parent_user <~ users) ~> parent_user ~> (username, email))
				DEFAULT VALUES
				 
				--> CTE:
				 
				WITH
				  "$main~0" AS (
				    INSERT INTO public.users
				      (email)
				    DEFAULT VALUES
				    RETURNING users.id
				  ),
				  "$dependency~0" AS (
				    INSERT INTO public.users
				      (username, email)
				    DEFAULT VALUES
				    RETURNING users.id
				  ),
				  "$dependency~1" AS (
				    INSERT INTO public.users
				      (parent_user)
				    SELECT "$main~0".id
				    FROM "$main~0"
				    RETURNING users.id
				  ),
				  "$dependent~0" AS (
				    INSERT INTO public.users
				      (parent_user, parent_user)
				    VALUES ROW ((
				      SELECT "$dependency~0".id
				      FROM "$dependency~0"
				    ), (
				      SELECT "$dependency~1".id
				      FROM "$dependency~1"
				    ))
				  )
				SELECT COUNT(*) AS COUNT
				FROM "$main~0"
				
    INSERT ... SELECT
      ✔ should parse a basic deep INSERT ... SELECT statement
        ∟ InsertStmt   .parse(`
				INSERT INTO users
				  (id, email, parent_user ~> email)
				SELECT id, order_total AS email, parent_order AS rr FROM orders as t WHERE 1
				`) 
				--> InsertStmt:
				 
				INSERT INTO users
				  (id, email, parent_user ~> email)
				SELECT id, order_total AS email, parent_order AS rr
				FROM orders AS t
				WHERE 1
				 
				--> CTE:
				 
				WITH
				  "$memo~0" AS (
				    SELECT 
				      ROW_NUMBER() OVER () AS "$row_number~a",
				      t.id AS id,
				      t.order_total AS email,
				      t.parent_order AS rr
				    FROM public.orders AS t
				    WHERE 1
				  ),
				  "$dependency~0" AS (
				    INSERT INTO public.users
				      (email)
				    SELECT "$memo~0".rr AS email
				    FROM "$memo~0"
				    RETURNING users.id
				  ),
				  "$dependency~0~indices" AS (
				    SELECT 
				      "$dependency~0".id AS id,
				      ROW_NUMBER() OVER () AS "$row_number~b"
				    FROM "$dependency~0"
				  )
				INSERT INTO public.users
				  (id, email, parent_user)
				SELECT 
				  "$memo~0".id AS id,
				  "$memo~0".email AS email,
				  (
				    SELECT "$dependency~0~indices".id
				    FROM "$dependency~0~indices"
				    WHERE "$dependency~0~indices"."$row_number~b" = "$memo~0"."$row_number~a"
				  ) AS parent_user
				FROM "$memo~0"
				
      ✔ should parse a "deep-deep" INSERT ... SELECT statement
        ∟ InsertStmt   .parse(`
				INSERT INTO users
				  (id, email, parent_user ~> parent_user ~> email)
				SELECT id, order_total AS email, parent_order AS rr FROM orders as t WHERE 1
				`) 
				--> InsertStmt:
				 
				INSERT INTO users
				  (id, email, parent_user ~> parent_user ~> email)
				SELECT id, order_total AS email, parent_order AS rr
				FROM orders AS t
				WHERE 1
				 
				--> CTE:
				 
				WITH
				  "$memo~0" AS (
				    SELECT 
				      ROW_NUMBER() OVER () AS "$row_number~a",
				      t.id AS id,
				      t.order_total AS email,
				      t.parent_order AS rr
				    FROM public.orders AS t
				    WHERE 1
				  ),
				  "$dependency~1" AS (
				    INSERT INTO public.users
				      (email)
				    SELECT "$memo~0".rr AS email
				    FROM "$memo~0"
				    RETURNING users.id
				  ),
				  "$dependency~1~indices" AS (
				    SELECT 
				      "$dependency~1".id AS id,
				      ROW_NUMBER() OVER () AS "$row_number~b"
				    FROM "$dependency~1"
				  ),
				  "$dependency~0" AS (
				    INSERT INTO public.users
				      (parent_user)
				    SELECT (
				      SELECT "$dependency~1~indices".id
				      FROM "$dependency~1~indices"
				      WHERE "$dependency~1~indices"."$row_number~b" = "$memo~0"."$row_number~a"
				    ) AS parent_user
				    FROM "$memo~0"
				    RETURNING users.id
				  ),
				  "$dependency~0~indices" AS (
				    SELECT 
				      "$dependency~0".id AS id,
				      ROW_NUMBER() OVER () AS "$row_number~b"
				    FROM "$dependency~0"
				  )
				INSERT INTO public.users
				  (id, email, parent_user)
				SELECT 
				  "$memo~0".id AS id,
				  "$memo~0".email AS email,
				  (
				    SELECT "$dependency~0~indices".id
				    FROM "$dependency~0~indices"
				    WHERE "$dependency~0~indices"."$row_number~b" = "$memo~0"."$row_number~a"
				  ) AS parent_user
				FROM "$memo~0"
				
      ✔ should parse a "back-referencing" deep INSERT ... SELECT statement
        ∟ InsertStmt   .parse(`
				INSERT INTO users
				  (id, email, (parent_user <~ users) ~> email)
				SELECT id, order_total AS email, parent_order AS rr FROM orders as t WHERE 1
				`) 
				--> InsertStmt:
				 
				INSERT INTO users
				  (id, email, (parent_user <~ users) ~> email)
				SELECT id, order_total AS email, parent_order AS rr
				FROM orders AS t
				WHERE 1
				 
				--> CTE:
				 
				WITH
				  "$memo~0" AS (
				    SELECT 
				      ROW_NUMBER() OVER () AS "$row_number~a",
				      t.id AS id,
				      t.order_total AS email,
				      t.parent_order AS rr
				    FROM public.orders AS t
				    WHERE 1
				  ),
				  "$main~0" AS (
				    INSERT INTO public.users
				      (id, email)
				    SELECT "$memo~0".id AS id, "$memo~0".email AS email
				    FROM "$memo~0"
				    RETURNING users.id
				  ),
				  "$main~0~indices" AS (
				    SELECT "$main~0".id AS id, ROW_NUMBER() OVER () AS "$row_number~b"
				    FROM "$main~0"
				  ),
				  "$dependent~0" AS (
				    INSERT INTO public.users
				      (email, parent_user)
				    SELECT 
				      "$memo~0".rr AS email,
				      (
				        SELECT "$main~0~indices".id
				        FROM "$main~0~indices"
				        WHERE "$main~0~indices"."$row_number~b" = "$memo~0"."$row_number~a"
				      ) AS parent_user
				    FROM "$memo~0"
				  )
				SELECT COUNT(*) AS COUNT
				FROM "$main~0"
				
      ✔ should parse a "back-back-referencing" deep INSERT ... SELECT statement
        ∟ InsertStmt   .parse(`
				INSERT INTO users
				  (id, email, (parent_user <~ parent_user <~ users) ~> email)
				SELECT id, order_total AS email, parent_order AS rr FROM orders as t WHERE 1
				`) 
				--> InsertStmt:
				 
				INSERT INTO users
				  (id, email, (parent_user <~ parent_user <~ users) ~> email)
				SELECT id, order_total AS email, parent_order AS rr
				FROM orders AS t
				WHERE 1
				 
				--> CTE:
				 
				WITH
				  "$memo~0" AS (
				    SELECT 
				      ROW_NUMBER() OVER () AS "$row_number~a",
				      t.id AS id,
				      t.order_total AS email,
				      t.parent_order AS rr
				    FROM public.orders AS t
				    WHERE 1
				  ),
				  "$main~0" AS (
				    INSERT INTO public.users
				      (id, email)
				    SELECT "$memo~0".id AS id, "$memo~0".email AS email
				    FROM "$memo~0"
				    RETURNING users.id
				  ),
				  "$main~0~indices" AS (
				    SELECT "$main~0".id AS id, ROW_NUMBER() OVER () AS "$row_number~b"
				    FROM "$main~0"
				  ),
				  "$dependency~0" AS (
				    INSERT INTO public.users
				      (parent_user)
				    SELECT (
				      SELECT "$main~0~indices".id
				      FROM "$main~0~indices"
				      WHERE "$main~0~indices"."$row_number~b" = "$memo~0"."$row_number~a"
				    ) AS parent_user
				    FROM "$memo~0"
				    RETURNING users.id
				  ),
				  "$dependency~0~indices" AS (
				    SELECT 
				      "$dependency~0".id AS id,
				      ROW_NUMBER() OVER () AS "$row_number~b"
				    FROM "$dependency~0"
				  ),
				  "$dependent~0" AS (
				    INSERT INTO public.users
				      (email, parent_user)
				    SELECT 
				      "$memo~0".rr AS email,
				      (
				        SELECT "$dependency~0~indices".id
				        FROM "$dependency~0~indices"
				        WHERE "$dependency~0~indices"."$row_number~b" = "$memo~0"."$row_number~a"
				      ) AS parent_user
				    FROM "$memo~0"
				  )
				SELECT COUNT(*) AS COUNT
				FROM "$main~0"
				
      ✔ should parse a "back-back-referencing" "deep-deep" INSERT ... SELECT statement (41ms)
        ∟ InsertStmt   .parse(`
				INSERT INTO users
				  (username, email, (parent_user <~ parent_user <~ users) ~> parent_user ~> (status, email))
				SELECT id, order_total AS email, ROW(2, parent_order) AS rr FROM orders as t WHERE 1
				`) 
				--> InsertStmt:
				 
				INSERT INTO users
				  (username, email, (parent_user <~ parent_user <~ users) ~> parent_user ~> (status, email))
				SELECT id, order_total AS email, ROW (2, parent_order) AS rr
				FROM orders AS t
				WHERE 1
				 
				--> CTE:
				 
				WITH
				  "$memo~0" AS (
				    SELECT 
				      ROW_NUMBER() OVER () AS "$row_number~a",
				      t.id AS id,
				      t.order_total AS email,
				      2 AS "rr~rand~0",
				      t.parent_order AS "rr~rand~1"
				    FROM public.orders AS t
				    WHERE 1
				  ),
				  "$main~0" AS (
				    INSERT INTO public.users
				      (username, email)
				    SELECT "$memo~0".id AS id, "$memo~0".email AS email
				    FROM "$memo~0"
				    RETURNING users.id
				  ),
				  "$main~0~indices" AS (
				    SELECT "$main~0".id AS id, ROW_NUMBER() OVER () AS "$row_number~b"
				    FROM "$main~0"
				  ),
				  "$dependency~0" AS (
				    INSERT INTO public.users
				      (status, email)
				    SELECT 
				      "$memo~0"."rr~rand~0" AS status,
				      "$memo~0"."rr~rand~1" AS email
				    FROM "$memo~0"
				    RETURNING users.id
				  ),
				  "$dependency~0~indices" AS (
				    SELECT 
				      "$dependency~0".id AS id,
				      ROW_NUMBER() OVER () AS "$row_number~b"
				    FROM "$dependency~0"
				  ),
				  "$dependency~1" AS (
				    INSERT INTO public.users
				      (parent_user)
				    SELECT (
				      SELECT "$main~0~indices".id
				      FROM "$main~0~indices"
				      WHERE "$main~0~indices"."$row_number~b" = "$memo~0"."$row_number~a"
				    ) AS parent_user
				    FROM "$memo~0"
				    RETURNING users.id
				  ),
				  "$dependency~1~indices" AS (
				    SELECT 
				      "$dependency~1".id AS id,
				      ROW_NUMBER() OVER () AS "$row_number~b"
				    FROM "$dependency~1"
				  ),
				  "$dependent~0" AS (
				    INSERT INTO public.users
				      (parent_user, parent_user)
				    SELECT 
				      (
				        SELECT "$dependency~0~indices".id
				        FROM "$dependency~0~indices"
				        WHERE "$dependency~0~indices"."$row_number~b" = "$memo~0"."$row_number~a"
				      ) AS parent_user,
				      (
				        SELECT "$dependency~1~indices".id
				        FROM "$dependency~1~indices"
				        WHERE "$dependency~1~indices"."$row_number~b" = "$memo~0"."$row_number~a"
				      ) AS parent_user
				    FROM "$memo~0"
				  )
				SELECT COUNT(*) AS COUNT
				FROM "$main~0"
				

  DeSugaring - Multi-dimensional UPDATE Statements
    UPDATE
      ✔ should parse a basic deep UPDATE statement
        ∟ UpdateStmt   .parse(`
				UPDATE users AS u
				SET
				  id = 2,
				  email = 'x@x.com',
				  (username, parent_user ~> id) = (232, 3445)
				`) 
				--> UpdateStmt:
				 
				UPDATE users AS u
				SET
				  id = 2,
				  email = 'x@x.com',
				  (username, parent_user ~> id) = (232, 3445)
				 
				--> CTE:
				 
				WITH
				  "$main~0" AS (
				    UPDATE public.users AS u
				    SET
				      id = 2,
				      email = 'x@x.com',
				      (username, parent_user) = ROW (232, u.parent_user)
				    RETURNING u.parent_user
				  ),
				  "$dependency~0" AS (
				    UPDATE public.users AS users
				    SET (id) = ROW (3445)
				    WHERE users.id IN (
				      SELECT "$main~0".parent_user
				      FROM "$main~0"
				    )
				  )
				SELECT COUNT(*) AS COUNT
				FROM "$main~0"
				
      ✔ should parse a "deep-deep" UPDATE statement
        ∟ UpdateStmt   .parse(`
				UPDATE users AS u
				SET
				  id = 2,
				  email = 'x@x.com',
				  (username, parent_user ~> parent_user ~> id) = (232, 3445)
				`) 
				--> UpdateStmt:
				 
				UPDATE users AS u
				SET
				  id = 2,
				  email = 'x@x.com',
				  (username, parent_user ~> parent_user ~> id) = (232, 3445)
				 
				--> CTE:
				 
				WITH
				  "$main~0" AS (
				    UPDATE public.users AS u
				    SET
				      id = 2,
				      email = 'x@x.com',
				      (username, parent_user) = ROW (232, u.parent_user)
				    RETURNING u.parent_user
				  ),
				  "$main~1" AS (
				    UPDATE public.users AS users
				    SET (parent_user) = ROW (users.parent_user)
				    WHERE users.id IN (
				      SELECT "$main~0".parent_user
				      FROM "$main~0"
				    )
				    RETURNING users.parent_user
				  ),
				  "$dependency~1" AS (
				    UPDATE public.users AS users
				    SET (id) = ROW (3445)
				    WHERE users.id IN (
				      SELECT "$main~1".parent_user
				      FROM "$main~1"
				    )
				  )
				SELECT COUNT(*) AS COUNT
				FROM "$main~0"
				
      ✔ should parse a "back-referencing" deep UPDATE statement
        ∟ UpdateStmt   .parse(`
				UPDATE users AS u
				SET
				  id = 2,
				  email = 'x@x.com',
				  (username, (parent_user <~ users) ~> id) = (232, 3445)
				`) 
				--> UpdateStmt:
				 
				UPDATE users AS u
				SET
				  id = 2,
				  email = 'x@x.com',
				  (username, (parent_user <~ users) ~> id) = (232, 3445)
				 
				--> CTE:
				 
				WITH
				  "$main~0" AS (
				    UPDATE public.users AS u
				    SET
				      id = 2, email = 'x@x.com', (username) = ROW (232)
				    RETURNING u.id
				  ),
				  "$dependent~0" AS (
				    UPDATE public.users AS users
				    SET (id) = ROW (3445)
				    WHERE users.parent_user IN (
				      SELECT "$main~0".id
				      FROM "$main~0"
				    )
				  )
				SELECT COUNT(*) AS COUNT
				FROM "$main~0"
				
      ✔ should parse a "back-back-referencing" deep UPDATE statement
        ∟ UpdateStmt   .parse(`
				UPDATE users AS u
				SET
				  id = 2,
				  email = 'x@x.com',
				  (username, (parent_user <~ users) ~> parent_user ~> id) = (232, 3445)
				`) 
				--> UpdateStmt:
				 
				UPDATE users AS u
				SET
				  id = 2,
				  email = 'x@x.com',
				  (username, (parent_user <~ users) ~> parent_user ~> id) = (232, 3445)
				 
				--> CTE:
				 
				WITH
				  "$main~0" AS (
				    UPDATE public.users AS u
				    SET
				      id = 2, email = 'x@x.com', (username) = ROW (232)
				    RETURNING u.id
				  ),
				  "$main~1" AS (
				    UPDATE public.users AS users
				    SET (parent_user) = ROW (users.parent_user)
				    WHERE users.parent_user IN (
				      SELECT "$main~0".id
				      FROM "$main~0"
				    )
				    RETURNING users.parent_user
				  ),
				  "$dependency~0" AS (
				    UPDATE public.users AS users
				    SET (id) = ROW (3445)
				    WHERE users.id IN (
				      SELECT "$main~1".parent_user
				      FROM "$main~1"
				    )
				  )
				SELECT COUNT(*) AS COUNT
				FROM "$main~0"
				
      ✔ should parse a "back-back-referencing" "deep-deep" UPDATE statement (44ms)
        ∟ UpdateStmt   .parse(`
				UPDATE users AS u
				SET
				  id = 2,
				  email = 'x@x.com',
				  (username, (parent_user <~ parent_user <~ users) ~> parent_user ~> id) = (222, 3445)
				`) 
				--> UpdateStmt:
				 
				UPDATE users AS u
				SET
				  id = 2,
				  email = 'x@x.com',
				  (username, (parent_user <~ parent_user <~ users) ~> parent_user ~> id) = (222, 3445)
				 
				--> CTE:
				 
				WITH
				  "$main~0" AS (
				    UPDATE public.users AS u
				    SET
				      id = 2, email = 'x@x.com', (username) = ROW (222)
				    RETURNING u.id
				  ),
				  "$main~1" AS (
				    UPDATE public.users AS users
				    SET (parent_user) = ROW (users.parent_user)
				    FROM (
				      SELECT 
				        "$join~1:users".id AS id,
				        "$join~1:users".parent_user AS parent_user
				      FROM public.users AS "$join~1:users"
				      WHERE users.id = "$join~1:users".id
				    ) AS "$join~1:users"
				    LEFT JOIN (
				      SELECT users.id AS "$key~0", users.parent_user AS "$ref~0"
				      FROM public.users
				    ) AS "$join~0"
				      ON "$join~1:users".parent_user = "$join~0"."$key~0"
				    WHERE "$join~0"."$ref~0" IN (
				      SELECT "$main~0".id
				      FROM "$main~0"
				    )
				    RETURNING users.parent_user
				  ),
				  "$dependency~0" AS (
				    UPDATE public.users AS users
				    SET (id) = ROW (3445)
				    WHERE users.id IN (
				      SELECT "$main~1".parent_user
				      FROM "$main~1"
				    )
				  )
				SELECT COUNT(*) AS COUNT
				FROM "$main~0"
				
    UPDATE ... WHERE
      ✔ should parse a basic deep UPDATE ... WHERE statement
        ∟ UpdateStmt   .parse(`
				UPDATE users AS u
				SET
				  id = 2,
				  email = 'x@x.com',
				  (username, parent_user ~> id) = (232, 3445)
				WHERE parent_user ~> id = 2
				`) 
				--> UpdateStmt:
				 
				UPDATE users AS u
				SET
				  id = 2,
				  email = 'x@x.com',
				  (username, parent_user ~> id) = (232, 3445)
				WHERE parent_user ~> id = 2
				 
				--> CTE:
				 
				WITH
				  "$main~0" AS (
				    UPDATE public.users AS u
				    SET
				      id = 2,
				      email = 'x@x.com',
				      (username, parent_user) = ROW (232, u.parent_user)
				    FROM (
				      SELECT "$join~1:u".id AS id, "$join~1:u".parent_user AS parent_user
				      FROM public.users AS "$join~1:u"
				      WHERE u.id = "$join~1:u".id
				    ) AS "$join~1:u"
				    LEFT JOIN (
				      SELECT users.id AS "$key~0", users.id AS "$ref~0"
				      FROM public.users
				    ) AS "$join~0"
				      ON "$join~1:u".parent_user = "$join~0"."$key~0"
				    WHERE "$join~0"."$ref~0" = 2
				    RETURNING u.parent_user
				  ),
				  "$dependency~0" AS (
				    UPDATE public.users AS users
				    SET (id) = ROW (3445)
				    WHERE users.id IN (
				      SELECT "$main~0".parent_user
				      FROM "$main~0"
				    )
				  )
				SELECT COUNT(*) AS COUNT
				FROM "$main~0"
				
      ✔ should parse a "deep-deep" UPDATE ... WHERE statement (46ms)
        ∟ UpdateStmt   .parse(`
				UPDATE users AS u
				SET
				  id = 2,
				  email = 'x@x.com',
				  (username, parent_user ~> parent_user ~> id) = (232, 3445)
				WHERE parent_user ~> id = 2
				`) 
				--> UpdateStmt:
				 
				UPDATE users AS u
				SET
				  id = 2,
				  email = 'x@x.com',
				  (username, parent_user ~> parent_user ~> id) = (232, 3445)
				WHERE parent_user ~> id = 2
				 
				--> CTE:
				 
				WITH
				  "$main~0" AS (
				    UPDATE public.users AS u
				    SET
				      id = 2,
				      email = 'x@x.com',
				      (username, parent_user) = ROW (232, u.parent_user)
				    FROM (
				      SELECT "$join~1:u".id AS id, "$join~1:u".parent_user AS parent_user
				      FROM public.users AS "$join~1:u"
				      WHERE u.id = "$join~1:u".id
				    ) AS "$join~1:u"
				    LEFT JOIN (
				      SELECT users.id AS "$key~0", users.id AS "$ref~0"
				      FROM public.users
				    ) AS "$join~0"
				      ON "$join~1:u".parent_user = "$join~0"."$key~0"
				    WHERE "$join~0"."$ref~0" = 2
				    RETURNING u.parent_user
				  ),
				  "$main~1" AS (
				    UPDATE public.users AS users
				    SET (parent_user) = ROW (users.parent_user)
				    WHERE users.id IN (
				      SELECT "$main~0".parent_user
				      FROM "$main~0"
				    )
				    RETURNING users.parent_user
				  ),
				  "$dependency~1" AS (
				    UPDATE public.users AS users
				    SET (id) = ROW (3445)
				    WHERE users.id IN (
				      SELECT "$main~1".parent_user
				      FROM "$main~1"
				    )
				  )
				SELECT COUNT(*) AS COUNT
				FROM "$main~0"
				
      ✔ should parse a "back-referencing" deep UPDATE ... WHERE statement
        ∟ UpdateStmt   .parse(`
				UPDATE users AS u
				SET
				  id = 2,
				  email = 'x@x.com',
				  (username, (parent_user <~ users) ~> id) = (232, 3445)
				WHERE parent_user ~> id = 2
				`) 
				--> UpdateStmt:
				 
				UPDATE users AS u
				SET
				  id = 2,
				  email = 'x@x.com',
				  (username, (parent_user <~ users) ~> id) = (232, 3445)
				WHERE parent_user ~> id = 2
				 
				--> CTE:
				 
				WITH
				  "$main~0" AS (
				    UPDATE public.users AS u
				    SET
				      id = 2, email = 'x@x.com', (username) = ROW (232)
				    FROM (
				      SELECT "$join~1:u".id AS id, "$join~1:u".parent_user AS parent_user
				      FROM public.users AS "$join~1:u"
				      WHERE u.id = "$join~1:u".id
				    ) AS "$join~1:u"
				    LEFT JOIN (
				      SELECT users.id AS "$key~0", users.id AS "$ref~0"
				      FROM public.users
				    ) AS "$join~0"
				      ON "$join~1:u".parent_user = "$join~0"."$key~0"
				    WHERE "$join~0"."$ref~0" = 2
				    RETURNING u.id
				  ),
				  "$dependent~0" AS (
				    UPDATE public.users AS users
				    SET (id) = ROW (3445)
				    WHERE users.parent_user IN (
				      SELECT "$main~0".id
				      FROM "$main~0"
				    )
				  )
				SELECT COUNT(*) AS COUNT
				FROM "$main~0"
				
      ✔ should parse a "back-back-referencing" deep UPDATE ... WHERE statement (51ms)
        ∟ UpdateStmt   .parse(`
				UPDATE users AS u
				SET
				  id = 2,
				  email = 'x@x.com',
				  (username, (parent_user <~ users) ~> parent_user ~> id) = (232, 3445)
				WHERE parent_user ~> id = 2
				`) 
				--> UpdateStmt:
				 
				UPDATE users AS u
				SET
				  id = 2,
				  email = 'x@x.com',
				  (username, (parent_user <~ users) ~> parent_user ~> id) = (232, 3445)
				WHERE parent_user ~> id = 2
				 
				--> CTE:
				 
				WITH
				  "$main~0" AS (
				    UPDATE public.users AS u
				    SET
				      id = 2, email = 'x@x.com', (username) = ROW (232)
				    FROM (
				      SELECT "$join~1:u".id AS id, "$join~1:u".parent_user AS parent_user
				      FROM public.users AS "$join~1:u"
				      WHERE u.id = "$join~1:u".id
				    ) AS "$join~1:u"
				    LEFT JOIN (
				      SELECT users.id AS "$key~0", users.id AS "$ref~0"
				      FROM public.users
				    ) AS "$join~0"
				      ON "$join~1:u".parent_user = "$join~0"."$key~0"
				    WHERE "$join~0"."$ref~0" = 2
				    RETURNING u.id
				  ),
				  "$main~1" AS (
				    UPDATE public.users AS users
				    SET (parent_user) = ROW (users.parent_user)
				    WHERE users.parent_user IN (
				      SELECT "$main~0".id
				      FROM "$main~0"
				    )
				    RETURNING users.parent_user
				  ),
				  "$dependency~0" AS (
				    UPDATE public.users AS users
				    SET (id) = ROW (3445)
				    WHERE users.id IN (
				      SELECT "$main~1".parent_user
				      FROM "$main~1"
				    )
				  )
				SELECT COUNT(*) AS COUNT
				FROM "$main~0"
				
      ✔ should parse a "back-back-referencing" "deep-deep" UPDATE ... WHERE statement (74ms)
        ∟ UpdateStmt   .parse(`
				UPDATE users AS u
				SET
				  id = 2,
				  email = 'x@x.com',
				  (username, (parent_user <~ parent_user <~ users) ~> parent_user ~> id) = (222, 3445)
				WHERE parent_user ~> id = 2
				`) 
				--> UpdateStmt:
				 
				UPDATE users AS u
				SET
				  id = 2,
				  email = 'x@x.com',
				  (username, (parent_user <~ parent_user <~ users) ~> parent_user ~> id) = (222, 3445)
				WHERE parent_user ~> id = 2
				 
				--> CTE:
				 
				WITH
				  "$main~0" AS (
				    UPDATE public.users AS u
				    SET
				      id = 2, email = 'x@x.com', (username) = ROW (222)
				    FROM (
				      SELECT "$join~1:u".id AS id, "$join~1:u".parent_user AS parent_user
				      FROM public.users AS "$join~1:u"
				      WHERE u.id = "$join~1:u".id
				    ) AS "$join~1:u"
				    LEFT JOIN (
				      SELECT users.id AS "$key~0", users.id AS "$ref~0"
				      FROM public.users
				    ) AS "$join~0"
				      ON "$join~1:u".parent_user = "$join~0"."$key~0"
				    WHERE "$join~0"."$ref~0" = 2
				    RETURNING u.id
				  ),
				  "$main~1" AS (
				    UPDATE public.users AS users
				    SET (parent_user) = ROW (users.parent_user)
				    FROM (
				      SELECT 
				        "$join~1:users".id AS id,
				        "$join~1:users".parent_user AS parent_user
				      FROM public.users AS "$join~1:users"
				      WHERE users.id = "$join~1:users".id
				    ) AS "$join~1:users"
				    LEFT JOIN (
				      SELECT users.id AS "$key~0", users.parent_user AS "$ref~0"
				      FROM public.users
				    ) AS "$join~0"
				      ON "$join~1:users".parent_user = "$join~0"."$key~0"
				    WHERE "$join~0"."$ref~0" IN (
				      SELECT "$main~0".id
				      FROM "$main~0"
				    )
				    RETURNING users.parent_user
				  ),
				  "$dependency~0" AS (
				    UPDATE public.users AS users
				    SET (id) = ROW (3445)
				    WHERE users.id IN (
				      SELECT "$main~1".parent_user
				      FROM "$main~1"
				    )
				  )
				SELECT COUNT(*) AS COUNT
				FROM "$main~0"
				
    UPDATE ... SELECT
      ✔ should parse a basic deep UPDATE ... SELECT statement
        ∟ UpdateStmt   .parse(`
				UPDATE users AS u
				SET
				  id = 2,
				  email = 'x@x.com',
				  (username, parent_user ~> (id, username)) = (SELECT 232, (3445, 333) FROM orders)
				`) 
				--> UpdateStmt:
				 
				UPDATE users AS u
				SET
				  id = 2,
				  email = 'x@x.com',
				  (username, parent_user ~> (id, username)) = (
				    SELECT 232, (3445, 333)
				    FROM orders
				  )
				 
				--> CTE:
				 
				WITH
				  "$memo~0" AS (
				    SELECT 
				      ROW_NUMBER() OVER () AS "$row_number~a",
				      232 AS username,
				      3445 AS "$value~0",
				      333 AS "$value~1"
				    FROM public.orders
				  ),
				  "$main~0" AS (
				    UPDATE public.users AS u
				    SET
				      id = 2,
				      email = 'x@x.com',
				      (username, parent_user) = (
				        SELECT "$memo~0".username AS username, u.parent_user AS parent_user
				        FROM "$memo~0"
				      )
				    RETURNING u.parent_user
				  ),
				  "$dependency~0" AS (
				    UPDATE public.users AS users
				    SET (id, username) = (
				      SELECT 
				        "$memo~0"."$value~0" AS "$value~0",
				        "$memo~0"."$value~1" AS "$value~1"
				      FROM "$memo~0"
				    )
				    WHERE users.id IN (
				      SELECT "$main~0".parent_user
				      FROM "$main~0"
				    )
				  )
				SELECT COUNT(*) AS COUNT
				FROM "$main~0"
				
      ✔ should parse a "deep-deep" UPDATE ... SELECT statement
        ∟ UpdateStmt   .parse(`
				UPDATE users AS u
				SET
				  id = 2,
				  email = 'x@x.com',
				  (username, parent_user ~> parent_user ~> (id, username)) = (232, (SELECT 3445, 333 FROM orders))
				`) 
				--> UpdateStmt:
				 
				UPDATE users AS u
				SET
				  id = 2,
				  email = 'x@x.com',
				  (username, parent_user ~> parent_user ~> (id, username)) = (232, (
				    SELECT 3445, 333
				    FROM orders
				  ))
				 
				--> CTE:
				 
				WITH
				  "$main~0" AS (
				    UPDATE public.users AS u
				    SET
				      id = 2,
				      email = 'x@x.com',
				      (username, parent_user) = ROW (232, u.parent_user)
				    RETURNING u.parent_user
				  ),
				  "$main~1" AS (
				    UPDATE public.users AS users
				    SET (parent_user) = ROW (users.parent_user)
				    WHERE users.id IN (
				      SELECT "$main~0".parent_user
				      FROM "$main~0"
				    )
				    RETURNING users.parent_user
				  ),
				  "$dependency~1" AS (
				    UPDATE public.users AS users
				    SET (id, username) = (
				      SELECT 3445, 333
				      FROM public.orders
				    )
				    WHERE users.id IN (
				      SELECT "$main~1".parent_user
				      FROM "$main~1"
				    )
				  )
				SELECT COUNT(*) AS COUNT
				FROM "$main~0"
				
      ✔ should parse a "back-back-referencing" "deep-deep" UPDATE ... SELECT statement
        ∟ UpdateStmt   .parse(`
				UPDATE users AS u
				SET
				  id = 2,
				  email = 'x@x.com',
				  (username, parent_user ~> parent_user ~> (id, username)) = (232, (SELECT 3445, 333 FROM orders))
				`) 
				--> UpdateStmt:
				 
				UPDATE users AS u
				SET
				  id = 2,
				  email = 'x@x.com',
				  (username, parent_user ~> parent_user ~> (id, username)) = (232, (
				    SELECT 3445, 333
				    FROM orders
				  ))
				 
				--> CTE:
				 
				WITH
				  "$main~0" AS (
				    UPDATE public.users AS u
				    SET
				      id = 2,
				      email = 'x@x.com',
				      (username, parent_user) = ROW (232, u.parent_user)
				    RETURNING u.parent_user
				  ),
				  "$main~1" AS (
				    UPDATE public.users AS users
				    SET (parent_user) = ROW (users.parent_user)
				    WHERE users.id IN (
				      SELECT "$main~0".parent_user
				      FROM "$main~0"
				    )
				    RETURNING users.parent_user
				  ),
				  "$dependency~1" AS (
				    UPDATE public.users AS users
				    SET (id, username) = (
				      SELECT 3445, 333
				      FROM public.orders
				    )
				    WHERE users.id IN (
				      SELECT "$main~1".parent_user
				      FROM "$main~1"
				    )
				  )
				SELECT COUNT(*) AS COUNT
				FROM "$main~0"
				


  67 passing (2s)

